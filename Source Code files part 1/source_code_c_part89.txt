oadSpec,"noload"))) {
            DriverId = SlGetKeyName(Inf,LoadSectionName,i);
            
#ifdef UNICODE
            DriverDescription = SlGetIniValueW(
                                        Inf, 
                                        SectionName, 
                                        DriverId, 
                                        SlCopyStringAW(DriverId));
#else
            DriverDescription = SlGetIniValue(
                                        Inf, 
                                        SectionName, 
                                        DriverId, 
                                        DriverId);
#endif                                        

            Status = SlLoadDriver(DriverDescription,
                                  DriverFilename,
                                  0,
                                  TRUE,
                                  FALSE,
                                  NULL
                                  );

//            if((Status == ENOENT) && IgnoreMissingFiles) {
//                Status = ESUCCESS;
//            }

            if (Status == ESUCCESS) {
                if( DetectedDeviceList != NULL ) {
                    //
                    // if the enumerator loaded, then record DETECTED_DEVICE info
                    //
                    TempDevice = BlAllocateHeap(sizeof(DETECTED_DEVICE));
                    
                    if(!TempDevice) {
                        SlNoMemoryError();

                        return ENOMEM;
                    }
                    
                    TempDevice->IdString = SlCopyStringA(DriverId);
                    TempDevice->Description = DriverDescription;
                    TempDevice->ThirdPartyOptionSelected = FALSE;
                    TempDevice->MigratedDriver = FALSE;
                    TempDevice->FileTypeBits = 0;
                    TempDevice->BaseDllName = SlCopyStringA(DriverFilename);
                    TempDevice->Next = *DetectedDeviceList;
                    *DetectedDeviceList = TempDevice;
                }
            } else {
                SlFriendlyError(
                    Status,
                    DriverFilename,
                    __LINE__,
                    __FILE__
                    );
                return(Status);
            }
        }
        i++;

    } while ( DriverFilename != NULL );

    return(ESUCCESS);
}


ARC_STATUS
SlDetectMigratedScsiDrivers(
    IN PVOID Inf
    )

/*++

Routine Description:

    Create an entry in the ScsiDevice list for each migrated SCSI driver.

Arguments:

    Inf - Supplies a handle to the INF file.

Return Value:

    ESUCCESS if all drivers were added to the ScsiDevice list.

--*/

{
    ULONG i;
    CHAR LoadSectionName[100];
    PCHAR DriverFilename;
    PCHAR DriverId;
    PTCHAR DriverDescription;
    PDETECTED_DEVICE ScsiDevice;
    SCSI_INSERT_STATUS sis;

    i=0;
    do {
        DriverId = SlGetSectionLineIndex(Inf,"Devices",i,0);
        if( DriverId ) {
            sprintf(LoadSectionName, "Files.%s", DriverId);

            DriverFilename = SlGetSectionLineIndex(Inf,LoadSectionName,0,0);
            if(DriverFilename) {

                //
                // Remove inbox drivers with the same name as a winnt32-migrated OEM driver (if any)
                //
                SlRemoveInboxDriver (DriverFilename);

                //
                // Create a new detected device entry.
                //
                if((sis = SlInsertScsiDevice(SL_OEM_DEVICE_ORDINAL, &ScsiDevice)) == ScsiInsertError) {
                    return(ENOMEM);
                }

                if(sis == ScsiInsertExisting) {
#if DBG
                    //
                    // Sanity check to make sure we're talking about the same driver
                    //
                    if(_stricmp(ScsiDevice->BaseDllName, DriverFilename)) {
                        SlError(400);
                        return EINVAL;
                    }
#endif
                } else {
                    DriverDescription = SlCopyString(BlFindMessage(SL_TEXT_SCSI_UNNAMED));

                    ScsiDevice->IdString = DriverId;
                    ScsiDevice->Description = DriverDescription;
                    ScsiDevice->ThirdPartyOptionSelected = FALSE;
                    ScsiDevice->MigratedDriver = TRUE;
                    ScsiDevice->FileTypeBits = 0;
                    ScsiDevice->Files = NULL;
                    ScsiDevice->BaseDllName = DriverFilename;
                }
            }
        }
        i++;

    } while ( DriverId != NULL );

    return(ESUCCESS);
}



ARC_STATUS
SlGetMigratedHardwareIds(
    IN PSETUP_LOADER_BLOCK SetupBlock,
    IN PVOID               Inf
    )

/*++

Routine Description:

    Add the hardware ids for the migrated scsi drivers, to the hardware id list.

Arguments:

    SetupBlock - Supplies a pointer to the Setup loader block

Return Value:

    ESUCCESS if all hardware ids were added to the hardware id list

--*/

{

    PCHAR DriverId;
    ULONG i, j;
    PPNP_HARDWARE_ID TempHardwareId;
    PCHAR   p;

    for( j = 0;
         (DriverId = SlGetSectionLineIndex(Inf,"Devices",j,0)) != NULL;
         j++ ) {
        CHAR  SectionName[100];

        sprintf(SectionName, "HardwareIds.%s", DriverId);
        for( i = 0;
             ((p = SlGetKeyName( Inf, SectionName, i )) != NULL);
             i++ ) {
            TempHardwareId = BlAllocateHeap(sizeof(PNP_HARDWARE_ID));

            if (TempHardwareId==NULL) {
                SlNoMemoryError();

                return ENOMEM;
            }
            
            TempHardwareId->Id = p;
            p = SlGetSectionKeyIndex( Inf,
                                      SectionName,
                                      TempHardwareId->Id,
                                      0 );
            TempHardwareId->DriverName = p;
            p = SlGetSectionKeyIndex( Inf,
                                      SectionName,
                                      TempHardwareId->Id,
                                      1 );
            TempHardwareId->ClassGuid = p;

            TempHardwareId->Next = SetupBlock->HardwareIdDatabase;
            SetupBlock->HardwareIdDatabase = TempHardwareId;
        }
    }
    return( ESUCCESS );
}


BOOLEAN
SlIsCdBootUpgrade(
    IN  PCHAR   InstallDirectory,
    IN  PCHAR   SetupFileName,
    IN  ULONG   MaxDisksToScan,
    IN  ULONG   MaxPartitionsPerDisk,
    OUT PCHAR   NewSetupDevice
    )
/*++

Routine Description:

    Finds out by looking into the hard disk if the specified
    directory exists and if the the user was indeed
    trying to uprgade

Arguments:

    InstallDirectory - Directory used on the hard disk
                       for installation

    SetupFileName    - Inf file name which has the key which
                       indicates if upgrade was in progress or
                       not

    MaxDisksToScan   - Maximum number of disks to scan

    MaxPartitionsPerDisk - Maximum partitions per disk to look into
                           for the install directory.

    NewSetupDevice - Place holder for arc name for the device 
                     if user wants to switch to harddisk boot.
                       

Return Value:

    TRUE if upgrade was in progress and user selected to continue on
    otherwise FALSE.

--*/
{
    BOOLEAN     Result = FALSE;    
    CHAR        DeviceName[128];
    ARC_STATUS  Status;
    ULONG       CurrentPartition;
    ULONG       CurrentDisk;

    //
    // Go through each disk 
    //
    for (CurrentDisk = 0; 
        (!Result && (CurrentDisk < MaxDisksToScan)); 
        CurrentDisk++) {

        Status = ESUCCESS;

        //
        // Go through each valid partition
        // for the current disk
        //
        for (CurrentPartition = 1; 
            (!Result && (Status == ESUCCESS));
            CurrentPartition++) {
            
            ULONG   DiskId;
            
            sprintf(DeviceName, 
                "multi(0)disk(0)rdisk(%d)partition(%d)",
                CurrentDisk,
                CurrentPartition);

            Status = ArcOpen(DeviceName, ArcOpenReadOnly, &DiskId);

            if (Status == ESUCCESS) {
                CHAR    FullName[128];
                PVOID   SifHandle = NULL;
                ULONG   ErrorLine = 0;
                ARC_STATUS  FileStatus;

                //
                // Function does not support the return of failures.
                // so lets just truncate the string
                //
                _snprintf(FullName,
                          sizeof(FullName),
                          "%s\\%s",
                          InstallDirectory,
                          SetupFileName);
                FullName[sizeof(FullName) - 1] = '\0';

                FileStatus = SlInitIniFile(NULL,
                                       DiskId,
                                       FullName,
                                       &SifHandle,
                                       NULL,
                                       NULL,
                                       &ErrorLine);

                if ((FileStatus == ESUCCESS) && SifHandle) {
                    Result = SlIsUpgrade(SifHandle);
                }

                ArcClose(DiskId);
            } else {            
                //
                // Ignore the error till the maximum number of
                // partitions are searched for
                //
                if (CurrentPartition < MaxPartitionsPerDisk) {
                    Status = ESUCCESS;
                }                    
            }
        }                
    }        

    if (Result) {
        ULONG   UserInput;
        BOOLEAN OldStatus = SlGetStatusBarStatus();

        //
        // Reset the result based on user input
        //
        Result = FALSE;

        SlEnableStatusBar(FALSE);        
        SlClearClientArea();
        SlDisplayMessageBox(SL_UPGRADE_IN_PROGRESS);

#ifdef EFI
        // 
        // disable watchdog timer for user input
        //
        DisableEFIWatchDog();
#endif

        do {            
            SlFlushConsoleBuffer();
            UserInput = SlGetChar();
        } 
        while ((UserInput != ASCI_CR) && 
               (UserInput != SL_KEY_F3) &&
               (UserInput != SL_KEY_F10));
#ifdef EFI
        // 
        // reset watchdog timer
        //
        SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif

        SlClearClientArea();    
               
        if (UserInput == SL_KEY_F3) {
            ArcRestart();
        } else if (UserInput == ASCI_CR) {
            Result = TRUE;
            strcpy(NewSetupDevice, DeviceName);
        }

        SlEnableStatusBar(OldStatus);
    }                
    
    return Result;
}


BOOLEAN
SlIsUpgrade(
    IN PVOID SifHandle
    )
/*++

Routine Description:

    Finds out by looking into the SIF file if upgrade is
    in progress or not

Arguments:

    InfHandle - Handle to winnt.sif file

Return Value:

    TRUE if upgrade  is in progress otherwise FALSE

--*/
{
    BOOLEAN Result = FALSE;

    if (SifHandle) {
        PCHAR   NtUpgrade = SlGetSectionKeyIndex(SifHandle,
                                WINNT_DATA_A,
                                WINNT_D_NTUPGRADE_A,
                                0);

        if (NtUpgrade) {
            Result = (BOOLEAN) (_stricmp(NtUpgrade, WINNT_A_YES_A) == 0);
        }

        if (!Result) {
            PCHAR   Win9xUpgrade = SlGetSectionKeyIndex(SifHandle,
                                        WINNT_DATA_A,
                                        WINNT_D_WIN95UPGRADE_A,
                                        0);


            if (Win9xUpgrade) {
                Result = (BOOLEAN) (_stricmp(Win9xUpgrade, WINNT_A_YES_A) == 0);
            }
        }
    }

    return Result;
}

BOOLEAN
SlIsVirtualOemDeviceDisabled(
    IN      PVOID SifHandle, 
    IN      PPREINSTALL_DRIVER_INFO PreinstallDriverList
    )
/*++
Routine Description:

    Finds out if we need to enable or disable the loading of virtual OEM devices.
    
Arguments:

    InfHandle - Handle to winnt.sif file

    PreinstallDriverList - PreInstall Driver List

Return Value:
    BOOLEAN, TRUE/FALSE
--*/
{
                                          

    if((!DisableVirtualOemDevices) && (SifHandle)){
        //
        // Is Preinstall?
        //
        if (PreinstallDriverList != NULL){
            DisableVirtualOemDevices = TRUE;
        }else{
            PCHAR p;
            p = SlGetSectionKeyIndex(SifHandle,
                                     WINNT_UNATTENDED_A,
                                     WINNT_DISABLE_VIRTUAL_OEM_DEVICES_A,
                                     0);

            //
            // In case of unattended setup.
            // if we have set the option in the unattend file DisableVirtualOemDevices = yes
            // then disable the virtual oem source devices
            //
            if(p && (!_stricmp(p ,WINNT_A_YES_A))) {
                DisableVirtualOemDevices = TRUE;
            }
            
        }
    }
    
     return DisableVirtualOemDevices;
 }

VOID
SlDisableVirtualOemDevices(
    IN      POEM_SOURCE_DEVICE OemDeviceList
    )
/*++
Routine Description:

    Marks the Virtual Oem Devices as Skipped.
    
Arguments:

    OemDeviceList - The list of OEM devices

Return Value:
    None.
--*/
{
    //
    // If the DisableVirtualOemDevices is set to TRUE mark the Virtual OEM devices
    // as skipped.
    //
    if ((DisableVirtualOemDevices) && (OemDeviceList)){
        POEM_SOURCE_DEVICE CurrentDevice = OemDeviceList;
            
        while (CurrentDevice) {
            //
            // If this is an OEM source device marked virtual then mark it as skipped.
            // 
            if(SL_OEM_SOURCE_DEVICE_TYPE(CurrentDevice,
                                         SL_OEM_SOURCE_DEVICE_TYPE_VIRTUAL)){

                SL_OEM_SET_SOURCE_DEVICE_STATE( CurrentDevice,
                                                SL_OEM_SOURCE_DEVICE_SKIPPED);
            }
            CurrentDevice = CurrentDevice->Next;           
        }
     }
 }

BOOLEAN
SlpIsDynamicUpdate(
    IN  PVOID   InfHandle,
    OUT PCSTR   *DynamicUpdateRootDir
    )
/*++

Routine Description:

    Finds out whether there are any dynamic update boot drivers
    to process or not.

Arguments:

    InfHandle - Handle to winnt.sif file

    DynamicUpdateRootDir - Receives the root directory under which all
        the dynamic update boot driver packages are present.

Return Value:

    TRUE, if there are dynamic update boot drivers otherwise
    FALSE

--*/
{
    BOOLEAN Result = FALSE;

    if (InfHandle) {
        PCHAR   DynUpdateKey = SlGetSectionKeyIndex(InfHandle,
                                        WINNT_SETUPPARAMS_A,
                                        WINNT_SP_DYNUPDTBOOTDRIVERPRESENT_A,
                                        0);

        PCHAR   DynUpdateRoot = SlGetSectionKeyIndex(InfHandle,
                                        WINNT_SETUPPARAMS_A,
                                        WINNT_SP_DYNUPDTBOOTDRIVERROOT_A,
                                        0);

        //
        // DynamicUpdateBootDriverPresent and DynamicUpateBootDriverRoot
        // should have valid values
        //
        Result = (BOOLEAN) (DynUpdateKey && DynUpdateRoot &&
                            !_stricmp(DynUpdateKey, "yes"));

        if (Result && DynamicUpdateRootDir) {
            *DynamicUpdateRootDir = SlCopyStringA(DynUpdateRoot);
        }
    }

    return Result;
}

UCHAR
SlGetDefaultAttr(
  VOID
  )
{
  return (UCHAR)((UseRegularBackground) ? (ATT_FG_WHITE | ATT_BG_BLACK) : (ATT_FG_WHITE | ATT_BG_BLUE));
}

UCHAR
SlGetDefaultInvAttr(
  VOID
  )
{
  return (UCHAR)((UseRegularBackground) ? (ATT_FG_BLACK | ATT_BG_WHITE) : (ATT_FG_BLUE | ATT_BG_WHITE));
}

#ifdef _IA64_

BOOLEAN
SlIsWinPEAutoBoot(
    IN PSTR LoaderDeviceName
    )
/*++

Routine Description:

    Determines if this is an automated WinPE boot.

    NOTE : Automated WinPE boot is determined by the presence
    of the $WINPE$.$$$ file at the same location where
    setupldr.efi was started from.

Arguments:

    LoaderDeviceName : Arcname of the device where setupldr
        was started from.

Return Value:

    TRUE if this is WinPE auto boot, otherwise FALSE.

--*/
{
    BOOLEAN Result = FALSE;
    
    if (LoaderDeviceName) {
        ULONG   DiskId;
        ARC_STATUS Status;
        
        //
        // open the partition
        //
        Status = ArcOpen(LoaderDeviceName, ArcOpenReadOnly, &DiskId);

        if (Status == ESUCCESS) {
            CHAR        FileName[128];
            ARC_STATUS  FileStatus;
            ULONG       FileId;

            //
            // check for the existence of \$WINPE$.$$$
            //
            strcpy(FileName, "\\");
            strcat(FileName, WINPE_AUTOBOOT_FILENAME);
            
            FileStatus = BlOpen(DiskId, FileName, ArcOpenReadOnly, &FileId);

            if (FileStatus == ESUCCESS) {
                BlClose(FileId);
                Result = TRUE; 
            }

            ArcClose(DiskId);                    
        }                            
    }

    return Result;
}

ARC_STATUS
SlGetWinPEStartupParams(
    IN OUT PSTR StartupDeviceName,
    IN OUT PSTR StartupDirectory
    )
/*++

Routine Description:

    Searches for the WinPE installation on the available
    partitions on the first 4 disks. 
    
Arguments:

    StartupDeviceName - place holder for receiving device name 
        where WinPE installation was found.

    StartupDirectory - place holder for receiving WinPE installation
        directory.
            
Return Value:

    Appropriate ARC_STATUS error code.    

--*/
{
    ARC_STATUS Status = EINVAL;

    //
    // validate arguments
    //
    if (StartupDeviceName && StartupDirectory) {
        BOOLEAN     Found = FALSE;    
        CHAR        DeviceName[128];
        ULONG       CurrentPartition;
        ULONG       CurrentDisk;

        //
        // Go through each disk (at the max 4)
        //
        for (CurrentDisk = 0; 
            (!Found && (CurrentDisk < 4)); 
            CurrentDisk++) {
            
            //
            // Go through each valid partition
            // for the current disk
            //
            for (CurrentPartition = 1, Status = ESUCCESS; 
                (!Found && (Status == ESUCCESS));
                CurrentPartition++) {
                
                ULONG   DiskId;
                
                sprintf(DeviceName, 
                    "multi(0)disk(0)rdisk(%d)partition(%d)",
                    CurrentDisk,
                    CurrentPartition);

                //
                // open the disk
                //
                Status = ArcOpen(DeviceName, ArcOpenReadOnly, &DiskId);

                if (Status == ESUCCESS) {
                    CHAR        FullName[128];
                    ARC_STATUS  FileStatus;
                    ULONG       DirId;

                    //
                    // check for the existence of \\winpe\\ia64\\system32 directory
                    //
                    strcpy(FullName, "\\WINPE\\ia64\\system32");

                    FileStatus = BlOpen(DiskId, FullName, ArcOpenDirectory, &DirId);

                    if (FileStatus == ESUCCESS) {
                        BlClose(DirId);
                        Found = TRUE; 
                    }

                    ArcClose(DiskId);                    
                }                    
            }                
        }            

        //
        // update return arguments
        //
        if (Found && (ESUCCESS == Status)) {
            strcpy(StartupDeviceName, DeviceName);
            strcpy(StartupDirectory, "\\WINPE\\ia64\\");
        }

        if (!Found) {
            Status = EBADF;
        }
    }            

    return Status;
}

#endif // _IA64_

    
#ifdef _X86_

ARC_STATUS
SlLoadBootFontFile(
    IN PSETUP_LOADER_BLOCK SetupLoaderBlock,
    IN ULONG DiskId,
    IN ULONG BootFontImageLength
    )
/*++

Routine Description:

    Loads the bootfont.bin into memory and initializes
    relevant fields in setup loader block.
    
Arguments:

    SetupLoaderBlock - pointer to setup loader block.

    DiskId - Disk ID where bootfont.bin resides on the root

    BootFontImageLength - The length of the bootfont.bin file.
            
Return Value:

    Appropriate ARC_STATUS error code.    

--*/
{
    ARC_STATUS Status = EINVAL;

    //
    // verify arguments
    //
    if (SetupLoaderBlock && BootFontImageLength) {
        ULONG FileId;
        PVOID Image = NULL;

        //
        // open the bootfont.bin file
        //
        if (BlBootingFromNet
#if defined(REMOTE_BOOT)
            && NetworkBootRom
#endif // defined(REMOTE_BOOT)
            ) {
            CHAR Buffer[129];
        
            strcpy(Buffer, NetBootPath);
            strcat(Buffer, "BOOTFONT.BIN");
            
            Status = BlOpen(DiskId, 
                        Buffer, 
                        ArcOpenReadOnly, 
                        &FileId);                    
        } else {
            Status = BlOpen(DiskId,
                        "\\BOOTFONT.BIN",
                        ArcOpenReadOnly,
                        &FileId);
        }

        //
        // allocate memory and read the contents of the file
        // into memory
        //
        if (ESUCCESS == Status) {        
            Image = BlAllocateHeap(BootFontImageLength);

            if (Image) {
                ULONG BytesRead = 0;
                
                Status = BlRead(FileId, Image, BootFontImageLength, &BytesRead);

                if ((ESUCCESS == Status) && (BytesRead != BootFontImageLength)) {
                    Status = EIO;
                }                    
            } else {
                Status = ENOMEM;
            }

            BlClose(FileId);
        }  

        if (Image && (ESUCCESS == Status)) {
            SetupLoaderBlock->BootFontFile = Image;
            SetupLoaderBlock->BootFontFileLength = BootFontImageLength;
        }
    }

    return Status;
}

#endif

BOOLEAN
SlGetNextOption(
    IN OUT PCSTR* Options,
    IN OUT ULONG_PTR* Length
    )
/*++

Routine Description:

    Scans and returns the next load option in the input string. Scanning stops at the
    end of the string or at the first empty option (should not happen).
    
Arguments:

    Options -   On input, holds the pointer to the current load option, not including the starting slash.
                On output, contains the start of the next load option, not including the starting slash.
                Options cannot be NULL, but *Options can.

    Length -    On input, contains the length of the current load option (pointed to by *Options), not inlcuding
                the starting slash.
                On output, holds the length of the next load option (pointed to by the new *Options), not
                including the starting slash.
                Cannot be NULL.

                Note: to get the first load option in the string, *Options must point to the start of the
                string (before or at the first slash) and *Length must be zero.
            
Return Value:

    TRUE if there is a non-empty load option retured in *Options; FALSE if no subsequent options in the string
    or if the next option is empty (e.g. '//' - shouldn't happen).

--*/
{
    BOOLEAN bFound = FALSE;

    if(*Options != NULL) {
        *Options = strchr(*Options + *Length, '/');

        if(*Options != NULL) {
            PCSTR szEnd = strchr(++(*Options), '/');

            if(NULL == szEnd) {
                szEnd = *Options + strlen(*Options);
            }

            while(szEnd != *Options && ' ' == szEnd[-1]) {
                --szEnd;
            }

            *Length = szEnd - *Options;
            bFound = (BOOLEAN) (*Length != 0);
        }
    }

    return bFound;
}

BOOLEAN
SlModifyOsLoadOptions(
    IN OUT PSTR* LoadOptions,
    IN PCSTR OptionsToAdd OPTIONAL,
    IN PCSTR OptionsToRemove OPTIONAL
    )
/*++

Routine Description:

    Modifies the string containing the load options by adding and/or removing options to/from the string.
    First, the options to remove are removed from the options string, and then the options to add are added.
    This function does not check if OptionsToAdd and OptionsToRemove have common options; if this happens,
    those options will be removed and then added back.
    
Arguments:

    LoadOptions -       On input, holds the pointer to the current load options string, which must be allocated on the heap.
                        On output, holds the new options string (if modified), also allocated on the heap (can be empty).

    OptionsToAdd -      Contains the string of options to add to the *LoadOptions string. All options must be
                        preceded by a slash. Can be NULL or empty.

    OptionsToRemove -   Contains the string of options to remove from the *LoadOptions string. All options must be
                        preceded by a slash. Can be NULL or empty.
            
Return Value:

    TRUE if the *LoadOptions string was modified and thus reallocated; FALSE if *LoadOptions was left alone.

--*/
{
    BOOLEAN bChanged = FALSE;
    PSTR szOption = *LoadOptions;
    ULONG_PTR Length = 0;
    PCSTR szSearch;
    ULONG_PTR Length2;
    ULONG_PTR TotalLength = 0;
    ULONG_PTR Count = 0;
    ULONG_PTR i;

    static struct {
        PCSTR szOption;
        ULONG_PTR Length;
    } Options[50];

    const ULONG_PTR MaxOptions = sizeof(Options) / sizeof(Options[0]);

    while(Count < MaxOptions && SlGetNextOption(&szOption, &Length)) {
        BOOLEAN bRemove = FALSE;
        szSearch = OptionsToRemove;
        Length2 = 0;

        while(SlGetNextOption(&szSearch, &Length2)) {
            if(Length == Length2 && 0 == _strnicmp(szOption, szSearch, Length)) {
                //
                // Need to remove this option
                //
                bChanged = bRemove = TRUE;
                break;
            }
        }

        if(!bRemove) {
            //
            // Add the option to the list. We'll prepend '/' and append a space so we'll need 2 extra chars.
            // The space will become the terminator for the last option.
            //
            Options[Count].szOption = szOption;
            Options[Count].Length = Length;
            TotalLength += Options[Count].Length + 2;
            ++Count;
        }
    }

    //
    // Add the new options if they are not already present
    //
    szSearch = OptionsToAdd;
    Length2 = 0;

    while(Count < MaxOptions && SlGetNextOption(&szSearch, &Length2)) {
        BOOLEAN bAdd = TRUE;

        for(i = 0; i < Count; ++i) {
            if(Options[i].Length == Length2 && 0 == _strnicmp(Options[i].szOption, szSearch, Length2)) {
                bAdd = FALSE;
                break;
            }
        }

        if(bAdd) {
            Options[Count].szOption = szSearch;
            Options[Count].Length = Length2;
            TotalLength += Options[Count].Length + 2;
            ++Count;
            bChanged = TRUE;
        }
    }

    if(bChanged) {
        //
        // Need to create a new options string
        //
        PSTR szNewOptions;

        if(0 == Count) {
            //
            // We'll allocate an empty string
            //
            TotalLength = 1;
        }

        ASSERT(TotalLength != 0);
        szNewOptions = (LPSTR) BlAllocateHeap((ULONG) TotalLength);

        if(NULL == szNewOptions) {
            SlNoMemoryError();
        } else {
            szNewOptions[0] = 0;

            if(Count != 0) {
                szOption = szNewOptions;

                for(i = 0; i < Count; ++i) {
                    *szOption++ = '/';
                    RtlCopyMemory(szOption, Options[i].szOption, Options[i].Length);
                    szOption += Options[i].Length;
                    *szOption++ = ' ';
                }

                szOption[-1] = 0;
            }
        }

        *LoadOptions = szNewOptions;
    }

    return bChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\oemdisk.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    oemdisk.c

Abstract:

    Provides routines for handling OEM disks for video, SCSI miniport, and HAL.

    Currently used only on ARC machines.

Author:

    John Vert (jvert) 4-Dec-1993

Revision History:

    John Vert (jvert) 4-Dec-1993
        created

    Mandar Gokhale (mandarg) 12-July-2002
        1.  Added functionality to load multiple drivers from an OEM source device
            using single txtsetup.oem file. (Adding DriverLoadList key to the [Defaults] 
            section.

        2.  Re-factoring of SlLoadOemScsiDriversFromOemSources(..).


--*/
#include <setupbat.h>
#include "setupldr.h"
#include "stdio.h"
#include <ctype.h>

#ifdef i386
#include <bldrx86.h>
#endif

#if DBG

#define DIAGOUT(x) SlPrint x

#else

#define DIAGOUT(x)

#endif

#if defined(EFI)
#include "bootefi.h"
#endif

BOOLEAN PromptOemHal=FALSE;
BOOLEAN PromptOemScsi=FALSE;
BOOLEAN PromptOemVideo=FALSE;
PVOID PreInstallOemInfHandle = NULL;

//
// Floppy disks which need to be treated as
// as virtual floppies
//
const static ULONG VirtualFloppyStart = 1;
const static ULONG MinimumFloppiesToScan = 2;   


#ifdef ARCI386
BOOLEAN PromptOemKeyboard=FALSE;
#endif

PCHAR FloppyDiskPath;
ULONG FloppyNumber=0;
ULONG IsSuperFloppy=0;

extern PCHAR BootPath;
extern PCHAR BootDevice;
extern ULONG BootDeviceId;
extern PVOID InfFile;

typedef struct _MENU_ITEM_DATA {
    PVOID InfFile;
    PCHAR SectionName;
    ULONG Index;
    PTCHAR Description;
    PCHAR Identifier;
} MENU_ITEM_DATA, *PMENU_ITEM_DATA;

typedef enum _OEMFILETYPE {
    OEMSCSI,
    OEMHAL,
    OEMOTHER
    } OEMFILETYPE, *POEMFILETYPE;

//
// Define how many lines of SCSI adapters we can list.
//
#define MAX_SCSI_MINIPORT_COUNT 4

//
// private function prototypes
//
ULONG
SlpAddSectionToMenu(
    IN PVOID    InfHandle,
    IN PCHAR    SectionName,
    IN PSL_MENU Menu
    );

BOOLEAN
SlpOemDiskette(
    IN POEM_SOURCE_DEVICE OemSourceDevice,
    IN PCHAR              ComponentName,
    IN OEMFILETYPE        ComponentType,
    IN TYPE_OF_MEMORY     MemoryType,
    IN ULONG              MenuHeaderId,
    OUT PDETECTED_DEVICE  DetectedDevice,
    OUT PVOID *           ImageBase,
    OUT OPTIONAL PCHAR *  ImageName,
    OUT OPTIONAL PTCHAR * DriverDescription,
    IN BOOLEAN            AllowUserSelection,
    IN PTCHAR             PreInstallComponentDescription,
    OUT PPNP_HARDWARE_ID* HardwareIdDatabase,
    IN PCHAR DriverDir,
    IN BOOLEAN InsertDevice,
    IN OPTIONAL PCSTR DriverIdString
    );

BOOLEAN
SlpSelectHardware(
    IN POEM_SOURCE_DEVICE SourceDevice,
    IN PCHAR             ComponentName,
    IN OEMFILETYPE        ComponentType,
    IN TYPE_OF_MEMORY     MemoryType,
    IN ULONG              MenuHeaderId,
    IN ULONG              OemMenuHeaderId,
    OUT PDETECTED_DEVICE  DetectedDevice,
    OUT PVOID *           ImageBase,
    OUT OPTIONAL PCHAR *  ImageName,
    OUT OPTIONAL PTCHAR * DriverDescription,
    IN BOOLEAN            AllowUserSelection,
    IN PTCHAR             PreInstallComponentDescription,
    IN BOOLEAN            PreInstallOemComponent,
    OUT PPNP_HARDWARE_ID* HardwareIdDatabase
    );

BOOLEAN
SlpOemInfSelection(
    IN  POEM_SOURCE_DEVICE OemSourceDevice,
    IN  PVOID   OemInfHandle,
    IN  PCHAR   ComponentName,
    IN  PCHAR   SelectedId,
    IN  PTCHAR  ItemDescription,
    OUT PDETECTED_DEVICE    Device,
    OUT PPNP_HARDWARE_ID*   HardwareIdDatabase,
    IN  PCHAR   DriverDir
    );

VOID
SlpInitDetectedDevice(
    IN PDETECTED_DEVICE Device,
    IN PCHAR            IdString,
    IN PTCHAR           Description,
    IN BOOLEAN          ThirdPartyOptionSelected
    );

PDETECTED_DEVICE_REGISTRY
SlpInterpretOemRegistryData(
    IN PVOID            InfHandle,
    IN PCHAR            SectionName,
    IN ULONG            Line,
    IN HwRegistryType   ValueType
    );

BOOLEAN
FoundFloppyDiskCallback(
    IN PCONFIGURATION_COMPONENT_DATA Component
    );

BOOLEAN
SuperFloppyCallback(
    IN PCONFIGURATION_COMPONENT_DATA Component
    );

int
SlpFindStringInTable(
    IN PCHAR String,
    IN PCHAR *StringTable
    );

//
// FileTypeNames -- keep in sync with HwFileType enum!
//
PCHAR FileTypeNames[HwFileMax] = { "driver", "port"  , "class", "inf",
                                   "dll"   , "detect", "hal", "catalog"
                                 };

//
// RegistryTypeNames -- keep in sync with HwRegistryType enum!
//
PCHAR RegistryTypeNames[HwRegistryMax] = { "REG_DWORD", "REG_BINARY", "REG_SZ",
                                           "REG_EXPAND_SZ", "REG_MULTI_SZ"
                                         };

ULONG RegistryTypeMap[HwRegistryMax] = { REG_DWORD, REG_BINARY, REG_SZ,
                                         REG_EXPAND_SZ, REG_MULTI_SZ
                                       };

//
// global scratch buffer for work
//                                        
UCHAR ScratchBuffer[256];



VOID
SlPromptOemScsi(
    IN POEM_SOURCE_DEVICE ScsiSourceDevice,
    IN BOOLEAN AllowUserSelection,        
    OUT POEMSCSIINFO *pOemScsiInfo
    )
/*++

Routine Description:

    Provides the user interface and logic for allowing the user to manually select
    SCSI adapters from the main INF file or the INF file on an OEM driver disk.

Arguments:

    ScsiSourceDevice - The OEM_SOURCE_DEVICE from which the the drivers need to 
        be loaded.
        
    AllowUserSelection - Whether user can interact while selecting the driver
        from txtsetup.oem driver list.

    pOemScsiInfo - Returns a linked list containing info about any third-party scsi
                   drivers selected.

Return Value:

    none.

--*/

{
    PVOID        OemScsiBase;
    PTCHAR       MessageString, ScsiDescription, MnemonicText;
    PCHAR        OemScsiName;
    BOOLEAN      Success, bFirstTime = TRUE, bRepaint;
    ULONG        x, y1, y2, ScsiDriverCount, NumToSkip;
    ULONG        c;
    TCHAR         Mnemonic;
    POEMSCSIINFO NewOemScsi, CurOemScsi;
    PDETECTED_DEVICE ScsiDevice;
    ULONG        OemScsiDriverCount = 0;
    PPREINSTALL_DRIVER_INFO CurrentDriver;
                         
    CurrentDriver = PreinstallDriverList;

    *pOemScsiInfo = CurOemScsi = NULL;

    MnemonicText = BlFindMessage(SL_SCSI_SELECT_MNEMONIC);
    Mnemonic = (TCHAR)_totupper(MnemonicText[0]);

    bRepaint = TRUE;
    Success = FALSE;
    
    while(1) {
#ifdef EFI
        //  
        // disable efi watchdog
        //
        DisableEFIWatchDog();
#endif

        if( AllowUserSelection ) {
            if(bRepaint) {
                
                SlClearClientArea();

                if(bFirstTime) {
                    MessageString = BlFindMessage(SL_SCSI_SELECT_MESSAGE_1);
                } else if(Success) {
                    MessageString = BlFindMessage(SL_SCSI_SELECT_MESSAGE_3);
                } else {
                    MessageString = BlFindMessage(SL_SCSI_SELECT_ERROR);
                }
                x = 1;
                y1 = 4;
                SlGenericMessageBox(0, NULL, MessageString, &x, &y1, &y2, FALSE);
                y1 = y2 + 1;
                x = 4;

                //
                // Count all currently 'detected' SCSI devices.
                //
                for(ScsiDriverCount = 0, OemScsiDriverCount = 0, ScsiDevice = BlLoaderBlock->SetupLoaderBlock->ScsiDevices;
                    ScsiDevice;
                    ScsiDevice = ScsiDevice->Next) {
                    ScsiDriverCount++;
                    if( ScsiDevice->ThirdPartyOptionSelected ) {
                        OemScsiDriverCount++;
                    }
                }

                //
                // Display each loaded OEM miniport driver description.
                //
                if(OemScsiDriverCount) {

                    if(OemScsiDriverCount > MAX_SCSI_MINIPORT_COUNT) {
                        NumToSkip = ScsiDriverCount - (OemScsiDriverCount - MAX_SCSI_MINIPORT_COUNT);
                        //
                        // Display ellipses to indicate that top entries have scrolled out of view
                        //
                        SlGenericMessageBox(0,
                                            NULL,
                                            TEXT("..."),
                                            &x,
                                            &y1,
                                            &y2,
                                            FALSE
                                            );

                        y1 = y2 + 1;

                    } else {
                        NumToSkip = ScsiDriverCount - OemScsiDriverCount;
                        y1++;
                    }

                    ScsiDevice = BlLoaderBlock->SetupLoaderBlock->ScsiDevices;
                    while(NumToSkip && ScsiDevice) {
                        ScsiDevice = ScsiDevice->Next;
                        NumToSkip--;
                    }

                    while(ScsiDevice) {

                        SlGenericMessageBox(0,
                                            NULL,
                                            ScsiDevice->Description,
                                            &x,
                                            &y1,
                                            &y2,
                                            FALSE
                                            );

                        y1 = y2 + 1;
                        ScsiDevice = ScsiDevice->Next;
                    }
                } else {

                    y1++;
                    SlGenericMessageBox(0,
                                        NULL,
                                        BlFindMessage(SL_TEXT_ANGLED_NONE),
                                        &x,
                                        &y1,
                                        &y2,
                                        FALSE
                                        );
                    y1 = y2 + 1;
                }

                x = 1;
                y1++;
                SlGenericMessageBox(0,
                                    NULL,
                                    BlFindMessage(SL_SCSI_SELECT_MESSAGE_2),
                                    &x,
                                    &y1,
                                    &y2,
                                    FALSE
                                    );

                SlWriteStatusText(BlFindMessage(SL_SCSI_SELECT_PROMPT));

                bRepaint = FALSE;
            }
            c = SlGetChar();
        } else {
            c = ( CurrentDriver != NULL )? Mnemonic : ASCI_CR;
        }
#ifdef EFI
        //
        // reset efi watchdog
        //
        SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif
        switch (c) {
            case SL_KEY_F3:
                SlConfirmExit();
                bRepaint = TRUE;
                break;

            case ASCI_CR:
                return;

            default:
                if(toupper(c) == Mnemonic) {
                    bFirstTime = FALSE;
                    bRepaint = TRUE;
                    
                    Success = SlpSelectHardware(ScsiSourceDevice,
                                    "SCSI",
                                    OEMSCSI,
                                    LoaderBootDriver,
                                    SL_PROMPT_SCSI,
                                    SL_PROMPT_OEM_SCSI,
                                    NULL,
                                    &OemScsiBase,
                                    &OemScsiName,
                                    &ScsiDescription,
                                    AllowUserSelection,
                                    (AllowUserSelection)? NULL  : CurrentDriver->DriverDescription,
                                    (BOOLEAN)((AllowUserSelection)? FALSE : CurrentDriver->OemDriver),
                                    &BlLoaderBlock->SetupLoaderBlock->HardwareIdDatabase);

                    if(!AllowUserSelection) {
                        CurrentDriver  = CurrentDriver->Next;
                    }

                    if(Success) {
                        //
                        // Check to see if the driver loaded was an OEM SCSI driver.  If so,
                        // then add an OemScsiInfo entry onto the end of our list.
                        //
                        if(OemScsiBase) {

                            NewOemScsi = BlAllocateHeap(sizeof(OEMSCSIINFO));
                            if(!NewOemScsi) {
                                SlNoMemoryError();
                            }

                            if(CurOemScsi) {
                                CurOemScsi->Next = NewOemScsi;
                            } else {
                                *pOemScsiInfo = NewOemScsi;
                            }
                            CurOemScsi = NewOemScsi;

                            NewOemScsi->ScsiBase = OemScsiBase;
                            NewOemScsi->ScsiName = OemScsiName;
                            NewOemScsi->Next     = NULL;
                        }
                    }
                }
        }
    }
}


BOOLEAN
SlLoadOemScsiDriversUnattended(
    IN  POEM_SOURCE_DEVICE  OemSourceDevice,
    IN  PVOID               InfHandle,
    IN  PCHAR               ParamsSectionName,
    IN  PCHAR               RootDirKeyName,
    IN  PCHAR               BootDriversKeyName,
    IN  POEMSCSIINFO*       ScsiInfo,
    OUT PPNP_HARDWARE_ID*   HardwareIdDatabase    
    )
/*++

Routine Description:

    Loads the boot drivers (SCSI miniport only) specified in inf file
    in an unattended fashion

Arguments:

    OemSourceDevice - The OEM_SOURCE_DEVICE which contains the scsi
        mass storage drivers that need to be loaded.

    InfHandle - Handle to inf file (e.g. winnt.sif)

    ParamsSectionName - The section name which contains the boot driver
                        keys and values.

    RootDirKeyName - The key name whose value points to the root directory
                     under which all the different directories are present

    BootDriversKeyName - The key name which consits of multiple values of
                         one level subdirectory name which are present under
                         the specified root directory.

    ScsiInfo - Returns a linked list containing info about any third-party scsi
               drivers loaded.               

    HardwareIdDatabase - Hardware Ids of the device which the loaded driver supports

Return Value:

    TRUE, if successful otherwise FALSE

--*/
{
    BOOLEAN LoadResult = FALSE;

    if (InfHandle) {
        POEMSCSIINFO    CurrOemScsi = NULL;
        ULONG           Index = 0;
        PCHAR           DriverDir = SlGetSectionKeyIndex(InfHandle,
                                        ParamsSectionName,
                                        BootDriversKeyName,
                                        Index);
        PCHAR           DriverRoot = SlGetSectionKeyIndex(InfHandle,
                                        ParamsSectionName,
                                        RootDirKeyName,
                                        0); 
        ULONG           RootLength = DriverRoot ? (ULONG)strlen(DriverRoot) : 0;

        //
        // DriverRoot and DriverDir need to have valid values 
        // in specified ParamsSectionName
        //
        LoadResult = (DriverDir && DriverRoot) ? TRUE : FALSE;                                

        while (DriverDir && LoadResult) {
            CHAR            FullDriverDir[256];
            DETECTED_DEVICE DetectedDevice = {0};
            PVOID           ImageBase = NULL;
            PCHAR           ImageName = NULL;
            PTCHAR          DriverDescription = NULL;

            //
            // Create the full path of the driver directory relative
            // to the boot directory
            //
            if (RootLength) {
                strcpy(FullDriverDir, DriverRoot);
                strcat(FullDriverDir, "\\");
            } else {
                FullDriverDir[0] = 0;
            }

            strcat(FullDriverDir, DriverDir);

            //
            // Load the driver and related files, in an unattended manner
            //
            LoadResult = SlpOemDiskette(OemSourceDevice,
                            "SCSI",
                            OEMSCSI,
                            LoaderBootDriver,
                            0,
                            &DetectedDevice,
                            &ImageBase,
                            &ImageName,
                            &DriverDescription,
                            FALSE,
                            NULL,
                            HardwareIdDatabase,
                            FullDriverDir,
                            TRUE,
                            NULL);

            if (LoadResult) {        
                //
                // If the load was successful, then create and add the information
                // ScsiInfo
                //
                if (ImageBase && ScsiInfo) {
                    POEMSCSIINFO    NewScsi = (POEMSCSIINFO)BlAllocateHeap(sizeof(OEMSCSIINFO));

                    if (!NewScsi) {
                        SlNoMemoryError();
                        return FALSE;
                    }

                    RtlZeroMemory(NewScsi, sizeof(OEMSCSIINFO));
                    NewScsi->ScsiBase = ImageBase;
                    NewScsi->ScsiName = ImageName;

                    if (CurrOemScsi) {
                        CurrOemScsi->Next = NewScsi;
                    } else {
                        *ScsiInfo = NewScsi;
                    }

                    CurrOemScsi = NewScsi;                    
                }

                //
                // Get the next driver directory to process
                //
                Index++;
                DriverDir = SlGetSectionKeyIndex(InfHandle,
                                ParamsSectionName,
                                BootDriversKeyName,
                                Index);
            }                                
        }
    }

    return LoadResult;
}


VOID
SlPromptOemHal(
    IN POEM_SOURCE_DEVICE HalSourceDevice,
    IN BOOLEAN AllowUserSelection,
    OUT PVOID *HalBase,
    OUT PCHAR *HalName
    )

/*++

Routine Description:

    Provides the user interface and logic for allowing the user to manually select
    a HAL from the main INF file or the INF file on an OEM driver disk.

Arguments:

    HalSourceDevice - The OEM_SOURCE_DEVICE which contains the HAL that needs
        to be loaded.

    AllowUserSelection - Indicates whether user can interact while selecting the
        OEM hal from the list specified in txtsetup.oem.

    HalBase - Returns the address where the HAL was loaded into memory.

    HalName - Returns the name of the HAL that was loaded.

Return Value:

    ESUCCESS - HAL successfully loaded.

--*/

{
    BOOLEAN Success;
    
    do {
        Success = SlpSelectHardware(HalSourceDevice,
                        "Computer",
                        OEMHAL,
                        LoaderHalCode,
                        SL_PROMPT_HAL,
                        SL_PROMPT_OEM_HAL,
                        &BlLoaderBlock->SetupLoaderBlock->ComputerDevice,
                        HalBase,
                        HalName,
                        NULL,
                        AllowUserSelection,
                        ComputerType,
                        OemHal,
                        &BlLoaderBlock->SetupLoaderBlock->HardwareIdDatabase);

    } while ( !Success );

}


VOID
SlPromptOemVideo(
    IN POEM_SOURCE_DEVICE VideoSourceDevice,
    IN BOOLEAN AllowUserSelection,
    OUT PVOID *VideoBase,
    OUT PCHAR *VideoName
    )

/*++

Routine Description:

    Provides the user interface and logic for allowing the user to manually select
    a video adapter from the main INF file or the INF file on an OEM driver disk.

Arguments:

    VideoSourceDevice - The OEM_SOURCE_DEVICE which contains the video driver that 
        needs to be loaded.

    AllowUserSelection - Indicates whether user can interact while selecting the
        driver from the list specified in txtsetup.oem.
        
    VideoBase - Returns the address where the video driver was loaded

    VideoName - Returns a pointer to the name of the video driver

Return Value:

    None.

--*/

{
    BOOLEAN Success;

    do {
        Success = SlpSelectHardware(VideoSourceDevice,
                        "display",
                        OEMOTHER,
                        LoaderBootDriver,
                        SL_PROMPT_VIDEO,
                        SL_PROMPT_OEM_VIDEO,
                        &BlLoaderBlock->SetupLoaderBlock->VideoDevice,
                        VideoBase,
                        VideoName,
                        NULL,
                        AllowUserSelection,
                        NULL,
                        FALSE,
                        &BlLoaderBlock->SetupLoaderBlock->HardwareIdDatabase);

    } while ( !Success );

}


BOOLEAN
SlpSelectHardware(
    IN POEM_SOURCE_DEVICE SourceDevice,
    IN PCHAR ComponentName,
    IN OEMFILETYPE ComponentType,
    IN TYPE_OF_MEMORY MemoryType,
    IN ULONG MenuHeaderId,
    IN ULONG OemMenuHeaderId,
    OUT OPTIONAL PDETECTED_DEVICE DetectedDevice,
    OUT PVOID *ImageBase,
    OUT OPTIONAL PCHAR *ImageName,
    OUT OPTIONAL PTCHAR *DriverDescription,
    IN BOOLEAN AllowUserSelection,
    IN PTCHAR PreInstallComponentDescription,
    IN BOOLEAN PreInstallOemComponent,
    OUT PPNP_HARDWARE_ID* HardwareIdDatabase
    )

/*++

Routine Description:

    Present the user with a menu of options for the selected device class.
    This menu will consist of options listed in the main inf plus a single
    oem option if one is currently selected, plus additional items in the
    system partition inf for the component if specified (ARC machines).

    When the user makes a selection, forget any previous OEM option (except
    for SCSI).  If the user selects an option supplied by us, set up the
    SELECTED_DEVICE structure and return. Otherwise prompt for a manufacturer-
    supplied diskette.

Arguments:

    SourceDevice - The device which contains the driver/hal that needs to 
        be loaded.
    
    ComponentName - Supplies the name of the component to be presented.

    ComponentType - Supplies the type of the component (HAL, SCSI, or Other)

    MemoryType - Supplies the type of memory used to load the image.

    MenuHeaderId - Supplies the ID of the menu header to be displayed

    OemMenuHeaderId - Supplies the ID of the menu header to be displayed
            when an OEM selection is to be made.

    DetectedDevice - returns the DeviceId of the selected device.  If an
            OEM diskette is required, the necessary OEM structures will
            be allocated and filled in.  (This field is ignored for SCSI
            components.)

    ImageBase - Returns the base of the image that was loaded.

    ImageName - Returns the filename of the image.

    DriverDescription - If specified, returns the description of the loaded
                        device.

    AllowUserSelection - Indicates whether or not user is allowed to select
                         a driver. This flag is typically set to FALSE when
                         pre-installing components defined in unattend.txt.

    PreInstallComponentDescription - In the pre-install mode, points to the string
                                     that identifies the component to pre-install.
                                     It is NULL if AllowUserSelction is TRUE.

    PreInstallOemComponent - In the pre-install mode, this flag indicates
                             whether or not the component to pre-install is
                             an OEM or RETAIL component.


Return Value:

    TRUE - Success

    FALSE - The user has escaped out of the dialog

--*/

{
    PSL_MENU Menu = NULL;
    ULONG Selection;
    ULONG OtherSelection = 0;
    PTCHAR OtherSelectionName = (PTCHAR)ScratchBuffer; // use global buffer to save stack
    PTCHAR p;
    ULONG c;
    PCHAR AdapterName;
    CHAR Buffer[80];
    PCHAR FileName;
    PTCHAR FileDescription;
    ARC_STATUS Status;
    BOOLEAN b;
    ULONG Ordinal;
    SCSI_INSERT_STATUS sis;

    if( AllowUserSelection ) {
        if(ComponentType != OEMSCSI) {
            Menu = SlCreateMenu();
            if (Menu==NULL) {
                SlNoMemoryError();
                return(FALSE);
            }

            //
            // Build a list of options containing the drivers we ship and the
            // currently selected OEM option (if any).
            //

            c = SlpAddSectionToMenu(InfFile,
                                    ComponentName,
                                    Menu);
            //
            // Add selection for "other"
            //
            _tcsncpy(OtherSelectionName,
                     BlFindMessage(SL_TEXT_OTHER_DRIVER),
                     sizeof(ScratchBuffer)/sizeof(TCHAR) - 1
                     );
            OtherSelectionName[sizeof(ScratchBuffer)/sizeof(TCHAR) - 1] = TEXT('\0');

            //
            // Use text up to the first CR or LF.
            //
            for(p = OtherSelectionName; *p; p++) {
                if((*p == TEXT('\n')) || (*p == TEXT('\r'))) {
                    *p = TEXT('\0');
                    break;
                }
            }

            OtherSelection = SlAddMenuItem(Menu,
                                           OtherSelectionName,
                                           (PVOID)-1,
                                           0);

            //
            // Default is "other"
            //
            Selection = OtherSelection;
        } else {
            //
            //  For SCSI devices we don't display any list of drivers for the user to choose.
            //  We just prompt for the OEM disk, this is because we always load all SCSI drivers
            //  in the NT product, due to pnp requirements.
            //
            //
            // Default is "other"
            //
            Selection = OtherSelection;
        }            
    } else {
        //
        //  This is a pre-install. Find out if the component to pre-install
        //  is RETAIL or OEM.
        //
        OtherSelection = SlCountLinesInSection( InfFile,
                                                ComponentName );
        if( PreInstallOemComponent ) {
            //
            //  Pre-installing an OEM component
            //
            Selection = OtherSelection;
        } else {
            //
            //  Pre-installing a RETAIL component
            //
            PCHAR   q;
            q = SlPreInstallGetComponentName( InfFile,
                                              ComponentName,
                                              PreInstallComponentDescription );
            if (q==NULL) {
                //
                // we have enumerated the entire section without finding a
                // match, return failure.
                //
                SlFatalError(SL_BAD_UNATTENDED_SCRIPT_FILE,
                             PreInstallComponentDescription,
                             SlCopyStringAT(ComponentName),
                             TEXT("txtsetup.sif"));
                goto SelectionAbort;
            }

            Selection = SlGetSectionKeyOrdinal( InfFile,
                                                ComponentName,
                                                q );
        }
    }

    //
    // Allow the user to interact with the menu
    //
    while (1) {
        if( AllowUserSelection ) {
            SlClearClientArea();
            p = BlFindMessage(SL_SELECT_DRIVER_PROMPT);
            if (p) {
                SlWriteStatusText(p);
            }

            if(ComponentType != OEMSCSI) {
                c = SlDisplayMenu(MenuHeaderId,
                                  Menu,
                                  &Selection);
            } else {
                //
                //  For SCSI devices, we don't display any list of driver for the user to chose
                //
                c = ASCI_CR;
            }
        } else {
            c = ASCI_CR;
        }
        switch (c) {
            case SL_KEY_F3:
                SlConfirmExit();
                break;

            case ASCI_ESC:
                goto SelectionAbort;

            case ASCI_CR: 

                if (Selection == OtherSelection) {
                    //
                    // User selected "other"  Prompt for OEM diskette
                    //
                    b = SlpOemDiskette(SourceDevice,
                            ComponentName,
                            ComponentType,
                            MemoryType,
                            OemMenuHeaderId,
                            DetectedDevice,
                            ImageBase,
                            ImageName,
                            DriverDescription,
                            AllowUserSelection,
                            PreInstallComponentDescription,
                            HardwareIdDatabase,
                            NULL,
                            TRUE,
                            NULL);


                    SlClearClientArea();
                    SlWriteStatusText(TEXT(""));
                    return(b);

                } else {
                    //
                    // User selected a built-in.  Go ahead and load
                    // it here.
                    //

                    if(ComponentType == OEMHAL) {
                        //
                        // We are looking for a HAL. If we're doing a remote
                        // boot, look in the [Hal] section. Otherwise, look in
                        // the [Hal.Load] section. (Local setup has a separate
                        // section to minimize the number of HAL binaries that
                        // need to be on the boot floppies.)
                        //
                        strcpy(Buffer, BlBootingFromNet ? "Hal" : "Hal.Load");
                    } else {
                        sprintf(Buffer, "%s.Load", ComponentName );
                    }

                    AdapterName = SlGetKeyName(InfFile,
                                               ComponentName,
                                               Selection
                                               );
                    if(AdapterName==NULL) {
                        SlFatalError(SL_BAD_INF_FILE, TEXT("txtsetup.sif"), ENODEV);
                        goto SelectionAbort;
                    }

                    FileName = SlGetIniValue(InfFile,
                                             Buffer,
                                             AdapterName,
                                             NULL);

                    if((FileName==NULL) && (ComponentType == OEMHAL)) {
                        FileName = SlGetIniValue(InfFile,
                                                 "Hal",
                                                 AdapterName,
                                                 NULL);
                        FileDescription = SlCopyString(BlFindMessage(SL_HAL_NAME));
                    } else {              
#ifdef UNICODE
                        FileDescription = SlGetIniValueW(
#else
                        FileDescription = SlGetIniValue(
#endif
                                                        InfFile,
                                                        ComponentName,
                                                        AdapterName,
                                                        NULL);
                    }

                    if(FileName==NULL) {
                        SlFatalError(SL_BAD_INF_FILE, TEXT("txtsetup.sif"), EBADF);
                        goto SelectionAbort;
                    }

                    if(ARGUMENT_PRESENT(ImageName)) {
                        *ImageName = FileName;
                    }

                    if(ARGUMENT_PRESENT(DriverDescription)) {
                        *DriverDescription = FileDescription;
                    }

                    //
                    // If we're doing OEM SCSI, then get a properly-inserted
                    // DETECTED_DEVICE structure
                    //
                    if(ComponentType == OEMSCSI) {
                        //
                        // Find this adapter's ordinal within the Scsi.Load section of txtsetup.sif
                        //
                        Ordinal = SlGetSectionKeyOrdinal(InfFile, Buffer, AdapterName);
                        if(Ordinal == SL_OEM_DEVICE_ORDINAL) {
                            SlFatalError(SL_BAD_INF_FILE, TEXT("txtsetup.sif"), EINVAL);
                            goto SelectionAbort;
                        }

                        //
                        // Create a new detected device entry.
                        //
                        if((sis = SlInsertScsiDevice(Ordinal, &DetectedDevice)) == ScsiInsertError) {
                            SlFriendlyError(ENOMEM, "SCSI detection", __LINE__, __FILE__);
                            goto SelectionAbort;
                        }


                        if(sis == ScsiInsertExisting) {
#if DBG
                            //
                            // Sanity check to make sure we're talking about the same driver
                            //
                            if(_stricmp(DetectedDevice->BaseDllName, FileName)) {
                                SlError(400);
                                goto SelectionAbort;
                            }
#endif
                        }
                    }

                    DetectedDevice->IdString = AdapterName;
                    DetectedDevice->Description = FileDescription;
                    DetectedDevice->ThirdPartyOptionSelected = FALSE;
                    DetectedDevice->FileTypeBits = 0;
                    DetectedDevice->Files = NULL;
                    DetectedDevice->BaseDllName = FileName;

                    //
                    // We only want to load the image if we're not doing SCSI.
                    //
                    if(ComponentType != OEMSCSI) {
                        sprintf(Buffer, "%s%s", BootPath, FileName);
                        SlGetDisk(FileName);

#ifdef i386
retryhal:
#endif
                        BlOutputLoadMessage(BootDevice, FileName, FileDescription);
                        Status = BlLoadImage(BootDeviceId,
                                             MemoryType,
                                             Buffer,
                                             TARGET_IMAGE,
                                             ImageBase
                                             );
#ifdef i386
                        //
                        // If the HAL didn't fit in the preferred range, reset the range to
                        // all of memory and try again.
                        //
                        if ((Status == ENOMEM) &&
                            ((BlUsableBase != 0) ||
                             (BlUsableLimit != _16MB))) {
                            BlUsableBase = 0;
                            BlUsableLimit = _16MB;

                            goto retryhal;
                        }
#endif
                    } else {
                        *ImageBase = NULL;
                        Status = ESUCCESS;
                    }
                }

                if (Status != ESUCCESS) {
                    SlMessageBox(SL_FILE_LOAD_FAILED,Buffer,Status);
                    goto SelectionAbort;
                }

                SlClearClientArea();
                SlWriteStatusText(TEXT(""));
                return(TRUE);

            default:
                break;
        }
    }

SelectionAbort:
    SlClearClientArea();
    SlWriteStatusText(TEXT(""));
    return FALSE;
}


ARC_STATUS
SlGetDriverTimeStampFromFile(
  IN ULONG DeviceId,
  IN PCHAR DriverPath,
  OUT PULONG TimeDateStamp
  )
/*++

Routine Description:

  Gets the driver's link time stamp from the the image
  header.

Arguments:

  DeviceId : Device on which the driver file resides (e.g. floppy)

  DriverPath : Full qualified path of the driver file

  TimeDateStamp : Place holder to return the image header time stamp

Return Value:

  ESUCCESS if successful, otherwise appropriate error code.

--*/
{
  ARC_STATUS  Status = EINVAL;

  if (DriverPath && TimeDateStamp) {
    UCHAR UBuffer[SECTOR_SIZE * 2 + 256] = {0};
    UCHAR *Buffer = ALIGN_BUFFER(UBuffer);
    ULONG FileId = 0;

    //
    // open the file
    //
    Status = BlOpen(DeviceId, DriverPath, ArcOpenReadOnly, &FileId);

    if (Status == ESUCCESS) {
      ULONG BytesToRead = SECTOR_SIZE * 2;
      ULONG BytesRead = 0;

      //
      // read the first two sectors of the file
      //
      Status = BlRead(FileId, Buffer, BytesToRead, &BytesRead);

      if ((Status == ESUCCESS) && (BytesToRead == BytesRead)) {
        PIMAGE_NT_HEADERS ImgHdr = RtlImageNtHeader(Buffer);
        Status = EINVAL;

        if (ImgHdr) {
          *TimeDateStamp = ImgHdr->FileHeader.TimeDateStamp;
          Status = ESUCCESS;
        }
      }

      BlClose(FileId);
    }
  }

  return Status;
}

BOOLEAN
SlRemoveInboxDriver(
  IN PCHAR DriverToRemove
  )
/*++

Routine Description:

  Removes the given driver name from list of the
  SCSI miniport devices that need to be loaded as default
  boot driver.

Arguments:

  DriverToRemove : Driver base name, that needs to be removed

Return Value:

  TRUE, if the driver was found and removed otherwise FALSE

--*/
{
  BOOLEAN Result = FALSE;

  if (DriverToRemove) {
    PDETECTED_DEVICE NodePtr = BlLoaderBlock->SetupLoaderBlock->ScsiDevices;
    PDETECTED_DEVICE PrevNode = NULL;

    while (NodePtr) {
      if (NodePtr->BaseDllName && !_stricmp(NodePtr->BaseDllName, DriverToRemove))
        break;

      PrevNode = NodePtr;
      NodePtr = NodePtr->Next;
    }

    if (NodePtr) {
      if (PrevNode) {
        PrevNode->Next = NodePtr->Next;
        Result = TRUE;
      } else {
        if (NodePtr == BlLoaderBlock->SetupLoaderBlock->ScsiDevices) {
          BlLoaderBlock->SetupLoaderBlock->ScsiDevices = NULL;
          Result = TRUE;
        }
      }
    }
  }

  return Result;
}

ARC_STATUS
SlConstructDriverPath(
  IN PDETECTED_DEVICE Device,
  IN PCHAR DefaultPath,
  OUT PCHAR FullPath
  )
/*++

Routine Description:

  Constructs a fully qualified driver path given the device node.

Arguments:

  Device : The device for which the path needs to be created.

  Defaultpath : Directory path to use, if device does not has file list.

  FullPath : Placeholder to return the constructed path

Return Value:

  ESUCCESS if path is constructed, otherwise a proper error code.

--*/
{
  ARC_STATUS  Status = EINVAL;

  if (Device && FullPath) {
    PDETECTED_DEVICE_FILE  Node = Device->Files;

    //
    // locate the driver file
    //
    while (Node) {
      HwFileType  FileType = Node->FileType;

      if((FileType == HwFilePort) || (FileType == HwFileClass) ||
          (FileType == HwFileDriver) || (FileType == HwFileHal)) {
        break;
      }

      Node = Node->Next;
    }

    if (Node && Node->Filename) {
      *FullPath = '\0';

      if (Node->Directory)
        strcat(FullPath, Node->Directory);

      //
      // append separator only if directory-name does not have
      // trailing separator or the the filename does
      // not have a leading separator
      //
      if ((Node->Filename[0] != '\\') && (*FullPath) &&
          (FullPath[strlen(FullPath) - 1] != '\\')) {
        strcat(FullPath, "\\");
      }

      strcat(FullPath, Node->Filename);
      Status = ESUCCESS;
    } else {
      if (DefaultPath && Device->BaseDllName) {
        //
        // default path has a valid trailing separator
        //
        strcpy(FullPath, DefaultPath);
        strcat(FullPath, Device->BaseDllName);
        Status = ESUCCESS;
      }
    }

    if (Status != ESUCCESS)
      *FullPath = '\0';
  }


  return Status;
}

VERSION_COMP_RESULT
SlCompareDriverVersion(
  IN ULONG InboxDeviceId,
  IN PDETECTED_DEVICE InboxDriver,
  IN ULONG OemDeviceId,
  IN PDETECTED_DEVICE OemDriver
  )
/*++

Routine Description:

  Compares the version of an inbox driver and  oem driver
  based on the link date-time stamp present in the image
  header.

Arguments:

  InboxDeviceId : Boot device ID

  InboxDriver : Device containing inbox driver details

  OemDeviceId : Oem device ID (either floppy or boot device)

  OemDriver : Device containing OEM driver details

Return Value:

  VersionErr if not able to get version information for the
  drivers, otherwise one of the following appropriately :
  VersionSame, VersionOemNew, VersionInboxNew

--*/
{
  VERSION_COMP_RESULT Result = VersionError;

  if (InboxDriver && OemDriver) {
    CHAR  FullPath[256];
    ULONG InboxDateTime = 0, OemDateTime = 0;
    ARC_STATUS Status;

    Status = SlConstructDriverPath(InboxDriver, BootPath, FullPath);

    if (Status == ESUCCESS) {
      Status = SlGetDriverTimeStampFromFile(InboxDeviceId,
                  FullPath, &InboxDateTime);

      if (Status == ESUCCESS) {
        Status = SlConstructDriverPath(OemDriver, NULL, FullPath);

        if (Status == ESUCCESS) {
          Status = SlGetDriverTimeStampFromFile(OemDeviceId,
                      FullPath, &OemDateTime);
        }
      }
    }

    if ((Status == ESUCCESS) && InboxDateTime && OemDateTime) {
      if (InboxDateTime != OemDateTime) {
        Result = (InboxDateTime > OemDateTime) ?
            VersionInboxNew : VersionOemNew;
      } else {
        Result = VersionSame;
      }
    }
  }

  return Result;
}

BOOLEAN
SlConfirmInboxDriverReplacement(
  IN PTCHAR DriverName,
  IN PTCHAR AdditionalInfo
  )
/*++

Routine Description:

  Puts up a dialog box on the screen giving information about
  the same inbox driver and oem driver being loaded, asking
  for user selection i.e. either OEM or INBOX driver.

Arguments:

  DriverName : Driver name which is same for inbox and OEM

  AdditionalInfo : Which driver is newer i.e. either OEM or
  Inbox or nothing if could not determine which driver is
  newer.

Return Value:

  TRUE if the user selected to replace default driver with OEM
  driver, otherwise return FALSE indicating that user wants
  to use inbox driver.

--*/
{
  ULONG KeyPressed = 0;
  PTCHAR MnemonicText = BlFindMessage(SL_SCSI_SELECT_MNEMONIC);
  ULONG Mnemonic = MnemonicText ? toupper(MnemonicText[0]) : 'S';

  if (AdditionalInfo) {
    ULONG Len = (ULONG)_tcslen(AdditionalInfo);

    if ((Len >= 2) && (AdditionalInfo[Len-2] == TEXT('\r')) &&
         (AdditionalInfo[Len-1] == TEXT('\n'))) {
      AdditionalInfo[Len-2] = TEXT('\0');
    }
  }

  if (DriverName) {
    SlClearClientArea();
    SlDisplayMessageBox(SL_OEM_DRIVERINFO, AdditionalInfo, DriverName);
    SlWriteStatusText(BlFindMessage(SL_CONFIRM_OEMDRIVER));

#ifdef EFI
    // 
    // disable watchdog timer when waiting for user response
    //
    DisableEFIWatchDog();
#endif

    do {
      KeyPressed = SlGetChar();
      KeyPressed = toupper(KeyPressed);
    }
    while ((KeyPressed != ASCI_CR) && (KeyPressed != Mnemonic));
#ifdef EFI
    // 
    // reset efi watchdog
    //
    SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif

    SlClearClientArea();
    SlWriteStatusText(TEXT(""));
  }

  return (KeyPressed == Mnemonic) ? TRUE : FALSE;
}

PDETECTED_DEVICE
SlCheckForInboxDriver(
  IN PCHAR DriverToCheck
  )
/*++

Routine Description:

  Searches the inbox SCSI miniport list to see if a driver
  of the given name exists.

Arguments:

  DriverToCheck : Base driver name to look for, in the list

Return Value:

  Pointer to device node containing driver information, if the
  given driver name is found, otherwise NULL

--*/
{
  PDETECTED_DEVICE  NodePtr = NULL;

  if (DriverToCheck) {
    NodePtr = BlLoaderBlock->SetupLoaderBlock->ScsiDevices;

    while (NodePtr) {
      if (NodePtr->BaseDllName && !_stricmp(NodePtr->BaseDllName, DriverToCheck)) {
        break;
      }

      NodePtr = NodePtr->Next;
    }
  }

  return NodePtr;
}



BOOLEAN
SlpOemDiskette(
    IN POEM_SOURCE_DEVICE OemSourceDevice,
    IN PCHAR ComponentName,
    IN OEMFILETYPE ComponentType,
    IN TYPE_OF_MEMORY MemoryType,
    IN ULONG MenuHeaderId,
    OUT OPTIONAL PDETECTED_DEVICE DetectedDevice,
    OUT PVOID *ImageBase,
    OUT OPTIONAL PCHAR *ImageName,
    OUT OPTIONAL PTCHAR *DriverDescription,
    IN BOOLEAN  AllowUserSelection,
    IN PTCHAR    PreInstallComponentDescription,
    OUT PPNP_HARDWARE_ID* HardwareIdDatabase,
    IN PCHAR    DriverDir,
    IN BOOLEAN  InsertDevice,
    IN OPTIONAL PCSTR    DriverIdString
    )

/*++

Routine Description:

    Prompt for an oem driver diskette and read the oem text inf file
    from it.  Present the choices for the device class to the user and
    allow him to select one.

    Remember information about the selection the user has made.

Arguments:

    OemSourceDevice - The device which contains the driver/hal that 
        needs to be loaded.
        
    ComponentName - Supplies name of component to look for.

    ComponentType - Supplies the type of the component (HAL, SCSI, or Other)

    MemoryType - Supplies the type of memory used to load the image.

    MenuHeaderId - Supplies ID of menu header to be displayed

    DetectedDevice - Returns information about the device seleceted

    ImageBase - Returns image base of loaded image

    ImageName - Returns filename of loaded image

    DriverDescription - If specified, returns description of loaded driver

    AllowUserSelection - Indicates whether or not user is allowed to select
                         a driver. This flag is typically set to FALSE when
                         pre-installing components defined in unattend.txt.

    PreInstallComponentDescription - In the pre-install mode, points to the string
                                     that identifies the component to pre-install.
                                     It is NULL if AllowUserSelction is TRUE.

    HardwareIdDatabase - The hardware IDs what were loaded for the particular
        driver.
    
    DriverDir - The driver directory which has the dynamic update driver. The 
                path is relative to the boot directory. This value indicates
                that the driver to be loaded is dyamic update boot driver.

    InsertDevice - Indicates whether to insert the device into the detected
        device list or not. Currently only valid for SCSI mass storage device
        drivers.

    DriverIdString - Driver Id of a particular driver to be loaded.
                     It is used to load a driver specified in 
                     the txtsetup.oem file using the DriverLoadList key
                     in the [Defaults] section.
        
Return Value:

    TRUE if the user made a choice, FALSE if the user cancelled/error occurred.

--*/

{
    static CHAR LoadDeviceName[128];
    ULONG LoadDeviceId = SL_OEM_DEVICE_ORDINAL;
    PVOID OemInfHandle = NULL;
    ULONG Error;
    ARC_STATUS Status;
    ULONG Count;
    ULONG DefaultSelection = 0;
    PTCHAR DefaultSelText = NULL;
    PCHAR p;
    PSL_MENU Menu = NULL;
    ULONG c;
    PMENU_ITEM_DATA Data;
    PDETECTED_DEVICE_FILE FileStruct;
    BOOLEAN bDriverLoaded;
    HwFileType filetype;
    static CHAR FullDriverPath[256];
    static CHAR FilePath[256];
    PCHAR OemComponentId = NULL;
    PTCHAR OemComponentDescription;
    DETECTED_DEVICE TempDevice;
    static TCHAR ScratchBuffer[256] = {0};
    PDETECTED_DEVICE InboxDevice;
    BOOLEAN DynamicUpdate = FALSE;
    BOOLEAN Preinstallation = FALSE;
    BOOLEAN DeviceOpened = FALSE;
    BOOLEAN DriverLoadList = FALSE;

    //
    // If source device is specified, then probe it and
    // extract some required state information
    //
    if (OemSourceDevice) {
        if (SL_OEM_SOURCE_DEVICE_TYPE(OemSourceDevice,
                SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE)) {
            DynamicUpdate = TRUE;                
        }                            

        if (SL_OEM_SOURCE_DEVICE_TYPE(OemSourceDevice,
                SL_OEM_SOURCE_DEVICE_TYPE_PREINSTALL)) {
            Preinstallation = TRUE;                
        }
        
        //
        // Is the inf already opened ?
        //
        if (!DynamicUpdate && OemSourceDevice->InfHandle &&
            !SL_OEM_SOURCE_DEVICE_STATE(OemSourceDevice,
                SL_OEM_SOURCE_DEVICE_PROCESSED)) {
            OemInfHandle = OemSourceDevice->InfHandle;
        }            

        LoadDeviceId = OemSourceDevice->DeviceId; 
        DriverLoadList = ((DriverIdString) && (DriverIdString[0] != 0)) ? TRUE : FALSE;

    }                                

    if (AllowUserSelection) {
        SlClearClientArea();
    }        

    if (AllowUserSelection) {
        //
        // Only try to detect floppy 0 if no source device
        // specified
        //
        if (OemSourceDevice) {
            strcpy(LoadDeviceName, OemSourceDevice->ArcDeviceName);
            LoadDeviceId = OemSourceDevice->DeviceId;
        } else {
            //
            // Compute the name of the A: drive
            //
            if (!SlpFindFloppy(0, LoadDeviceName)) {
                ULONG UserInput;
                
                //
                // No floppy drive available, bail out.
                //
                SlClearClientArea();
                SlDisplayMessageBox(SL_NO_FLOPPY_DRIVE);

#ifdef EFI
                // 
                // disable efi watchdog timer
                //
                DisableEFIWatchDog();
#endif
                do {
                    UserInput = SlGetChar();
                } 
                while ((UserInput != ASCI_ESC) && (UserInput != SL_KEY_F3));
#ifdef EFI
                // 
                // reset efi watchdog timer
                //
                SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif

                if (UserInput == SL_KEY_F3) {
                    ArcRestart();
                }

                SlClearClientArea();
                
                return  FALSE;
            }
        }

        //
        // Open the device if its not already done
        //
        if (LoadDeviceId == SL_OEM_DEVICE_ORDINAL) {
            //
            // Prompt for the disk.
            //
            while(1) {
                if (!SlPromptForDisk(BlFindMessage(SL_OEM_DISK_PROMPT), TRUE)) {
                    return(FALSE);
                }

                Status = ArcOpen(LoadDeviceName, ArcOpenReadOnly, &LoadDeviceId);

                if(Status == ESUCCESS) {
                    DeviceOpened = TRUE;
                    break;
                }
            }
        }            
    }

    //
    // Load the OEM INF file
    //
    if( AllowUserSelection ) {
        *FilePath = *FullDriverPath = '\0';
    } else {

        if (DynamicUpdate || Preinstallation) {
            strcpy(FilePath, BootPath);
        } else {
            *FilePath = '\0';
        }
        
        if (DynamicUpdate && DriverDir) {
            //
            // In case of dynamic update boot drivers
            // the path to txtsetup.oem needs to be fully
            // qualified from the boot directory
            //
            strcat(FilePath, DriverDir);
        } 

        if (PreInstall) {
#if defined(_X86_)
            if ( BlBootingFromNet ) {
#endif
                //
                //  On RISC platforms and on x86 remote boot clients,
                //  remove the platform specific directory from the path.
                //
                p =  (FilePath + strlen(FilePath) - 1);

                if( *p == '\\' ) {
                    *p = '\0';
                }
                
                p = strrchr(FilePath, '\\');
                
                *(p+1) = '\0';
#if defined(_X86_)
            }
#endif
        
            //
            //  Note that on x86 the path to txtsetup.oem is going to be:
            //      $win_nt$.~bt\$OEM$
            //  while on non-x86 platforms, the path is going to be:
            //      $win_nt$.~ls\$OEM$\TEXTMODE
            //  but on remote boot clients, the path is going to be:
            //      \device\lanmanredirector\server\reminst\setup\language\images\build\$OEM$\TEXTMODE
            //
            strcat(
                FilePath,
#if defined(_X86_)
                BlBootingFromNet ? WINNT_OEM_TEXTMODE_DIR_A : WINNT_OEM_DIR_A
#else
                WINNT_OEM_TEXTMODE_DIR_A
#endif
              );
        }             
        
        //
        //  Save the path to the directory that contains txtsetup.oem.
        //  It will be used later on, when we load the driver.
        //
        strcpy(FullDriverPath, FilePath);
        strcat(FilePath, "\\");
    }
    
    //
    //  Now form the path to txtsetup.oem
    //
    strcat(FilePath, "txtsetup.oem");

    //
    // Note : Reload the txtsetup.oem again in dynamic update boot driver case
    //        since for each driver the txtsetup.oem is different in its own
    //        downloaded directory
    //
    if (!OemInfHandle) {
        if (DriverDir || AllowUserSelection || (PreInstallOemInfHandle == NULL)) {        
            Status = SlInitIniFile(NULL,
                                   LoadDeviceId,
                                   FilePath,
                                   &OemInfHandle,
                                   NULL,
                                   NULL,
                                   &Error);
                                   
            if (Status != ESUCCESS) {
                SlFriendlyError(Status, "txtsetup.oem", __LINE__, __FILE__);
                goto OemLoadFailed;
            }
            
            if( !AllowUserSelection ) {
                PreInstallOemInfHandle = OemInfHandle;
            }
        } else {
            OemInfHandle = PreInstallOemInfHandle;
        }
    }        

    Count = SlCountLinesInSection(OemInfHandle, ComponentName);
    
    if(Count == BL_INF_FILE_ERROR) {
        SlMessageBox(SL_WARNING_SIF_NO_COMPONENT);
        goto OemLoadFailed;
    }

    //
    // Get the text of the default choice
    //
    if (!PreInstallComponentDescription) {
        if (DriverLoadList){                
            p = (PCHAR) DriverIdString;                
        }else{
            p = SlGetSectionKeyIndex(OemInfHandle, "Defaults",ComponentName, 0);
        }
        
        if(p && (p[0] != 0)){

#ifdef UNICODE
            DefaultSelText = SlGetSectionKeyIndexW(
#else
            DefaultSelText = SlGetSectionKeyIndex(
#endif                        
                                                OemInfHandle,
                                                ComponentName,
                                                p,
                                                0);

            //
            // Save away the component id
            //
            OemComponentId = p;                                                
        } else {
            DefaultSelText = NULL;
        }            
    } else {
        DefaultSelText = PreInstallComponentDescription;
    }

    //
    // In case of dynamic update drivers, if the defaults is not set then
    // use the first entry in the section as the default !!!
    //
    if (DynamicUpdate && !AllowUserSelection && !DefaultSelText) {
        OemComponentId = SlGetKeyName(
                            OemInfHandle, 
                            ComponentName, 
                            0);
    }    

    if( AllowUserSelection ) {
        //
        // Build menu
        //
        Menu = SlCreateMenu();
        
        if (Menu==NULL) {
            SlNoMemoryError();
        }
        
        SlpAddSectionToMenu(OemInfHandle,ComponentName,Menu);

        //
        // Find the index of the default choice
        //
        if(!DefaultSelText ||
           !SlGetMenuItemIndex(Menu,DefaultSelText,&DefaultSelection)) {
            DefaultSelection=0;
        }
    }

    //
    // Allow the user to interact with the menu
    //
    while (1) {
        if( AllowUserSelection ) {
            SlClearClientArea();
            SlWriteStatusText(BlFindMessage(SL_SELECT_DRIVER_PROMPT));

            c = SlDisplayMenu(MenuHeaderId,
                              Menu,
                              &DefaultSelection);
        } else {
            c = ASCI_CR;
        }
        
        switch (c) {
            case SL_KEY_F3:
                SlConfirmExit();
                break;

            case ASCI_ESC:
                return(FALSE);
                break;

            case ASCI_CR:
                //
                // User selected an option, fill in the detected
                // device structure with the information from the
                // INF file.
                //

                if (!DetectedDevice) {
                  RtlZeroMemory(&TempDevice, sizeof(DETECTED_DEVICE));
                  DetectedDevice = &TempDevice;
                }
                                               
                //
                // We create a new device using SlInsertScsiDevice(...) only if we load
                // the requested SCSI miniport successfully
                //
                if (ComponentType == OEMSCSI) {
                  DetectedDevice->Ordinal= SL_OEM_DEVICE_ORDINAL;
                }

                if( AllowUserSelection ) {
                    Data = SlGetMenuItem(Menu, DefaultSelection);
                    OemComponentId = Data->Identifier;
                    OemComponentDescription = Data->Description;
                } else {
                    if (PreInstallComponentDescription) {
                        OemComponentId = SlPreInstallGetComponentName( OemInfHandle,
                                                                       ComponentName,
                                                                       PreInstallComponentDescription );
                        if( OemComponentId == NULL ) {
                            SlFatalError(SL_BAD_UNATTENDED_SCRIPT_FILE,
                                         PreInstallComponentDescription,
                                         SlCopyStringAT(ComponentName),
                                         "txtsetup.oem");

                        }
                        
                        OemComponentDescription = PreInstallComponentDescription;
                    } else {
#ifdef UNICODE
                        OemComponentDescription = SlGetSectionKeyIndexW(
                                                        OemInfHandle,
                                                        ComponentName,
                                                        OemComponentId,
                                                        0);
#else
                        OemComponentDescription = SlGetSectionKeyIndex(
                                                        OemInfHandle,
                                                        ComponentName,
                                                        OemComponentId,
                                                        0);
#endif                                                        
                    }
                }
                

                if(SlpOemInfSelection(OemSourceDevice,
                        OemInfHandle,
                        ComponentName,
                        OemComponentId,
                        OemComponentDescription,
                        DetectedDevice,
                        HardwareIdDatabase,
                        FullDriverPath)) {
                    //
                    // Go load the driver.  The correct disk must
                    // already be in the drive, since we just read
                    // the INF file off it.
                    //
                    // We step down the linked list, and load the first driver we find.
                    //
                    for(FileStruct = DetectedDevice->Files, bDriverLoaded = FALSE;
                            (FileStruct && !bDriverLoaded);
                            FileStruct = FileStruct->Next) {

                        filetype = FileStruct->FileType;

                        if((filetype == HwFilePort) || (filetype == HwFileClass) ||
                                (filetype == HwFileDriver) || (filetype == HwFileHal)) {
                            ULONG DirLength;
                            
                            BlOutputLoadMessage(
                                LoadDeviceName,
                                FileStruct->Filename,
                                OemComponentDescription // Data->Description
                                );


                            //
                            // Reconstruct the FullDriverPath 
                            //
                            strcpy(FullDriverPath, FileStruct->Directory);                                                
                            DirLength = (ULONG)strlen(FullDriverPath);

                            if (DirLength && (FullDriverPath[DirLength - 1] != '\\')) {
                                strcat(FullDriverPath, "\\");
                            }                                    
                            
                            strcat(FullDriverPath, FileStruct->Filename);

                            if (ComponentType == OEMSCSI) {
                              PTCHAR FmtStr = 0;

                              //
                              // Verify that we don't have an in-box driver
                              //
                              InboxDevice = SlCheckForInboxDriver(FileStruct->Filename);

                              if (InboxDevice) {
                                VERSION_COMP_RESULT VerResult;
                                PTCHAR AdditionalInfo;
                                PTCHAR DriverName = OemComponentDescription;
#ifdef UNICODE
                                WCHAR FileNameW[100];
#endif

                                if(DriverName == NULL) {
#ifdef UNICODE
                                    UNICODE_STRING uString;
                                    ANSI_STRING aString;
                                    RtlInitAnsiString(&aString, FileStruct->Filename);
                                    uString.Buffer = FileNameW;
                                    uString.MaximumLength = sizeof(FileNameW);
                                    RtlAnsiStringToUnicodeString(&uString, &aString, FALSE);
                                    //
                                    // the converted string is NULL-terminated
                                    //
                                    DriverName = FileNameW;
#else
                                    DriverName = FileStruct->Filename;
#endif
                                }

                                //
                                // Compare the drivers version's using link time stamp
                                //
                                VerResult = SlCompareDriverVersion(
                                                BootDeviceId,
                                                InboxDevice,
                                                LoadDeviceId,
                                                DetectedDevice
                                                );

                                //
                                // Show additional message to the user about the driver
                                // version mismatch
                                //
                                switch (VerResult) {
                                  case VersionOemNew:
                                    AdditionalInfo = BlFindMessage(SL_OEMDRIVER_NEW);
                                    break;

                                  case VersionInboxNew:
                                    AdditionalInfo = BlFindMessage(SL_INBOXDRIVER_NEW);
                                    break;

                                  default:
                                    AdditionalInfo = TEXT("");
                                    break;
                                }

                                //
                                // Show the message and get confirmation from user
                                // only in attended case. In case of dynamic update
                                // boot drivers just use the inbox driver itself
                                //
                                if (AllowUserSelection && 
                                    SlConfirmInboxDriverReplacement(DriverName,
                                        AdditionalInfo)) {
                                  //
                                  // Remove the driver node from inbox SCSI miniport
                                  // list
                                  //
                                  SlRemoveInboxDriver(FileStruct->Filename);
                                } else {
                                    //
                                    // User selected to use inbox driver
                                    //
                                    if (AllowUserSelection) {

                                        if (DeviceOpened) {
                                            ArcClose(LoadDeviceId);
                                        }
                                        
                                        return FALSE;
                                    }

                                    if (DynamicUpdate) {
                                        //
                                        // NOTE: Use the inbox driver instead
                                        // of dynamic update driver
                                        //
                                        return TRUE;    
                                    }                                        

                                    //
                                    // If user already loaded another third party
                                    // driver then honor that
                                    //
                                    if (InboxDevice->ThirdPartyOptionSelected) {
                                        return FALSE;
                                    }
                                    
                                    //
                                    // NOTE : For other autoload features we
                                    // use the OEM driver, instead of inbox
                                    // driver to make auto load feature
                                    // meaningful.
                                }
                              }

                              //
                              // Inform the user that the driver is being loaded
                              //
                              FmtStr = BlFindMessage(SL_FILE_LOAD_MESSAGE);

                              if (FmtStr && !WinPEBoot) {
                                  PTSTR pFileName;
#ifdef UNICODE
                                  WCHAR FileNameW[64];
                                  ANSI_STRING aString;
                                  UNICODE_STRING uString;
                                    
                                  RtlInitString( &aString, FileStruct->Filename );
                                  uString.Buffer = FileNameW;
                                  uString.MaximumLength = sizeof(FileNameW);
                                  RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
                                    
                                  pFileName = FileNameW;
                                    
#else
                                  pFileName = FileStruct->Filename;
                                    
#endif
                                  _stprintf(ScratchBuffer, FmtStr, pFileName);
                                  SlWriteStatusText(ScratchBuffer);
                              }
                            }

                            Status = BlLoadImage(LoadDeviceId,
                                               MemoryType,
                                               FullDriverPath,
                                               TARGET_IMAGE,
                                               ImageBase);

                            if (Status == ESUCCESS) {

                                DetectedDevice->BaseDllName = FileStruct->Filename;

                                if(ARGUMENT_PRESENT(ImageName)) {
                                    *ImageName = FileStruct->Filename;
                                }

                                if(ARGUMENT_PRESENT(DriverDescription)) {
                                    *DriverDescription = OemComponentDescription; // Data->Description;
                                }

                                bDriverLoaded = TRUE;

                            } else {

                                if( !PreInstall ) {
                                    SlFriendlyError(
                                        Status,
                                        FullDriverPath,
                                        __LINE__,
                                        __FILE__
                                        );

                                    //
                                    // If one of the drivers causes an error, then we abort
                                    //
                                    if (DeviceOpened) {
                                        ArcClose(LoadDeviceId);
                                    }                                            

                                    return FALSE;
                                } else {
                                    SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(FullDriverPath), Status);
                                }
                            }
                        }
                    }

                    if (DeviceOpened) {
                        ArcClose(LoadDeviceId);
                    }                            

                    if(bDriverLoaded) {
                      if ((ComponentType == OEMSCSI) && InsertDevice) {
                        PDETECTED_DEVICE  NewScsiDevice = NULL;

                        //
                        // Insert the device in SCSI miniport list
                        //
                        if(SlInsertScsiDevice(SL_OEM_DEVICE_ORDINAL, &NewScsiDevice) == ScsiInsertError) {
                          SlNoMemoryError();
                        }

                        //
                        // update the node information we just created
                        //
                        *NewScsiDevice = *DetectedDevice;
                      }

                      return TRUE;
                    } else {
                        //
                        // We didn't find any drivers, so inform the user.
                        //
                        SlMessageBox(SL_WARNING_SIF_NO_DRIVERS);
                        break;
                    }

                } else {
                    SlFriendlyError(
                        0,
                        "",
                        __LINE__,
                        __FILE__
                        );

                    //
                    // Treat the invalid txtsetup.oem files cases as
                    // user cancellation
                    //
                    goto OemLoadFailed;                        
                }
                break;
        }
    }

OemLoadFailed:
    
    if (DeviceOpened){
        ArcClose(LoadDeviceId);
    }
    return(FALSE);
}


ULONG
SlpAddSectionToMenu(
    IN PVOID InfHandle,
    IN PCHAR SectionName,
    IN PSL_MENU Menu
    )
/*++

Routine Description:

    Adds the entries in an INF section to the given menu

Arguments:

    InfHandle - Supplies a handle to the INF file

    SectionName - Supplies the name of the section.

    Menu - Supplies the menu to add the items in the section to.

Return Value:

    Number of items added to the menu.

--*/
{
    ULONG i;
    ULONG LineCount;
    PTCHAR Description;
    PMENU_ITEM_DATA Data;

    if (InfHandle==NULL) {
        //
        // nothing to add
        //
        return(0);
    }

    LineCount = SlCountLinesInSection(InfHandle,SectionName);
    if(LineCount == BL_INF_FILE_ERROR) {
        LineCount = 0;
    }
    for (i=0;i<LineCount;i++) {
        Data = BlAllocateHeap(sizeof(MENU_ITEM_DATA));
        if (Data==NULL) {
            SlError(0);
            return(0);
        }

        Data->InfFile = InfHandle;
        Data->SectionName = SectionName;
        Data->Index = i;

#ifdef UNICODE
        Description = SlGetSectionLineIndexW(
#else
        Description = SlGetSectionLineIndex(
#endif
                                        InfHandle,
                                        SectionName,
                                        i,
                                        0);
        if (Description==NULL) {
            Description=TEXT("BOGUS!");
        }

        Data->Description = Description;
        Data->Identifier = SlGetKeyName(InfHandle,SectionName,i);

        SlAddMenuItem(Menu,
                      Description,
                      Data,
                      0);
    }

    return(LineCount);
}


BOOLEAN
SlpFindFloppy(
    IN ULONG Number,
    OUT PCHAR ArcName
    )

/*++

Routine Description:

    Determines the ARC name for a particular floppy drive.

Arguments:

    Number - Supplies the floppy drive number

    ArcName - Returns the ARC name of the given floppy drive.

Return Value:

    TRUE - Drive was found.

    FALSE - Drive was not found.

--*/

{

    FloppyDiskPath = ArcName;
    FloppyDiskPath[0] = '\0';

    BlSearchConfigTree(BlLoaderBlock->ConfigurationRoot,
                       PeripheralClass,
                       FloppyDiskPeripheral,
                       Number,
                       FoundFloppyDiskCallback);

    if (ArcName[0]=='\0') {
        return(FALSE);
    } else {
        return(TRUE);
    }

}

BOOLEAN
FoundFloppyDiskCallback(
    IN PCONFIGURATION_COMPONENT_DATA Component
    )

/*++

Routine Description:

    Callback routine called by SlpFindFloppy to find a given floppy
    drive in the ARC tree.

    Check to see whether the parent is disk controller 0.

Arguments:

    Component - Supplies the component.

Return Value:

    TRUE if search is to continue.
    FALSE if search is to stop.

--*/

{
    PCONFIGURATION_COMPONENT_DATA ParentComponent;

    //
    // A floppy disk peripheral was found.  If the parent was disk(0),
    // we've got a floppy disk drive.
    //

    ParentComponent = Component->Parent;

    if( ParentComponent &&
        (ParentComponent->ComponentEntry.Type == DiskController))
    {

        //
        // Store the ARC pathname of the floppy
        //
        BlGetPathnameFromComponent(Component,FloppyDiskPath);
        return(FALSE);
    }

    return(TRUE);               // keep searching
}
BOOLEAN
SlpIsOnlySuperFloppy(
    void
    )

/*++

Routine Description:

    Determines if we only have ATAPI super floppies

Arguments:


Return Value:

    TRUE - only super floppies

    FALSE - > 0 regular floppies

--*/

{

    BlSearchConfigTree(BlLoaderBlock->ConfigurationRoot,
                       PeripheralClass,
                       FloppyDiskPeripheral,
                       0,
                       SuperFloppyCallback);

    return(IsSuperFloppy == FloppyNumber) ? TRUE : FALSE;

}

BOOLEAN
SuperFloppyCallback(
    IN PCONFIGURATION_COMPONENT_DATA Component
    )

/*++

Routine Description:

    Callback routine called by SlpIsOnlySuper to find if we only have ATAPI floppy
    drives in the ARC tree.

    Check to see whether the parent is disk controller 0.

Arguments:

    Component - Supplies the component.

Return Value:

    TRUE if search is to continue.
    FALSE if search is to stop.

--*/

{
    PCM_FLOPPY_DEVICE_DATA FloppyData;
    PCM_PARTIAL_RESOURCE_LIST DescriptorList;

    if(Component->ComponentEntry.Type==FloppyDiskPeripheral) {
       //
       // A floppy disk peripheral was found.
       //

       FloppyNumber++;

       //
       // Crack the CM descriptors. This is a reversal of the storage from
       // ..\detect\i386\diskc.c. The data is in the 2nd, not the 1st descriptor
       //
       DescriptorList = (PCM_PARTIAL_RESOURCE_LIST)Component->ConfigurationData;
       FloppyData = (PCM_FLOPPY_DEVICE_DATA)(DescriptorList +1);

       if (FloppyData->MaxDensity & 0x80000000) {
           //
           // Is it a special removeable ATAPI device?
           //
           IsSuperFloppy++;
       }
    }

    return(TRUE);               // keep searching
}


BOOLEAN
SlpReplicatePnpHardwareIds(
    IN PPNP_HARDWARE_ID ExistingIds,
    OUT PPNP_HARDWARE_ID *NewIds
    )
/*++

Routine Description:

    Replicates the input PNP_HARDWARE_ID list.

Arguments:

    ExistingIds -   The input PNP_HARDWARE_ID list

    NewIds - Placeholder for the the new replicated hardware
        ID linked list.

Return Value:

    TRUE if successful, otherwise FALSE.

--*/
{
    BOOLEAN Result = FALSE;

    if (ExistingIds && NewIds) {
        PPNP_HARDWARE_ID SrcNode = ExistingIds;
        PPNP_HARDWARE_ID HeadNode = NULL;
        PPNP_HARDWARE_ID PrevNode = NULL;
        PPNP_HARDWARE_ID CurrNode = NULL;

        do {             
            CurrNode = BlAllocateHeap(sizeof(PNP_HARDWARE_ID));

            if (CurrNode) {            
                *CurrNode = *SrcNode;
                CurrNode->Next = NULL;
                                
                if (!HeadNode) {
                    HeadNode = CurrNode;
                }

                if (PrevNode) {
                    PrevNode->Next = CurrNode;
                }
                
                PrevNode = CurrNode;                    
                SrcNode = SrcNode->Next;
            }                            
        }
        while (SrcNode && CurrNode);

        if (CurrNode) {
            Result = TRUE;
            *NewIds = HeadNode;
        }            
    }

    return Result;
}
    


BOOLEAN
SlpOemInfSelection(
    IN  POEM_SOURCE_DEVICE OemSourceDevice,
    IN  PVOID             OemInfHandle,
    IN  PCHAR             ComponentName,
    IN  PCHAR             SelectedId,
    IN  PTCHAR            ItemDescription,
    OUT PDETECTED_DEVICE  Device,
    OUT PPNP_HARDWARE_ID* HardwareIdDatabase,
    IN  PCHAR   DriverDir
    )
{
    PCHAR FilesSectionName,ConfigSectionName,HardwareIdsSectionName;
    ULONG Line,Count,Line2,Count2;
    BOOLEAN rc = FALSE;
    PDETECTED_DEVICE_FILE FileList = NULL, FileListTail = NULL;
    PDETECTED_DEVICE_REGISTRY RegList = NULL, RegListTail = NULL;
    PPNP_HARDWARE_ID IdList = NULL, IdListTail;
    PPNP_HARDWARE_ID PrivateIdList = NULL;
    ULONG FileTypeBits = 0;

    //
    // Validate the parameters
    //
    if (!ComponentName || !SelectedId) {
        return FALSE;
    }
    
    //
    // Iterate through the files section, remembering info about the
    // files to be copied in support of the selection.
    //

    FilesSectionName = BlAllocateHeap(sizeof("Files.") +       // includes 1 for the \0
                                      (ULONG)strlen(ComponentName) +
                                      sizeof(CHAR) +           // 1 for the "."
                                      (ULONG)strlen(SelectedId)
                                      );
                                      
    if (!FilesSectionName) {
        return FALSE; // out of memory
    }
    strcpy(FilesSectionName,"Files.");
    strcat(FilesSectionName,ComponentName);
    strcat(FilesSectionName,".");
    strcat(FilesSectionName,SelectedId);
    Count = SlCountLinesInSection(OemInfHandle,FilesSectionName);
    if(Count == BL_INF_FILE_ERROR) {
        SlMessageBox(SL_BAD_INF_SECTION,FilesSectionName);
        goto sod0;
    }

    for(Line=0; Line<Count; Line++) {

        PCHAR Disk,Filename,Filetype,Tagfile,Directory,ConfigName;
        PTCHAR Description;
        HwFileType filetype;
        PDETECTED_DEVICE_FILE FileStruct;

        //
        // Get the disk specification, filename, and filetype from the line.
        //

        Disk = SlGetSectionLineIndex(OemInfHandle,FilesSectionName,Line,OINDEX_DISKSPEC);

        Filename = SlGetSectionLineIndex(OemInfHandle,FilesSectionName,Line,OINDEX_FILENAME);
        Filetype = SlGetKeyName(OemInfHandle,FilesSectionName,Line);

        if(!Disk || !Filename || !Filetype) {
#ifdef UNICODE
            DIAGOUT((
                TEXT("SlpOemDiskette: Disk=%S, Filename=%S, Filetype=%S"),
                Disk ? Disk : "(null)",
                Filename ? Filename : "(null)",
                Filetype ? Filetype : "(null)"));
#else
            DIAGOUT((
                TEXT("SlpOemDiskette: Disk=%s, Filename=%s, Filetype=%s"),
                Disk ? Disk : "(null)",
                Filename ? Filename : "(null)",
                Filetype ? Filetype : "(null)"));
#endif            
            SlError(Line);
//            SppOemInfError(ErrorMsg,&SptOemInfErr2,Line+1,FilesSectionName);

            goto sod0;
        }

        //
        // Parse the filetype.
        //
        filetype = SlpFindStringInTable(Filetype,FileTypeNames);
        if(filetype == HwFileMax) {
//            SppOemInfError(ErrorMsg,&SptOemInfErr4,Line+1,FilesSectionName);
            goto sod0;
        }

        //
        // Fetch the name of the section containing configuration information.
        // Required if file is of type port, class, or driver.
        //
        if((filetype == HwFilePort) || (filetype == HwFileClass) || (filetype == HwFileDriver)) {
            ConfigName = SlGetSectionLineIndex(OemInfHandle,FilesSectionName,Line,OINDEX_CONFIGNAME);
            if(ConfigName == NULL) {
//                SppOemInfError(ErrorMsg,&SptOemInfErr8,Line+1,FilesSectionName);
                goto sod0;
            }
        } else {
            ConfigName = NULL;
        }

        //
        // Using the disk specification, look up the tagfile, description,
        // and directory for the disk.
        //

        Tagfile     = SlGetSectionKeyIndex(OemInfHandle,"Disks",Disk,OINDEX_TAGFILE);
        
#ifdef UNICODE
        Description = SlGetSectionKeyIndexW(
#else
        Description = SlGetSectionKeyIndex(
#endif
                                        OemInfHandle,
                                        "Disks",
                                        Disk,
                                        OINDEX_DISKDESCR);

        Directory   = SlGetSectionKeyIndex(OemInfHandle,"Disks",Disk,OINDEX_DIRECTORY);
        if((Directory == NULL) || !strcmp(Directory,"\\")) {
            Directory = SlCopyStringA("");
        }

        if(!Tagfile || !Description) {
            DIAGOUT((
                TEXT("SppOemDiskette: Tagfile=%s, Description=%s"),
                Tagfile ? Tagfile : "(null)",
                Description ? Description : TEXT("(null)")));
//            SppOemInfError(ErrorMsg,&SptOemInfErr5,Line+1,FilesSectionName);
            goto sod0;
        }

        FileStruct = BlAllocateHeap(sizeof(DETECTED_DEVICE_FILE));
        memset(FileStruct, 0, sizeof(DETECTED_DEVICE_FILE));

        //
        // Use the fully qualified path, for dynamic update drivers
        // if any
        //
        if (DriverDir && DriverDir[0]) {
            PCHAR   FullDir = BlAllocateHeap(256);

            if (FullDir) {
                *FullDir = '\0';

                //
                // Do we need a starting '\' ?
                //
                if (DriverDir[0] != '\\') {
                    strcat(FullDir, "\\");
                }
                
                strcat(FullDir, DriverDir);

                //
                // Do we need to append another '\' between
                // the paths ?
                //
                if ((FullDir[strlen(FullDir) - 1] != '\\') &&
                        (*Directory != '\\')) {
                    strcat(FullDir, "\\");                        
                }                    
                
                strcat(FullDir, Directory);

                //
                // Do we need a terminating '\'?
                //
                if (FullDir[strlen(FullDir) - 1] != '\\') {
                    strcat(FullDir, "\\");
                }                    
                
                Directory = FullDir;
            } else {
                return  FALSE;  // ran out of memory
            }                
        }

        FileStruct->Directory = Directory;
        FileStruct->Filename = Filename;
        FileStruct->DiskDescription = Description;
        FileStruct->DiskTagfile = Tagfile;
        FileStruct->FileType = filetype;
        //
        // Insert at tail of list so we preserve the order in the Files section
        //
        if(FileList) {
            ASSERT(FileListTail != NULL);
            FileListTail->Next = FileStruct;
            FileListTail = FileStruct;
        } else {
            FileList = FileListTail = FileStruct;
        }
        FileStruct->Next = NULL;

        if(ConfigName) {
            FileStruct->ConfigName = ConfigName;
        } else {
            FileStruct->ConfigName = NULL;
        }
        FileStruct->RegistryValueList = NULL;

        if((filetype == HwFilePort) || (filetype == HwFileDriver)) {
            SET_FILETYPE_PRESENT(FileTypeBits,HwFilePort);
            SET_FILETYPE_PRESENT(FileTypeBits,HwFileDriver);
        } else {
            SET_FILETYPE_PRESENT(FileTypeBits,filetype);
        }

        //
        // If this is a dynamic update driver, then mark the
        // the device file type bits to indicate this. Textmode
        // setup needs this to construct a valid source path.
        //
        if (OemSourceDevice && 
            SL_OEM_SOURCE_DEVICE_TYPE(OemSourceDevice, SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE)){
            SET_FILETYPE_PRESENT(FileTypeBits, HwFileDynUpdt);
        }            

        //
        // Now go look in the [Config.<ConfigName>] section for registry
        // information that is to be set for this driver file.
        //
        if(ConfigName) {
            ConfigSectionName = BlAllocateHeap((ULONG)strlen(ConfigName) + sizeof("Config.")); // sizeof counts the \0
            strcpy(ConfigSectionName,"Config.");
            strcat(ConfigSectionName,ConfigName);
            Count2 = SlCountLinesInSection(OemInfHandle,ConfigSectionName);
            if(Count2 == BL_INF_FILE_ERROR) {
                Count2 = 0;
            }

            for(Line2=0; Line2<Count2; Line2++) {

                PCHAR KeyName,ValueName,ValueType;
                PDETECTED_DEVICE_REGISTRY Reg;
                HwRegistryType valuetype;

                //
                // Fetch KeyName, ValueName, and ValueType from the line.
                //

                KeyName   = SlGetSectionLineIndex(OemInfHandle,ConfigSectionName,Line2,OINDEX_KEYNAME);
                ValueName = SlGetSectionLineIndex(OemInfHandle,ConfigSectionName,Line2,OINDEX_VALUENAME);
                ValueType = SlGetSectionLineIndex(OemInfHandle,ConfigSectionName,Line2,OINDEX_VALUETYPE);

                if(!KeyName || !ValueName || !ValueType) {
                    DIAGOUT((
                        TEXT("SlpOemDiskette: KeyName=%s, ValueName=%s, ValueType=%s"),
                        KeyName   ? KeyName   : "(null)",
                        ValueName ? ValueName : "(null)",
                        ValueType ? ValueType : "(null)"));
//                    SppOemInfError(ErrorMsg,&SptOemInfErr2,Line2+1,ConfigSectionName);
                    goto sod0;
                }

                //
                // Parse the value type and associated values.
                //
                valuetype = SlpFindStringInTable(ValueType,RegistryTypeNames);
                if(valuetype == HwRegistryMax) {
//                    SppOemInfError(ErrorMsg,&SptOemInfErr6,Line2+1,ConfigSectionName);
                    goto sod0;
                }

                Reg = SlpInterpretOemRegistryData(OemInfHandle,ConfigSectionName,Line2,valuetype);
                if(Reg) {

                    Reg->KeyName = KeyName;
                    Reg->ValueName = ValueName;
                    //
                    // Insert at tail of list so as to preserve the order given in the config section
                    //
                    if(RegList) {
                        ASSERT(RegListTail != NULL);
                        RegListTail->Next = Reg;
                        RegListTail = Reg;
                    } else {
                        RegList = RegListTail = Reg;
                    }
                    Reg->Next = NULL;

                } else {
//                    SppOemInfError(ErrorMsg,&SptOemInfErr7,Line2+1,ConfigSectionName);
                    goto sod0;
                }
            }

            FileStruct->RegistryValueList = RegList;
            RegList = NULL;
        }

        //
        // Save away the arc device name also
        //
        if (OemSourceDevice && OemSourceDevice->ArcDeviceName) {
            FileStruct->ArcDeviceName = SlCopyStringA(OemSourceDevice->ArcDeviceName);
        } else {
            FileStruct->ArcDeviceName = NULL;
        }                        
    }
    
    //
    //  Get the hardware ids if such a section exist
    //
    HardwareIdsSectionName = BlAllocateHeap(sizeof("HardwareIds.") +      // includes the \0
                                            (ULONG)strlen(ComponentName) + 
                                            sizeof(CHAR) +                // "."
                                            (ULONG)strlen(SelectedId)
                                            );

    strcpy(HardwareIdsSectionName,"HardwareIds.");
    strcat(HardwareIdsSectionName,ComponentName);
    strcat(HardwareIdsSectionName,".");
    strcat(HardwareIdsSectionName,SelectedId);
    Count = SlCountLinesInSection(OemInfHandle,HardwareIdsSectionName);
    if(Count == BL_INF_FILE_ERROR) {
        //
        //  If the section doesn't exist, the assume it is empty
        //
        Count = 0;
    }
    IdList = IdListTail = NULL;
    for(Line=0; Line<Count; Line++) {
        PCHAR   Id;
        PCHAR   DriverName;
        PCHAR   ClassGuid;
        PPNP_HARDWARE_ID TempIdElement;

        Id          = SlGetSectionLineIndex(OemInfHandle,HardwareIdsSectionName,Line,OINDEX_HW_ID);
        DriverName  = SlGetSectionLineIndex(OemInfHandle,HardwareIdsSectionName,Line,OINDEX_DRIVER_NAME);
        ClassGuid   = SlGetSectionLineIndex(OemInfHandle,HardwareIdsSectionName,Line,OINDEX_CLASS_GUID);
        if( !Id || !DriverName ) {
            SlMessageBox(SL_BAD_INF_SECTION,HardwareIdsSectionName);
            goto sod0;
        }
        TempIdElement = BlAllocateHeap(sizeof(PNP_HARDWARE_ID));
        if(IdListTail == NULL) {
            IdListTail = TempIdElement;
        }
        TempIdElement->Id         = Id;
        TempIdElement->DriverName = DriverName;
        TempIdElement->ClassGuid  = ClassGuid;
        TempIdElement->Next = IdList;
        IdList = TempIdElement;
    }
    
    if( IdList != NULL ) {
        //
        // Replicate the PNP hardware Id list
        //
        if (!SlpReplicatePnpHardwareIds(IdList, &PrivateIdList)) {
            goto sod0;  // ran out of memory
        }
        
        IdListTail->Next = *HardwareIdDatabase;
        *HardwareIdDatabase = IdList;
    }

    //
    // Everything is OK so we can place the information we have gathered
    // into the main structure for the device class.
    //

    SlpInitDetectedDevice( Device,
                           SelectedId,
                           ItemDescription,
                           TRUE
                         );

    Device->Files = FileList;
    Device->FileTypeBits = FileTypeBits;
    Device->HardwareIds = PrivateIdList;    
    rc = TRUE;

    //
    // Clean up and exit.
    //

sod0:
    return(rc);
}

int
SlpFindStringInTable(
    IN PCHAR String,
    IN PCHAR *StringTable
    )

/*++

Routine Description:

    Locate a string in an array of strings, returning its index.  The search
    is not case sensitive.

Arguments:

    String - string to locate in the string table.

    StringTable - array of strings to search in.  The final element of the
        array must be NULL so we can tell where the table ends.

Return Value:

    Index into the table, or some positive index outside the range of valid
    indices for the table if the string is not found.

--*/

{
    int i;

    for(i=0; StringTable[i]; i++) {
        if(_stricmp(StringTable[i],String) == 0) {
            return(i);
        }
    }

    return(i);
}


VOID
SlpInitDetectedDevice(
    IN PDETECTED_DEVICE Device,
    IN PCHAR            IdString,
    IN PTCHAR           Description,
    IN BOOLEAN          ThirdPartyOptionSelected
    )
{
    Device->IdString = IdString;
    Device->Description = Description;
    Device->ThirdPartyOptionSelected = ThirdPartyOptionSelected;
    Device->FileTypeBits = 0;
    Device->Files = NULL;
}


PDETECTED_DEVICE_REGISTRY
SlpInterpretOemRegistryData(
    IN PVOID            InfHandle,
    IN PCHAR            SectionName,
    IN ULONG            Line,
    IN HwRegistryType   ValueType
    )
{
    PDETECTED_DEVICE_REGISTRY Reg;
    PCHAR Value;
    unsigned i,len;
    ULONG Dword;
    ULONG BufferSize;
    PVOID Buffer = NULL;
    PUCHAR BufferUchar;

    //
    // Perform appropriate action based on the type
    //

    switch(ValueType) {

    case HwRegistryDword:
//  case REG_DWORD_LITTLE_ENDIAN:
//  case REG_DWORD_BIG_ENDIAN:

        Value = SlGetSectionLineIndex(InfHandle,SectionName,Line,OINDEX_FIRSTVALUE);
        if(Value == NULL) {
            goto x1;
        }

        //
        // Make sure it's really a hex number
        //

        len = (ULONG)strlen(Value);
        if(len > 8) {
            goto x1;
        }
        for(i=0; i<len; i++) {
            if(!isxdigit(Value[i])) {
                goto x1;
            }
        }

        //
        // convert it from ascii to a hex number
        //

        if (!sscanf(Value,"%lx",&Dword)) {
            Dword = 0;
        }

    #if 0
        //
        // If big endian, perform appropriate conversion
        //

        if(VaueType == REG_DWORD_BIG_ENDIAN) {

            Dword =   ((Dword << 24) & 0xff000000)
                    | ((Dword <<  8) & 0x00ff0000)
                    | ((Dword >>  8) & 0x0000ff00)
                    | ((Dword >> 24) & 0x000000ff);
        }
    #endif

        //
        // Allocate a 4-byte buffer and store the dword in it
        //

        Buffer = BlAllocateHeap(BufferSize = sizeof(ULONG));
        if (Buffer == NULL) {
            goto x1;
        }
        *(PULONG)Buffer = Dword;
        break;

    case HwRegistrySz:
    case HwRegistryExpandSz:

        Value = SlGetSectionLineIndex(InfHandle,SectionName,Line,OINDEX_FIRSTVALUE);
        if(Value == NULL) {
            goto x1;
        }

        //
        // Allocate a buffer of appropriate size for the string
        //

        Buffer = BlAllocateHeap(BufferSize = (ULONG)strlen(Value)+1);
        if (Buffer == NULL) {
        goto x1;
        }

        strcpy(Buffer, Value);
        break;

    case HwRegistryBinary:

        Value = SlGetSectionLineIndex(InfHandle,SectionName,Line,OINDEX_FIRSTVALUE);
        if(Value == NULL) {
            goto x1;
        }

        //
        // Figure out how many byte values are specified
        //

        len = (unsigned)strlen(Value);
        if(len & 1) {
            goto x1;            // odd # of characters
        }

        //
        // Allocate a buffer to hold the byte values
        //

        Buffer = BlAllocateHeap(BufferSize = len / 2);
        BufferUchar = Buffer;

        //
        // For each digit pair, convert to a hex number and store in the
        // buffer
        //

        for(i=0; i<len; i+=2) {

            UCHAR byte;
            unsigned j;

            //
            // Convert the current digit pair to hex
            //

            for(byte=0,j=i; j<i+2; j++) {

                byte <<= 4;

                if(isdigit(Value[j])) {

                    byte |= (UCHAR)Value[j] - (UCHAR)'0';

                } else if((Value[j] >= 'a') && (Value[j] <= 'f')) {

                    byte |= (UCHAR)Value[j] - (UCHAR)'a' + (UCHAR)10;

                } else if((Value[j] >= 'A') && (Value[j] <= 'F')) {

                    byte |= (UCHAR)Value[j] - (UCHAR)'A' + (UCHAR)10;

                } else {

                    goto x1;
                }
            }

            BufferUchar[i/2] = byte;
        }

        break;

    case HwRegistryMultiSz:

        //
        // Calculate size of the buffer needed to hold all specified strings
        //
        BufferSize = 1;
        i = 0;
        Value = SlGetSectionLineIndex(InfHandle,SectionName,Line,OINDEX_FIRSTVALUE+i++);

        while (Value) {
            BufferSize += (ULONG)strlen(Value)+1;
            Value = SlGetSectionLineIndex(InfHandle,SectionName,Line,OINDEX_FIRSTVALUE+i++);
        }

        //
        // Allocate a buffer of appropriate size
        //

        Buffer = BlAllocateHeap(BufferSize);
        BufferUchar = Buffer;

        //
        // Store each string in the buffer, converting to wide char format
        // in the process
        //
        i = 0;
        Value = SlGetSectionLineIndex(InfHandle,SectionName,Line,OINDEX_FIRSTVALUE+i++);

        while(Value) {
            strcpy((PCHAR)BufferUchar,Value);
            BufferUchar += strlen(Value) + 1;
            Value = SlGetSectionLineIndex(InfHandle,SectionName,Line,OINDEX_FIRSTVALUE+i++);
        }

        //
        // Place final terminating nul in the buffer
        //

        *BufferUchar = 0;

        break;

    default:
    x1:

        //
        // Error - bad type specified or maybe we detected bad data values
        // and jumped here
        //

        return(NULL);
    }

    Reg = BlAllocateHeap(sizeof(DETECTED_DEVICE_REGISTRY));

    Reg->ValueType = RegistryTypeMap[ValueType];
    Reg->Buffer = Buffer;
    Reg->BufferSize = BufferSize;

    return(Reg);
}


PCHAR
SlPreInstallGetComponentName(
    IN PVOID  Inf,
    IN PCHAR  SectionName,
    IN PTCHAR TargetName
    )

/*++

Routine Description:

    Determines the canonical short name for a component to be loaded for
    this machine.

Arguments:

    Inf - Handle to an inf file (retail or OEM).

    SectionName - Supplies the name of the section (eg. [Computer])

    TargetName - Supplies the ARC string to be matched (eg. "Digital DECpc AXP 150")

Return Value:

    NULL - No match was found.

    PCHAR - Pointer to the canonical shortname of the component.

--*/

{
    ULONG i;
    PTCHAR SearchName;

    //
    // If this is not an OEM component, then enumerate the entries in the
    // section in txtsetup.sif
    //
    for (i=0;;i++) {
#ifdef UNICODE
        SearchName = SlGetSectionLineIndexW(
#else
        SearchName = SlGetSectionLineIndex(
#endif
                                           Inf,
                                           SectionName,
                                           i,
                                           0 );
        if (SearchName==NULL) {
            //
            // we have enumerated the entire section without finding a
            // match, return failure.
            //
            return(NULL);
        }

        if (_tcsicmp(TargetName, SearchName) == 0) {
            //
            // we have a match
            //
            break;
        }
    }
    //
    // i is the index into the section of the short machine name
    //
    return(SlGetKeyName(Inf,
                        SectionName,
                        i));
}


ARC_STATUS
SlLoadWinPESection(
    IN  POEM_SOURCE_DEVICE OemSourceDevice,
    IN  PVOID   OemInfHandle,        
    IN  PCSTR   OemSectionName,
    IN  PVOID   InboxInfHandle,
    IN  PCSTR   InboxSectionName,
    IN  BOOLEAN IsScsiSection,
    IN  POEMSCSIINFO*       ScsiInfo,           OPTIONAL
    OUT PPNP_HARDWARE_ID*   HardwareIdDatabase  OPTIONAL
    )
/*++

Routine Description:

    Loads the oem drivers from the specified section in the
    given OEM file name

Arguments:

    OemSourceDevice : The device that has the drivers that need to
        be loaded for WinPE.

    OemInfHandle   : Handle to the oem inf file

    OemSectionName : The section name that needs to be loaded.                

    InboxInfHandle : The original setup inf handle (txtsetup.sif)

    InboxSectionName : The section name, whose drivers are to be loaded

    IsScsiSection : Indicates whether the driver being loaded is SCSI
                    miniport or not.

    ScsiInfo - Returns a linked list containing info about any third-party scsi
               drivers loaded.               

    HardwareIdDatabase - Hardware Ids of the device which the loaded driver supports
    
Return Value:

    Appropriate ARC_STATUS

--*/
{
    ARC_STATUS  Status = EINVAL;

    if (OemSourceDevice && OemInfHandle && OemSectionName && InboxInfHandle && InboxSectionName) {        
        CHAR    Buffer[128];
        ULONG   EntryCount;
        BOOLEAN Append = TRUE;
        PCHAR   SectionName = Buffer;
        ULONG   InsertIndex = 0;

        Status = ESUCCESS;
        
        strcpy(SectionName, OemSectionName);
        strcat(SectionName, WINPE_REPLACE_SUFFIX_A);

        //
        // check if there is a .replace section
        //
        EntryCount = SlCountLinesInSection(OemInfHandle,
                            SectionName);

        if (EntryCount && (EntryCount != BL_INF_FILE_ERROR)) {                
            Append = FALSE;
        } else {
            //
            // check if there is a .append section
            //
            strcpy(SectionName, OemSectionName);
            strcat(SectionName, WINPE_APPEND_SUFFIX_A);
            
            EntryCount = SlCountLinesInSection(OemInfHandle,
                                SectionName);
       }                      

        //
        // if append was requested then load the inbox
        // drivers first
        //
        if (Append) {
            Status = SlLoadSection(InboxInfHandle,
                        InboxSectionName,
                        IsScsiSection,
                        TRUE,
                        &InsertIndex);
        }

        //
        // load the non-pnp oem drivers if any
        //
        if ((Status == ESUCCESS) && EntryCount && (EntryCount != BL_INF_FILE_ERROR)) {
            Status = SlLoadSection(OemInfHandle,
                        SectionName,
                        IsScsiSection,
                        FALSE,
                        &InsertIndex);
        }

        //
        // load the pnp oem drivers
        // 
        if (IsScsiSection && ScsiInfo && HardwareIdDatabase) {
            EntryCount = SlCountLinesInSection(OemInfHandle,
                                WINPE_OEMDRIVER_PARAMS_A);

            //
            // Try to load the driver only if present
            //
            if (EntryCount && (EntryCount != BL_INF_FILE_ERROR)) {                        
                BOOLEAN Result;
                ULONG OldDeviceType = OemSourceDevice->DeviceType;

                //
                // We mark the device type as dynupdate device type
                // so that the fully qualified driver root directory is
                // used while loading MSDs
                //
                SL_OEM_SET_SOURCE_DEVICE_TYPE(OemSourceDevice,
                    (SL_OEM_SOURCE_DEVICE_TYPE_LOCAL |
                     SL_OEM_SOURCE_DEVICE_TYPE_FIXED |
                     SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE));

                Result = SlLoadOemScsiDriversUnattended(OemSourceDevice,
                                    OemInfHandle,
                                    WINPE_OEMDRIVER_PARAMS_A,
                                    WINPE_OEMDRIVER_ROOTDIR_A,
                                    WINPE_OEMDRIVER_DIRS_A,
                                    ScsiInfo,
                                    HardwareIdDatabase);

                //
                // Restore the old device type
                //
                SL_OEM_SET_SOURCE_DEVICE_TYPE(OemSourceDevice,
                    OldDeviceType);

                if (!Result) {
                    Status = EINVAL;
                }
            }        
        }            
    }        
    
    return Status;    
}

ARC_STATUS
SlInitOemSourceDevices(
    OUT POEM_SOURCE_DEVICE *OemSourceDevices,
    OUT POEM_SOURCE_DEVICE *DefaultSourceDevice
    )
/*++

Routine Description:

    This routine scans the devices to figure out which
    are the OEM source devices and creates a list of
    such devices.

Arguments:

    OemSourceDevices - Place holder for receiving the
        linked list of OEM source devices.

    DefaultSourceDevice - Place holder for the OEM source
        device which will be used as the default device
        while trying to load OEM drivers / HAL -- generally
        floppy(0).

Return Value:

    Returns the appropriate ARC_STATUS error code.
    
--*/
{
    ARC_STATUS Status = EINVAL;

    if (OemSourceDevices && DefaultSourceDevice) {    
        ULONG   Index = 0;
        CHAR    ArcDeviceName[128];
        POEM_SOURCE_DEVICE OemDevices = NULL;

        ArcDeviceName[0] = '\0';
        Status = ESUCCESS;

        //
        // We may not find any devices 
        //
        *OemSourceDevices = *DefaultSourceDevice = NULL;

        //
        // Iterate through all the floppy drives and make them
        // oem source devices
        //

        while (ESUCCESS == Status) {
            POEM_SOURCE_DEVICE  NewDevice;

            //
            // Scan for atleast minimum number for floppies
            //
            if (!SlpFindFloppy(Index, ArcDeviceName)) {
                if ((Index + 1) < MinimumFloppiesToScan) {
                    Index++;
                    
                    continue;
                } else {
                    break;
                }                    
            }
            
            NewDevice = BlAllocateHeap(sizeof(OEM_SOURCE_DEVICE));

            if (!NewDevice) {            
                Status = ENOMEM;
            } else {                
                ARC_STATUS  OpenStatus;
                ULONG   DeviceId;                
                ULONG   DeviceType = (SL_OEM_SOURCE_DEVICE_TYPE_LOCAL | 
                                      SL_OEM_SOURCE_DEVICE_TYPE_REMOVABLE);
                
                memset(NewDevice, 0, sizeof(OEM_SOURCE_DEVICE));
                strcpy(NewDevice->ArcDeviceName, ArcDeviceName);                

                //
                // Assume we are not going to use device id
                //
                NewDevice->DeviceId = SL_OEM_DEVICE_ORDINAL;

                //
                // Treat all the floppy drives which are greater than 0
                // as virtual floppy drives
                //
                if (Index >= VirtualFloppyStart) {
                    DeviceType |= SL_OEM_SOURCE_DEVICE_TYPE_VIRTUAL;
                }

                //
                // Currently we only use local removable media for
                // OEM drivers
                //
                SL_OEM_SET_SOURCE_DEVICE_TYPE(NewDevice, DeviceType);

                SL_OEM_SET_SOURCE_DEVICE_STATE(NewDevice, 
                    SL_OEM_SOURCE_DEVICE_NOT_PROCESSED);

                OpenStatus = ArcOpen(ArcDeviceName,
                                ArcOpenReadOnly,
                                &DeviceId);

                if (ESUCCESS == OpenStatus) {
                    CHAR        InfPath[128];
                    ULONG       FileId;
                    ULONG       MediaType = SL_OEM_SOURCE_MEDIA_PRESENT;
                    
                    strcpy(InfPath, "\\");
                    strcat(InfPath, TXTSETUP_OEM_FILENAME);

                    //
                    // Verify if the file is present
                    //
                    OpenStatus = BlOpen(DeviceId,
                                    InfPath,
                                    ArcOpenReadOnly,
                                    &FileId);

                    if (ESUCCESS == OpenStatus) {
                        PVOID   InfHandle = NULL;    
                        ULONG   ErrorLine = 0;

                        //
                        // We don't need file handle any more
                        //
                        BlClose(FileId);

                        //
                        // Open and parse the txtsetup.oem file
                        //
                        OpenStatus = SlInitIniFile(NULL,
                                        DeviceId,
                                        InfPath,
                                        &InfHandle,
                                        NULL,
                                        0,
                                        &ErrorLine);

                        if (ESUCCESS == OpenStatus) {
                            PCHAR   StrValue;
                            
                            MediaType |= SL_OEM_SOURCE_MEDIA_HAS_DRIVERS;
                            NewDevice->InfHandle = InfHandle;
                            NewDevice->DeviceId = DeviceId;

                            StrValue = SlGetSectionKeyIndex(InfHandle,
                                            TXTSETUP_OEM_DEFAULTS,
                                            TXTSETUP_OEM_DEFAULTS_COMPUTER,
                                            0);

                            if (StrValue) {
                                MediaType |= (SL_OEM_SOURCE_MEDIA_HAS_DEFAULT |
                                              SL_OEM_SOURCE_MEDIA_HAS_HAL);
                            }

                            StrValue = SlGetSectionKeyIndex(InfHandle,
                                            TXTSETUP_OEM_DEFAULTS,
                                            TXTSETUP_OEM_DEFAULTS_SCSI,
                                            0);
                                                                                      
                            if (StrValue) {
                                    MediaType |= (SL_OEM_SOURCE_MEDIA_HAS_DEFAULT |
                                                  SL_OEM_SOURCE_MEDIA_HAS_MSD);
                            } 
                        } else {
                            //
                            // Inform the user about the error & abort ?
                            //
                            MediaType |= SL_OEM_SOURCE_MEDIA_NO_DRIVERS;
                        }

                        //
                        // close the device if not needed
                        //
                        if (NewDevice->DeviceId != DeviceId) {
                            ArcClose(DeviceId);
                        }                        

                        //
                        // Mark the device state as scanned
                        //
                        SL_OEM_SET_SOURCE_DEVICE_STATE(NewDevice, 
                            SL_OEM_SOURCE_DEVICE_SCANNED);                        
                    }

                    SL_OEM_SET_SOURCE_MEDIA_TYPE(NewDevice,
                        MediaType);                        
                } else {
                    SL_OEM_SET_SOURCE_MEDIA_TYPE(NewDevice,
                        SL_OEM_SOURCE_MEDIA_ABSENT);
                }                    

                //
                // insert the new device at the head of the linked list
                //
                if (!OemDevices) {
                    OemDevices = NewDevice;
                } else {
                    NewDevice->Next = OemDevices;
                    OemDevices = NewDevice;
                }                    

                //
                // Currently floppy0 is the default OEM source device
                //
                if (Index == 0) {
                    *DefaultSourceDevice = NewDevice;
                }                    

                //
                // Process next floppy drive
                //
                Index++;
                ArcDeviceName[0] = '\0';                
            }                
        }

        if (ESUCCESS == Status) {
            *OemSourceDevices = OemDevices;
        }            
    }

    return Status;
}

BOOLEAN
SlProcessDriversToLoad(
     IN  POEM_SOURCE_DEVICE     OemSourceDevice,
     OUT PPNP_HARDWARE_ID *     HardwareIdDatabaseList,
     OUT POEMSCSIINFO*          OemScsiInfo,
     IN  BOOLEAN                LoadMultipleDrivers
    )
/*++

Routine Description:

    This routine scans the oem source device and loads all the drivers 
    as specified by the DriverLoadList key in the [Defaults] section of
    the txtsetup.oem file.
    It is of the format  
    [Defaults]
    DriverLoadList = driverid1, driverid2    

Arguments:

    OemSourceDevice - The OEM source device we want to process.

    HardwareIdDatabase - The hardware IDs what were loaded for the particular
                         driver.

    OemScsiInfo - Placeholder for receiving the list OEMSCSIINFO
                  list, which has the driver base and driver name for each
                  driver loaded.

    LoadMultipleDrivers - Flag which indicates whether we are processing the
                            DriverLoadList or a single entry in the [Default] section.
    
Return Value:

    Returns the appropriate BOOLEAN status code.
    TRUE(Success)/FALSE(Failure)
    
--*/ 
{
    BOOLEAN LoadResult = FALSE;
    BOOLEAN DriverLoaded = FALSE;

    if (OemSourceDevice         &&
        HardwareIdDatabaseList  &&
        OemScsiInfo             &&
        OemSourceDevice->InfHandle){

        ULONG            DriverIdIndex = 0;
        PCHAR            DriverId = NULL;
        POEMSCSIINFO     CurrOemScsi = NULL;
        POEMSCSIINFO     OemScsiLocalList = NULL;

        //
        // If we are processing DriverLoadList from [defaults] section only then 
        // process it otherwise we want to process the [defaults] section normally.
        //
        if (LoadMultipleDrivers){
            DriverId = SlGetSectionKeyIndex(OemSourceDevice->InfHandle,
                                    TXTSETUP_OEM_DEFAULTS,
                                    TXTSETUP_OEM_DEFAULTS_DRIVERLOADLIST,            
                                    DriverIdIndex);
            //
            // In case no entry was specified in the DriverLoadList fall back
            // on the default entry.
            //
            if (!DriverId || (DriverId[0] == 0)){
                LoadMultipleDrivers = FALSE;
            }
        }       

        //
        // Process all the Driver Id's specified or process for a single entry in case
        // we are processing the [Defaults] section.
        //
        while((DriverId && (DriverId)[0])||
              (!LoadMultipleDrivers)){
            DETECTED_DEVICE     DetectedDevice = {0};
            PTCHAR              DriverDescription = NULL;
            PPNP_HARDWARE_ID    HardwareIdDatabase = NULL;
            PVOID               ImageBase = NULL;
            PCHAR               ImageName = NULL;

            
            //
            // Load the driver and related files, in an unattended manner
            //
            LoadResult = SlpOemDiskette(OemSourceDevice,
                            "SCSI",
                            OEMSCSI,
                            LoaderBootDriver,
                            0,
                            &DetectedDevice,
                            &ImageBase,
                            &ImageName,
                            &DriverDescription,
                            FALSE,
                            NULL,
                            &HardwareIdDatabase,
                            NULL,
                            TRUE,
                            DriverId); // if present indicates the DriverId to override

            if (LoadResult) {        
                //
                // If the load was successful, then create and add the information
                // ScsiInfo
                //
                POEMSCSIINFO    NewScsi = (POEMSCSIINFO)BlAllocateHeap(sizeof(OEMSCSIINFO));


                if (!NewScsi) {
                    SlNoMemoryError();
                    LoadResult = FALSE;
                    break;
                }

                RtlZeroMemory(NewScsi, sizeof(OEMSCSIINFO));
                NewScsi->ScsiBase = ImageBase;
                NewScsi->ScsiName = ImageName;

                if (CurrOemScsi) {
                    CurrOemScsi->Next = NewScsi;
                } else {
                    OemScsiLocalList = NewScsi;
                }
                
                CurrOemScsi = NewScsi;
                
                if (HardwareIdDatabase){
                    PPNP_HARDWARE_ID TempHwIdPtr = HardwareIdDatabase;   
                    
                    while (HardwareIdDatabase->Next) {
                            HardwareIdDatabase = HardwareIdDatabase->Next;
                    }
                    HardwareIdDatabase->Next = *HardwareIdDatabaseList;
                    *HardwareIdDatabaseList = TempHwIdPtr;
                }

                //
                // At least one driver got loaded successfully.
                //
                DriverLoaded = TRUE;
             }
            
            //
            // If we are not processing the DriverLoadList then we need 
            // to break from the loop as we process just one entry.
            // Else
            // Get the next driver entry to be processed.
            //
            if (!LoadMultipleDrivers){
                break;
            } else {

                //
                // Get the next driver Id to process.
                //
                DriverIdIndex++;
                DriverId = SlGetSectionKeyIndex(OemSourceDevice->InfHandle,
                                                TXTSETUP_OEM_DEFAULTS,
                                                TXTSETUP_OEM_DEFAULTS_DRIVERLOADLIST,            
                                                DriverIdIndex);
   
            }           
        }        
        if (DriverLoaded && OemScsiLocalList){
            *OemScsiInfo = OemScsiLocalList;
        }
    }
    return DriverLoaded;
}

BOOLEAN
SlIsDriverLoadListPresent(
    IN PVOID InfHandle    
    )
/*++
Routine Description:

    This routine checks if the [Defaults] section of
    the txtsetup.oem file has a DriverLoadList key with atleast one valid value.
    
    [Defaults]
    DriverLoadList = driverid1, driverid2    

Arguments:

    InfHandle - Handle to the txtsetup.oem file.

Return Value:
    Appropriate BOOLEAN status. 
    TRUE/FALSE.

--*/
{
    PCHAR StrValue = NULL;

    if (InfHandle){
    StrValue = SlGetSectionKeyIndex(InfHandle,
                                TXTSETUP_OEM_DEFAULTS,
                                TXTSETUP_OEM_DEFAULTS_DRIVERLOADLIST,
                                0);
    }
    
    return((StrValue && (StrValue[0] != 0)) ? TRUE : FALSE);
}

ARC_STATUS
SlLoadOemScsiDriversFromOemSources(
    IN POEM_SOURCE_DEVICE OemSourceDevices,
    IN OUT PPNP_HARDWARE_ID *HardwareIds,
    OUT POEMSCSIINFO *OemScsiInfo
    )
/*++

Routine Description:

    Goes through each of the OEM source device and loads the
    default drivers, if any.

Arguments:

    OemSourceDevices - List of OEM source devices.

    HardwareIds - List of all the hardware IDs of the devices which
        are controlled by the drivers which were loaded.

    OemScsiInfo - Placeholder for receiving the list OEMSCSIINFO
        list, which has the driver base and driver name for each
        driver loaded.

Return Value:

    Returns the appropriate ARC_STATUS error code.
    
--*/
{
    ARC_STATUS Status = EINVAL;

    if (OemSourceDevices && OemScsiInfo) {    
        POEM_SOURCE_DEVICE  CurrDevice = OemSourceDevices;
        POEMSCSIINFO        DeviceOemScsiInfo = NULL;
        POEMSCSIINFO        LastOemScsiNode = NULL;        

        Status = ESUCCESS;
        
        while (CurrDevice) {
            //
            // Only process those devices which are not processed yet
            // and which are not dynamic update source devices and 
            // not marked to be skipped.
            //
            if (!SL_OEM_SOURCE_DEVICE_STATE(CurrDevice,
                    SL_OEM_SOURCE_DEVICE_PROCESSED) &&
                !SL_OEM_SOURCE_DEVICE_TYPE(CurrDevice,
                    SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE) &&
                !SL_OEM_SOURCE_DEVICE_STATE(CurrDevice,
                    SL_OEM_SOURCE_DEVICE_SKIPPED)
                ) {                    

                //
                // Does the device has MSD with default entry ?
                //
                if (SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice,
                        SL_OEM_SOURCE_MEDIA_HAS_DRIVERS) &&
                    SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice,
                        SL_OEM_SOURCE_MEDIA_HAS_DEFAULT) &&
                    SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice,
                         SL_OEM_SOURCE_MEDIA_HAS_MSD)) {

                    BOOLEAN      Result = FALSE;
                    POEMSCSIINFO OemScsiInfoLocal = NULL;
                    
                    //
                    // Load drivers specified in the DriverLoadList key.
                    // We make no distinction between virual oem source devices and floppies
                    // hence we make no distinction between loading drivers from them.
                    //
                    Result = SlProcessDriversToLoad(CurrDevice,
                                            HardwareIds,
                                            &OemScsiInfoLocal,
                                            SlIsDriverLoadListPresent(CurrDevice->InfHandle));
                
                    //
                    // If we are successful in loading even a single driver from 
                    // the DriverLoadList ( in case we intended to load the driver list)
                    // or 
                    // the driver specified by the default section in the default behavior case
                    // mark the device as processed.
                    //
                    if(Result){

                        //
                        // Add the oem source device list to the global list.
                        //
                        if (OemScsiInfoLocal){
                            //
                            // Initialize head if necessary
                            //
                            if (!DeviceOemScsiInfo) {
                                DeviceOemScsiInfo = OemScsiInfoLocal;
                            }

                            //
                            // Merge the current linked list with the
                            // full OEM source device linked list
                            //
                            if (LastOemScsiNode) {
                                LastOemScsiNode->Next = OemScsiInfoLocal;
                            } else {
                                LastOemScsiNode = OemScsiInfoLocal;
                            }

                            //
                            // NOTE : We need to maintain the linked list
                            // in the order the drivers were loaded so 
                            // search for the last node in the current list
                            // and keep last node pointer around for the
                            // merge for next iteration.
                            //
                            while (LastOemScsiNode->Next) {
                                LastOemScsiNode = LastOemScsiNode->Next;
                            }

                        }
                        
                        //
                        // Mark the oem source device state, as processed
                        //
                        SL_OEM_SET_SOURCE_DEVICE_STATE(CurrDevice,
                            SL_OEM_SOURCE_DEVICE_PROCESSED);
                    } else {
                        //
                        // Make the oem source device state as skipped so that
                        // we don't create virtual oem source device for it
                        //
                        SL_OEM_SET_SOURCE_DEVICE_STATE(CurrDevice,
                            SL_OEM_SOURCE_DEVICE_SKIPPED);
                    }   
                        
                }                         
            }                    
            
            CurrDevice = CurrDevice->Next;
        }
        //
        // Initialize the return argument irrespective of
        // status code since we might have loaded some drivers
        // and would like to use it anyway
        //
        *OemScsiInfo = DeviceOemScsiInfo;

    }

    return Status;
}            

ARC_STATUS
SlInitVirtualOemSourceDevices(
    IN PSETUP_LOADER_BLOCK SetupLoaderBlock,
    IN POEM_SOURCE_DEVICE OemSourceDevices
    )
/*++

Routine Description:

    Goes through each of the OEM source devices and creates
    another linked list of virtual OEM source devices.
    
    This list is put in the loader block for setupdd.sys
    to inform the RAM disk driver to create virtual devices
    under NT to read drivers of this device.

    NOTE : Currently we allocate memory for the whole virtual
    device and replicate its contents into the allocated memory.
    We do this because we don't want OEMs to write separate
    NT driver to read from the virtual device under NT.
    We also limit the size of each virtual device to be 3MB
    at the max.
    
Arguments:

    SetupLoaderBlock - Setup loader block

    OemSourceDevices - The list of OEM source devices identified
        by the setupldr.
        
Return Value:

    Returns the appropriate ARC_STATUS error code.
    
--*/
{
    ARC_STATUS Status = EINVAL;

    if (SetupLoaderBlock && OemSourceDevices) {
        PDETECTED_OEM_SOURCE_DEVICE OemVirtualDevices = NULL;
        PDETECTED_OEM_SOURCE_DEVICE NewVirtualDevice = NULL;
        POEM_SOURCE_DEVICE CurrentDevice = OemSourceDevices;

        Status = ESUCCESS;

        while (CurrentDevice) {
            //
            // Process only those devices which are virtual
            // and have drivers in them and which were not skipped
            //
            if (SL_OEM_SOURCE_DEVICE_TYPE(CurrentDevice,
                    SL_OEM_SOURCE_DEVICE_TYPE_VIRTUAL) &&
                SL_OEM_SOURCE_MEDIA_TYPE(CurrentDevice,
                    SL_OEM_SOURCE_MEDIA_HAS_DRIVERS) &&
                !SL_OEM_SOURCE_DEVICE_STATE(CurrentDevice,
                    SL_OEM_SOURCE_DEVICE_SKIPPED)) {

                ULONGLONG ImageSize = 0;
                PVOID ImageBase = NULL;
                ULONG DeviceId = SL_OEM_DEVICE_ORDINAL;
                FILE_INFORMATION FileInfo = {0};
                LARGE_INTEGER Start = {0};

                //
                // Open the device, only if needed
                //
                if (CurrentDevice->DeviceId == SL_OEM_DEVICE_ORDINAL) {
                    Status = ArcOpen(CurrentDevice->ArcDeviceName,
                                ArcOpenReadOnly,
                                &DeviceId);
                } else {
                    DeviceId = CurrentDevice->DeviceId;
                }                    

                if (Status != ESUCCESS) {
                    break;
                }        

                //
                // Rewind the device
                //
                Status = ArcSeek(DeviceId, &Start, SeekAbsolute);

                if (Status != ESUCCESS) {
                    break;
                }                    

                //
                // Get the device size
                //
                Status = ArcGetFileInformation(DeviceId,
                            &FileInfo);

                if (Status != ESUCCESS) {
                    break;
                }

                //
                // Allocate the memory for the disk image
                //
                ImageSize = FileInfo.EndingAddress.QuadPart;

                //
                // NOTE : At the max we only allow 3MB per 
                // virtual device (should be only one device
                // in most of the cases)
                //
                if (ImageSize > 0x300000) {
                    Status = E2BIG;
                } else {
#ifdef _X86_
                    ULONG   HeapPage = 0;
                    
                    
                    //
                    // NOTE : Allocate "LoaderFirmwarePermanent" memory
                    // so that memory manager while initializing doesn't
                    // reclaim this memory. This also helps us to avoid 
                    // double copy -- i.e. this is the only location
                    // where we read the device contents into memory and 
                    // this memory is valid through out the textmode setup. 
                    //                        
                    // If we didn't allocate loader firmware permanent memory
                    // then setupdd.sys would have to allocate paged pool memory
                    // and replicate the contents from the loader block during
                    // initialization.
                    //                    
                    Status = BlAllocateDescriptor(
                                LoaderFirmwarePermanent,
                                0,
                                (ULONG)(ROUND_TO_PAGES(ImageSize) >> PAGE_SHIFT),
                                (PULONG)&HeapPage);                    

                    if (Status == ESUCCESS) {
                        ImageBase = (PVOID)(KSEG0_BASE | (HeapPage << PAGE_SHIFT));
                    }                                                
                        
#else
                    //
                    // NOTE : 05/13/2001 LoaderFirmwarePermanent doesn't seem to work on non
                    // x86 platforsm (particularly IA64). Till this issue is resolved
                    // we have to allocate memory from regular heap and we have to 
                    // replicate the memory in setupdd!SpInitialize0(..)
                    //
                    ImageBase = BlAllocateHeap((ULONG)ImageSize);

                    if (!ImageBase) {
                        Status = ENOMEM;
                    }                        
#endif

                    if (Status != ESUCCESS) {
                        break;
                    }
                    
                    if (ImageBase) {
                        ULONG BytesRead = 0;
                        
                        RtlZeroMemory(ImageBase, (ULONG)ImageSize);

                        //
                        // Read the whole device image in a single call
                        //
                        Status = ArcRead(DeviceId,
                                    ImageBase, 
                                    (ULONG)ImageSize,
                                    &BytesRead);

                        //
                        // NOTE : The approximate device size may 
                        // be bigger than the media size. So if we
                        // read atleast some bytes then we assume
                        // we are fine.
                        //
                        if ((BytesRead > 0) && (Status != ESUCCESS)) {
                            Status = ESUCCESS;
                        }
                    } else {
                        Status = ENOMEM;
                    }
                }                            

                if (Status != ESUCCESS) {
                    break;
                }

                //
                // Create a new virtual device node and put it in the 
                // list of virtual devices
                //
                NewVirtualDevice = BlAllocateHeap(sizeof(DETECTED_OEM_SOURCE_DEVICE));
                
                RtlZeroMemory(NewVirtualDevice, sizeof(DETECTED_OEM_SOURCE_DEVICE));

                if (NewVirtualDevice == NULL) {
                    Status = ENOMEM;

                    break;
                }                    
                    
                NewVirtualDevice->ArcDeviceName = SlCopyStringA(CurrentDevice->ArcDeviceName);
                NewVirtualDevice->ImageBase = ImageBase;
                NewVirtualDevice->ImageSize = ImageSize;

                DbgPrint("SETUPLDR: Virtual Device => %s (base:%p, size:%d)\n", 
                    NewVirtualDevice->ArcDeviceName,
                    ImageBase, 
                    (ULONG)ImageSize);
                
                //
                // Add the new device at the head of the linked list
                //
                if (!OemVirtualDevices) {
                    OemVirtualDevices = NewVirtualDevice;
                } else {
                    NewVirtualDevice->Next = OemVirtualDevices;
                    OemVirtualDevices = NewVirtualDevice;
                }                    
            }                    

            //
            // go on to next OEM source device
            //
            CurrentDevice = CurrentDevice->Next;
        }

        if (Status == ESUCCESS) {
            SetupLoaderBlock->OemSourceDevices = OemVirtualDevices;
        }            
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=setupldr

!IF "$(BUILD_DEBUG_LOADER)" != ""
DBG_LDR=_dbg
!ELSE
DBG_LDR=
!ENDIF

!include $(PROJECT_ROOT)\boot\loader$(DBG_LDR).inc

TARGETNAME=setupldr
TARGETPATH=obj
TARGETTYPE=LIBRARY

MSC_WARNING_LEVEL=/W4 /WX

INCLUDES=\
    $(PROJECT_ROOT)\boot\inc;\
    $(PROJECT_ROOT)\ntos\inc;\
    $(PROJECT_ROOT)\ntos\config;\
    $(PROJECT_ROOT)\ntos\nthals;\
    $(PROJECT_ROOT)\fs\fastfat;\
    $(PROJECT_ROOT)\fs\udfs;\
    ..;\
    $(O)

!IF 0
NOTE : To force CD/DVD boot while starting setupldr from harddisk use
       FORCE_CD_BOOT
C_DEFINES=$(C_DEFINES) -DFORCE_CD_BOOT
!ENDIF

SOURCES=..\arcdisp.c       \
        ..\config.c        \
        ..\decomp.c        \
        ..\oemdisk.c       \
        ..\setup.c         \
        $(O)\msgs.mc       \
        ..\setupldr.rc
        
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
NTTARGETFILE0=$(O)\msgs.mc

!IF $(386)
MC_FLAGS=-A
!ENDIF

UMRES=$(O)\setupldr.res
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\it\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\setupldr.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    setupldr.h

Abstract:

    Common header file for the setupldr module

Author:

    John Vert (jvert) 6-Oct-1993

Environment:

    ARC environment

Revision History:

--*/
#include "bldr.h"
#include "haldtect.h"
#include "setupblk.h"
#include "msgs.h"
#include "stdio.h"
#include "stdarg.h"

//
// Device Ordinal Id to indicate an OEM device
//
#define SL_OEM_DEVICE_ORDINAL (ULONG)-1

//
// OEM source device types
//
#define SL_OEM_SOURCE_DEVICE_TYPE_LOCAL         0x00008000
#define SL_OEM_SOURCE_DEVICE_TYPE_REMOVABLE     0x00000001
#define SL_OEM_SOURCE_DEVICE_TYPE_FIXED         0x00000002
#define SL_OEM_SOURCE_DEVICE_TYPE_PREINSTALL    0x10000000
#define SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE    0x20000000
#define SL_OEM_SOURCE_DEVICE_TYPE_VIRTUAL       0x40000000
#define SL_OEM_SOURCE_DEVICE_TYPE_REMOTE        0x80000000

//
// OEM source device media states
//
#define SL_OEM_SOURCE_MEDIA_ABSENT          0x00000001
#define SL_OEM_SOURCE_MEDIA_NO_DRIVERS      0x00000002
#define SL_OEM_SOURCE_MEDIA_HAS_MSD         0x00000004
#define SL_OEM_SOURCE_MEDIA_HAS_HAL         0x00000008
#define SL_OEM_SOURCE_MEDIA_HAS_DEFAULT     0x20000000
#define SL_OEM_SOURCE_MEDIA_HAS_DRIVERS     0x40000000
#define SL_OEM_SOURCE_MEDIA_PRESENT         0x80000000

//
// OEM source device processing states
//
#define SL_OEM_SOURCE_DEVICE_NOT_PROCESSED  0x00000000
#define SL_OEM_SOURCE_DEVICE_PROCESSED      0x00000001
#define SL_OEM_SOURCE_DEVICE_SKIPPED        0x00000002
#define SL_OEM_SOURCE_DEVICE_SCANNED        0x00000004
#define SL_OEM_SOURCE_DEVICE_HAL_LOADED     0x00000008
#define SL_OEM_SOURCE_DEVICE_MSD_LOADED     0x00000010
#define SL_OEM_SOURCE_DEVICE_DRIVERS_LOADED 0x40000000
#define SL_OEM_SOURCE_DEVICE_PROCESSING     0x80000000

#define SL_REGKEY_SERVICES_A        "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"
#define SL_REGKEY_SERVICES_W        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"
#define SL_REGKEY_SERVICES_LEN      (sizeof(SL_REGKEY_SERVICES_A) - 1)

typedef struct _OEM_SOURCE_DEVICE {
    CHAR    ArcDeviceName[128];
    ULONG   DeviceType;
    ULONG   MediaType;
    ULONG   DeviceState;
    ULONG   DeviceId;
    PVOID   InfHandle;
    PCSTR   DriverDir;
    struct _OEM_SOURCE_DEVICE *Next;   
} OEM_SOURCE_DEVICE, *POEM_SOURCE_DEVICE;


#define SL_OEM_SOURCE_DEVICE_TYPE(DevicePtr, Type)          \
            ((DevicePtr)->DeviceType & (Type))
            
#define SL_OEM_SET_SOURCE_DEVICE_TYPE(DevicePtr, Type)      \
            ((DevicePtr)->DeviceType = (Type))
            
#define SL_OEM_SOURCE_MEDIA_TYPE(DevicePtr, Type)           \
            ((DevicePtr)->MediaType & (Type))

#define SL_OEM_SET_SOURCE_MEDIA_TYPE(DevicePtr, Type)       \
            ((DevicePtr)->MediaType = (Type))

#define SL_OEM_SOURCE_DEVICE_STATE(DevicePtr, Type)         \
            ((DevicePtr)->DeviceState & (Type))

#define SL_OEM_SET_SOURCE_DEVICE_STATE(DevicePtr, Type)     \
            ((DevicePtr)->DeviceState = (Type))

ARC_STATUS
SlInitOemSourceDevices(
    IN OUT POEM_SOURCE_DEVICE *OemSourceDevices,
    IN OUT POEM_SOURCE_DEVICE *DefaultSourceDevice
    );

//
//
// Functions for managing the display
//
//

VOID
SlSetCurrentAttribute(
    IN UCHAR Attribute
    );

ARC_STATUS
SlWriteString(
    IN PTCHAR s
    );

ARC_STATUS
SlPositionCursor(
    IN unsigned x,
    IN unsigned y
    );

VOID
SlGetCursorPosition(
    OUT unsigned *x,
    OUT unsigned *y
    );

ARC_STATUS
SlClearClientArea(
    VOID
    );

ARC_STATUS
SlClearToEol(
    VOID
    );

VOID
SlInitDisplay(
    VOID
    );

VOID
SlWriteHeaderText(
    IN ULONG MsgId
    );

VOID
SlSetStatusAttribute(
    IN UCHAR Attribute
    );

BOOLEAN
SlGetStatusBarStatus(
    VOID
    );

VOID
SlEnableStatusBar(
    IN  BOOLEAN Enable
    );

VOID
SlWriteStatusText(
    IN PTCHAR Text
    );

VOID
SlGetStatusText(
    OUT PTCHAR Text
    );

VOID
SlClearDisplay(
    VOID
    );

VOID
SlPrint(
    IN PTCHAR FormatString,
    ...
    );

VOID
SlConfirmExit(
    VOID
    );


BOOLEAN
SlPromptForDisk(
    IN PTCHAR  DiskName,
    IN BOOLEAN IsCancellable
    );

BOOLEAN
SlGetDisk(
    IN PCHAR Filename
    );

//
// Menuing support
//
typedef struct _SL_MENU {
    ULONG ItemCount;
    ULONG Width;
    LIST_ENTRY ItemListHead;
} SL_MENU, *PSL_MENU;

typedef struct _SL_MENUITEM {
    LIST_ENTRY ListEntry;
    PTCHAR Text;
    PVOID Data;
    ULONG Attributes;
} SL_MENUITEM, *PSL_MENUITEM;

PSL_MENU
SlCreateMenu(
    VOID
    );

ULONG
SlAddMenuItem(
    PSL_MENU Menu,
    PTCHAR Text,
    PVOID Data,
    ULONG Attributes
    );

PVOID
SlGetMenuItem(
    IN PSL_MENU Menu,
    IN ULONG Item
    );

ULONG
SlDisplayMenu(
    IN ULONG HeaderId,
    IN PSL_MENU Menu,
    IN OUT PULONG Selection
    );

BOOLEAN
SlGetMenuItemIndex(
    IN PSL_MENU Menu,
    IN PTCHAR Text,
    OUT PULONG Index
    );

//
// Bullet character and macro to make a beep at the console
//
#ifndef EFI
#define BULLET "*"
#define BEEP { ULONG c; ArcWrite(ARC_CONSOLE_OUTPUT,"",1,&c); }

#if 0
#define BULLET ""
#define BEEP HWCURSOR(0x80000000,0xe07);     // int 10 func e, char 7
#endif
#endif

//
// Character attributes used for various purposes.
//

UCHAR
SlGetDefaultAttr(
  VOID
  );  

UCHAR
SlGetDefaultInvAttr(
  VOID
  );  


#define ATT_FG_BLACK        0
#define ATT_FG_RED          1
#define ATT_FG_GREEN        2
#define ATT_FG_YELLOW       3
#define ATT_FG_BLUE         4
#define ATT_FG_MAGENTA      5
#define ATT_FG_CYAN         6
#define ATT_FG_WHITE        7

#define ATT_BG_BLACK       (ATT_FG_BLACK   << 4)
#define ATT_BG_BLUE        (ATT_FG_BLUE    << 4)
#define ATT_BG_GREEN       (ATT_FG_GREEN   << 4)
#define ATT_BG_CYAN        (ATT_FG_CYAN    << 4)
#define ATT_BG_RED         (ATT_FG_RED     << 4)
#define ATT_BG_MAGENTA     (ATT_FG_MAGENTA << 4)
#define ATT_BG_YELLOW      (ATT_FG_YELLOW  << 4)
#define ATT_BG_WHITE       (ATT_FG_WHITE   << 4)

#define ATT_FG_INTENSE      8
#define ATT_BG_INTENSE     (ATT_FG_INTENSE << 4)

#define DEFATT    SlGetDefaultAttr()
#define INVATT    SlGetDefaultInvAttr()

#define DEFIATT   (ATT_FG_WHITE | ATT_BG_BLUE | ATT_FG_INTENSE)
// intense red on blue doesn't show up on all monitors.
//#define DEFERRATT (ATT_FG_RED   | ATT_BG_BLUE | ATT_FG_INTENSE)
#define DEFERRATT DEFATT
#define DEFSTATTR (ATT_FG_BLACK | ATT_BG_WHITE)
#define DEFDLGATT (ATT_FG_RED   | ATT_BG_WHITE)


//
// Function to flush keyboard buffer
//

VOID
SlFlushConsoleBuffer(
    VOID
    );


//
// Function to retrieve a keystroke
//

ULONG
SlGetChar(
    VOID
    );


//
// Virtualized contants for various keystrokes
//
#define ASCI_BS         8
#define ASCI_CR         13
#define ASCI_LF         10
#define ASCI_ESC        27
#define SL_KEY_UP       0x00010000
#define SL_KEY_DOWN     0x00020000
#define SL_KEY_HOME     0x00030000
#define SL_KEY_END      0x00040000
#define SL_KEY_PAGEUP   0x00050000
#define SL_KEY_PAGEDOWN 0x00060000
#define SL_KEY_F1       0x01000000
#define SL_KEY_F2       0x02000000
#define SL_KEY_F3       0x03000000
#define SL_KEY_F4       0x04000000
#define SL_KEY_F5       0x05000000
#define SL_KEY_F6       0x06000000
#define SL_KEY_F7       0x07000000
#define SL_KEY_F8       0x08000000
#define SL_KEY_F9       0x09000000
#define SL_KEY_F10      0x0A000000
#define SL_KEY_F11      0x0B000000
#define SL_KEY_F12      0x0C000000


//
// Standard error handling functions
//

extern TCHAR MessageBuffer[1024];

VOID
SlFriendlyError(
    IN ULONG uStatus,
    IN PCHAR pchBadFile,
    IN ULONG uLine,
    IN PCHAR pchCodeFile
    );

ULONG
SlDisplayMessageBox(
    IN ULONG MessageId,
    ...
    );

VOID
SlGenericMessageBox(
    IN     ULONG   MessageId, OPTIONAL
    IN     va_list *args,     OPTIONAL
    IN     PTCHAR  Message,   OPTIONAL
    IN OUT PULONG  xLeft,     OPTIONAL
    IN OUT PULONG  yTop,      OPTIONAL
    OUT    PULONG  yBottom,   OPTIONAL
    IN     BOOLEAN bCenterMsg
    );

VOID
SlMessageBox(
    IN ULONG MessageId,
    ...
    );

VOID
SlFatalError(
    IN ULONG MessageId,
    ...
    );

//
// Routines for parsing the setupldr.ini file
//

#define SIF_FILENAME_INDEX 0

extern PVOID InfFile;
extern PVOID WinntSifHandle;

ARC_STATUS
SlInitIniFile(
   IN  PCHAR   DevicePath,
   IN  ULONG   DeviceId,
   IN  PCHAR   INFFile,
   OUT PVOID  *pINFHandle,
   OUT PVOID  *pINFBuffer OPTIONAL,
   OUT PULONG  INFBufferSize OPTIONAL,
   OUT PULONG  ErrorLine
   );

PCHAR
SlGetIniValue(
    IN PVOID InfHandle,
    IN PCHAR SectionName,
    IN PCHAR KeyName,
    IN PCHAR Default
    );

PCHAR
SlGetKeyName(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    );

ULONG
SlGetSectionKeyOrdinal(
    IN  PVOID INFHandle,
    IN  PCHAR SectionName,
    IN  PCHAR Key
    );

PCHAR
SlGetSectionKeyIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN PCHAR Key,
   IN ULONG ValueIndex
   );

PCHAR
SlCopyStringA(
    IN PCSTR String
    );

PTCHAR
SlCopyString(
    IN PTCHAR String
    );


PCHAR
SlGetSectionLineIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN ULONG LineIndex,
   IN ULONG ValueIndex
   );

ULONG
SlCountLinesInSection(
    IN PVOID INFHandle,
    IN PCHAR SectionName
    );

BOOLEAN
SpSearchINFSection (
   IN PVOID INFHandle,
   IN PCHAR SectionName
   );

PCHAR
SlSearchSection(
    IN PCHAR SectionName,
    IN PCHAR TargetName
    );

//
// functions for querying the ARC configuration tree
//
typedef
BOOLEAN
(*PNODE_CALLBACK)(
    IN PCONFIGURATION_COMPONENT_DATA FoundComponent
    );

BOOLEAN
SlSearchConfigTree(
    IN PCONFIGURATION_COMPONENT_DATA Node,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN ULONG Key,
    IN PNODE_CALLBACK CallbackRoutine
    );

BOOLEAN
SlFindFloppy(
    IN ULONG FloppyNumber,
    OUT PCHAR ArcName
    );

//
// Routines for detecting various hardware
//
VOID
SlDetectScsi(
    IN PSETUP_LOADER_BLOCK SetupBlock
    );

VOID
SlDetectVideo(
    IN PSETUP_LOADER_BLOCK SetupBlock
    );

//
// Routines for dealing with OEM disks.
//
extern BOOLEAN PromptOemHal;
extern BOOLEAN PromptOemScsi;
extern BOOLEAN PromptOemVideo;


//
// Variable indicating whether we are booting into
// WinPE (aka MiniNT) or not
//
extern BOOLEAN WinPEBoot;

typedef struct _OEMSCSIINFO {

    struct _OEMSCSIINFO *Next;

    //
    // Address where the SCSI driver was loaded
    //
    PVOID ScsiBase;

    //
    // Name of the SCSI driver
    //
    PCHAR ScsiName;

} OEMSCSIINFO, *POEMSCSIINFO;

VOID
SlPromptOemVideo(
    IN POEM_SOURCE_DEVICE VideoSourceDevice,
    IN BOOLEAN AllowUserSelection,
    OUT PVOID *VideoBase,
    OUT PCHAR *VideoName
    );

VOID
SlPromptOemHal(
    IN POEM_SOURCE_DEVICE HalSourceDevice,
    IN BOOLEAN AllowUserSelection,
    OUT PVOID *HalBase,
    OUT PCHAR *ImageName    
    );


VOID
SlPromptOemScsi(
    IN POEM_SOURCE_DEVICE ScsiSourceDevice,
    IN BOOLEAN AllowUserSelection,
    OUT POEMSCSIINFO *pOemScsiInfo
    );

BOOLEAN
SlLoadOemScsiDriversUnattended(
    IN  POEM_SOURCE_DEVICE  OemSourceDevice,
    IN  PVOID               InfHandle,
    IN  PCHAR               ParamsSectionName,
    IN  PCHAR               RootDirKeyName,
    IN  PCHAR               BootDriversKeyName,
    IN  POEMSCSIINFO*       ScsiInfo,
    OUT PPNP_HARDWARE_ID*   HardwareIdDatabase    
    );    


#if defined(_X86_) || defined(_IA64_)
VOID
BlInitializeTerminal(
    VOID
    );
#endif


//
// Routine to find the ARC name of a floppy
//
BOOLEAN
SlpFindFloppy(
    IN ULONG Number,
    OUT PCHAR ArcName
    );

//
// Are all the floppies only removable ATAPI super floppies
//
BOOLEAN
SlpIsOnlySuperFloppy(
    void
    );

//
// Enums for controlling setupldr process
//
typedef enum _SETUP_TYPE {
    SetupInteractive,
    SetupRepair,
    SetupCustom,
    SetupUpgrade,
    SetupExpress
} SETUP_TYPE;

typedef enum _MEDIA_TYPE {
    MediaInteractive,
    MediaFloppy,
    MediaCdRom,
    MediaDisk
} MEDIA_TYPE;

//
// Enum for status of inserting a new SCSI device
//
typedef enum _SCSI_INSERT_STATUS {
    ScsiInsertError,
    ScsiInsertNewEntry,
    ScsiInsertExisting
} SCSI_INSERT_STATUS;

//
// Routine to insert a DETECTED_DEVICE into its
// correct position in the ScsiDevices linked list.
//
SCSI_INSERT_STATUS
SlInsertScsiDevice(
    IN  ULONG Ordinal,
    OUT PDETECTED_DEVICE *pScsiDevice
    );

BOOLEAN
SlRemoveInboxDriver(
  IN PCHAR DriverToRemove
  );

PDETECTED_DEVICE
SlCheckForInboxDriver(
  IN PCHAR DriverToCheck
  );

BOOLEAN
SlConfirmInboxDriverReplacement(
  IN PTCHAR DriverName,
  IN PTCHAR AdditionalInfo
  );

typedef enum _VERSION_COMP_RESULT {
  VersionError,
  VersionOemNew,
  VersionInboxNew,
  VersionSame
} VERSION_COMP_RESULT;  


VERSION_COMP_RESULT
SlCompareDriverVersion(
  IN ULONG InboxDeviceId,
  IN PDETECTED_DEVICE InboxDriver,
  IN ULONG OemDeviceId,
  IN PDETECTED_DEVICE OemDriver
  );

//
// Variables dealing with pre-installation.
//

typedef struct _PREINSTALL_DRIVER_INFO {

    struct _PREINSTALL_DRIVER_INFO *Next;

    //
    // String that describes the driver to preinstall
    //
    PTCHAR DriverDescription;

    //
    // Name of the SCSI driver
    //
    BOOLEAN OemDriver;

} PREINSTALL_DRIVER_INFO, *PPREINSTALL_DRIVER_INFO;



extern BOOLEAN PreInstall;
extern PTCHAR  ComputerType;
extern BOOLEAN OemHal;
// extern PCHAR   OemBootPath;
extern PPREINSTALL_DRIVER_INFO PreinstallDriverList;

PCHAR
SlPreInstallGetComponentName(
    IN PVOID    Inf,
    IN PCHAR    SectionName,
    IN PTCHAR   TargetName
    );

ARC_STATUS
SlLoadSection(
    IN PVOID Inf,
    IN PCSTR SectionName,
    IN BOOLEAN IsScsiSection,
    IN BOOLEAN AppendLoadSuffix,
    IN OUT PULONG StartingIndexInsert
    );    

#define WINPE_AUTOBOOT_FILENAME     "$WINPE$.$$$"

BOOLEAN
SlIsWinPEAutoBoot(
    IN PSTR LoaderDeviceName
    );

ARC_STATUS
SlGetWinPEStartupParams(
    IN PSTR DeviceName,
    IN PSTR StartupDirectory
    );

ARC_STATUS
SlLoadWinPESection(
    IN  POEM_SOURCE_DEVICE OemSourceDevice,
    IN  PVOID   OemInfHandle,        
    IN  PCSTR   OemSectionName,
    IN  PVOID   InboxInfHandle,
    IN  PCSTR   InboxSectionName,
    IN  BOOLEAN IsScsiSection,
    IN  POEMSCSIINFO*       ScsiInfo,           OPTIONAL
    OUT PPNP_HARDWARE_ID*   HardwareIdDatabase  OPTIONAL
    );

ARC_STATUS
SlLoadOemScsiDriversFromOemSources(
    IN POEM_SOURCE_DEVICE OemSourceDevices,
    IN OUT PPNP_HARDWARE_ID *HardwareIds,
    OUT POEMSCSIINFO *OemScsiInfo
    );   

ARC_STATUS
SlInitVirtualOemSourceDevices(
    IN PSETUP_LOADER_BLOCK SetupLoaderBlock,
    IN POEM_SOURCE_DEVICE OemSourceDevices
    );
    

#if defined(ARCI386)
BOOLEAN
SlDetectSifPromVersion(
    IN PSETUP_LOADER_BLOCK SetupBlock
    );
#endif

#define VGA_DRIVER_FILENAME "vga.sys"
#define VIDEO_DEVICE_NAME   "VGA"

extern ULONG BootFontImageLength;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\jpn\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\kor\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\i386\initx86.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initx86.c

Abstract:

    Does any x86-specific initialization, then starts the common ARC setupldr

Author:

    John Vert (jvert) 14-Oct-1993

Revision History:

--*/
#include "setupldr.h"
#include "bldrx86.h"
#include "msgs.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <netboot.h>

ARC_STATUS
SlInit(
    IN ULONG Argc,
    IN PCHAR Argv[],
    IN PCHAR Envp[]
    );

BOOLEAN
BlDetectHardware(
    IN ULONG DriveId,
    IN PCHAR LoadOptions
    );


VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does x86-specific initialization, particularly running NTDETECT, then
    calls to the common setupldr.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG Argc;
    PCHAR Argv[10];
    CHAR SetupLoadFileName[129];
    ARC_STATUS Status;
    ULONG DriveId;
    ULONGLONG NetRebootParameter;
    BOOLEAN UseCommandConsole = FALSE;
    BOOLEAN RollbackEnabled = FALSE;
    extern BOOLEAN FwDescriptorsValid;
    extern BOOLEAN TryASRViaNetwork;


    if (BlBootingFromNet) {

        //
        // Go retrieve all the information passed to us from StartROM.
        // Once we have that, we'll call BlGetHeadlessRestartBlock and
        // get all the port settings that StartROM sent us.  These,
        // in turn, will then be used in BlInitializeTerminal(), which
        // we'are about to call.
        //
        NetGetRebootParameters(
            &NetRebootParameter,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            FALSE
            );

        if (NetRebootParameter == NET_REBOOT_COMMAND_CONSOLE_ONLY) {
            UseCommandConsole = TRUE;
        }

        if (NetRebootParameter == NET_REBOOT_ASR) {
            TryASRViaNetwork = TRUE;            
        }
    }

    //
    // Initialize any dumb terminal that may be connected.
    //
    BlInitializeHeadlessPort();

    //
    // Open the boot partition so we can load NTDETECT off it.
    //
    Status = ArcOpen(PartitionName, ArcOpenReadOnly, &DriveId);
    if (Status != ESUCCESS) {
        BlPrint(BlFindMessage(SL_DRIVE_ERROR),PartitionName);
        return;
    }

    if (_stricmp( (PCHAR)(0x7c03), "cmdcons" ) == 0) {
        UseCommandConsole = TRUE;
    } else if (strcmp ((PCHAR)(0x7c03), "undo") == 0) {
        //
        // NTLDR wrote the exact text "undo" (including the nul
        // terminator). We know the address this text was written
        // to -- 0x7C03. If we find the token, then enable rollback
        // mode. This triggers an argument to be passed to textmode
        // setup, plus a different boot message.
        //

        RollbackEnabled = TRUE;
    }

    //
    // Initialize dbcs font and display.
    //
    TextGrInitialize(DriveId, &BootFontImageLength);

    if (UseCommandConsole) {
        BlPrint(BlFindMessage(SL_NTDETECT_CMDCONS));
    } else if (RollbackEnabled) {
        BlPrint(BlFindMessage(SL_NTDETECT_ROLLBACK));
    } else {
        BlPrint(BlFindMessage(SL_NTDETECT_MSG));
    }

    //
    // detect HAL here.
    //
    if (!BlDetectHardware(DriveId, "FASTDETECT")) {
        BlPrint(BlFindMessage(SL_NTDETECT_FAILURE));
        return;
    }

    FwDescriptorsValid = FALSE;
    BlKernelChecked=TRUE;
    //
    // NOTE:
    // If you are testing the changes on read only Jaz drive uncomment this line
    // and put the correct value for rdisk(?). You also need to make sure
    // that SCSI BIOS emulation for the jaz drive is turned on for this trick
    // to work.
    //

    //strcpy(PartitionName, "multi(0)disk(0)rdisk(1)partition(1)");

    //
    // Close the drive, the loader will re-open it.
    //

    ArcClose(DriveId);

    //
    // Create arguments, call off to setupldr
    //
    if (BlBootingFromNet) {
        strcpy(SetupLoadFileName, PartitionName);
        strcat(SetupLoadFileName, "\\i386\\SETUPLDR");
    } else {
        strcpy(SetupLoadFileName, PartitionName);
        strcat(SetupLoadFileName, "\\SETUPLDR");
    }
    Argv[0] = SetupLoadFileName;
    Argc = 1;

    if (UseCommandConsole) {
        Argv[Argc++] = "ImageType=cmdcons";
    }

    if (RollbackEnabled) {
        //
        // Rollback is a special case where we know there can be no
        // OsLoadOptions.
        //

        Argv[Argc++] = "ImageType=rollback";
    }


    Status = SlInit( Argc, Argv, NULL );

    //
    // We should never return here, something
    // horrible has happened.
    //

    if (!BlIsTerminalConnected()) {
        //
        // typical case.  wait for user to press a key and then 
        // restart
        //
        while(!BlGetKey());
    }
    else {
        // 
        // headless case.  present user with mini sac
        //
        while(!BlTerminalHandleLoaderFailure());
    }
    ArcRestart();    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\ia64\initia64.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initia64.c

Abstract:

    Does any x86-specific initialization, then starts the common ARC setupldr

Author:

    John Vert (jvert) 14-Oct-1993

Revision History:

    Allen Kay (akay) 19-Mar-1998

--*/
#include "setupldr.h"
#include "bldria64.h"
#include "msgs.h"
#include <netboot.h>
#include "parsebnvr.h"

#if defined(ELTORITO)
extern BOOLEAN ElToritoCDBoot;
#endif

UCHAR MyBuffer[SECTOR_SIZE+32];

ARC_STATUS
SlInit(
    IN ULONG Argc,
    IN PCHAR Argv[],
    IN PCHAR Envp[]
    );

BOOLEAN
BlDetectHardware(
    IN ULONG DriveId,
    IN PCHAR LoadOptions
    );

VOID
KiProcessorWorkAround(
ULONG Arg1
);

ARC_STATUS
BlGetEfiBootOptions(
    OUT PUCHAR Argv0String OPTIONAL,
    OUT PUCHAR SystemPartition OPTIONAL,
    OUT PUCHAR OsLoaderFilename OPTIONAL,
    OUT PUCHAR OsLoadPartition OPTIONAL,
    OUT PUCHAR OsLoadFilename OPTIONAL,
    OUT PUCHAR FullKernelPath OPTIONAL,
    OUT PUCHAR OsLoadOptions OPTIONAL
    );


VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does x86-specific initialization, particularly running NTDETECT, then
    calls to the common setupldr.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG Argc = 0;
    PCHAR Argv[10];
    CHAR SetupLoadFileName[129], szOSLoadOptions[100], szOSLoadFilename[129], szOSLoadPartition[129];
    CHAR SystemPartition[129];
    ARC_STATUS Status;

    SetupLoadFileName[0] = '\0';
    szOSLoadOptions[0] = '\0';
    szOSLoadFilename[0] = '\0';
    szOSLoadPartition[0] = '\0';


    //
    // Initialize any dumb terminal that may be connected.
    //
    BlInitializeHeadlessPort();

    if (!BlBootingFromNet) {
    
        //
        // Try to read the NVRAM first. This will fail if we were
        // boot from the EFI shell, in which case we need to read
        // boot.nvr.
        //
        Status = BlGetEfiBootOptions(
                    (PUCHAR) SetupLoadFileName,
                    NULL,
                    NULL,
                    (PUCHAR) szOSLoadPartition,
                    (PUCHAR) szOSLoadFilename,
                    NULL,
                    (PUCHAR) szOSLoadOptions
                    );
        if ( Status != ESUCCESS ) {
#if DBG
            BlPrint(TEXT("Couldn't get EFI boot options\r\n"));
#endif   
            //
            // It's expected that this fails if we're booting off of CDROM
            // since there isn't any windows information in the EFI cdrom boot
            // entry
            //
            if (ElToritoCDBoot ) { 
                strcpy(SetupLoadFileName, PartitionName);
                strcat(SetupLoadFileName, "\\setupldr.efi");                
                
                //
                // the code was setting these options on a CDBOOT, but I don't
                // think these options are at all necessary.
                //
//                strcpy(szOSLoadOptions, "OSLOADOPTIONS=WINNT32" );
//                strcpy(szOSLoadFilename, "OSLOADFILENAME=\\$WIN_NT$.~LS\\IA64"  );
//                strcpy(szOSLoadPartition, "OSLOADPARTITION=" );
//                strcat(szOSLoadPartition, PartitionName);

            } else { 
                //
                // uh-oh.  no information on this build. we either guess or
                // we have to bail out.  Let's guess.
                //
                strcpy(SetupLoadFileName, "multi(0)disk(0)rdisk(0)partition(1)\\setupldr.efi");
                strcpy(szOSLoadOptions, "OSLOADOPTIONS=WINNT32" );
                strcpy(szOSLoadFilename, "OSLOADFILENAME=\\$WIN_NT$.~LS\\IA64"  );
                strcpy(szOSLoadPartition, "OSLOADPARTITION=multi(0)disk(0)rdisk(0)partition(3)" );
            }               
        }
    } else {

#if DBG               
        BlPrint(TEXT("setting os load options for PXE boot\r\n"));
#endif

        strcpy(SetupLoadFileName, PartitionName);
        strcat(SetupLoadFileName, "\\ia64\\setupldr.efi");
               
    }

    //
    // detect HAL here.
    //

    //
    // Create arguments, call off to setupldr
    //
    Argv[Argc++]=SetupLoadFileName;

    //
    // A0 processor workarounds
    //
    KiProcessorWorkAround(0);

    _strlwr(PartitionName);

    
    if( strstr(PartitionName, "rdisk") || (BlBootingFromNet) ) {        
        Argv[Argc++] = szOSLoadOptions;
        Argv[Argc++] = szOSLoadFilename;
        Argv[Argc++] = szOSLoadPartition;
    }

    //
    // System partition is needed for automated WinPE boot
    //
    strcpy(SystemPartition, "systempartition=");
    strcat(SystemPartition, PartitionName);
    Argv[Argc++] = SystemPartition;

    Status = SlInit(Argc, Argv, NULL);

    //
    // We should never return here, something
    // horrible has happened.
    //
    
    if (!BlIsTerminalConnected()) {
        //
        // typical case.  wait for user to press a key and then 
        // restart
        //
        while(!BlGetKey());
    }
    else {
        // 
        // headless case.  present user with mini sac
        //
        while(!BlTerminalHandleLoaderFailure());
    }
    ArcRestart();    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\i386\x86dtect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    detecthw.c

Abstract:

    Routines for determining which drivers/HAL need to be loaded.

Author:

    John Vert (jvert) 20-Oct-1993

Revision History:

--*/
#include "setupldr.h"


//
// NOTE: SlHalDetect() has been moved to boot\lib\i386\haldtect.c
//


VOID
SlDetectScsi(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )

/*++

Routine Description:

    SCSI detection routine for x86 machines.

Arguments:

    SetupBlock - Supplies the Setup loader block

Return Value:

    None.

--*/

{
    PVOID SifHandle;
    PCHAR p;
    ULONG LineCount,u;
    PDETECTED_DEVICE ScsiDevice;
    ULONG Ordinal;
    PCHAR ScsiFileName;
    PCHAR ScsiDescription;
    SCSI_INSERT_STATUS sis;

    extern BOOLEAN LoadScsiMiniports;

    //
    // If winnt.sif wasn't loaded, assume it's not a winnt setup
    // and therefore not unattended setup, and we detect no scsi
    // in this case on x86.
    //
    if(WinntSifHandle == NULL) {
        return;
    } else {
        SifHandle = WinntSifHandle;
    }

    //
    // If it's a floppyless setup, then the default is to load all
    // known scsi miniports. If it's not a floppyless setup,
    // the default is to load no miniports.
    //
    p = SlGetSectionKeyIndex(SifHandle,"Data","Floppyless",0);
    if(p && (*p != '0')) {

        //
        // Even if no miniport drivers are loaded, we want to indicate that
        // we "detected scsi".
        //
        SetupBlock->ScalarValues.LoadedScsi = 1;

        LineCount = SlCountLinesInSection(SifHandle,"DetectedMassStorage");
        if(LineCount == (ULONG)(-1)) {
            //
            // Section does not exist -- load all known miniports.
            // Setting this flag will cause all known miniports to be loaded
            // (see ..\setup.c).
            //
            LoadScsiMiniports = TRUE;
        } else {

            for(u=0; u<LineCount; u++) {

                if((p = SlGetSectionLineIndex(SifHandle,"DetectedMassStorage",u,0)) != NULL) {
                    //
                    // Find this adapter's ordinal within the Scsi.Load section of txtsetup.sif
                    //
                    Ordinal = SlGetSectionKeyOrdinal(InfFile, "Scsi.Load", p);
                    if(Ordinal == SL_OEM_DEVICE_ORDINAL) {
                        continue;
                    }

                    //
                    // Find the driver filename
                    //
                    ScsiFileName = SlGetSectionKeyIndex(InfFile,
                                                        "Scsi.Load",
                                                        p,
                                                        SIF_FILENAME_INDEX);
                    if(!ScsiFileName) {
                        continue;
                    }

                    //
                    // Create a new detected device entry.
                    //
                    if((sis = SlInsertScsiDevice(Ordinal, &ScsiDevice)) == ScsiInsertError) {
                        SlFriendlyError(ENOMEM, "SCSI detection", 0, NULL);
                        return;
                    }

                    if(sis == ScsiInsertExisting) {
#if DBG
                        //
                        // Sanity check to make sure we're talking about the same driver
                        //
                        if(_stricmp(ScsiDevice->BaseDllName, ScsiFileName)) {
                            SlError(400);
                            return;
                        }
#endif
                    } else {
                        //
                        // Find the driver description
                        //
                        ScsiDescription = SlGetIniValue(InfFile,
                                                        "SCSI",
                                                        p,
                                                        p);

                        ScsiDevice->IdString = p;
                        ScsiDevice->Description = ScsiDescription;
                        ScsiDevice->ThirdPartyOptionSelected = FALSE;
                        ScsiDevice->FileTypeBits = 0;
                        ScsiDevice->Files = NULL;
                        ScsiDevice->BaseDllName = ScsiFileName;
                    }
                }
            }
        }
    }
}


VOID
SlDetectVideo(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )

/*++

Routine Description:

    Video detection routine for x86 machines.

    Currently, no video detection is done on x86 machines, this just fills
    in the appropriate fields in the setuploaderblock that say "VGA"

Arguments:

    SetupBlock - Supplies the Setup loader block

Return Value:

    None.

--*/

{

    SetupBlock->VideoDevice.Next = NULL;
    SetupBlock->VideoDevice.IdString = SlCopyString(VIDEO_DEVICE_NAME);
    SetupBlock->VideoDevice.ThirdPartyOptionSelected = FALSE;
    SetupBlock->VideoDevice.FileTypeBits = 0;
    SetupBlock->VideoDevice.Files = NULL;
    SetupBlock->VideoDevice.BaseDllName = NULL;
    SetupBlock->Monitor = NULL;
    SetupBlock->MonitorId = NULL;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\no\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\nl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\pl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\psu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\ia64\parsebnvr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initia64.c

Abstract:

    Gets boot environment vars from c:\boot.nvr

    -- This will go away once we r/w the vars directly to/fro nvram

Author:

    Mudit Vats (v-muditv) 11-02-99

Revision History:

--*/
#include "parsebnvr.h"
#include "stdio.h"
#include "string.h"

#define SYSTEMPARTITION     0
#define OSLOADER            1
#define OSLOADPARTITION     2
#define OSLOADFILENAME      3
#define LOADIDENTIFIER      4
#define OSLOADOPTIONS       5
#define COUNTDOWN           6
#define AUTOLOAD            7
#define LASTKNOWNGOOD       8

#define MAXBOOTVARS         9
#define MAXBOOTVARSIZE      1024

CHAR g_szBootVars[MAXBOOTVARS][MAXBOOTVARSIZE];

CHAR szSelectKernelString[MAXBOOTVARSIZE];


VOID
BlGetBootVars( 
    IN PCHAR szBootNVR, 
    IN ULONG nLengthBootNVR 
    )
/*++

Routine Description:

    Parses the boot.txt file and determines the fully-qualified name of
    the kernel to be booted.

Arguments:
    szBootNVR      - pointer "boot.nvr" image in memory

    nLengthBootNVR - lenghth, in bytes, of szBootNVR

Return Value:

    none

--*/
{
    ULONG i=0, j;
    ULONG nbootvar;

    if (*szBootNVR == '\0') {
        //
        // No boot.nvr file, so we boot the default.
        //
        strcpy( g_szBootVars[ SYSTEMPARTITION ],  "multi(0)disk(0)rdisk(0)partition(1)" );
        strcpy( g_szBootVars[ OSLOADER        ],  "multi(0)disk(0)rdisk(0)partition(1)\\setupldr.efi" );
        strcpy( g_szBootVars[ OSLOADPARTITION ],  "multi(0)disk(0)rdisk(0)partition(2)" );
        strcpy( g_szBootVars[ OSLOADFILENAME  ],  "\\$WIN_NT$.~LS\\IA64" );
        strcpy( g_szBootVars[ LOADIDENTIFIER  ],  "Windows 2000 Setup" );
        strcpy( g_szBootVars[ OSLOADOPTIONS   ],  "WINNT32" );
        strcpy( g_szBootVars[ COUNTDOWN       ], "10" );
        strcpy( g_szBootVars[ AUTOLOAD        ], "YES" );
        strcpy( g_szBootVars[ LASTKNOWNGOOD   ], "FALSE" );
    } else {
        //
        // Get the boot vars
        //
        // BOOTVAR    ::= =<VARVALUE>
        // <VARVALUE> ::= null | {;} | <VALUE>{;} | <VALUE>;<VARVALUE>
        // 
        for( nbootvar = SYSTEMPARTITION; nbootvar<=LASTKNOWNGOOD; nbootvar++ ) {

            // read to '='
            while( (szBootNVR[i] != '=') && (i<nLengthBootNVR) )
                i++;

            // read past '='
            i++;        
            j = 0;

            // get env var from '=' to CR or ';'
            while( (szBootNVR[i] != '\r') && (szBootNVR[i] != ';') && (i<nLengthBootNVR) )
                g_szBootVars[nbootvar][j++] = szBootNVR[i++];

            g_szBootVars[nbootvar][j++] = '\0';

            // if ';' read to CR
            if( szBootNVR[i] == ';' ) {
                while( (szBootNVR[i] != '\r') && (i<nLengthBootNVR) )
                    i++;
            }
        }
    }
}


PCHAR
BlSelectKernel( 
	)
/*++

Routine Description:

    Parses the boot.txt file and determines the fully-qualified name of
    the kernel to be booted.

Arguments:


Return Value:

    Pointer to the name of a kernel to boot.

--*/

{
    sprintf( szSelectKernelString, "%s%s", g_szBootVars[OSLOADPARTITION], g_szBootVars[OSLOADFILENAME] );
    return szSelectKernelString;
}


/*++

Routine Descriptions:

    The following are access functions to GET boot env vars

Arguments:

     PCHAR XXX - where the env var is copied to


Return Value:
    
--*/
VOID
BlGetVarSystemPartition(
    OUT PCHAR szSystemPartition
    )
{
    sprintf( szSystemPartition, "SYSTEMPARTITION=%s", g_szBootVars[SYSTEMPARTITION] );
}

VOID
BlGetVarOsLoader(
    OUT PCHAR szOsLoader
    )
{
    sprintf( szOsLoader, "OSLOADER=%s", g_szBootVars[OSLOADER] );
}

VOID
BlGetVarOsLoadPartition(
    OUT PCHAR szOsLoadPartition
    )
{
    sprintf( szOsLoadPartition, "OSLOADPARTITION=%s", g_szBootVars[OSLOADPARTITION] );
}

VOID
BlGetVarOsLoadFilename(
    OUT PCHAR szOsLoadFilename
    )
{
    sprintf( szOsLoadFilename, "OSLOADFILENAME=%s", g_szBootVars[OSLOADFILENAME] );
}

VOID
BlGetVarOsLoaderShort(
    OUT PCHAR szOsLoaderShort
    )
{
    sprintf( szOsLoaderShort, "%s", g_szBootVars[OSLOADER] );
}

VOID
BlGetVarLoadIdentifier(
    OUT PCHAR szLoadIdentifier
    )
{
    sprintf( szLoadIdentifier, "LOADIDENTIFIER=%s", g_szBootVars[LOADIDENTIFIER] );
}

VOID
BlGetVarOsLoadOptions(
    OUT PCHAR szLoadOptions
    )
{
    sprintf( szLoadOptions, "OSLOADOPTIONS=%s", g_szBootVars[OSLOADOPTIONS] );
}

VOID
BlGetVarCountdown(
    OUT PCHAR szCountdown
    )
{
    sprintf( szCountdown, "COUNTDOWN=%s", g_szBootVars[COUNTDOWN] );
}

VOID
BlGetVarAutoload(
    OUT PCHAR szAutoload
    )
{
    sprintf( szAutoload, "AUTOLOAD=%s", g_szBootVars[AUTOLOAD] );
}

VOID
BlGetVarLastKnownGood(
    OUT PCHAR szLastKnownGood
    )
{
    sprintf( szLastKnownGood, "LASTKNOWNGOOD=%s", g_szBootVars[LASTKNOWNGOOD] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\pt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\ru\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\sv\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\tst\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\tr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\ia64\ia64dtect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    detecthw.c

Abstract:

    Routines for determining which drivers/HAL need to be loaded.

Author:

    John Vert (jvert) 20-Oct-1993

Revision History:

--*/
#include "setupldr.h"


//
// NOTE: SlHalDetect() has been moved to boot\lib\i386\haldtect.c
//


VOID
SlDetectScsi(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )

/*++

Routine Description:

    SCSI detection routine for x86 machines.

Arguments:

    SetupBlock - Supplies the Setup loader block

Return Value:

    None.

--*/

{
    PVOID SifHandle;
    PCHAR p;
    ULONG LineCount,u;
    PDETECTED_DEVICE ScsiDevice;
    ULONG Ordinal;
    PCHAR ScsiFileName;
    PTCHAR ScsiDescription;
    SCSI_INSERT_STATUS sis;

    extern BOOLEAN LoadScsiMiniports;

    //
    // If winnt.sif wasn't loaded, assume it's not a winnt setup
    // and therefore not unattended setup, and we detect no scsi
    // in this case on x86.
    //
    if(WinntSifHandle == NULL) {
        return;
    } else {
        SifHandle = WinntSifHandle;
    }

    //
    // If it's a floppyless setup, then the default is to load all
    // known scsi miniports. If it's not a floppyless setup,
    // the default is to load no miniports.
    //
    p = SlGetSectionKeyIndex(SifHandle,"Data","Floppyless",0);
    if(p && (*p != '0')) {

        //
        // Even if no miniport drivers are loaded, we want to indicate that
        // we "detected scsi".
        //
        SetupBlock->ScalarValues.LoadedScsi = 1;

        LineCount = SlCountLinesInSection(SifHandle,"DetectedMassStorage");
        if(LineCount == (ULONG)(-1)) {
            //
            // Section does not exist -- load all known miniports.
            // Setting this flag will cause all known miniports to be loaded
            // (see ..\setup.c).
            //
            LoadScsiMiniports = TRUE;
        } else {

            for(u=0; u<LineCount; u++) {

                if((p = SlGetSectionLineIndex(SifHandle,"DetectedMassStorage",u,0)) != 0) {
                    //
                    // Find this adapter's ordinal within the Scsi.Load section of txtsetup.sif
                    //
                    Ordinal = SlGetSectionKeyOrdinal(InfFile, "Scsi.Load", p);
                    if(Ordinal == SL_OEM_DEVICE_ORDINAL) {
                        continue;
                    }

                    //
                    // Find the driver filename
                    //
                    ScsiFileName = SlGetSectionKeyIndex(InfFile,
                                                        "Scsi.Load",
                                                        p,
                                                        SIF_FILENAME_INDEX);
                    if(!ScsiFileName) {
                        continue;
                    }

                    //
                    // Create a new detected device entry.
                    //
                    if((sis = SlInsertScsiDevice(Ordinal, &ScsiDevice)) == ScsiInsertError) {
                        SlFriendlyError(ENOMEM, "SCSI detection", 0, NULL);
                        return;
                    }

                    if(sis == ScsiInsertExisting) {
#if DBG
                        //
                        // Sanity check to make sure we're talking about the same driver
                        //
                        if(_stricmp(ScsiDevice->BaseDllName, ScsiFileName)) {
                            SlError(400);
                            return;
                        }
#endif
                    } else {
                        //
                        // Find the driver description
                        //
#ifdef UNICODE
                        ScsiDescription = SlGetIniValueW(
                                                    InfFile,
                                                    "SCSI",
                                                    p,
                                                    SlCopyStringAW(p));
#else
                        ScsiDescription = (PTCHAR)SlGetIniValue(
                                                    InfFile,
                                                    "SCSI",
                                                    p,
                                                    p);
#endif

                        ScsiDevice->IdString = p;
                        ScsiDevice->Description = ScsiDescription;
                        ScsiDevice->ThirdPartyOptionSelected = FALSE;
                        ScsiDevice->FileTypeBits = 0;
                        ScsiDevice->Files = NULL;
                        ScsiDevice->BaseDllName = ScsiFileName;
                    }
                }
            }
        }
    }
}


VOID
SlDetectVideo(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )

/*++

Routine Description:

    Video detection routine for x86 machines.

    Currently, no video detection is done on x86 machines, this just fills
    in the appropriate fields in the setuploaderblock that say "VGA"

Arguments:

    SetupBlock - Supplies the Setup loader block

Return Value:

    None.

--*/

{

    SetupBlock->VideoDevice.Next = NULL;
    SetupBlock->VideoDevice.IdString = SlCopyStringA(VIDEO_DEVICE_NAME);
    SetupBlock->VideoDevice.ThirdPartyOptionSelected = FALSE;
    SetupBlock->VideoDevice.FileTypeBits = 0;
    SetupBlock->VideoDevice.Files = NULL;
    SetupBlock->VideoDevice.BaseDllName = NULL;
    SetupBlock->Monitor = NULL;
    SetupBlock->MonitorId = NULL;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\daytona.n12\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\daytona.nui\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\hdlscom1\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\hdlscom2\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\hdlscom1.n12\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\hdlscom2.n12\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\ia64\parsebnvr.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initia64.c

Abstract:

    Gets boot environment vars from c:\boot.nvr

    -- This will go away once we r/w the vars directly to/fro nvram

Author:

    Mudit Vats (v-muditv) 11-02-99

Revision History:

--*/
#ifndef _PARSEBNVR_
#define _PARSEBNVR_

#include "ntos.h"

VOID
BlGetBootVars(
    IN PCHAR szBootNVR, 
    IN ULONG nLengthBootNVR 
    );

PCHAR
BlSelectKernel(
    );

VOID
BlGetVarSystemPartition(
    OUT PCHAR szSystemPartition
    );

VOID
BlGetVarOsLoader(
    OUT PCHAR szOsLoader
    );

VOID
BlGetVarOsLoaderShort(
    OUT PCHAR szOsLoadFilenameShort
    );

VOID
BlGetVarOsLoadPartition(
    OUT PCHAR szOsLoadPartition
    );

VOID
BlGetVarOsLoadFilename(
    OUT PCHAR szOsLoadFilename
    );

VOID
BlGetVarLoadIdentifier(
    OUT PCHAR szLoadIdentifier
    );

VOID
BlGetVarOsLoadOptions(
    OUT PCHAR szLoadOptions
    );

VOID
BlGetVarCountdown(
    OUT PCHAR szCountdown
    );

VOID
BlGetVarAutoload(
    OUT PCHAR szAutoload
    );

VOID
BlGetVarLastKnownGood(
    OUT PCHAR szLastKnownGood
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\hdlstst1.n12\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\hdlstst2.n12\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\constant.h ===
/*--

    Module Name

        constant.h

    Author

        Thomas Parslow  (tomp)

--*/

//
// Debugging Level defines
//

#ifdef DEBUG0
#define DBG0(x)     x
#define DBG1(x)
#elif defined  DEBUG1
#define DBG0(x)     x
#define DBG1(x)     x
#else
#define DBG0(x)
#define DBG1(x)
#endif

#define WAITFOREVER while(1);
#define BUGCHECK    while(1);


#define ENTRIES_PER_PAGETABLE       1024
#define PAGE_SIZE                   0x1000
#define ENABLING                    0
#define RE_ENABLING                 1



//
// Define page-table-entry bit definitions
//
//     Dir       Table
//  ----------==========
//  00000000000000000000xxxxxxxxxxxx
//                           ::::::+--- Present    = 1 - Not Present = 0
//                           :::::+---- ReadWrite  = 1 - Read only   = 0
//                           ::::+----- UserAccess = 1 - Supervisor  = 0
//                           :::+------ Reserved
//                           ::+------- Reserved
//                           :+-------- Dirty      = 1 - Not written = 0
//                           +--------- Accessed   = 1 - No accessed = 0

#define  PAGE_SUPERVISOR     0x0000
#define  PAGE_READ_ONLY      0x0000
#define  PAGE_PRESENT        0x0001
#define  PAGE_NOT_PRESENT    0x0000
#define  PAGE_READ_WRITE     0x0002
#define  PAGE_USER_ACCESS    0x0004
#define  PAGE_PERSIST        0x0200 // Tells kernel maintain
//
//  Define RWSP (Read, Write, Supervisor, Present)
//

#define  PAGE_RWSP      0L | PAGE_READ_WRITE | PAGE_SUPERVISOR | PAGE_PRESENT
#define  PAGE_ROSP      0L | PAGE_READ_ONLY | PAGE_SUPERVISOR | PAGE_PRESENT
// Since the entire boot process occurs at ring 0, the only way we can
// protext areas that we don't want trashed is too mark them not present
#define  PAGE_NO_ACCESS    0L | PAGE_READ_ONLY  | PAGE_SUPERVISOR | PAGE_NOT_PRESENT


//
// Page-entry macros
//

#define PD_Entry(x)     (USHORT)((x)>>22) & 0x3ff
#define PT_Entry(x)     (USHORT)((x)>>12) & 0x3ff
#define PAGE_Count(x)     (USHORT)((x)/PAGE_SIZE) + (((x) % PAGE_SIZE) ? 1 : 0)
#define PhysToSeg(x)    (USHORT)((x) >> 4) & 0xffff
#define PhysToOff(x)    (USHORT)((x) & 0x0f)
#define MAKE_FP(p,a)    FP_SEG(p) = (USHORT)((a) >> 4) & 0xffff; FP_OFF(p) = (USHORT)((a) & 0x0f)
#define MAKE_FLAT_ADDRESS(fp) ( ((ULONG)FP_SEG(fp) * 16 ) +  (ULONG)FP_OFF(fp) )

//
// Machine type definitions.
// N.B.  All the constants defined here
//       must match the ones defined in ntos\inc\i386.h
//

#define MACHINE_TYPE_ISA 0
#define MACHINE_TYPE_EISA 1
#define MACHINE_TYPE_MCA 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\a20.asm ===
;  NOTICE
;  This was taken from the os2 bios sources and was slightly modified to
;  enable the a20 line. There's still some work to do and much clean-up to
;  bring the file upto coding standards. I'll do this when time permits.
;  TomP


;* _EnableA20
;* Description:                                                               *
;*      This routine enables and disables the A20 address line, depending on  *
;*      the value in ax                                                       *
;*                                                                            *
;*      In general when in real mode we want the A20 line disabled,           *
;*      when in protected mode enabled. However if there is no high           *
;*      memory installed we can optimise out unnecessary switching            *
;*      of the A20 line. Unfortunately the PC/AT ROM does not allow           *
;*      us to completely decouple mode switching the 286 from gating          *
;*      the A20 line.                                                         *
;*                                                                            *
;*      In real mode we would want A20 enabled if we need to access           *
;*      high memory, for example in a device driver. We want it               *
;*      disabled while running arbitrary applications because they            *
;*      may rely on the 1 meg address wrap feature which having the           *
;*      A20 line off provides.                                                *
;*                                                                            *
;*      This code is largely duplicated from the PC/AT ROM BIOS.              *
;*      See Module "BIOS1" on page 5-155 of the PC/AT tech ref.               *
;*                                                                            *
;*      WARNING:                                                              *
;*                                                                            *
;*      The performance characteristics of these routines                     *
;*      are not well understood. There may be worst case                      *
;*      scenarios where the routine could take a relatively                   *
;*      long time to complete.                                                *
;*                                                                            *
;* Linkage:                                                                   *
;*      far call                                                              *
;*                                                                            *
;* Input:                                                                     *
;*                                                                            *
;* Exit:                                                                      *
;*      A20 line enabled/disabled                                             *
;*                                                                            *
;* Uses:                                                                      *
;*      ax                                                                    *
;*                                                                            *
;* Internal References:                                                       *
;*      empty_8042  --  waits for 8042 input buffer to drain                  *

.386p
include su.inc

IODelay macro
        jmp     $+2
        endm

extrn  _puts:near
extrn  _Empty_8042Failed:near


; Equates for cmos

CMOS_DATA       equ     71h             ; I/O word for cmos chip
SHUT_ADDR       equ     8fh             ; shutdown byte address in cmos
SHUT_CODE       equ     9               ; block copy return code we use


; equates for 8042
STATUS_PORT     equ     64h             ; 8042 com port
PORT_A          equ     60h             ; 8042 data port
BUF_FULL        equ     2               ; 8042 busy bit


SHUT_CMD        equ     0feh            ; RESET 286 command

MSW_VIRTUAL     equ     1               ; protected mode bit of MSW

MASTER_IMR      equ     21h             ; mask port for master 8259


;CONST   SEGMENT WORD USE16 PUBLIC 'CONST'
;CONST   ENDS

;_BSS   SEGMENT WORD USE16 PUBLIC 'BSS'
;_BSS   ENDS

;DGROUP  GROUP   CONST, _BSS, _DATA
;        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP


;++
;
;VOID
;EnableA20(
;    VOID
;    )
;
;Routine Description:
;
;    Enables the A20 line for any machine.  
;
;Arguments:
;
;    None
;
;Return Value:
;
;    None.
;
;    The A20 line is enabled.
;
;--
        public  _EnableA20

_EnableA20      proc    near

;            Check if empty_8042 has failed before
;            If so, skip this function.  This would occur
;            on legacy free systems.

         mov   di,offset DGROUP:_Empty_8042Failed
         cmp   byte ptr [di],1
         jz   EA2
         
;         cmp   byte ptr [di],0
        
        call    empty_8042              ; ensure 8042 input buffer empty
        jnz     EA2                     ; 8042 error return


;            Enable or disable the A20 line

        mov     al,0d1h                 ; 8042 cmd to write output port
        out     STATUS_PORT,al          ; send cmd to 8042
        call    empty_8042              ; wait for 8042 to accept cmd
        jnz     EA2                     ; 8042 error return
        mov     al,0dfh                 ; 8042 port data
        out     PORT_A,al               ; output port data to 8042
        call    empty_8042

;       We must wait for the a20 line to settle down, which (on an AT)
;       may not happen until up to 20 usec after the 8042 has accepted
;       the command.  We make use of the fact that the 8042 will not
;       accept another command until it is finished with the last one.
;       The 0FFh command does a NULL 'Pulse Output Port'.  Total execution
;       time is on the order of 30 usec, easily satisfying the IBM 8042
;       settling requirement.  (Thanks, CW!)

        mov     al,0FFh                 ;* Pulse Output Port (pulse no lines)
        out     STATUS_PORT,al          ;* send cmd to 8042
        call    empty_8042              ;* wait for 8042 to accept cmd

EA2:
        ret

_EnableA20   endp


;++
;
;VOID
;DisableA20(
;    VOID
;    )
;
;Routine Description:
;
;    Disables the A20 line for any machine. 
;
;Arguments:
;
;    None
;
;Return Value:
;
;    None.
;
;    The A20 line is disabled.
;
;--
        public  _DisableA20

_DisableA20      proc    near

;            Check if empty_8042 has failed before
;            If so, skip this function.  This would occur
;            on legacy free systems.

         mov   di,offset DGROUP:_Empty_8042Failed
         cmp   byte ptr [di],1
         jz   EA2
         
         cmp   byte ptr [di],0
            
DA1:
        call    empty_8042              ; ensure 8042 input buffer empty
        jnz     DA2                     ; 8042 error return


;            Disable the A20 line

        mov     al,0d1h                 ; 8042 cmd to write output port
        out     STATUS_PORT,al          ; send cmd to 8042
        call    empty_8042              ; wait for 8042 to accept cmd
        jnz     DA2                     ; 8042 error return
        mov     al,0ddh                 ; 8042 port data
        out     PORT_A,al               ; output port data to 8042
        call    empty_8042

;       We must wait for the a20 line to settle down, which (on an AT)
;       may not happen until up to 20 usec after the 8042 has accepted
;       the command.  We make use of the fact that the 8042 will not
;       accept another command until it is finished with the last one.
;       The 0FFh command does a NULL 'Pulse Output Port'.  Total execution
;       time is on the order of 30 usec, easily satisfying the IBM 8042
;       settling requirement.  (Thanks, CW!)

        mov     al,0FFh                 ;* Pulse Output Port (pulse no lines)
        out     STATUS_PORT,al          ;* send cmd to 8042
        call    empty_8042              ;* wait for 8042 to accept cmd

DA2:
        ret

_DisableA20   endp
;**
; empty_8042 -- wait for 8042 input buffer to drain
;
; Input:
;      interrupts disabled
;
; Exit:
;      al=0, z=0   => 8042 input buffer empty
;
; Uses:
;      ax, flags

        public  Empty8042
Empty8042     proc    near
empty_8042:
        sub     cx,cx                   ; cx = 0, timeout loop counter

emp1:   in      al,STATUS_PORT          ; read 8042 status port
        IODelay
        IODelay
        IODelay
        IODelay
        and     al,BUF_FULL             ; test buffer full bit
        loopnz  emp1

        cmp     cx,0                    ; see if buffer is full
        jnz     emp2
        

        ; if we reached this point this indicates an error
        
        mov   di,offset DGROUP:_Empty_8042Failed
        mov   byte ptr [di],1
        
        
        
;        mov     [_Empty_8042Failed],1                    ; set Empty_8042Failed global to "TRUE"
;        mov     _Empty_8042Failed,1                    ; set Empty_8042Failed global to "TRUE"
;        mov     cx, offset _Empty_8042Failed
;        mov     [cx],ah
                

emp2:
        and   al,BUF_FULL                               ; reset the Z flag
        ret

Empty8042     endp

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\makefile.inc ===
# Copyright (C) by Microsoft Corporation.
#
# MAKEFILE for NT SU.X86
#
# Created:
#               91.01.18
#
# Author:
#               Thomas Parslow
#

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

.SUFFIXES:       .com .exe .obj .lst .c .asm .def .lnk .inc


#
#       C Compiler Definitions
#       ~~~~~~~~~~~~~~~~~~~~~~

!IFDEF ALT_PROJECT_MAKE
ALT_PROJECT_FLAGS=-D$(ALT_PROJECT)
!ENDIF

PATH= $(PATH_TOOLS16);$(PATH)

CC=     cl16
CFLAGS= -WX -W3 -G2s -Zelp $(LOADER_DEBUG)  $(BLFLAGS) $(ALT_PROJECT_FLAGS)
CINC=   $(PROJECT_INC_PATH);$(SDK_INC_PATH);..\i386;..\i386\$(LANGUAGE);..\..\inc


#
#       Assembler Definitions
#       ~~~~~~~~~~~~~~~~~~~~~

ASM=    masm386
AFLAGS= -Mx  -z $(LOADER_DEBUG) $(GAFLAGS) $(ALT_PROJECT_FLAGS)
AINC=  -I\nt\public\sdk\inc -I..\i386


#
#       Linker Definitions
#       ~~~~~~~~~~~~~~~~~~

LINK=link16
LIBS=..\..\startup\long.lib
DEF=


#
#       Rules for generating objects
#       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~



{..\i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
        $(ASM) $(AFLAGS) $(AINC) $< $@;

{..\i386\}.asm.lst:
        $(ASM) -l -n $(AFLAGS) $(AINC) $<;

#        $(CC) $(CFLAGS) $(CINC) -c $<

{..\i386\}.c{$(_OBJ_DIR)\i386\}.obj:
    set INCLUDE=$(CINC)
    @echo $(CC) $(CFLAGS) -Fo$@ -c $<
    @$(CC) $(CFLAGS) -Fo$@ -c $< | findstr /v 4011
    set INCLUDE=

{..\}.c{$(_OBJ_DIR)\i386\}.obj:
    set INCLUDE=$(CINC)
    @echo $(CC) $(CFLAGS) -Fo$@ -c $<
    @$(CC) $(CFLAGS) -Fo$@ -c $< | findstr /v 4011
    set INCLUDE=

{..\i386\}.c.lst:
    set INCLUDE=$(CINC)
    $(CC) $(CFLAGS) -Fc$*.cod -Fo$*.obj -dos -c $<
    set INCLUDE=


#
#       List of object files required
#       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

OBJ= $(_OBJ_DIR)\i386\su.obj  $(_OBJ_DIR)\i386\exp.obj  $(_OBJ_DIR)\i386\sudata.obj \
$(_OBJ_DIR)\i386\eisaa.obj  $(_OBJ_DIR)\i386\a20.obj  $(_OBJ_DIR)\i386\trap.obj  $(_OBJ_DIR)\i386\eisac.obj \
$(_OBJ_DIR)\i386\main.obj  $(_OBJ_DIR)\i386\trapdump.obj $(_OBJ_DIR)\i386\display.obj \
$(_OBJ_DIR)\i386\mtftp.obj


#
#       Dependencies
#       ~~~~~~~~~~~~


$(_OBJ_DIR)\i386\startrom.com: $(OBJ)

$(_OBJ_DIR)\i386\exp.obj         exp.lst:        ..\i386\exp.asm ..\i386\su.inc ..\i386\macro.inc

$(_OBJ_DIR)\i386\eisaa.obj       eisaa.lst:      ..\i386\eisa.inc ..\i386\eisaa.asm

$(_OBJ_DIR)\i386\eisac.obj       eisac.lst:      ..\i386\eisa.h ..\i386\eisac.c

$(_OBJ_DIR)\i386\su.obj          su.lst:         ..\i386\su.asm ..\i386\su.inc

$(_OBJ_DIR)\i386\sudata.obj      sudata.lst:     ..\i386\sudata.asm ..\i386\su.inc ..\i386\memmap.inc

$(_OBJ_DIR)\i386\main.obj        main.lst:       ..\i386\main.c ..\i386\global.h ..\i386\types.h ..\i386\constant.h

$(_OBJ_DIR)\i386\trap.obj        trap.lst:       ..\i386\trap.asm ..\i386\su.inc

$(_OBJ_DIR)\i386\trapdump.obj    trapdump.lst:   ..\i386\trapdump.c ..\i386\types.h ..\i386\constant.h

$(_OBJ_DIR)\i386\display.obj     display.lst:    ..\i386\display.c ..\i386\types.h ..\i386\constant.h ..\i386\global.h

$(_OBJ_DIR)\i386\mtftp.obj       mtftp.lst:      ..\i386\mtftp.c

$(_OBJ_DIR)\i386\startrom.com: $(OBJ) $(DOBJ) $(LIBS)
        $(LINK) /tiny /nod /noi /map:full @<<
$(OBJ: = +^
)
$(_OBJ_DIR)\i386\startrom.com
startrom.map
$(LIBS)

<<

$(_OBJ_DIR)\i386\startrom.n12: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\startrom.n12

$(_OBJ_DIR)\i386\startrom.nui: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\startrom.nui

$(_OBJ_DIR)\i386\hdlscom1.com: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\hdlscom1.com

$(_OBJ_DIR)\i386\hdlscom2.com: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\hdlscom2.com

$(_OBJ_DIR)\i386\hdlscom1.n12: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\hdlscom1.n12

$(_OBJ_DIR)\i386\hdlscom2.n12: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\hdlscom2.n12

$(_OBJ_DIR)\i386\hdlstst1.n12: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\hdlstst1.n12

$(_OBJ_DIR)\i386\hdlstst2.n12: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\hdlstst2.n12
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

!ENDIF

MAJORCOMP=ntos
MINORCOMP=startrom
TARGETPATH=obj

!if $(ALPHA) || $(AXP64)

TARGETNAME=startrom
TARGETTYPE=LIBRARY

SOURCES=

!endif

!if $(IA64)

TARGETNAME=startrom
TARGETTYPE=LIBRARY

SOURCES=

!endif

!IF $(386)

TARGETNAME=startrom.com
TARGETTYPE=UMAPPL_NOLIB

INCLUDES=$(SDK_INC_PATH);..\..\inc;..\..\..\inc;..\..\..\config;..\..\..\nthals

SOURCES=

i386_SOURCES=..\i386\su.asm         \
             ..\i386\exp.asm        \
             ..\i386\sudata.asm     \
             ..\i386\eisaa.asm      \
             ..\i386\eisac.c        \
             ..\i386\main.c         \
             ..\i386\mtftp.c        \
             ..\i386\a20.asm        \
             ..\i386\trap.asm       \
             ..\i386\trapdump.c     \
             ..\i386\display.c      
!ENDIF

!IF $(386)

NTTARGETFILES=$(_OBJ_DIR)\i386\startrom.com
!IFNDEF ALT_TARGETNAME
MISCFILES=$(_OBJ_DIR)\i386\startrom.com
!ELSE
MISCFILES=$(_OBJ_DIR)\i386\$(ALT_TARGETNAME)
!ENDIF

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\eisa.inc ===
;++
;
;   Copyright (c) 1989	Microsoft Corporation
;
;   Module Name:
;
;	eisa.inc
;
;   Abstract:
;
;	This module contains the assembly structures and definitions
;       for making 16-bit real mode EISA BIOS calls.
;
;   Author:
;
;	Shie-Lin (shielint) 7-June-1991
;
;   Revision History:
;
;--

;
; EISA BIOS call function number.
;

GET_EISA_SLOT_INFORMATION     equ 0D800h
GET_EISA_FUNCTION_INFORMATION equ 0D801h

;
; Length of EISA information block
;

EISA_INFORMATION_BLOCK_LENGTH equ 320

;
; Structure for EISA slot information block
;

EISA_SLOT_INFORMATION   struc

    SlotReturn                  db      0
    SlotFlags                   db      0
    SlotMajorRevision           db      0
    SlotMinorRevision           db      0
    SlotChecksum                dw      0
    SlotNumberFunctions         db      0
    SlotFunctionInformation     db      0
    SlotCompressedId            dd      0

EISA_SLOT_INFORMATION   ends

;
; Structure for EISA function information block
;

EISA_FUNCTION_INFORMATION       struc

    FunctionReturn      db      0
    FunctionInformation db      EISA_INFORMATION_BLOCK_LENGTH dup (0)

EISA_FUNCTION_INFORMATION       ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\display.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    display.c

Author:

    Thomas Parslow (tomp) Mar-01-90

Abstract:

    Video support routines.

    The SU module only need to be able to write to the video display
    in order to report errors, traps, etc.

    The routines in this file all write to a video buffer assumed to be
    at realmode address b800:0000, and 4k bytes in length. The segment
    portion of the far pointers used to access the video buffer are stamped
    with a protmode selector value when we switch to protect mode. This is
    done in the routine "ProtMode" in "misc386.asm".


--*/

#include "su.h"


#define ZLEN_BYTE(x)  (x < 0x10)
#define ZLEN_SHORT(x) ((x < 0x10) + (x < 0x100) + (x < 0x1000))
#define ZLEN_LONG(x)  ((x < 0x10) + (x < 0x100) + (x < 0x1000) + (x < 0x10000) + (x < 0x100000)+(x < 0x1000000)+(x < 0x10000000))

#ifdef DEBUG1
#define ROWS 43
#else
#define ROWS 25
#endif
#define COLUMNS 80
#define SCREEN_WIDTH COLUMNS
#define SCREEN_SIZE ROWS * COLUMNS
#define NORMAL_ATTRIB 0x07
#define REVERSE_ATTRIB 0x70
#define SCREEN_START 0xb8000000

#define VIDEO_BIOS   0x10
#define LINES_400_CONFIGURATION  0x1202
#define SELECT_SCAN_LINE 0x301
#define SET_80X25_16_COLOR_MODE  0x3
#define LOAD_8X8_CHARACTER_SET   0x1112

//
// Internal routines
//

static
VOID
tab(
    VOID
    );

static
VOID
newline(
    VOID
    );

static
VOID
putzeros(
    USHORT,
    USHORT
    );


USHORT
Redirect = 0;

VOID
InitializeVideoSubSystem(
    VOID
    )
/*++

Routine Description:

    Initializes the video mode to 80x50 alphanumeric mode with 400 lines
    vertical resolution.

Arguments:

    None

Returns:

    Nothing


--*/

{
    BIOSREGS ps;
    UCHAR _far *BiosArea;

    //
    // Set 40:10 to indicate color is the default display
    //   *(40:10) &= ~0x30;
    //   *(40:10) |= 0x20;
    //
    // Fixes obscure situation where both monochrome and VGA adapters
    // are installed and the monochrome is the default display.
    //
    BiosArea = (UCHAR _far *)(0x410L);

    *BiosArea &= ~0x30;
    *BiosArea |= 0x20;

    //
    // Establish 80x25 alphanumeric mode with 400-lines vertical resolution
    //
    ps.fn = VIDEO_BIOS;
    ps.ax = LINES_400_CONFIGURATION;
    ps.bx = SELECT_SCAN_LINE;
    biosint(&ps);

    ps.fn = VIDEO_BIOS;
    ps.ax = SET_80X25_16_COLOR_MODE;
    biosint(&ps);

    DBG1(
        ps.ax = LOAD_8X8_CHARACTER_SET;
        ps.bx = 0;
        biosint(&ps);
    )

    //
    // HACK-O-RAMA - Make some random video BIOS calls here to make sure the
    // BIOS is initialized and warmed up and ready to go.  Otherwise,
    // some Number 9 S3 cards don't quite work right later in the game.
    //  John Vert (jvert) 9-Jun-1993
    //

    //
    // set cursor position to 0,0
    //
    ps.fn = VIDEO_BIOS;
    ps.ax = 0x2000;
    ps.bx = 0;
    ps.dx = 0;
    biosint(&ps);

    //
    // write character (' ' in this case)
    //
    ps.fn = VIDEO_BIOS;
    ps.ax = 0x0a00 | (USHORT)' ';
    ps.bx = 0;
    ps.cx = 1;
    biosint(&ps);

    clrscrn();
    return ;
}


//
// Used by all BlPrint subordinate routines for padding computations.
//

CHAR sc=0;
ULONG fw=0;



VOID
BlPrint(
    PCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex
     %b      - byte in hex

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.


Returns:

    Nothing


--*/

{
    UCHAR uc;
    USHORT b,c,w,len;
    PUCHAR ap;
    ULONG l;

    //
    // Cast a pointer to the first word on the stack
    //

    ap = (PUCHAR)&cp + sizeof(PCHAR);
    sc = ' '; // default padding char is space

    //
    // Process the arguments using the descriptor string
    //


    while (b = *cp++)
        {
        if (b == '%')
            {
            c = *cp++;

            switch (c)
                {
                case 'd':
                    puti((long)*((int *)ap));
                    ap += sizeof(int);
                    break;

                case 's':
                    puts(*((PCHAR *)ap));
                    ap += sizeof (char *);
                    break;

                case 'c':
                    putc(*((char *)ap));
                    ap += sizeof(int);
                    break;

                case 'x':
                    w = *((USHORT *)ap);
                    len = ZLEN_SHORT(w);
                    while(len--) putc('0');
                    putx((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'u':
                    putu((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'b':
                    uc = *((UCHAR *)ap);
                    len = ZLEN_BYTE(uc);
                    while(len--) putc('0');
                    putx((ULONG)uc);
                    ap += sizeof(int);
                    break;

                case 'l':
                    c = *cp++;

                switch(c) {

                    case 'u':
                        putu(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'x':
                        l = *((ULONG *)ap);
                        len = ZLEN_LONG(l);
                        while(len--) putc('0');
                        putx(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'd':
                        puti(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                }
                break;

                default :
                    putc((char)b);
                    putc((char)c);
                }
            }
        else
            putc((char)b);
        }

}

FPUCHAR vp = (FPUCHAR)SCREEN_START;
FPUCHAR ScreenStart = (FPUCHAR)SCREEN_START;

static int lcnt = 0;
static int row  = 0;


VOID puts(
    PCHAR cp
    )
/*++

Routine Description:

    Writes a string on the display at the current cursor position

Arguments:

    cp - pointer to ASCIIZ string to display.


Returns:

    Nothing



--*/


{
    char c;

    while(c = *cp++)
        putc(c);
}


//
// Write a hex short to display
//


VOID putx(
    ULONG x
    )
/*++

Routine Description:

    Writes hex long to the display at the current cursor position.

Arguments:

    x  - ulong to write.

Returns:

    Nothing


--*/

{
    ULONG j;

    if (x/16)
        putx(x/16);

    if((j=x%16) > 9) {
        putc((char)(j+'A'- 10));
    } else {
        putc((char)(j+'0'));
    }
}


VOID puti(
    LONG i
    )
/*++

Routine Description:

    Writes a long integer on the display at the current cursor position.

Arguments:

    i - the integer to write to the display.

Returns:

    Nothing


--*/


{
    if (i<0)
        {
        i = -i;
        putc((char)'-');
        }

    if (i/10)
        puti(i/10);

    putc((char)((i%10)+'0'));
}



VOID putu(
    ULONG u
    )
/*++

Routine Description:

    Write an unsigned long to display

Arguments:

    u - unsigned


--*/

{
    if (u/10)
        putu(u/10);

    putc((char)((u%10)+'0'));

}


VOID putc(
    CHAR c
    )
/*++

Routine Description:

    Writes a character on the display at the current position.

Arguments:

    c - character to write


Returns:

    Nothing


--*/

{
    switch (c)
        {
        case '\n':
            newline();
            break;

        case '\t':
            tab();
            break;

        default :
            if (FP_OFF(vp) >= (SCREEN_SIZE * 2)) {
                vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
                scroll();
            }
            *vp = c;
            vp += 2;
            ++lcnt;
      }
}


VOID newline(
    VOID
    )
/*++

Routine Description:

    Moves the cursor to the beginning of the next line. If the bottom
    of the display has been reached, the screen is scrolled one line up.

Arguments:

    None


Returns:

    Nothing


--*/

{
    vp += (SCREEN_WIDTH - lcnt)<<1;

    if (++row > ROWS-1) {

        vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
        scroll();

    }

    lcnt = 0;

}


VOID scroll(
    VOID
    )
/*++

Routine Description:

    Scrolls the display UP one line.

Arguments:

    None

Returns:

    Nothing

Notes:

    Currently we scroll the display by reading and writing directly from
    and to the video display buffer. We optionally switch to real mode
    and to int 10s

--*/

{
    USHORT i,j;
    USHORT far *p1 = (USHORT far *)ScreenStart;
    USHORT far *p2 = (USHORT far *)(ScreenStart + 2*SCREEN_WIDTH) ;

    for (i=0; i < ROWS - 1; i++)
        for (j=0; j < SCREEN_WIDTH; j++)
            *p1++ = *p2++;

    for (i=0; i < SCREEN_WIDTH; i++)
        *p1++ = REVERSE_ATTRIB*256 + ' ';

}


static
VOID tab(
    VOID
    )
/*++

Routine Description:


    Computes the next tab stop and moves the cursor to that location.


Arguments:


    None


Returns:

    Nothing

--*/

{
    int inc;

    inc = 8 - (lcnt % 8);
    vp += inc<<1;
    lcnt += inc;
}


VOID clrscrn(
    VOID
    )
/*++

Routine Description:

    Clears the video display by writing blanks with the current
    video attribute over the entire display.


Arguments:

    None

Returns:

    Nothing


--*/

{
    int i,a;
    unsigned far *vwp = (unsigned far *)ScreenStart;
    a = NORMAL_ATTRIB*256 + ' ';

    for (i = SCREEN_SIZE ; i ; i--)
        *vwp++ = a;

    row  = 0;
    lcnt = 0;
    vp = (FPUCHAR)ScreenStart;

}

// END OF FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\eisaa.asm ===
title  "EISA bus Support Assembley Code"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    eisaa.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to get configuration
;    information on EISA machines.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 7-June-1991
;
; Environment:
;
;    Real Mode 16-bit code.
;
; Revision History:
;
;
;--


.386p
        .xlist
include eisa.inc
        .list

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

        public  _FunctionInformation
_FunctionInformation     db      0
                         db      EISA_INFORMATION_BLOCK_LENGTH dup (0)

_DATA   ends

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT

;++
;
; VOID
; BtGetEisaSlotInformation (
;    PBTEISA_SLOT_INFORMATION SlotInformation,
;    UCHAR Slot
;    )
;
; Routine Description:
;
;    This function retrieves the slot information for the specified slot.
;
; Arguments:
;
;    SlotInformation - Supplies a pointer to the structure which will
;                      receive the slot information.
;
;    Slot - Specifies the slot to retrieve the information.
;
; Return Value:
;
;    None.
;
;--

BgesSlotInformation     equ     [bp + 4]
BgesSlot                equ     [bp + 6]

        public  _BtGetEisaSlotInformation
_BtGetEisaSlotInformation       proc

        push    bp                      ; The following INT 15H destroies
        mov     bp, sp                  ;   ALL the general registers.
        push    si
        push    di
        push    bx

        mov     cl, BgesSlot
        mov     ax, GET_EISA_SLOT_INFORMATION
        int     15h

        push    bx                      ; Save revision level
        mov     bx, BgesSlotInformation

        ;
        ; fill values into eisa slot info structure.
        ;

        mov     [bx].SlotReturn, ah
        mov     [bx].SlotFlags, al
        pop     ax                      ; [ax] = revision level
        mov     [bx].SlotMajorRevision, ah
        mov     [bx].SlotMinorRevision, al
        mov     [bx].SlotChecksum, cx
        mov     [bx].SlotNumberFunctions, dh
        mov     [bx].SlotFunctionInformation, dl
        mov     word ptr [bx].SlotCompressedId, di
        mov     word ptr [bx+2].SlotCompressedId, si

        pop     bx
        pop     di
        pop     si
        pop     bp
        ret

_BtGetEisaSlotInformation       endp

;++
;
; UCHAR
; BtGetEisaFunctionInformation (
;    PBTEISA_FUNCTION_INFORMATION FunctionInformation,
;    UCHAR Slot,
;    UCHAR Function
;    )
;
; Routine Description:
;
;    This function retrieves function information for the specified slot
;    and function.
;
; Arguments:
;
;    FunctionInformation - Supplies a pointer to the structure which will
;           receive the slot information.
;
;    Slot - Specifies the slot to retrieve the information.
;
;    Function - Supplies the function number of the desired slot.
;
; Return Value:
;
;    Return code of the EISA function call.
;
;--

BgefFunctionInformation equ     [bp + 4]
BgefSlot                equ     [bp + 6]
BgefFunction            equ     [bp + 8]

        public  _BtGetEisaFunctionInformation
_BtGetEisaFunctionInformation     proc

        push    bp
        mov     bp, sp
        push    si

        mov     ax, GET_EISA_FUNCTION_INFORMATION
        mov     cl, BgefSlot            ; [cl] = slot, [ch]=function
        mov     ch, BgefFunction
        mov     si, BgefFunctionInformation
                                        ; (ds:si)->Function information
        int     15h

        mov     al, ah                  ; move the return code to AL

        pop     si
        pop     bp
        ret
_BtGetEisaFunctionInformation     endp

;++
;
; BOOLEAN
; BtIsEisaSystem (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines if the target machines is EISA based machines.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    TRUE - if this is EISA machine.  Otherwise, a value of FALSE is returned.
;--

        public _BtIsEisaSystem
_BtIsEisaSystem proc

        push    es
        push    bx

;
;       Check for an EISA system.  If "EISA" is at F000:FFD9h then it
;       is an EISA system.
;

        mov     ax,0f000h               ; segment
        mov     es,ax
        mov     bx,0ffd9h               ; offset in the ROM
        mov     eax, "ASIE"
        cmp     eax, es:[bx]
        jne     short bies00            ; if ne, Not EISA system, go bies00

        mov     ax, 1                   ; set return value to TRUE
        jmp     short bies10

bies00:
        mov     ax, 0
bies10:
        pop     bx
        pop     es
        ret
_BtIsEisaSystem endp

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\eisa.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisa.h

Abstract:

    This module contains the i386 EISA bus specific header file.

Author:

    Shie-Lin Tzong (shielint) 6-June-1991

Revision History:

--*/

//
// SU module's version of the memory descriptor
//
typedef struct _MEMORY_LIST_ENTRY {
    ULONG BlockBase;
    ULONG BlockSize;
} MEMORY_LIST_ENTRY, *PMEMORY_LIST_ENTRY;


//
// SU module's version of the address space parameters for int-15 E820 calls
//

typedef struct {
    ULONG       ErrorFlag;
    ULONG       Key;
    ULONG       Size;
    struct {
        ULONG       BaseAddrLow;
        ULONG       BaseAddrHigh;
        ULONG       SizeLow;
        ULONG       SizeHigh;
        ULONG       MemoryType;
    } Descriptor;
} E820Frame;


//
// Misc. definitions
//

#define _16MEGB                  ((ULONG)16 * 1024 * 1024)
#define _64MEGB                  ((ULONG)64 * 1024 * 1024)

typedef CM_EISA_SLOT_INFORMATION BTEISA_SLOT_INFORMATION;
typedef CM_EISA_SLOT_INFORMATION *PBTEISA_SLOT_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION BTEISA_FUNCTION_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION *PBTEISA_FUNCTION_INFORMATION;
typedef EISA_MEMORY_CONFIGURATION BTEISA_MEMORY_CONFIGURATION;
typedef EISA_MEMORY_CONFIGURATION *PBTEISA_MEMORY_CONFIGURATION;

BOOLEAN
FindFunctionInformation (
    IN UCHAR SlotFlags,
    IN UCHAR FunctionFlags,
    OUT PBTEISA_FUNCTION_INFORMATION Buffer,
    IN BOOLEAN FromBeginning
    );

USHORT
CountMemoryBlocks (
    VOID
    );

ULONG
EisaConstructMemoryDescriptors (
    VOID
    );

UCHAR
BtGetEisaSlotInformation (
   PBTEISA_SLOT_INFORMATION SlotInformation,
   UCHAR Slot
   );

UCHAR
BtGetEisaFunctionInformation (
   PBTEISA_FUNCTION_INFORMATION FunctionInformation,
   UCHAR Slot,
   UCHAR Function
   );

BOOLEAN
BtIsEisaSystem (
   VOID
   );

//
// External References
//

extern MEMORY_LIST_ENTRY _far *MemoryDescriptorList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\global.h ===
/*++

Copyright (c) 1990  Microsoft Corporation


File Name:

   global.h


Abstract:

     Prototypes for all global functions defined for the 386 NT bootloader


Author

    Thomas Parslow  (TomP) 2-Jan-90



--*/


VOID
SuMain(
    IN ULONG BtBootDrive
    );

extern
USHORT
Debugger;


/////
///// IN sumain.c
/////


VOID
SetupPageTables(
    VOID
    );


//
// in Supage.c
//

extern
VOID
InitializePageTables(
    VOID
    );

VOID
ZeroMemory(
    ULONG,
    ULONG
);



USHORT DebuggerPresent;

VOID
PrintBootMessage(
    VOID
    );

/*
VOID
DoGlobalInitialization(
    IN FPVOID,
    IN FPDISKBPB,
    IN USHORT
    );


VOID
MoveMemory(
    IN ULONG,
    IN PUCHAR,
    IN USHORT
    );


/////
///// IN disk.c
/////

VOID
InitializeDiskSubSystem(
    IN FPDISKBPB,
    IN USHORT
    );

/*

VOID
InitializePageSets(
    IN PIMAGE_FILE_HEADER
    );

VOID
EnableA20(
    VOID
    );


extern IDT IDT_Table;

*/

/////
///// IN su.asm
/////


VOID
EnableProtectPaging(
    USHORT
    );


SHORT
biosint(
    IN BIOSREGS far *
    );

extern
VOID
TransferToLoader(
    ULONG
    );


/////
///// IN video.c
/////

VOID
InitializeVideoSubSystem(
    VOID
    );

VOID
putc(
    IN CHAR
    );
VOID
putu(
    IN ULONG
    );

VOID
puts(
    IN PCHAR
    );

VOID
puti(
    IN LONG
    );

VOID
putx(
    IN ULONG
    );

VOID
scroll(
    VOID
    );

VOID
clrscrn(
    VOID
    );

VOID
BlPrint(
    IN PCHAR,
    ...
    );


// END OF FILE //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\main.c ===
/*++

Copyright (c) 1991  Microsoft Corporation


Module Name:

    main.c

Abstract:

    Main for the SU (startup) module for the OS loader. The SU module
    must take the x86 from a real-mode 16bit state to a FLAT model,
    32bit protect/paging enabled state.

Author:

    Thomas Parslow (tomp) Created 20-Dec-90


Revision History:

--*/


int _acrtused = 0;

#define NTAPI

#include "su.h"
#include "eisa.h"

#define _SYS_GUID_OPERATORS_
#include <guiddef.h>
// Prevent ntimage.h from defining the COM+ IL structs and enums.  The enum
// has a value > 16 bits so the 16-bit build fails.  The startrom code doesn't
// need to know about COM+ IL.
#define __IMAGE_COR20_HEADER_DEFINED__
#include "ntimage.h"

#include "strings.h"

#include "pxe_cmn.h"
#include "pxe_api.h"
#include "undi_api.h"

#include <sdistructs.h>

extern VOID RealMode(VOID);
extern USHORT IDTregisterZero;
extern IMAGE_DOS_HEADER edata;
extern VOID MoveMemory(ULONG,ULONG,ULONG);
extern USHORT SuStackBegin;
extern UCHAR Beginx86Relocation;
extern UCHAR Endx86Relocation;
extern USHORT BackEnd;
extern ULONG FileStart;
extern BOOLEAN IsNpxPresent(VOID);
extern USHORT HwGetProcessorType(VOID);
extern USHORT HwGetCpuStepping(USHORT);
extern ULONG MachineType;
extern ULONG OsLoaderStart;
extern ULONG OsLoaderEnd;
extern ULONG ResourceDirectory;
extern ULONG ResourceOffset;
extern ULONG OsLoaderBase;
extern ULONG OsLoaderExports;
extern ULONG NetPcRomEntry;
extern ULONG BootFlags;
extern ULONG NtDetectStart;
extern ULONG NtDetectEnd;
extern ULONG SdiAddress;

extern
TurnMotorOff(
    VOID
    );

extern
EnableA20(
    VOID
    );

extern
BOOLEAN
ConstructMemoryDescriptors(
    VOID
    );

extern
USHORT
IsaConstructMemoryDescriptors(
    VOID
    );

VOID
Relocatex86Structures(
    VOID
    );

ULONG
RelocateLoaderSections(
    OUT PULONG Start,
    OUT PULONG End
    );

t_PXENV_ENTRY far *
PxenvGetEntry(
    VOID
);

BOOLEAN
PxenvVerifyEntry(
    t_PXENV_ENTRY far *entry
);

extern UINT16
PxenvApiCall(
    UINT16 service,
    void far *param
);

BOOLEAN
PxenvTftp(
);

VOID 
Reboot(
    VOID
    );

VOID 
Wait(
    IN ULONG WaitTime
    );

ULONG
GetTickCount(
    VOID
    );
    
extern
FSCONTEXT_RECORD
FsContext;

#define REVISION_NUMBER "1.1"
#define DISK_TABLE_VECTOR (0x1e*4)

VOID
SuMain(
    IN ULONG BtBootDrive
    )
/*++

Routine Description:

    Main entrypoint of the SU module. Control is passed from the boot
    sector to startup.asm which does some run-time fixups on the stack
    and data segments and then passes control here.

Arguments:

    BtBootDrive - The low byte contains the drive that we booted from (int13
        unit number). If 0x41, this is an SDI boot, and the upper three bytes
        of BtBootDrive contain the upper three bytes of the physical address
        of the SDI image (which must be page aligned)

Returns:

    Does not return. Passes control to the OS loader

--*/
{
    ULONG LoaderEntryPoint;
    ULONG EisaNumPages;
    USHORT IsaNumPages;
    MEMORY_LIST_ENTRY _far *CurrentEntry;
    IMAGE_OPTIONAL_HEADER far *OptionalHeader;
    ULONG BlockEnd;
    ULONG ImageSize;
    ULONG ImageBase;
    UCHAR bootDrive;

    //
    // Get the boot drive out of the input argument. If this is an SDI boot,
    // store the SDI address in the boot context record.
    //

    bootDrive = (UCHAR)BtBootDrive;
    if ( bootDrive == 0x41 ) {
        SdiAddress = BtBootDrive & ~(PAGE_SIZE - 1);
    }

    //
    // Save fs context info
    //
    FsContext.BootDrive = bootDrive;

    //
    // Set the NTLDR boot flags that are passed in the BootContext.
    //
#ifdef DEFAULT_BOOTFLAGS
    BootFlags = DEFAULT_BOOTFLAGS;
#endif

    //
    // Initialize the video subsystem first so that
    // errors end exceptions can be displayed.
    //

    InitializeVideoSubSystem();

    //
    // In case we booted from a floppy, turn the drive motor off.
    //

    TurnMotorOff();

    //
    // Set up machine type based on its Bus type.
    //

    if (BtIsEisaSystem()) {
        MachineType = MACHINE_TYPE_EISA;
    } else {
        MachineType = MACHINE_TYPE_ISA;
    }

    if (!ConstructMemoryDescriptors()) {
        //
        // If INT 15 E802h fails...
        //
        if (MachineType == MACHINE_TYPE_EISA) {

            //
            // HACKHACK John Vert (jvert)
            //    This is completely bogus.  Since there are a number of EISA
            //    machines which do not let you correctly configure the EISA
            //    NVRAM, and even MORE machines which are improperly configured,
            //    we first check to see how much memory the ISA routines say
            //    exists.  Then we check what the EISA routines tell us, and
            //    compare the two.  If the EISA number is much lower (where "much"
            //    is a completely random fudge factor) than the ISA number, we
            //    assume the machine is improperly configured and we throw away
            //    the EISA numbers and use the ISA ones.  If not, we assume that
            //    the machine is actually configured properly and we trust the
            //    EISA numbers..
            //

            IsaNumPages = IsaConstructMemoryDescriptors();
            EisaNumPages = EisaConstructMemoryDescriptors();
            if (EisaNumPages + 0x80 < IsaNumPages) {
                IsaConstructMemoryDescriptors();
            }

        } else {
            IsaConstructMemoryDescriptors();
        }
    }

    //
    // Search for memory descriptor describing low memory
    //
    CurrentEntry = MemoryDescriptorList;
    while ((CurrentEntry->BlockBase != 0) &&
           (CurrentEntry->BlockSize != 0)) {
        CurrentEntry++;
    }

    if ((CurrentEntry->BlockBase == 0) &&
        (CurrentEntry->BlockSize < (ULONG)512 * (ULONG)1024)) {

        BlPrint(SU_NO_LOW_MEMORY,CurrentEntry->BlockSize/1024);
        goto StartFailed;
    }

    //
    // Is this a network boot?
    //

    if (bootDrive == 0x40) {

        t_PXENV_ENTRY far *entry;

        //
        // Get the address of the NetPC ROM entry point.
        //

        entry = PxenvGetEntry( );
        if ( PxenvVerifyEntry(entry) != 0 ) {
            BlPrint( "\nUnable to verify NetPC ROM entry point.\n" );
            goto StartFailed;
        }

        FP_SEG(NetPcRomEntry) = entry->rm_entry_seg;
        FP_OFF(NetPcRomEntry) = entry->rm_entry_off;

#if 0
        //
        // Disable broadcast reception.
        //
        // chuckl: Don't do this. We added it to solve a problem with DEC cards
        // and the boot floppy, but we need to have broadcasts enabled in case
        // the server needs to ARP us. We tried enabling/disabling broadcasts
        // during the receive loop, but that seems to put Compaq cards to sleep.
        // So we need to leave broadcasts enabled. The DEC card problem will
        // have to be fixed another way.
        //

        {
            t_PXENV_UNDI_SET_PACKET_FILTER UndiSetPF;
            UndiSetPF.Status = 0;
            UndiSetPF.filter = FLTR_DIRECTED;
            if (PxenvApiCall(PXENV_UNDI_SET_PACKET_FILTER, &UndiSetPF) != PXENV_EXIT_SUCCESS) {
                BlPrint("\nSet packet filter failed.\n");
                goto StartFailed;
            }
        }
#endif
        if ( PxenvTftp() ) {
            BlPrint("\nTFTP download failed.\n");
            goto StartFailed;
        }

    }

    //
    // Enable the A20 line for protect mode
    //

    EnableA20();

    //
    // Relocate x86 structures. This includes the GDT, IDT,
    // page directory, and first level page table.
    //

    Relocatex86Structures();

    //
    // Enable protect and paging modes for the first time
    //

    EnableProtectPaging(ENABLING);

    //
    // If this is an SDI boot, copy the OS loader from the SDI image to 0x100000.
    //

    if ( bootDrive == 0x41 ) {

        int i;
        ULONG osloaderOffset;
        ULONG osloaderLength;
        SDI_HEADER *sdiHeader;
        UCHAR *sig1;
        UCHAR *sig2;

        //
        // In the code below, edata is a near pointer to the end of
        // startrom.com. Since we are using 16-bit selectors here,
        // edata is the only thing we can directly reference. FileStart
        // is a 32-bit linear pointer to edata. MoveMemory() uses this
        // pointer.
        //
        // First, copy the SDI header to edata so that we can look at it.
        // Verify that it's really an SDI image.
        //

        MoveMemory(SdiAddress,
                   FileStart,                   
                   sizeof(SDI_HEADER));

        //
        // Verify that the SDI header looks right by checking the signature.
        //

        sdiHeader = (SDI_HEADER *)&edata;

        sig1 = sdiHeader->Signature;
        sig2 = SDI_SIGNATURE;

        for ( i = 0; i < SDI_SIZEOF_SIGNATURE; i++ ) {
            if ( *sig1++ != *sig2++ ) {
                BlPrint("\nSDI image format corrupt.\n");
                goto StartFailed;
            }
        }

        //
        // Scan the TOC looking for a LOAD entry.
        //

        for ( i = 0; i < SDI_TOCMAXENTRIES; i++ ) {
            if ( sdiHeader->ToC[i].dwType == SDI_BLOBTYPE_LOAD ) {
                break;
            }
        }

        if ( i >= SDI_TOCMAXENTRIES ) {
            BlPrint("\nSDI image missing LOAD entry.\n");
            goto StartFailed;
        }

        //
        // Copy the loader to 0x100000.
        //

        osloaderOffset = (ULONG)sdiHeader->ToC[i].llOffset.LowPart;
        osloaderLength = (ULONG)sdiHeader->ToC[i].llSize.LowPart;

        MoveMemory(SdiAddress + osloaderOffset,
                   (ULONG)0x100000,
                   osloaderLength);
    }

    //
    // If this is a network boot or an SDI boot, copy the section headers from
    // the loader image (at 0x100000) down into low memory (at &edata).
    //

    if ((bootDrive == 0x40) || (bootDrive == 0x41)) {

        //
        // This is a tricky bit of code. The only pointer that can be dereferenced
        // is edata. edata is the near pointer which can be used here. FileStart is
        // the far pointer which must be passed to MoveMemory. 
        // 
        IMAGE_DOS_HEADER far *src = (IMAGE_DOS_HEADER far*)0x100000;
        IMAGE_DOS_HEADER far *dst = (IMAGE_DOS_HEADER far*)FileStart;
        
        //
        // Copy the fixed part of the header so we can find the start of the optional
        // header.
        //
        MoveMemory((ULONG)src,
                   (ULONG)dst,                   
                   sizeof(IMAGE_DOS_HEADER));

        //
        // Copy the optional header so we can find the size of all the headers
        //          
        OptionalHeader = &((IMAGE_NT_HEADERS far *) ((UCHAR far *) src + edata.e_lfanew))->OptionalHeader;
        MoveMemory((ULONG)OptionalHeader,
                   (ULONG)&((IMAGE_NT_HEADERS far *) ((UCHAR far *) dst + edata.e_lfanew))->OptionalHeader,
                   sizeof(IMAGE_OPTIONAL_HEADER));

        //
        // Now we know the size of all the headers, so just recopy the entire first chunk
        // that contains all the headers.
        ///
        MoveMemory((ULONG)src,
                   (ULONG)dst,
                   ((PIMAGE_NT_HEADERS)((PUCHAR)&edata + edata.e_lfanew))->OptionalHeader.SizeOfHeaders);

        FileStart = (ULONG)src;
    }

    //
    // Ensure there is a memory descriptor to contain osloader image
    //
    OptionalHeader = &((PIMAGE_NT_HEADERS) ((PUCHAR) &edata + edata.e_lfanew))->OptionalHeader;
    ImageBase = OptionalHeader->ImageBase;
    ImageSize = OptionalHeader->SizeOfImage;
    OsLoaderBase = ImageBase;
    OsLoaderExports = ImageBase + OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    CurrentEntry = MemoryDescriptorList;
    while (ImageSize > 0) {
        while (CurrentEntry->BlockSize != 0) {
            BlockEnd = CurrentEntry->BlockBase + CurrentEntry->BlockSize;

            if ((CurrentEntry->BlockBase <= ImageBase) &&
                (BlockEnd > ImageBase)) {

                //
                // this descriptor at least partially contains a chunk
                // of the osloader.
                //
                if (BlockEnd-ImageBase > ImageSize) {
                    ImageSize = 0;
                } else {
                    ImageSize -= (BlockEnd-ImageBase);
                    ImageBase = BlockEnd;
                }

                //
                // look for remaining part (if any) of osloader
                //
                CurrentEntry = MemoryDescriptorList;
                break;
            }
            CurrentEntry++;
        }
        if (CurrentEntry->BlockSize == 0) {
            break;
        }
    }

    if (ImageSize > 0) {
        //
        // We could not relocate the osloader to high memory.  Error out
        // and display the memory map.
        //
        BlPrint(SU_NO_EXTENDED_MEMORY);

        CurrentEntry = MemoryDescriptorList;
        while (CurrentEntry->BlockSize != 0) {
            BlPrint("    %lx - %lx\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockBase + CurrentEntry->BlockSize);

            CurrentEntry++;
        }
        goto StartFailed;
    }

    //
    // Go relocate loader sections and build page table entries
    //

    LoaderEntryPoint = RelocateLoaderSections(&OsLoaderStart, &OsLoaderEnd);

    //
    // Search for memory descriptor containing the osloader and
    // change it.
    //

    //
    // Transfer control to the OS loader
    //

    TransferToLoader(LoaderEntryPoint);

StartFailed:

    if (BootFlags & 1) { // BOOTFLAG_REBOOT_ON_FAILURE == 1 from bldr.h
        ULONG WaitTime = 5;
        BlPrint("\nRebooting in %d seconds...\n", WaitTime);
        Wait(WaitTime);
        Reboot();
    }

    WAITFOREVER
}

ULONG
RelocateLoaderSections(
    OUT PULONG Start,
    OUT PULONG End
    )
/*++

Routine Description:

    The SU module is prepended to the OS loader file. The OS loader file
    is a coff++ file. This routine computes the beginning of the OS loader
    file, then relocates the OS loader's sections as if it were just
    loading the file from disk file.

Arguments:

    Start - Returns the address of the start of the image
    End   - Returns the address of the end of the image

Returns:

    Entry point of loader


--*/
{
    USHORT Section;
    ULONG Source,Destination;
    ULONG VirtualSize;
    ULONG SizeOfRawData;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER SectionHeader;

    //
    // Make a pointer to the beginning of the loader's coff header
    //

    FileHeader = &((PIMAGE_NT_HEADERS) ((PUCHAR) &edata + edata.e_lfanew))->FileHeader;

    //
    // Validate the appended loader image by checking signatures.
    //   1st - is it an executable image?
    //   2nd - is the target environment the 386?
    //

    if ((FileHeader->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) {
        puts(SU_NTLDR_CORRUPT);
        WAITFOREVER;
    }

    if (FileHeader->Machine != IMAGE_FILE_MACHINE_I386) {
        puts(SU_NTLDR_CORRUPT);
        WAITFOREVER;
    }

    //
    // Make a pointer to the optional header in the header-buffer
    //

    OptionalHeader = (PIMAGE_OPTIONAL_HEADER)((PUCHAR)FileHeader +
        sizeof(IMAGE_FILE_HEADER));

    //
    // Make a pointer to the first section in the header buffer
    //

    SectionHeader = (PIMAGE_SECTION_HEADER)((PUCHAR)OptionalHeader +
        FileHeader->SizeOfOptionalHeader);

    *Start = OptionalHeader->ImageBase+SectionHeader->VirtualAddress;
    *End   = *Start + SectionHeader->SizeOfRawData;

    //
    // Display some debug stuff for now
    //

    DBG1(
    BlPrint("Machine = %x\n",FileHeader->Machine);
    BlPrint("NumberOfSections = %x\n",FileHeader->NumberOfSections);
    BlPrint("TimeDateStamp %lx\n",FileHeader->TimeDateStamp);
    BlPrint("PointerToSymbolTable = %lx\n",FileHeader->PointerToSymbolTable);
    BlPrint("NumberOfSymbols %lx\n",FileHeader->NumberOfSymbols);
    BlPrint("SizeOfOptionalHeader = %x\n",FileHeader->SizeOfOptionalHeader);
    BlPrint("Characteristics = %x\n",FileHeader->Characteristics);
    )

    //
    // Loop and relocate each section with a non-zero RawData size
    //

    for (Section=FileHeader->NumberOfSections ; Section-- ; SectionHeader++) {

        //
        // Compute source, destination, and count arguments
        //

        Source = FileStart  + SectionHeader->PointerToRawData;
        Destination = OptionalHeader->ImageBase + SectionHeader->VirtualAddress;

        VirtualSize = SectionHeader->Misc.VirtualSize;
        SizeOfRawData = SectionHeader->SizeOfRawData;

        if (VirtualSize == 0) {
            VirtualSize = SizeOfRawData;
        }

        if (SectionHeader->PointerToRawData == 0) {
            //
            // SizeOfRawData can be non-zero even if PointerToRawData is zero
            //

            SizeOfRawData = 0;
        } else if (SizeOfRawData > VirtualSize) {
            //
            // Don't load more from image than is expected in memory
            //

            SizeOfRawData = VirtualSize;
        }

        if (Destination < *Start) {
            *Start = Destination;
        }

        if (Destination+VirtualSize > *End) {
            *End = Destination+VirtualSize;
        }

        DBG1(BlPrint("src=%lx  dest=%lx raw=%lx\n",Source,Destination,SizeOfRawData);)

        if (SizeOfRawData != 0) {
            //
            // This section is either a code (.TEXT) section or an
            // initialized data (.DATA) section.
            // Relocate the section to memory at the virtual/physical
            // addresses specified in the section header.
            //
            MoveMemory(Source,Destination,SizeOfRawData);
        }

        if (SizeOfRawData < VirtualSize) {
            //
            // Zero the portion not loaded from the image
            //

            DBG1( BlPrint("Zeroing destination %lx\n",Destination+SizeOfRawData); )
            ZeroMemory(Destination+SizeOfRawData,VirtualSize - SizeOfRawData);
        }

        //
        // Check if this is the resource section.  If so, we need
        // to pass its location to the osloader.
        //
        if ((SectionHeader->Name[0] == '.') &&
            (SectionHeader->Name[1] == 'r') &&
            (SectionHeader->Name[2] == 's') &&
            (SectionHeader->Name[3] == 'r') &&
            (SectionHeader->Name[4] == 'c')) {
            ResourceDirectory = Destination;
            ResourceOffset = SectionHeader->VirtualAddress;
        }

        //
        // look for the .detect section that will contain the contents
        // of ntdetect.com. This is optional.
        //
        if ((SectionHeader->Name[0] == '.') &&
            (SectionHeader->Name[1] == 'd') &&
            (SectionHeader->Name[2] == 'e') &&
            (SectionHeader->Name[3] == 't') &&
            (SectionHeader->Name[4] == 'e') &&
            (SectionHeader->Name[5] == 'c') &&
            (SectionHeader->Name[6] == 't')) {
            NtDetectStart = Destination;
            NtDetectEnd = NtDetectStart + SizeOfRawData;
        }

    }

    DBG1( BlPrint("RelocateLoaderSections done - EntryPoint == %lx\n",
            OptionalHeader->AddressOfEntryPoint + OptionalHeader->ImageBase);)
    return(OptionalHeader->AddressOfEntryPoint + OptionalHeader->ImageBase);

}

VOID
Relocatex86Structures(
    VOID
    )
/*++

Routine Description:

    The gdt and idt are statically defined and imbedded in the SU modules
    data segment. This routine moves then out of the data segment and into
    a page mapped at a defined location.

Arguments:

    None

Returns:

    Nothing


--*/
{
    FPUCHAR Fpsrc, Fpdst;
    USHORT Count;

    //
    // Make pointers to the data and compute the size
    // of the block to use.
    //

    Fpsrc = (FPUCHAR)&Beginx86Relocation;
    MAKE_FP(Fpdst,SYSTEM_STRUCTS_BASE_PA);
    Count = (&Endx86Relocation - &Beginx86Relocation);

    //
    // Move the data to its new location
    //

    while (Count--) {
        *Fpdst++ = *Fpsrc++;

    }

}

VOID
DisplayArgs(
    USHORT es,
    USHORT bx,
    USHORT cx,
    USHORT dx,
    USHORT ax
    )
/*++

Routine Description:

    Just a debugging routine to dump some registers.

Arguments:

    The x86 registers es, bx, cx, dx, and ax are pushed on the stack
    before this routine is called.


Returns:

    Nothing


Environment:

    Real Mode ONLY


--*/
{
    BlPrint("ax:%x dx:%x cx:%x bx:%x es:%x\n",
                (USHORT) ax,
                (USHORT) dx,
                (USHORT) cx,
                (USHORT) bx,
                (USHORT) es);

    return;
}


//
// PxenvVerifyEntry()
//
// Description:
//  Verify that the contents of the PXENV Entry Point structure are
//  valid.
//
// Passed:
//  entry := Far pointer to PXENV Entry Point structure
//
// Returns:
//  TRUE := Structure is invalid
//  FALSE := Structure is valid
//

BOOLEAN
PxenvVerifyEntry(
    t_PXENV_ENTRY far *entry
)
{
    unsigned n;
    UINT8 cksum = 0;

    //
    // Is structure pointer NULL?
    //

    if (entry == NULL) {
        BlPrint("\nNULL PXENV Entry Point structure\n");
        return TRUE;
    }

    //
    // Is real-mode API entry point NULL?
    //

    if (!(entry->rm_entry_off | entry->rm_entry_seg)) {
        BlPrint("\nNULL PXENV API Entry Point\n");
        return TRUE;
    }

    //
    // Verify structure signature
    //

    for (n = sizeof entry->signature; n--; ) {
        if (entry->signature[n] != (UINT8)(PXENV_ENTRY_SIG[n])) {
            BlPrint("\nBad PXENV Entry Point signature\n");
            return TRUE;
        }
    }

    //
    // Verify structure signature
    //

    if (entry->length < sizeof(t_PXENV_ENTRY) ) {
        BlPrint("\nBad PXENV Entry Point size\n");
        return TRUE;
    }

    //
    // Verify structure checksum
    //

#if 0
    for (n = 0; n < entry->length; n++ ) {
        BlPrint( "%x ", ((UINT8 far *)entry)[n] );
        if ((n & 15) == 15) {
            BlPrint( "\n" );
        }
    }
#endif

    for (n = entry->length; n--; ) {
        cksum += ((UINT8 far *)entry)[n];
    }

    if (cksum) {
        BlPrint("\nBad PXENV Entry Point structure checksum\n");
        return TRUE;
    }

    return FALSE;
}


VOID 
Reboot(
    VOID
    )
/*++

Routine Description:

    Reboots the machine using the keyboard port.
    
Arguments:

    None

Returns:

    Nothing

--*/
{
    RealMode();

    __asm {
        mov     ax, 040h
        mov     ds, ax
        mov     word ptr ds:[72h], 1234h        // set location 472 to 1234 to indicate warm reboot
        mov     al, 0feh
        out     64h, al                         // write to keyboard port to cause reboot
    }
}


VOID 
Wait(
    IN ULONG WaitTime
    )
/*++

Routine Description:

    Waits for the requested number of seconds.
    
Arguments:

    WaitTime - in seconds

Returns:

    Nothing

--*/
{
    ULONG startTime = GetTickCount();
    while ( (((GetTickCount() - startTime) * 10) / 182) < WaitTime ) {
    }
}

// END OF FILE //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\macro.inc ===
;++
;
; File Name:
;
;       macro.inc
;
; Author:
;
;       Thomas Parslow [tomp]
;
; Created:
;
;       27-Feb-91
;
; Abstract:
;
;       The macros used for creating the exported entry points the
;       OS loader will use for basic h/w dependent services. These
;       services are:
;
;       o       Disk I/O
;       o       Character I/O
;
;
;--


;++
;
; EXPORT_ENTRY_MACRO
; We arrive here from the OS loader with a 32bit CS. That is, we're
; executing the code with cs:eip where cs contains a selector for a
; 32bit flat segment. We want to get to a 16bit cs. That is, cs:ip.
; The entry points are exported as 32bit near pointers to the OS loader.
; All code in the SU module is identity mapped so the flat 32bit offset
; is equal to the physical address.
;
; Therefore, we export the 32bit physical address as the
; entry point and the code may be executed with either the 32bit
; flat cs or the SU module's 16bit based cs.  Before we can switch
; modes we must load all of the segment registers with selectors for
; 16bit segments.  We start by pushing a far pointer to a label in
; the macro and then doing a retf. This allows us to fall through
; to the next instruction, but we're now executing through cs:ip
; with a 16bit CS.
;
; Output:
;
;       (ebx) = pointer to stack frame (and top of 32bit stack).
;

EXPORT_ENTRY_MACRO  macro entryname
        LOCAL    exp1
_TEXT32 segment para use32 public 'CODE'
        ASSUME CS:_TEXT32
ALIGN 4
Public  EntryName
EntryName LABEL near
;
; We've go a 32bit CS:EIP - go to a 16bit CS:IP

        push     dword ptr SuCodeSelector
        push     dword ptr (offset exp1)

        retf
_TEXT32 ends
        ASSUME CS:_TEXT
ALIGN 4
exp1:
;
; Save caller's EBP register and stack pointer (ESP)
;

        push     ebp
        push     ebx
        push     esi
        push     edi
        mov      ebx,esp
;
; Load all the segment registers with 16bit segment selectors
;
        mov      ax,SuDataSelector
        mov      ds,ax
        mov      ss,ax
;
; Set the stack to the top of the segment. We can do this now since
; all of the OS loader's code has already be relocated. Also, we need
; plenty of stack since we'll be calling BIOS routines.
;
        mov      esp,EXPORT_STACK
        push     ebx                  ; save the caller's esp
        endm
;
; EXPORT_ENTRY_MACRO end
;



;++
;
; Name:
;
;       ExportExit
;
; Arguments:
;
;
; Notes:
;
;       EAX = return code and MUST be preserved by this macro.
;
;--

EXPORT_EXIT_MACRO macro
;
; Next get caller's esp that we saved upon entry on the 16bit stack
;
        pop      ebx                    ; get caller's esp
;
; Restore flat selectors in segment registers.
;
        mov      dx,KeDataSelector
        mov      ds,dx
        mov      ss,dx
        mov      es,dx
        mov      esp,ebx


;
; Restore callers' ebp that we saved on the 32bit stack
;
        pop      edi
        pop      esi
        pop      ebx
        pop      ebp      ; (ebp) = caller's ebp

;
; Pull callers flat return address off stack and push the
; flat code selector followed by the return offset, then
; execute a far return and we'll be back in the OS loaders code space.
;
        pop      edx      ; (edx) = caller's return address
        push     dword ptr KeCodeSelector
        push     edx
        db OVERRIDE
        retf
        endm

;++
;
;
;
;--

RE_ENABLE_PAGING_MACRO macro
extrn _EnableProtectPaging:near
        push     RE_ENABLING
        call     _EnableProtectPaging
        add      sp,2
        endm

ENTER_REALMODE_MACRO macro
extrn _RealMode:near
        call    _RealMode
        endm



WAIT_FOREVER_MACRO macro
        LOCAL wf1
wf1:    jmp     wf1
        endm

;++
;
; MAKE_STACK_FRAME_MACRO
;
; Arguments:
;
;    _FrameName_ - is the name of the structure defining the
;                  stack frame layout.
;
;    _PointerRegister_ - is the register containing the linear pointer to
;                        the top of the stack frame.
; ProtectMode ONLY
;
;--

MAKE_STACK_FRAME_MACRO macro _FrameName_ , _PointerRegister_
Local msf1
        mov     ecx, (size _FrameName_)/2
        mov     esi,_PointerRegister_   ; (esi) = offset of argument frame
        add     esi,20                  ; account for ebp, ebx, esi, edi and
                                        ; return address
        push    KeDataSelector          ; (ax) = Flat 32bit segment selector
        pop     ds                      ; (ds:esi) points to argument frame
        push    ss                      ;
        pop     es                      ; (es) = 16bit stack selector
        sub     sp, size _FrameName_    ; make room for the arguments
        xor     edi,edi                 ; clear out upper 16bits of edi
        mov     di,sp                   ; (es:edi) points to top of stack
msf1:
        mov     ax,[esi]
        mov     es:[edi],ax
        add     esi,2
        add     edi,2
        loop    msf1
        push    es                      ;
        pop     ds                      ; put 16bit selector back into ds
        endm


REMOVE_STACK_FRAME_MACRO macro _FrameName_

        add     sp, size _FrameName_
        endm


;BuildDescriptor macro   Base,Limit,Access,Dpl,Stype
;        dw       (Limit AND 0ffffh)
;        dw       (Base AND 0ffffh)
;        db       ((Base SHR 16) AND 0ffh)
;        db       (Gran + Dpl + Stype)
;        db       ((Limit SHR 16) AND 0ffh)
;        db       ((Base SHR 24) AND 0ffh)
;        endm



;
;
;
RETURNCODE_IN_EAX_MACRO macro

        shl      edx,16
        mov      dx,ax
        mov      eax,edx
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\eisac.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisac.c

Abstract:

    This module implements routines to get EISA configuration information.

Author:

    Shie-Lin Tzong (shielint) 10-June-1991

Environment:

    16-bit real mode.


Revision History:

    John Vert (jvert) 5-Sep-1991
        Moved into the SU module of portable bootloader

--*/
#include "su.h"
#include "eisa.h"

//
// HACKHACK - John Vert (jvert) 12-Sep-1991
//      We have to initialize this or else it gets stuck in our BSS section
//      which is right in the middle of the osloader.exe header
//
extern BTEISA_FUNCTION_INFORMATION FunctionInformation;


BOOLEAN
FindFunctionInformation (
    IN UCHAR SlotFlags,
    IN UCHAR FunctionFlags,
    OUT PBTEISA_FUNCTION_INFORMATION Buffer,
    IN BOOLEAN FromBeginning
    )

/*++

Routine Description:

    This routine finds function information that matches the specified
    flags.  It starts, either where it left off last time, or at the
    beginning (slot 0, function 0)

Arguments:

    Flags - Flags to check against EISA function and slot information.

    Buffer - pointer to buffer to store EISA information in.

    FromBeginning - if TRUE, search starts at slot 0, function 0.
                    else continue from where it left off last time.

Return Value:

    TRUE - If the operation is success (Buffer is filled in.)
    FALSE - Request fails.

    Notes: The buffer is always changed, reguardless of the success
    of the function.  When failure is returned, the info is invalid.

--*/

{
    static UCHAR Slot=0;
    static UCHAR Function=0;
    BTEISA_SLOT_INFORMATION  SlotInformation;
    UCHAR Flags;
    UCHAR ReturnCode;

    if (FromBeginning) {
        Slot = 0;
        Function = 0;
    }
    BtGetEisaSlotInformation(&SlotInformation, Slot);
    while (SlotInformation.ReturnCode != EISA_INVALID_SLOT) {

        //
        // insure that the slot is not empty, and all of the flags are set.
        // the flags are tested by performing the following logic:
        //
        // -- (RequestSlotFlags XOR (SlotFlags AND RequestSlotFlags)) --
        //
        // if all the requested flags are set, the result will be zero
        //

        if ((SlotInformation.ReturnCode != EISA_EMPTY_SLOT) &&
            (!(SlotFlags ^ (SlotInformation.FunctionInformation & SlotFlags)))) {

            while (SlotInformation.NumberFunctions > Function) {
                ReturnCode = BtGetEisaFunctionInformation(Buffer, Slot, Function);
                Function++;

                //
                // if function call succeeded
                //

                if (!ReturnCode){

                    Flags = Buffer->FunctionFlags;

                    //
                    // Function Enable/Disable bit reversed.
                    //

                    Flags |= (~Flags & EISA_FUNCTION_ENABLED);

                    //
                    // insure that all the function flags are set.
                    // the flags are tested by performing the following logic:
                    //
                    // -- (ReqFuncFlags XOR (FuncFlags AND ReqFuncFlags)) --
                    //
                    // if all the requested flags are set, the result will
                    // be zero
                    //

                    if (!(FunctionFlags ^ (Flags & FunctionFlags))) {
                        return TRUE;
                    }
                }

            }
        }
        Slot++;
        Function = 0;
        BtGetEisaSlotInformation(&SlotInformation, Slot);
    }

    Slot = 0;
    Function = 0;
    return FALSE;
}

VOID
InsertDescriptor (
    ULONG Address,
    ULONG Size
    )

/*++

Routine Description:

    This routine inserts a descriptor into the correct place in the
    memory descriptor list.

Arguments:

    Address - Starting address of the memory block.

    Size - Size of the memory block to be inserted.

Return Value:

    None.

--*/

{
    MEMORY_LIST_ENTRY _far *CurrentEntry;

#ifdef DEBUG1
    BlPrint("Inserting descriptor %lx at %lx\n",Size,Address);
        _asm {
            push    ax
            mov     ax, 0
            int     16h
            pop     ax
        }
#endif
    //
    // Search the spot to insert the new descriptor.
    //

    CurrentEntry = MemoryDescriptorList;

    while (CurrentEntry->BlockSize > 0) {
        //
        // Check to see if this memory descriptor is contiguous with
        // the current one.  If so, coalesce them.  (yes, some machines
        // will return memory descriptors that look like this.  Compaq
        // Prosignia machines)
        //
        if (Address+Size == CurrentEntry->BlockBase) {
#ifdef DEBUG1
            BlPrint("  coalescing with descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            CurrentEntry->BlockBase = Address;
            CurrentEntry->BlockSize += Size;
#ifdef DEBUG1
            BlPrint("  new descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            break;
        }
        if (Address == (CurrentEntry->BlockBase + CurrentEntry->BlockSize)) {
#ifdef DEBUG1
            BlPrint("  coalescing with descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            CurrentEntry->BlockSize += Size;
#ifdef DEBUG1
            BlPrint("  new descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            break;
        }

        CurrentEntry++;
    }

    if (CurrentEntry->BlockSize == 0) {
        //
        // If CurrentEntry->BlockSize == 0, we  have reached the end of the list
        // So, insert the new descriptor here, and create a new end-of-list entry
        //
        CurrentEntry->BlockBase = Address;
        CurrentEntry->BlockSize = Size;

        ++CurrentEntry;
        //
        // Create a new end-of-list marker
        //
        CurrentEntry->BlockBase = 0L;
        CurrentEntry->BlockSize = 0L;
    }
#ifdef DEBUG1
    //
    // Wait for a keypress
    //
        _asm {
            push    ax
            mov     ax, 0
            int     16h
            pop     ax
        }
#endif

}

ULONG
EisaConstructMemoryDescriptors (
    VOID
    )

/*++

Routine Description:

    This routine gets the information EISA memory function above 16M
    and creates entries in the memory Descriptor array for them.

Arguments:

    None.

Return Value:

    Number of pages of usable memory.

--*/

{
    BOOLEAN Success;
    PBTEISA_MEMORY_CONFIGURATION MemoryConfiguration;
    ULONG Address;
    ULONG EndAddress;
    ULONG Size;
    ULONG MemorySize=0;
    ULONG IsaMemUnder1Mb=0xffffffff;
    MEMORY_LIST_ENTRY _far *CurrentEntry;

    //
    // HACKHACK John Vert (jvert) 5-Mar-1993
    //
    // See if there is already a memory descriptor for the 640k under
    // 1Mb.  If so, we will believe it instead of the EISA routine.  This
    // is because many EISA routines will always return 640k, even if
    // the disk parameter table is in the last 1k.  The ISA routines will
    // always account for the disk parameter tables.  If we believe the
    // EISA routines, we can overwrite the disk parameter tables, causing
    // much grief.
    //
    CurrentEntry = MemoryDescriptorList;
    while (CurrentEntry->BlockSize > 0) {
        if (CurrentEntry->BlockBase == 0) {
            //
            // found a descriptor starting at zero with a size > 0, so
            // this is the one we want to override the EISA information.
            //
            IsaMemUnder1Mb = CurrentEntry->BlockSize;
            break;
        }
        ++CurrentEntry;
    }

    //
    // Initialize the first entry in the list to zero (end-of-list)
    //

    MemoryDescriptorList->BlockSize = 0;
    MemoryDescriptorList->BlockBase = 0;

    Success = FindFunctionInformation(
                              EISA_HAS_MEMORY_ENTRY,
                              EISA_FUNCTION_ENABLED | EISA_HAS_MEMORY_ENTRY,
                              &FunctionInformation,
                              TRUE
                              );

    //
    // while there are more memory functions, and more free descriptors
    //

    while (Success) {

        MemoryConfiguration = &FunctionInformation.EisaMemory[0];

        do {

            //
            // Get physical address of the memory.
            // Note: physical address is stored divided by 100h
            //

            Address = (((ULONG)MemoryConfiguration->AddressHighByte << 16)
                      + MemoryConfiguration->AddressLowWord) * 0x100;

            //
            // Get the size of the memory block.
            // Note: Size is stored divided by 400h with the value of 0
            //       meaning a size of 64M
            //

            if (MemoryConfiguration->MemorySize) {
                Size = ((ULONG)MemoryConfiguration->MemorySize) * 0x400;
            } else {
                Size = (_64MEGB);
            }

#ifdef DEBUG1
            BlPrint("EISA memory at %lx  Size=%lx  Type=%x ",
                    Address,
                    Size,
                    MemoryConfiguration->ConfigurationByte);

            if ((MemoryConfiguration->ConfigurationByte.Type == EISA_SYSTEM_MEMORY) &&
                (MemoryConfiguration->ConfigurationByte.ReadWrite == EISA_MEMORY_TYPE_RAM) ) {

                BlPrint("  (USED BY NT)\n");
            } else {
                BlPrint("  (not used)\n");
            }
#endif

            //
            // Compute end address to determine if any part of the block
            // is above 16M
            //

            EndAddress = Address + Size;

            //
            // If it is SYSTEM memory and RAM, add the descriptor to the list.
            //

            if ((MemoryConfiguration->ConfigurationByte.Type == EISA_SYSTEM_MEMORY) &&
                (MemoryConfiguration->ConfigurationByte.ReadWrite == EISA_MEMORY_TYPE_RAM) ) {

                if (Address==0) {
                    //
                    // This is the descriptor for the memory under 1Mb.
                    // Compare it with the ISA routine's result, and see
                    // if the ISA one is smaller.  If it is, use the ISA
                    // answer.
                    //
                    if (Size > IsaMemUnder1Mb) {
                        Size = IsaMemUnder1Mb;
                    }
                }
                InsertDescriptor(Address, Size);
                MemorySize += (Size >> 12);
            }

        } while (MemoryConfiguration++->ConfigurationByte.MoreEntries);

        Success = FindFunctionInformation(
                                  EISA_HAS_MEMORY_ENTRY,
                                  EISA_FUNCTION_ENABLED | EISA_HAS_MEMORY_ENTRY,
                                  &FunctionInformation,
                                  FALSE
                                  );
    }
#ifdef DEBUG1
    //
    // Wait for a keypress
    //
        _asm {
            push    ax
            mov     ax, 0
            int     16h
            pop     ax
        }
#endif
    return(MemorySize);
}

BOOLEAN
Int15E820 (
    E820Frame       *Frame
    );


BOOLEAN
ConstructMemoryDescriptors (
    VOID
    )
/*++

Routine Description:

Arguments:


Return Value:


--*/
{
    ULONG           BAddr, EAddr;
    E820Frame       Frame;

    //
    // Initialize the first entry in the list to zero (end-of-list)
    //

    MemoryDescriptorList->BlockSize = 0;
    MemoryDescriptorList->BlockBase = 0;

    //
    // Any entries returned for E820?
    //

    Frame.Key = 0;
    Frame.Size = sizeof (Frame.Descriptor);
    Int15E820 (&Frame);
    if (Frame.ErrorFlag  ||  Frame.Size < sizeof (Frame.Descriptor)) {
        return FALSE;
    }

    //
    // Found memory in table, use the reported memory
    //

    Frame.Key = 0;
    do {
        Frame.Size = sizeof (Frame.Descriptor);
        Int15E820 (&Frame);
        if (Frame.ErrorFlag  ||  Frame.Size < sizeof (Frame.Descriptor)) {
            break ;
        }

#ifdef DEBUG1
        BlPrint("E820: %lx  %lx:%lx %lx:%lx %lx %lx\n",
            Frame.Size,
            Frame.Descriptor.BaseAddrHigh,  Frame.Descriptor.BaseAddrLow,
            Frame.Descriptor.SizeHigh,      Frame.Descriptor.SizeLow,
            Frame.Descriptor.MemoryType,
            Frame.Key
            );

            _asm {
                push    ax
                mov     ax, 0
                int     16h
                pop     ax
            }
#endif

        BAddr = Frame.Descriptor.BaseAddrLow;
        EAddr = Frame.Descriptor.BaseAddrLow + Frame.Descriptor.SizeLow - 1;

        //
        // All the processors we have right now only support 32 bits
        // If the upper 32 bits of the Base Address is non-zero, then
        // this range is entirely above the 4g mark and can be ignored
        //

        if (Frame.Descriptor.BaseAddrHigh == 0) {

            if (EAddr < BAddr) {
                //
                // address wrapped - truncate the Ending address to
                // 32 bits of address space
                //

                EAddr = 0xFFFFFFFF;
            }

            //
            // Based upon the address range descriptor type, find the
            // available memory and add it to the descriptor list
            //

            switch (Frame.Descriptor.MemoryType) {
                case 1:
                    //
                    // This is a memory descriptor
                    //

                    InsertDescriptor (BAddr, EAddr - BAddr + 1);
                    break;
            }
        }

    } while (Frame.Key) ;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\exp.asm ===
;++
;
; Module name
;
;       exp.asm
;
; Author
;
;       Thomas Parslow  (tomp)  Feb-26-91
;
; Description
;
;       Entry points exported to OS loader by SU module. Exported
;       routines provide basic machine dependent i/o funtions needed
;       by the OS loader. Providing these routines decouples the
;       OS loader from the h/w. Note that the OS loader will
;       refer to these exported routines as the "external services".
;
;
; Exported Procedures
;
;       RebootProcessor - Reboots the machine
;       GetSector - Read one or more sectors from the boot device.
;       PutChar - Puts a character on the video display.
;       GetKey - Gets a key from the keyboard
;       GetKeyEx - Gets an extended key from the keyboard or the comport (headless)
;       GetCounter - Reads the Tick Counter
;       Reboot - Transfers control to a loaded boot sector.
;       HardwareCursor - set position of hardware cursor
;       GetDateTime - gets date and time
;       ComPort - int14 functions
;       GetStallCount - calculates processor stall count
;
;
; Notes
;
;       When adding a new exported routine note that you must manually add the
;       entry's name to the BootRecord in "sudata.asm".
;
;--

include su.inc
include macro.inc

DISK_TABLE_VECTOR       equ     01Eh * 4

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP
.386p

        extrn   _DiskBaseTable:near
        extrn   _RomDiskBasePointer:near
        extrn   _EddsAddressPacket:near
        extrn   _NetPcRomEntry:near
        extrn   _EnableA20:near


;++
;
; Exported Name:
;
;       RebootProcessor
;
; Arguments:
;
;       None
;
; Description:
;
;       Reboot the processor using INT 19h
;
;
;
;--
;
; ExportEntry takes us from a 32bit cs to a 16bit cs, inits 16bit stack
; and ds segments and saves the callers esp and ebp.
;
;--

EXPORT_ENTRY_MACRO    RebootProcessor
;
; Switch to real mode so we can take interrupts
;

        ENTER_REALMODE_MACRO

;
; int 19h doesn't do what you would expect on BIOS Boot Specification machines.
; It either goes on to the next boot device or goes back to the first boot
; device. In both cases, it does not properly reset the machine. So we write
; to the keyboard port instead (as does HalpReboot).
;

        mov     ax, 040h
        mov     ds, ax
        mov     word ptr ds:[72h], 1234h        ; set location 472 to 1234 to indicate warm reboot
        mov     al, 0feh
        out     64h, al                         ; write to keyboard port to cause reboot

;
; Loop forever and wait to ctrl-alt-del (should never get here)
;

        WAIT_FOREVER_MACRO

;EXPORT_EXIT_MACRO


;++
;
; Name:
;
;       GetSector
;
; Description:
;
;       Reads the requested number of sectors from the specified drive into
;       the specified buffer.
;
; Arguments:
;
;             ULONG Virtual address into which to read data
;             ULONG Number of sectors to read
;             ULONG Physical sector number
;             ULONG Drive Number
;             ULONG Function Number
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;--

EXPORT_ENTRY_MACRO    GetSector
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetSectorFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Get the requested sectors. Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Put the buffer pointer into es:bx. Note that and buffer
; addresses passed to this routine MUST be in the lower one
; megabyte of memory to be addressable in real mode.
;

        mov      eax,[bp].BufferPointer
        mov      bx,ax
        and      bx,0fh
        shr      eax,4
        mov      es,ax
;
; Place the upper 2 bits of the 10bit track/cylinder number
; into the uppper 2 bits of the SectorNumber as reguired by
; the bios.
;
        mov      cx,word ptr [bp].TrackNumber
        xchg     ch,cl
        shl      cl,6
        add      cl,byte ptr [bp].SectorNumber

;
; Get the rest of the arguments
;
        mov      ah,byte ptr [bp].FunctionNumber
        mov      al,byte ptr [bp].NumberOfSectors
        mov      dh,byte ptr [bp].HeadNumber
        mov      dl,byte ptr [bp].DriveNumber

;
; Check to see if we are trying to reset/read/write/verify off the second
; floppy drive.  If so, we need to go change the disk-base vector.
;
        cmp     dl,1
        jne     gs3
        cmp     ah,4
        jg      gs3
        cmp     ah,0
        je      gs1
        cmp     ah,2
        jl      gs3

gs1:
;
; We need to point the BIOS disk-table vector to our own table for this
; drive.
;
        push    es
        push    bx
        push    di

        push    0
        pop     es

        mov     di, offset DGROUP:_RomDiskBasePointer

        mov     bx,es:[DISK_TABLE_VECTOR]
        mov     [di],bx
        mov     bx,es:[DISK_TABLE_VECTOR+2]
        mov     [di+2],bx

        mov     bx,offset DGROUP:_DiskBaseTable
        mov     es:[DISK_TABLE_VECTOR],bx
        mov     bx,ds
        mov     es:[DISK_TABLE_VECTOR+2],bx

        pop     di
        pop     bx
        pop     es

        int     BIOS_DISK_INTERRUPT

        push    es
        push    bx
        push    di

        push    0
        pop     es

        mov     di, offset DGROUP:_RomDiskBasePointer

        mov     bx, [di]
        mov     es:[DISK_TABLE_VECTOR],bx
        mov     bx, [di+2]
        mov     es:[DISK_TABLE_VECTOR+2],bx

        pop     di
        pop     bx
        pop     es

        jc      gs5
        xor     eax,eax
        jmp     short gs5

gs3:

;
; Call the bios to read the sector now
;
if 0
        push     ax
        push     dx
        push     cx
        push     bx
        push     es
extrn _DisplayArgs:near
        call     _DisplayArgs
        pop      es
        pop      bx
        pop      cx
        pop      dx
        pop      ax
endif

        int      BIOS_DISK_INTERRUPT
        jc       gs5

;
; Carry wasn't set so we have no error and need to "clean" eax of
; any garbage that may have been left in it.
;
        xor     eax,eax
gs5:
if 0
        push     ax
        push     dx
        push     cx
        push     bx
        push     es
extrn _DisplayArgs:near
        call     _DisplayArgs
        pop      es
        pop      bx
        pop      cx
        pop      dx
        pop      ax
endif

;
; Mask-off any garbage that my have been left in the upper
; 16bits of eax.
;
        and      eax,0000ffffh

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetSectorFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

; move cx into high 16-bits of ecx, and dx into cx.  This is so the loader
; can get at interesting values in dx, even though edx gets munged by the
; random real-mode macros.

        shl     ecx, 16
        mov     cx,dx
        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax
;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO

;++
;
; Name:
;
;       GetEddsSector
;
; Description:
;
;       Reads the requested number of sectors from the specified drive into
;       the specified buffer based on the Phoenix Enhanced Disk Drive Spec.
;
; Arguments:
;
;             ULONG xint13 function number (42 = read, 43 = write)
;             ULONG Virtual address into which to read data
;             ULONG Number of logical blocks to read (word)
;             ULONG Logical block number (High dword)
;             ULONG Logical block number (Low dword)
;             ULONG Drive Number (byte)
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;--

EXPORT_ENTRY_MACRO    GetEddsSector
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetEddsSectorFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Get the requested sectors. Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

        push     ds
        push     si
        push     bx

;
; Set up DS:SI -> Disk Address Packet
;
        push    0
        pop     ds
        mov     si, offset DGROUP:_EddsAddressPacket
        mov     ds:[si],word ptr 10h             ; Packet size = 10h, plus reserved byte
        mov     ax,word ptr [bp].NumberOfBlocks
        mov     ds:[si][2],ax                    ; Num blocks to transfer
        mov     eax,[bp].BufPointer
        mov     bx,ax
        and     bx,0fh
        mov     ds:[si][4],bx                    ; Transfer buffer address (low word=offset)
        shr     eax,4
        mov     ds:[si][6],ax                    ; Transfer buffer address (high word=segment)
        mov     eax,[bp].LBNLow
        mov     ds:[si][8],eax                   ; Starting logical block number (low dword)
        mov     eax,[bp].LBNHigh
        mov     ds:[si][12],eax                  ; Starting logical block number (high dword)

;
; Call the bios to read the sector now (DS:SI -> Disk address packet)
;
       mov      ah,byte ptr [bp].FunctionNum    ; function
       xor      al,al                           ; force verify on write off
       mov      dl,byte ptr [bp].DriveNum       ; DL = drive number
       int      BIOS_DISK_INTERRUPT
       jc       geserror1

;
; Carry wasn't set so we have no error and need to "clean" eax of
; any garbage that may have been left in it.
;
        xor      eax,eax
geserror1:

;
; Mask-off any garbage that my have been left in the upper
; 16bits of eax.
;
        and      eax,0000ffffh

        pop      bx
        pop      si
        pop      ds

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetEddsSectorFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

; move cx into high 16-bits of ecx, and dx into cx.  This is so the loader
; can get at interesting values in dx, even though edx gets munged by the
; random real-mode macros.

        shl      ecx, 16
        mov      cx,dx
        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax
;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetKey
;
; Description:
;
;       Checks the keyboard to see if a key is available.
;
; Arguments:
;
;       None.
;
; Returns:
;
;       If no key is available, returns 0
;
;       If ASCII character is available, LSB 0 is ASCII code
;                                        LSB 1 is keyboard scan code
;       If extended character is available, LSB 0 is extended ASCII code
;                                           LSB 1 is keyboard scan code
;
;--

EXPORT_ENTRY_MACRO      GetKey
;
; Go into real mode.  We still have the same stack and sp
; but we'll be executing in real mode.
;

        ENTER_REALMODE_MACRO

;
; Set up registers to call BIOS and check to see if a key is available
;

        mov     ax,0100h
        int     BIOS_KEYBOARD_INTERRUPT

        jnz     GkKeyAvail
        mov     eax, 0
        jmp     GkDone

GkKeyAvail:
;
; Now we call BIOS again, this time to get the key from the keyboard buffer
;
        mov     ax,0h
        int     BIOS_KEYBOARD_INTERRUPT
        and     eax,0000ffffh

;
; Save return code on 16bit stack
; Re-enable protect mode and paging
;
GkDone:
        push    eax
        RE_ENABLE_PAGING_MACRO
        pop     eax

;
; Return to caller and the 32-bit universe
;
EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetKeyEx
;
; Description:
;
;       Checks the keyboard to see if a (possibly extended) key is available.
;
; Arguments:
;
;       None.
;
; Returns:
;
;       If no key is available, returns 0
;
;       If ASCII character is available, LSB 0 is ASCII code
;                                        LSB 1 is keyboard scan code
;       If extended character is available, LSB 0 is extended ASCII code
;                                           LSB 1 is keyboard scan code
;
;--

        public  GetKeyEx
GetKeyEx        proc    near

IFDEF HEADLESS_SRV
;
; Give priority to Com I/O
;
        push    edi

        call    GetCounterReal   ; get starting RTC value
        mov     edi,eax          ; calculate RTC value for now + 2 secs.
        add     edi,37           ; (RTC clicks 18.2 times per second)

TopComPortRead:
        mov     ah, 03h          ; Query status
        mov     al, 0
        mov     dx, HEADLESS_COMPORT ; Com port
        int     14h

        mov     bh, ah           ; There seems to be a problem where the transmitter shift
        and     ah, 40h          ;  register status bit gets stuck on.  When this is
        jz      XmitterOk1       ;  the case, it blocks all other status bits.  To resolve it
                                 ;  we write out a NULL character

        mov     ah, 01h          ; Write character
        mov     al, 0            ; NULL character
        mov     dx, HEADLESS_COMPORT ; Com port
        int     14h

        call    GetCounterReal   ; get current RTC value
        cmp     eax, edi         ; is it higher than end value?
        jb      TopComPortRead   ; loop if current < end
        jmp     NoComPortKey

XmitterOk1:

        mov     ah, bh
        and     ah, 1            ; Data ready
        jz      NoComPortKey

        mov     ah, 02h          ; Read character
        mov     al, 0
        mov     dx, HEADLESS_COMPORT ; Com port
        int     14h

        cmp     al, 1bh          ; If this is the ESC character, process Function key (if any)
        jne     ExitComPortRead

        call    GetCounterReal   ; get starting RTC value
        mov     edi,eax          ; calculate RTC value for now + 2 secs.
        add     edi,37           ; (RTC clicks 18.2 times per second)

EscLoop:
        mov     ah, 03h          ; Query status
        mov     al, 0
        mov     dx, HEADLESS_COMPORT ; Com port
        int     14h

        mov     bh, ah           ; There seems to be a problem where the transmitter shift
        and     ah, 40h          ;  register status bit gets stuck on.  When this is
        jz      XmitterOk2       ;  the case, it blocks all other status bits.  To resolve it
                                 ;  we write out a NULL character

        mov     ah, 01h          ; Write character
        mov     al, 0            ; NULL character
        mov     dx, HEADLESS_COMPORT ; Com port
        int     14h
        jmp     EscLoop

XMitterOk2:
        mov     ah, bh
        and     ah, 1            ; Data ready
        jnz     NextKeyPressed

        call    GetCounterReal   ; get current RTC value
        cmp     eax, edi         ; is it higher than end value?
        jb      EscLoop          ; loop if current < end
        jmp     ComPortEscapeKey

NextKeyPressed:
        mov     ah, 02h          ; Read character
        mov     al, 0
        mov     dx, HEADLESS_COMPORT ; Com port
        int     14h

        cmp     al, 40h          ; '@' key
        jne     CheckMinusSign
        mov     eax, 0DA00h      ; F12 key
        jmp     GkxDone

CheckMinusSign:
        cmp     al, 21h          ; '!' key
        jne     CheckNumbers
        mov     eax, 0D900h      ; F11 key
        jmp     GkxDone

CheckNumbers:
        cmp     al, 30h
        jl      ComPortEscapeKey
        cmp     al, 39h
        jg      ComPortEscapeKey
        add     al, 10
        mov     ah, 0
        shl     eax, 8
        cmp     eax, 3a00h        ; Check for miscomputation on F10 key (aka Esc-0)
        jne     GkxDone
        mov     eax, 4400h
        jmp     GkxDone

ComPortEscapeKey:
        mov     eax, 011bh        ; ESCAPE key
        jmp     GkxDone

ExitComPortRead:
        movzx   edx, al
        mov     eax, edx
        jmp     GkxDone

NoComPortKey:

endif

;
; Set up registers to call BIOS and check to see if a key is available
;

        mov     ax,01100h
        int     BIOS_KEYBOARD_INTERRUPT

        jnz     GkxKeyAvail
        mov     eax, 0
        jmp     GkxDone

GkxKeyAvail:

;
; Now we call BIOS again, this time to get the key from the keyboard buffer
;
        mov     ax,01000h
        int     BIOS_KEYBOARD_INTERRUPT

        and     eax,0000ffffh

GkxDone:

IFDEF HEADLESS_SRV
        pop     edi
endif

        ret

GetKeyEx        endp

;++
;
; Routine Name:
;
;       GetCounter
;
; Description:
;
;       Reads the tick counter (incremented 18.2 times per second)
;
; Arguments:
;
;       None
;
; Returns:
;
;       The current value of the tick counter
;
;--

EXPORT_ENTRY_MACRO      GetCounter
;
; Go into real mode.
;

        ENTER_REALMODE_MACRO

        call    GetCounterReal

        push    eax
        RE_ENABLE_PAGING_MACRO
        pop     eax

EXPORT_EXIT_MACRO

        public  GetCounterReal
GetCounterReal proc near

        mov     ah,0
        int     01ah
        mov     ax,cx           ; high word of count
        shl     eax,16
        mov     ax,dx           ; low word of count

        ret

GetCounterReal endp

;++
;
; Routine Name:
;
;       Reboot
;
; Description:
;
;       Switches to real-mode and transfers control to a loaded boot sector
;
; Arguments:
;
;       unsigned BootType
;           0 = FAT. Just jump to 0:7c00.
;           1 = HPFS. Assumes boot code and super+spare areas (20 sectors)
;                  are already loaded at 0xd000; jumps to d00:200.
;           2 = NTFS. Assumes boot code is loaded (16 sectors) at 0xd000.
;                  Jumps to d00:256.
;           3 = SDI. Boot from downloaded SDI image. Assumes boot code
;                  (startrom.com) has been copied from the SDI image to
;                  0x7c00. Changes low byte of argument from 0x03 to 0x41
;                  to tell startrom that this is an SDI boot. The upper 3
;                  bytes of the argument are the upper 3 bytes of the
;                  page-aligned address at which the SDI image was loaded.
;
; Returns:
;       Does not return
;
; Environment:
;
;       Boot sector has been loaded at 7C00
;--

EXPORT_ENTRY_MACRO      Reboot
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <RebootFrame>, ebx
;
; Go into real mode.
;

        ENTER_REALMODE_MACRO

;
; Get the BootType argument.  Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;

        push     bp
        mov      bp,sp
        add      bp,2
        mov      edx, [bp].BootType

;
; Zero out the firmware heaps, 3000:0000 - 4000:ffff.
;

        xor     eax,eax         ; prepare for stosd
        mov     bx,3000h
        mov     es,bx
        mov     di,ax           ; es:di = physical address 30000
        mov     cx,4000h        ; cx = rep count, # dwords in 64K
        cld
        rep stosd
        mov     cx,4000h        ; rep count
        mov     es,cx           ; es:di = physical address 40000
        rep stosd

;
; Disable the A20 line.  Some things (like EMM386 and OS/2 on PS/2 machines)
; hiccup or die if we don't do this.
;

extrn   _DisableA20:near
        call    _DisableA20

;
; Put the video adapter back in 80x25 mode
;
        push    edx
        mov     ax, 0003h
        int     010h
        pop     edx

;
; Reset all the segment registers and setup the original stack
;
        mov     ax,0
        mov     ds,ax
        mov     es,ax
        mov     fs,ax
        mov     gs,ax

        mov     ax,30
        mov     ss,ax
        mov     esp,0100h
        mov     ebp,0
        mov     esi,0
        mov     edi,0

;
; Check for FAT boot or SDI boot and jump as appropriate.
;

        test    dx,-1
        jz      FatBoot

        cmp     dl,3
        je      SdiBoot

;
; Setup the registers the way the second sector of the OS/2 HPFS boot code
; expects them.  We skip the first sector entirely, as that just loads in
; the rest of the sectors.  Since the rest of the sectors are ours and not
; OS/2's, this would cause great distress.
;
        mov     ax,07c0h
        mov     ds, ax
        mov     ax, 0d00h
        mov     es, ax

        cli
        xor     ax,ax
        mov     ss,ax
        mov     sp, 07c00h
        sti

        push    0d00h
        push    0256h
        jmp     RebootDoit

;
; SDI boot. Set up to jump to startrom at 0:7c00. Change the 0x03 in DL
; to 0x41 to indicate SDI boot. Leave the upper three bytes of EDX as is.
;

SdiBoot:
        push    0
        push    07c00h
        mov     dl,041h
        jmp     RebootDoit

;
; FAT boot. Set up to jump to startup at 0:7c00. Put 0x80 in DX to indicate
; the boot drive.
;

FatBoot:
        push    0            ; set up for branch to boot sector
        push    07c00h
        mov     dx,080h

;
; And away we go!
;
RebootDoit:
        retf

        RE_ENABLE_PAGING_MACRO

        REMOVE_STACK_FRAME_MACRO  <RebootFrame>

EXPORT_EXIT_MACRO

;++
;
; Name:
;
;       HardwareCursor
;
; Description:
;
;       Positions the hardware cursor and performs other display stuff.
;
; Arguments:
;
;             ULONG Y coord (0 based)
;             ULONG X coord (0 based)
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;       If X = 0x80000000, then Y contains values that get placed into
;           ax (low word of Y) and bx (hi word of y).
;       Otherwise X,Y = coors for cursor
;
;
;--

EXPORT_ENTRY_MACRO    HardwareCursor
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <HardwareCursorFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Get the requested sectors. Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Put the row (y coord) in dh and the column (x coord) in dl.
;

        mov      eax,[bp].YCoord
        mov      edx,[bp].XCoord
        cmp      edx,80000000h
        jne      gotxy

        mov      ebx,eax
        shr      ebx,16
        jmp      doint10

    gotxy:
        mov      dh,al
        mov      ah,2
        mov      bh,0

    doint10:
        int      10h

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <HardwareCursorFrame>

;
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


;++
;
; Name:
;
;       GetDateTime
;
; Description:
;
;       Gets date and time
;
; Arguments:
;
;             ULONG Virtual address of a dword in which to place time.
;             ULONG Virtual address of a dword in which to place date.
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;--

BCD_TO_BIN  macro
    xor ah,ah
    rol ax,4
    ror al,4
    aad
endm

EXPORT_ENTRY_MACRO    GetDateTime
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetDateTimeFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Get the time
;

        mov      ah,2
        int      1ah

;
; Convert BIOS time format into our format and place in caller's dword
; bits 0-5 are the second
; bits 6-11 are the minute
; bits 12-16 are the hour
;
        xor      eax,eax
        mov      al,dh      ; BCD seconds
        BCD_TO_BIN
        movzx    edx,ax
        mov      al,cl      ; BCD minutes
        BCD_TO_BIN
        shl      ax,6
        or       dx,ax
        mov      al,ch      ; BCD hours
        BCD_TO_BIN
        shl      eax,12
        or       edx,eax

        mov      eax,[bp].TimeDword
        mov      bx,ax
        and      bx,0fh
        shr      eax,4
        mov      es,ax

        mov      es:[bx],edx

;
; Get the date
;

        mov      ah,4
        int      1ah

;
; Convert BIOS date format into our format and place in caller's dword
; bits 0-4  are the day
; bits 5-8  are the month
; bits 9-31 are the year
;

        xor     eax,eax
        mov     al,dl       ; BCD day
        BCD_TO_BIN
        mov     bl,dh
        movzx   edx,ax
        mov     al,bl       ; BCD month
        BCD_TO_BIN
        shl     ax,5
        or      dx,ax
        mov     al,cl       ; BCD year
        BCD_TO_BIN
        mov     cl,al
        mov     al,ch       ; BCD century
        BCD_TO_BIN
        mov     ah,100
        mul     ah
        xor     ch,ch
        add     ax,cx
        shl     eax,9
        or      edx,eax

        mov     eax,[bp].DateDword
        mov     bx,ax
        and     bx,0fh
        shr     eax,4
        mov     es,ax

        mov     es:[bx],edx

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetDateTimeFrame>

;
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO

;++
;
; VOID
; DetectHardware (
;    IN PDETECTION_RECORD DetectionRecord
;    )
;
; Routine Description:
;
;    This routine invokes x86 16 bit real mode detection code from
;    osloader 32 bit flat mode.
;
; Arguments:
;
;    DetectionRecord - Supplies a pointer to a detection record structure.
;
; Return Value:
;
;    None.
;
;--


EXPORT_ENTRY_MACRO    DetectHardware

;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <DetectionFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Call the Hardware Detection code
;

        push    cs
        push    offset _TEXT:DetectionDone      ; push far return addr

        push    DETECTION_ADDRESS_SEG
        push    DETECTION_ADDRESS_OFFSET
        retf

DetectionDone:

;
; Restore bp and remove stack-frame from stack
;

        REMOVE_STACK_FRAME_MACRO <DetectionFrame>

;
; No return code, so we don't save return code around page enabling code
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;

EXPORT_EXIT_MACRO

;++
;
; VOID
; ComPort (
;    IN LONG  Port,
;    IN ULONG Function,
;    IN UCHAR Arg
;    )
;
; Routine Description:
;
;    Invoke int14 on com1.
;
; Arguments:
;
;    Port - port # (0 = com1, etc).
;
;    Function - int 14 function (for ah)
;
;    Arg - arg for function (for al)
;
; Return Value:
;
;    None.
;
;--


EXPORT_ENTRY_MACRO    ComPort

;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <ComPortFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Get args and call int14
;

        mov      ah,byte ptr [bp].ComPortFunction
        mov      al,byte ptr [bp].ComPortArg
        mov      dx,word ptr [bp].ComPortPort
        int      14h

;
; Restore bp and remove stack-frame from stack
;

        pop      bp

        REMOVE_STACK_FRAME_MACRO <ComPortFrame>

;
; No return code, so we don't save return code around page enabling code
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;

EXPORT_EXIT_MACRO

;++
;
; ULONG
; GetStallCount (
;    VOID
;    )
;
; Routine Description:
;
;    Calculates how many increments are required to stall for one microsecond
;
;    The way this routine works is to set up an ISR on the BIOS vector 1C.
;    This routine will get called 18.2 times a second.  The location where
;    IP will be stored when the interrupt occurs is computed and stashed in
;    the code segment.  When the ISR fires, the IP on the stack is changed
;    to point to the next chunk of code to execute.  So we can spin in a
;    very tight loop and automatically get blown out of the loop when the
;    interrupt occurs.
;
;    This is all pretty sleazy, but it allows us to calibrate accurately
;    without relying on the 8259 or 8254 (just BIOS).  It also does not
;    depend on whether the ISR can affect the CPU registers or not.  (some
;    BIOSes, notably Olivetti, will preserve the registers for you)
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Number of increments required to stall for one microsecond
;
;--

EXPORT_ENTRY_MACRO    GetStallCount
;
; Go into real mode.
;


        ENTER_REALMODE_MACRO

        cli

        push    di
        push    si
        push    ds
        mov     ax,0
        mov     ds,ax

;
; save previous vector
;
        mov     di, 01ch*4
        mov     cx, [di]
        mov     dx, [di+2]

;
; insert our vector
;
        mov     ax, offset GscISR
        mov     [di], ax
        push    cs
        pop     ax
        mov     [di+2], ax

        mov     eax,0
        mov     ebx,0
        mov     si,sp
        sub     si,6
        mov     cs:savesp,si
        mov     cs:newip,offset GscLoop2
        sti

;
; wait for first tick.
;
GscLoop1:
        cmp     ebx,0
        je      GscLoop1

;
; start counting
;
;
; We spin in this loop until the ISR fires.  The ISR will munge the return
; address on the stack to blow us out of the loop and into GscLoop3
;
GscLoop2:
        mov     cs:newip,offset GscLoop4

GscLoop3:

        add     eax,1
        jnz     short GscLoop3

;
GscLoop4:
;
; stop counting
;

;
; replace old vector
;
        cli
        mov     [di],cx
        mov     [di+2],dx
        sti

        pop     ds
        pop     si
        pop     di
        jmp     GscDone

newip   dw      ?
savesp  dw      ?

GscISR:
;
; blow out of loop
;
        push    bp
        push    ax
        mov     bp,cs:savesp
        mov     ax,cs:newip
        mov     ss:[bp],ax
        pop     ax
        pop     bp

GscISRdone:
        iret


GscDone:
        mov     edx, eax
        mov     ecx,16
        shr     edx,cl                  ; (dx:ax) = dividend
        mov     cx,0D6A6h               ; (cx) = divisor

        div     cx

        and     eax,0ffffh
        inc     eax                     ; round loopcount up (prevent 0)

;
; Re-enable protect-mode and paging.
;
        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax

;
; Return to caller and the 32bit universe.
;

EXPORT_EXIT_MACRO


;++
;
; Routine Name:
;
;       InitializeDisplayForNt
;
; Description:
;
;       Puts the display into 50 line mode
;
; Arguments:
;
;       None
;
; Returns:
;
;       None
;
;--

EXPORT_ENTRY_MACRO      InitializeDisplayForNt
;
; Go into real mode.
;

        ENTER_REALMODE_MACRO

        mov     ax, 1112h       ; Load 8x8 font
        mov     bx, 0
        int     10h

        RE_ENABLE_PAGING_MACRO

EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetMemoryDescriptor
;
; Description:
;
;       Returns a memory descriptor
;
; Arguments:
;
;       pointer to MemoryDescriptorFrame
;
; Returns:
;
;       None
;
;--

EXPORT_ENTRY_MACRO      GetMemoryDescriptor

;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <MemoryDescriptorFramePointer>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2


        mov     eax,[bp].E820FramePointer
        mov     bp,ax
        and     bp,0fh
        shr     eax,4
        mov     es,ax                   ; (es:bp) = E820 Frame

        mov     ebx, es:[bp].Key
        mov     ecx, es:[bp].DescSize
        lea     di, [bp].BaseAddrLow
        mov     eax, 0E820h
        mov     edx, 'SMAP'             ; (edx) = signature

        INT     15h
        mov     es:[bp].Key, ebx        ; update callers ebx
        mov     es:[bp].DescSize, ecx   ; update callers size

        sbb     ecx, ecx                ; ecx = -1 if carry, else 0
        sub     eax, 'SMAP'             ; eax = 0 if signature matched
        or      ecx, eax
        mov     es:[bp].ErrorFlag, ecx  ; return 0 or non-zero

;
; Restore bp and remove stack-frame from stack
;

        pop     bp
        REMOVE_STACK_FRAME_MACRO <MemoryDescriptorFramePointer>
        RE_ENABLE_PAGING_MACRO

EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetElToritoStatus
;
; Description:
;
;       Get El Torito Disk Emulation Status
;
; Arguments:
;
;       None
;
; Returns:
;
;       None
;
;--

EXPORT_ENTRY_MACRO      GetElToritoStatus
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetElToritoStatusFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2

        push    dx
        push    bx
        push    ds
        push    si

;
; Put the Specification Packet pointer into DS:SI, and the Drive
; Number on DL. Note that and buffer
; addresses passed to this routine MUST be in the lower one
; megabyte of memory to be addressable in real mode.
;

        mov     eax,[bp].SpecPacketPointer
        mov     bx,ax
        and     bx,0fh
        mov     si,bx
        shr     eax,4
        mov     ds,ax

        mov     dl,byte ptr [bp].ETDriveNum

        mov     ax,04B01h                       ; Function = Return Disk Emulation status
        int     BIOS_DISK_INTERRUPT

        jc      etstatuserr

;
; Carry wasn't set so we have no error and need to "clean" eax of
; any garbage that may have been left in it.
;
        xor     eax,eax

etstatuserr:
;
; Mask-off any garbage that my have been left in the upper
; 16bits of eax.
;
        and     eax,0000ffffh

        pop     si
        pop     ds
        pop     bx
        pop     dx

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetElToritoStatusFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


;++
;
; Routine Name:
;
;       GetExtendedInt13Params
;
; Description:
;
;       Determine if extended int13 services are available for a drive
;       and if so retrieve extended disk parameters.
;
; Arguments:
;
;       - 32-bit flat pointer to 26-byte param packet filled by this routine
;
;       - int 13 unit number
;
; Returns:
;
;       ax = 0 means extended int13 not supported on the given drive
;       ax = 1 means extended int13 supported and param packet filled in
;
;--

EXPORT_ENTRY_MACRO      GetExtendedInt13Params
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetExtendedInt13ParamsFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2

        push    dx
        push    bx
        push    ds
        push    si

;
; Check for support for this drive.
;
        mov     ah,41h
        mov     bx,55aah
        mov     dl,byte ptr [bp].Int13UnitNumber
        int     BIOS_DISK_INTERRUPT
        jc      noxint13                        ; carry set means no xint13
        cmp     bx,0aa55h                       ; check signature
        jnz     noxint13                        ; not present, no xint13
        test    cl,1                            ; bit 0 clear means no xint13
        jz      noxint13

;
; If we get here it looks like we have xint13 support.
; Some BIOSes are broken though so we do some validation while we're
; asking for the extended int13 drive parameters for the drive.
; Note that and buffer addresses passed to this routine
; MUST be in the lower one megabyte of memory to be addressable in real mode.
;
        mov     eax,[bp].ParamPacketPointer
        mov     bx,ax
        and     bx,0fh
        mov     si,bx
        shr     eax,4
        mov     ds,ax                           ; DS:SI -> param packet
        mov     word ptr [si],26                ; initialize packet with size
                                                ; some bioses helpfully zero out
                                                ; the whole buffer according to
                                                ; this size, so make SURE the
                                                ; entire word is initialized and
                                                ; there's no junk in the high byte.

        mov     dl,byte ptr [bp].Int13UnitNumber
        mov     ah,48h
        int     BIOS_DISK_INTERRUPT
        jc      noxint13
;
; If we get here then everything's cool and we have xint13 parameters.
; We also know carry isn't set.
;
        mov     al,1
        jnc     xint13done

noxint13:
        xor     al,al

xint13done:
        movzx   eax,al

        pop     si
        pop     ds
        pop     bx
        pop     dx

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetExtendedInt13ParamsFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


;++
;
; ULONG
; NetPcRomServices (
;    ULONG FunctionNumber
;    PVOID CommandPacket
;    )
;
; Routine Name:
;
;       NetPcRomServices
;
; Description:
;
;       Invoke a NetPC ROM service
;
; Arguments:
;
;       FunctionNumber - NetPC ROM function number
;       CommandPacket - 32-bit flat pointer to command packet (must be in
;                       low megabyte of physical memory)
;
; Returns:
;
;       NetPC ROM status code
;
;--

EXPORT_ENTRY_MACRO      NetPcRomServices
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <NetPcRomServicesFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2

;
; Put the CommandPacket pointer into ES:DI, and the Function Number into BX.
;

        mov     eax,dword ptr [bp].NetPcRomCommandPacketPointer
        mov     bx,ax
        and     bx,0fh
        mov     di,bx
        shr     eax,4
        mov     es,ax

        mov     bx,word ptr [bp].NetPcRomFunctionNumber

        push    ds

        lds     si,dword ptr _NetPcRomEntry
        mov     ax,ds
        shl     eax,16
        mov     ax,si

        push    cs
        push    offset _TEXT:RomServiceDone

        push    ds
        push    si

if 0
        push    ds
        push    si
        push    0b800h
        pop     ds
        mov     si, 20*(80*2)+(2*40)
        mov     byte ptr ds:[si],02bh
        pop     si
        pop     ds
endif

        retf

RomServiceDone:

if 0
        push    ds
        push    si
        push    0b800h
        pop     ds
        mov     si, 20*(80*2)+(2*40)
        mov     byte ptr ds:[si],02dh
        pop     si
        pop     ds
endif

        pop     ds

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <NetPcRomServicesFrame>

;
; Save return code on 16bit stack.  Turn the A20 gate back on,
; in case the BIOS turned it off in int 15h, op 87h.
; Re-enable protect-mode and paging.
;

        push     eax

        cli
        call    _EnableA20
        sti

        RE_ENABLE_PAGING_MACRO

        pop      eax

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO



;++
;
; ULONG
; BiosRedirectService (
;    ULONG Command
;    )
;
; Routine Name:
;
;       BiosRedirectService
;
; Description:
;
;       Get parameters of bios redirection.
;
; Arguments:
;
;       Command - 1: Get Com Port Number
;                 2: Get Baud Rate
;                 3: Get Parity
;                 4: Get Stop Bits
;
; Returns:
;
;       Value, or -1 if an error.
;
;--

EXPORT_ENTRY_MACRO      BiosRedirectService
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <BiosRedirectServiceFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2


;
; Get the Command and do it.
;

        mov     eax,dword ptr [bp].Command

        cmp     eax, 1
        je      GetComPort

        cmp     eax, 2
        je      GetBaudRate

        cmp     eax, 3
        je      GetParity

        cmp     eax, 4
        je      GetStopBits

        mov     eax, -1
        jmp     Done



GetStopBits:
        mov     eax, 1
        jmp     Done

GetParity:
        mov     eax, 0
        jmp     Done

GetBaudRate:
IFDEF HDLS_HISPEED
        mov     eax, 115200
else
        mov     eax, 9600
endif
        jmp     Done

GetComPort:
IFDEF HEADLESS_SRV
        mov     eax, HEADLESS_COMPORT
        add     eax, 1
else
        mov     eax, -1
endif

Done:

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <BiosRedirectServiceFrame>

;
; Save return code on 16bit stack.  Turn the A20 gate back on,
; in case the BIOS turned it off in int 15h, op 87h.
; Re-enable protect-mode and paging.
;

        push     eax

        cli
        call    _EnableA20
        sti

        RE_ENABLE_PAGING_MACRO

        pop      eax
;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\memmap.inc ===
PAGE_DIR_ADDRESS        equ     99000h
PAGE_TABLE_ADDRESS      equ     9A000h

;;
;; Address Mappings
;;


PhysAddressVideo        equ     0b8000h
PhysSizeVideo           equ     2000h

SYSTEM_PAGE_PA          equ     17000h
SYSTEM_PAGE_VA          equ     80420000h
GDT_LOC                 equ     0
IDT_LOC                 equ     400h
TSS_LOC                 equ     0C00h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\memmap.h ===
//
// The following memory address definitions apply to
// indentity mapped objects for the x86 environment.
//

#define RM_PROTECT_BASE_VA          0x000000
#define RM_PROTECT_BASE_PA          0x000000
#define RM_PROTECT_SIZE             0x001000
#define RM_PROTECT_ATTRIBUTES       PAGE_ROSP

#define BPB_BASE_VA                 0x007000
#define BPB_BASE_PA                 0x007000
#define BPB_SIZE                    0x001000
#define BPB_ATTRIBUTES              PAGE_ROSP

#define SU_MODULE_BASE_VA           0x020000
#define SU_MODULE_BASE_PA           0x020000
#define SU_MODULE_SIZE              0x020000
#define SU_MODULE_ATTRIBUTES        PAGE_RWSP

#define LOADER_BASE_VA              0x040000
#define LOADER_BASE_PA              0x040000
#define LOADER_SIZE                 0x020000
#define LOADER_ATTRIBUTES           PAGE_RWSP

#define SYSTEM_STRUCTS_BASE_VA      0x80420000
#define SYSTEM_STRUCTS_BASE_PA      0x00017000
#define SYSTEM_STRUCTS_SIZE         0x002000
#define SYSTEM_STRUCTS_ATTRIBUTES   PAGE_RWSP + PAGE_PERSIST

#define PAGE_TABLE_AREA_BASE_VA     0x00099000
#define PAGE_TABLE_AREA_BASE_PA     0x00099000
#define PAGE_TABLE_AREA_SIZE        0x002000
#define PAGE_TABLE_AREA_ATTRIBUTES  PAGE_RWSP + PAGE_PERSIST

#define LDR_STACK_BASE_VA           0x09b000
#define LDR_STACK_BASE_PA           0x09b000
#define LDR_STACK_SIZE              0x001000
#define LDR_STACK_ATTRIBUTES        PAGE_RWSP
#define LDR_STACK_POINTER           0x09bffe // in su.inc also

#define VIDEO_BUFFER_BASE_VA        0x0B8000
#define VIDEO_BUFFER_BASE_PA        0x0B8000
#define VIDEO_BUFFER_SIZE           0x004000
#define VIDEO_BUFFER_ATTRIBUTES     PAGE_RWSP


#define HYPER_PAGE_DIRECTORY        0xC0300C00
#define HYPER_SPACE_BEGIN           0xC0000000  // points to 1st page table
#define HYPER_SPACE_SIZE            0x8000L
#define HYPER_SPACE_ENTRY           768
#define PAGE_TABLE1_ADDRESS         0xC0000000L
#define PD_PHYSICAL_ADDRESS         PAGE_TABLE_AREA_BASE_PA  // in su.inc also.
#define PT_PHYSICAL_ADDRESS         PAGE_TABLE_AREA_BASE_PA + PAGE_SIZE
#define VIDEO_ENTRY                 0xB8

/*



Switching to Realmode
~~~~~~~~~~~~~~~~~~~~~

When switching to realmode "sp" will be initialized to
0xfffe and (ss) will be set to the base of the SU module's
data segment. This has several effects.

 1) The stack will remain withing the 0x20000 - 0x3ffff range
    reserved for the original SU module and loader image prior to
    relocation, and since the loader will already have been relocated
    it is no longer necessary to preserve this area.

 2) This will preserve the SU module's small model character which
    requires that offsets can be used interchangably through (ss) or (ds).

 3) This allows for the maximum stack size for small model apps (which is
    what the SU module is). Bios calls should not be tromping on any
    data or code while in realmode.

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\ntmisc.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ntmisc.h

Abstract:

    This module contains the misc. definitions in \nt\public\sdk\inc
    directory.  Note, we created this file because ntdetect uses 16 bit
    compiler and various new C compiler switches/pragamas are not recognized
    by the 16 bit C compiler.

Author:

    Shie-Lin Tzong (shielint) 11-Nov-1992


Revision History:


--*/
//
// PHYSICAL_ADDRESS
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

//
// Note all the definitions defined below are used to make compiler shut up.
// Ntdetect.com does not rely on the correctness of the structures.
//

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY far *Flink;
   struct _LIST_ENTRY far *Blink;
} LIST_ENTRY, far *PLIST_ENTRY;

#define PTIME_FIELDS    PVOID


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\pxe_cmn.inc ===
;
; Modifications:   $Header:   W:/LCS/ARCHIVES/preboot/lsa2/base/iputil.asv   1.3   Apr 04 1997 10:05:58   GRGUSTAF  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;


;* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;* Result codes returned in AX by a PXE API service.
;*
PXENV_EXIT_SUCCESS	equ	0
PXENV_EXIT_FAILURE	equ	1
PXENV_EXIT_CHAIN		equ	0FFFFh	; used internally


;* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;* CPU types
;*
PXENV_CPU_X86		equ	0
PXENV_CPU_ALPHA		equ	1
PXENV_CPU_PPC		equ	2


;* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;* Bus types
;*
PXENV_BUS_ISA		equ	0
PXENV_BUS_EISA		equ	1
PXENV_BUS_MCA		equ	2
PXENV_BUS_PCI		equ	3
PXENV_BUS_VESA		equ	4
PXENV_BUS_PCMCIA		equ	5


;* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;* Status codes returned in the status word of PXE API parameter structures.
;*
PXENV_STATUS_SUCCESS	equ	0
PXENV_STATUS_FAILURE	equ	1	; general failure
PXENV_STATUS_BAD_FUNC	equ	2	; invalid function number
PXENV_STATUS_UNSUPPORTED equ	3	; Function is not yet supported. 
PXENV_STATUS_1A_HOOKED	 equ	4	; Int 1Ah cannot be unhooked. 


; ARP errors 
PXENV_STATUS_ARP_TIMEOUT			equ 11h

; TFTP errors 
PXENV_STATUS_TFTP_CANNOT_ARP_ADDRESS	equ 30h
PXENV_STATUS_TFTP_OPEN_TIMEOUT			equ 32h
PXENV_STATUS_TFTP_UNKNOWN_OPCODE		equ 33h
PXENV_STATUS_TFTP_ERROR_OPCODE			equ 34h
PXENV_STATUS_TFTP_READ_TIMEOUT			equ 35h
PXENV_STATUS_TFTP_WRITE_TIMEOUT			equ 37h
PXENV_STATUS_TFTP_CANNOT_OPEN_CONNECTION		equ 38h
PXENV_STATUS_TFTP_CANNOT_READ_FROM_CONNECTION	equ 39h
PXENV_STATUS_TFTP_CANNOT_WRITE_TO_CONNECTION	equ 3Ah

; BOOTP errors 
PXENV_STATUS_BOOTP_TIMEOUT					equ 41h
PXENV_STATUS_BOOTP_NO_CLIENT_OR_SERVER_IP	equ 42h
PXENV_STATUS_BOOTP_NO_BOOTFILE_NAME			equ 43h
PXENV_STATUS_BOOTP_CANNOT_ARP_REDIR_SRVR	equ 44h

; DHCP errors 
PXENV_STATUS_DHCP_TIMEOUT			equ 	51h

; UNDI Errors
PXENV_STATUS_UNDI_MEDIATEST_FAILED 	equ	 61h


; MTFTP errors 
PXENV_STATUS_MTFTP_CANNOT_ARP_ADDRESS	equ 90h
PXENV_STATUS_MTFTP_OPEN_TIMEOUT			equ 92h
PXENV_STATUS_MTFTP_UNKNOWN_OPCODE		equ 93h
PXENV_STATUS_MTFTP_READ_TIMEOUT			equ 95h
PXENV_STATUS_MTFTP_WRITE_TIMEOUT		equ 97h
PXENV_STATUS_MTFTP_CANNOT_OPEN_CONNECTION		equ 98h
PXENV_STATUS_MTFTP_CANNOT_READ_FROM_CONNECTION	equ 99h
PXENV_STATUS_MTFTP_CANNOT_WRITE_TO_CONNECTION	equ 9Ah
PXENV_STATUS_MTFTP_CANNOT_INIT_NIC_FOR_MCAST	equ 9Bh
PXENV_STATUS_MTFTP_TOO_MANY_PACKAGES			equ 9Ch
PXENV_STATUS_MTFTP_MCOPY_PROBLEM				equ 9Dh


; EOF - $Workfile:   pxe_api.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\pxe_api.inc ===
;
; Modifications:   $Header:   W:/LCS/ARCHIVES/preboot/lsa2/base/iputil.asv   1.3   Apr 04 1997 10:05:58   GRGUSTAF  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Local includes
;

include pxe_cmn.inc


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; One of the following command op-codes needs to be loaded into the
; op-code register (BX) before making a call a PXENV API service.
;
PXENV_UNLOAD_STACK		equ	070h
PXENV_GET_BINL_INFO		equ	071h
PXENV_RESTART_DHCP		equ	072h
PXENV_RESTART_TFTP		equ	073h


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Structures and records
;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
s_pxenv_entry struc
en_signature	db	6 dup(?)	; 'PXENV+'

en_version	dw	?		; MSB=major, LSB=minor

en_bytes	db	?		; sizeof s_pxenv_entry
en_checksum	db	?		; 8-bit checksum of structure,
					; including this byte shoube be zero.

en_rm_entry_off	dw	?		; 16-bit real-mode segment & offset.
en_rm_entry_seg	dw	?

en_pm_entry_off	dw	?		; 16-bit protected mode 32-bit physical
en_pm_entry_base dd	?		; address and 16-bit offset.
s_pxenv_entry ends


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; PXENV API parameter structure typedefs.
;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
s_PXENV_UNLOAD_STACK struc
ul_status	dw	?		; Out: See PXENV_STATUS_xxx constants.
ul_rm_entry_off	dw	?		; Out: 16-bit real-mode segment and
ul_rm_entry_seg	dw	?		;      offset of PXENV Entry Point
					;      structure.
ul_pm_entry_off	dw	?		; Out: 16-bit protected-mode offset
ul_pm_entry_base dd	?		;      and segment base address of
					;      PXENV Entry Point structure.
s_PXENV_UNLOAD_STACK ends


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
s_PXENV_GET_BINL_INFO struc
gbi_status	dw	?		; Out: See PXENV_STATUS_xxx constants.
gbi_packet_type	dw	?		; In: See PXEVN_PACKET_TYPE_xxx */
					;     constants.
gbi_buffer_size	dw	?		; In: Size of the buffer in
					;     bytes.  Specifies the maximum
					;     amount of data that will be
					;     copied by the service.  A size
					;     of zero is valid.
					; Out: Amount of BINL data, in
					;      bytes, that was copied into
					;      the buffer.  For an input
					;      size of zero, no data will be
					;      copied and BufferSize will be
					;      set to the maximum amount of
					;      data available to be copied.
gbi_buffer_offset dw	?		; In: 16-bit offset and segment/
gbi_buffer_segment dw	?		;     selector of a buffer to copy
					;     the BINL information into.
s_PXENV_GET_BINL_INFO ends


PXENV_PACKET_TYPE_DHCP_DISCOVER	equ	1
PXENV_PACKET_TYPE_DHCP_ACK	equ	2
PXENV_PACKET_TYPE_BINL_REPLY	equ	3


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
s_PXENV_RESTART_DHCP struc
rd_status	dw	?		; Out: See PXENV_STATUS_xxx constants.
s_PXENV_RESTART_DHCP ends



; EOF - $Workfile:   pxe_api.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\mtftp.c ===
#include "su.h"
#include "pxe_cmn.h"
#include "pxe_api.h"
#include "tftp_api.h"
#include "udp_api.h"
#include "dhcp.h"
#include "pxe.h"



#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))


//
// packet - Work buffer used to hold DHCP ACK and BINL REPLY packets.
//          These packets will be read into this buffer using the
//          PXENV API service PXENV_GET_BINL_INFO.
//

BOOTPLAYER packet;

//
// PxenvApiCall() - see su.asm for details
//

extern UINT16
PxenvApiCall(
    UINT16 service,
    void far *param
);


//
// GetPacket()
//
// Description:
//  Get cached packet from PXENV API.
//
// Passed:
//  packet := Far pointer to packet buffer
//  packet_type := see pxe_api.h for PXENV_PACKET_TYPE_xxx #defines
//
// Returns:
//  -1 := Packet could not be transfered to buffer
//  size := Number of bytes transfered into packet buffer
//
// Warning:
//  No check is made to see if buffer is actually large enough to
//  hold the entire packet.  The buffer should be of type BOOTPLAYER.
//

SHORT
GetPacket(
    void far *packet,
    UINT16 packet_type
)
{
    t_PXENV_GET_BINL_INFO gbi;

    //
    // Check for invalid parameters
    //

    if (packet == NULL) {
        BlPrint("\nGetPacket()  NULL pointers\n");
        return -1;
    }

    //
    // Request size of packet by sending a size of zero.
    //

    gbi.packet_type = packet_type;
    gbi.buffer_size = 0;

    if (PxenvApiCall(PXENV_GET_BINL_INFO, &gbi) != PXENV_EXIT_SUCCESS) {
        BlPrint("\nGetPacket()  PXENV API FAILURE #1\n");
        return -1;
    }

    //
    // Transfer cached packet into buffer.
    //

    gbi.buffer_offset = FP_OFF(packet);
    gbi.buffer_segment = FP_SEG(packet);

    if (PxenvApiCall(PXENV_GET_BINL_INFO, &gbi) != PXENV_EXIT_SUCCESS) {
        BlPrint("\nGetPacket()  PXENV API FAILURE #2\n");
        return -1;
    }

    return (SHORT)gbi.buffer_size;
}


//
// pFindOption()
//
// Description:
//  Find the desired Option in an options string
//  internal routine to allow FindOption/FindVendorOption
//  to share code.
//
// Passed:
//  Option := Option to be found
//  options := options string
//  pLength := IN Length of options string (16bit max)
//             OUT Length of option.       (8bit max)
//
// Returns:
//  pointer to option data; NULL if not present
//
UINT32 *
pFindOption(
    UINT8 Option,
    UINT8 *options,
    UINT16 *pLength
    )
{
    UINT8 *end;

    if (options == NULL || pLength == NULL) {
        return NULL;
    }

    end = options + *pLength;
    *pLength = 0;

    //
    // walk down the packet looking for the desired option
    // type.  be sure to check that the option will not 
    // walk off the end of a malformed packet.
    // use length to indicate whether a valid 
    // option was found
    //
    while ((options < end) &&
           (*options != 0xFF) 
           ) {
        //
        // step over option pads
        //
        if ( *options == DHCP_PAD ) {
            options++;
        }
        else {

            if ( end <= options + 2 ||
                 end <= options + 2 + options[1] ) {
                //
                // invalid option.  it walked past the end of the packet
                //
                break;
            }

            if ( *options == Option ) {
                //
                // found the option.  break out of loop
                //
                *pLength = options[1];
                break;
            }
            else {
                options += 2 + options[1];
            }
        }
    }

    return (*pLength != 0) ? (UINT32 *)(options + 2) : NULL; 
}



//
// FindOption()
//
// Description:
//  Find the subnet mask option in a DHCP packet.
//
// Passed:
//  Packet := IN Pointer to DHCP packet.
//  PacketLength := IN Length of DHCP packet.
//  pLength := OUT Length of option.
//
// Returns:
//  pointer to option data; NULL if not present
//

UINT32 *
FindOption(
    UINT8 Option,
    BOOTPLAYER *Packet,
    UINT16 PacketLength,
    UINT8 *pLength
    )
{
    UINT32 *retOption;
    UINT16   length;

    //
    // Verify parameters
    //

    if ( *((ULONG *)Packet->vendor.v.magic) != VM_RFC1048 ) {
        return NULL;
    }


    length = PacketLength;
    retOption = pFindOption(Option,
                            (UINT8 *)&Packet->vendor.v.flags,
                            &length
                            );

    if (pLength != NULL) {
        *pLength = (UINT8)length;
    }

    return retOption;
}


UCHAR *
FindVendorOption(
    UINT8 Option,
    UINT8 VendorOption,
    BOOTPLAYER *Packet,
    UINT16 PacketLength,
    UINT8 * pLength
    )
{
    UINT8 *start;
    UINT16 cb;
    UCHAR *retOption;

    if (pLength != NULL) {
        *pLength = 0;
    }

    start = (UINT8*)FindOption( Option, Packet, PacketLength, (UINT8*)&cb );
    if (start == NULL) {
        return NULL;
    }

    retOption = (UCHAR *)pFindOption( VendorOption, start, &cb );

    if (pLength) {
        *pLength = (UINT8)cb;
    }

    return retOption;
}


//
// strlen()
//
// Description:
//  Works like std C.
//

int
strlen(UCHAR *s1)
{
    int n = 0;

    if (s1 != NULL)
        while (*s1++)
            ++n;

    return n;
}


//
// strcpy()
//
// Description:
//  Works like std C.
//

UCHAR *
strcpy(UCHAR *s1, UCHAR *s2)
{
    UCHAR *s = s1;

    if (s1 != NULL && s2 != NULL)
        while ((*s1++ = *s2++) != 0)
            ;

    return s;
}


//
// strncpy()
//
// Description:
//  Works like std C.
//

UCHAR *
strncpy(UCHAR *s1, UCHAR *s2, int n)
{
    UCHAR *s = s1;

    if (s1 != NULL && s2 != NULL && n > 0)
        while (n--)
            if ((*s1++ = *s2++) == 0)
                break;

    return s;
}


//
// memset()
//
// Description:
//  Works like std C.
//

PUCHAR
memset(
    PUCHAR Destination,
    UCHAR Value,
    int Length
    )
{
    while (Length--) {
        *Destination++ = Value;
    }

    return Destination;
}


//
// PxenvTftp()
//
// Description:
//  Try to transfer the protect-mode loader using information from
//  DHCP ACK and BINL REPLY packets.
//
// Passed:
//  DownloadAddr := Physical address, in client machine, to transfer to.
//  FileName := File name sent down in BINL REPLY packet.
//

BOOLEAN
PxenvTftp(
)
{
    UINT16 status;
    UINT16 packetLength;
    t_PXENV_TFTP_READ_FILE tftp;
    int pathLength;
    UINT32 clientIp;
    UINT32 serverIp;
    UINT32 gatewayIp;
    UINT32 *optionPtr;
    UINT32 subnetMask;
    UCHAR *FileName;
    UCHAR cb;
    UCHAR *optionVendor;


    //
    // Get the DHCP ACK packet.
    //

    if ((packetLength = GetPacket(&packet, PXENV_PACKET_TYPE_DHCP_ACK)) == -1) {
        return TRUE;
    }

    //
    // Get client IP address, server IP address, default gateway IP address,
    // and subnet mask from the DHCP ACK packet.
    //

    clientIp = *(UINT32 *)packet.yip;
    serverIp = *(UINT32 *)packet.sip;
    //BlPrint("PxenvTftp:  DHCP ACK yip = %lx, sip = %lx\n", *(UINT32 *)packet.yip, *(UINT32 *)packet.sip);

    optionPtr = FindOption( DHCP_ROUTER, &packet, packetLength, NULL );
    if ( optionPtr != NULL ) {
        //BlPrint("PxenvTftp:  DHCP ACK router = %lx\n", *optionPtr);
        gatewayIp = *optionPtr;
    } else {
        //BlPrint("PxenvTftp:  DHCP ACK gip = %lx\n", *(UINT32 *)packet.gip);
        gatewayIp = *(UINT32 *)packet.gip;
    }

    optionPtr = FindOption( DHCP_SUBNET, &packet, packetLength, NULL );
    if ( optionPtr != NULL ) {
        //BlPrint("PxenvTftp:  DHCP ACK subnet = %lx\n", *optionPtr);
        subnetMask = *optionPtr;
    } else {
        //BlPrint("PxenvTftp:  DHCP ACK subnet not specified\n");
        subnetMask = 0;
    }

    //
    // Get the BINL REPLY packet.
    //

    if ((packetLength = GetPacket(&packet, PXENV_PACKET_TYPE_BINL_REPLY)) == -1) {
        return TRUE;
    }

    //
    // Values for client IP address, server IP address, default gateway IP address,
    // and subnet mask that are present in the BINL REPLY packet override those
    // in the DHCP ACK packet.
    //

    if ( *(UINT32 *)packet.yip != 0 ) {
        clientIp = *(UINT32 *)packet.yip;
    }
    if ( *(UINT32 *)packet.sip != 0 ) {
        serverIp = *(UINT32 *)packet.sip;
    }
    //BlPrint("PxenvTftp:  BINL REPLY yip = %lx, sip = %lx\n", *(UINT32 *)packet.yip, *(UINT32 *)packet.sip);

    optionPtr = FindOption( DHCP_ROUTER, &packet, packetLength, NULL );
    if ( optionPtr != NULL ) {
        //BlPrint("PxenvTftp:  BINL REPLY router = %lx\n", *optionPtr);
        gatewayIp = *optionPtr;
    } else if ( *(UINT32 *)packet.gip != 0 ) {
        //BlPrint("PxenvTftp:  BINL REPLY router = %lx\n", *(UINT32 *)packet.gip);
        gatewayIp = *(UINT32 *)packet.gip;
    }

    optionPtr = FindOption( DHCP_SUBNET, &packet, packetLength, NULL );
    if ( optionPtr != NULL ) {
        //BlPrint("PxenvTftp:  BINL REPLY subnet = %lx\n", *optionPtr);
        subnetMask = *optionPtr;
    }

    //
    // Determine whether we need to send packets via the gateway.
    //

    //BlPrint("PxenvTftp:  clientIp = %lx, serverIp = %lx, subnet = %lx\n", clientIp, serverIp, subnetMask);
    //BlPrint("            router = %lx\n", gatewayIp);
    if ( (clientIp & subnetMask) == (serverIp & subnetMask) ) {
        //BlPrint("PxenvTftp:  subnets match. clearing router address\n");
        gatewayIp = 0;
    }
    //PxenvApiCall(-1, NULL);


    //
    // Now fill in the TFTP TRANSFER parameter structure
    //

    memset( (PUCHAR)&tftp, 0, sizeof( tftp ) );

    //
    // Find the name and path of the NTLDR that we are going to download.
    // This is specified by a DHCP Vendor option tag. If this tag
    // is missing we will default to NTLDR and the same path as 
    // startrom.com.
    //
    FileName = (UCHAR*)FindOption( DHCP_LOADER_PATH, &packet, packetLength, &cb );
    if ( FileName == NULL ) {
        //
        // We could not find the DHCP_LOADER_PATH. We will use the default name of 
        // <path>\NTLDR where the <path> is the same as that used 
        // to download startrom.com
        //
        
        strncpy(tftp.FileName, packet.bootfile, sizeof(tftp.FileName) - sizeof("NTLDR"));
        tftp.FileName[sizeof(tftp.FileName) - 1] = '\0';
        
        pathLength = strlen(tftp.FileName);
        while (pathLength > 0) {
            --pathLength;
            if (tftp.FileName[pathLength] == '\\') {
                ++pathLength;  // advance it past the '\'
                break;
            }
        }

        strcpy(tftp.FileName + pathLength, "NTLDR");
        
    } else {

        // We found the DHCP_LOADER_PATH option. We will use that 
        // as is to download the loader, unless it is too large.
        // Note that since the DHCP_LOADER_PATH size might include a 
        // null terminator, we need to check to make sure that it
        // just might fit

        if ((cb > sizeof(tftp.FileName)) || 
                ((cb == sizeof(tftp.FileName)) && (FileName[cb] != '\0'))) {
            //BlPrint("PxenvTftp:  DHCP_LOADER_PATH is too large = %s\n", FileName);
            return TRUE;
        }
        
        strncpy(tftp.FileName, FileName, cb);        
        tftp.FileName[sizeof(tftp.FileName) - 1] = '\0';
    }

    //
    // Loader will be transfered to 1MB region and must not be more 
    // than to 2MB in length.
    //

    tftp.BufferSize = 0x200000L;
    tftp.BufferOffset = 0x100000L; 

    //
    // Set the Server and gateway address
    //
    *((UINT32 *)tftp.ServerIPAddress) = serverIp;
    *((UINT32 *)tftp.GatewayIPAddress) = gatewayIp;

    //
    // Check whether we are going to use multicast download or not. The 
    // multicast options are set in a DHCP option tag (DHCP_LOADER_MCAST_OPTIONS).
    // These are encapsulated options and work the same way as Vendor options.
    // If these are missing then unicast transfer will be used.
    //
    optionVendor = FindVendorOption( DHCP_LOADER_MCAST_OPTIONS, PXE_MTFTP_IP, &packet, packetLength, &cb );
    if ( optionVendor != NULL && cb == 4 ) {

        *(UINT32*)tftp.McastIPAddress = *(UINT32*)optionVendor;

        optionVendor = FindVendorOption( DHCP_LOADER_MCAST_OPTIONS, PXE_MTFTP_CPORT, &packet, packetLength, &cb );
        if (optionVendor == NULL || cb != 2) {
            return TRUE;
        }

        tftp.TFTPClntPort = htons( *(UINT16*)optionVendor );

        optionVendor = FindVendorOption( DHCP_LOADER_MCAST_OPTIONS, PXE_MTFTP_SPORT, &packet, packetLength, &cb );
        if (optionVendor == NULL || cb != 2) {
            return TRUE;
        }

        tftp.TFTPSrvPort = htons( *(UINT16*)optionVendor );

        optionVendor = FindVendorOption( DHCP_LOADER_MCAST_OPTIONS, PXE_MTFTP_TMOUT, &packet, packetLength, &cb );
        if (optionVendor == NULL || cb != 1) {
            return TRUE;
        }

        tftp.TFTPOpenTimeOut = *(UINT8*)optionVendor;

        optionVendor = FindVendorOption( DHCP_LOADER_MCAST_OPTIONS, PXE_MTFTP_DELAY, &packet, packetLength, &cb );
        if (optionVendor == NULL || cb != 1) {
            return TRUE;
        }

        tftp.TFTPReopenDelay = *(UINT8*)optionVendor;
    }
    

#if DBG

    BlPrint("Downloading Loader:\n");
    BlPrint("FileName = %s\n", tftp.FileName );
    BlPrint("BufferSize = %lx\n", tftp.BufferSize );
    BlPrint("BufferOffset = %lx\n", tftp.BufferOffset );
    BlPrint("ServerIPAddress = %d.%d.%d.%d\n", 
        tftp.ServerIPAddress[0], 
        tftp.ServerIPAddress[1], 
        tftp.ServerIPAddress[2], 
        tftp.ServerIPAddress[3] );
    BlPrint("GatewayIPAddress = %d.%d.%d.%d\n", 
        tftp.GatewayIPAddress[0], 
        tftp.GatewayIPAddress[1], 
        tftp.GatewayIPAddress[2], 
        tftp.GatewayIPAddress[3] );
    BlPrint("McastIPAddress = %d.%d.%d.%d\n", 
        tftp.McastIPAddress[0], 
        tftp.McastIPAddress[1], 
        tftp.McastIPAddress[2], 
        tftp.McastIPAddress[3] );
    BlPrint("TFTPClntPort = %d\n", htons( tftp.TFTPClntPort ) );
    BlPrint("TFTPSrvPort = %d\n", htons( tftp.TFTPSrvPort ) );
    BlPrint("TFTPOpenTimeOut = %d\n", tftp.TFTPOpenTimeOut );
    BlPrint("TFTPReopenDelay = %d\n", tftp.TFTPReopenDelay );

    BlPrint("\n\nPress any key to start download...\n" );

    _asm {
        push    ax
        mov     ax, 0
        int     16h
        pop     ax
    }

#endif

    //
    // Transfer image from TFTP server
    //
    status = PxenvApiCall(PXENV_TFTP_READ_FILE, &tftp);
    if (status != PXENV_EXIT_SUCCESS) {
        return TRUE;
    }

    return FALSE;
}

/* EOF - mtftp.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\su.asm ===
;++ 
;
; Module name
;
;       su.asm
;
; Author
;
;       Thomas Parslow  (tomp)  Jan-15-91
;
; Description
;
;       Startup module for the 386 NT OS loader.
;
; Exported Procedures
;
;       EnableProtectPaging
;
; Notes
;       NT386 Boot Loader program. This assembly file is required in
;       order to link C modules into a "/TINY"  (single segment) memory
;       model.
;
;
; This file does the following:
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 1) Defines the entry point for the boot loader's startup program
; 2) Computes what values should actually be in the DS and SS registers.
; 3) Provides the int bios functionality
; 4) Provides 386/486 mode (protect/paging) switching code.
;
; The OS/2 bootstrap routine (boot sector) loads the boot loader program at
; real-mode address 2000:0000 with the following register values:
;
;       CS = 2000
;       IP = 0000
;       DS = 07C0
;       ES = 1000
;       SS = 0000
;       SP = 7C00
;
; The PXE boot PROM loads the boot loader program at real-mode address
; 0000:7C00 with the following register values:
;
;       CS = 0000
;       IP = 7C00
;       DS = Data segment of PXE boot PROM
;       SS = Stack segment of PXE boot PROM
;       SP = Stack pointer of PXE boot PROM (at least 1K free)
;       ES = 16-bit, real-mode, segment of PXENV Entry Point structure
;       BX = 16-bit, real-mode, offset of PXENV Entry Point structure
;       EDX = 32-bit, physical, address of PXENV Entry Point structure
;
; For a boot from an SDI image, startrom is loaded at real-mode address
; 0000:7C00 with the following register values:
;
;       CS = 0000
;       IP = 7C00
;       DS = don't care
;       SS = Caller-defined stack segment
;       SP = Caller-defined stack pointer
;       EDX = physical address of page-aligned SDI image ORed with 0x41
;
; This startup module relocates itself to 2000:0 and changes the CS and IP
; register values to:
;
;       CS = 2000
;       IP = 0000
;
; Build Notes:
; ~~~~~~~~~~~~
; The microsoft C compiler will not produce "tiny" model programs. In the
; tiny model, the entire program consists of only one segment. The small
; model produced by our compilers consists of two segments: DGROUP and _TEXT.
; If you convert a small model program into a tiny model program, DS (which
; should point to DGROUP (bss,const,data) will always be wrong. For this reason
; we need an assembly module to do a simple run-time fixup on SS and DS. To
; guarantee that DS will point to DGROUP no matter where os2ldr is loaded,
; the paragraph (shifted right four bits) offset of DGROUP from _TEXT must
; be added to the value in CS to compute DS and SS.
;
; We get the linker to fixup the offset of the beginning of the dgroup segment
; relative to the beginning of the code segment and it's this value added
; to the value in CS that allows us to build a "tiny" model program in C
; without a lot of munging around in order to get the data reference offsets
; in the code correct.
;
; If the _TEXT:DGROUP fixup appears in other files (which it does), the linker
; will not compute the correct value unless the accumulated data pointer is
; zero when it gets there. Therefore, no data should be placed in the data segment
; until after all instances of _TEXT:DGROUP have been encountered by the linker.
; The linker processes files from right to left on the command line.
;
; A Note About Stacks
; Initially we run on our internal stack (SuStack) which is only 160 bytes deep
; but seems to do the trick. Then we have to have a separate double fault stack.
; This stack can be in the middle of the stack/data segment. It will step on
; the loader image, but that's ok since the fault was either caused by 16bit
; code (which won't be in the loader image) or, it was caused by the 32bit
; loader (which has already been relocated) so we won't be stepping on code
; that may have caused the fault. And finally, we have the "call back" stack
; which  starts at the top of the stack/data segment. We use this during
; all call backs since the original loader source is no longer needed and
; this'll give us plenty of stack for bios calls etc.
;
;--

DoubleWord      struc
lsw     dw      ?
msw     dw      ?
DoubleWord      ends

;
; This is the structure used to pass all shared data between the boot sector
; and NTLDR.
;

SHARED  struc
        ReadClusters            dd      ?               ; function pointer
        ReadSectors             dd      ?               ; function pointer

        SectorBase              dd      ?               ; starting sector
                                                        ; for ReadSectors
                                                        ; callback
SHARED  ends


BPB     struc
        BytesPerSector          dw      ?
        SectorsPerCluster       db      ?
        ReservedSectors         dw      ?
        Fats                    db      ?
        DirectoryEntries        dw      ?
        Sectors                 dw      ?
        Media                   db      ?
        FatSectors              dw      ?
        SectorsPerTrack         dw      ?
        Heads                   dw      ?
        HiddenSectors           dd      ?
        SectorsLong             dd      ?
;
; The following byte is NOT part of the BPB but is set by SYS and format
;

        BootDriveNumber         db      ?
BPB     ends

SU_CODEMODULE    equ      1        ; Identifies this module to "su.inc"
include su.inc
include macro.inc

extrn _BootRecord:word
extrn _puts:near
extrn _MemoryDescriptorList:near
extrn _InsertDescriptor:near
extrn _NetPcRomEntry:near
extrn GetKeyEx:near
extrn GetCounterReal:near

include pxe_api.inc                     ; Included for PXENV Entry Point
                                        ; structure.  Also includes
                                        ; pxe_cmn.inc file.

MAXREAD     EQU 10000h
MAXSECTORS  EQU MAXREAD/0200h

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP
.386p

;
; Run-time fixups for stack and data segment
;

public Start
Start:
;
; The FAT boot sector only reads in the first 512 bytes of NTLDR.  This is
; the module that contains those 512 bytes, so we are now responsible for
; loading the rest of the file.  Other filesystems (i.e. HPFS, NTFS, RIPL)
; will load the whole file, so the default entrypoint branches around the
; FAT-specific code.
;
        jmp     RealStart

FatBegin:
.386
;
; If we're here, we've booted off a FAT system and we must load the rest
; of NTLDR at 2000:0200 (right behind this sector)  NTLDR passes us the
; following:
;       BX = Starting Cluster Number of NTLDR
;       DL = INT 13h drive number we've booted from
;       DS:SI -> boot media's BPB
;       DS:DI -> argument structure (see above struc definition)
;
;
; Save away the boot drive and the starting cluster number
;
        push    dx
        push    bx

;
; Blast the FAT into memory at 6000:0000 - 8000:0000
;

.386
        push    06000h
.8086
        pop     es
        xor     bx,bx                           ; (es:bx) = 6000:0000
        mov     cx,ds:[si].ReservedSectors
        mov     ds:[di].SectorBase.msw,0
        mov     ds:[di].SectorBase.lsw,cx       ; set up Sector Base

        mov     ax,ds:[si].FatSectors           ; (al) = # Sectors to read
        cmp     ax,080h
        jbe     FatLt64k

;  The FAT is > 64k, so we read the first 64k chunk, then the rest.
;  (A 16-bit FAT can't be bigger than 128k)

        push    cx
        mov     ax,080h         ; (al) = # of sectors to read
        call    ds:[di].ReadSectors
        pop     cx                      ; (cx) = previous SectorBase
.386
        push    07000h
.8086
        pop     es
        xor     bx,bx                   ; (es:bx) = 7000:0000
        mov     ax,ds:[si].FatSectors
        sub     ax,080h                 ; (ax) = # Sectors left to read
        add     cx,080h                 ; (cx) = SectorBase for next read
        mov     ds:[di].SectorBase.lsw,cx
        adc     ds:[di].SectorBase.msw,0        ; set up SectorBase

;
; (al) = # of sectors to read
;
FatLt64k:
        call    ds:[di].ReadSectors

;
; FAT is in memory, now we restore our starting cluster number
;
        pop     dx                      ; (dx) = starting cluster number
        xor     bx,bx

;
; set up FS and GS for reading the FAT
;
.386
        mov     ax,6000h
        mov     fs,ax
        mov     ax,7000h
        mov     gs,ax
.8086

;
; set up ES for reading in the rest of us
;
        push    cs
        pop     es

        mov     ah,MAXSECTORS           ; (ah) = number of sectors we can read
                                        ;        until boundary
FatLoop:
;
; (dx) = next cluster to load
;
        push    dx
        mov     al,ds:[si].SectorsPerCluster    ; (al) = number of contiguous sectors
                                                ;        found
        sub     ah,ds:[si].SectorsPerCluster                                                    ;        can read before 64k

;
; Check to see if we've reached the end of the file
;
        cmp     dx,0ffffh
        jne     Fat10

;
; The entire file has been loaded.  Throw away the saved next cluster,
; restore the boot drive, and let NTLDR do its thing.
;
        pop     dx
        pop     dx
        jmp     RealStart

Fat10:
        mov     cx,dx
;
; (dx) = (cx) = last contiguous cluster
; (al) = # of contiguous clusters found
;

        call    NextFatEntry
;
; (dx) = cluster following last contiguous cluster

;
; Check to see if the next cluster is contiguous.  If not, go load the
; contiguous block we've found.
;
        inc     cx
        cmp     dx,cx

        jne     LncLoad

;
; Check to see if we've reached the 64k boundary.  If so, go load the
; contiguous block so far.  If not, increment the number of contiguous
; sectors and loop again.
;
        cmp     ah,0
        jne     Lnc20
        mov     ah,MAXSECTORS           ; (ah) = number of sectors until
                                        ;        boundary reached again
        jmp     short LncLoad

Lnc20:
        add     al,ds:[si].SectorsPerCluster
        sub     ah,ds:[si].SectorsPerCluster
        jmp     short Fat10


LncLoad:
;
; (TOS) = first cluster to load
; (dx)  = first cluster of next group to load
; (al)  = number of contiguous sectors
;
        pop     cx
        push    dx
        mov     dx,cx
        mov     cx,10                   ; (cx) = retry count

;
; N.B.
;       This assumes that we will never have more than 255 contiguous clusters.
;       Since that would get broken up into chunks that don't cross the 64k
;       boundary, this is ok.
;
; (dx) = first cluster to load
; (al) = number of contiguous sectors
; (TOS) = first cluster of next group to load
; (es:bx) = address where clusters should be loaded
;
FatRetry:
        push    bx
        push    ax
        push    dx
        push    cx

if 0
        push    dx
        call    PrintDbg
        mov     dx,ax
        call    PrintDbg
        pop     dx
endif

        call    [di].ReadClusters
        jnc     ReadOk
;
; error in the read, reset the drive and try again
;
if 0
        mov     dx, ax
        call    PrintDbg
endif
        mov     ax,01h
        mov     al,ds:[si].BootDriveNumber
        int     13h
if 0
        mov     dx,ax
        call    PrintDbg
endif
        xor     ax,ax
        mov     al,ds:[si].BootDriveNumber
        int     13h

;
; pause for a while
;
        xor     ax,ax
FatPause:
        dec     ax
        jnz     FatPause

        pop     cx
        pop     dx
        pop     ax
        pop     bx

        dec     cx
        jnz     FatRetry

;
; we have re-tried ten times, it still doesn't work, so punt.
;
        push    cs
        pop     ds
        mov     si,offset FAT_ERROR
FatErrPrint:
        lodsb
        or      al,al
        jz      FatErrDone
        mov     ah,14           ; write teletype
        mov     bx,7            ; attribute
        int     10h             ; print it
        jmp     FatErrPrint

FatErrDone:
        jmp     $
        ; This should be replaced by a mechanism to get a pointer
        ; passed to us in the param block. since the boot sector msg itself
        ; is properly localized but this one isn't.
FAT_ERROR       db      13,10,"Disk I/O error",0dh,0ah,0


ReadOk:
        pop     cx
        pop     dx
        pop     ax
        pop     bx
        pop     dx                      ; (dx) = first cluster of next group
                                        ;        to load.

.386
;
; Convert # of sectors into # of bytes.
;
        mov     cl,al
        xor     ch,ch
        shl     cx,9
.8086
        add     bx,cx
        jz      FatLoopDone
        jmp     FatLoop

FatLoopDone:
;
; (bx) = 0
;   This means we've just ended on a 64k boundary, so we have to
;   increment ES to continue reading the file.  We are guaranteed to
;   always end on a 64k boundary and never cross it, because we
;   will reduce the number of contiguous clusters to read
;   to ensure that the last cluster read will end on the 64k boundary.
;   Since we start reading at 0, and ClusterSize will always be a power
;   of two, a cluster will never cross a 64k boundary.
;
        mov     ax,es
        add     ax,01000h
        mov     es,ax
        mov     ah,MAXSECTORS
        jmp     FatLoop

;++
;
; NextFatEntry - This procedure returns the next cluster in the FAT chain.
;                It will deal with both 12-bit and 16-bit FATs.  It assumes
;                that the entire FAT has been loaded into memory.
;
; Arguments:
;    (dx)   = current cluster number
;    (fs:0) = start of FAT in memory
;    (gs:0) = start of second 64k of FAT in memory
;
; Returns:
;    (dx)   = next cluster number in FAT chain
;    (dx)   = 0ffffh if there are no more clusters in the chain
;
;--
NextFatEntry    proc    near
        push    bx

;
; Check to see if this is a 12-bit or 16-bit FAT.  The biggest FAT we can
; have for a 12-bit FAT is 4080 clusters.  This is 6120 bytes, or just under
; 12 sectors.
;
; A 16-bit FAT that's 12 sectors long would only hold 3072 clusters.  Thus,
; we compare the number of FAT sectors to 12.  If it's greater than 12, we
; have a 16-bit FAT.  If it's less than or equal to 12, we have a 12-bit FAT.
;
        call    IsFat12
        jnc     Next16Fat

Next12Fat:
        mov     bx,dx                   ; (fs:bx) => temporary index
        shr     dx,1                    ; (dx) = offset/2
                                        ; (CY) = 1  need to shift
        pushf                           ;      = 0  don't need to shift
        add     bx,dx                   ; (fs:bx) => next cluster number
.386
        mov     dx,fs:[bx]              ; (dx) = next cluster number
.8086
        popf
        jc      shift                   ; carry flag tells us whether to
        and     dx,0fffh                ; mask
        jmp     short N12Tail
shift:
.386
        shr     dx,4                    ; or shift
.8086

N12Tail:
;
; Check for end of file
;
        cmp     dx,0ff8h                ; If we're at the end of the file,
        jb      NfeDone                 ; convert to canonical EOF.
        mov     dx,0ffffh
        jmp     short NfeDone

Next16Fat:
        add     dx,dx                   ; (dx) = offset
        jc      N16high

        mov     bx,dx                   ; (fs:bx) => next cluster number
.386
        mov     dx,fs:[bx]              ; (dx) = next cluster number
.8086
        jmp     short N16Tail

N16high:
        mov     bx,dx
.386
        mov     dx,gs:[bx]
.8086

N16Tail:
        cmp     dx,0fff8h
        jb      NfeDone
        mov     dx,0ffffh               ; If we're at the end of the file
                                        ; convert to canonical EOF.

NfeDone:
        pop     bx
        ret
NextFatEntry    endp

;++
;
; IsFat12 - This function determines whether the BPB describes a 12-bit
;           or 16-bit FAT.
;
; Arguments - ds:si supplies pointer to BPB
;
; Returns
;       CY set -   12-bit FAT
;       CY clear - 16-bit FAT
;
;--
IsFat12 proc    near

.386
        push    eax
        push    ebx
        push    ecx
        push    edx

        movzx   ecx, ds:[si].Sectors
        or      cx,cx
        jnz     if10
        mov     ecx, ds:[si].SectorsLong
if10:
;
; (ecx) = number of sectors
;
        movzx   ebx, byte ptr ds:[si].Fats
        movzx   eax, word ptr ds:[si].FatSectors
        mul     ebx
        sub     ecx,eax

;
; (ecx) = (#sectors)-(sectors in FATs)
;
        movzx   eax, word ptr ds:[si].DirectoryEntries
        shl     eax, 5
;
; (eax) = #bytes in root dir
;
        mov     edx,eax
        and     edx,0ffff0000h
        div     word ptr ds:[si].BytesPerSector
        sub     ecx,eax

;
; (ecx) = (#sectors) - (sectors in fat) - (sectors in root dir)
;
        movzx   eax, word ptr ds:[si].ReservedSectors
        sub     ecx, eax
        mov     eax, ecx
        movzx   ecx, byte ptr ds:[si].SectorsPerCluster
        xor     edx,edx
        div     ecx

        cmp     eax, 4087
        jae     if20
        stc
        jmp     short if30
if20:
        clc
if30:
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        ret
.8086
IsFat12 endp



PrintDbg       proc    near
        push    ax
        push    bx
        push    cx

        mov     cx,4
pd10:
.386
        rol     dx,4
.8086
        mov     ah,0eh
        mov     bx,7
        mov     al,dl
        and     al,0fh
        add     al,'0'
        cmp     al,'9'
        jbe     pd15
        add     al,'A'-('9'+1)

pd15:
        int     010h
        loop    pd10

        mov     ah,0eh
        mov     al,' '
        mov     bx,7
        int     010h
        pop     cx
        pop     bx
        pop     ax

        ret

PrintDbg      endp

IFDEF HEADLESS_SRV
TerminalStatus          dw      0
endif


Free    EQU     512-($-Start)
if Free lt 0
        %out FATAL PROBLEM: FAT-specific startup code is greater than
        %out 512 bytes.  Fix it!
        .err
endif

RealStart:
.386p
;
; Compute the paragraph needed for DS
;
if 0
        mov     ax,0
        int     16h
endif
;
; If this is a network boot (known by CS == 0 and IP ~= 7C00), then
; move the startup module to 2000:0.
;

        call    near ptr pxe_boot_check ; *(SP -= 2) = IP

pxe_boot_check:
        pop     ax                      ; AX := IP

        cmp     ax, 7c00h + pxe_boot_check - Start
        jne     not_pxe_boot
        mov     ax, cs
        cmp     ax, 0
        jne     not_pxe_boot

        push    ds
        push    es

        xor     ax,ax
        mov     cx,7c0h                 ; move from 7C0:0
        mov     ds,cx
        mov     si,ax
        mov     cx,2000h                ; move to 2000:0
        mov     es,cx
        mov     di,ax

        mov     ecx,offset _TEXT:DGROUP ; get length of text segment
        add     ecx,offset DGROUP:_edata ; add length of data segment

        cld                             ; move forward
        rep     movsb                   ; relocate to 2000:0

        pop     es
        pop     ds

        db      0EAh                    ; Far jump to 2000h:CS_IP_adjust
        dw      offset CS_IP_adjust     ; to change CS:IP and flush
        dw      2000h                   ; prefetch.

CS_IP_adjust:


IFDEF HEADLESS_SRV
        push    edx
        mov     ax, 00e3h               ; Initialize, 9600 baud, no parity, 1 stop bit, 8 data bits
        mov     dx, HEADLESS_COMPORT    ; com port
        int     14h
        mov     cs:TerminalStatus, ax   ; Save the status for later
        pop     edx
endif

;
; Check DL as set by our caller. If it is 0x41, this implies that we're doing
; an SDI boot. Our caller is a different initial boot program that has loaded
; into memory an SDI image containing a ramdisk image, startrom.com and
; osloader.exe. The caller has copied startrom.com to 0:7c00 and jumped to it.
; We are to do the normal PXE bootstrap things here, except that we don't have
; to download the loader, because it's already here. We do have to move it into
; the right place from where it exists in the SDI image.
;
; If this is an SDI boot, the top three bytes of the page-aligned physical
; address of the SDI image are in the top three bytes of EDX. This address is
; passed to SuMain().
;
        cmp     dl, 41h                 ; SDI boot?
        je      sdi_boot                ; Jump if yes (skip wait for F12,
                                        ; leave dl == 0x41 to indicate boot
                                        ; drive, and leave the SDI address in
                                        ; the upper part of edx.

;
; Give the user a chance to press F12 to request a network boot. If F12 is not
; pressed, then return from the boot code. This causes the BIOS to try the next
; boot device (usually the disk).
;

ifndef ALWAYS_BOOT_FROM_NET
        call    CheckForF12
        cmp     ax,0
        jnz     do_remote_boot

        retf

do_remote_boot:
endif

        mov     dx, 0040h               ; Default boot disk (0x40 == PXE boot)

sdi_boot:
not_pxe_boot:

;
; Compute the paragraph needed for DS
;
        mov     bx,offset _TEXT:DGROUP  ; first calculate offset to data
        shr     bx,4                    ; must be para aligned

        mov     ax,cs                   ; get base of code
        add     ax,bx                   ; add paragraph offset to data

        mov     ss,ax                      ; ints disabled for next instruct
        mov     sp,offset DGROUP:SuStack   ; (sp) = top of internal stack

;
; Build C stack frame for _SuMain
;
        push    edx                     ; pass bootdisk to main
;
; Make DS point to the paragraph address of DGROUP
;
        mov     ds,ax                   ; ds now points to beginning of DGROUP
        mov     es,ax                   ; es now points to beginning of DGROUP
;
; Compute the physical address of the end of the data segment (which
; will be the beginning of the prepended loader file).
;

        movzx    edx,ax
        shl      edx,4
        add      edx,offset DGROUP:_edata
        mov      dword ptr _FileStart,edx

;
; Force the upper parts of
; of EBP and ESP to be zero in real mode.
;

        xor      bp,bp
        movzx    ebp,bp
        movzx    esp,sp
        mov      [saveDS],ds

        call    _SuMain                 ; go to C code to do everything else.


;++
; _EnableProtectPaging
;
; Loads 386 protect mode registers.
; Enables 386 protection h/w
; Loads pagings registers
; Enables 386 paging h/w
;
;--

public _EnableProtectPaging
_EnableProtectPaging  proc near
;
; Sanitize ES and GS and clean out any junk in the upper 16bits
; of the flags that may have been left by the bios, before we go protected
;
        push     dword ptr 0
        popfd
        mov      bx,sp
        mov      dx,[bx+2]  ; are we enabling prot/paging for the first time?
        xor      ax,ax
        mov      gs,ax
        mov      es,ax


;
; FS must contain the selector of the PCR when we call the kernel
;
        push    PCR_Selector
        pop     fs
;
; Load the gdtr and idtr.
; We disable interrupts here since we can't handle interrups with the
; idt loaded while were in real mode and before we switch to protmode.

        cli
        lgdt     fword ptr [_GDTregister]
        lidt     fword ptr [_IDTregister]


;
; We have to stamp the segment portion of any real-mode far pointer with
; the corresponding selector values before we go protected.
;
        mov      si,offset _ScreenStart
        mov      word ptr [si+2],VideoSelector
        mov      si,offset _vp
        mov      word ptr [si+2],VideoSelector
        mov      si,offset _MemoryDescriptorList
        mov      word ptr [si+2],MdlSelector

;
; Enable protect and paging mode
;
        mov      eax,cr0

; If we're enabling protect mode for the first time, don't turn on paging
; because the osloader does all that.  However, if we're returning to
; protected mode, the page tables are already setup, therefore we do want
; to turn paging on.
        cmp     dx,1
        jnz     only_prot
        or      eax,PROT_MODE + ENABLE_PAGING
        mov     cr0,eax

;
; The following JMP must be DWORD-aligned in order to avoid an obscure i386
; hardware bug.  If not, it is possible (albeit unlikely) that the prefetch
; queue can get trashed.
;

ALIGN 4
        jmp     flush


only_prot:
        or       eax,PROT_MODE
        mov      cr0,eax
;
; Flush the prefetch queue
;

ALIGN 4
        jmp     flush
flush:


;
; Load CS with the SU module's code selector
;
        push    SuCodeSelector
        push    offset cs:restart
        retf
;
; Now load DS and SS with the SU module's protect mode data selector.
;

restart:
        mov      ax,SuDataSelector
        mov      ds,ax
        mov      ss,ax

;
; Load LDT with zero since it will never be used.
;
        xor      bx,bx
        lldt     bx

;
; Load the Task Register and return to the boot SU module.
;
        or       dx,dx
        jnz      epp10


        mov      bx,TSS_Selector
        ltr      bx


epp10:
        ret

_EnableProtectPaging endp

.286p
;** _biosint
;
;   Rom bios interrupt dispatcher
;

public _biosint
_biosint proc    near

        enter   0,0
        push    di
        push    si
        push    ds
        push    es

;       Get pointer to register parameter frame

        les     di,[bp+4]

;       Get requested interrupt number

        mov     ax,es:[di].intnum

;       Check that requested bios interrupt is supported

        sub     ax,10h          ; sub lowest int number supported
        jnc     short bios1
        mov     es:[di].intnum,FUNCTION_ERROR
        jmp     short biosx
bios1:
        shl     ax,1            ; shift if to make it a word offset
        cmp     ax,bios_cnt     ; offset beyond end of table?
        jb      short bios2

;       Error: requested interrupt not supported

        mov     es:[di].sax,FUNCTION_ERROR
        jmp     short biosx

bios2:  mov     bx,ax
        mov     ax,word ptr cs:bios_table[bx]
        push    es              ; save seg of address frame
        push    di              ; save stack register frame pointer
        push    ax              ; address of bios int

        mov     ax,es:[di].sax
        mov     bx,es:[di].sbx
        mov     cx,es:[di].scx
        mov     dx,es:[di].sdx
        mov     si,es:[di].ssi
        mov     es,es:[di].ses
        ret                     ; this sends us to the "int #" instruction

;       We return here from the jmp instruction following the int

bios_ret:

        pop     di              ; get address of register parameter frame
        pop     es              ; restore segment of parameter frame


bios5:  pushf
        pop     es:[di].sfg
        mov     es:[di].sax,ax
        mov     es:[di].sbx,bx
        mov     es:[di].scx,cx
        mov     es:[di].sdx,dx
        mov     es:[di].ssi,si
        mov     es:[di].ses,es

;       Restore original registers and return to caller

biosx:
        pop     es
        pop     ds
        pop     si
        pop     di
        leave
        ret

_biosint endp

;** Bios Interrupt Table
;


bios10: int     10h
        jmp     short bios_ret
bios11: int     11h
        jmp     short bios_ret
bios12: int     12h
        jmp     short bios_ret
bios13: int     13h
        jmp     short bios_ret
bios14: int     14h
        jmp     short bios_ret
bios15: int     15h
        jmp     short bios_ret
bios16: int     16h
        jmp     short bios_ret
bios17: int     17h
        jmp     short bios_ret
bios18: int     18h
        jmp     short bios_ret
bios19: int     19h
        jmp     short bios_ret

bios_table dw      bios10,bios11,bios12,bios13,bios14,bios15,bios16,bios17,bios18,bios19

bios_cnt        equ     $ - bios_table

.386p

;++
;
; _MoveMemory
;
; Routine Description
;
;       Moves dwords in memory from source to destination.
;
; Arguments
;
;       (TOS+4)  =  number of bytes to move
;       (TOS+8)  =  linear address of destination
;       (TOS+12) =  linear address of source
;
; Notes
;
;   1)  Valid page table entries must already exist for the
;       source and destination memory.
;
;   2)  ALL memory in the lower one megabyte is assumed to
;       be identity mapped if used.
;
; USES  ESI, EDI, ECX, FLAGS
;
;
;--


public _MoveMemory
_MoveMemory proc near

        enter    0,0
        push     ds
        push     es
;
; Get source, destination, and count arguments from the stack
; Make "count" the number of dwords to move.
;

        mov      esi,dword ptr [bp+4]
        mov      edi,dword ptr [bp+8]
        mov      ecx,dword ptr [bp+12]
        shr      ecx,2

;
; Load FLAT selectors into DS and ES
;

        mov      ax,KeDataSelector
        mov      ds,ax
        mov      es,ax

;
; Move the block of data.
;
assume es:FLAT, ds:FLAT

;
; move the dwords
;
        cld
        rep     movs    dword ptr [edi],dword ptr [esi]

;
; move the remaining tail
;
        mov     ecx, dword ptr [bp+12]
        and     ecx, 3
        rep     movs    byte ptr [edi],byte ptr [esi]


assume es:nothing, ds:DGROUP

        pop      es
        pop      ds
        leave
        ret

_MoveMemory endp



;++
;
; _ZeroMemory
;
; Routine Description
;
;       Writes zeros into memory at the target address.
;
; Arguments
;
;       (TOS+4)  =  linear address of target
;       (TOS+8)  =  number of bytes to zero
;
; Notes
;
;   1)  Valid page table entries must already exist for the
;       source and destination memory.
;
;   2)  ALL memory in the lower one megabyte is assumed to
;       be identity mapped if used.
;
; USES  ESI, EDI, ECX, FLAGS
;
;
;--

public _ZeroMemory
_ZeroMemory proc near


        enter    0,0
        push     es
;
; Get source, destination, and count arguments from the stack
; Make "count" the number of dwords to move.
;

        mov      edi,dword ptr [bp+4]
        mov      ecx,dword ptr [bp+8]
        shr      ecx,2

;
; Load FLAT selectors into DS and ES
;

        mov      ax,KeDataSelector
        mov      es,ax
        xor      eax,eax

;
; Zero the the block of data.
;
assume es:FLAT

;
; Zero the dwords
;
        cld
        rep     stos    dword ptr [edi]

;
; Zero the remaining bytes
;
        mov     ecx, dword ptr [bp+8]
        and     ecx, 3
        rep     stos    byte ptr [edi]

assume es:nothing, ds:DGROUP

        pop      es
        leave
        ret


_ZeroMemory endp

public _SetMemory
_SetMemory proc near


        enter    0,0
        push     es
;
; Get source, destination, and count arguments from the stack
; Make "count" the number of dwords to move.
;

        mov      edi,dword ptr [bp+4]
        mov      ecx,dword ptr [bp+8]
        shr      ecx,2

;
; Load FLAT selectors into DS and ES
;

        mov      ax,KeDataSelector
        mov      es,ax
        mov      eax,dword ptr [bp+12]

;
; Set the the block of data.
;
assume es:FLAT

;
; Set the dwords
;
        cld
        rep     stos    dword ptr [edi]

;
; Set the remaining bytes
;
        mov     ecx, dword ptr [bp+8]
        and     ecx, 3
        rep     stos    byte ptr [edi]

assume es:nothing, ds:DGROUP

        pop      es
        leave
        ret


_SetMemory endp




;++
;
; Turn Floppy Drive Motor Off
;
;--

public _TurnMotorOff
DriveControlRegister      equ      3f2h     ; Floppy control register

_TurnMotorOff proc near

        mov      dx,DriveControlRegister
        mov      ax,0CH
        out      dx,al
        ret

_TurnMotorOff endp


;
; Note: we do not save and restore the gdt and idt values because they
; cannot change while external services are being used by the OS loader.
; This is because they MUST remain identity mapped until all mode
; switching has ceased.
;

public _RealMode
_RealMode proc near

;
; Switch to real-mode
;

        sgdt     fword ptr [_GDTregister]
        sidt     fword ptr [_IDTregister]
        push     [saveDS]          ; push this so we can get to it later
        mov      ax,SuDataSelector
        mov      es,ax
        mov      fs,ax
        mov      gs,ax

        mov      eax,cr0
        and      eax, not (ENABLE_PAGING + PROT_MODE)
        mov      cr0,eax

;
; flush the pipeline
;
        jmp     far ptr here
here:

;
; Flush TLB
;

; HACKHACK - We don't know where the page directory is, since it was
;       allocated in the osloader.  So we don't want to clear out cr3,
;       but we DO want to flush the TLB....
;
        mov     eax,cr3

        nop                             ; Fill - Ensure 13 non-page split
        nop                             ; accesses before CR3 load
        nop                             ; (P6 errata #11 stepping B0)
        nop

        mov     cr3,eax
;
; switch to real mode addressing
;
; N. B. We need to do a far jump rather than a retf, because a retf will not
;       reset the access rights to CS properly.
;
        db      0EAh                    ; JMP FAR PTR
        dw      offset _TEXT:rmode      ; 2000:rmode
        dw      02000h
rmode:
        pop      ax
        mov      ds,ax
        mov      ss,ax
;
; Stamp video pointers for real-mode use
;
        mov     si,offset _ScreenStart
        mov     word ptr [si+2],0b800h
        mov     si,offset _vp
        mov     word ptr [si+2],0b800h
;
; re-enable interrups
;
        lidt    fword ptr [_IDTregisterZero]

;
; Re-enable interrupts
;

        sti
        ret

_RealMode endp

;** _TransferToLoader  - transfer control the the OS loader
;
;
;  Arguments:
;
;       None
;
;  Returns:
;
;       Does not return
;
;**

public _TransferToLoader
_TransferToLoader proc near

;  generates a double fault for debug purposes
;        mov      sp,0
;        push 0

        mov      ebx,dword ptr [esp+2]      ; get entrypoint arg
        xor      eax,eax
        mov      ax,[saveDS]

;
; Setup OS loader's stack. Compute FLAT model esp to id map to
; original stack.
;
        mov      cx,KeDataSelector
        mov      ss,cx
        mov      esp,LOADER_STACK  
;
; Load ds and es with kernel's data selectors
;

        mov      ds,cx
        mov      es,cx

;
; Setup pointer to file system and boot context records
;
; Make a linear pointer to the Boot Context Record

        shl      eax,4
        xor      ecx,ecx
        mov      cx,offset _BootRecord
        add      eax,ecx
        push     eax

        push     1010h       ; dummy return address.
        push     1010h       ; dummy return address.

;
; Push 48bit address of loader entry-point
;
        db OVERRIDE
        push    KeCodeSelector
        push    ebx

;
; Pass control to the OS loader
;
        db OVERRIDE
        retf

_TransferToLoader endp




;++
; Description:
;
;       Gets memory block sizes for memory from zero to one meg and
;       from one meg to 64 meg. We do this by calling int 12h
;       (get conventional memory size) and int 15h function 88h (get
;       extended memory size).
;
; Arguments:
;
;       None
;
; Returns:
;
;       USHORT - Size of usable memory (in pages)
;
;--

public _IsaConstructMemoryDescriptors
BmlTotal        equ     [bp-4]
Func88Result    equ     [bp-6]
_IsaConstructMemoryDescriptors proc near
        push    bp                     ; save ebp
        mov     bp, sp
        sub     sp, 6
;
; Initialize the MemoryList to start with a zero entry.  (end-of-list)
;
        les     si, dword ptr _MemoryDescriptorList
        xor     eax,eax
        mov     es:[si].BlockSize,eax
        mov     es:[si].BlockBase,eax

;
; Get conventional (below one meg) memory size
;
        push    es
        push    si
        int     12h
        movzx   eax,ax
;
; EAX is the number of 1k blocks, which we need to convert to the
; number of bytes.
;
        shl     eax,10

        push    eax
        shr     eax, 12
        mov     BmlTotal, eax
        xor     eax,eax
        push    eax
        call    _InsertDescriptor
        add     sp,8

;
; Get extended memory size and fill-in the second descriptor
;

        mov     ah,88h

        int     15h

        mov     Func88Result,ax
        and     eax,0ffffh
;
; EAX is the number of 1k blocks, which we need to convert to the
; number of bytes.
;
        shl     eax,10
        push    eax
        shr     eax,12
        add     BmlTotal, ax
        mov     eax,0100000h
        push    eax
        call    _InsertDescriptor
        add     sp,8

;
; Try function E801, see if that is supported on this machine
;
        mov     ax,0E801h
        int     15h
        jc      short Isa50

        cmp     ax,Func88Result     ; Is extended memory same as 88?
        je      short Isa40         ; Yes, go add the rest

        cmp     ax, (16-1) * 1024   ; Is extended memory exactly 16MB?
        jne     short Isa50         ; No, conflict between 88 & E801

Isa40:
;
; Function looks like it worked
;
; AX = extended memory < 16M in 1k blocks
; BX = extended memory > 16M in 64k blocks
;
        and     ebx,0ffffh
        jz      short Isa50

        shl     ebx,16              ; ebx = memory > 16M in bytes (via E801)
        add     ebx, 16*1024*1024   ; ebx = end of memory in bytes (via E801)

        mov     ax, Func88Result
        and     eax,0ffffh
        shl     eax, 10             ; eax = memory > 1M in bytes (via 88)
        add     eax, 1*1024*1024    ; eax = end of memory in bytes (via 88)

        sub     ebx, eax            ; ebx = memory above eax
        jbe     short Isa50         ; if ebx <= eax, done

        push    ebx
        shr     ebx,12
        add     BmlTotal, bx
        push    eax
        call    _InsertDescriptor
        add     sp,8
        and     eax,0ffffh

Isa50:
        pop     si
        pop     es
        mov     eax, BmlTotal
        mov     sp, bp
        pop     bp
        ret

_IsaConstructMemoryDescriptors endp

;++
;
; BOOLEAN
; Int15E820 (
;     E820Frame     *Frame
;     );
;
;
; Description:
;
;       Gets address range descriptor by calling int 15 function E820h.
;
; Arguments:
;
; Returns:
;
;       BOOLEAN - failed or succeed.
;
;--

cmdpFrame       equ     [bp + 6]
public _Int15E820
_Int15E820 proc near

        push    ebp
        mov     bp, sp
        mov     bp, cmdpFrame           ; (bp) = Frame
        push    es
        push    edi
        push    esi
        push    ebx

        push    ss
        pop     es

        mov     ebx, [bp].Key
        mov     ecx, [bp].DescSize
        lea     di,  [bp].BaseAddrLow
        mov     eax, 0E820h
        mov     edx, 'SMAP'             ; (edx) = signature

        INT     15h

        mov     [bp].Key, ebx           ; update callers ebx
        mov     [bp].DescSize, ecx      ; update callers size

        sbb     ecx, ecx                ; ecx = -1 if carry, else 0
        sub     eax, 'SMAP'             ; eax = 0 if signature matched
        or      ecx, eax
        mov     [bp].ErrorFlag, ecx     ; return 0 or non-zero

        pop     ebx
        pop     esi
        pop     edi
        pop     es
        pop     ebp
        ret

_Int15E820 endp

;++
;
; t_PXENV_ENTRY far *
; PxenvGetEntry (
;     VOID
; );
;
;
; Description:
;       Get the address of the PXENV Entry Point structure using Int 1Ah.
;
; Arguments:
;       none
;
; Returns:
;       DX:AX := Far pointer to PXENV Entry Point structure.
;
;--

public _PxenvGetEntry
_PxenvGetEntry proc near

        push    ebp                     ; Save important C registers
        push    edi
        push    esi
        push    ds
        push    es

        mov     ax, 5650h               ; Get address of PXENV Entry Point
        int     1Ah                     ; structure.

        jc      no_pxenv_entry          ; CF set if function not supported.

        cmp     ax, 564Eh               ; Check for PXENV API signature.
        jne     no_pxenv_entry

        mov     dx, es                  ; Return far pointer to C in DX:AX.
        mov     ax, bx

        jmp     exit

no_pxenv_entry:
        xor     dx, dx                  ; Return NULL if PXENV Entry Point
        xor     ax, ax                  ; structure is not available.

exit:
        pop     es                      ; Restore C registers.
        pop     ds
        pop     esi
        pop     edi
        pop     ebp

        ret

_PxenvGetEntry endp


;++
;
; UINT16
; PxenvApiCall(
;     UINT16 service,
;     void far *param
; );
;
;
; Description:
;       Make a service call into the PXENV API.
;
; Arguments:
;       ENTRY (TOS+6) := Far pointer to PXENV Entry Point structure
;       SERVICE (TOS+10) := PXENV API service number
;       PARAM (TOS+12) := Far pointer to PXENV API parameter structure
;
; Returns:
;       AX := Return value from PXENV API service
;       Contents of parameter structure will be modified as per API.
;
;--

SERVICE equ     word ptr [bp + 6]
PARAM   equ     dword ptr [bp + 8]

public _PxenvApiCall
_PxenvApiCall proc near

        push    ebp                     ; Save caller's stack frame & use BP
        mov     bp, sp                  ; to reference stack parameters.

        push    ebx                     ; Save all general use registers.
        push    ecx
        push    edx
        push    edi
        push    esi
        push    ds
        push    es

        mov     bx, SERVICE             ; Setup BX & ES:DI for call to

ifdef ALLOW_WAIT_FOR_F12_API
        cmp     bx,-1
        jne     xxxSkip
xxxLoop:
        call    GetKeyEx                ; get keystroke, if any
        mov     ebx,eax                 ; copy it
        cmp     ebx,08600h              ; check for F12
        jz      pxenv_api_ret           ; jump out if F12 pressed
        cmp     ebx,0011Bh              ; check for ESC
        jz      pxenv_api_ret           ; jump out if ESC pressed
        jmp     xxxLoop                 ; loop
xxxSkip:
endif

        les     di, PARAM               ; PXENV API service.

        lds     si, dword ptr _NetPcRomEntry

        push    cs                      ; Push far return address onto stack
        lea     ax, pxenv_api_ret       ; (just as if we did a far call).
        push    ax

        push    ds
        push    si

        retf                            ; Far return into API entry point.

pxenv_api_ret:

        pop     es                      ; Restore all general use registers.
        pop     ds
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx

        pop     ebp                     ; Restore caller's stack frame.

        ret

_PxenvApiCall endp

;++
;
; ULONG
; CheckForF12(
;     VOID
; );
;
;
; Description:
;       This routine spins for three seconds monitoring the keyboard.
;       If the user presses F12, the routine returns immediately with
;       eax==1. If the user presses ESC, the routine returns immediately
;       with eax==0. All other keys are ignored. If neither F12 nor ESC
;       is pressed within three seconds, the routine returns with eax==0.
;       
;       If this is a restart invoked by a loader program (indicate by
;       a block of memory at a known location initialized correctly), the
;       return returns immediately with eax==1.
;
; Arguments:
;       None.
;
; Returns:
;       EAX - 1 if F12 pressed or if this is a restart; otherwise 0.
;
;--

CheckForF12     proc    near

;
; Save DS and ES.
;

        push    ds
        push    es

;
; Set DS and ES to 0.
;

        mov     ax,0
        mov     ds,ax
        mov     es,ax

;
; Point ESI to the last DWORD of the restart block. Check to see if the
; tag value is present. If not, jump to the wait loop.
;

        mov     esi,07c00h + 08000h - 4 ; point to last DWORD of block

        mov     ebx,[esi]               ; get the tag value
        cmp     ebx,'rtsR'              ; is it right?
        jnz     DoF12Check              ; if not, enter wait loop

;
; Calculate the checksum of the block. If it is 0, then this is a valid
; restart block, so pretend that the user pressed F12.
;

        mov     eax,0                   ; accumulated checksum
        mov     ecx,128/4               ; length of block (last 128 bytes
                                        ;  of restart block)

F12csLoop:

        mov     ebx,[esi]               ; get next DWORD
        add     eax,ebx                 ; add it to accumulated checksum
        sub     esi,4                   ; point to previous DWORD
        dec     ecx                     ; check for end of block
        jnz     F12csLoop

        cmp     eax,0                   ; is checksum correct?
        mov     eax,1                   ; indicate F12 pressed
        jz      F12Done                 ; jump out if checksum is correct

DoF12Check:

;
; Write a prompt string. (Yes, this is not internationalizable.)
;

        push    cs                      ; prompt string is in code segment
        pop     ds
        mov     si,offset F12Prompt     ; ds:si points to prompt string

IFDEF HEADLESS_SRV

        mov     ax, cs:TerminalStatus   ; If there is a terminal, initialize it
        and     al, 0b0h
        cmp     al, 0b0h
        jne     SkipTerminalInit

;
; Set color to black on white "\033[m\017"
;
        mov     ah, 01h
        mov     al, 1bh
        int     14h
        mov     ah, 01h
        mov     al, '['
        int     14h
        mov     ah, 01h
        mov     al, 'm'
        int     14h
        mov     ah, 01h
        mov     al, 11h
        int     14h
    
;
; Clear the terminal screen "\033[H\033[J"
; 
        mov     ah, 01h
        mov     al, 1bh
        int     14h
        mov     ah, 01h
        mov     al, '['
        int     14h
        mov     ah, 01h
        mov     al, 'H'
        int     14h
        mov     ah, 01h
        mov     al, 1bh
        int     14h
        mov     ah, 01h
        mov     al, '['
        int     14h
        mov     ah, 01h
        mov     al, 'J'
        int     14h
        
SkipTerminalInit:

endif   

PromptLoop:

        lodsb                           ; get next byte of string
        cmp     al,0                    ; end of string?
        jz      PromptDone              ; jump out if yes

IFDEF HEADLESS_SRV
        
        mov     bx, cs:TerminalStatus   ; if there is a terminal, write out to it as well
        and     bl, 0b0h
        cmp     bl, 0b0h
        jne     SkipTerminalPrompt
        
        mov     ah, 01h                 ; Write command
        mov     dx, HEADLESS_COMPORT    ; Com port
        int     14h                     ; Make com port call
        
SkipTerminalPrompt:

endif

        mov     ah,14
        mov     bx,7
        int     10h                     ; print the byte

        jmp     PromptLoop

PromptDone:

        push    es                      ; restore ds
        pop     ds
        

;
; Capture the current RTC value.
;

        call    GetCounterReal          ; get starting RTC value
        mov     edi,eax                 ; calculate RTC value for now + 3 secs.
IFDEF HEADLESS_SRV
        add     edi,182                 ;  (if this is headless, make it 10 seconds)
ELSE
        add     edi,55                  ;  (RTC clicks 18.2 times per second)
ENDIF

F12Loop:

        call    GetKeyEx                ; get keystroke, if any
        mov     ebx,eax                 ; copy it

        cmp     ebx,08600h              ; check for F12
        mov     eax,1                   ; indicate F12 pressed
        jz      F12Done                 ; jump out if F12 pressed

        cmp     ebx,0DA00h              ; check for F12
        mov     eax,1                   ; indicate F12 pressed
        jz      F12Done                 ; jump out if F12 pressed

        cmp     ebx,0011Bh              ; check for ESC
        mov     eax,0                   ; indicate F12 not pressed
        jz      F12Done                 ; jump out if ESC pressed

        call    GetCounterReal          ; get current RTC value
        cmp     eax,edi                 ; is it higher than end value?
        mov     eax,0                   ; indicate F12 not pressed
        jb      F12Loop                 ; loop if current < end

F12Done:

        pop     es
        pop     ds

        ret

CheckForF12     endp

F12Prompt       db      13,10,"Press F12 for network service boot",13,10,0


;++
;
;   ULONG
;   GetTickCount(
;       VOID
;       )
;
;   Description:
;
;       Reads the tick counter (incremented 18.2 times per second)
;
;   Arguments:
;       None.
;
;--
        public  _GetTickCount
_GetTickCount proc near

		push 	cx
        mov     ah,0
        int     01ah
        mov     ax,dx           ; low word of count
        mov     dx,cx           ; high word of count
		pop     cx
        ret
_GetTickCount endp



_TEXT   ends

        end      Start
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\su.h ===
//
// Master include file for StartUp Module
//

#define i386
#define __stdcall
#define __cdecl
#define UNALIGNED
#pragma warning(4:4103)
#include "types.h"
#include "ntmisc.h"
#include "ntconfig.h"
#include "global.h"
#include "constant.h"
#include "memmap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\su.inc ===
;++
;
; Module name
;
;       su.inc
;
; Author
;
;       Thomas Parslow  (tomp)  Mar-1-90
;
; Description
;
;       Include file for SU.ASM.
;
;
;--

.386

PAGE_SIZE               equ     1000h
MACHINE_TYPE_ISA        equ     0
MACHINE_TYPE_EISA       equ     1
MACHINE_TYPE_MCA        equ     2

;
; Define the segment:offset address pair of the location to
; load detection module.
; N.B. This definition *MUST* be the same as the ones defined
;      in ..\constant.h
;

DETECTION_ADDRESS_SEG   equ     1000h
DETECTION_ADDRESS_OFFSET        equ     0

;
; Structure definitions and equates for INT 15 function E820
;

E820Frame struc
        ErrorFlag       dd      ?
        Key             dd      ?
        DescSize        dd      ?

        BaseAddrLow     dd      ?
        BaseAddrHigh    dd      ?
        SizeLow         dd      ?
        SizeHigh        dd      ?
        MemoryType      dd      ?
E820Frame ends

MemoryDescriptorFramePointer struc
        E820FramePointer    dd      ?
MemoryDescriptorFramePointer ends



;

IFDEF NEC_98
IDT_ENTRIES             equ     100h

BIOS_KEYBOARD_INTERRUPT equ     18h
BIOS_DISK_INTERRUPT     equ     1bh
else  ;NEC_98
BIOS_DISK_INTERRUPT     equ     13h
BIOS_READ_SECTOR        equ     2
IDT_ENTRIES             equ     100h

BIOS_KEYBOARD_INTERRUPT equ     16h
endif ;NEC_98

EXPORT_STACK            equ     07ffeh
RE_ENABLING             equ     1
LOADER_STACK            equ     061ffch

CR0_ET                  equ     10h

;
; Trap Number macro save eax on the stack and then pushes the
; number of the trap that's in progress.
;

TRAP_NUMBER      macro  num,addr
        IF num EQ 9
        push     eax  ; push place holder for error code
        ENDIF
        IF num LE 7
        push     eax  ; push place holder for error code
        ENDIF
        push     eax       ; save eax on stack first
        mov      eax,num
        push     eax
        jmp      addr
        endm

;;
;
; GetSector Stack Frame Structure
;
; Stack frame definition for GetSector call from OS loader
; to 16bit routines.
;
;;

GetSectorFrame          struc
        FunctionNumber  dd      ?
        DriveNumber     dd      ?
        HeadNumber      dd      ?
        TrackNumber     dd      ?
        SectorNumber    dd      ?
        NumberOfSectors dd      ?
        BufferPointer   dd      ?
GetSectorFrame          ends

;;
;
; GetEddsSector Stack Frame Structure
;
; Stack frame definition for GetEddsSector call from OS loader
; to 16bit routines.
;
;;

GetEddsSectorFrame      struc
        DriveNum        dd      ?
        LBNLow          dd      ?
        LBNHigh         dd      ?
        NumberOfBlocks  dd      ?
        BufPointer      dd      ?
        FunctionNum     dd      ?
GetEddsSectorFrame      ends

RebootFrame             struc
        BootType        dd      ?
RebootFrame             ends

;
; ABIOS services Stack Frame Structure
;
; Stack frame definition for ABIOS services call from OS loader
; to 16 bit routine.
;

AbiosServicesFrame      struc
        AbiosFunction   dd      ?
        CommonDataArea  dd      ?
        InitTable       dd      ?
        RamExtension    dd      ?
        AbiosRoutine    dd      ?
        LogicalId       dd      ?
        NumberLids      dd      ?
AbiosServicesFrame      ends

;
; Hardware detection frame structure
;
; Stack frame definition for DetectHardware call from OS loader
; to 16 bit routine.
;

DetectionFrame          struc
        HeapStart       dd      ?
        HeapSize        dd      ?
        ConfigTree      dd      ?
        HeapUsed        dd      ?
        LoadOptions     dd      ?
        OptionsLength   dd      ?
DetectionFrame          ends

;
; HardwareCursor Stack Frame Structure
;
; Stack frame definition for HardwareCursor call from OS loader
; to 16 bit routine.
;

HardwareCursorFrame     struc
        XCoord          dd      ?
        YCoord          dd      ?
HardwareCursorFrame     ends

;
; GetDateTime Stack Frame Structure
;
; Stack frame definition for GetDateTime call from OS loader
; to 16 bit routine.
;

GetDateTimeFrame        struc
        DateDword       dd      ?
        TimeDword       dd      ?
GetDateTimeFrame        ends


;
; ComPort Stack Frame Structure
;
; Stack frame definition for ComPort call from OS loader
; to 16 bit routine.
;

ComPortFrame            struc
        ComPortPort     dd      ?
        ComPortFunction dd      ?
        ComPortArg      dd      ?
ComPortFrame            ends

;
; IsMcaMachine Stack Frame Structure
;
; Stack frame definition for IsMcaMachine call from OS loader
; to 16 bit routine.
;

IsMcaMachineFrame       struc
        Dummy           dd      ?
IsMcaMachineFrame       ends

;;
;
; GetElToritoStatus Stack Frame Structure
;
; Stack frame definition for GetElToritoStatus call from OS loader
; to 16bit routines.
;
;;

GetElToritoStatusFrame     struc
        SpecPacketPointer  dd      ?
        ETDriveNum         dd      ?
GetElToritoStatusFrame     ends

;;
;
; GetExtendedInt13Params Stack Frame Structure
;
; Stack frame definition for GetExtendedInt13Params call from OS loader
; to 16bit routines.
;
;;

GetExtendedInt13ParamsFrame struc
        ParamPacketPointer dd      ?
        Int13UnitNumber    dd      ?            ; really only a byte >= 0x80
GetExtendedInt13ParamsFrame ends

;;
;
; NetPcRomServices Stack Frame Structure
;
; Stack frame definition for NetPcRomServices call from OS loader
; to 16bit routines.
;
;;

NetPcRomServicesFrame struc
        NetPcRomFunctionNumber          dd      ?
        NetPcRomCommandPacketPointer    dd      ?
NetPcRomServicesFrame ends

;;
;
; BiosRedirectService Stack Frame Structure
;
; Stack frame definition for BiosRedirectService call from OS loader
; to 16bit routines.
;
;;

BiosRedirectServiceFrame struc
        Command          dd      ?
BiosRedirectServiceFrame ends

;;
;
; Memory Descriptor Structure.
;
; Passed to OS loader as part of the boot context record
;
;;

MemoryDescriptor struc
        BlockBase       dd              ?
        BlockSize       dd              ?
MemoryDescriptor ends

;;
;
; File System Context Record Structure
;
;;

FsContextRecord struc
        BootDrive       db              ?
FsContextRecord ends

;;
;
; IDT Descriptor Structure
;
;;

TrapDesc        struc
        IDT_offset      dw              ?
        IDT_selector    dw              ?
        IDT_attribute   dw              ?
        IDT_reserved    dw              ?
TrapDesc        ends

;;
;
; GDT Descriptor Structure ;;
;
;;

GDTDesc         struc
        GDT_limit       dw              0
        GDT_base1       dw              0
        GDT_base2       db              0
        GDT_access      db              0
        GDT_limacc      db              0
        GDT_base3       db              0
GDTDesc         ends


;;
;
; GDT Selector Definitions
;
;;

NULL_Selector           equ     0h
KeCodeSelector          equ     8h
KeDataSelector          equ     10h
UsCodeSelector          equ     18h
UsDataSelector          equ     20h
TSS_Selector            equ     28h
PCR_Selector            equ     30h
TEP_Selector            equ     38h
BDA_Selector            equ     40h
KeLdtSelector           equ     48h
DblFltTskSelector       equ     50h
SuCodeSelector          equ     58h
SuDataSelector          equ     60h
VideoSelector           equ     68h
GDT_AliasSelector       equ     70h
DbCodeSelector          equ     78h
DbDataSelector          equ     80h
DebugUseSelector        equ     88h
MdlSelector             equ     90h

;;
;
; Exception Frame Structure
; Note, this absolutely must match the corresponding structure
; defined in "types.h"
;
;;

ExceptionFrame struc
        Ftr     dw       0
        Fdr6    dd       0
        Fcr0    dd       0
        Fcr2    dd       0
        Fcr3    dd       0
        Fss     dw       0
        Fgs     dw       0
        Ffs     dw       0
        Fes     dw       0
        Fds     dw       0
        Fedi    dd       0
        Fesi    dd       0
        Febp    dd       0
        Fesp    dd       0
        Febx    dd       0
        Fedx    dd       0
        Fecx    dd       0
        TrapNum dd       0
        Feax    dd       0
        Error   dd       0
        Feip    dd       0
        Fcs     dd       0
        Feflags dd       0
ExceptionFrame  ends



FUNCTION_ERROR  equ     -1

;;
;
; Register Frame Structure
;
; For bios int calls
;
;;

reg_frame struc
        intnum  dw      ?
        sfg     dw      ?
        sax     dw      ?
        sbx     dw      ?
        scx     dw      ?
        sdx     dw      ?
        ssi     dw      ?
        ses     dw      ?
reg_frame ends

IFDEF NEC_98
gdpRegistors    struc
    rAL     db  0FFh
    FLG     db  ?
    rBX     dw  ?
    rCX     dw  ?
    rDX     dw  ?
gdpRegistors    ends

PartitionDescriptor struc
    BootableFlag        db  ?
    PartitionType       db  ?
    Reserved00          dw  ?
    IPLSector           db  ?
    IPLTrack            db  ?
    IPLCylinder         dw  ?
    StartingSector      db  ?
    StartingTrack       db  ?
    StartingCylinder    dw  ?
    EndingSector        db  ?
    EndingTrack         db  ?
    EndingCylinder      dw  ?
    PartitionName       db  16 dup(?)       ; ASCII strings
PartitionDescriptor ends

BIOS_FLAG           equ     500h        ; byte in ROM work segment
BIOS_FLAG1          equ     480h        ; byte in ROM work segment
BIOS_FLAG4          equ     484h        ; byte in ROM work segment
BIOS_FLAG5          equ     458h        ; byte in ROM work segment
BIOS_FLAG6          equ     45Ah        ; byte in ROM work segment
AT_SWITCH           equ     457h        ; byte in ROM work segment
DAUA                equ     584h        ; byte in ROM work segment
DISK_EQUIP          equ     55Ch        ; byte in ROM work segment
DISK_EQUIPS_SCSI    equ     482h        ; byte in ROM work segment
EXPMMSIZ            equ     401h        ; byte in ROM work segment
EXPMMSZ2            equ     594h        ; word in ROM work segment
DISK_RESULT         equ     564h        ; word in ROM work segment
H_EQUIPS            equ     47Dh        ; byte in ROM work segment
H_DISK_EQUIPS       equ     47Eh        ; word in ROM work segment
EQUIPS_47Ch         equ     47Ch        ; byte in ROM work segment
IC0                 equ     10000000b
IC1                 equ     01000000b
DAFloppy            equ     00010000b   ; floppy bit in DA
DASCSI              equ     00100000b   ; SCSI bit in DA
DASASI              equ     00000000b   ; SASI bit in DA
DEVICEFORMAT        equ     0FFFFh
TRACKFORMAT         equ     00000h
MEMBANK08           equ     91h         ; bank 08
MEMBANK0A           equ     93h         ; bank 0A

ROLLOVER_COUNT      equ     45011       ; 1/18.2 * 2457.6KHz /3
TIMER_VECTOR        equ     (8*4)
TIMER1_DATA_PORT0   equ     71h         ; Timer1, channel 0 data port
TIMER1_CONTROL_PORT0 equ    77h         ; Timer1, channel 0 control port
TIMER1_INTSHAREREG  equ     879h        ; PC-H98 TIMER INT SHARE REGISTER
COMMAND_8254_COUNTER0 equ   00h         ; Select count 0
COMMAND_8254_RW_16BIT equ   30h         ; Read/Write LSB firt then MSB
COMMAND_8254_MODE2  equ     4           ; Use mode 2

UR_DAT              equ     030h        ; data port
UR_LCR              equ     UR_DAT+2    ; line control registers
UR_LSR              equ     UR_DAT+2    ; line status register
UR_IEN              equ     UR_DAT+5    ; Interrupt enable
UR_TIMERSET         equ     75h         ; 8253 counter set
UR_TIMERMODE        equ     77h         ; 8253 counter mode

UR_MODE             equ     01001110B   ; stop 1, disable p, 8 bpc, 1 stop, x16
UR_COMMAND          equ     00110111B   ; RTS, err reset, RXE, DTR, TXEN
UR_RESET            equ     01000000B   ; internal reset command

RD_RDY              equ     02h         ; recieve data ready
TX_RDY              equ     01h         ; transmitter empty if 1
endif ;NEC_98

;;
;; Processor Flags
;;

PROT_MODE               equ     000000001       ; Enable protect mode operation
ENABLE_PAGING           equ     80000000h       ; Enable paging hardware
PD_PHYSICAL_ADDRESS     equ     99000h
TSS_SIZE                equ     80h
OVERRIDE                equ     66h

;
; Operand and Address size overrides
;

OPSIZE          macro
                db 66h
                endm
ADSIZE          macro
                db 67h
                endm


;
; External Procedures for SUDATA.ASM
;

IFDEF SU_CODEMODULE
extrn _SuMain:near
extrn _ScreenStart:near
extrn _vp:near
extrn _putx:near
extrn _TrapHandler:near
extrn _GDTregister:fword
extrn _IDTregister:fword
extrn _IDTregisterZero:fword
extrn saveDS:word
extrn SuStack:word
extrn _edata:word
extrn _FileStart:dword
ENDIF



;
; External Procedures for SUDATA.ASM
;

IFDEF SU_DATAMODULE
extrn  Trap0:far
extrn  Trap1:far
extrn  Trap2:far
extrn  Trap3:far
extrn  Trap4:far
extrn  Trap5:far
extrn  Trap6:far
extrn  Trap7:far
extrn  Trap8:far
extrn  Trap9:far
extrn  TrapA:far
extrn  TrapB:far
extrn  TrapC:far
extrn  TrapD:far
extrn  TrapE:far
extrn  TrapF:far
extrn  _edata:near
ENDIF



;
; Segment declarations for "Small Model" 16 bit Su Module.
;

_TEXT   segment para use16 public 'CODE'
_TEXT   ends

_DATA   segment para use16 public 'DATA'
_DATA   ends

CONST   segment para use16 public 'CONST'
CONST   ends

_BSS    segment para use16 public 'BSS'
_BSS    ends

DGROUP  group   const, _BSS, _DATA


;;; END OF FILE ;;;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\br\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\cs\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\usa\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT has found only %dK of low memory.  512k of low memory\n"  \
"is required to run Windows NT.  You may need to upgrade your\n"      \
"computer or run a configuration program provided by the manufacturer.\n"

#define SU_NO_EXTENDED_MEMORY \
"Windows NT has not found enough extended memory.  7Mb of extended\n"       \
"memory is required to run Windows NT.  You may need to upgrade your\n"     \
"computer or run a configuration program provided by the manufacturer.\n"   \
"\n\nMemory Map:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR is corrupt.  The system cannot boot."

#define PG_FAULT_MSG    " =================== PAGE FAULT ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE FAULT ================================ \n\n"
#define GP_FAULT_MSG    " ============== GENERAL PROTECTION FAULT ======================== \n\n"
#define STK_OVERRUN_MSG " ===== STACK SEGMENT OVERRUN or NOT PRESENT FAULT =============== \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPTION ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** At linear address %lx\n"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\da\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\el\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\trap.asm ===
;++
;
; Module Name:
;
;       trap.asm
;
; Author:
;
;       Thomas Parslow [tomp]
;
; Created:
;
;       15-Jan-91
;
;
; Description:
;
;       x86 exception code
;
;

include su.inc

;
; Exception Routing Table:
; ~~~~~~~~~~~~~~~~~~~~~~~~
; When an exception occurs in the SU module or before the OS loader
; is able to setup its own IDT, control is vectored to one of the
; Trap0 though TrapF labels. We push a number on the stack identifying
; the exception number and then jump to code that pushes the register set
; onto the stack. We then call a general purpose C routine that will dump
; the register contents, the trap number, and error code information
; onto the display.
;

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP
.386p

extrn _TrapHandler:near
extrn _putx:near
extrn _GDTregister:fword
extrn _IDTregister:fword
extrn _InDebugger:word
extrn SaveSP:word

public  Trap0,Trap1,Trap2,Trap3,Trap4,Trap5,Trap6,Trap7
public  Trap8,Trap9,TrapA,TrapB,TrapC,TrapD,TrapE,TrapF


Trap0:  TRAP_NUMBER  0,MakeTrapFrame
Trap1:  TRAP_NUMBER  1,MakeTrapFrame
Trap2:  TRAP_NUMBER  2,MakeTrapFrame
Trap3:  TRAP_NUMBER  3,MakeTrapFrame
Trap4:  TRAP_NUMBER  4,MakeTrapFrame
Trap5:  TRAP_NUMBER  5,MakeTrapFrame
Trap6:  TRAP_NUMBER  6,MakeTrapFrame
Trap7:  TRAP_NUMBER  7,MakeTrapFrame
Trap8:  TRAP_NUMBER  8,MakeTrapFrame
Trap9:  TRAP_NUMBER  9,MakeTrapFrame
TrapA:  TRAP_NUMBER  0Ah,MakeTrapFrame
TrapB:  TRAP_NUMBER  0Bh,MakeTrapFrame
TrapC:  TRAP_NUMBER  0Ch,MakeTrapFrame
TrapD:  TRAP_NUMBER  0Dh,MakeTrapFrame
TrapE:  TRAP_NUMBER  0Eh,MakeTrapFrame
TrapF:  TRAP_NUMBER  0Fh,MakeTrapFrame


;
; We save the user's register contents here on the stack and call
; a C routine to display those contents.
; Uses 42 bytes of stack. (40 for frame)
;
; Note that we build a stack frame that's independent of the code and
; stack segments' "size" during execution. That way whether we enter
; with a 16bit or 32bit stack, the arguments frame is exacely the same.
;

MakeTrapFrame:

        mov      eax,esp
        push     ecx
        push     edx
        push     ebx
        push     eax  ; (eax)=(esp)
        push     ebp
        push     esi
        push     edi

        mov      ax,ds
        push     ax
        mov      ax,es
        push     ax
        mov      ax,fs
        push     ax
        mov      ax,gs
        push     ax
        mov      ax,ss
        push     ax
        mov      eax,cr3
        push     eax
        mov      eax,cr2
        push     eax
        mov      eax,cr0
        push     eax
        mov      eax,dr6
        push     eax
        str      ax
        push     ax
;
; Clear out debug register signals
;

        xor      eax,eax
        mov      dr6,eax

;
; Get a known good data segment
;
        mov      ax,SuDataSelector
        mov      ds,ax
;
; Save system registers
;
        mov      bx,offset DGROUP:_GDTregister
        sgdt     fword ptr [bx]
        mov      bx,offset DGROUP:_IDTregister
        sidt     fword ptr [bx]
;
; Is the exception frame on a 16bit or 32bit stack?
;
        mov      ax,ss
        cmp      ax,KeDataSelector
        je       Trap32
        cmp      ax,DbDataSelector
        jne      mtf8
;
; Most likely we took a trap while initializing the 386 kernel debugger
; So we've got a 16bit stack that isn't ours. We need to move
; the stack frame onto the SU module's stack.

        jmp      Trap16

mtf8:
;
; Frame on a our 16bit stack so just call the trap dump routine
;
        mov      bx,offset DGROUP:SaveSP
        mov      [bx],sp

        call     _TrapHandler

;
; Get rid of the junk we saved just to display
;
        pop      eax      ; get rid of ebp pushed for other returns
        add      sp,ExceptionFrame.Fgs
;
; Reload the user's context and return to 16bit code
;
        pop      gs
        pop      fs
        pop      es
        pop      ds
        pop      edi
        pop      esi
        pop      ebp
        pop      eax
        pop      ebx
        pop      edx
        pop      ecx
        pop      eax      ; get rid of trap #
        pop      eax      ; get original eax
        add      esp,4    ; get rid of error code
;
; Pop IRET frame and return to where the trap occured
;
        OPSIZE
        iret





Trap32:
;
; The exception frame is on a 32bit stack so we must setup a 16bit
; stack and then move the exception frame on to it before calling
; the trap dump routine.
;

        mov      ebx,esp
;
; Setup a known good stack
;
        mov      ax,SuDataSelector
        mov      ss,ax
        mov      sp,EXPORT_STACK
;
; Copy the exception frame to the new stack
;

        mov     ecx, (size ExceptionFrame)/2 ; # of words in frame
        mov     esi,ebx                 ; (esi) = offset of argument frame
        push    KeDataSelector          ; (ax) = Flat 32bit segment selector
        pop     ds                      ; (ds:esi) points to argument frame
        push    ss                      ;
        pop     es                      ; (es) = 16bit stack selector
        sub     sp, size ExceptionFrame ; make room for the arguments
        xor     edi,edi                 ; clear out upper 16bits of edi
        mov     di,sp                   ; (es:edi) points to top of stack
;
; Loop and copy a word at a time.
;
msf1:
        mov     ax,[esi]
        mov     es:[edi],ax
        add     esi,2
        add     edi,2
        loop    msf1

        push    es                      ;
        pop     ds                      ; put 16bit selector back into ds

;
; Now call the general purpose exception handler
;
        push     ebx                    ; save esp for return
;
;  Save SP in order to restore the stack in case we
;  take a fault in the debugger
;
        mov      bx,offset DGROUP:SaveSP
        mov      [bx],sp

        call     _TrapHandler

IFDEF  DEBUG0
public DebugReturn
DebugReturn:
ENDIF ;DEBUG
        pop      ebx
;
; We may have changed the flags while in the debugger. Copy the
; new eflag to the iret frame. After we restore the original stack
; pointers.
;

        mov      bp,sp
        mov      ecx,[bp].Feflags

        mov      ax,KeDataSelector
        mov      ss,ax
        mov      esp,ebx

        mov      [esp].Feflags,ecx
;
; Get rid of the junk we saved just to display
;
        add      esp,ExceptionFrame.Fgs
;
; Reload the user's context
;
        pop      gs
        pop      fs
        pop      es
        pop      ds
        pop      edi
        pop      esi
        pop      ebp
        pop      eax
        pop      ebx
        pop      edx
        pop      ecx
        pop      eax      ; get rid of trap #
        pop      eax      ; get original eax
        add      esp,4    ; get rid of error code
;
; Pop IRET frame and return to where the trap occured
;
        OPSIZE
        iret


Trap16:

; The exception frame is on a 16bit stack that isn't ours. So we must
; move the exception frame on to the SU module's stack before calling
; the trap dump routine.
;

        mov      ebx,esp
;
; Setup a known good stack
;
        mov      ax,SuDataSelector
        mov      ss,ax
        mov      sp,EXPORT_STACK
;
; Copy the exception frame to the new stack
;

        mov      ecx, (size ExceptionFrame)/2
        mov      si,bx                 ; (esi) = offset of argument frame
        push     DbDataSelector          ;
        pop      ds                      ; (ds:esi) points to argument frame
        push     ss                      ;
        pop      es                      ; (es) = 16bit stack selector
        sub      sp, size ExceptionFrame ; make room for the arguments
        mov      di,sp                   ; (es:edi) points to top of stack
;
; Loop and copy a word at a time.
;
Trap16_10:
        mov      ax,[si]
        mov      es:[di],ax
        add      si,2
        add      di,2
        loop     Trap16_10

        push     es                      ;
        pop      ds                      ; put 16bit selector back into ds

;
; Now call the general purpose exception handler
;

        push     ebx                    ; save (original esp) for return
;
;  Save SP in order to restore the stack in case we
;  take a fault in the debugger
;
        mov      bx,offset DGROUP:SaveSP
        mov      [bx],sp

        call     _TrapHandler

IFDEF  DEBUG0
public Debug16Return
Debug16Return:
ENDIF ;DEBUG
        pop      ebx
;
; We may have changed the flags while in the debugger. Copy the
; new eflag to the iret frame. After we restore the original stack
; pointers.
;

        mov      bp,sp
        mov      ecx,dword ptr [bp].Feflags

        mov      ax,DbDataSelector
        mov      ss,ax
        mov      esp,ebx

        mov      dword ptr ss:[bx].Feflags,ecx
;
; Get rid of the junk we saved just to display
;
        add      sp,ExceptionFrame.Fgs
;
; Reload the user's context
;
        pop      gs
        pop      fs
        pop      es
        pop      ds
        pop      edi
        pop      esi
        pop      ebp
        pop      eax
        pop      ebx
        pop      edx
        pop      ecx
        pop      eax      ; get rid of trap #
        pop      eax      ; get original eax
        add      esp,4    ; get rid of error code
;
; Pop IRET frame and return to where the trap occured
;
        OPSIZE
        iret



_TEXT   ends
        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\makefile.inc ===
# Copyright (C) by Microsoft Corporation.
#
# MAKEFILE for NT SU.X86
#
# Created:
#               91.01.18
#
# Author:
#               Thomas Parslow
#

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

.SUFFIXES:       .com .exe .obj .lst .c .asm .def .lnk .inc


#
#       C Compiler Definitions
#       ~~~~~~~~~~~~~~~~~~~~~~

# Environment Variable to set debugging level
# LOADER_DEBUG is the debugging level for building the OS loader, SU module, and BFSD. It should be
# set to either -DDEBUG0 or -DDEBUG1 to enable either level 1 or 2 debugging.
#
!IFDEF ALT_PROJECT_MAKE
ALT_PROJECT_FLAGS=-D$(ALT_PROJECT)
!ENDIF

PATH= $(PATH_TOOLS16);$(PATH)

CC=     cl16
CFLAGS= -W3 -G2s -Zelp $(LOADER_DEBUG)  $(BLFLAGS) $(ALT_PROJECT_FLAGS)
CINC=   -I. -I$(SDK_INC_PATH) -I..\i386 -I..\i386\$(LANGUAGE)


#
#       Assembler Definitions
#       ~~~~~~~~~~~~~~~~~~~~~

ASM=    masm386
AFLAGS= -Mx  -z $(LOADER_DEBUG) $(GAFLAGS) $(ALT_PROJECT_FLAGS)
AINC=  -I$(SDK_INC_PATH) -I..\i386


#
#       Linker Definitions
#       ~~~~~~~~~~~~~~~~~~

LINK=link16 /map:full
LIBS=..\long.lib
DEF=


#
#       Rules for generating objects
#       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~



{..\i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
        $(ASM) $(AFLAGS) $(AINC) $< $@;

{..\i386\}.asm.lst:
        $(ASM) -l -n $(AFLAGS) $(AINC) $<;

#        $(CC) $(CFLAGS) $(CINC) -c $<

{..\i386\}.c{$(_OBJ_DIR)\i386\}.obj:
    $(CC) $(CFLAGS) $(CINC) -Fo$@  -c $<

{..\}.c{$(_OBJ_DIR)\i386\}.obj:
    $(CC) $(CFLAGS) $(CINC) -Fo$@ -c $<

{..\i386\}.c.lst:
        $(CC) $(CFLAGS) -Fc$*.cod -Fo$*.obj -dos $(CINC) -c $<


#
#       List of object files required
#       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

OBJ= $(_OBJ_DIR)\i386\su.obj  $(_OBJ_DIR)\i386\exp.obj  $(_OBJ_DIR)\i386\sudata.obj \
$(_OBJ_DIR)\i386\eisaa.obj  $(_OBJ_DIR)\i386\a20.obj  $(_OBJ_DIR)\i386\trap.obj  $(_OBJ_DIR)\i386\eisac.obj \
$(_OBJ_DIR)\i386\main.obj  $(_OBJ_DIR)\i386\trapdump.obj $(_OBJ_DIR)\i386\display.obj $(_OBJ_DIR)\i386\backend.obj


#
#       Dependencies
#       ~~~~~~~~~~~~


$(_OBJ_DIR)\i386\startup.com: $(OBJ)

$(_OBJ_DIR)\i386\exp.obj         exp.lst:        ..\i386\exp.asm ..\i386\su.inc ..\i386\macro.inc

$(_OBJ_DIR)\i386\eisaa.obj       eisaa.lst:      ..\i386\eisa.inc ..\i386\eisaa.asm

$(_OBJ_DIR)\i386\eisac.obj       eisac.lst:      ..\i386\eisa.h ..\i386\eisac.c

$(_OBJ_DIR)\i386\su.obj          su.lst:         ..\i386\su.asm ..\i386\su.inc

$(_OBJ_DIR)\i386\sudata.obj      sudata.lst:     ..\i386\sudata.asm ..\i386\su.inc ..\i386\memmap.inc

$(_OBJ_DIR)\i386\main.obj        main.lst:       ..\i386\main.c ..\i386\global.h ..\i386\types.h ..\i386\constant.h

$(_OBJ_DIR)\i386\trap.obj        trap.lst:       ..\i386\trap.asm ..\i386\su.inc

$(_OBJ_DIR)\i386\trapdump.obj    trapdump.lst:   ..\i386\trapdump.c ..\i386\types.h ..\i386\constant.h

$(_OBJ_DIR)\i386\display.obj     display.lst:    ..\i386\display.c ..\i386\types.h ..\i386\constant.h ..\i386\global.h

$(_OBJ_DIR)\i386\backend.obj     backend.lst:    ..\i386\backend.asm

$(_OBJ_DIR)\i386\startup.com: $(OBJ) $(DOBJ) $(LIBS)
        $(LINK) @<<
/tiny /nod /noi +
$(OBJ)
$(_OBJ_DIR)\i386\startup.com
$(_OBJ_DIR)\i386\startup.map
$(LIBS)

<<
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\sudata.asm ===
;++
;
; Module name
;
;       su.asm
;
; Author
;
;       Thomas Parslow  (tomp)  Mar-1-90
;
; Description
;
;       Static data for Startup module for the 386 NT OS loader. The gdt
;       idt, and double fault tss are statically defined here. Also most
;       of the zero init static data is defined here because the SU module
;       must have a zero length .bss section.
;
;
;--

.386p

SU_DATAMODULE       equ      1


include su.inc
include memmap.inc



_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

;
; Global Descriptor Table
;
; Note, the SuCode and SuData segments must have limits of 64k in
; order for the mode switch code to work.
;

public _Beginx86Relocation
public _GDT

_Beginx86Relocation       equ      $
_GDT  equ $
;;;
;;;   Lim 0-15,  Base0-15,Base 16-23, LimAcc,
;;;

;
; Selector 00h - Null selector - unsused
;

GDTDesc <00000h, 00000h, 000h, 000h, 000h, 000h>

;
; Selector 08h  KeCodeSelector  - kernel code segment : FLAT 4gig limit
;

GDTDesc <0ffffh, 00000h, 000h, 09ah, 0cfh, 000h>

;
; Selector 10h - KeDataSelector - kernel data segment : FLAT 4gig limit
;

GDTDesc <0ffffh, 00000h, 000h, 092h, 0cfh, 000h>

;
; Selector 18h - UsCodeSelector - User code segment : FLAT 2gig limit
;

GDTDesc <0ffffh, 00000h, 000h, 0fah, 0cfh, 000h>

;
; Selector 20h - UsDataSelector - User data segment : FLAT 2gig limit
;
GDTDesc <0ffffh, 00000h, 000h, 0f2h, 0cfh, 000h>

;
; Selector 28h - TSS_Selector - Kernels TSS
;

GDTDesc <EndTssKernel - _TssKernel - 1, offset _TEXT:_TssKernel, \
002h, 089h, 000h, 000h> ; TSS

;
; Selector 30h - PCR_Selector - Master Boot Processor's PCR segment
;       This is actually edited later in BlSetupForNt in order to
;       point to a page located at a high virtual address.
;

GDTDesc <01h, 00000h, 000h, 092h, 0c0h, 000h>

;
; Selector 38h - TEP_Selector - Thread Environment
;

GDTDesc <0fffh, 00000h, 000h, 0f3h, 040h, 000h>

;
; Selector 40 - BDA_SAelector - Bios Data Area near-clone
;

GDTDesc <0ffffh, 00400h, 000h, 0f2h, 000h, 000h>

;
; Selector 48h - LdtDescriptor - used to load an ldt
;       (Gets set at Ldt set and process switch by the kernel)
;

GDTDesc <00000h, 00000h, 000h, 000h, 000h, 000h>

;
; Selector 50h - DblFltTskSelector - Double Fault TSS
;

GDTDesc <EndTssDblFault32 - _TssDblFault32 - 1, offset _TEXT:_TssDblFault32,  \
002h, 089h, 000h, 000h> ;

;
; Selector 58h - SuCodeSelector - Startup module's code segment
;

GDTDesc <0ffffh, 00000h, 002h, 09ah, 000h, 000h>

;
; Selector 60h - SuDataSelector - Startup module's data segment
;

GDTDesc <0ffffh, offset _TEXT:DGROUP, 002h, 092h, 000h, 000h>

;
; Selector 68h - VideoSelector - Video display buffer
;

GDTDesc <03fffh, 08000h, 00bh, 092h, 000h, 000h>

;
; Selector 70h - GDT_AliasSelector - GDT Alias Selector
;

GDTDesc <EndGDT - _GDT - 1, 7000h, 0ffh, 092h, 000h,0ffh>


; Debug selectors : CURRENTLY NOT USED

GDTDesc <0ffffh, 00000h, 040h, 09ah, 000h, 080h>  ; 78 Debug Code
GDTDesc <0ffffh, 00000h, 040h, 092h, 000h, 080h>  ; 80 Debug Data
GDTDesc <00000h, 00000h, 000h, 092h, 000h, 000h>  ; 88 Debug Use
GDTDesc <0ffffh, 00000h, 007h, 092h, 000h, 000h>  ; 90 Memory Descriptor List
DEFINED_GDT_ENTRIES     equ     ($ - _GDT) / size GDTDesc
                 dq ((1024 / size GDTDesc) - DEFINED_GDT_ENTRIES) DUP(0)
EndGDT  equ      $
GDT_SIZE         equ      (EndGDT - _GDT)


;;
;; Interrupt Descriptor Table
;;


public _IDT
align   16
_IDT    equ      $
TrapDesc         <offset Trap0,  KeCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap1,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap2,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap3,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap4,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap5,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap6,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap7,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap8,  SuCodeSelector, 8f00h,  0>
;TrapDesc         <offset Trap8,  DblFltTskSelector,8500h,  0>
TrapDesc         <offset Trap9,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapA,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapB,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapC,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapD,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapE,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapF,  SuCodeSelector, 8f00h,  0>
DEFINED_IDT_ENTRIES     equ     ($ - _IDT) / size TrapDesc
                 dq (IDT_ENTRIES - DEFINED_IDT_ENTRIES) DUP(0)



EndIDT                    equ   $
public _Endx86Relocation
_Endx86Relocation         equ      $

;
; disk-base table.  We copy it from the ROM to here so we can patch the
; last sector number.  This lets us access both 5.25" and 3.5" drives.
;
Public _DiskBaseTable
_DiskBaseTable  equ     $
    SpecifyBytes dw 0
    WaitTime     db 0
    SectorLength db 0
    LastSector   db 0
    SecGapLength db 0
    DataTransfer db 0
    TrackGapLength db 0
    DataValue    db 0
    HeadSettle   db 0
    StartupTime  db 0

Public _RomDiskBasePointer
_RomDiskBasePointer dd 0

;
; Enhanced Disk Drive Spec. Disk Address Packet
;
Public _EddsAddressPacket
_EddsAddressPacket  equ     $
    PacketSize   db  10h
    Reserved1    db  0
    Blocks2Xfer  dw  0
    XferBuf      dd  0
    LBALow       dd  0
    LBAHigh      dd  0

;
; Task State Segment for Double Fault Handler
;
Public _TssDblFault
align 16
_TssDblFault     equ      $
        dw       0 ;link
        dw       offset _DATA:DblFaultStack
        dw       SuDataSelector
        dd       0 ; ring1 ss:sp
        dd       0 ; ring2 ss:sp
        dw       offset _TEXT:Trap8
        dw       0 ; flags
        dw       0 ; ax
        dw       0 ; cx
        dw       0 ; dx
        dw       0 ; bx
        dw       offset _DATA:DblFaultStack ; sp
        dw       0 ; bp
        dw       0 ; si
        dw       0 ; di
        dw       SuDataSelector  ; es
        dw       SuCodeSelector  ; cs
        dw       SuDataSelector  ; ss
        dw       SuDataSelector  ; ds
        dw       0 ; ldt selector
        dw       0
EndTssDblFault   equ      $


_TssDblFault32   equ      $
        dd       0 ;link
        dd       offset _DATA:DblFaultStack
        dd       SuDataSelector
        dd       0 ; ring1 esp
        dd       0 ; ring1 ss
        dd       0 ; ring2 esp
        dd       0 ; ring2 ss
        dd       PD_PHYSICAL_ADDRESS
        dd       offset _TEXT:Trap8
        dd       0 ; eflags
        dd       0 ; eax
        dd       0 ; ecx
        dd       0 ; edx
        dd       0 ; ebx
        dd       offset _DATA:DblFaultStack ; sp
        dd       0 ; bp
        dd       0 ; si
        dd       0 ; di
        dd       SuDataSelector  ; es
        dd       SuCodeSelector  ; cs
        dd       SuDataSelector  ; ss
        dd       SuDataSelector  ; ds
        dd       0 ;fs
        dd       0 ;gs
        dd       0 ; ldt selector
        dd       0 ; i/o map
        dd       0 ;
        dd       0 ;
EndTssDblFault32   equ      $



;
; Stack for Double Fault Handler Task
;

public _FileStart
_FileStart       dd       0

align 4
public DblFaultStack
                 dw       50 DUP(0)
DblFaultStack    equ      $

;
; Note that we need at least 2k of real-mode stack because some EISA BIOS
; routines require it.
;
align 4
public SuStack
public _SuStackBegin
_SuStackBegin    equ      $
                 db       2048 DUP (0)
SuStack          equ      $

align 16
public _TssKernel
_TssKernel       dw       60  DUP(0)
EndTssKernel     equ      $

align 4
public _GDTregister
_GDTregister     dw       EndGDT - _GDT - 1
                 dw       (SYSTEM_PAGE_PA and 0ffffh) + offset DGROUP:_GDT
                 dw       (SYSTEM_PAGE_PA SHR 16) and 0ffh

align 4
public _IDTregister
_IDTregister     dw       EndIDT - _IDT - 1
                 dw       (SYSTEM_PAGE_PA and 0ffffh) + offset DGROUP:_IDT
                 dw       (SYSTEM_PAGE_PA SHR 16) and 0ffh

;
; We load the idtr from the this fword .
;
public _IDTregisterZero
_IDTregisterZero dw       0ffffh
                 dd       0

;
; We save the base of the real mode data segment here so we
; can use it later in calculations of the linear address of
; the start of DGROUP.
;
public saveDS
saveDS           dw       0
;
; When ever we enter the debugger we set this variable to
; on so we can tell if we've faulted in the debugger when
; we get an exception.
;
public _InDebugger
_InDebugger      dw       0

; We save SP here when we get an exception in the debugging
; version of the SU module. If we get an exception in the
; debugger, we use this value to reset the stack to point to
; the base of the original exception/break-point stack frame.
;
public SaveSP
SaveSP           dw       0

;
; NetPcRomEntry is the address of the entry point exported by the
; NetPC ROM.
;

public _NetPcRomEntry
_NetPcRomEntry  dd      0

;
; BOOT CONTEXT RECORD
;

;
; Export Entry Table
;

extrn RebootProcessor:near
extrn GetSector:near
extrn GetEddsSector:near
extrn GetKey:near
extrn GetCounter:near
extrn Reboot:near
extrn DetectHardware:near
extrn HardwareCursor:near
extrn GetDateTime:near
extrn ComPort:near
extrn GetStallCount:near
extrn InitializeDisplayForNt:near
extrn GetMemoryDescriptor:near
extrn GetElToritoStatus:near
extrn GetExtendedInt13Params:near
extrn NetPcRomServices:near
extrn BiosRedirectService:near

SU_LOAD_ADDRESS equ 20000h



; FsContext
;
;
public _FsContext
align 4
_FsContext FsContextRecord      <0>

;
; Memory Descriptor Table
;       The Memory Descriptor Table begins at 7000:0000 and grows upward.
;       Note that this is 64k above the start of the OS Loader Heap and
;       64k below the start of the OS Loader Stack.  This is ok, since the
;       x86 Arc Emulation will have converted all of this information into
;       Arc Memory Descriptors before the OS Loader is initialized.
;

align 4
public _MemoryDescriptorList
_MemoryDescriptorList  dw       0
                       dw       7000h

;
; This is called the External Services Table by the OS loader
;

;**
;   NOTE WELL
;       The offsets of entries in this table must match its twin
;       in startup\i386\sudata.asm, and the structure in boot\inc\bldrx86.h
;**
align 4
public _ExportEntryTable
_ExportEntryTable equ     $
                 dw       offset _TEXT:RebootProcessor
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetSector
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetKey
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetCounter
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:Reboot
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:DetectHardware
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:HardwareCursor
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetDateTime
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:ComPort
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetStallCount
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:InitializeDisplayForNt
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetMemoryDescriptor
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetEddsSector
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetElToritoStatus
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetExtendedInt13Params
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:NetPcRomServices
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       0             ; null slot for
                 dw       0             ; apmattemptreconnect
                 dw       offset _TEXT:BiosRedirectService
                 dw       SU_LOAD_ADDRESS SHR 16
                 dd       0
;**
; See note above
;**

align 4
Public _BootRecord
_BootRecord      dw       offset _TEXT:_FsContext
                 dw       SU_LOAD_ADDRESS SHR 16

                 dw       offset _TEXT:_ExportEntryTable
                 dw       SU_LOAD_ADDRESS SHR 16

;
; The memory descriptor table begins at 0x70000
;
                 dw       0
                 dw       7

public _MachineType
_MachineType     dd       0             ; Machine type infor.

;
; pointer to where osloader.exe is in memory
;
public _OsLoaderStart
_OsLoaderStart          dd      0
public _OsLoaderEnd
_OsLoaderEnd            dd      0
public _ResourceDirectory
_ResourceDirectory      dd      0
public _ResourceOffset
_ResourceOffset         dd      0
public _OsLoaderBase
_OsLoaderBase           dd      0
public _OsLoaderExports
_OsLoaderExports        dd      0
public _BootFlags
_BootFlags              dd      0
public _NtDetectStart
_NtDetectStart          dd      0
public _NtDetectEnd
_NtDetectEnd            dd      0
public _SdiAddress
_SdiAddress             dd      0


;
; Defines the machine variables, we can use them to check the validity of
; loaded Ram Extension later.
;

                public  MachineModel, MachineSubmodel, BiosRevision
MachineModel            db      0
MachineSubmodel         db      0
BiosRevision            db      0

;
; keeps track of 8042 access failing so we can avoid doing it repeatedly
;
public _Empty_8042Failed
_Empty_8042Failed       db      0

_DATA   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\trapdump.c ===
/*++

Copyright (c) 1990  Microsoft Corporation


Module Name:

    trap.c

Author:

    Thomas Parslow   [TomP]  Mar-01-90


Abstract:

    General purpose trap handler for 80386 boot loader. When built in
    debugger is present, output is redirected to the com port. When no
    debugger is present, output goes to the display.


--*/

#include "su.h"

extern
USHORT
InDebugger;

extern
USHORT
DebuggerPresent;

extern
UCHAR
GDTregister;

extern
UCHAR
IDTregister;

extern
VOID
OutPort(
    USHORT
    );

extern
USHORT
InPort(
    VOID
    );

extern
VOID
ReEnterDebugger(
    VOID
    );

extern
USHORT
TssKernel;

extern
USHORT
Redirect;

extern
VOID RealMode(
    VOID
    );

VOID
TrapHandler(
    IN ULONG,
    IN USHORT
    );

VOID
DumpProcessorContext(
    VOID
    );

VOID
DumpSystemRegisters(
    VOID
    );

VOID
DumpCommonRegisters(
    VOID
    );

VOID
DisplayFlags(
    ULONG f
    );


VOID
DumpTSS(
    VOID
    );


ULONG
GetAddress(
    VOID
    );

VOID
GetNumber(
    PCHAR cp
    );

USHORT
GetChar(
    VOID
    );

VOID
DumpAddress(
    ULONG
    );

#define PG_FAULT_MSG    " =================== PAGE FAULT ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE FAULT ================================ \n\n"
#define GP_FAULT_MSG    " ============== GENERAL PROTECTION FAULT ======================== \n\n"
#define STK_OVERRUN_MSG " ===== STACK SEGMENT OVERRUN or NOT PRESENT FAULT =============== \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPTION ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define ishex(x)  ( ( x >= '0' && x <= '9') || (x >= 'A' && x <= 'F') || (x >= 'a' && x <= 'f') )


//
// Global Trap Frame Pointer
//

PTF TrapFrame;


VOID
TrapHandler(
    IN ULONG Padding,
    IN USHORT TF_base
    )
/*++

Routine Description:

    Prints minimal trap information

Arguments:


    386 Trap Frame on Stack

Environment:

    16-bit protect mode only.


--*/

{
    //
    // Initialize global trap frame pointer and print trap number
    //

    TrapFrame = (PTF)&TF_base;

    //
    // Fix esp to point to where it pointed before trap
    //

    TrapFrame->Fesp += 24;

    BlPrint("\n TRAP %lx ",TrapFrame->TrapNum);

    //
    // Print the trap specific header and display processor context
    //

    switch(TrapFrame->TrapNum) {

        case 1:
        case 3:
            puts( DEBUG_EXCEPTION );
            DumpCommonRegisters();
            break;

        case 8:
            puts( DBL_FAULT_MSG );
            DumpTSS();
            break;

        case 12:
            puts( STK_OVERRUN_MSG );
            DumpProcessorContext();
            break;

        case 13:
            puts( GP_FAULT_MSG );
            DumpProcessorContext();
            break;

        case 14:
            puts( PG_FAULT_MSG );
            BlPrint("** At linear address %lx\n",TrapFrame->Fcr2);
            DumpProcessorContext();
            break;

        default :
            puts( EX_FAULT_MSG );
            DumpProcessorContext();
            break;
    }

    RealMode();
    while (1); //**** WAITFOREVER *** //


}


VOID
DumpProcessorContext(
    VOID
    )
/*++

Routine Description:

    Dumps all the processors registers. Called whenever a trap or fault
    occurs.

Arguments:

    None

Returns:

    Nothing

--*/
{
    DumpSystemRegisters();
    DumpCommonRegisters();
}

VOID
DumpSystemRegisters(
    VOID
    )
/*++

Routine Description:

    Dumps (writes to the display or com poirt) the x86 processor control
    registers only. Does not dump the common registers (see
    DumpCommonRegisters)

Arguments:

    None

Returns:

    Nothing


--*/
{
    BlPrint("\n tr=%x  cr0=%lx  cr2=%lx  cr3=%lx\n",
            TrapFrame->Ftr,TrapFrame->Fcr0,TrapFrame->Fcr2,TrapFrame->Fcr3);
    BlPrint(" gdt limit=%x  base=%lx    idt limit=%x  base=%lx\n",
          *(PUSHORT)&GDTregister,*(PULONG)(&GDTregister + 2),
          *(PUSHORT)&IDTregister,*(PULONG)(&IDTregister + 2));
}



VOID
DumpCommonRegisters(
    VOID
    )
/*++

Routine Description:

    Dumps (writes to the display or com poirt) the x86 processor
    commond registers only.

Arguments:

    None

Returns:

    Nothing


--*/
{
    USHORT err;

    //
    // Is the error code valid or just a padding dword
    //

    if ((TrapFrame->TrapNum == 8) || (TrapFrame->TrapNum >= 10 && TrapFrame->TrapNum <= 14) )
        err = (USHORT)TrapFrame->Error;
    else
        err = 0;

    //
    // Display the processor's common registers
    //

    BlPrint("\n cs:eip=%x:%lx  ss:esp=%x:%lx  errcode=%x\n",
        (USHORT)(TrapFrame->Fcs & 0xffff),TrapFrame->Feip,(USHORT)TrapFrame->Fss,TrapFrame->Fesp,err);
    DisplayFlags(TrapFrame->Feflags);
    BlPrint(" eax=%lx  ebx=%lx  ecx=%lx  edx=%lx",TrapFrame->Feax,TrapFrame->Febx,TrapFrame->Fecx,TrapFrame->Fedx);
    BlPrint(" ds=%x  es=%x\n",TrapFrame->Fds,TrapFrame->Fes);
    BlPrint(" edi=%lx  esi=%lx  ebp=%lx  cr0=%lx",TrapFrame->Fedi,TrapFrame->Fesi,TrapFrame->Febp,TrapFrame->Fcr0);
    BlPrint(" fs=%x  gs=%x\n",TrapFrame->Ffs,TrapFrame->Fgs);

}


VOID
DisplayFlags(
    ULONG f
    )
/*++

Routine Description:

    Writes the value of the key flags in the flags register to
    the display or com port.

Arguments:

    f - the 32bit flags word

Returns:

    Nothing

--*/
{

    BlPrint(" flags=%lx  ",f);
    if (f & FLAG_CF) puts("Cy "); else puts("NoCy ");
    if (f & FLAG_ZF) puts("Zr "); else puts("NoZr ");
    if (f & FLAG_IE) puts("IntEn"); else puts("IntDis ");
    if (f & FLAG_DF) puts("Up "); else puts("Down ");
    if (f & FLAG_TF) puts("TrapEn \n"); else puts("TrapDis \n");

}



VOID
DumpTSS(
    VOID
    )
/*++

Routine Description:

    Writes the contents of the TSS to the display or com port when
    called after a double fault.

Arguments:

    None

Returns:

    Nothing

--*/
{

    PTSS_FRAME pTss;

//  FP_SEG(Fp) = Fcs;
//  FP_OFF(Fp) = Fip;

    pTss = (PTSS_FRAME) &TssKernel;

    //
    //  Dump the outgoing TSS
    //

    BlPrint("Link %x\n",pTss->Link);
    BlPrint("Esp0 %x\n",pTss->Esp0);
    BlPrint("SS0  %x\n",pTss->SS0);
    BlPrint("Esp1 %lx\n",pTss->Esp1);
    BlPrint("Cr3  %lx\n",pTss->Cr3);
    BlPrint("Eip  %lx\n",pTss->Eip);
    BlPrint("Eflg %lx\n",pTss->Eflags);
    BlPrint("Eax  %lx\n",pTss->Eax);
    BlPrint("Ebx  %lx\n",pTss->Ebx);
    BlPrint("Ecx  %lx\n",pTss->Ecx);
    BlPrint("Edx  %lx\n",pTss->Edx);
    BlPrint("Esp  %lx\n",pTss->Esp);
    BlPrint("Ebp  %lx\n",pTss->Ebp);
    BlPrint("Esi  %lx\n",pTss->Esi);
    BlPrint("Edi  %lx\n",pTss->Edi);
    BlPrint("ES   %x\n",pTss->ES);
    BlPrint("CS   %x\n",pTss->CS);
    BlPrint("SS   %x\n",pTss->SS);
    BlPrint("DS   %x\n",pTss->DS);
    BlPrint("FS   %x\n",pTss->FS);
    BlPrint("GS   %x\n",pTss->GS);
    BlPrint("Ldt  %x\n",pTss->Ldt);
    RealMode();
    while(1);
}

// END OF FILE

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startrom\i386\types.h ===
/*

File

      types.h


Description

      defines and structure definitions for nt386 boot loader


Author

      Thomas Parslow  [TomP]

*/

#define IN
#define OUT
#define OPTIONAL
#define NOTHING
#define CONST               const

//
// Void
//

typedef void *PVOID;    // winnt

//
// Basics
//

#define VOID    void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
typedef long LONGLONG;

//
// ANSI (Multi-byte Character) types
//

typedef CHAR *PCHAR;

typedef double DOUBLE;

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt

//
// Unsigned Basics
//

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef unsigned long ULONGLONG;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef ULONG KAFFINITY;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;

//
// Far point to Basic
//

typedef UCHAR far  * FPCHAR;
typedef UCHAR far  * FPUCHAR;
typedef VOID far   * FPVOID;
typedef USHORT far * FPUSHORT;
typedef ULONG far  * FPULONG;

//
// Boolean
//

typedef CCHAR BOOLEAN;
typedef BOOLEAN *PBOOLEAN;

//
// UNICODE (Wide Character) types
//

typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;

//
// Large (64-bit) integer types and operations
//

typedef struct _LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

#define FP_SEG(fp) (*((unsigned *)&(fp) + 1))
#define FP_OFF(fp) (*((unsigned *)&(fp)))
#define toupper(x) (((x) >= 'a' && (x) <= 'z') ? x - 'a' + 'A' : x )
#define isascii(x) (((x) >= ' ' && (x) < 0x80) ? 1 : 0)

#define FLAG_CF 0x01L
#define FLAG_ZF 0x40L
#define FLAG_TF 0x100L
#define FLAG_IE 0x200L
#define FLAG_DF 0x400L

#define TRUE 1
#define FALSE 0
#define NULL   ((void *)0)

typedef UCHAR far  * FPCHAR;
typedef UCHAR far  * FPUCHAR;
typedef VOID far   * FPVOID;
typedef USHORT far * FPUSHORT;
typedef ULONG far  * FPULONG;
typedef UCHAR FAT;
typedef FAT * PFAT;
typedef LONG  NTSTATUS;


typedef struct _FSCONTEXT_RECORD {
    UCHAR BootDrive;
} FSCONTEXT_RECORD, *PFSCONTEXT_RECORD;

typedef struct {
    USHORT SpecifyBytes;
    UCHAR  WaitTime;
    UCHAR  SectorLength;
    UCHAR  LastSector;
    UCHAR  SecGapLength;
    UCHAR  DataTransfer;
    UCHAR  TrackGapLength;
    UCHAR  DataValue;
    UCHAR  HeadSettle;
    UCHAR  StartupTime;
} DISK_BASE_TABLE;

//
// biosint register structure
//

typedef struct {
   USHORT   fn;
   USHORT   fg;
   USHORT   ax;
   USHORT   bx;
   USHORT   cx;
   USHORT   dx;
   USHORT   si;
   USHORT   es;
} BIOSREGS;


//
// Trap Frame Structure when error code is present
//

typedef struct {
    USHORT Ftr;
    ULONG  Fdr6;
    ULONG  Fcr0;
    ULONG  Fcr2;
    ULONG  Fcr3;
    USHORT Fss;
    USHORT Fgs;
    USHORT Ffs;
    USHORT Fes;
    USHORT Fds;
    ULONG  Fedi;
    ULONG  Fesi;
    ULONG  Febp;
    ULONG  Fesp;
    ULONG  Febx;
    ULONG  Fedx;
    ULONG  Fecx;
    ULONG  TrapNum;
    ULONG  Feax;
    ULONG  Error;
    ULONG  Feip;
    ULONG  Fcs;
    ULONG  Feflags;

} TF_ERRCODE, *PTF ;

//
//  Task State Segment structure
//

typedef struct {
    USHORT Link;
    USHORT a;
    ULONG  Esp0;
    USHORT SS0;
    USHORT b;
    ULONG  Esp1;
    USHORT SS1;
    USHORT c;
    ULONG  Esp2;
    USHORT SS2;
    USHORT d;
    ULONG  Cr3;
    ULONG  Eip;
    ULONG  Eflags;
    ULONG  Eax;
    ULONG  Ecx;
    ULONG  Edx;
    ULONG  Ebx;
    ULONG  Esp;
    ULONG  Ebp;
    ULONG  Esi;
    ULONG  Edi;
    USHORT ES;
    USHORT e;
    USHORT CS;
    USHORT f;
    USHORT SS;
    USHORT g;
    USHORT DS;
    USHORT h;
    USHORT FS;
    USHORT i;
    USHORT GS;
    USHORT j;
    USHORT Ldt;
    USHORT k;

} TSS_FRAME, *PTSS_FRAME;


//
// Overlay structure of disk bios parameter block
//

typedef struct {
   USHORT   bps;
   UCHAR    spc;
   USHORT   sra;
   UCHAR    cof;
   USHORT   rde;
   USHORT   tns;
   UCHAR    dmd;
   USHORT   spf;
   USHORT   spt;
   USHORT   noh;
   union {
   USHORT   shs;
   ULONG    bhs;   // hidden sectors
   } hs;
   ULONG    bts;  // extended total sectors
} DISKBPB;

typedef DISKBPB far * FPDISKBPB;



//
// FAT directory structure
//

typedef struct {
   CHAR     fname[11];
   UCHAR    attrb;
   UCHAR    rsrv[10];
   USHORT   time;
   USHORT   date;
   USHORT   clust;
   ULONG    size;

} DIRENTRY,*PDIRENTRY,far * FPDIRENTRY;

typedef struct {
   CHAR  fname[11];
   UCHAR attrb;
   UCHAR rsrv[10];
   USHORT time;
   USHORT date;
   USHORT starting_cluster;
   ULONG file_size;
   ULONG fptr;
   PUCHAR clusterbuffer;
   USHORT cur_phys_cluster;
   USHORT cur_file_cluster;
} FILEDESCRIPTOR,* FILEHANDLE;

/*
typedef struct {

   USHORT bff[FAT_BUFFERS];
   USHORT usebuf;
   FAT *  fcptr;

} FATCACHE;
*/

typedef struct {
   USHORT   limit;
   USHORT   base1;
   UCHAR     base2;
   UCHAR     access;
   UCHAR     limacc;
   UCHAR     base3;
} _GDT,far *FPGDT;


// Debugger initialization table

typedef  ULONG  IDT,*PIDT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\es\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\fr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\fi\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\hu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\ger\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\constant.h ===
/*--

    Module Name

        constant.h

    Author

        Thomas Parslow  (tomp)

--*/

//
// Debugging Level defines
//

#ifdef DEBUG0
#define DBG0(x)     x
#define DBG1(x)
#elif defined  DEBUG1
#define DBG0(x)     x
#define DBG1(x)     x
#else
#define DBG0(x)
#define DBG1(x)
#endif

#define WAITFOREVER while(1);
#define BUGCHECK    while(1);


#define ENTRIES_PER_PAGETABLE       1024
#define PAGE_SIZE                   0x1000
#define ENABLING                    0
#define RE_ENABLING                 1



//
// Define page-table-entry bit definitions
//
//     Dir       Table
//  ----------==========
//  00000000000000000000xxxxxxxxxxxx
//                           ::::::+--- Present    = 1 - Not Present = 0
//                           :::::+---- ReadWrite  = 1 - Read only   = 0
//                           ::::+----- UserAccess = 1 - Supervisor  = 0
//                           :::+------ Reserved
//                           ::+------- Reserved
//                           :+-------- Dirty      = 1 - Not written = 0
//                           +--------- Accessed   = 1 - No accessed = 0

#define  PAGE_SUPERVISOR     0x0000
#define  PAGE_READ_ONLY      0x0000
#define  PAGE_PRESENT        0x0001
#define  PAGE_NOT_PRESENT    0x0000
#define  PAGE_READ_WRITE     0x0002
#define  PAGE_USER_ACCESS    0x0004
#define  PAGE_PERSIST        0x0200 // Tells kernel maintain
//
//  Define RWSP (Read, Write, Supervisor, Present)
//

#define  PAGE_RWSP      0L | PAGE_READ_WRITE | PAGE_SUPERVISOR | PAGE_PRESENT
#define  PAGE_ROSP      0L | PAGE_READ_ONLY | PAGE_SUPERVISOR | PAGE_PRESENT
// Since the entire boot process occurs at ring 0, the only way we can
// protext areas that we don't want trashed is too mark them not present
#define  PAGE_NO_ACCESS    0L | PAGE_READ_ONLY  | PAGE_SUPERVISOR | PAGE_NOT_PRESENT


//
// Page-entry macros
//

#define PD_Entry(x)     (USHORT)((x)>>22) & 0x3ff
#define PT_Entry(x)     (USHORT)((x)>>12) & 0x3ff
#define PAGE_Count(x)     (USHORT)((x)/PAGE_SIZE) + (((x) % PAGE_SIZE) ? 1 : 0)
#define PhysToSeg(x)    (USHORT)((x) >> 4) & 0xffff
#define PhysToOff(x)    (USHORT)((x) & 0x0f)
#define MAKE_FP(p,a)    FP_SEG(p) = (USHORT)((a) >> 4) & 0xffff; FP_OFF(p) = (USHORT)((a) & 0x0f)
#define MAKE_FLAT_ADDRESS(fp) ( ((ULONG)FP_SEG(fp) * 16 ) +  (ULONG)FP_OFF(fp) )

//
// Machine type definitions.
// N.B.  All the constants defined here
//       must match the ones defined in ntos\inc\i386.h
//

#define MACHINE_TYPE_ISA 0
#define MACHINE_TYPE_EISA 1
#define MACHINE_TYPE_MCA 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\eisa.inc ===
;++
;
;   Copyright (c) 1989	Microsoft Corporation
;
;   Module Name:
;
;	eisa.inc
;
;   Abstract:
;
;	This module contains the assembly structures and definitions
;       for making 16-bit real mode EISA BIOS calls.
;
;   Author:
;
;	Shie-Lin (shielint) 7-June-1991
;
;   Revision History:
;
;--

;
; EISA BIOS call function number.
;

GET_EISA_SLOT_INFORMATION     equ 0D800h
GET_EISA_FUNCTION_INFORMATION equ 0D801h

;
; Length of EISA information block
;

EISA_INFORMATION_BLOCK_LENGTH equ 320

;
; Structure for EISA slot information block
;

EISA_SLOT_INFORMATION   struc

    SlotReturn                  db      0
    SlotFlags                   db      0
    SlotMajorRevision           db      0
    SlotMinorRevision           db      0
    SlotChecksum                dw      0
    SlotNumberFunctions         db      0
    SlotFunctionInformation     db      0
    SlotCompressedId            dd      0

EISA_SLOT_INFORMATION   ends

;
; Structure for EISA function information block
;

EISA_FUNCTION_INFORMATION       struc

    FunctionReturn      db      0
    FunctionInformation db      EISA_INFORMATION_BLOCK_LENGTH dup (0)

EISA_FUNCTION_INFORMATION       ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\eisaa.asm ===
title  "EISA bus Support Assembley Code"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    eisaa.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to get configuration
;    information on EISA machines.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 7-June-1991
;
; Environment:
;
;    Real Mode 16-bit code.
;
; Revision History:
;
;
;--


.386p
        .xlist
include eisa.inc
        .list

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

        public  _FunctionInformation
_FunctionInformation     db      0
                         db      EISA_INFORMATION_BLOCK_LENGTH dup (0)

_DATA   ends

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT

;++
;
; VOID
; BtGetEisaSlotInformation (
;    PBTEISA_SLOT_INFORMATION SlotInformation,
;    UCHAR Slot
;    )
;
; Routine Description:
;
;    This function retrieves the slot information for the specified slot.
;
; Arguments:
;
;    SlotInformation - Supplies a pointer to the structure which will
;                      receive the slot information.
;
;    Slot - Specifies the slot to retrieve the information.
;
; Return Value:
;
;    None.
;
;--

BgesSlotInformation     equ     [bp + 4]
BgesSlot                equ     [bp + 6]

        public  _BtGetEisaSlotInformation
_BtGetEisaSlotInformation       proc

        push    bp                      ; The following INT 15H destroies
        mov     bp, sp                  ;   ALL the general registers.
        push    si
        push    di
        push    bx

        mov     cl, BgesSlot
        mov     ax, GET_EISA_SLOT_INFORMATION
        int     15h

        push    bx                      ; Save revision level
        mov     bx, BgesSlotInformation

        ;
        ; fill values into eisa slot info structure.
        ;

        mov     [bx].SlotReturn, ah
        mov     [bx].SlotFlags, al
        pop     ax                      ; [ax] = revision level
        mov     [bx].SlotMajorRevision, ah
        mov     [bx].SlotMinorRevision, al
        mov     [bx].SlotChecksum, cx
        mov     [bx].SlotNumberFunctions, dh
        mov     [bx].SlotFunctionInformation, dl
        mov     word ptr [bx].SlotCompressedId, di
        mov     word ptr [bx+2].SlotCompressedId, si

        pop     bx
        pop     di
        pop     si
        pop     bp
        ret

_BtGetEisaSlotInformation       endp

;++
;
; UCHAR
; BtGetEisaFunctionInformation (
;    PBTEISA_FUNCTION_INFORMATION FunctionInformation,
;    UCHAR Slot,
;    UCHAR Function
;    )
;
; Routine Description:
;
;    This function retrieves function information for the specified slot
;    and function.
;
; Arguments:
;
;    FunctionInformation - Supplies a pointer to the structure which will
;           receive the slot information.
;
;    Slot - Specifies the slot to retrieve the information.
;
;    Function - Supplies the function number of the desired slot.
;
; Return Value:
;
;    Return code of the EISA function call.
;
;--

BgefFunctionInformation equ     [bp + 4]
BgefSlot                equ     [bp + 6]
BgefFunction            equ     [bp + 8]

        public  _BtGetEisaFunctionInformation
_BtGetEisaFunctionInformation     proc

        push    bp
        mov     bp, sp
        push    si

        mov     ax, GET_EISA_FUNCTION_INFORMATION
        mov     cl, BgefSlot            ; [cl] = slot, [ch]=function
        mov     ch, BgefFunction
        mov     si, BgefFunctionInformation
                                        ; (ds:si)->Function information
        int     15h

        mov     al, ah                  ; move the return code to AL

        pop     si
        pop     bp
        ret
_BtGetEisaFunctionInformation     endp

;++
;
; BOOLEAN
; BtIsEisaSystem (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines if the target machines is EISA based machines.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    TRUE - if this is EISA machine.  Otherwise, a value of FALSE is returned.
;--

        public _BtIsEisaSystem
_BtIsEisaSystem proc

        push    es
        push    bx

;
;       Check for an EISA system.  If "EISA" is at F000:FFD9h then it
;       is an EISA system.
;

        mov     ax,0f000h               ; segment
        mov     es,ax
        mov     bx,0ffd9h               ; offset in the ROM
        mov     eax, "ASIE"
        cmp     eax, es:[bx]
        jne     short bies00            ; if ne, Not EISA system, go bies00

        mov     ax, 1                   ; set return value to TRUE
        jmp     short bies10

bies00:
        mov     ax, 0
bies10:
        pop     bx
        pop     es
        ret
_BtIsEisaSystem endp

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\eisa.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisa.h

Abstract:

    This module contains the i386 EISA bus specific header file.

Author:

    Shie-Lin Tzong (shielint) 6-June-1991

Revision History:

--*/

//
// SU module's version of the memory descriptor
//
typedef struct _MEMORY_LIST_ENTRY {
    ULONG BlockBase;
    ULONG BlockSize;
} MEMORY_LIST_ENTRY, *PMEMORY_LIST_ENTRY;


//
// SU module's version of the address space parameters for int-15 E820 calls
//

typedef struct {
    ULONG       ErrorFlag;
    ULONG       Key;
    ULONG       Size;
    struct {
        ULONG       BaseAddrLow;
        ULONG       BaseAddrHigh;
        ULONG       SizeLow;
        ULONG       SizeHigh;
        ULONG       MemoryType;
    } Descriptor;
} E820Frame;


//
// Misc. definitions
//

#define _16MEGB                  ((ULONG)16 * 1024 * 1024)
#define _64MEGB                  ((ULONG)64 * 1024 * 1024)

typedef CM_EISA_SLOT_INFORMATION BTEISA_SLOT_INFORMATION;
typedef CM_EISA_SLOT_INFORMATION *PBTEISA_SLOT_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION BTEISA_FUNCTION_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION *PBTEISA_FUNCTION_INFORMATION;
typedef EISA_MEMORY_CONFIGURATION BTEISA_MEMORY_CONFIGURATION;
typedef EISA_MEMORY_CONFIGURATION *PBTEISA_MEMORY_CONFIGURATION;

BOOLEAN
FindFunctionInformation (
    IN UCHAR SlotFlags,
    IN UCHAR FunctionFlags,
    OUT PBTEISA_FUNCTION_INFORMATION Buffer,
    IN BOOLEAN FromBeginning
    );

USHORT
CountMemoryBlocks (
    VOID
    );

ULONG
EisaConstructMemoryDescriptors (
    VOID
    );

UCHAR
BtGetEisaSlotInformation (
   PBTEISA_SLOT_INFORMATION SlotInformation,
   UCHAR Slot
   );

UCHAR
BtGetEisaFunctionInformation (
   PBTEISA_FUNCTION_INFORMATION FunctionInformation,
   UCHAR Slot,
   UCHAR Function
   );

BOOLEAN
BtIsEisaSystem (
   VOID
   );

//
// External References
//

extern MEMORY_LIST_ENTRY _far *MemoryDescriptorList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

!ENDIF

MAJORCOMP=ntos
MINORCOMP=startup

TARGETNAME=startup.com
TARGETPATH=obj
TARGETTYPE=UMAPPL_NOLIB

INCLUDES=$(SDK_INC_PATH);..\..\inc;..\..\..\inc;..\..\..\config;..\..\..\nthals

SOURCES=

i386_SOURCES=..\i386\su.asm         \
             ..\i386\exp.asm        \
             ..\i386\sudata.asm     \
             ..\i386\eisaa.asm      \
             ..\i386\eisac.c        \
             ..\i386\main.c         \
             ..\i386\a20.asm        \
             ..\i386\trap.asm       \
             ..\i386\trapdump.c     \
             ..\i386\display.c      \
             ..\i386\backend.asm    \


!IF $(386)

NTTARGETFILES=$(_OBJ_DIR)\i386\startup.com

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\backend.asm ===
;++
;
; Module Name:
;
;       backend.asm
;
; Module Description:
;
;       This module is needed only to get around a linker quirk we
;       run into because we're linking an app compiled as a "small"
;       model app as a "tiny" model app.
;
; This is how we find the end of the com file and the beginning of the
; OS loader coff header. This file must always be linked last when
; generating STARTUP.COM
;--


.386p

_DATA   segment para use16 public 'DATA'

public _BackEnd
_BackEnd equ $

_DATA   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\global.h ===
/*++

Copyright (c) 1990  Microsoft Corporation


File Name:

   global.h


Abstract:

     Prototypes for all global functions defined for the 386 NT bootloader


Author

    Thomas Parslow  (TomP) 2-Jan-90



--*/


VOID
SuMain(
    IN UCHAR BtBootDrive
    );

extern
USHORT
Debugger;


/////
///// IN sumain.c
/////


VOID
SetupPageTables(
    VOID
    );


//
// in Supage.c
//

extern
VOID
InitializePageTables(
    VOID
    );

VOID
ZeroMemory(
    ULONG,
    ULONG
    );


VOID
PrintBootMessage(
    VOID
    );

/*
VOID
DoGlobalInitialization(
    IN FPVOID,
    IN FPDISKBPB,
    IN USHORT
    );


VOID
MoveMemory(
    IN ULONG,
    IN PUCHAR,
    IN USHORT
    );


/////
///// IN disk.c
/////

VOID
InitializeDiskSubSystem(
    IN FPDISKBPB,
    IN USHORT
    );

/*

VOID
InitializePageSets(
    IN PIMAGE_FILE_HEADER
    );

VOID
EnableA20(
    VOID
    );


extern IDT IDT_Table;

*/

/////
///// IN su.asm
/////


VOID
EnableProtectPaging(
    USHORT
    );


SHORT
biosint(
    IN BIOSREGS far *
    );

extern
VOID
TransferToLoader(
    ULONG
    );


/////
///// IN video.c
/////

VOID
InitializeVideoSubSystem(
    VOID
    );

VOID
putc(
    IN CHAR
    );
VOID
putu(
    IN ULONG
    );

VOID
puts(
    IN PCHAR
    );

VOID
puti(
    IN LONG
    );

VOID
putx(
    IN ULONG
    );

VOID
scroll(
    VOID
    );

VOID
clrscrn(
    VOID
    );

VOID
BlPrint(
    IN PCHAR,
    ...
    );


// END OF FILE //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\a20.asm ===
;  NOTICE
;  This was taken from the os2 bios sources and was slightly modified to
;  enable the a20 line. There's still some work to do and much clean-up to
;  bring the file upto coding standards. I'll do this when time permits.
;  TomP


;* _EnableA20
;* Description:                                                               *
;*      This routine enables and disables the A20 address line, depending on  *
;*      the value in ax                                                       *
;*                                                                            *
;*      In general when in real mode we want the A20 line disabled,           *
;*      when in protected mode enabled. However if there is no high           *
;*      memory installed we can optimise out unnecessary switching            *
;*      of the A20 line. Unfortunately the PC/AT ROM does not allow           *
;*      us to completely decouple mode switching the 286 from gating          *
;*      the A20 line.                                                         *
;*                                                                            *
;*      In real mode we would want A20 enabled if we need to access           *
;*      high memory, for example in a device driver. We want it               *
;*      disabled while running arbitrary applications because they            *
;*      may rely on the 1 meg address wrap feature which having the           *
;*      A20 line off provides.                                                *
;*                                                                            *
;*      This code is largely duplicated from the PC/AT ROM BIOS.              *
;*      See Module "BIOS1" on page 5-155 of the PC/AT tech ref.               *
;*                                                                            *
;*      WARNING:                                                              *
;*                                                                            *
;*      The performance characteristics of these routines                     *
;*      are not well understood. There may be worst case                      *
;*      scenarios where the routine could take a relatively                   *
;*      long time to complete.                                                *
;*                                                                            *
;* Linkage:                                                                   *
;*      far call                                                              *
;*                                                                            *
;* Input:                                                                     *
;*                                                                            *
;* Exit:                                                                      *
;*      A20 line enabled/disabled                                             *
;*                                                                            *
;* Uses:                                                                      *
;*      ax                                                                    *
;*                                                                            *
;* Internal References:                                                       *
;*      empty_8042  --  waits for 8042 input buffer to drain                  *

.386p
include su.inc

IODelay macro
        jmp     $+2
        endm

extrn  _puts:near
extrn  _Empty_8042Failed:near


; Equates for cmos

CMOS_DATA       equ     71h             ; I/O word for cmos chip
SHUT_ADDR       equ     8fh             ; shutdown byte address in cmos
SHUT_CODE       equ     9               ; block copy return code we use


; equates for 8042
STATUS_PORT     equ     64h             ; 8042 com port
PORT_A          equ     60h             ; 8042 data port
BUF_FULL        equ     2               ; 8042 busy bit


SHUT_CMD        equ     0feh            ; RESET 286 command

MSW_VIRTUAL     equ     1               ; protected mode bit of MSW

MASTER_IMR      equ     21h             ; mask port for master 8259


;CONST   SEGMENT WORD USE16 PUBLIC 'CONST'
;CONST   ENDS

;_BSS   SEGMENT WORD USE16 PUBLIC 'BSS'
;_BSS   ENDS

;DGROUP  GROUP   CONST, _BSS, _DATA
;        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP


;++
;
;VOID
;EnableA20(
;    VOID
;    )
;
;Routine Description:
;
;    Enables the A20 line for any machine.  
;
;Arguments:
;
;    None
;
;Return Value:
;
;    None.
;
;    The A20 line is enabled.
;
;--
        public  _EnableA20

_EnableA20      proc    near

;            Check if empty_8042 has failed before
;            If so, skip this function.  This would occur
;            on legacy free systems.

         mov   di,offset DGROUP:_Empty_8042Failed
         cmp   byte ptr [di],1
         jz   EA2
         
;         cmp   byte ptr [di],0
        
        call    empty_8042              ; ensure 8042 input buffer empty
        jnz     EA2                     ; 8042 error return


;            Enable or disable the A20 line

        mov     al,0d1h                 ; 8042 cmd to write output port
        out     STATUS_PORT,al          ; send cmd to 8042
        call    empty_8042              ; wait for 8042 to accept cmd
        jnz     EA2                     ; 8042 error return
        mov     al,0dfh                 ; 8042 port data
        out     PORT_A,al               ; output port data to 8042
        call    empty_8042

;       We must wait for the a20 line to settle down, which (on an AT)
;       may not happen until up to 20 usec after the 8042 has accepted
;       the command.  We make use of the fact that the 8042 will not
;       accept another command until it is finished with the last one.
;       The 0FFh command does a NULL 'Pulse Output Port'.  Total execution
;       time is on the order of 30 usec, easily satisfying the IBM 8042
;       settling requirement.  (Thanks, CW!)

        mov     al,0FFh                 ;* Pulse Output Port (pulse no lines)
        out     STATUS_PORT,al          ;* send cmd to 8042
        call    empty_8042              ;* wait for 8042 to accept cmd

EA2:
        ret

_EnableA20   endp


;++
;
;VOID
;DisableA20(
;    VOID
;    )
;
;Routine Description:
;
;    Disables the A20 line for any machine. 
;
;Arguments:
;
;    None
;
;Return Value:
;
;    None.
;
;    The A20 line is disabled.
;
;--
        public  _DisableA20

_DisableA20      proc    near

;            Check if empty_8042 has failed before
;            If so, skip this function.  This would occur
;            on legacy free systems.

         mov   di,offset DGROUP:_Empty_8042Failed
         cmp   byte ptr [di],1
         jz   EA2
         
         cmp   byte ptr [di],0
            
DA1:
        call    empty_8042              ; ensure 8042 input buffer empty
        jnz     DA2                     ; 8042 error return


;            Disable the A20 line

        mov     al,0d1h                 ; 8042 cmd to write output port
        out     STATUS_PORT,al          ; send cmd to 8042
        call    empty_8042              ; wait for 8042 to accept cmd
        jnz     DA2                     ; 8042 error return
        mov     al,0ddh                 ; 8042 port data
        out     PORT_A,al               ; output port data to 8042
        call    empty_8042

;       We must wait for the a20 line to settle down, which (on an AT)
;       may not happen until up to 20 usec after the 8042 has accepted
;       the command.  We make use of the fact that the 8042 will not
;       accept another command until it is finished with the last one.
;       The 0FFh command does a NULL 'Pulse Output Port'.  Total execution
;       time is on the order of 30 usec, easily satisfying the IBM 8042
;       settling requirement.  (Thanks, CW!)

        mov     al,0FFh                 ;* Pulse Output Port (pulse no lines)
        out     STATUS_PORT,al          ;* send cmd to 8042
        call    empty_8042              ;* wait for 8042 to accept cmd

DA2:
        ret

_DisableA20   endp
;**
; empty_8042 -- wait for 8042 input buffer to drain
;
; Input:
;      interrupts disabled
;
; Exit:
;      al=0, z=0   => 8042 input buffer empty
;
; Uses:
;      ax, flags

        public  Empty8042
Empty8042     proc    near
empty_8042:
        sub     cx,cx                   ; cx = 0, timeout loop counter

emp1:   in      al,STATUS_PORT          ; read 8042 status port
        IODelay
        IODelay
        IODelay
        IODelay
        and     al,BUF_FULL             ; test buffer full bit
        loopnz  emp1

        cmp     cx,0                    ; see if buffer is full
        jnz     emp2
        

        ; if we reached this point this indicates an error
        
        mov   di,offset DGROUP:_Empty_8042Failed
        mov   byte ptr [di],1
        
        
        
;        mov     [_Empty_8042Failed],1                    ; set Empty_8042Failed global to "TRUE"
;        mov     _Empty_8042Failed,1                    ; set Empty_8042Failed global to "TRUE"
;        mov     cx, offset _Empty_8042Failed
;        mov     [cx],ah
                

emp2:
        and   al,BUF_FULL                               ; reset the Z flag
        ret

Empty8042     endp

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\macro.inc ===
;++
;
; File Name:
;
;       macro.inc
;
; Author:
;
;       Thomas Parslow [tomp]
;
; Created:
;
;       27-Feb-91
;
; Abstract:
;
;       The macros used for creating the exported entry points the
;       OS loader will use for basic h/w dependent services. These
;       services are:
;
;       o       Disk I/O
;       o       Character I/O
;
;
;--


;++
;
; EXPORT_ENTRY_MACRO
; We arrive here from the OS loader with a 32bit CS. That is, we're
; executing the code with cs:eip where cs contains a selector for a
; 32bit flat segment. We want to get to a 16bit cs. That is, cs:ip.
; The entry points are exported as 32bit near pointers to the OS loader.
; All code in the SU module is identity mapped so the flat 32bit offset
; is equal to the physical address.
;
; Therefore, we export the 32bit physical address as the
; entry point and the code may be executed with either the 32bit
; flat cs or the SU module's 16bit based cs.  Before we can switch
; modes we must load all of the segment registers with selectors for
; 16bit segments.  We start by pushing a far pointer to a label in
; the macro and then doing a retf. This allows us to fall through
; to the next instruction, but we're now executing through cs:ip
; with a 16bit CS.
;
; Output:
;
;       (ebx) = pointer to stack frame (and top of 32bit stack).
;

EXPORT_ENTRY_MACRO  macro entryname
        LOCAL    exp1
_TEXT32 segment para use32 public 'CODE'
        ASSUME CS:_TEXT32
ALIGN 4
Public  EntryName
EntryName LABEL near
;
; We've go a 32bit CS:EIP - go to a 16bit CS:IP

        push     dword ptr SuCodeSelector
        push     dword ptr (offset exp1)

        retf
_TEXT32 ends
        ASSUME CS:_TEXT
ALIGN 4
exp1:
;
; Save caller's EBP register and stack pointer (ESP)
;

        push     ebp
        push     ebx
        push     esi
        push     edi
        mov      ebx,esp
;
; Load all the segment registers with 16bit segment selectors
;
        mov      ax,SuDataSelector
        mov      ds,ax
        mov      ss,ax
;
; Set the stack to the top of the segment. We can do this now since
; all of the OS loader's code has already be relocated. Also, we need
; plenty of stack since we'll be calling BIOS routines.
;
        mov      sp,EXPORT_STACK
        push     ebx                  ; save the caller's esp
        endm
;
; EXPORT_ENTRY_MACRO end
;



;++
;
; Name:
;
;       ExportExit
;
; Arguments:
;
;
; Notes:
;
;       EAX = return code and MUST be preserved by this macro.
;
;--

EXPORT_EXIT_MACRO macro
;
; Next get caller's esp that we saved upon entry on the 16bit stack
;
        pop      ebx                    ; get caller's esp
;
; Restore flat selectors in segment registers.
;
        mov      dx,KeDataSelector
        mov      ds,dx
        mov      ss,dx
        mov      es,dx
        mov      esp,ebx


;
; Restore callers' ebp that we saved on the 32bit stack
;
        pop      edi
        pop      esi
        pop      ebx
        pop      ebp      ; (ebp) = caller's ebp

;
; Pull callers flat return address off stack and push the
; flat code selector followed by the return offset, then
; execute a far return and we'll be back in the OS loaders code space.
;
        pop      edx      ; (edx) = caller's return address
        push     dword ptr KeCodeSelector
        push     edx
        db OVERRIDE
        retf
        endm

;++
;
;
;
;--

RE_ENABLE_PAGING_MACRO macro
extrn _EnableProtectPaging:near
        push     RE_ENABLING
        call     _EnableProtectPaging
        add      sp,2
        endm

ENTER_REALMODE_MACRO macro
extrn _RealMode:near
        call    _RealMode
        endm



WAIT_FOREVER_MACRO macro
        LOCAL wf1
wf1:    jmp     wf1
        endm

;++
;
; MAKE_STACK_FRAME_MACRO
;
; Arguments:
;
;    _FrameName_ - is the name of the structure defining the
;                  stack frame layout.
;
;    _PointerRegister_ - is the register containing the linear pointer to
;                        the top of the stack frame.
; ProtectMode ONLY
;
;--

MAKE_STACK_FRAME_MACRO macro _FrameName_ , _PointerRegister_
Local msf1
        mov     ecx, (size _FrameName_)/2
        mov     esi,_PointerRegister_   ; (esi) = offset of argument frame
        add     esi,20                  ; account for ebp, ebx, esi, edi and
                                        ; return address
        push    KeDataSelector          ; (ax) = Flat 32bit segment selector
        pop     ds                      ; (ds:esi) points to argument frame
        push    ss                      ;
        pop     es                      ; (es) = 16bit stack selector
        sub     sp, size _FrameName_    ; make room for the arguments
        xor     edi,edi                 ; clear out upper 16bits of edi
        mov     di,sp                   ; (es:edi) points to top of stack
msf1:
        mov     ax,[esi]
        mov     es:[edi],ax
        add     esi,2
        add     edi,2
        loop    msf1
        push    es                      ;
        pop     ds                      ; put 16bit selector back into ds
        endm


REMOVE_STACK_FRAME_MACRO macro _FrameName_

        add     sp, size _FrameName_
        endm


;BuildDescriptor macro   Base,Limit,Access,Dpl,Stype
;        dw       (Limit AND 0ffffh)
;        dw       (Base AND 0ffffh)
;        db       ((Base SHR 16) AND 0ffh)
;        db       (Gran + Dpl + Stype)
;        db       ((Limit SHR 16) AND 0ffh)
;        db       ((Base SHR 24) AND 0ffh)
;        endm



;
;
;
RETURNCODE_IN_EAX_MACRO macro

        shl      edx,16
        mov      dx,ax
        mov      eax,edx
        endm

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\memmap.h ===
//
// The following memory address definitions apply to
// indentity mapped objects for the x86 environment.
//

#define RM_PROTECT_BASE_VA          0x000000
#define RM_PROTECT_BASE_PA          0x000000
#define RM_PROTECT_SIZE             0x001000
#define RM_PROTECT_ATTRIBUTES       PAGE_ROSP

#define BPB_BASE_VA                 0x007000
#define BPB_BASE_PA                 0x007000
#define BPB_SIZE                    0x001000
#define BPB_ATTRIBUTES              PAGE_ROSP

#define SU_MODULE_BASE_VA           0x020000
#define SU_MODULE_BASE_PA           0x020000
#define SU_MODULE_SIZE              0x020000
#define SU_MODULE_ATTRIBUTES        PAGE_RWSP

#define LOADER_BASE_VA              0x040000
#define LOADER_BASE_PA              0x040000
#define LOADER_SIZE                 0x020000
#define LOADER_ATTRIBUTES           PAGE_RWSP

#define SYSTEM_STRUCTS_BASE_VA      0x80420000
#define SYSTEM_STRUCTS_BASE_PA      0x00017000
#define SYSTEM_STRUCTS_SIZE         0x002000
#define SYSTEM_STRUCTS_ATTRIBUTES   PAGE_RWSP + PAGE_PERSIST

#define PAGE_TABLE_AREA_BASE_VA     0x00099000
#define PAGE_TABLE_AREA_BASE_PA     0x00099000
#define PAGE_TABLE_AREA_SIZE        0x002000
#define PAGE_TABLE_AREA_ATTRIBUTES  PAGE_RWSP + PAGE_PERSIST

#define LDR_STACK_BASE_VA           0x09b000
#define LDR_STACK_BASE_PA           0x09b000
#define LDR_STACK_SIZE              0x001000
#define LDR_STACK_ATTRIBUTES        PAGE_RWSP
#define LDR_STACK_POINTER           0x09bffe // in su.inc also

#define VIDEO_BUFFER_BASE_VA        0x0B8000
#define VIDEO_BUFFER_BASE_PA        0x0B8000
#define VIDEO_BUFFER_SIZE           0x004000
#define VIDEO_BUFFER_ATTRIBUTES     PAGE_RWSP


#define HYPER_PAGE_DIRECTORY        0xC0300C00
#define HYPER_SPACE_BEGIN           0xC0000000  // points to 1st page table
#define HYPER_SPACE_SIZE            0x8000L
#define HYPER_SPACE_ENTRY           768
#define PAGE_TABLE1_ADDRESS         0xC0000000L
#define PD_PHYSICAL_ADDRESS         PAGE_TABLE_AREA_BASE_PA  // in su.inc also.
#define PT_PHYSICAL_ADDRESS         PAGE_TABLE_AREA_BASE_PA + PAGE_SIZE
#define VIDEO_ENTRY                 0xB8

/*



Switching to Realmode
~~~~~~~~~~~~~~~~~~~~~

When switching to realmode "sp" will be initialized to
0xfffe and (ss) will be set to the base of the SU module's
data segment. This has several effects.

 1) The stack will remain withing the 0x20000 - 0x3ffff range
    reserved for the original SU module and loader image prior to
    relocation, and since the loader will already have been relocated
    it is no longer necessary to preserve this area.

 2) This will preserve the SU module's small model character which
    requires that offsets can be used interchangably through (ss) or (ds).

 3) This allows for the maximum stack size for small model apps (which is
    what the SU module is). Bios calls should not be tromping on any
    data or code while in realmode.

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\display.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    display.c

Author:

    Thomas Parslow (tomp) Mar-01-90

Abstract:

    Video support routines.

    The SU module only need to be able to write to the video display
    in order to report errors, traps, etc.

    The routines in this file all write to a video buffer assumed to be
    at realmode address b800:0000, and 4k bytes in length. The segment
    portion of the far pointers used to access the video buffer are stamped
    with a protmode selector value when we switch to protect mode. This is
    done in the routine "ProtMode" in "misc386.asm".


--*/

#include "su.h"


#define ZLEN_SHORT(x) ((x < 0x10) + (x < 0x100) + (x < 0x1000))
#define ZLEN_LONG(x)  ((x < 0x10) + (x < 0x100) + (x < 0x1000) + (x < 0x10000) + (x < 0x100000)+(x < 0x1000000)+(x < 0x10000000))

#ifdef DEBUG1
#define ROWS 43
#else
#define ROWS 25
#endif
#define COLUMNS 80
#define SCREEN_WIDTH COLUMNS
#define SCREEN_SIZE ROWS * COLUMNS
#define NORMAL_ATTRIB 0x07
#define REVERSE_ATTRIB 0x70
#define SCREEN_START 0xb8000000

#define VIDEO_BIOS   0x10
#define LINES_400_CONFIGURATION  0x1202
#define SELECT_SCAN_LINE 0x301
#define SET_80X25_16_COLOR_MODE  0x3
#define LOAD_8X8_CHARACTER_SET   0x1112

//
// Internal routines
//

static
VOID
tab(
    VOID
    );

static
VOID
newline(
    VOID
    );

static
VOID
putzeros(
    USHORT,
    USHORT
    );


USHORT
Redirect = 0;

VOID
InitializeVideoSubSystem(
    VOID
    )
/*++

Routine Description:

    Initializes the video mode to 80x50 alphanumeric mode with 400 lines
    vertical resolution.

Arguments:

    None

Returns:

    Nothing


--*/

{
    BIOSREGS ps;
    UCHAR _far *BiosArea;

    //
    // Set 40:10 to indicate color is the default display
    //   *(40:10) &= ~0x30;
    //   *(40:10) |= 0x20;
    //
    // Fixes obscure situation where both monochrome and VGA adapters
    // are installed and the monochrome is the default display.
    //
    BiosArea = (UCHAR _far *)(0x410L);

    *BiosArea &= ~0x30;
    *BiosArea |= 0x20;

    //
    // Establish 80x25 alphanumeric mode with 400-lines vertical resolution
    //
    ps.fn = VIDEO_BIOS;
    ps.ax = LINES_400_CONFIGURATION;
    ps.bx = SELECT_SCAN_LINE;
    biosint(&ps);

    ps.fn = VIDEO_BIOS;
    ps.ax = SET_80X25_16_COLOR_MODE;
    biosint(&ps);

    DBG1(
        ps.ax = LOAD_8X8_CHARACTER_SET;
        ps.bx = 0;
        biosint(&ps);
    )

    //
    // HACK-O-RAMA - Make some random video BIOS calls here to make sure the
    // BIOS is initialized and warmed up and ready to go.  Otherwise,
    // some Number 9 S3 cards don't quite work right later in the game.
    //  John Vert (jvert) 9-Jun-1993
    //

    //
    // set cursor position to 0,0
    //
    ps.fn = VIDEO_BIOS;
    ps.ax = 0x2000;
    ps.bx = 0;
    ps.dx = 0;
    biosint(&ps);

    //
    // write character (' ' in this case)
    //
    ps.fn = VIDEO_BIOS;
    ps.ax = 0x0a00 | (USHORT)' ';
    ps.bx = 0;
    ps.cx = 1;
    biosint(&ps);

    clrscrn();
    return ;
}


//
// Used by all BlPrint subordinate routines for padding computations.
//

CHAR sc=0;
ULONG fw=0;



VOID
BlPrint(
    PCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.


Returns:

    Nothing


--*/

{
    USHORT b,c,w,len;
    PUCHAR ap;
    ULONG l;

    //
    // Cast a pointer to the first word on the stack
    //

    ap = (PUCHAR)&cp + sizeof(PCHAR);
    sc = ' '; // default padding char is space

    //
    // Process the arguments using the descriptor string
    //


    while (b = *cp++)
        {
        if (b == '%')
            {
            c = *cp++;

            switch (c)
                {
                case 'd':
                    puti((long)*((int *)ap));
                    ap += sizeof(int);
                    break;

                case 's':
                    puts(*((PCHAR *)ap));
                    ap += sizeof (char *);
                    break;

                case 'c':
                    putc(*((char *)ap));
                    ap += sizeof(int);
                    break;

                case 'x':
                    w = *((USHORT *)ap);
                    len = ZLEN_SHORT(w);
                    while(len--) putc('0');
                    putx((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'u':
                    putu((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'l':
                    c = *cp++;

                switch(c) {

                    case 'u':
                        putu(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'x':
                        l = *((ULONG *)ap);
                        len = ZLEN_LONG(l);
                        while(len--) putc('0');
                        putx(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'd':
                        puti(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                }
                break;

                default :
                    putc((char)b);
                    putc((char)c);
                }
            }
        else
            putc((char)b);
        }

}

FPUCHAR vp = (FPUCHAR)SCREEN_START;
FPUCHAR ScreenStart = (FPUCHAR)SCREEN_START;

static int lcnt = 0;
static int row  = 0;


VOID puts(
    PCHAR cp
    )
/*++

Routine Description:

    Writes a string on the display at the current cursor position

Arguments:

    cp - pointer to ASCIIZ string to display.


Returns:

    Nothing



--*/


{
    char c;

    while(c = *cp++)
        putc(c);
}


//
// Write a hex short to display
//


VOID putx(
    ULONG x
    )
/*++

Routine Description:

    Writes hex long to the display at the current cursor position.

Arguments:

    x  - ulong to write.

Returns:

    Nothing


--*/

{
    ULONG j;

    if (x/16)
        putx(x/16);

    if((j=x%16) > 9) {
        putc((char)(j+'A'- 10));
    } else {
        putc((char)(j+'0'));
    }
}


VOID puti(
    LONG i
    )
/*++

Routine Description:

    Writes a long integer on the display at the current cursor position.

Arguments:

    i - the integer to write to the display.

Returns:

    Nothing


--*/


{
    if (i<0)
        {
        i = -i;
        putc((char)'-');
        }

    if (i/10)
        puti(i/10);

    putc((char)((i%10)+'0'));
}



VOID putu(
    ULONG u
    )
/*++

Routine Description:

    Write an unsigned long to display

Arguments:

    u - unsigned


--*/

{
    if (u/10)
        putu(u/10);

    putc((char)((u%10)+'0'));

}


VOID putc(
    CHAR c
    )
/*++

Routine Description:

    Writes a character on the display at the current position.

Arguments:

    c - character to write


Returns:

    Nothing


--*/

{
    switch (c)
        {
        case '\n':
            newline();
            break;

        case '\t':
            tab();
            break;

        default :
            if (FP_OFF(vp) >= (SCREEN_SIZE * 2)) {
                vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
                scroll();
            }
            *vp = c;
            vp += 2;
            ++lcnt;
      }
}


VOID newline(
    VOID
    )
/*++

Routine Description:

    Moves the cursor to the beginning of the next line. If the bottom
    of the display has been reached, the screen is scrolled one line up.

Arguments:

    None


Returns:

    Nothing


--*/

{
    vp += (SCREEN_WIDTH - lcnt)<<1;

    if (++row > ROWS-1) {

        vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
        scroll();

    }

    lcnt = 0;

}


VOID scroll(
    VOID
    )
/*++

Routine Description:

    Scrolls the display UP one line.

Arguments:

    None

Returns:

    Nothing

Notes:

    Currently we scroll the display by reading and writing directly from
    and to the video display buffer. We optionally switch to real mode
    and to int 10s

--*/

{
    USHORT i,j;
    USHORT far *p1 = (USHORT far *)ScreenStart;
    USHORT far *p2 = (USHORT far *)(ScreenStart + 2*SCREEN_WIDTH) ;

    for (i=0; i < ROWS - 1; i++)
        for (j=0; j < SCREEN_WIDTH; j++)
            *p1++ = *p2++;

    for (i=0; i < SCREEN_WIDTH; i++)
        *p1++ = REVERSE_ATTRIB*256 + ' ';

}


static
VOID tab(
    VOID
    )
/*++

Routine Description:


    Computes the next tab stop and moves the cursor to that location.


Arguments:


    None


Returns:

    Nothing

--*/

{
    int inc;

    inc = 8 - (lcnt % 8);
    vp += inc<<1;
    lcnt += inc;
}


VOID clrscrn(
    VOID
    )
/*++

Routine Description:

    Clears the video display by writing blanks with the current
    video attribute over the entire display.


Arguments:

    None

Returns:

    Nothing


--*/

{
    int i,a;
    unsigned far *vwp = (unsigned far *)ScreenStart;
    a = NORMAL_ATTRIB*256 + ' ';

    for (i = SCREEN_SIZE ; i ; i--)
        *vwp++ = a;

    row  = 0;
    lcnt = 0;
    vp = (FPUCHAR)ScreenStart;

}

// END OF FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\memmap.inc ===
PAGE_DIR_ADDRESS        equ     99000h
PAGE_TABLE_ADDRESS      equ     9A000h

;;
;; Address Mappings
;;


PhysAddressVideo        equ     0b8000h
PhysSizeVideo           equ     2000h

SYSTEM_PAGE_PA          equ     17000h
SYSTEM_PAGE_VA          equ     80420000h
GDT_LOC                 equ     0
IDT_LOC                 equ     400h
TSS_LOC                 equ     0C00h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\eisac.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisac.c

Abstract:

    This module implements routines to get EISA configuration information.

Author:

    Shie-Lin Tzong (shielint) 10-June-1991

Environment:

    16-bit real mode.


Revision History:

    John Vert (jvert) 5-Sep-1991
        Moved into the SU module of portable bootloader

--*/
#include "su.h"
#include "eisa.h"

//
// HACKHACK - John Vert (jvert) 12-Sep-1991
//      We have to initialize this or else it gets stuck in our BSS section
//      which is right in the middle of the osloader.exe header
//
extern BTEISA_FUNCTION_INFORMATION FunctionInformation;


BOOLEAN
FindFunctionInformation (
    IN UCHAR SlotFlags,
    IN UCHAR FunctionFlags,
    OUT PBTEISA_FUNCTION_INFORMATION Buffer,
    IN BOOLEAN FromBeginning
    )

/*++

Routine Description:

    This routine finds function information that matches the specified
    flags.  It starts, either where it left off last time, or at the
    beginning (slot 0, function 0)

Arguments:

    Flags - Flags to check against EISA function and slot information.

    Buffer - pointer to buffer to store EISA information in.

    FromBeginning - if TRUE, search starts at slot 0, function 0.
                    else continue from where it left off last time.

Return Value:

    TRUE - If the operation is success (Buffer is filled in.)
    FALSE - Request fails.

    Notes: The buffer is always changed, reguardless of the success
    of the function.  When failure is returned, the info is invalid.

--*/

{
    static UCHAR Slot=0;
    static UCHAR Function=0;
    BTEISA_SLOT_INFORMATION  SlotInformation;
    UCHAR Flags;
    UCHAR ReturnCode;

    if (FromBeginning) {
        Slot = 0;
        Function = 0;
    }
    BtGetEisaSlotInformation(&SlotInformation, Slot);
    while (SlotInformation.ReturnCode != EISA_INVALID_SLOT) {

        //
        // insure that the slot is not empty, and all of the flags are set.
        // the flags are tested by performing the following logic:
        //
        // -- (RequestSlotFlags XOR (SlotFlags AND RequestSlotFlags)) --
        //
        // if all the requested flags are set, the result will be zero
        //

        if ((SlotInformation.ReturnCode != EISA_EMPTY_SLOT) &&
            (!(SlotFlags ^ (SlotInformation.FunctionInformation & SlotFlags)))) {

            while (SlotInformation.NumberFunctions > Function) {
                ReturnCode = BtGetEisaFunctionInformation(Buffer, Slot, Function);
                Function++;

                //
                // if function call succeeded
                //

                if (!ReturnCode){

                    Flags = Buffer->FunctionFlags;

                    //
                    // Function Enable/Disable bit reversed.
                    //

                    Flags |= (~Flags & EISA_FUNCTION_ENABLED);

                    //
                    // insure that all the function flags are set.
                    // the flags are tested by performing the following logic:
                    //
                    // -- (ReqFuncFlags XOR (FuncFlags AND ReqFuncFlags)) --
                    //
                    // if all the requested flags are set, the result will
                    // be zero
                    //

                    if (!(FunctionFlags ^ (Flags & FunctionFlags))) {
                        return TRUE;
                    }
                }

            }
        }
        Slot++;
        Function = 0;
        BtGetEisaSlotInformation(&SlotInformation, Slot);
    }

    Slot = 0;
    Function = 0;
    return FALSE;
}

VOID
InsertDescriptor (
    ULONG Address,
    ULONG Size
    )

/*++

Routine Description:

    This routine inserts a descriptor into the correct place in the
    memory descriptor list.

Arguments:

    Address - Starting address of the memory block.

    Size - Size of the memory block to be inserted.

Return Value:

    None.

--*/

{
    MEMORY_LIST_ENTRY _far *CurrentEntry;

#ifdef DEBUG1
    BlPrint("Inserting descriptor %lx at %lx\n",Size,Address);
        _asm {
            push    ax
            mov     ax, 0
            int     16h
            pop     ax
        }
#endif
    //
    // Search the spot to insert the new descriptor.
    //

    CurrentEntry = MemoryDescriptorList;

    while (CurrentEntry->BlockSize > 0) {
        //
        // Check to see if this memory descriptor is contiguous with
        // the current one.  If so, coalesce them.  (yes, some machines
        // will return memory descriptors that look like this.  Compaq
        // Prosignia machines)
        //
        if (Address+Size == CurrentEntry->BlockBase) {
#ifdef DEBUG1
            BlPrint("  coalescing with descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            CurrentEntry->BlockBase = Address;
            CurrentEntry->BlockSize += Size;
#ifdef DEBUG1
            BlPrint("  new descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            break;
        }
        if (Address == (CurrentEntry->BlockBase + CurrentEntry->BlockSize)) {
#ifdef DEBUG1
            BlPrint("  coalescing with descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            CurrentEntry->BlockSize += Size;
#ifdef DEBUG1
            BlPrint("  new descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            break;
        }

        CurrentEntry++;
    }

    if (CurrentEntry->BlockSize == 0) {
        //
        // If CurrentEntry->BlockSize == 0, we  have reached the end of the list
        // So, insert the new descriptor here, and create a new end-of-list entry
        //
        CurrentEntry->BlockBase = Address;
        CurrentEntry->BlockSize = Size;

        ++CurrentEntry;
        //
        // Create a new end-of-list marker
        //
        CurrentEntry->BlockBase = 0L;
        CurrentEntry->BlockSize = 0L;
    }
#ifdef DEBUG1
    //
    // Wait for a keypress
    //
        _asm {
            push    ax
            mov     ax, 0
            int     16h
            pop     ax
        }
#endif

}

ULONG
EisaConstructMemoryDescriptors (
    VOID
    )

/*++

Routine Description:

    This routine gets the information EISA memory function above 16M
    and creates entries in the memory Descriptor array for them.

Arguments:

    None.

Return Value:

    Number of pages of usable memory.

--*/

{
    BOOLEAN Success;
    PBTEISA_MEMORY_CONFIGURATION MemoryConfiguration;
    ULONG Address;
    ULONG EndAddress;
    ULONG Size;
    ULONG MemorySize=0;
    ULONG IsaMemUnder1Mb=0xffffffff;
    MEMORY_LIST_ENTRY _far *CurrentEntry;

    //
    // HACKHACK John Vert (jvert) 5-Mar-1993
    //
    // See if there is already a memory descriptor for the 640k under
    // 1Mb.  If so, we will believe it instead of the EISA routine.  This
    // is because many EISA routines will always return 640k, even if
    // the disk parameter table is in the last 1k.  The ISA routines will
    // always account for the disk parameter tables.  If we believe the
    // EISA routines, we can overwrite the disk parameter tables, causing
    // much grief.
    //
    CurrentEntry = MemoryDescriptorList;
    while (CurrentEntry->BlockSize > 0) {
        if (CurrentEntry->BlockBase == 0) {
            //
            // found a descriptor starting at zero with a size > 0, so
            // this is the one we want to override the EISA information.
            //
            IsaMemUnder1Mb = CurrentEntry->BlockSize;
            break;
        }
        ++CurrentEntry;
    }

    //
    // Initialize the first entry in the list to zero (end-of-list)
    //

    MemoryDescriptorList->BlockSize = 0;
    MemoryDescriptorList->BlockBase = 0;

    Success = FindFunctionInformation(
                              EISA_HAS_MEMORY_ENTRY,
                              EISA_FUNCTION_ENABLED | EISA_HAS_MEMORY_ENTRY,
                              &FunctionInformation,
                              TRUE
                              );

    //
    // while there are more memory functions, and more free descriptors
    //

    while (Success) {

        MemoryConfiguration = &FunctionInformation.EisaMemory[0];

        do {

            //
            // Get physical address of the memory.
            // Note: physical address is stored divided by 100h
            //

            Address = (((ULONG)MemoryConfiguration->AddressHighByte << 16)
                      + MemoryConfiguration->AddressLowWord) * 0x100;

            //
            // Get the size of the memory block.
            // Note: Size is stored divided by 400h with the value of 0
            //       meaning a size of 64M
            //

            if (MemoryConfiguration->MemorySize) {
                Size = ((ULONG)MemoryConfiguration->MemorySize) * 0x400;
            } else {
                Size = (_64MEGB);
            }

#ifdef DEBUG1
            BlPrint("EISA memory at %lx  Size=%lx  Type=%x ",
                    Address,
                    Size,
                    MemoryConfiguration->ConfigurationByte);

            if ((MemoryConfiguration->ConfigurationByte.Type == EISA_SYSTEM_MEMORY) &&
                (MemoryConfiguration->ConfigurationByte.ReadWrite == EISA_MEMORY_TYPE_RAM) ) {

                BlPrint("  (USED BY NT)\n");
            } else {
                BlPrint("  (not used)\n");
            }
#endif

            //
            // Compute end address to determine if any part of the block
            // is above 16M
            //

            EndAddress = Address + Size;

            //
            // If it is SYSTEM memory and RAM, add the descriptor to the list.
            //

            if ((MemoryConfiguration->ConfigurationByte.Type == EISA_SYSTEM_MEMORY) &&
                (MemoryConfiguration->ConfigurationByte.ReadWrite == EISA_MEMORY_TYPE_RAM) ) {

                if (Address==0) {
                    //
                    // This is the descriptor for the memory under 1Mb.
                    // Compare it with the ISA routine's result, and see
                    // if the ISA one is smaller.  If it is, use the ISA
                    // answer.
                    //
                    if (Size > IsaMemUnder1Mb) {
                        Size = IsaMemUnder1Mb;
                    }
                }
                InsertDescriptor(Address, Size);
                MemorySize += (Size >> 12);
            }

        } while (MemoryConfiguration++->ConfigurationByte.MoreEntries);

        Success = FindFunctionInformation(
                                  EISA_HAS_MEMORY_ENTRY,
                                  EISA_FUNCTION_ENABLED | EISA_HAS_MEMORY_ENTRY,
                                  &FunctionInformation,
                                  FALSE
                                  );
    }
#ifdef DEBUG1
    //
    // Wait for a keypress
    //
        _asm {
            push    ax
            mov     ax, 0
            int     16h
            pop     ax
        }
#endif
    return(MemorySize);
}

BOOLEAN
Int15E820 (
    E820Frame       *Frame
    );


BOOLEAN
ConstructMemoryDescriptors (
    VOID
    )
/*++

Routine Description:

Arguments:


Return Value:


--*/
{
    ULONG           BAddr, EAddr;
    E820Frame       Frame;

    //
    // Initialize the first entry in the list to zero (end-of-list)
    //

    MemoryDescriptorList->BlockSize = 0;
    MemoryDescriptorList->BlockBase = 0;

    //
    // Any entries returned for E820?
    //

    Frame.Key = 0;
    Frame.Size = sizeof (Frame.Descriptor);
    Int15E820 (&Frame);
    if (Frame.ErrorFlag  ||  Frame.Size < sizeof (Frame.Descriptor)) {
        return FALSE;
    }

    //
    // Found memory in table, use the reported memory
    //

    Frame.Key = 0;
    do {
        Frame.Size = sizeof (Frame.Descriptor);
        Int15E820 (&Frame);
        if (Frame.ErrorFlag  ||  Frame.Size < sizeof (Frame.Descriptor)) {
            break ;
        }

#ifdef DEBUG1
        BlPrint("E820: %lx  %lx:%lx %lx:%lx %lx %lx\n",
            Frame.Size,
            Frame.Descriptor.BaseAddrHigh,  Frame.Descriptor.BaseAddrLow,
            Frame.Descriptor.SizeHigh,      Frame.Descriptor.SizeLow,
            Frame.Descriptor.MemoryType,
            Frame.Key
            );

            _asm {
                push    ax
                mov     ax, 0
                int     16h
                pop     ax
            }
#endif

        BAddr = Frame.Descriptor.BaseAddrLow;
        EAddr = Frame.Descriptor.BaseAddrLow + Frame.Descriptor.SizeLow - 1;

        //
        // All the processors we have right now only support 32 bits
        // If the upper 32 bits of the Base Address is non-zero, then
        // this range is entirely above the 4g mark and can be ignored
        //

        if (Frame.Descriptor.BaseAddrHigh == 0) {

            if (EAddr < BAddr) {
                //
                // address wrapped - truncate the Ending address to
                // 32 bits of address space
                //

                EAddr = 0xFFFFFFFF;
            }

            //
            // Based upon the address range descriptor type, find the
            // available memory and add it to the descriptor list
            //

            switch (Frame.Descriptor.MemoryType) {
                case 1:
                    //
                    // This is a memory descriptor
                    //

                    InsertDescriptor (BAddr, EAddr - BAddr + 1);
                    break;
            }
        }

    } while (Frame.Key) ;

    return TRUE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\main.c ===
/*++

Copyright (c) 1991  Microsoft Corporation


Module Name:

    main.c

Abstract:

    Main for the SU (startup) module for the OS loader. The SU module
    must take the x86 from a real-mode 16bit state to a FLAT model,
    32bit protect/paging enabled state.

Author:

    Thomas Parslow (tomp) Created 20-Dec-90


Revision History:

--*/


#define NTAPI

#include "su.h"
#include "eisa.h"
#define _SYS_GUID_OPERATORS_
#include <guiddef.h>
#include "ntimage.h"
#include "strings.h"

extern VOID RealMode(VOID);
extern USHORT IDTregisterZero;
extern IMAGE_DOS_HEADER edata;
extern USHORT end;
extern VOID MoveMemory(ULONG,ULONG,ULONG);
extern USHORT SuStackBegin;
extern UCHAR Beginx86Relocation;
extern UCHAR Endx86Relocation;
extern USHORT BackEnd;
extern ULONG FileStart;
extern BOOLEAN IsNpxPresent(VOID);
extern USHORT HwGetProcessorType(VOID);
extern USHORT HwGetCpuStepping(USHORT);
extern ULONG MachineType;
extern ULONG OsLoaderStart;
extern ULONG OsLoaderEnd;
extern ULONG ResourceDirectory;
extern ULONG ResourceOffset;
extern ULONG OsLoaderBase;
extern ULONG OsLoaderExports;

extern
TurnMotorOff(
    VOID
    );

extern
EnableA20(
    VOID
    );

extern
BOOLEAN
ConstructMemoryDescriptors(
    VOID
    );

extern
USHORT
IsaConstructMemoryDescriptors(
    VOID
    );

VOID
Relocatex86Structures(
    VOID
    );

ULONG
RelocateLoaderSections(
    OUT PULONG Start,
    OUT PULONG End
    );

extern
FSCONTEXT_RECORD
FsContext;

#define DISK_TABLE_VECTOR (0x1e*4)

FPULONG DiskTableVector = (FPULONG)(DISK_TABLE_VECTOR);

VOID
SuMain(
    IN UCHAR BtBootDrive
    )
/*++

Routine Description:

    Main entrypoint of the SU module. Control is passed from the boot
    sector to startup.asm which does some run-time fixups on the stack
    and data segments and then passes control here.

Arguments:

    BtBootDrive - Drive that we booted from (int13 unit number)

Returns:

    Does not return. Passes control to the OS loader

--*/
{
    ULONG LoaderEntryPoint;
    ULONG EisaNumPages;
    USHORT IsaNumPages;
    MEMORY_LIST_ENTRY _far *CurrentEntry;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    ULONG BlockEnd;
    ULONG ImageSize;
    ULONG ImageBase;

    //
    // Save fs context info
    //
    FsContext.BootDrive = BtBootDrive;

    //
    // Initialize the video subsystem first so that
    // errors end exceptions can be displayed.
    //

    InitializeVideoSubSystem();

    //
    // In case we booted from a floppy, turn the drive motor off.
    //

    TurnMotorOff();

    //
    // Set up machine type based on its Bus type.
    //

    if (BtIsEisaSystem()) {
        MachineType = MACHINE_TYPE_EISA;
    } else {
        MachineType = MACHINE_TYPE_ISA;
    }

    if (!ConstructMemoryDescriptors()) {
        //
        // If INT 15 E802h fails...
        //

        if (MachineType == MACHINE_TYPE_EISA) {

            //
            // HACKHACK John Vert (jvert)
            //    This is completely bogus.  Since there are a number of EISA
            //    machines which do not let you correctly configure the EISA
            //    NVRAM, and even MORE machines which are improperly configured,
            //    we first check to see how much memory the ISA routines say
            //    exists.  Then we check what the EISA routines tell us, and
            //    compare the two.  If the EISA number is much lower (where "much"
            //    is a completely random fudge factor) than the ISA number, we
            //    assume the machine is improperly configured and we throw away
            //    the EISA numbers and use the ISA ones.  If not, we assume that
            //    the machine is actually configured properly and we trust the
            //    EISA numbers..
            //

            IsaNumPages = IsaConstructMemoryDescriptors();
            EisaNumPages = EisaConstructMemoryDescriptors();
            if (EisaNumPages + 0x80 < IsaNumPages) {
                IsaConstructMemoryDescriptors();
            }
        } else {
            IsaConstructMemoryDescriptors();
        }
    }

    //
    // Search for memory descriptor describing low memory
    //
    CurrentEntry = MemoryDescriptorList;
    while ((CurrentEntry->BlockBase != 0) &&
           (CurrentEntry->BlockSize != 0)) {
        CurrentEntry++;
    }

    if ((CurrentEntry->BlockBase == 0) &&
        (CurrentEntry->BlockSize < (ULONG)512 * (ULONG)1024)) {

        BlPrint(SU_NO_LOW_MEMORY,CurrentEntry->BlockSize/1024);
        while (1) {
        }
    }

    //
    // Ensure there is a memory descriptor to contain osloader image
    //
    OptionalHeader = &((PIMAGE_NT_HEADERS) ((PUCHAR) &edata + edata.e_lfanew))->OptionalHeader;
    ImageBase = OptionalHeader->ImageBase;
    ImageSize = OptionalHeader->SizeOfImage;
    OsLoaderBase = ImageBase;
    OsLoaderExports = ImageBase + OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    CurrentEntry = MemoryDescriptorList;
    while (ImageSize > 0) {
        while (CurrentEntry->BlockSize != 0) {
            BlockEnd = CurrentEntry->BlockBase + CurrentEntry->BlockSize;

            if ((CurrentEntry->BlockBase <= ImageBase) &&
                (BlockEnd > ImageBase)) {

                //
                // this descriptor at least partially contains a chunk
                // of the osloader.
                //
                if (BlockEnd-ImageBase > ImageSize) {
                    ImageSize = 0;
                } else {
                    ImageSize -= (BlockEnd-ImageBase);
                    ImageBase = BlockEnd;
                }

                //
                // look for remaining part (if any) of osloader
                //
                CurrentEntry = MemoryDescriptorList;
                break;
            }
            CurrentEntry++;
        }
        if (CurrentEntry->BlockSize == 0) {
            break;
        }
    }

    if (ImageSize > 0) {
        //
        // We could not relocate the osloader to high memory.  Error out
        // and display the memory map.
        //
        BlPrint(SU_NO_EXTENDED_MEMORY);

        CurrentEntry = MemoryDescriptorList;
        while (CurrentEntry->BlockSize != 0) {
            BlPrint("    %lx - %lx\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockBase + CurrentEntry->BlockSize);

            CurrentEntry++;
        }
        while (1) {
        }

    }

    //
    // Enable the A20 line for protect mode
    //

    EnableA20();

    //
    // Relocate x86 structures. This includes the GDT, IDT,
    // page directory, and first level page table.
    //

    Relocatex86Structures();

    //
    // Enable protect and paging modes for the first time
    //


    EnableProtectPaging(ENABLING);

    //
    // Go relocate loader sections and build page table entries
    //

    LoaderEntryPoint = RelocateLoaderSections(&OsLoaderStart, &OsLoaderEnd);

    //
    // Search for memory descriptor containing the osloader and
    // change it.
    //

    //
    // Transfer control to the OS loader
    //

    TransferToLoader(LoaderEntryPoint);

}

ULONG
RelocateLoaderSections(
    OUT PULONG Start,
    OUT PULONG End
    )
/*++

Routine Description:

    The SU module is prepended to the OS loader file. The OS loader file
    is a coff++ file. This routine computes the beginning of the OS loader
    file, then relocates the OS loader's sections as if it were just
    loading the file from disk file.

Arguments:

    Start - Returns the address of the start of the image
    End   - Returns the address of the end of the image

Returns:

    Entry point of loader


--*/
{
    USHORT Section;
    ULONG Source,Destination;
    ULONG VirtualSize;
    ULONG SizeOfRawData;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER SectionHeader;

    //
    // Make a pointer to the beginning of the loader's coff header
    //
    FileHeader = &((PIMAGE_NT_HEADERS) ((PUCHAR) &edata + edata.e_lfanew))->FileHeader;


    //
    // Validate the appended loader image by checking signatures.
    //   1st - is it an executable image?
    //   2nd - is the target environment the 386?
    //

    if ((FileHeader->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) {
        puts(SU_NTLDR_CORRUPT);
        WAITFOREVER;
    }

    if (FileHeader->Machine != IMAGE_FILE_MACHINE_I386) {
        puts(SU_NTLDR_CORRUPT);
        WAITFOREVER;
    }

    //
    // Make a pointer to the optional header in the header-buffer
    //

    OptionalHeader = (PIMAGE_OPTIONAL_HEADER)((PUCHAR)FileHeader +
        sizeof(IMAGE_FILE_HEADER));

    //
    // Make a pointer to the first section in the header buffer
    //

    SectionHeader = (PIMAGE_SECTION_HEADER)((PUCHAR)OptionalHeader +
        FileHeader->SizeOfOptionalHeader);

    *Start = OptionalHeader->ImageBase+SectionHeader->VirtualAddress;
    *End   = *Start + SectionHeader->SizeOfRawData;

    //
    // Display some debug stuff for now
    //

    DBG1(
    BlPrint("Machine = %x\n",FileHeader->Machine);
    BlPrint("NumberOfSections = %x\n",FileHeader->NumberOfSections);
    BlPrint("TimeDateStamp %lx\n",FileHeader->TimeDateStamp);
    BlPrint("PointerToSymbolTable = %lx\n",FileHeader->PointerToSymbolTable);
    BlPrint("NumberOfSymbols %lx\n",FileHeader->NumberOfSymbols);
    BlPrint("SizeOfOptionalHeader = %x\n",FileHeader->SizeOfOptionalHeader);
    BlPrint("Characteristics = %x\n",FileHeader->Characteristics);
    )

    //
    // Loop and relocate each section with a non-zero RawData size
    //

    for (Section=FileHeader->NumberOfSections ; Section-- ; SectionHeader++) {

        //
        // Compute source, destination, and count arguments
        //

        Source = FileStart  + SectionHeader->PointerToRawData;
        Destination = OptionalHeader->ImageBase + SectionHeader->VirtualAddress;

        VirtualSize = SectionHeader->Misc.VirtualSize;
        SizeOfRawData = SectionHeader->SizeOfRawData;

        if (VirtualSize == 0) {
            VirtualSize = SizeOfRawData;
        }

        if (SectionHeader->PointerToRawData == 0) {
            //
            // SizeOfRawData can be non-zero even if PointerToRawData is zero
            //

            SizeOfRawData = 0;
        } else if (SizeOfRawData > VirtualSize) {
            //
            // Don't load more from image than is expected in memory
            //

            SizeOfRawData = VirtualSize;
        }

        if (Destination < *Start) {
            *Start = Destination;
        }

        if (Destination+VirtualSize > *End) {
            *End = Destination+VirtualSize;
        }

        DBG1(BlPrint("src=%lx  dest=%lx raw=%lx\n",Source,Destination,SizeOfRawData);)

        if (SizeOfRawData != 0) {
            //
            // This section is either a code (.TEXT) section or an
            // initialized data (.DATA) section.
            // Relocate the section to memory at the virtual/physical
            // addresses specified in the section header.
            //
            MoveMemory(Source,Destination,SizeOfRawData);
        }

        if (SizeOfRawData < VirtualSize) {
            //
            // Zero the portion not loaded from the image
            //

            DBG1( BlPrint("Zeroing destination %lx\n",Destination+SizeOfRawData); )
            ZeroMemory(Destination+SizeOfRawData,VirtualSize - SizeOfRawData);
        }
        //
        // Check if this is the resource section.  If so, we need
        // to pass its location to the osloader.
        //
        if ((SectionHeader->Name[0] == '.') &&
            (SectionHeader->Name[1] == 'r') &&
            (SectionHeader->Name[2] == 's') &&
            (SectionHeader->Name[3] == 'r') &&
            (SectionHeader->Name[4] == 'c')) {
            ResourceDirectory = Destination;
            ResourceOffset = SectionHeader->VirtualAddress;
        }
    }

    DBG1( BlPrint("RelocateLoaderSections done - EntryPoint == %lx\n",
            OptionalHeader->AddressOfEntryPoint + OptionalHeader->ImageBase);)
    return(OptionalHeader->AddressOfEntryPoint + OptionalHeader->ImageBase);

}

VOID
Relocatex86Structures(
    VOID
    )
/*++

Routine Description:

    The gdt and idt are statically defined and imbedded in the SU modules
    data segment. This routine moves then out of the data segment and into
    a page mapped at a defined location.

Arguments:

    None

Returns:

    Nothing


--*/
{
    FPUCHAR Fpsrc, Fpdst;
    USHORT Count;

    //
    // Make pointers to the data and compute the size
    // of the block to use.
    //

    Fpsrc = (FPUCHAR)&Beginx86Relocation;
    MAKE_FP(Fpdst,SYSTEM_STRUCTS_BASE_PA);
    Count = (&Endx86Relocation - &Beginx86Relocation);

    //
    // Move the data to its new location
    //

    while (Count--) {
        *Fpdst++ = *Fpsrc++;

    }

}

VOID
DisplayArgs(
    USHORT es,
    USHORT bx,
    USHORT cx,
    USHORT dx,
    USHORT ax
    )
/*++

Routine Description:

    Just a debugging routine to dump some registers.

Arguments:

    The x86 registers es, bx, cx, dx, and ax are pushed on the stack
    before this routine is called.


Returns:

    Nothing


Environment:

    Real Mode ONLY


--*/
{
    BlPrint("ax:%x dx:%x cx:%x bx:%x es:%x\n",
                (USHORT) ax,
                (USHORT) dx,
                (USHORT) cx,
                (USHORT) bx,
                (USHORT) es);

    return;
}

// END OF FILE //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\ntmisc.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ntmisc.h

Abstract:

    This module contains the misc. definitions in \nt\public\sdk\inc
    directory.  Note, we created this file because ntdetect uses 16 bit
    compiler and various new C compiler switches/pragamas are not recognized
    by the 16 bit C compiler.

Author:

    Shie-Lin Tzong (shielint) 11-Nov-1992


Revision History:


--*/
//
// PHYSICAL_ADDRESS
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

//
// Note all the definitions defined below are used to make compiler shut up.
// Ntdetect.com does not rely on the correctness of the structures.
//

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY far *Flink;
   struct _LIST_ENTRY far *Blink;
} LIST_ENTRY, far *PLIST_ENTRY;

#define PTIME_FIELDS    PVOID


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\exp.asm ===
;++
;
; Module name
;
;       exp.asm
;
; Author
;
;       Thomas Parslow  (tomp)  Feb-26-91
;
; Description
;
;       Entry points exported to OS loader by SU module. Exported
;       routines provide basic machine dependent i/o funtions needed
;       by the OS loader. Providing these routines decouples the
;       OS loader from the h/w. Note that the OS loader will
;       refer to these exported routines as the "external services".
;
;
; Exported Procedures
;
;       RebootProcessor - Reboots the machine
;       GetSector - Read one or more sectors from the boot device.
;       PutChar - Puts a character on the video display.
;       GetKey - Gets a key from the keyboard
;       GetCounter - Reads the Tick Counter
;       Reboot - Transfers control to a loaded boot sector.
;       HardwareCursor - set position of hardware cursor
;       GetDateTime - gets date and time
;       ComPort - int14 functions
;       GetStallCount - calculates processor stall count
;
;
; Notes
;
;       When adding a new exported routine note that you must manually add the
;       entry's name to the BootRecord in "sudata.asm".
;
;--

include su.inc
include macro.inc

DISK_TABLE_VECTOR       equ     01Eh * 4

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP
.386p

        extrn   _DiskBaseTable:near
        extrn   _RomDiskBasePointer:near
        extrn   _EddsAddressPacket:near


;++
;
; Exported Name:
;
;       RebootProcessor
;
; Arguments:
;
;       None
;
; Description:
;
;       Reboot the processor using INT 19h
;
;
;
;--
;
; ExportEntry takes us from a 32bit cs to a 16bit cs, inits 16bit stack
; and ds segments and saves the callers esp and ebp.
;
;--

EXPORT_ENTRY_MACRO    RebootProcessor
;
; Switch to real mode so we can take interrupts
;

        ENTER_REALMODE_MACRO

;
; int 19h doesn't do what you would expect on BIOS Boot Specification machines.
; It either goes on to the next boot device or goes back to the first boot
; device. In both cases, it does not properly reset the machine. So we write
; to the keyboard port instead (as does HalpReboot).
;
;        int 19h
        mov     ax, 040h
        mov     ds, ax
        mov     word ptr ds:[72h], 1234h        ; set location 472 to 1234 to indicate warm reboot
        mov     al, 0feh
        out     64h, al                         ; write to keyboard port to cause reboot

;
; Loop forever and wait to ctrl-alt-del (should never get here)
;

        WAIT_FOREVER_MACRO

;EXPORT_EXIT_MACRO


;++
;
; Name:
;
;       GetSector
;
; Description:
;
;       Reads the requested number of sectors from the specified drive into
;       the specified buffer.
;
; Arguments:
;
;             ULONG Virtual address into which to read data
;             ULONG Number of sectors to read
;             ULONG Physical sector number
;             ULONG Drive Number
;             ULONG Function Number
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;--

EXPORT_ENTRY_MACRO    GetSector
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetSectorFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Get the requested sectors. Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Put the buffer pointer into es:bx. Note that and buffer
; addresses passed to this routine MUST be in the lower one
; megabyte of memory to be addressable in real mode.
;

        mov      eax,[bp].BufferPointer
        mov      bx,ax
        and      bx,0fh
        shr      eax,4
        mov      es,ax
;
; Place the upper 2 bits of the 10bit track/cylinder number
; into the uppper 2 bits of the SectorNumber as reguired by
; the bios.
;
        mov      cx,word ptr [bp].TrackNumber
        xchg     ch,cl
        shl      cl,6
        add      cl,byte ptr [bp].SectorNumber

;
; Get the rest of the arguments
;
        mov      ah,byte ptr [bp].FunctionNumber
        mov      al,byte ptr [bp].NumberOfSectors
        mov      dh,byte ptr [bp].HeadNumber
        mov      dl,byte ptr [bp].DriveNumber

;
; Check to see if we are trying to reset/read/write/verify off the second
; floppy drive.  If so, we need to go change the disk-base vector.
;
        cmp     dl,1
        jne     gs3
        cmp     ah,4
        jg      gs3
        cmp     ah,0
        je      gs1
        cmp     ah,2
        jl      gs3

gs1:
;
; We need to point the BIOS disk-table vector to our own table for this
; drive.
;
        push    es
        push    bx
        push    di

        push    0
        pop     es

        mov     di, offset DGROUP:_RomDiskBasePointer

        mov     bx,es:[DISK_TABLE_VECTOR]
        mov     [di],bx
        mov     bx,es:[DISK_TABLE_VECTOR+2]
        mov     [di+2],bx

        mov     bx,offset DGROUP:_DiskBaseTable
        mov     es:[DISK_TABLE_VECTOR],bx
        mov     bx,ds
        mov     es:[DISK_TABLE_VECTOR+2],bx

        pop     di
        pop     bx
        pop     es

        int     BIOS_DISK_INTERRUPT

        push    es
        push    bx
        push    di

        push    0
        pop     es

        mov     di, offset DGROUP:_RomDiskBasePointer

        mov     bx, [di]
        mov     es:[DISK_TABLE_VECTOR],bx
        mov     bx, [di+2]
        mov     es:[DISK_TABLE_VECTOR+2],bx

        pop     di
        pop     bx
        pop     es

        jc      gs5
        xor     eax,eax
        jmp     short gs5

gs3:

;
; Call the bios to read the sector now
;
if 0
        push     ax
        push     dx
        push     cx
        push     bx
        push     es
extrn _DisplayArgs:near
        call     _DisplayArgs
        pop      es
        pop      bx
        pop      cx
        pop      dx
        pop      ax
endif

        int      BIOS_DISK_INTERRUPT
        jc       gs5

;
; Carry wasn't set so we have no error and need to "clean" eax of
; any garbage that may have been left in it.
;
        xor     eax,eax
gs5:
if 0
        push     ax
        push     dx
        push     cx
        push     bx
        push     es
extrn _DisplayArgs:near
        call     _DisplayArgs
        pop      es
        pop      bx
        pop      cx
        pop      dx
        pop      ax
endif

;
; Mask-off any garbage that my have been left in the upper
; 16bits of eax.
;
        and      eax,0000ffffh

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetSectorFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

; move cx into high 16-bits of ecx, and dx into cx.  This is so the loader
; can get at interesting values in dx, even though edx gets munged by the
; random real-mode macros.

        shl     ecx, 16
        mov     cx,dx
        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax
;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO

;++
;
; Name:
;
;       GetEddsSector
;
; Description:
;
;       Reads the requested number of sectors from the specified drive into
;       the specified buffer based on the Phoenix Enhanced Disk Drive Spec.
;
; Arguments:
;
;             ULONG xint13 function number (42 = read, 43 = write)
;             ULONG Virtual address into which to read data
;             ULONG Number of logical blocks to read (word)
;             ULONG Logical block number (High dword)
;             ULONG Logical block number (Low dword)
;             ULONG Drive Number (byte)
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;--

EXPORT_ENTRY_MACRO    GetEddsSector
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetEddsSectorFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Get the requested sectors. Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

        push     ds
        push     si
        push     bx

;
; Set up DS:SI -> Disk Address Packet
;
        push    0
        pop     ds
        mov     si, offset DGROUP:_EddsAddressPacket
        mov     ds:[si],word ptr 10h             ; Packet size = 10h, plus reserved byte
        mov     ax,word ptr [bp].NumberOfBlocks
        mov     ds:[si][2],ax                    ; Num blocks to transfer
        mov     eax,[bp].BufPointer
        mov     bx,ax
        and     bx,0fh
        mov     ds:[si][4],bx                    ; Transfer buffer address (low word=offset)
        shr     eax,4
        mov     ds:[si][6],ax                    ; Transfer buffer address (high word=segment)
        mov     eax,[bp].LBNLow
        mov     ds:[si][8],eax                   ; Starting logical block number (low dword)
        mov     eax,[bp].LBNHigh
        mov     ds:[si][12],eax                  ; Starting logical block number (high dword)

;
; Call the bios to read the sector now (DS:SI -> Disk address packet)
;
       mov      ah,byte ptr [bp].FunctionNum    ; function
       xor      al,al                           ; force verify on write off
       mov      dl,byte ptr [bp].DriveNum       ; DL = drive number
       int      BIOS_DISK_INTERRUPT
       jc       geserror1

;
; Carry wasn't set so we have no error and need to "clean" eax of
; any garbage that may have been left in it.
;
        xor      eax,eax
geserror1:

;
; Mask-off any garbage that my have been left in the upper
; 16bits of eax.
;
        and      eax,0000ffffh

        pop      bx
        pop      si
        pop      ds

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetEddsSectorFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

; move cx into high 16-bits of ecx, and dx into cx.  This is so the loader
; can get at interesting values in dx, even though edx gets munged by the
; random real-mode macros.

        shl      ecx, 16
        mov      cx,dx
        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax
;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetKey
;
; Description:
;
;       Checks the keyboard to see if a key is available.
;
; Arguments:
;
;       None.
;
; Returns:
;
;       If no key is available, returns 0
;
;       If ASCII character is available, LSB 0 is ASCII code
;                                        LSB 1 is keyboard scan code
;       If extended character is available, LSB 0 is extended ASCII code
;                                           LSB 1 is keyboard scan code
;
;--

EXPORT_ENTRY_MACRO      GetKey
;
; Go into real mode.  We still have the same stack and sp
; but we'll be executing in real mode.
;

        ENTER_REALMODE_MACRO

;
; Set up registers to call BIOS and check to see if a key is available
;

        mov     ax,0100h
        int     BIOS_KEYBOARD_INTERRUPT

        jnz     GkKeyAvail
        mov     eax, 0
        jmp     GkDone

GkKeyAvail:
;
; Now we call BIOS again, this time to get the key from the keyboard buffer
;
        mov     ax,0h
        int     BIOS_KEYBOARD_INTERRUPT
        and     eax,0000ffffh

;
; Save return code on 16bit stack
; Re-enable protect mode and paging
;
GkDone:
        push    eax
        RE_ENABLE_PAGING_MACRO
        pop     eax
;
; Return to caller and the 32-bit universe
;
EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetCounter
;
; Description:
;
;       Reads the tick counter (incremented 18.2 times per second)
;
; Arguments:
;
;       None
;
; Returns:
;
;       The current value of the tick counter
;
;--

EXPORT_ENTRY_MACRO      GetCounter
;
; Go into real mode.
;

        ENTER_REALMODE_MACRO

        mov     ah,0
        int     01ah
        mov     ax,cx           ; high word of count
        shl     eax,16
        mov     ax,dx           ; low word of count

        push    eax
        RE_ENABLE_PAGING_MACRO
        pop     eax

EXPORT_EXIT_MACRO


;++
;
; Routine Name:
;
;       Reboot
;
; Description:
;
;       Switches to real-mode and transfers control to a loaded boot sector
;
; Arguments:
;
;       unsigned BootType
;           0 = FAT. Just jump to 0:7c00.
;           1 = HPFS. Assumes boot code and super+spare areas (20 sectors)
;                  are already loaded at 0xd000; jumps to d00:200.
;           2 = NTFS. Assumes boot code is loaded (16 sectors) at 0xd000.
;                  Jumps to d00:256.
;
; Returns:
;       Does not return
;
; Environment:
;
;       Boot sector has been loaded at 7C00
;--

EXPORT_ENTRY_MACRO      Reboot
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <RebootFrame>, ebx
;
; Go into real mode.
;

        ENTER_REALMODE_MACRO

;
; Get the BootType argument.  Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;

        push     bp
        mov      bp,sp
        add      bp,2
        mov      edx, [bp].BootType

;
; Zero out the firmware heaps, 3000:0000 - 4000:ffff.
;

        xor     eax,eax         ; prepare for stosd
        mov     bx,3000h
        mov     es,bx
        mov     di,ax           ; es:di = physical address 30000
        mov     cx,4000h        ; cx = rep count, # dwords in 64K
        cld
        rep stosd
        mov     cx,4000h        ; rep count
        mov     es,cx           ; es:di = physical address 40000
        rep stosd

;
; Disable the A20 line.  Some things (like EMM386 and OS/2 on PS/2 machines)
; hiccup or die if we don't do this.
;

extrn   _DisableA20:near
        call    _DisableA20

;
; Put the video adapter back in 80x25 mode
;
        push    dx
        mov     ax, 0003h
        int     010h
        pop     dx

;
; Reset all the segment registers and setup the original stack
;
        mov     ax,0
        mov     ds,ax
        mov     es,ax
        mov     fs,ax
        mov     gs,ax

        mov     ax,30
        mov     ss,ax
        mov     esp,0100h
        mov     ebp,0
        mov     esi,0
        mov     edi,0

        test    dx,-1
        jz      FatBoot

;
; Setup the registers the way the second sector of the OS/2 HPFS boot code
; expects them.  We skip the first sector entirely, as that just loads in
; the rest of the sectors.  Since the rest of the sectors are ours and not
; OS/2's, this would cause great distress.
;
        mov     ax,07c0h
        mov     ds, ax
        mov     ax, 0d00h
        mov     es, ax

        cli
        xor     ax,ax
        mov     ss,ax
        mov     sp, 07c00h
        sti

        push    0d00h
        push    0256h
        jmp     RebootDoit

FatBoot:
        push    0            ; set up for branch to boot sector
        push    07c00h
        mov     dx,080h

;
; And away we go!
;
RebootDoit:
        retf

        RE_ENABLE_PAGING_MACRO

        REMOVE_STACK_FRAME_MACRO  <RebootFrame>

EXPORT_EXIT_MACRO

;++
;
; Name:
;
;       HardwareCursor
;
; Description:
;
;       Positions the hardware cursor and performs other display stuff.
;
; Arguments:
;
;             ULONG Y coord (0 based)
;             ULONG X coord (0 based)
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;       If X = 0x80000000, then Y contains values that get placed into
;           ax (low word of Y) and bx (hi word of y).
;       Otherwise X,Y = coors for cursor
;
;
;--

EXPORT_ENTRY_MACRO    HardwareCursor
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <HardwareCursorFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Get the requested sectors. Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Put the row (y coord) in dh and the column (x coord) in dl.
;

        mov      eax,[bp].YCoord
        mov      edx,[bp].XCoord
        cmp      edx,80000000h
        jne      gotxy

        mov      ebx,eax
        shr      ebx,16
        jmp      doint10

    gotxy:
        mov      dh,al
        mov      ah,2
        mov      bh,0

    doint10:
        int      10h

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <HardwareCursorFrame>

;
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


;++
;
; Name:
;
;       GetDateTime
;
; Description:
;
;       Gets date and time
;
; Arguments:
;
;             ULONG Virtual address of a dword in which to place time.
;             ULONG Virtual address of a dword in which to place date.
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;--

BCD_TO_BIN  macro
    xor ah,ah
    rol ax,4
    ror al,4
    aad
endm

EXPORT_ENTRY_MACRO    GetDateTime
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetDateTimeFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Get the time
;

        mov      ah,2
        int      1ah

;
; Convert BIOS time format into our format and place in caller's dword
; bits 0-5 are the second
; bits 6-11 are the minute
; bits 12-16 are the hour
;
        xor      eax,eax
        mov      al,dh      ; BCD seconds
        BCD_TO_BIN
        movzx    edx,ax
        mov      al,cl      ; BCD minutes
        BCD_TO_BIN
        shl      ax,6
        or       dx,ax
        mov      al,ch      ; BCD hours
        BCD_TO_BIN
        shl      eax,12
        or       edx,eax

        mov      eax,[bp].TimeDword
        mov      bx,ax
        and      bx,0fh
        shr      eax,4
        mov      es,ax

        mov      es:[bx],edx

;
; Get the date
;

        mov      ah,4
        int      1ah

;
; Convert BIOS date format into our format and place in caller's dword
; bits 0-4  are the day
; bits 5-8  are the month
; bits 9-31 are the year
;

        xor     eax,eax
        mov     al,dl       ; BCD day
        BCD_TO_BIN
        mov     bl,dh
        movzx   edx,ax
        mov     al,bl       ; BCD month
        BCD_TO_BIN
        shl     ax,5
        or      dx,ax
        mov     al,cl       ; BCD year
        BCD_TO_BIN
        mov     cl,al
        mov     al,ch       ; BCD century
        BCD_TO_BIN
        mov     ah,100
        mul     ah
        xor     ch,ch
        add     ax,cx
        shl     eax,9
        or      edx,eax

        mov     eax,[bp].DateDword
        mov     bx,ax
        and     bx,0fh
        shr     eax,4
        mov     es,ax

        mov     es:[bx],edx

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetDateTimeFrame>

;
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO

;++
;
; VOID
; DetectHardware (
;    IN PDETECTION_RECORD DetectionRecord
;    )
;
; Routine Description:
;
;    This routine invokes x86 16 bit real mode detection code from
;    osloader 32 bit flat mode.
;
; Arguments:
;
;    DetectionRecord - Supplies a pointer to a detection record structure.
;
; Return Value:
;
;    None.
;
;--


EXPORT_ENTRY_MACRO    DetectHardware

;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <DetectionFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Call the Hardware Detection code
;

        push    cs
        push    offset _TEXT:DetectionDone      ; push far return addr

        push    DETECTION_ADDRESS_SEG
        push    DETECTION_ADDRESS_OFFSET
        retf

DetectionDone:

;
; Restore bp and remove stack-frame from stack
;

        REMOVE_STACK_FRAME_MACRO <DetectionFrame>

;
; No return code, so we don't save return code around page enabling code
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;

EXPORT_EXIT_MACRO

;++
;
; VOID
; ComPort (
;    IN LONG  Port,
;    IN ULONG Function,
;    IN UCHAR Arg
;    )
;
; Routine Description:
;
;    Invoke int14 on com1.
;
; Arguments:
;
;    Port - port # (0 = com1, etc).
;
;    Function - int 14 function (for ah)
;
;    Arg - arg for function (for al)
;
; Return Value:
;
;    None.
;
;--


EXPORT_ENTRY_MACRO    ComPort

;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <ComPortFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Get args and call int14
;

        mov      ah,byte ptr [bp].ComPortFunction
        mov      al,byte ptr [bp].ComPortArg
        mov      dx,word ptr [bp].ComPortPort
        int      14h

;
; Restore bp and remove stack-frame from stack
;

        pop      bp

        REMOVE_STACK_FRAME_MACRO <ComPortFrame>

;
; No return code, so we don't save return code around page enabling code
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;

EXPORT_EXIT_MACRO

;++
;
; ULONG
; GetStallCount (
;    VOID
;    )
;
; Routine Description:
;
;    Calculates how many increments are required to stall for one microsecond
;
;    The way this routine works is to set up an ISR on the BIOS vector 1C.
;    This routine will get called 18.2 times a second.  The location where
;    IP will be stored when the interrupt occurs is computed and stashed in
;    the code segment.  When the ISR fires, the IP on the stack is changed
;    to point to the next chunk of code to execute.  So we can spin in a
;    very tight loop and automatically get blown out of the loop when the
;    interrupt occurs.
;
;    This is all pretty sleazy, but it allows us to calibrate accurately
;    without relying on the 8259 or 8254 (just BIOS).  It also does not
;    depend on whether the ISR can affect the CPU registers or not.  (some
;    BIOSes, notably Olivetti, will preserve the registers for you)
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Number of increments required to stall for one microsecond
;
;--

EXPORT_ENTRY_MACRO    GetStallCount
;
; Go into real mode.
;


        ENTER_REALMODE_MACRO

        cli

        push    di
        push    si
        push    ds
        mov     ax,0
        mov     ds,ax

;
; save previous vector
;
        mov     di, 01ch*4
        mov     cx, [di]
        mov     dx, [di+2]

;
; insert our vector
;
        mov     ax, offset GscISR
        mov     [di], ax
        push    cs
        pop     ax
        mov     [di+2], ax

        mov     eax,0
        mov     ebx,0
        mov     si,sp
        sub     si,6
        mov     cs:savesp,si
        mov     cs:newip,offset GscLoop2
        sti

;
; wait for first tick.
;
GscLoop1:
        cmp     ebx,0
        je      GscLoop1

;
; start counting
;
;
; We spin in this loop until the ISR fires.  The ISR will munge the return
; address on the stack to blow us out of the loop and into GscLoop3
;
GscLoop2:
        mov     cs:newip,offset GscLoop4

GscLoop3:

        add     eax,1
        jnz     short GscLoop3

;
GscLoop4:
;
; stop counting
;

;
; replace old vector
;
        cli
        mov     [di],cx
        mov     [di+2],dx
        sti

        pop     ds
        pop     si
        pop     di
        jmp     GscDone

newip   dw      ?
savesp  dw      ?

GscISR:
;
; blow out of loop
;
        push    bp
        push    ax
        mov     bp,cs:savesp
        mov     ax,cs:newip
        mov     ss:[bp],ax
        pop     ax
        pop     bp

GscISRdone:
        iret


GscDone:
        mov     edx, eax
        mov     ecx,16
        shr     edx,cl                  ; (dx:ax) = dividend
        mov     cx,0D6A6h               ; (cx) = divisor

        div     cx

        and     eax,0ffffh
        inc     eax                     ; round loopcount up (prevent 0)

;
; Re-enable protect-mode and paging.
;
        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax

;
; Return to caller and the 32bit universe.
;

EXPORT_EXIT_MACRO


;++
;
; Routine Name:
;
;       InitializeDisplayForNt
;
; Description:
;
;       Puts the display into 50 line mode
;
; Arguments:
;
;       None
;
; Returns:
;
;       None
;
;--

EXPORT_ENTRY_MACRO      InitializeDisplayForNt
;
; Go into real mode.
;

        ENTER_REALMODE_MACRO

        mov     ax, 1112h       ; Load 8x8 font
        mov     bx, 0
        int     10h

        RE_ENABLE_PAGING_MACRO

EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetMemoryDescriptor
;
; Description:
;
;       Returns a memory descriptor
;
; Arguments:
;
;       pointer to MemoryDescriptorFrame
;
; Returns:
;
;       None
;
;--

EXPORT_ENTRY_MACRO      GetMemoryDescriptor

;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <MemoryDescriptorFramePointer>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2


        mov     eax,[bp].E820FramePointer
        mov     bp,ax
        and     bp,0fh
        shr     eax,4
        mov     es,ax                   ; (es:bp) = E820 Frame

        mov     ebx, es:[bp].Key
        mov     ecx, es:[bp].DescSize
        lea     di, [bp].BaseAddrLow
        mov     eax, 0E820h
        mov     edx, 'SMAP'             ; (edx) = signature

        INT     15h
        mov     es:[bp].Key, ebx        ; update callers ebx
        mov     es:[bp].DescSize, ecx   ; update callers size

        sbb     ecx, ecx                ; ecx = -1 if carry, else 0
        sub     eax, 'SMAP'             ; eax = 0 if signature matched
        or      ecx, eax
        mov     es:[bp].ErrorFlag, ecx  ; return 0 or non-zero

;
; Restore bp and remove stack-frame from stack
;

        pop     bp
        REMOVE_STACK_FRAME_MACRO <MemoryDescriptorFramePointer>
        RE_ENABLE_PAGING_MACRO

EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetElToritoStatus
;
; Description:
;
;       Get El Torito Disk Emulation Status
;
; Arguments:
;
;       None
;
; Returns:
;
;       None
;
;--

EXPORT_ENTRY_MACRO      GetElToritoStatus
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetElToritoStatusFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2

        push    dx
        push    bx
        push    ds
        push    si

;
; Put the Specification Packet pointer into DS:SI, and the Drive
; Number on DL. Note that and buffer
; addresses passed to this routine MUST be in the lower one
; megabyte of memory to be addressable in real mode.
;

        mov     eax,[bp].SpecPacketPointer
        mov     bx,ax
        and     bx,0fh
        mov     si,bx
        shr     eax,4
        mov     ds,ax

        mov     dl,byte ptr [bp].ETDriveNum

        mov     ax,04B01h                       ; Function = Return Disk Emulation status
        int     BIOS_DISK_INTERRUPT

        jc      etstatuserr

;
; Carry wasn't set so we have no error and need to "clean" eax of
; any garbage that may have been left in it.
;
        xor     eax,eax

etstatuserr:
;
; Mask-off any garbage that my have been left in the upper
; 16bits of eax.
;
        and     eax,0000ffffh

        pop     si
        pop     ds
        pop     bx
        pop     dx

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetElToritoStatusFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


;++
;
; Routine Name:
;
;       GetExtendedInt13Params
;
; Description:
;
;       Determine if extended int13 services are available for a drive
;       and if so retrieve extended disk parameters.
;
; Arguments:
;
;       - 32-bit flat pointer to 26-byte param packet filled by this routine
;
;       - int 13 unit number
;
; Returns:
;
;       ax = 0 means extended int13 not supported on the given drive
;       ax = 1 means extended int13 supported and param packet filled in
;
;--

EXPORT_ENTRY_MACRO      GetExtendedInt13Params
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetExtendedInt13ParamsFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2

        push    dx
        push    bx
        push    ds
        push    si

;
; Check for support for this drive.
;
        mov     ah,41h
        mov     bx,55aah
        mov     dl,byte ptr [bp].Int13UnitNumber
        int     BIOS_DISK_INTERRUPT
        jc      noxint13                        ; carry set means no xint13
        cmp     bx,0aa55h                       ; check signature
        jnz     noxint13                        ; not present, no xint13
        test    cl,1                            ; bit 0 clear means no xint13
        jz      noxint13

;
; If we get here it looks like we have xint13 support.
; Some BIOSes are broken though so we do some validation while we're
; asking for the extended int13 drive parameters for the drive.
; Note that and buffer addresses passed to this routine
; MUST be in the lower one megabyte of memory to be addressable in real mode.
;
        mov     eax,[bp].ParamPacketPointer
        mov     bx,ax
        and     bx,0fh
        mov     si,bx
        shr     eax,4
        mov     ds,ax                           ; DS:SI -> param packet
        mov     word ptr [si],26                ; initialize packet with size
                                                ; some bioses helpfully zero out
                                                ; the whole buffer according to
                                                ; this size, so make SURE the
                                                ; entire word is initialized and
                                                ; there's no junk in the high byte.

        mov     dl,byte ptr [bp].Int13UnitNumber
        mov     ah,48h
        int     BIOS_DISK_INTERRUPT
        jc      noxint13
;
; If we get here then everything's cool and we have xint13 parameters.
; We also know carry isn't set.
;
        mov     al,1
        jnc     xint13done

noxint13:
        xor     al,al

xint13done:
        movzx   eax,al

        pop     si
        pop     ds
        pop     bx
        pop     dx

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetExtendedInt13ParamsFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


;++
;
; Routine Name:
;
;       ApmAttemptReconnect
;
; Description:
;
;       Called only during x86 resume from hiberate operation.  Attempts
;       to connect to APM bios in same way ntdetect.com did on first try,
;       so that if APM is present on the machine, it will be reinited to
;       the same working state it was in before hibernate.
;
;       APM version, addresses, selector mappings, etc, are assumed
;       not to have changed while the machine is hibernated.
;
;
; Arguments:
;
;       None.
;
; Returns:
;
;       None.  (It either works or it doesn't.)
;
;--

;
; Yet another set of cheater APM include values
;
APM_INSTALLATION_CHECK          equ     5300h
APM_REAL_MODE_CONNECT           equ     5301h
APM_PROTECT_MODE_16bit_CONNECT  equ     5302h
APM_DRIVER_VERSION              equ     530Eh
APM_DISCONNECT                  equ     5304h

APM_DEVICE_BIOS                 equ     0h
APM_MODE_16BIT                  equ     1h

EXPORT_ENTRY_MACRO      ApmAttemptReconnect

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;
        ENTER_REALMODE_MACRO

;
; APM installation check
;
        mov     eax,APM_INSTALLATION_CHECK
        mov     ebx,APM_DEVICE_BIOS
        int     15h

        jc      aar_punt
        cmp     bl,'M'
        jnz     aar_punt
        cmp     bh,'P'
        jnz     aar_punt

;
; If we get here, we have an APM bios.  If we just call it,
; we may get grief.  So we will connect in real mode, then
; set our version to the whatever the driver says it is, or 1.2,
; whichever is LESS.  Then query options again.
;

        cmp     ah,1
        jle     aar10
        mov     ah,1            ; ah = min(old ah, 1)
aar10:

        cmp     al,2
        jle     aar20
        mov     al,2            ; al = min(old al, 2)
aar20:

;
; ax = min(apm version, 1.2)
;
        push    ax

;
; connect to the real mode interface
;

        mov     ax,APM_REAL_MODE_CONNECT
        mov     bx,APM_DEVICE_BIOS
        int     15h

        pop     ax
        jc      aar_punt
        push    ax

;
; set the version of the real mode interface
;
        mov     cx,ax           ; ax = major.minor
        mov     bx,APM_DEVICE_BIOS
        mov     ax,APM_DRIVER_VERSION
        int     15h

        pop     ax
        jc      aar_punt

;
; do the install check again, now that we've connected and
; set the version to min(apm ver, 1.2)  some apm bios code
; will give us different install parameters now.
;
        mov     ax,APM_INSTALLATION_CHECK
        mov     bx,APM_DEVICE_BIOS
        int     15h

        jc      aar_punt

;
; If we are here:
;       AH = revised Major version
;       AL = revised Minor version
;       CX = APM Flags
;
        push    cx
        push    ax

;
; Now disconnect from the real mode interface
;
        mov     ax,APM_DISCONNECT
        mov     bx,APM_DEVICE_BIOS
        int     15h

        pop     ax
        pop     cx
        jc      aar_punt

;
; Since we are here:
;       AH = revised Major version
;       AL = revised Minor version
;       CX = apm parameters
;
;       APM is present, and seems to work, and we've set it to the
;       version number that we think it and we both like.
;
;       So, things should just work, if APM has proper support
;       for the modes and features that we need.
;

        cmp     cx,APM_MODE_16BIT
        jz      aar_punt

;
; 16bit protected mode is available
;
        push    ax
        push    cx

;
; do 16 bit protected mode connect
;
        mov     ax,APM_PROTECT_MODE_16bit_CONNECT
        mov     bx,APM_DEVICE_BIOS
        int     15h

        pop     cx
        pop     ax
        jc      aar_punt

;
; do 16 bit protected mode set version
;

        mov     cx,ax
        mov     ax,APM_DRIVER_VERSION
        mov     bx,APM_DEVICE_BIOS
        int     15h

;
; if NC, then we have connect to 16bit proected mode interface,
; AND set the version.  since ntdetect.com presumably did this
; exact same thing at first boot, we already have GDT entries pointing
; to the 16bit code, hooks set, etc.  So, in theory, it just works.
;
; if CY here, or anywhere above, APM doesn't work for us.  Too bad.
;

aar_punt:
;
; return to paged mode
;
        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\su.h ===
//
// Master include file for StartUp Module
//

#define i386
#define __stdcall
#define __cdecl
#define UNALIGNED
#pragma warning(disable:4103)
#pragma warning(disable:4341)
#include "types.h"
#include "ntmisc.h"
#include "ntconfig.h"
#include "global.h"
#include "constant.h"
#include "memmap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\su.inc ===
;++
;
; Module name
;
;       su.inc
;
; Author
;
;       Thomas Parslow  (tomp)  Mar-1-90
;
; Description
;
;       Include file for SU.ASM.
;
;
;--

.386

PAGE_SIZE               equ     1000h
MACHINE_TYPE_ISA        equ     0
MACHINE_TYPE_EISA       equ     1
MACHINE_TYPE_MCA        equ     2

;
; Define the segment:offset address pair of the location to
; load detection module.
; N.B. This definition *MUST* be the same as the ones defined
;      in ..\constant.h
;

DETECTION_ADDRESS_SEG   equ     1000h
DETECTION_ADDRESS_OFFSET        equ     0

;
; Structure definitions and equates for INT 15 function E820
;

E820Frame struc
        ErrorFlag       dd      ?
        Key             dd      ?
        DescSize        dd      ?

        BaseAddrLow     dd      ?
        BaseAddrHigh    dd      ?
        SizeLow         dd      ?
        SizeHigh        dd      ?
        MemoryType      dd      ?
E820Frame ends

MemoryDescriptorFramePointer struc
        E820FramePointer    dd      ?
MemoryDescriptorFramePointer ends



;

BIOS_DISK_INTERRUPT     equ     13h
BIOS_READ_SECTOR        equ     2
IDT_ENTRIES             equ     100h

BIOS_KEYBOARD_INTERRUPT equ     16h

EXPORT_STACK            equ     07ffeh
RE_ENABLING             equ     1
LOADER_STACK            equ     061ffch

CR0_ET                  equ     10h

;
; Trap Number macro save eax on the stack and then pushes the
; number of the trap that's in progress.
;

TRAP_NUMBER      macro  num,addr
        IF num EQ 9
        push     eax  ; push place holder for error code
        ENDIF
        IF num LE 7
        push     eax  ; push place holder for error code
        ENDIF
        push     eax       ; save eax on stack first
        mov      eax,num
        push     eax
        jmp      addr
        endm

;;
;
; GetSector Stack Frame Structure
;
; Stack frame definition for GetSector call from OS loader
; to 16bit routines.
;
;;

GetSectorFrame          struc
        FunctionNumber  dd      ?
        DriveNumber     dd      ?
        HeadNumber      dd      ?
        TrackNumber     dd      ?
        SectorNumber    dd      ?
        NumberOfSectors dd      ?
        BufferPointer   dd      ?
GetSectorFrame          ends

;;
;
; GetEddsSector Stack Frame Structure
;
; Stack frame definition for GetEddsSector call from OS loader
; to 16bit routines.
;
;;

GetEddsSectorFrame      struc
        DriveNum        dd      ?
        LBNLow          dd      ?
        LBNHigh         dd      ?
        NumberOfBlocks  dd      ?
        BufPointer      dd      ?
        FunctionNum     dd      ?
GetEddsSectorFrame      ends

RebootFrame             struc
        BootType        dd      ?
RebootFrame             ends

;
; ABIOS services Stack Frame Structure
;
; Stack frame definition for ABIOS services call from OS loader
; to 16 bit routine.
;

AbiosServicesFrame      struc
        AbiosFunction   dd      ?
        CommonDataArea  dd      ?
        InitTable       dd      ?
        RamExtension    dd      ?
        AbiosRoutine    dd      ?
        LogicalId       dd      ?
        NumberLids      dd      ?
AbiosServicesFrame      ends

;
; Hardware detection frame structure
;
; Stack frame definition for DetectHardware call from OS loader
; to 16 bit routine.
;

DetectionFrame          struc
        HeapStart       dd      ?
        HeapSize        dd      ?
        ConfigTree      dd      ?
        HeapUsed        dd      ?
        LoadOptions     dd      ?
        OptionsLength   dd      ?
DetectionFrame          ends

;
; HardwareCursor Stack Frame Structure
;
; Stack frame definition for HardwareCursor call from OS loader
; to 16 bit routine.
;

HardwareCursorFrame     struc
        XCoord          dd      ?
        YCoord          dd      ?
HardwareCursorFrame     ends

;
; GetDateTime Stack Frame Structure
;
; Stack frame definition for GetDateTime call from OS loader
; to 16 bit routine.
;

GetDateTimeFrame        struc
        DateDword       dd      ?
        TimeDword       dd      ?
GetDateTimeFrame        ends


;
; ComPort Stack Frame Structure
;
; Stack frame definition for ComPort call from OS loader
; to 16 bit routine.
;

ComPortFrame            struc
        ComPortPort     dd      ?
        ComPortFunction dd      ?
        ComPortArg      dd      ?
ComPortFrame            ends

;
; IsMcaMachine Stack Frame Structure
;
; Stack frame definition for IsMcaMachine call from OS loader
; to 16 bit routine.
;

IsMcaMachineFrame       struc
        Dummy           dd      ?
IsMcaMachineFrame       ends

;;
;
; GetElToritoStatus Stack Frame Structure
;
; Stack frame definition for GetElToritoStatus call from OS loader
; to 16bit routines.
;
;;

GetElToritoStatusFrame     struc
        SpecPacketPointer  dd      ?
        ETDriveNum         dd      ?
GetElToritoStatusFrame     ends

;;
;
; GetExtendedInt13Params Stack Frame Structure
;
; Stack frame definition for GetExtendedInt13Params call from OS loader
; to 16bit routines.
;
;;

GetExtendedInt13ParamsFrame struc
        ParamPacketPointer dd      ?
        Int13UnitNumber    dd      ?            ; really only a byte >= 0x80
GetExtendedInt13ParamsFrame ends

;;
;
; Memory Descriptor Structure.
;
; Passed to OS loader as part of the boot context record
;
;;

MemoryDescriptor struc
        BlockBase       dd              ?
        BlockSize       dd              ?
MemoryDescriptor ends

;;
;
; File System Context Record Structure
;
;;

FsContextRecord struc
        BootDrive       db              ?
FsContextRecord ends

;;
;
; IDT Descriptor Structure
;
;;

TrapDesc        struc
        IDT_offset      dw              ?
        IDT_selector    dw              ?
        IDT_attribute   dw              ?
        IDT_reserved    dw              ?
TrapDesc        ends

;;
;
; GDT Descriptor Structure ;;
;
;;

GDTDesc         struc
        GDT_limit       dw              0
        GDT_base1       dw              0
        GDT_base2       db              0
        GDT_access      db              0
        GDT_limacc      db              0
        GDT_base3       db              0
GDTDesc         ends


;;
;
; GDT Selector Definitions
;
;;

NULL_Selector           equ     0h
KeCodeSelector          equ     8h
KeDataSelector          equ     10h
UsCodeSelector          equ     18h
UsDataSelector          equ     20h
TSS_Selector            equ     28h
PCR_Selector            equ     30h
TEP_Selector            equ     38h
BDA_Selector            equ     40h
KeLdtSelector           equ     48h
DblFltTskSelector       equ     50h
SuCodeSelector          equ     58h
SuDataSelector          equ     60h
VideoSelector           equ     68h
GDT_AliasSelector       equ     70h
DbCodeSelector          equ     78h
DbDataSelector          equ     80h
DebugUseSelector        equ    88h
ReservedSelector        equ    90h

;;
;
; Exception Frame Structure
; Note, this absolutely must match the corresponding structure
; defined in "types.h"
;
;;

ExceptionFrame struc
        Ftr     dw       0
        Fdr6    dd       0
        Fcr0    dd       0
        Fcr2    dd       0
        Fcr3    dd       0
        Fss     dw       0
        Fgs     dw       0
        Ffs     dw       0
        Fes     dw       0
        Fds     dw       0
        Fedi    dd       0
        Fesi    dd       0
        Febp    dd       0
        Fesp    dd       0
        Febx    dd       0
        Fedx    dd       0
        Fecx    dd       0
        TrapNum dd       0
        Feax    dd       0
        Error   dd       0
        Feip    dd       0
        Fcs     dd       0
        Feflags dd       0
ExceptionFrame  ends



FUNCTION_ERROR  equ     -1

;;
;
; Register Frame Structure
;
; For bios int calls
;
;;

reg_frame struc
        intnum  dw      ?
        sfg     dw      ?
        sax     dw      ?
        sbx     dw      ?
        scx     dw      ?
        sdx     dw      ?
        ssi     dw      ?
        ses     dw      ?
reg_frame ends

;;
;; Processor Flags
;;

PROT_MODE               equ     000000001       ; Enable protect mode operation
ENABLE_PAGING           equ     80000000h       ; Enable paging hardware
PD_PHYSICAL_ADDRESS     equ     99000h
TSS_SIZE                equ     80h
OVERRIDE                equ     66h

;
; Operand and Address size overrides
;

OPSIZE          macro
                db 66h
                endm
ADSIZE          macro
                db 67h
                endm


;
; External Procedures for SUDATA.ASM
;

IFDEF SU_CODEMODULE
extrn _SuMain:near
extrn _ScreenStart:near
extrn _vp:near
extrn _putx:near
extrn _TrapHandler:near
extrn _GDTregister:fword
extrn _IDTregister:fword
extrn _IDTregisterZero:fword
extrn saveDS:word
extrn SuStack:word
extrn _edata:word
extrn _FileStart:dword
ENDIF



;
; External Procedures for SUDATA.ASM
;

IFDEF SU_DATAMODULE
extrn  Trap0:far
extrn  Trap1:far
extrn  Trap2:far
extrn  Trap3:far
extrn  Trap4:far
extrn  Trap5:far
extrn  Trap6:far
extrn  Trap7:far
extrn  Trap8:far
extrn  Trap9:far
extrn  TrapA:far
extrn  TrapB:far
extrn  TrapC:far
extrn  TrapD:far
extrn  TrapE:far
extrn  TrapF:far
extrn  _edata:near
ENDIF



;
; Segment declarations for "Small Model" 16 bit Su Module.
;

_TEXT   segment para use16 public 'CODE'
_TEXT   ends

_DATA   segment para use16 public 'DATA'
_DATA   ends

CONST   segment para use16 public 'CONST'
CONST   ends

_BSS    segment para use16 public 'BSS'
_BSS    ends

DGROUP  group   const, _BSS, _DATA


;;; END OF FILE ;;;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\types.h ===
/*

File

      types.h


Description

      defines and structure definitions for nt386 boot loader


Author

      Thomas Parslow  [TomP]

*/

#define IN
#define OUT
#define OPTIONAL
#define NOTHING
#define CONST               const

//
// Void
//

typedef void *PVOID;    // winnt

//
// Basics
//

#define VOID    void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
typedef long LONGLONG;

//
// ANSI (Multi-byte Character) types
//

typedef CHAR *PCHAR;

typedef double DOUBLE;

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt

//
// Unsigned Basics
//

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef unsigned long ULONGLONG;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef ULONG KAFFINITY;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;

//
// Far point to Basic
//

typedef UCHAR far  * FPCHAR;
typedef UCHAR far  * FPUCHAR;
typedef VOID far   * FPVOID;
typedef USHORT far * FPUSHORT;
typedef ULONG far  * FPULONG;

//
// Boolean
//

typedef CCHAR BOOLEAN;
typedef BOOLEAN *PBOOLEAN;

//
// UNICODE (Wide Character) types
//

typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;

//
// Large (64-bit) integer types and operations
//

typedef struct _LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

#define FP_SEG(fp) (*((unsigned *)&(fp) + 1))
#define FP_OFF(fp) (*((unsigned *)&(fp)))
#define toupper(x) (((x) >= 'a' && (x) <= 'z') ? x - 'a' + 'A' : x )
#define isascii(x) (((x) >= ' ' && (x) < 0x80) ? 1 : 0)

#define FLAG_CF 0x01L
#define FLAG_ZF 0x40L
#define FLAG_TF 0x100L
#define FLAG_IE 0x200L
#define FLAG_DF 0x400L

#define TRUE 1
#define FALSE 0
#define NULL   ((void *)0)

typedef UCHAR far  * FPCHAR;
typedef UCHAR far  * FPUCHAR;
typedef VOID far   * FPVOID;
typedef USHORT far * FPUSHORT;
typedef ULONG far  * FPULONG;
typedef UCHAR FAT;
typedef FAT * PFAT;
typedef LONG  NTSTATUS;


typedef struct _FSCONTEXT_RECORD {
    UCHAR BootDrive;
} FSCONTEXT_RECORD, *PFSCONTEXT_RECORD;

typedef struct {
    USHORT SpecifyBytes;
    UCHAR  WaitTime;
    UCHAR  SectorLength;
    UCHAR  LastSector;
    UCHAR  SecGapLength;
    UCHAR  DataTransfer;
    UCHAR  TrackGapLength;
    UCHAR  DataValue;
    UCHAR  HeadSettle;
    UCHAR  StartupTime;
} DISK_BASE_TABLE;

//
// biosint register structure
//

typedef struct {
   USHORT   fn;
   USHORT   fg;
   USHORT   ax;
   USHORT   bx;
   USHORT   cx;
   USHORT   dx;
   USHORT   si;
   USHORT   es;
} BIOSREGS;


//
// Trap Frame Structure when error code is present
//

typedef struct {
    USHORT Ftr;
    ULONG  Fdr6;
    ULONG  Fcr0;
    ULONG  Fcr2;
    ULONG  Fcr3;
    USHORT Fss;
    USHORT Fgs;
    USHORT Ffs;
    USHORT Fes;
    USHORT Fds;
    ULONG  Fedi;
    ULONG  Fesi;
    ULONG  Febp;
    ULONG  Fesp;
    ULONG  Febx;
    ULONG  Fedx;
    ULONG  Fecx;
    ULONG  TrapNum;
    ULONG  Feax;
    ULONG  Error;
    ULONG  Feip;
    ULONG  Fcs;
    ULONG  Feflags;

} TF_ERRCODE, *PTF ;

//
//  Task State Segment structure
//

typedef struct {
    USHORT Link;
    USHORT a;
    ULONG  Esp0;
    USHORT SS0;
    USHORT b;
    ULONG  Esp1;
    USHORT SS1;
    USHORT c;
    ULONG  Esp2;
    USHORT SS2;
    USHORT d;
    ULONG  Cr3;
    ULONG  Eip;
    ULONG  Eflags;
    ULONG  Eax;
    ULONG  Ecx;
    ULONG  Edx;
    ULONG  Ebx;
    ULONG  Esp;
    ULONG  Ebp;
    ULONG  Esi;
    ULONG  Edi;
    USHORT ES;
    USHORT e;
    USHORT CS;
    USHORT f;
    USHORT SS;
    USHORT g;
    USHORT DS;
    USHORT h;
    USHORT FS;
    USHORT i;
    USHORT GS;
    USHORT j;
    USHORT Ldt;
    USHORT k;

} TSS_FRAME, *PTSS_FRAME;


//
// Overlay structure of disk bios parameter block
//

typedef struct {
   USHORT   bps;
   UCHAR    spc;
   USHORT   sra;
   UCHAR    cof;
   USHORT   rde;
   USHORT   tns;
   UCHAR    dmd;
   USHORT   spf;
   USHORT   spt;
   USHORT   noh;
   union {
   USHORT   shs;
   ULONG    bhs;   // hidden sectors
   } hs;
   ULONG    bts;  // extended total sectors
} DISKBPB;

typedef DISKBPB far * FPDISKBPB;



//
// FAT directory structure
//

typedef struct {
   CHAR     fname[11];
   UCHAR    attrb;
   UCHAR    rsrv[10];
   USHORT   time;
   USHORT   date;
   USHORT   clust;
   ULONG    size;

} DIRENTRY,*PDIRENTRY,far * FPDIRENTRY;

typedef struct {
   CHAR  fname[11];
   UCHAR attrb;
   UCHAR rsrv[10];
   USHORT time;
   USHORT date;
   USHORT starting_cluster;
   ULONG file_size;
   ULONG fptr;
   PUCHAR clusterbuffer;
   USHORT cur_phys_cluster;
   USHORT cur_file_cluster;
} FILEDESCRIPTOR,* FILEHANDLE;

/*
typedef struct {

   USHORT bff[FAT_BUFFERS];
   USHORT usebuf;
   FAT *  fcptr;

} FATCACHE;
*/

typedef struct {
   USHORT   limit;
   USHORT   base1;
   UCHAR     base2;
   UCHAR     access;
   UCHAR     limacc;
   UCHAR     base3;
} _GDT,far *FPGDT;


typedef  ULONG  IDT,*PIDT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\su.asm ===
;++
;
; Module name
;
;       su.asm
;
; Author
;
;       Thomas Parslow  (tomp)  Jan-15-91
;
; Description
;
;       Startup module for the 386 NT OS loader.
;
; Exported Procedures
;
;       EnableProtectPaging
;
; Notes
;       NT386 Boot Loader program. This assembly file is required in
;       order to link C modules into a "/TINY"  (single segment) memory
;       model.
;
;
; This file does the following:
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 1) Defines the entry point for the boot loader's startup program
; 2) Computes what values should actually be in the DS and SS registers.
; 3) Provides the int bios functionality
; 4) Provides 386/486 mode (protect/paging) switching code.
;
; The OS/2 bootstrap routine (boot sector) loads the boot loader program at
; real-mode address 2000:0000 with the following register values:
;
;       CS = 2000
;       IP = 0000
;       DS = 07C0
;       ES = 1000
;       SS = 0000
;       SP = 7C00
;
; Build Notes:
; ~~~~~~~~~~~~
; The microsoft C compiler will not produce "tiny" model programs. In the
; tiny model, the entire program consists of only one segment. The small
; model produced by our compilers consists of two segments: DGROUP and _TEXT.
; If you convert a small model program into a tiny model program, DS (which
; should point to DGROUP (bss,const,data) will always be wrong. For this reason
; we need an assembly module to do a simple run-time fixup on SS and DS. To
; guarantee that DS will point to DGROUP no matter where os2ldr is loaded,
; the paragraph (shifted right four bits) offset of DGROUP from _TEXT must
; be added to the value in CS to compute DS and SS.
;
; We get the linker to fixup the offset of the beginning of the dgroup segment
; relative to the beginning of the code segment and it's this value added
; to the value in CS that allows us to build a "tiny" model program in C
; without a lot of munging around in order to get the data reference offsets
; in the code correct.
;
; If the _TEXT:DGROUP fixup appears in other files (which it does), the linker
; will not compute the correct value unless the accumulated data pointer is
; zero when it gets there. Therefore, no data should be placed in the data segment
; until after all instances of _TEXT:DGROUP have been encountered by the linker.
; The linker processes files from right to left on the command line.
;
; A Note About Stacks
; Initially we run on our internal stack (SuStack) which is only 160 bytes deep
; but seems to do the trick. Then we have to have a separate double fault stack.
; This stack can be in the middle of the stack/data segment. It will step on
; the loader image, but that's ok since the fault was either caused by 16bit
; code (which won't be in the loader image) or, it was caused by the 32bit
; loader (which has already been relocated) so we won't be stepping on code
; that may have caused the fault. And finally, we have the "call back" stack
; which  starts at the top of the stack/data segment. We use this during
; all call backs since the original loader source is no longer needed and
; this'll give us plenty of stack for bios calls etc.
;
;--

DoubleWord      struc
lsw     dw      ?
msw     dw      ?
DoubleWord      ends

;
; This is the structure used to pass all shared data between the boot sector
; and NTLDR.
;

SHARED  struc
        ReadClusters            dd      ?               ; function pointer
        ReadSectors             dd      ?               ; function pointer

        SectorBase              dd      ?               ; starting sector
                                                        ; for ReadSectors
                                                        ; callback
SHARED  ends


BPB     struc
        BytesPerSector          dw      ?
        SectorsPerCluster       db      ?
        ReservedSectors         dw      ?
        Fats                    db      ?
        DirectoryEntries        dw      ?
        Sectors                 dw      ?
        Media                   db      ?
        FatSectors              dw      ?
        SectorsPerTrack         dw      ?
        Heads                   dw      ?
        HiddenSectors           dd      ?
        SectorsLong             dd      ?
;
; The following byte is NOT part of the BPB but is set by SYS and format
;

        BootDriveNumber         db      ?
BPB     ends

SU_CODEMODULE    equ      1        ; Identifies this module to "su.inc"
include su.inc
include macro.inc

extrn _BootRecord:word
extrn _puts:near
extrn _MemoryDescriptorList:near
extrn _InsertDescriptor:near

MAXREAD     EQU 10000h
MAXSECTORS  EQU MAXREAD/0200h

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP
.386p

;
; Run-time fixups for stack and data segment
;

public Start
Start:
;
; The FAT boot sector only reads in the first 512 bytes of NTLDR.  This is
; the module that contains those 512 bytes, so we are now responsible for
; loading the rest of the file.  Other filesystems (i.e. HPFS, NTFS, RIPL)
; will load the whole file, so the default entrypoint branches around the
; FAT-specific code.
;
        jmp     RealStart

FatBegin:
.386
;
; If we're here, we've booted off a FAT system and we must load the rest
; of NTLDR at 2000:0200 (right behind this sector)  NTLDR passes us the
; following:
;       BX = Starting Cluster Number of NTLDR
;       DL = INT 13h drive number we've booted from
;       DS:SI -> boot media's BPB
;       DS:DI -> argument structure (see above struc definition)
;
;
; Save away the boot drive and the starting cluster number
;
        push    dx
        push    bx

;
; Blast the FAT into memory at 6000:0000 - 8000:0000
;

.386
        push    06000h
.8086
        pop     es
        xor     bx,bx                           ; (es:bx) = 6000:0000
        mov     cx,ds:[si].ReservedSectors
        mov     ds:[di].SectorBase.msw,0
        mov     ds:[di].SectorBase.lsw,cx       ; set up Sector Base

        mov     ax,ds:[si].FatSectors           ; (al) = # Sectors to read
        cmp     ax,080h
        jbe     FatLt64k

;  The FAT is > 64k, so we read the first 64k chunk, then the rest.
;  (A 16-bit FAT can't be bigger than 128k)

        push    cx
        mov     ax,080h         ; (al) = # of sectors to read
        call    ds:[di].ReadSectors
        pop     cx                      ; (cx) = previous SectorBase
.386
        push    07000h
.8086
        pop     es
        xor     bx,bx                   ; (es:bx) = 7000:0000
        mov     ax,ds:[si].FatSectors
        sub     ax,080h                 ; (ax) = # Sectors left to read
        add     cx,080h                 ; (cx) = SectorBase for next read
        mov     ds:[di].SectorBase.lsw,cx
        adc     ds:[di].SectorBase.msw,0        ; set up SectorBase

;
; (al) = # of sectors to read
;
FatLt64k:
        call    ds:[di].ReadSectors

;
; FAT is in memory, now we restore our starting cluster number
;
        pop     dx                      ; (dx) = starting cluster number
        xor     bx,bx

;
; set up FS and GS for reading the FAT
;
.386
        mov     ax,6000h
        mov     fs,ax
        mov     ax,7000h
        mov     gs,ax
.8086

;
; set up ES for reading in the rest of us
;
        push    cs
        pop     es

        mov     ah,MAXSECTORS           ; (ah) = number of sectors we can read
                                        ;        until boundary
FatLoop:
;
; (dx) = next cluster to load
;
        push    dx
        mov     al,ds:[si].SectorsPerCluster    ; (al) = number of contiguous sectors
                                                ;        found
        sub     ah,ds:[si].SectorsPerCluster                                                    ;        can read before 64k

;
; Check to see if we've reached the end of the file
;
        cmp     dx,0ffffh
        jne     Fat10

;
; The entire file has been loaded.  Throw away the saved next cluster,
; restore the boot drive, and let NTLDR do its thing.
;
        pop     dx
        pop     dx
        jmp     RealStart

Fat10:
        mov     cx,dx
;
; (dx) = (cx) = last contiguous cluster
; (al) = # of contiguous clusters found
;

        call    NextFatEntry
;
; (dx) = cluster following last contiguous cluster

;
; Check to see if the next cluster is contiguous.  If not, go load the
; contiguous block we've found.
;
        inc     cx
        cmp     dx,cx

        jne     LncLoad

;
; Check to see if we've reached the 64k boundary.  If so, go load the
; contiguous block so far.  If not, increment the number of contiguous
; sectors and loop again.
;
        cmp     ah,0
        jne     Lnc20
        mov     ah,MAXSECTORS           ; (ah) = number of sectors until
                                        ;        boundary reached again
        jmp     short LncLoad

Lnc20:
        add     al,ds:[si].SectorsPerCluster
        sub     ah,ds:[si].SectorsPerCluster
        jmp     short Fat10


LncLoad:
;
; (TOS) = first cluster to load
; (dx)  = first cluster of next group to load
; (al)  = number of contiguous sectors
;
        pop     cx
        push    dx
        mov     dx,cx
        mov     cx,10                   ; (cx) = retry count

;
; N.B.
;       This assumes that we will never have more than 255 contiguous clusters.
;       Since that would get broken up into chunks that don't cross the 64k
;       boundary, this is ok.
;
; (dx) = first cluster to load
; (al) = number of contiguous sectors
; (TOS) = first cluster of next group to load
; (es:bx) = address where clusters should be loaded
;
FatRetry:
        push    bx
        push    ax
        push    dx
        push    cx

if 0
        push    dx
        call    PrintDbg
        mov     dx,ax
        call    PrintDbg
        pop     dx
endif

        call    [di].ReadClusters
        jnc     ReadOk
;
; error in the read, reset the drive and try again
;
if 0
        mov     dx, ax
        call    PrintDbg
endif
        mov     ax,01h
        mov     al,ds:[si].BootDriveNumber
        int     13h
if 0
        mov     dx,ax
        call    PrintDbg
endif
        xor     ax,ax
        mov     al,ds:[si].BootDriveNumber
        int     13h

;
; pause for a while
;
        xor     ax,ax
FatPause:
        dec     ax
        jnz     FatPause

        pop     cx
        pop     dx
        pop     ax
        pop     bx

        dec     cx
        jnz     FatRetry

;
; we have re-tried ten times, it still doesn't work, so punt.
;
        push    cs
        pop     ds
        mov     si,offset FAT_ERROR
FatErrPrint:
        lodsb
        or      al,al
        jz      FatErrDone
        mov     ah,14           ; write teletype
        mov     bx,7            ; attribute
        int     10h             ; print it
        jmp     FatErrPrint

FatErrDone:
        jmp     $
        ; this should be replaced by a mechanism to get a pointer
        ; passed to us in the param block. since the boot sector msg itself
        ; is properly localized but this one isn't.
FAT_ERROR       db      13,10,"Disk I/O error",0dh,0ah,0


ReadOk:
        pop     cx
        pop     dx
        pop     ax
        pop     bx
        pop     dx                      ; (dx) = first cluster of next group
                                        ;        to load.

.386
;
; Convert # of sectors into # of bytes.
;
        mov     cl,al
        xor     ch,ch
        shl     cx,9
.8086
        add     bx,cx
        jz      FatLoopDone
        jmp     FatLoop

FatLoopDone:
;
; (bx) = 0
;   This means we've just ended on a 64k boundary, so we have to
;   increment ES to continue reading the file.  We are guaranteed to
;   always end on a 64k boundary and never cross it, because we
;   will reduce the number of contiguous clusters to read
;   to ensure that the last cluster read will end on the 64k boundary.
;   Since we start reading at 0, and ClusterSize will always be a power
;   of two, a cluster will never cross a 64k boundary.
;
        mov     ax,es
        add     ax,01000h
        mov     es,ax
        mov     ah,MAXSECTORS
        jmp     FatLoop

;++
;
; NextFatEntry - This procedure returns the next cluster in the FAT chain.
;                It will deal with both 12-bit and 16-bit FATs.  It assumes
;                that the entire FAT has been loaded into memory.
;
; Arguments:
;    (dx)   = current cluster number
;    (fs:0) = start of FAT in memory
;    (gs:0) = start of second 64k of FAT in memory
;
; Returns:
;    (dx)   = next cluster number in FAT chain
;    (dx)   = 0ffffh if there are no more clusters in the chain
;
;--
NextFatEntry    proc    near
        push    bx

;
; Check to see if this is a 12-bit or 16-bit FAT.  The biggest FAT we can
; have for a 12-bit FAT is 4080 clusters.  This is 6120 bytes, or just under
; 12 sectors.
;
; A 16-bit FAT that's 12 sectors long would only hold 3072 clusters.  Thus,
; we compare the number of FAT sectors to 12.  If it's greater than 12, we
; have a 16-bit FAT.  If it's less than or equal to 12, we have a 12-bit FAT.
;
        call    IsFat12
        jnc     Next16Fat

Next12Fat:
        mov     bx,dx                   ; (fs:bx) => temporary index
        shr     dx,1                    ; (dx) = offset/2
                                        ; (CY) = 1  need to shift
        pushf                           ;      = 0  don't need to shift
        add     bx,dx                   ; (fs:bx) => next cluster number
.386
        mov     dx,fs:[bx]              ; (dx) = next cluster number
.8086
        popf
        jc      shift                   ; carry flag tells us whether to
        and     dx,0fffh                ; mask
        jmp     short N12Tail
shift:
.386
        shr     dx,4                    ; or shift
.8086

N12Tail:
;
; Check for end of file
;
        cmp     dx,0ff8h                ; If we're at the end of the file,
        jb      NfeDone                 ; convert to canonical EOF.
        mov     dx,0ffffh
        jmp     short NfeDone

Next16Fat:
        add     dx,dx                   ; (dx) = offset
        jc      N16high

        mov     bx,dx                   ; (fs:bx) => next cluster number
.386
        mov     dx,fs:[bx]              ; (dx) = next cluster number
.8086
        jmp     short N16Tail

N16high:
        mov     bx,dx
.386
        mov     dx,gs:[bx]
.8086

N16Tail:
        cmp     dx,0fff8h
        jb      NfeDone
        mov     dx,0ffffh               ; If we're at the end of the file
                                        ; convert to canonical EOF.

NfeDone:
        pop     bx
        ret
NextFatEntry    endp

;++
;
; IsFat12 - This function determines whether the BPB describes a 12-bit
;           or 16-bit FAT.
;
; Arguments - ds:si supplies pointer to BPB
;
; Returns
;       CY set -   12-bit FAT
;       CY clear - 16-bit FAT
;
;--
IsFat12 proc    near

.386
        push    eax
        push    ebx
        push    ecx
        push    edx

        movzx   ecx, ds:[si].Sectors
        or      cx,cx
        jnz     if10
        mov     ecx, ds:[si].SectorsLong
if10:
;
; (ecx) = number of sectors
;
        movzx   ebx, byte ptr ds:[si].Fats
        movzx   eax, word ptr ds:[si].FatSectors
        mul     ebx
        sub     ecx,eax

;
; (ecx) = (#sectors)-(sectors in FATs)
;
        movzx   eax, word ptr ds:[si].DirectoryEntries
        shl     eax, 5
;
; (eax) = #bytes in root dir
;
        mov     edx,eax
        and     edx,0ffff0000h
        div     word ptr ds:[si].BytesPerSector
        sub     ecx,eax

;
; (ecx) = (#sectors) - (sectors in fat) - (sectors in root dir)
;
        movzx   eax, word ptr ds:[si].ReservedSectors
        sub     ecx, eax
        mov     eax, ecx
        movzx   ecx, byte ptr ds:[si].SectorsPerCluster
        xor     edx,edx
        div     ecx

        cmp     eax, 4087
        jae     if20
        stc
        jmp     short if30
if20:
        clc
if30:
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        ret
.8086
IsFat12 endp



PrintDbg       proc    near
        push    ax
        push    bx
        push    cx

        mov     cx,4
pd10:
.386
        rol     dx,4
.8086
        mov     ah,0eh
        mov     bx,7
        mov     al,dl
        and     al,0fh
        add     al,'0'
        cmp     al,'9'
        jbe     pd15
        add     al,'A'-('9'+1)

pd15:
        int     010h
        loop    pd10

        mov     ah,0eh
        mov     al,' '
        mov     bx,7
        int     010h
        pop     cx
        pop     bx
        pop     ax

        ret

PrintDbg      endp

Free    EQU     512-($-Start)
if Free lt 0
        %out FATAL PROBLEM: FAT-specific startup code is greater than
        %out 512 bytes.  Fix it!
        .err
endif

RealStart:
.386p
;
; Compute the paragraph needed for DS
;
if 0
        mov     ax,0
        int     16h
endif

        mov     bx,offset _TEXT:DGROUP  ; first calculate offset to data
        shr     bx,4                    ; must be para aligned

        mov     ax,cs                   ; get base of code
        add     ax,bx                   ; add paragraph offset to data

        mov     ss,ax                      ; ints disabled for next instruct
        mov     sp,offset DGROUP:SuStack   ; (sp) = top of internal stack
;
; Build C stack frame for _SuMain
;
        push    dx                      ; pass bootdisk to main (high byte is ignored)
;
; Make DS point to the paragraph address of DGROUP
;
        mov     ds,ax                   ; ds now points to beginning of DGROUP
        mov     es,ax                   ; es now points to beginning of DGROUP
;
; Compute the physical address of the end of the data segment (which
; will be the beginning of the prepended loader file).
;

        movzx    edx,ax
        shl      edx,4
        add      edx,offset DGROUP:_edata
        mov      dword ptr _FileStart,edx

;
; Force the upper parts of
; of EBP and ESP to be zero in real mode.
;

        xor      bp,bp
        movzx    ebp,bp
        movzx    esp,sp
        mov      [saveDS],ds

        call    _SuMain                 ; go to C code to do everything else.


;++
; _EnableProtectPaging
;
; Loads 386 protect mode registers.
; Enables 386 protection h/w
; Loads pagings registers
; Enables 386 paging h/w
;
;--

public _EnableProtectPaging
_EnableProtectPaging  proc near
;
; Sanitize ES and GS and clean out any junk in the upper 16bits
; of the flags that may have been left by the bios, before we go protected
;
        push     dword ptr 0
        popfd
        mov      bx,sp
        mov      dx,[bx+2]  ; are we enabling prot/paging for the first time?
        xor      ax,ax
        mov      gs,ax
        mov      es,ax


;
; FS must contain the selector of the PCR when we call the kernel
;
        push    PCR_Selector
        pop     fs
;
; Load the gdtr and idtr.
; We disable interrupts here since we can't handle interrups with the
; idt loaded while were in real mode and before we switch to protmode.

        cli
        lgdt     fword ptr [_GDTregister]
        lidt     fword ptr [_IDTregister]


;
; We have to stamp the segment portion of any real-mode far pointer with
; the corresponding selector values before we go protected.
;
        mov      si,offset _ScreenStart
        mov      word ptr [si+2],VideoSelector
        mov      si,offset _vp
        mov      word ptr [si+2],VideoSelector

;
; Enable protect and paging mode
;
        mov      eax,cr0

; If we're enabling protect mode for the first time, don't turn on paging
; because the osloader does all that.  However, if we're returning to
; protected mode, the page tables are already setup, therefore we do want
; to turn paging on.
        or      dx,dx
        jz      only_prot
        or      eax,PROT_MODE + ENABLE_PAGING
        mov     cr0,eax

;
; The following JMP must be DWORD-aligned in order to avoid an obscure i386
; hardware bug.  If not, it is possible (albeit unlikely) that the prefetch
; queue can get trashed.
;

ALIGN 4
        jmp     flush


only_prot:
        or       eax,PROT_MODE
        mov      cr0,eax
;
; Flush the prefetch queue
;

ALIGN 4
        jmp     flush
flush:


;
; Load CS with the SU module's code selector
;
        push    SuCodeSelector
        push    offset cs:restart
        retf
;
; Now load DS and SS with the SU module's protect mode data selector.
;

restart:
        mov      ax,SuDataSelector
        mov      ds,ax
        mov      ss,ax

;
; Load LDT with zero since it will never be used.
;
        xor      bx,bx
        lldt     bx

;
; Load the Task Register and return to the boot SU module.
;
        or       dx,dx
        jnz      epp10


        mov      bx,TSS_Selector
        ltr      bx


epp10:
        ret

_EnableProtectPaging endp

.286p
;** _biosint
;
;   Rom bios interrupt dispatcher
;

public _biosint
_biosint proc    near

        enter   0,0
        push    di
        push    si
        push    ds
        push    es

;       Get pointer to register parameter frame

        les     di,[bp+4]

;       Get requested interrupt number

        mov     ax,es:[di].intnum

;       Check that requested bios interrupt is supported

        sub     ax,10h          ; sub lowest int number supported
        jnc     short bios1
        mov     es:[di].intnum,FUNCTION_ERROR
        jmp     short biosx
bios1:
        shl     ax,1            ; shift if to make it a word offset
        cmp     ax,bios_cnt     ; offset beyond end of table?
        jb      short bios2

;       Error: requested interrupt not supported

        mov     es:[di].sax,FUNCTION_ERROR
        jmp     short biosx

bios2:  mov     bx,ax
        mov     ax,word ptr cs:bios_table[bx]
        push    es              ; save seg of address frame
        push    di              ; save stack register frame pointer
        push    ax              ; address of bios int

        mov     ax,es:[di].sax
        mov     bx,es:[di].sbx
        mov     cx,es:[di].scx
        mov     dx,es:[di].sdx
        mov     si,es:[di].ssi
        mov     es,es:[di].ses
        ret                     ; this sends us to the "int #" instruction

;       We return here from the jmp instruction following the int

bios_ret:

        pop     di              ; get address of register parameter frame
        pop     es              ; restore segment of parameter frame


bios5:  pushf
        pop     es:[di].sfg
        mov     es:[di].sax,ax
        mov     es:[di].sbx,bx
        mov     es:[di].scx,cx
        mov     es:[di].sdx,dx
        mov     es:[di].ssi,si
        mov     es:[di].ses,es

;       Restore original registers and return to caller

biosx:
        pop     es
        pop     ds
        pop     si
        pop     di
        leave
        ret

_biosint endp

;** Bios Interrupt Table
;


bios10: int     10h
        jmp     short bios_ret
bios11: int     11h
        jmp     short bios_ret
bios12: int     12h
        jmp     short bios_ret
bios13: int     13h
        jmp     short bios_ret
bios14: int     14h
        jmp     short bios_ret
bios15: int     15h
        jmp     short bios_ret
bios16: int     16h
        jmp     short bios_ret
bios17: int     17h
        jmp     short bios_ret
bios18: int     18h
        jmp     short bios_ret
bios19: int     19h
        jmp     short bios_ret

bios_table dw      bios10,bios11,bios12,bios13,bios14,bios15,bios16,bios17,bios18,bios19

bios_cnt        equ     $ - bios_table

.386p

;++
;
; _MoveMemory
;
; Routine Description
;
;       Moves dwords in memory from source to destination.
;
; Arguments
;
;       (TOS+4)  =  number of bytes to move
;       (TOS+8)  =  linear address of destination
;       (TOS+12) =  linear address of source
;
; Notes
;
;   1)  Valid page table entries must already exist for the
;       source and destination memory.
;
;   2)  ALL memory in the lower one megabyte is assumed to
;       be identity mapped if used.
;
; USES  ESI, EDI, ECX, FLAGS
;
;
;--


public _MoveMemory
_MoveMemory proc near

        enter    0,0
        push     ds
        push     es
;
; Get source, destination, and count arguments from the stack
; Make "count" the number of dwords to move.
;

        mov      esi,dword ptr [bp+4]
        mov      edi,dword ptr [bp+8]
        mov      ecx,dword ptr [bp+12]
        shr      ecx,2

;
; Load FLAT selectors into DS and ES
;

        mov      ax,KeDataSelector
        mov      ds,ax
        mov      es,ax

;
; Move the block of data.
;
assume es:FLAT, ds:FLAT

;
; move the dwords
;
        cld
        rep     movs    dword ptr [edi],dword ptr [esi]

;
; move the remaining tail
;
        mov     ecx, dword ptr [bp+12]
        and     ecx, 3
        rep     movs    byte ptr [edi],byte ptr [esi]


assume es:nothing, ds:DGROUP

        pop      es
        pop      ds
        leave
        ret

_MoveMemory endp



;++
;
; _ZeroMemory
;
; Routine Description
;
;       Writes zeros into memory at the target address.
;
; Arguments
;
;       (TOS+4)  =  linear address of target
;       (TOS+8)  =  number of bytes to zero
;
; Notes
;
;   1)  Valid page table entries must already exist for the
;       source and destination memory.
;
;   2)  ALL memory in the lower one megabyte is assumed to
;       be identity mapped if used.
;
; USES  ESI, EDI, ECX, FLAGS
;
;
;--

public _ZeroMemory
_ZeroMemory proc near


        enter    0,0
        push     es
;
; Get source, destination, and count arguments from the stack
; Make "count" the number of dwords to move.
;

        mov      edi,dword ptr [bp+4]
        mov      ecx,dword ptr [bp+8]
        shr      ecx,2

;
; Load FLAT selectors into DS and ES
;

        mov      ax,KeDataSelector
        mov      es,ax
        xor      eax,eax

;
; Zero the the block of data.
;
assume es:FLAT

;
; Zero the dwords
;
        cld
        rep     stos    dword ptr [edi]

;
; Zero the remaining bytes
;
        mov     ecx, dword ptr [bp+8]
        and     ecx, 3
        rep     stos    byte ptr [edi]

assume es:nothing, ds:DGROUP

        pop      es
        leave
        ret


_ZeroMemory endp




;++
;
; Turn Floppy Drive Motor Off
;
;--

public _TurnMotorOff
DriveControlRegister      equ      3f2h     ; Floppy control register

_TurnMotorOff proc near

        mov      dx,DriveControlRegister
        mov      ax,0CH
        out      dx,al
        ret

_TurnMotorOff endp


;
; Note: we do not save and restore the gdt and idt values because they
; cannot change while external services are being used by the OS loader.
; This is because they MUST remain identity mapped until all mode
; switching has ceased.
;

public _RealMode
_RealMode proc near

;
; Switch to real-mode
;

        sgdt     fword ptr [_GDTregister]
        sidt     fword ptr [_IDTregister]
        push     [saveDS]          ; push this so we can get to it later
        mov      ax,SuDataSelector
        mov      es,ax
        mov      fs,ax
        mov      gs,ax

        mov      eax,cr0
        and      eax, not (ENABLE_PAGING + PROT_MODE)
        mov      cr0,eax

;
; flush the pipeline
;
        jmp     far ptr here
here:

;
; Flush TLB
;

; HACKHACK - We don't know where the page directory is, since it was
;       allocated in the osloader.  So we don't want to clear out cr3,
;       but we DO want to flush the TLB....
;
        mov     eax,cr3

        nop                             ; Fill - Ensure 13 non-page split
        nop                             ; accesses before CR3 load
        nop                             ; (P6 errata #11 stepping B0)
        nop

        mov     cr3,eax
;
; switch to real mode addressing
;
; N. B. We need to do a far jump rather than a retf, because a retf will not
;       reset the access rights to CS properly.
;
        db      0EAh                    ; JMP FAR PTR
        dw      offset _TEXT:rmode      ; 2000:rmode
        dw      02000h
rmode:
        pop      ax
        mov      ds,ax
        mov      ss,ax
;
; Stamp video pointers for real-mode use
;
        mov     si,offset _ScreenStart
        mov     word ptr [si+2],0b800h
        mov     si,offset _vp
        mov     word ptr [si+2],0b800h
;
; re-enable interrups
;
        lidt    fword ptr [_IDTregisterZero]

;
; Re-enable interrupts
;

        sti
        ret

_RealMode endp








;** _TransferToLoader  - transfer control the the OS loader
;
;
;  Arguments:
;
;       None
;
;  Returns:
;
;       Does not return
;
;**

public _TransferToLoader
_TransferToLoader proc near

;  generates a double fault for debug purposes
;        mov      sp,0
;        push 0

        mov      ebx,dword ptr [esp+2]      ; get entrypoint arg
        xor      eax,eax
        mov      ax,[saveDS]

;
; Setup OS loader's stack. Compute FLAT model esp to id map to
; original stack.
;
        mov      cx,KeDataSelector
        mov      ss,cx
        mov      esp,LOADER_STACK  
;
; Load ds and es with kernel's data selectors
;

        mov      ds,cx
        mov      es,cx

;
; Setup pointer to file system and boot context records
;
; Make a linear pointer to the Boot Context Record

        shl      eax,4
        xor      ecx,ecx
        mov      cx,offset _BootRecord
        add      eax,ecx
        push     eax

        push     1010h       ; dummy return address.
        push     1010h       ; dummy return address.

;
; Push 48bit address of loader entry-point
;
        db OVERRIDE
        push    KeCodeSelector
        push    ebx

;
; Pass control to the OS loader
;
        db OVERRIDE
        retf

_TransferToLoader endp




;++
; Description:
;
;       Gets memory block sizes for memory from zero to one meg and
;       from one meg to 64 meg. We do this by calling int 12h
;       (get conventional memory size) and int 15h function 88h (get
;       extended memory size).
;
; Arguments:
;
;       None
;
; Returns:
;
;       USHORT - Size of usable memory (in pages)
;
;--

public _IsaConstructMemoryDescriptors
BmlTotal        equ     [bp-4]
Func88Result    equ     [bp-6]
_IsaConstructMemoryDescriptors proc near
        push    bp                     ; save ebp
        mov     bp, sp
        sub     sp, 6
;
; Initialize the MemoryList to start with a zero entry.  (end-of-list)
;
        les     si, dword ptr _MemoryDescriptorList
        xor     eax,eax
        mov     es:[si].BlockSize,eax
        mov     es:[si].BlockBase,eax

;
; Get conventional (below one meg) memory size
;
        push    es
        push    si
        int     12h
        movzx   eax,ax
;
; EAX is the number of 1k blocks, which we need to convert to the
; number of bytes.
;
        shl     eax,10

        push    eax
        shr     eax, 12
        mov     BmlTotal, eax
        xor     eax,eax
        push    eax
        call    _InsertDescriptor
        add     sp,8

;
; Get extended memory size and fill-in the second descriptor
;

        mov     ah,88h

        int     15h

        mov     Func88Result,ax
        and     eax,0ffffh
;
; EAX is the number of 1k blocks, which we need to convert to the
; number of bytes.
;
        shl     eax,10
        push    eax
        shr     eax,12
        add     BmlTotal, ax
        mov     eax,0100000h
        push    eax
        call    _InsertDescriptor
        add     sp,8

;
; Try function E801, see if that is supported on this machine
;
        mov     ax,0E801h
        int     15h
        jc      short Isa50

        cmp     ax,Func88Result     ; Is extended memory same as 88?
        je      short Isa40         ; Yes, go add the rest

        cmp     ax, (16-1) * 1024   ; Is extended memory exactly 16MB?
        jne     short Isa50         ; No, conflict between 88 & E801

Isa40:
;
; Function looks like it worked
;
; AX = extended memory < 16M in 1k blocks
; BX = extended memory > 16M in 64k blocks
;
        and     ebx,0ffffh
        jz      short Isa50

        shl     ebx,16              ; ebx = memory > 16M in bytes (via E801)
        add     ebx, 16*1024*1024   ; ebx = end of memory in bytes (via E801)

        mov     ax, Func88Result
        and     eax,0ffffh
        shl     eax, 10             ; eax = memory > 1M in bytes (via 88)
        add     eax, 1*1024*1024    ; eax = end of memory in bytes (via 88)

        sub     ebx, eax            ; ebx = memory above eax
        jbe     short Isa50         ; if ebx <= eax, done

        push    ebx
        shr     ebx,12
        add     BmlTotal, bx
        push    eax
        call    _InsertDescriptor
        add     sp,8
        and     eax,0ffffh

Isa50:
        pop     si
        pop     es
        mov     eax, BmlTotal
        mov     sp, bp
        pop     bp
        ret

_IsaConstructMemoryDescriptors endp

;++
;
; BOOLEAN
; Int15E820 (
;     E820Frame     *Frame
;     );
;
;
; Description:
;
;       Gets address range descriptor by calling int 15 function E820h.
;
; Arguments:
;
; Returns:
;
;       BOOLEAN - failed or succeed.
;
;--

cmdpFrame       equ     [bp + 6]
public _Int15E820
_Int15E820 proc near

        push    ebp
        mov     bp, sp
        mov     bp, cmdpFrame           ; (bp) = Frame
        push    es
        push    edi
        push    esi
        push    ebx

        push    ss
        pop     es

        mov     ebx, [bp].Key
        mov     ecx, [bp].DescSize
        lea     di,  [bp].BaseAddrLow
        mov     eax, 0E820h
        mov     edx, 'SMAP'             ; (edx) = signature

        INT     15h

        mov     [bp].Key, ebx           ; update callers ebx
        mov     [bp].DescSize, ecx      ; update callers size

        sbb     ecx, ecx                ; ecx = -1 if carry, else 0
        sub     eax, 'SMAP'             ; eax = 0 if signature matched
        or      ecx, eax
        mov     [bp].ErrorFlag, ecx     ; return 0 or non-zero

        pop     ebx
        pop     esi
        pop     edi
        pop     es
        pop     ebp
        ret

_Int15E820 endp

_TEXT   ends

        end      Start
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\sudata.asm ===
;++
;
; Module name
;
;       su.asm
;
; Author
;
;       Thomas Parslow  (tomp)  Mar-1-90
;
; Description
;
;       Static data for Startup module for the 386 NT OS loader. The gdt
;       idt, and double fault tss are statically defined here. Also most
;       of the zero init static data is defined here because the SU module
;       must have a zero length .bss section.
;
;
;--

.386p

SU_DATAMODULE       equ      1


include su.inc
include memmap.inc



_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

;
; Global Descriptor Table
;
; Note, the SuCode and SuData segments must have limits of 64k in
; order for the mode switch code to work.
;

public _Beginx86Relocation
public _GDT

_Beginx86Relocation       equ      $
_GDT  equ $
;;;
;;;   Lim 0-15,  Base0-15,Base 16-23, LimAcc,
;;;

;
; Selector 00h - Null selector - unsused
;

GDTDesc <00000h, 00000h, 000h, 000h, 000h, 000h>

;
; Selector 08h  KeCodeSelector  - kernel code segment : FLAT 4gig limit
;

GDTDesc <0ffffh, 00000h, 000h, 09ah, 0cfh, 000h>

;
; Selector 10h - KeDataSelector - kernel data segment : FLAT 4gig limit
;

GDTDesc <0ffffh, 00000h, 000h, 092h, 0cfh, 000h>

;
; Selector 18h - UsCodeSelector - User code segment : FLAT 2gig limit
;

GDTDesc <0ffffh, 00000h, 000h, 0fah, 0cfh, 000h>

;
; Selector 20h - UsDataSelector - User data segment : FLAT 2gig limit
;
GDTDesc <0ffffh, 00000h, 000h, 0f2h, 0cfh, 000h>

;
; Selector 28h - TSS_Selector - Kernels TSS
;

GDTDesc <EndTssKernel - _TssKernel - 1, offset _TEXT:_TssKernel, \
002h, 089h, 000h, 000h> ; TSS

;
; Selector 30h - PCR_Selector - Master Boot Processor's PCR segment
;       This is actually edited later in BlSetupForNt in order to
;       point to a page located at a high virtual address.
;

GDTDesc <01h, 00000h, 000h, 092h, 0c0h, 000h>

;
; Selector 38h - TEP_Selector - Thread Environment
;

GDTDesc <0fffh, 00000h, 000h, 0f3h, 040h, 000h>

;
; Selector 40 - BDA_SAelector - Bios Data Area near-clone
;

GDTDesc <0ffffh, 00400h, 000h, 0f2h, 000h, 000h>

;
; Selector 48h - LdtDescriptor - used to load an ldt
;       (Gets set at Ldt set and process switch by the kernel)
;

GDTDesc <00000h, 00000h, 000h, 000h, 000h, 000h>

;
; Selector 50h - DblFltTskSelector - Double Fault TSS
;

GDTDesc <EndTssDblFault32 - _TssDblFault32 - 1, offset _TEXT:_TssDblFault32,  \
002h, 089h, 000h, 000h> ;

;
; Selector 58h - SuCodeSelector - Startup module's code segment
;

GDTDesc <0ffffh, 00000h, 002h, 09ah, 000h, 000h>

;
; Selector 60h - SuDataSelector - Startup module's data segment
;

GDTDesc <0ffffh, offset _TEXT:DGROUP, 002h, 092h, 000h, 000h>

;
; Selector 68h - VideoSelector - Video display buffer
;

GDTDesc <03fffh, 08000h, 00bh, 092h, 000h, 000h>

;
; Selector 70h - GDT_AliasSelector - GDT Alias Selector
;

GDTDesc <EndGDT - _GDT - 1, 7000h, 0ffh, 092h, 000h,0ffh>


; Debug selectors : CURRENTLY NOT USED

GDTDesc <0ffffh, 00000h, 040h, 09ah, 000h, 080h>  ; 70 Debug Code
GDTDesc <0ffffh, 00000h, 040h, 092h, 000h, 080h>  ; 78 Debug Data
GDTDesc <00000h, 00000h, 000h, 092h, 000h, 000h>  ; 80 Debug Use
GDTDesc <00000h, 00000h, 000h, 000h, 000h, 000h>  ; 88 Spare
DEFINED_GDT_ENTRIES     equ     ($ - _GDT) / size GDTDesc
                 dq ((1024 / size GDTDesc) - DEFINED_GDT_ENTRIES) DUP(0)
EndGDT  equ      $
GDT_SIZE         equ      (EndGDT - _GDT)


;;
;; Interrupt Descriptor Table
;;


public _IDT
align   16
_IDT    equ      $
TrapDesc         <offset Trap0,  KeCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap1,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap2,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap3,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap4,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap5,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap6,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap7,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap8,  SuCodeSelector, 8f00h,  0>
;TrapDesc         <offset Trap8,  DblFltTskSelector,8500h,  0>
TrapDesc         <offset Trap9,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapA,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapB,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapC,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapD,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapE,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapF,  SuCodeSelector, 8f00h,  0>
DEFINED_IDT_ENTRIES     equ     ($ - _IDT) / size TrapDesc
                 dq (IDT_ENTRIES - DEFINED_IDT_ENTRIES) DUP(0)



EndIDT                    equ   $
public _Endx86Relocation
_Endx86Relocation         equ      $

;
; disk-base table.  We copy it from the ROM to here so we can patch the
; last sector number.  This lets us access both 5.25" and 3.5" drives.
;
Public _DiskBaseTable
_DiskBaseTable  equ     $
    SpecifyBytes dw 0
    WaitTime     db 0
    SectorLength db 0
    LastSector   db 0
    SecGapLength db 0
    DataTransfer db 0
    TrackGapLength db 0
    DataValue    db 0
    HeadSettle   db 0
    StartupTime  db 0

Public _RomDiskBasePointer
_RomDiskBasePointer dd 0

;
; Enhanced Disk Drive Spec. Disk Address Packet
;
Public _EddsAddressPacket
_EddsAddressPacket  equ     $
    PacketSize   db  10h
    Reserved1    db  0
    Blocks2Xfer  dw  0
    XferBuf      dd  0
    LBALow       dd  0
    LBAHigh      dd  0

;
; Task State Segment for Double Fault Handler
;
Public _TssDblFault
align 16
_TssDblFault     equ      $
        dw       0 ;link
        dw       offset _DATA:DblFaultStack
        dw       SuDataSelector
        dd       0 ; ring1 ss:sp
        dd       0 ; ring2 ss:sp
        dw       offset _TEXT:Trap8
        dw       0 ; flags
        dw       0 ; ax
        dw       0 ; cx
        dw       0 ; dx
        dw       0 ; bx
        dw       offset _DATA:DblFaultStack ; sp
        dw       0 ; bp
        dw       0 ; si
        dw       0 ; di
        dw       SuDataSelector  ; es
        dw       SuCodeSelector  ; cs
        dw       SuDataSelector  ; ss
        dw       SuDataSelector  ; ds
        dw       0 ; ldt selector
        dw       0
EndTssDblFault   equ      $


_TssDblFault32   equ      $
        dd       0 ;link
        dd       offset _DATA:DblFaultStack
        dd       SuDataSelector
        dd       0 ; ring1 esp
        dd       0 ; ring1 ss
        dd       0 ; ring2 esp
        dd       0 ; ring2 ss
        dd       PD_PHYSICAL_ADDRESS
        dd       offset _TEXT:Trap8
        dd       0 ; eflags
        dd       0 ; eax
        dd       0 ; ecx
        dd       0 ; edx
        dd       0 ; ebx
        dd       offset _DATA:DblFaultStack ; sp
        dd       0 ; bp
        dd       0 ; si
        dd       0 ; di
        dd       SuDataSelector  ; es
        dd       SuCodeSelector  ; cs
        dd       SuDataSelector  ; ss
        dd       SuDataSelector  ; ds
        dd       0 ;fs
        dd       0 ;gs
        dd       0 ; ldt selector
        dd       0 ; i/o map
        dd       0 ;
        dd       0 ;
EndTssDblFault32   equ      $



;
; Stack for Double Fault Handler Task
;

public _FileStart
_FileStart       dd       0

align 4
public DblFaultStack
                 dw       50 DUP(0)
DblFaultStack    equ      $

;
; Note that we need at least 2k of real-mode stack because some EISA BIOS
; routines require it.
;
align 4
public SuStack
public _SuStackBegin
_SuStackBegin    equ      $
                 db       2048 DUP (0)
SuStack          equ      $

align 16
public _TssKernel
_TssKernel       dw       60  DUP(0)
EndTssKernel     equ      $

align 4
public _GDTregister
_GDTregister     dw       EndGDT - _GDT - 1
                 dw       (SYSTEM_PAGE_PA and 0ffffh) + offset DGROUP:_GDT
                 dw       (SYSTEM_PAGE_PA SHR 16) and 0ffh

align 4
public _IDTregister
_IDTregister     dw       EndIDT - _IDT - 1
                 dw       (SYSTEM_PAGE_PA and 0ffffh) + offset DGROUP:_IDT
                 dw       (SYSTEM_PAGE_PA SHR 16) and 0ffh

;
; We load the idtr from the this fword .
;
public _IDTregisterZero
_IDTregisterZero dw       0ffffh
                 dd       0

;
; We save the base of the real mode data segment here so we
; can use it later in calculations of the linear address of
; the start of DGROUP.
;
public saveDS
saveDS           dw       0
;
; When ever we enter the debugger we set this variable to
; on so we can tell if we've faulted in the debugger when
; we get an exception.
;
public _InDebugger
_InDebugger      dw       0

; We save SP here when we get an exception in the debugging
; version of the SU module. If we get an exception in the
; debugger, we use this value to reset the stack to point to
; the base of the original exception/break-point stack frame.
;
public SaveSP
SaveSP           dw       0

;
; BOOT CONTEXT RECORD
;

;
; Export Entry Table
;

extrn RebootProcessor:near
extrn GetSector:near
extrn GetEddsSector:near
extrn GetKey:near
extrn GetCounter:near
extrn Reboot:near
extrn DetectHardware:near
extrn HardwareCursor:near
extrn GetDateTime:near
extrn ComPort:near
extrn GetStallCount:near
extrn InitializeDisplayForNt:near
extrn GetMemoryDescriptor:near
extrn GetElToritoStatus:near
extrn GetExtendedInt13Params:near
extrn ApmAttemptReconnect:near

SU_LOAD_ADDRESS equ 20000h



; FsContext
;
;
public _FsContext
align 4
_FsContext FsContextRecord      <0>

;
; Memory Descriptor Table
;       The Memory Descriptor Table begins at 7000:0000 and grows upward.
;       Note that this is 64k above the start of the OS Loader Heap and
;       64k below the start of the OS Loader Stack.  This is ok, since the
;       x86 Arc Emulation will have converted all of this information into
;       Arc Memory Descriptors before the OS Loader is initialized.
;

align 4
public _MemoryDescriptorList
_MemoryDescriptorList  dw       0
                       dw       7000h

;
; This is called the External Services Table by the OS loader
;

;**
;   NOTE WELL
;       The offsets of entries in this table must match its twin
;       in startup\i386\sudata.asm, and the structure in boot\inc\bldrx86.h
;**
align 4
public _ExportEntryTable
_ExportEntryTable equ     $
                 dw       offset _TEXT:RebootProcessor
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetSector
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetKey
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetCounter
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:Reboot
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:DetectHardware
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:HardwareCursor
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetDateTime
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:ComPort
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetStallCount
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:InitializeDisplayForNt
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetMemoryDescriptor
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetEddsSector
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetElToritoStatus
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetExtendedInt13Params
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       0                             ; fake entry for
                 dw       0                             ; NetPcRomServices
                 dw       offset _TEXT:ApmAttemptReconnect
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       0                             ; fake entry for
                 dw       0                             ; BiosRedirectService
                 dd       0
;**
; See note above
;**

align 4
Public _BootRecord
_BootRecord      dw       offset _TEXT:_FsContext
                 dw       SU_LOAD_ADDRESS SHR 16

                 dw       offset _TEXT:_ExportEntryTable
                 dw       SU_LOAD_ADDRESS SHR 16

;
; The memory descriptor table begins at 0x70000
;
                 dw       0
                 dw       7

public _MachineType
_MachineType     dd       0             ; Machine type infor.

;
; pointer to where osloader.exe is in memory
;
public _OsLoaderStart
_OsLoaderStart          dd      0
public _OsLoaderEnd
_OsLoaderEnd            dd      0
public _ResourceDirectory
_ResourceDirectory      dd      0
public _ResourceOffset
_ResourceOffset         dd      0
public _OsLoaderBase
_OsLoaderBase           dd      0
public _OsLoaderExports
_OsLoaderExports        dd      0
public _BootFlags
_BootFlags              dd      0
public _NtDetectStart
_NtDetectStart          dd      0
public _NtDetectEnd
_NtDetectEnd            dd      0


;
; Defines the machine variables, we can use them to check the validity of
; loaded Ram Extension later.
;

                public  MachineModel, MachineSubmodel, BiosRevision
MachineModel            db      0
MachineSubmodel         db      0
BiosRevision            db      0


;
; keeps track of 8042 access failing so we can avoid doing it repeatedly
;
public _Empty_8042Failed
_Empty_8042Failed       db      0

_DATA   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\trap.asm ===
;++
;
; Module Name:
;
;       trap.asm
;
; Author:
;
;       Thomas Parslow [tomp]
;
; Created:
;
;       15-Jan-91
;
;
; Description:
;
;       x86 exception code
;
;

include su.inc

;
; Exception Routing Table:
; ~~~~~~~~~~~~~~~~~~~~~~~~
; When an exception occurs in the SU module or before the OS loader
; is able to setup its own IDT, control is vectored to one of the
; Trap0 though TrapF labels. We push a number on the stack identifying
; the exception number and then jump to code that pushes the register set
; onto the stack. We then call a general purpose C routine that will dump
; the register contents, the trap number, and error code information
; onto the display.
;

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP
.386p

extrn _TrapHandler:near
extrn _putx:near
extrn _GDTregister:fword
extrn _IDTregister:fword
extrn _InDebugger:word
extrn SaveSP:word

public  Trap0,Trap1,Trap2,Trap3,Trap4,Trap5,Trap6,Trap7
public  Trap8,Trap9,TrapA,TrapB,TrapC,TrapD,TrapE,TrapF


Trap0:  TRAP_NUMBER  0,MakeTrapFrame
Trap1:  TRAP_NUMBER  1,MakeTrapFrame
Trap2:  TRAP_NUMBER  2,MakeTrapFrame
Trap3:  TRAP_NUMBER  3,MakeTrapFrame
Trap4:  TRAP_NUMBER  4,MakeTrapFrame
Trap5:  TRAP_NUMBER  5,MakeTrapFrame
Trap6:  TRAP_NUMBER  6,MakeTrapFrame
Trap7:  TRAP_NUMBER  7,MakeTrapFrame
Trap8:  TRAP_NUMBER  8,MakeTrapFrame
Trap9:  TRAP_NUMBER  9,MakeTrapFrame
TrapA:  TRAP_NUMBER  0Ah,MakeTrapFrame
TrapB:  TRAP_NUMBER  0Bh,MakeTrapFrame
TrapC:  TRAP_NUMBER  0Ch,MakeTrapFrame
TrapD:  TRAP_NUMBER  0Dh,MakeTrapFrame
TrapE:  TRAP_NUMBER  0Eh,MakeTrapFrame
TrapF:  TRAP_NUMBER  0Fh,MakeTrapFrame


;
; We save the user's register contents here on the stack and call
; a C routine to display those contents.
; Uses 42 bytes of stack. (40 for frame)
;
; Note that we build a stack frame that's independent of the code and
; stack segments' "size" during execution. That way whether we enter
; with a 16bit or 32bit stack, the arguments frame is exacely the same.
;

MakeTrapFrame:

        mov      eax,esp
        push     ecx
        push     edx
        push     ebx
        push     eax  ; (eax)=(esp)
        push     ebp
        push     esi
        push     edi

        mov      ax,ds
        push     ax
        mov      ax,es
        push     ax
        mov      ax,fs
        push     ax
        mov      ax,gs
        push     ax
        mov      ax,ss
        push     ax
        mov      eax,cr3
        push     eax
        mov      eax,cr2
        push     eax
        mov      eax,cr0
        push     eax
        mov      eax,dr6
        push     eax
        str      ax
        push     ax
;
; Clear out debug register signals
;

        xor      eax,eax
        mov      dr6,eax

;
; Get a known good data segment
;
        mov      ax,SuDataSelector
        mov      ds,ax
;
; Save system registers
;
        mov      bx,offset DGROUP:_GDTregister
        sgdt     fword ptr [bx]
        mov      bx,offset DGROUP:_IDTregister
        sidt     fword ptr [bx]
;
; Is the exception frame on a 16bit or 32bit stack?
;
        mov      ax,ss
        cmp      ax,KeDataSelector
        je       Trap32
        cmp      ax,DbDataSelector
        jne      mtf8
;
; Most likely we took a trap while initializing the 386 kernel debugger
; So we've got a 16bit stack that isn't ours. We need to move
; the stack frame onto the SU module's stack.

        jmp      Trap16

mtf8:
;
; Frame on a our 16bit stack so just call the trap dump routine
;
        mov      bx,offset DGROUP:SaveSP
        mov      [bx],sp

        call     _TrapHandler

;
; Get rid of the junk we saved just to display
;
        pop      eax      ; get rid of ebp pushed for other returns
        add      sp,ExceptionFrame.Fgs
;
; Reload the user's context and return to 16bit code
;
        pop      gs
        pop      fs
        pop      es
        pop      ds
        pop      edi
        pop      esi
        pop      ebp
        pop      eax
        pop      ebx
        pop      edx
        pop      ecx
        pop      eax      ; get rid of trap #
        pop      eax      ; get original eax
        add      esp,4    ; get rid of error code
;
; Pop IRET frame and return to where the trap occured
;
        OPSIZE
        iret





Trap32:
;
; The exception frame is on a 32bit stack so we must setup a 16bit
; stack and then move the exception frame on to it before calling
; the trap dump routine.
;

        mov      ebx,esp
;
; Setup a known good stack
;
        mov      ax,SuDataSelector
        mov      ss,ax
        mov      sp,EXPORT_STACK
;
; Copy the exception frame to the new stack
;

        mov     ecx, (size ExceptionFrame)/2 ; # of words in frame
        mov     esi,ebx                 ; (esi) = offset of argument frame
        push    KeDataSelector          ; (ax) = Flat 32bit segment selector
        pop     ds                      ; (ds:esi) points to argument frame
        push    ss                      ;
        pop     es                      ; (es) = 16bit stack selector
        sub     sp, size ExceptionFrame ; make room for the arguments
        xor     edi,edi                 ; clear out upper 16bits of edi
        mov     di,sp                   ; (es:edi) points to top of stack
;
; Loop and copy a word at a time.
;
msf1:
        mov     ax,[esi]
        mov     es:[edi],ax
        add     esi,2
        add     edi,2
        loop    msf1

        push    es                      ;
        pop     ds                      ; put 16bit selector back into ds

;
; Now call the general purpose exception handler
;
        push     ebx                    ; save esp for return
;
;  Save SP in order to restore the stack in case we
;  take a fault in the debugger
;
        mov      bx,offset DGROUP:SaveSP
        mov      [bx],sp

        call     _TrapHandler

IFDEF  DEBUG0
public DebugReturn
DebugReturn:
ENDIF ;DEBUG
        pop      ebx
;
; We may have changed the flags while in the debugger. Copy the
; new eflag to the iret frame. After we restore the original stack
; pointers.
;

        mov      bp,sp
        mov      ecx,[bp].Feflags

        mov      ax,KeDataSelector
        mov      ss,ax
        mov      esp,ebx

        mov      [esp].Feflags,ecx
;
; Get rid of the junk we saved just to display
;
        add      esp,ExceptionFrame.Fgs
;
; Reload the user's context
;
        pop      gs
        pop      fs
        pop      es
        pop      ds
        pop      edi
        pop      esi
        pop      ebp
        pop      eax
        pop      ebx
        pop      edx
        pop      ecx
        pop      eax      ; get rid of trap #
        pop      eax      ; get original eax
        add      esp,4    ; get rid of error code
;
; Pop IRET frame and return to where the trap occured
;
        OPSIZE
        iret


Trap16:

; The exception frame is on a 16bit stack that isn't ours. So we must
; move the exception frame on to the SU module's stack before calling
; the trap dump routine.
;

        mov      ebx,esp
;
; Setup a known good stack
;
        mov      ax,SuDataSelector
        mov      ss,ax
        mov      sp,EXPORT_STACK
;
; Copy the exception frame to the new stack
;

        mov      ecx, (size ExceptionFrame)/2
        mov      si,bx                 ; (esi) = offset of argument frame
        push     DbDataSelector          ;
        pop      ds                      ; (ds:esi) points to argument frame
        push     ss                      ;
        pop      es                      ; (es) = 16bit stack selector
        sub      sp, size ExceptionFrame ; make room for the arguments
        mov      di,sp                   ; (es:edi) points to top of stack
;
; Loop and copy a word at a time.
;
Trap16_10:
        mov      ax,[si]
        mov      es:[di],ax
        add      si,2
        add      di,2
        loop     Trap16_10

        push     es                      ;
        pop      ds                      ; put 16bit selector back into ds

;
; Now call the general purpose exception handler
;

        push     ebx                    ; save (original esp) for return
;
;  Save SP in order to restore the stack in case we
;  take a fault in the debugger
;
        mov      bx,offset DGROUP:SaveSP
        mov      [bx],sp

        call     _TrapHandler

IFDEF  DEBUG0
public Debug16Return
Debug16Return:
ENDIF ;DEBUG
        pop      ebx
;
; We may have changed the flags while in the debugger. Copy the
; new eflag to the iret frame. After we restore the original stack
; pointers.
;

        mov      bp,sp
        mov      ecx,dword ptr [bp].Feflags

        mov      ax,DbDataSelector
        mov      ss,ax
        mov      esp,ebx

        mov      dword ptr ss:[bx].Feflags,ecx
;
; Get rid of the junk we saved just to display
;
        add      sp,ExceptionFrame.Fgs
;
; Reload the user's context
;
        pop      gs
        pop      fs
        pop      es
        pop      ds
        pop      edi
        pop      esi
        pop      ebp
        pop      eax
        pop      ebx
        pop      edx
        pop      ecx
        pop      eax      ; get rid of trap #
        pop      eax      ; get original eax
        add      esp,4    ; get rid of error code
;
; Pop IRET frame and return to where the trap occured
;
        OPSIZE
        iret



_TEXT   ends
        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\trapdump.c ===
/*++

Copyright (c) 1990  Microsoft Corporation


Module Name:

    trap.c

Author:

    Thomas Parslow   [TomP]  Mar-01-90


Abstract:

    General purpose trap handler for 80386 boot loader. When built in
    debugger is present, output is redirected to the com port. When no
    debugger is present, output goes to the display.


--*/

#include "su.h"

extern
USHORT
InDebugger;

extern
UCHAR
GDTregister;

extern
UCHAR
IDTregister;

extern
VOID
OutPort(
    USHORT
    );

extern
USHORT
InPort(
    VOID
    );

extern
VOID
ReEnterDebugger(
    VOID
    );

extern
USHORT
TssKernel;

extern
USHORT
Redirect;

extern
VOID RealMode(
    VOID
    );

VOID
TrapHandler(
    IN ULONG,
    IN USHORT
    );

VOID
DumpProcessorContext(
    VOID
    );

VOID
DumpSystemRegisters(
    VOID
    );

VOID
DumpCommonRegisters(
    VOID
    );

VOID
DisplayFlags(
    ULONG f
    );


VOID
DumpTSS(
    VOID
    );


ULONG
GetAddress(
    VOID
    );

VOID
GetNumber(
    PCHAR cp
    );

USHORT
GetChar(
    VOID
    );

VOID
DumpAddress(
    ULONG
    );

#define PG_FAULT_MSG    " =================== PAGE FAULT ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE FAULT ================================ \n\n"
#define GP_FAULT_MSG    " ============== GENERAL PROTECTION FAULT ======================== \n\n"
#define STK_OVERRUN_MSG " ===== STACK SEGMENT OVERRUN or NOT PRESENT FAULT =============== \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPTION ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define ishex(x)  ( ( x >= '0' && x <= '9') || (x >= 'A' && x <= 'F') || (x >= 'a' && x <= 'f') )


//
// Global Trap Frame Pointer
//

PTF TrapFrame=0;


VOID
TrapHandler(
    IN ULONG Padding,
    IN USHORT TF_base
    )
/*++

Routine Description:

    Prints minimal trap information

Arguments:


    386 Trap Frame on Stack

Environment:

    16-bit protect mode only.


--*/

{
    //
    // Initialize global trap frame pointer and print trap number
    //

    TrapFrame = (PTF)&TF_base;

    //
    // Fix esp to point to where it pointed before trap
    //

    TrapFrame->Fesp += 24;

    BlPrint("\n TRAP %lx ",TrapFrame->TrapNum);

    //
    // Print the trap specific header and display processor context
    //

    switch(TrapFrame->TrapNum) {

        case 1:
        case 3:
            puts( DEBUG_EXCEPTION );
            DumpCommonRegisters();
            break;

        case 8:
            puts( DBL_FAULT_MSG );
            DumpTSS();
            break;

        case 12:
            puts( STK_OVERRUN_MSG );
            DumpProcessorContext();
            break;

        case 13:
            puts( GP_FAULT_MSG );
            DumpProcessorContext();
            break;

        case 14:
            puts( PG_FAULT_MSG );
            BlPrint("** At linear address %lx\n",TrapFrame->Fcr2);
            DumpProcessorContext();
            break;

        default :
            puts( EX_FAULT_MSG );
            DumpProcessorContext();
            break;
    }

    RealMode();
    while (1); //**** WAITFOREVER *** //


}


VOID
DumpProcessorContext(
    VOID
    )
/*++

Routine Description:

    Dumps all the processors registers. Called whenever a trap or fault
    occurs.

Arguments:

    None

Returns:

    Nothing

--*/
{
    DumpSystemRegisters();
    DumpCommonRegisters();
}

VOID
DumpSystemRegisters(
    VOID
    )
/*++

Routine Description:

    Dumps (writes to the display or com poirt) the x86 processor control
    registers only. Does not dump the common registers (see
    DumpCommonRegisters)

Arguments:

    None

Returns:

    Nothing


--*/
{
    BlPrint("\n tr=%x  cr0=%lx  cr2=%lx  cr3=%lx\n",
            TrapFrame->Ftr,TrapFrame->Fcr0,TrapFrame->Fcr2,TrapFrame->Fcr3);
    BlPrint(" gdt limit=%x  base=%lx    idt limit=%x  base=%lx\n",
          *(PUSHORT)&GDTregister,*(PULONG)(&GDTregister + 2),
          *(PUSHORT)&IDTregister,*(PULONG)(&IDTregister + 2));
}



VOID
DumpCommonRegisters(
    VOID
    )
/*++

Routine Description:

    Dumps (writes to the display or com poirt) the x86 processor
    commond registers only.

Arguments:

    None

Returns:

    Nothing


--*/
{
    USHORT err;

    //
    // Is the error code valid or just a padding dword
    //

    if ((TrapFrame->TrapNum == 8) || (TrapFrame->TrapNum >= 10 && TrapFrame->TrapNum <= 14) )
        err = (USHORT)TrapFrame->Error;
    else
        err = 0;

    //
    // Display the processor's common registers
    //

    BlPrint("\n cs:eip=%x:%lx  ss:esp=%x:%lx  errcode=%x\n",
        (USHORT)(TrapFrame->Fcs & 0xffff),TrapFrame->Feip,(USHORT)TrapFrame->Fss,TrapFrame->Fesp,err);
    DisplayFlags(TrapFrame->Feflags);
    BlPrint(" eax=%lx  ebx=%lx  ecx=%lx  edx=%lx",TrapFrame->Feax,TrapFrame->Febx,TrapFrame->Fecx,TrapFrame->Fedx);
    BlPrint(" ds=%x  es=%x\n",TrapFrame->Fds,TrapFrame->Fes);
    BlPrint(" edi=%lx  esi=%lx  ebp=%lx  cr0=%lx",TrapFrame->Fedi,TrapFrame->Fesi,TrapFrame->Febp,TrapFrame->Fcr0);
    BlPrint(" fs=%x  gs=%x\n",TrapFrame->Ffs,TrapFrame->Fgs);

}


VOID
DisplayFlags(
    ULONG f
    )
/*++

Routine Description:

    Writes the value of the key flags in the flags register to
    the display or com port.

Arguments:

    f - the 32bit flags word

Returns:

    Nothing

--*/
{

    BlPrint(" flags=%lx  ",f);
    if (f & FLAG_CF) puts("Cy "); else puts("NoCy ");
    if (f & FLAG_ZF) puts("Zr "); else puts("NoZr ");
    if (f & FLAG_IE) puts("IntEn"); else puts("IntDis ");
    if (f & FLAG_DF) puts("Up "); else puts("Down ");
    if (f & FLAG_TF) puts("TrapEn \n"); else puts("TrapDis \n");

}



VOID
DumpTSS(
    VOID
    )
/*++

Routine Description:

    Writes the contents of the TSS to the display or com port when
    called after a double fault.

Arguments:

    None

Returns:

    Nothing

--*/
{

    PTSS_FRAME pTss;

//  FP_SEG(Fp) = Fcs;
//  FP_OFF(Fp) = Fip;

    pTss = (PTSS_FRAME) &TssKernel;

    //
    //  Dump the outgoing TSS
    //

    BlPrint("Link %x\n",pTss->Link);
    BlPrint("Esp0 %x\n",pTss->Esp0);
    BlPrint("SS0  %x\n",pTss->SS0);
    BlPrint("Esp1 %lx\n",pTss->Esp1);
    BlPrint("Cr3  %lx\n",pTss->Cr3);
    BlPrint("Eip  %lx\n",pTss->Eip);
    BlPrint("Eflg %lx\n",pTss->Eflags);
    BlPrint("Eax  %lx\n",pTss->Eax);
    BlPrint("Ebx  %lx\n",pTss->Ebx);
    BlPrint("Ecx  %lx\n",pTss->Ecx);
    BlPrint("Edx  %lx\n",pTss->Edx);
    BlPrint("Esp  %lx\n",pTss->Esp);
    BlPrint("Ebp  %lx\n",pTss->Ebp);
    BlPrint("Esi  %lx\n",pTss->Esi);
    BlPrint("Edi  %lx\n",pTss->Edi);
    BlPrint("ES   %x\n",pTss->ES);
    BlPrint("CS   %x\n",pTss->CS);
    BlPrint("SS   %x\n",pTss->SS);
    BlPrint("DS   %x\n",pTss->DS);
    BlPrint("FS   %x\n",pTss->FS);
    BlPrint("GS   %x\n",pTss->GS);
    BlPrint("Ldt  %x\n",pTss->Ldt);
    RealMode();
    while(1);
}

// END OF FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\br\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"O Windows NT encontrou apenas %dKB de memria convencional. So necessrios\n"  \
"512KB de memria convencional para executar o Windows NT. Voc talvez tenha\n"  \
"que atualizar seu computador ou executar o programa de configurao\n"          \
"fornecido pelo fabricante.\n"

#define SU_NO_EXTENDED_MEMORY \
"O Windows NT no encontrou memria estendida suficiente. So necessrios\n"     \
"7MB de memria estendida para executar o Windows NT. Voc talvez tenha\n"       \
"que atualizar seu computador ou executar o programa de configurao\n"          \
"fornecido pelo fabricante.\n"                                                   \
"\n\nMapa da memria:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR est corrompido. O sistema no pode ser reiniciado."


#define PG_FAULT_MSG    " ======================== ERRO DE PGINA ======================== \n\n"
#define DBL_FAULT_MSG   " ========================= FALHA DUPLA ========================== \n\n"
#define GP_FAULT_MSG    " ==================== FALHA DE PROTEO GERAL =================== \n\n"
#define STK_OVERRUN_MSG " === SEGMENTO DA PILHA AUSENTE OU FALHA DE SATURAO DO MESMO === \n\n"
#define EX_FAULT_MSG    " =========================== EXCEO ============================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** No endereo linear %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\cs\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Systm Windows NT nael pouze %d kB doln pamti. Ke sputn systmu\n"   \
"je poteba 512 kB i vce doln pamti. Asi budete muset inovovat dan\n"  \
"pota, nebo spustit konfiguran program, kter byl dodn vrobcem.\n"

#define SU_NO_EXTENDED_MEMORY \
"Systm Windows NT nenael dost rozen pamti. Systm Windows NT\n"     \
"potebuje ke sputn 7 MB rozen pamti. Asi budete muset inovovat\n"  \
"pota, nebo spustit konfiguran program, kter byl dodn vrobcem.\n"   \
"\n\nMapa pamti:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR je pokozen. Systm nelze nastartovat."

#define PG_FAULT_MSG    " ================== CHYBA STRNKY =============================== \n\n"
#define DBL_FAULT_MSG   " ==================== DVOJCHYBA ================================= \n\n"
#define GP_FAULT_MSG    " ============== VEOBECN CHYBA OCHRANY ========================= \n\n"
#define STK_OVERRUN_MSG " ====== CHYBA: SEGMENT ZSOBNKU PEKRYT i CHYB =============== \n\n"
#define EX_FAULT_MSG    " ====================== VYJMKA ================================= \n\n"
#define DEBUG_EXCEPTION  "\nPAST DEBUG "
#define PG_FAULT_ADDRESS "** Na linern adrese %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\fr\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT a trouv seulement %d Ko de mmoire basse. 512 Ko\n"     \
"de mmoire basse sont requis pour excuter Windows NT. La mise \n"   \
"niveau de votre ordinateur ou l'excution d'un programme de configuration\n"   \
"fourni par votre fabriquant est peut-tre ncessaire.\n"      

#define SU_NO_EXTENDED_MEMORY \
"Windows NT n'a pas trouv suffisamment de mmoire tendue. 7 Mo\n"     \
"de mmoire tendue sont requis pour excuter Windows NT. La mise \n"   \
"niveau de votre ordinateur ou l'excution d'un programme de configuration\n"   \
"fourni par votre fabriquant est peut-tre ncessaire.\n"  \
"\n\nCarte de la mmoire :\n"

#define SU_NTLDR_CORRUPT \
"NTLDR est endommag. Le systme ne peut pas dmarrer."

#define PG_FAULT_MSG    " ================= PANNE DE PAGE ================================ \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE PANNE ================================ \n\n"
#define GP_FAULT_MSG    " =========== PANNE DE PROTECTION GENERALE ======================= \n\n"
#define STK_OVERRUN_MSG " === SEGMENT STACK SUREXECUTE ou PANNE NON PRESENTE ============= \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPTION ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBOGUER LES PAQUETS "
#define PG_FAULT_ADDRESS "** A l'adresse linaire %lx\n"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\es\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT ha encontrado slo %dKB de memoria baja. Se requieren 512 KB\n"  \
"de memoria baja para ejecutar Windows NT. Puede ser necesario actualizar \n"      \
"el equipo o ejecutar un programa de configuracin suministrado\n"   \
"por el fabricante."

#define SU_NO_EXTENDED_MEMORY \
"Windows NT no ha encontrado suficiente memoria extendida. Se requieren 7 MB \n"       \
"de memoria extendida para ejecutar Windows NT. Puede ser necesario \n"     \
"actualizar el equipo o ejecutar un programa de configuracin \n"   \
"suministrado por el fabricante de hardware. \n"   \
"\n\nMapa de memoria:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR est daado.  No se puede iniciar el sistema."

#define PG_FAULT_MSG    " =================== ERROR DE PGINA ======================= \n\n"
#define DBL_FAULT_MSG   " ================== ERROR DOBLE ================================ \n\n"
#define GP_FAULT_MSG    " ============== ERROR DE PROTECCIN GENERAL=================== \n\n"
#define STK_OVERRUN_MSG " ===== DESBORDAMIENTO DEL SEGMENTO DE PILA O ERROR DE AUSENCIA == \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPCIN ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** En direccin lineal %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\hu\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"A Windows 2000  %dK hagyomnyos memrit tallt. A Windows 2000  futtatshoz\n"  \
"legalbb 512k hagyomnyos memrira van szksg. Ellenrizze a szmtgp \n"  \
"hardver konfigurcijt, s szksg esetn szerezzen be tovbbi memrit.\n"

#define SU_NO_EXTENDED_MEMORY \
"A Windows 2000 nem tallt elegend kiterjesztett memrit. A Windows 2000\n"   \
"futtatshoz legalbb 7 megabjt kiterjesztett memrira van szksg. \n"   \
"Ellenrizze a szmtgp konfigurcijt, s szksg esetn szerezzen be\n" \
"tovbbi memrit.\n" \
"\n\nMemriatrkp:\n"

#define SU_NTLDR_CORRUPT \
"Az NTLDR hibs vagy srlt. A rendszer nem indthat."

#define PG_FAULT_MSG    " ======================= LAPHIBA ============================== \n\n"
#define DBL_FAULT_MSG   " =================== DUPLAHIBA FAULT ========================== \n\n"
#define GP_FAULT_MSG    " ============== MEMRIA vagy I/O VDELMI HIBA ================= \n\n"
#define STK_OVERRUN_MSG " ======= VEREMTLCSORDUS vagy HINYZ OBJEKTUM HIBA ========== \n\n"
#define EX_FAULT_MSG    " ======================= KIVTEL ============================== \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** cm %lx\n"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\tr\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT has found only %dK of low memory.  512k of low memory\n"  \
"is required to run Windows NT.  You may need to upgrade your\n"      \
"computer or run a configuration program provided by the manufacturer.\n"

#define SU_NO_EXTENDED_MEMORY \
"Windows NT has not found enough extended memory.  7Mb of extended\n"       \
"memory is required to run Windows NT.  You may need to upgrade your\n"     \
"computer or run a configuration program provided by the manufacturer.\n"   \
"\n\nMemory Map:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR is corrupt.  The system cannot boot."

#define PG_FAULT_MSG    " =================== PAGE FAULT ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE FAULT ================================ \n\n"
#define GP_FAULT_MSG    " ============== GENERAL PROTECTION FAULT ======================== \n\n"
#define STK_OVERRUN_MSG " ===== STACK SEGMENT OVERRUN or NOT PRESENT FAULT =============== \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPTION ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** At linear address %lx\n"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\ger\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT hat nur %d KB konventionellen Speicherplatz gefunden. \n"  \
"Zur Ausfhrung von Windows NT werden 512 KB konventioneller \n"       \
"Speicherplatz bentigt. Sie mssen evtl. Ihren Computer aufrsten \n" \
"oder ein Konfigurationsprogramm des Herstellers ausfhren.\n"


#define SU_NO_EXTENDED_MEMORY \
"Windows NT hat nicht gengend Erweiterungsspeicher gefunden. Zur\n"  \
"Ausfhrung von Windows NT werden 7 MB Erweiterungsspeicher \n"       \
"bentigt. Sie mssen evtl. Ihren Computer aufrsten oder ein \n"     \
"Konfigurationsprogramm des Herstellers ausfhren.\n"                 \
"\n\nSpeichertabelle:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR ist beschdigt. Das System kann nicht gestartet werden."


#define PG_FAULT_MSG    " ================== SEITENFEHLER ================================ \n\n"
#define DBL_FAULT_MSG   " ================ DOPPELTER FEHLER ============================== \n\n"
#define GP_FAULT_MSG    " =========== ALLGEMEINE SCHUTZVERLETZUNG ======================== \n\n"
#define STK_OVERRUN_MSG " = STAPELSPEICHER-SEGMENTBERLAUF oder NICHT VORHANDENER FEHLER = \n\n"
#define EX_FAULT_MSG    " ====================== AUSNAHME ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** Bei linearer Adresse %lx\n"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\usa\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT has found only %dK of low memory.  512k of low memory\n"  \
"is required to run Windows NT.  You may need to upgrade your\n"      \
"computer or run a configuration program provided by the manufacturer.\n"

#define SU_NO_EXTENDED_MEMORY \
"Windows NT has not found enough extended memory.  7Mb of extended\n"       \
"memory is required to run Windows NT.  You may need to upgrade your\n"     \
"computer or run a configuration program provided by the manufacturer.\n"   \
"\n\nMemory Map:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR is corrupt.  The system cannot boot."

#define PG_FAULT_MSG    " =================== PAGE FAULT ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE FAULT ================================ \n\n"
#define GP_FAULT_MSG    " ============== GENERAL PROTECTION FAULT ======================== \n\n"
#define STK_OVERRUN_MSG " ===== STACK SEGMENT OVERRUN or NOT PRESENT FAULT =============== \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPTION ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** At linear address %lx\n"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\it\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\nl\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT heeft slechts %d kB aan laag geheugen aangetroffen.\n"    \
"Er is 512 kB aan laag geheugen voor Windows NT nodig. Mogelijk\n"    \
"dient u de geheugencapaciteit van de computer uit te breiden\n"      \
"of een configuratieprogramma van de fabrikant te starten.\n"         \

#define SU_NO_EXTENDED_MEMORY \
"Windows NT heeft onvoldoende extended memory aangetroffen. Er is 7 MB\n"   \
"aan extended memory voor Windows NT nodig. Mogelijk dient u de geheugen-\n"\
"capaciteit van de computer uit te breiden of een configuratieprogramma\n"  \
"van de fabrikant te starten.\n"                                            \
"\n\nGeheugentoewijzing:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR is beschadigd. Het systeem kan niet worden gestart."

#define PG_FAULT_MSG    " =================== PAGINAFOUT ================================= \n\n"
#define DBL_FAULT_MSG	" ================== DUBBELE FOUT ================================ \n\n"
#define GP_FAULT_MSG	" ============== ALGEMENE BESCHERMINGSFOUT ======================= \n\n"
#define STK_OVERRUN_MSG " ===== STACK-SEGMENT-OVERLOOP of NIET-AANWEZIG-FOUT ============= \n\n"
#define EX_FAULT_MSG	" ===================== UITZONDERING ============================= \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** Op lineair adres %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\it\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Sono stati rilevati solo %d Kb di memoria convenzionale. Per eseguire\n"	\
"Windows NT sono necessari almeno 512 Kb. Aggiornare il computer o \n"	   \
"eseguire un programma di configurazione fornito dal costruttore.\n"

#define SU_NO_EXTENDED_MEMORY \
"Memoria estesa insufficiente. Per eseguire Windows NT sono necessari\n"	     \
"almeno 7 Mb di memoria estesa. Aggiornare il computer o eseguire\n"	 \
"un programma di configurazione fornito dal costruttore.\n"   \
"\n\nMappa della memoria:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR danneggiato. Impossibile avviare il sistema."

#define PG_FAULT_MSG    " =================== PAGE FAULT ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE FAULT ================================ \n\n"
#define GP_FAULT_MSG    " ============== ERRORE DI PROTEZIONE GENERALE =================== \n\n"
#define STK_OVERRUN_MSG " ===== OVERRUN DI STACK DEL SEGMENTO o FAULT DI ASSENZA ========= \n\n"
#define EX_FAULT_MSG    " ===================== ERRORE DI EXCEPTION ====================== \n\n"
#define DEBUG_EXCEPTION "\nTRAP DI DEBUG "
#define PG_FAULT_ADDRESS "** All'indirizzo lineare %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\pl\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"System Windows NT wykry tylko %d KB pamici niskiej. Do uruchomienia\n"  \
"systemu Windows NT wymagane jest 512 KB. Musisz rozbudowa komputer\n"      \
"lub uruchomi program konfiguracyjny dostarczony przez producenta.\n"

#define SU_NO_EXTENDED_MEMORY \
"System Windows NT nie znalaz wystarczajcej iloci pamici typu Extended.\n"       \
"Do uruchomienia systemu Windows NT wymagane jest 7 MB pamici Extended.\n"     \
"Musisz rozbudowa komputer lub uruchomi program konfiguracyjny dostarczony\n"   \
"przez producenta.\n\nMapa pamici:\n"

#define SU_NTLDR_CORRUPT \
"Plik NTLDR jest uszkodzony. System nie zostanie uruchomiony."

#define PG_FAULT_MSG    " =============== BD STRONY == (PAGE FAULT) ==================== \n\n"
#define DBL_FAULT_MSG   " =========== BD PODWJNY == (DOUBLE FAULT) ==================== \n\n"
#define GP_FAULT_MSG    " ======== OGLNY BD OCHRONY == (GENERAL PROTECTION FAULT) ===== \n\n"
#define STK_OVERRUN_MSG " ====== BD PRZEPENIENIA SEGMENTU STOSU lub NIEOBECNOCI ====== \n\n"
#define EX_FAULT_MSG    " =================== WYJTEK == (EXCEPTION) ===================== \n\n"
#define DEBUG_EXCEPTION "\nPUAPKA DEBUGOWANIA "
#define PG_FAULT_ADDRESS "** Pod adresem liniowym %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\no\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\nl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\pl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\pt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\psu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\ru\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\sv\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\tr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\pt\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"O Windows NT detectou apenas %dK de memria baixa.  So necessrios 512K\n"  \
"de memria baixa para executar o Windows NT. Poder ter de actualizar\n"      \
"o computador ou executar um prog. de config. fornecido pelo fabricante.\n"

#define SU_NO_EXTENDED_MEMORY \
"O Windows NT no detectou memria de extenso suficiente. So necessrios\n"       \
"7Mb de memria de extenso para o Windows NT. Poder ter de actualizar\n"     \
"o computador ou executar um prog. de config. fornecido pelo fabricante.\n"   \
"\n\nMapa de memria:\n"

#define SU_NTLDR_CORRUPT \
"O NTLDR est danificado. O sistema no pode arrancar."

#define PG_FAULT_MSG    " =================== FALHA DE PGINA============================= \n\n"
#define DBL_FAULT_MSG   " ================== FALHA DUPLA ================================= \n\n"
#define GP_FAULT_MSG    " ============== FALHA GERAL DE PROTECO ======================== \n\n"
#define STK_OVERRUN_MSG " === SOBRE-EXECUO DO SEGMENTO DE PILHA ou FALHA DE AUSNCIA === \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPO ================================= \n\n"
#define DEBUG_EXCEPTION "\nInterrupo de depurao "
#define PG_FAULT_ADDRESS "** No endereo linear  %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\tst\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\ru\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT 㦨 ⮫쪮 %d  筮 . \n"                  \
" ᪠ Windows NT ॡ 512  筮 . \n"             \
" ॡ  ⮣    \n"          \
"ணࠬ ன, ⠢塞 ⮢⥫. \n"

#define SU_NO_EXTENDED_MEMORY \
"Windows NT  㦨 筮 ꥬ ⥫쭮 . \n"  \
" ᪠ Windows NT 室 7  ⥫쭮 . \n"        \
" ॡ  ⮣    \n"           \
"ணࠬ ன, ⠢塞 ⮢⥫. \n"                     \
"\n\nᯮ짮 :\n"

#define SU_NTLDR_CORRUPT \
"NTLDR ᯮ祭.   㧨 ⥬."

#define PG_FAULT_MSG    " ===================   ============================ \n\n"
#define DBL_FAULT_MSG   " ====================   ============================ \n\n"
#define GP_FAULT_MSG    " =================    ========================== \n\n"
#define STK_OVERRUN_MSG " =====       ======== \n\n"
#define EX_FAULT_MSG    " =====================  =============================== \n\n"
#define DEBUG_EXCEPTION "\n誠 DEBUG "
#define PG_FAULT_ADDRESS "**    %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\startup\i386\sv\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT hittade bara %d kB lgt minne. 512 kB lgt minne\n"  \
"krvs fr att kra Windows NT. Du behver kanske uppgradera\n"      \
"datorn eller kra ett konfigurationsprogram frn terfrsljaren.\n"

#define SU_NO_EXTENDED_MEMORY \
"Inte tillrckligt med utkat minne fr att starta Windows NT. 7 MB utkat\n"       \
"minne krvs fr att kra Windows NT. Du behver kanske uppgradera\n"      \
"datorn eller kra ett konfigurationsprogram frn terfsljaren.\n"   \
"\n\nInformation om minne:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR r skadad. Datorn kan inte startas."

#define PG_FAULT_MSG    " =================== SIDFEL ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DUBBELFEL ================================ \n\n"
#define GP_FAULT_MSG    " ============== ALLMNNT SKERHETSFEL ======================= \n\n"
#define STK_OVERRUN_MSG " ===== STACKSEGMENTVERKRNING ELLER ICKE-TILLGNGLIG =============== \n\n"
#define EX_FAULT_MSG    " ===================== UNDANTAG ================================ \n\n"
#define DEBUG_EXCEPTION "\nFELSKNINGSFLLA "
#define PG_FAULT_ADDRESS "** Vid linjr adress %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\tftplib\precomp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Boot loader TFTP header file.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996

Revision History:

Notes:

--*/

#include <bldr.h>
#include <netboot.h>
#include <netfs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\tftplib\i386\xsum.asm ===
include xsum.x86
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\tftplib\i386\rom.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rom.c

Abstract:

    Boot loader ROM routines.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#include <bldrx86.h>

#define PhysToSeg(x)    (USHORT)((ULONG)(x) >> 4) & 0xffff
#define PhysToOff(x)    (USHORT)((ULONG)(x) & 0x0f)

#include <pxe_cmn.h>
#include <pxe_api.h>
#include <tftp_api.h>
#include <udp_api.h>
#include <undi_api.h>
#include <dhcp.h>
#include <pxe.h>

USHORT NetUnicastUdpDestinationPort = 0;

#if 0
USHORT NetMulticastUdpDestinationPort;
ULONG NetMulticastUdpDestinationAddress;
USHORT NetMulticastUdpSourcePort;
ULONG NetMulticastUdpSourceAddress;
#endif

#if 0 && DBG
#include <stdio.h>
VOID
RomDumpRawData (
    IN PUCHAR DataStart,
    IN ULONG DataLength,
    IN ULONG Offset
    );
ULONG RomMaxDumpLength = 64;
#endif


#if 0

//
// chuckl: Don't do this. We added it as part of a solution a problem
// with DEC cards and the boot floppy. We disabled broadcasts in
// startrom\i386\main.c so that the card wouldn't overflow and lock up,
// but we need to have broadcasts enabled in case the server needs to
// ARP us. The purpose of this routine is to enable/disable broadcasts
// during the receive loop, but that seems to put Compaq cards to sleep.
// So we need to leave broadcasts enabled all the time. The DEC card
// problem will have to be fixed another way.
//

VOID
RomSetBroadcastStatus(
    BOOLEAN Enable
    )
{
    t_PXENV_UNDI_SET_PACKET_FILTER UndiSetPF;
    USHORT status;

    UndiSetPF.Status = 0;
    if (Enable) {
        UndiSetPF.filter = FLTR_DIRECTED | FLTR_BRDCST;
    } else {
        UndiSetPF.filter = FLTR_DIRECTED;
    }
    status = NETPC_ROM_SERVICES( PXENV_UNDI_SET_PACKET_FILTER, &UndiSetPF );

    if ((status != 0) || (UndiSetPF.Status != 0)) {
        DPRINT( ERROR, ("RomSetBroadcastStatus: set packet filter failed %lx, %lx\n", status, UndiSetPF.Status ));
    }
}
#endif

VOID
RomSetReceiveStatus (
    IN USHORT UnicastUdpDestinationPort
#if 0
    ,
    IN USHORT MulticastUdpDestinationPort,
    IN ULONG MulticastUdpDestinationAddress,
    IN USHORT MulticastUdpSourcePort,
    IN ULONG MulticastUdpSourceAddress
#endif
    )
{
    USHORT status;
    PUCHAR multicastAddress;
    union {
        t_PXENV_UDP_OPEN UdpOpen;
        t_PXENV_UNDI_SHUTDOWN UndiShutdown;
    } command;

    if ( UnicastUdpDestinationPort != 0 ) {

        //
        // If we haven't opened UDP in the ROM yet, do so now.
        //

        if ( NetUnicastUdpDestinationPort == 0 ) {
            command.UdpOpen.Status = 0;
            *(UINT32 *)command.UdpOpen.SrcIp = 0;
            status = NETPC_ROM_SERVICES( PXENV_UDP_OPEN, &command );
            if ( status != 0 ) {
                DPRINT( ERROR, ("RomSetReceiveStatus: error %d from UDP_OPEN\n", status) );
            }
        }
        NetUnicastUdpDestinationPort = UnicastUdpDestinationPort;

#if 0
        NetMulticastUdpDestinationPort = MulticastUdpDestinationPort;
        NetMulticastUdpDestinationAddress = MulticastUdpDestinationAddress;
        NetMulticastUdpSourceAddress = MulticastUdpSourceAddress;
        NetMulticastUdpSourceAddress = MulticastUdpSourceAddress;
#endif

    } else {

        //
        // This is a loader shutdown notification. Shut the NIC down.
        //
        // NB: This is irreversible!
        //
        
        command.UndiShutdown.Status = 0;
        status = NETPC_ROM_SERVICES( PXENV_UNDI_SHUTDOWN, &command );
    }

    return;

} // RomSetReceiveStatus


ULONG
RomSendUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG RemoteHost,
    IN USHORT RemotePort
    )
{
    USHORT status;
    t_PXENV_UDP_WRITE command;
    UCHAR tmpBuffer[MAXIMUM_TFTP_PACKET_LENGTH];

#if 0 && DBG
    DPRINT( SEND_RECEIVE, ("RomSendUdpPacket: sending this packet:\n") );
    IF_DEBUG(SEND_RECEIVE) {
        RomDumpRawData( Buffer, Length, 0 );
    }
#endif

    Length = ( MAXIMUM_TFTP_PACKET_LENGTH < Length ) ? MAXIMUM_TFTP_PACKET_LENGTH : Length;
    RtlCopyMemory( tmpBuffer, Buffer, Length );

    command.Status = 0;

    //
    // Determine whether we need to send via the gateway.
    //

    if ( (RemoteHost & NetLocalSubnetMask) == (NetLocalIpAddress & NetLocalSubnetMask) ) {
        *(UINT32 *)command.GatewayIp = 0;
    } else {
        *(UINT32 *)command.GatewayIp = NetGatewayIpAddress;
    }

    *(UINT32 *)command.DestIp = RemoteHost;
    command.DestPort = RemotePort;
    command.SrcPort = NetUnicastUdpDestinationPort;

    command.BufferSize = (USHORT)Length;
    command.BufferOffset = PhysToOff(tmpBuffer);
    command.BufferSegment = PhysToSeg(tmpBuffer);
    //DbgPrint( "UDP write pktaddr %lx = %x:%x\n", tmpBuffer, command.BufferSegment, command.BufferOffset );

    status = NETPC_ROM_SERVICES( PXENV_UDP_WRITE, &command );
    //DbgPrint( "UDP write status = %x\n", command.Status );

    if ( status == 0 ) {
        return Length;
    } else {
        return 0;
    }

} // RomSendUdpPacket


ULONG
RomReceiveUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Timeout,
    OUT PULONG RemoteHost,
    OUT PUSHORT RemotePort
    )
{
    USHORT status;
    t_PXENV_UDP_READ command;
    ULONG startTime;
    UCHAR tmpBuffer[MAXIMUM_TFTP_PACKET_LENGTH];

    //
    // Turn on broadcasts while in the receive loop, in case
    // the other end needs to ARP to find us.
    //

#if 0
    RomSetBroadcastStatus(TRUE);
#endif

    startTime = SysGetRelativeTime();
    if ( Timeout < 2 ) Timeout = 2;

    while ( (SysGetRelativeTime() - startTime) < Timeout ) {
    
        command.Status = 0;
    
        *(UINT32 *)command.SrcIp = 0;
        *(UINT32 *)command.DestIp = 0;
        command.SrcPort = 0;
        command.DestPort = 0;
    
        command.BufferSize = (USHORT)Length;
        command.BufferOffset = PhysToOff(tmpBuffer);
        command.BufferSegment = PhysToSeg(tmpBuffer);
        //DbgPrint( "UDP read pktaddr %lx = %x:%x\n", tmpBuffer, command.BufferSegment, command.BufferOffset );
    
        status = NETPC_ROM_SERVICES( PXENV_UDP_READ, &command );
    
        if ( *(UINT32 *)command.SrcIp == 0 ) {
            continue;
        }

        //DbgPrint( "UDP read status = %x, src ip/port = %d.%d.%d.%d/%d, length = %x\n", command.Status,
        //            command.SrcIp[0], command.SrcIp[1], command.SrcIp[2], command.SrcIp[3],
        //            SWAP_WORD(command.SrcPort), command.BufferSize );
        //DbgPrint( "  dest ip/port = %d.%d.%d.%d/%d\n", 
        //            command.DestIp[0], command.DestIp[1], command.DestIp[2], command.DestIp[3],
        //            SWAP_WORD(command.DestPort) );

#if 0
        if ( (command.DestIp[0] < 224) || (command.DestIp[0] > 239) ) {
#endif

            //
            // This is a directed IP packet.
            //

            if ( !COMPARE_IP_ADDRESSES(command.DestIp, &NetLocalIpAddress) ||
                     (command.DestPort != NetUnicastUdpDestinationPort)
               ) {
                // DPRINT( ERROR, ("  Directed UDP packet to wrong port\n") );
                continue;
            }

#if 0
        } else {

            //
            // This is a multicast IP packet.
            //

            if ( !COMPARE_IP_ADDRESSES(command.SrcIp, &NetMulticastUdpSourceAddress) ||
                 !COMPARE_IP_ADDRESSES(command.DestIp, &NetMulticastUdpDestinationAddress) ||
                 (command.SrcPort != NetMulticastUdpSourcePort) ||
                 (command.DestPort != NetMulticastUdpDestinationPort) ) {
                DPRINT( ERROR, ("  Multicast UDP packet with wrong source/destination\n") );
                continue;
            }
        }
#endif

        //
        // We want this packet.
        //

        goto packet_received;
    }

    //
    // Timeout.
    //

    DPRINT( SEND_RECEIVE, ("RomReceiveUdpPacket: timeout\n") );

#if 0
    RomSetBroadcastStatus(FALSE);   // turn off broadcast reception
#endif
    return 0;

packet_received:

    //
    // Packet received.
    //

    RtlCopyMemory( Buffer, tmpBuffer, command.BufferSize );

    *RemoteHost = *(UINT32 *)command.SrcIp;
    *RemotePort = command.SrcPort;

#if 0 && DBG
    if ( command.BufferSize != 0 ) {
        DPRINT( SEND_RECEIVE, ("RomReceiveUdpPacket: received this packet:\n") );
        IF_DEBUG(SEND_RECEIVE) {
            RomDumpRawData( Buffer, command.BufferSize, 0 );
        }
    }
#endif

#if 0
    RomSetBroadcastStatus(FALSE);   // turn off broadcast reception
#endif
    return command.BufferSize;

} // RomReceiveUdpPacket


ULONG
RomGetNicType (
    OUT t_PXENV_UNDI_GET_NIC_TYPE *NicType
    )
{
    return NETPC_ROM_SERVICES( PXENV_UNDI_GET_NIC_TYPE, NicType );
}

#if 0 && DBG
VOID
RomDumpRawData (
    IN PUCHAR DataStart,
    IN ULONG DataLength,
    IN ULONG Offset
    )

{
    ULONG lastByte;
    UCHAR lineBuffer[88];
    PUCHAR bufferPtr;

    if ( DataLength > RomMaxDumpLength ) {
        DataLength = RomMaxDumpLength;
    }

    for ( lastByte = Offset + DataLength; Offset < lastByte; Offset += 16 ) {

        ULONG i;

        bufferPtr = lineBuffer;

        sprintf( bufferPtr, "  %08x  %04x: ", &DataStart[Offset], Offset );
        bufferPtr += 18;

        for ( i = 0; i < 16 && Offset + i < lastByte; i++ ) {

            sprintf( bufferPtr, "%02x", (UCHAR)DataStart[Offset + i] & (UCHAR)0xFF );
            bufferPtr += 2;

            if ( i == 7 ) {
                *bufferPtr++ = '-';
            } else {
                *bufferPtr++ = ' ';
            }
        }

        //
        // Print enough spaces so that the ASCII display lines up.
        //

        for ( ; i < 16; i++ ) {
            *bufferPtr++ = ' ';
            *bufferPtr++ = ' ';
            *bufferPtr++ = ' ';
        }

        *bufferPtr++ = ' ';
        *bufferPtr++ = ' ';
        *bufferPtr++ = '*';

        for ( i = 0; i < 16 && Offset + i < lastByte; i++ ) {
            if ( isprint( DataStart[Offset + i] ) ) {
                *bufferPtr++ = (CCHAR)DataStart[Offset + i];
            } else {
                *bufferPtr++ = '.';
            }
        }

        *bufferPtr = 0;
        DbgPrint( "%s*\n", lineBuffer );
    }

    return;

} // RomDumpRawData
#endif // DBG


ARC_STATUS
RomMtftpReadFile (
    IN PUCHAR FileName,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG ServerIPAddress, // network byte order
    IN ULONG MCastIPAddress, // network byte order
    IN USHORT MCastCPort, // network byte order
    IN USHORT MCastSPort, // network byte order
    IN USHORT Timeout,
    IN USHORT Delay,
    OUT PULONG DownloadSize
    )
{
    USHORT status;
    t_PXENV_TFTP_READ_FILE tftp;
    t_PXENV_UDP_CLOSE udpclose;

    if (DownloadSize != NULL) {
        *DownloadSize = 0;
    }

    ASSERT(strlen(FileName) < 128);

    memset( &tftp, 0 , sizeof( tftp ) );

    strcpy(tftp.FileName, FileName);
    tftp.BufferSize = BufferLength;
    tftp.BufferOffset = (UINT32)Buffer; 

    if ( (ServerIPAddress & NetLocalSubnetMask) == (NetLocalIpAddress & NetLocalSubnetMask) ) {
        *((UINT32 *)tftp.GatewayIPAddress) = 0;
    } else {
        *((UINT32 *)tftp.GatewayIPAddress) = NetGatewayIpAddress;
    }

    *((UINT32 *)tftp.ServerIPAddress) = ServerIPAddress;
    *((UINT32 *)tftp.McastIPAddress) = MCastIPAddress;
    tftp.TFTPClntPort = MCastCPort;
    tftp.TFTPSrvPort = MCastSPort;
    tftp.TFTPOpenTimeOut = Timeout;
    tftp.TFTPReopenDelay = Delay;

    // make sure that any UDP sessions are already closed.
    status = NETPC_ROM_SERVICES( PXENV_UDP_CLOSE, &udpclose );

    status = NETPC_ROM_SERVICES( PXENV_TFTP_READ_FILE, &tftp );
    if (status != PXENV_EXIT_SUCCESS) {
        return EINVAL;
    }

    if (DownloadSize != NULL) {
        *DownloadSize = tftp.BufferSize;
    }

    return ESUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\tftplib\helper.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    helper.c

Abstract:

    Helper functions for the loader.

Author:

    Adam Barr (adamba)              Aug 29, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    adamba      08-29-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#include <pxe_cmn.h>
#include <pxe_api.h>
#include <undi_api.h>
#include <ntexapi.h>

#ifdef EFI
#define BINL_PORT   0x0FAB    // 4011 (decimal) in little-endian
#else
#define BINL_PORT   0xAB0F    // 4011 (decimal) in big-endian
#endif

//
// This removes macro redefinitions which appear because we define __RPC_DOS__,
// but rpc.h defines __RPC_WIN32__
//

#pragma warning(disable:4005)

//
// As of 12/17/98, SECURITY_DOS is *not* defined - adamba
//

#if defined(SECURITY_DOS)
//
// These appear because we defined SECURITY_DOS
//

#define __far
#define __pascal
#define __loadds
#endif

#include <security.h>
#include <rpc.h>
#include <spseal.h>

#ifdef EFI
#include "bldr.h"
#include "efi.h"
#include "efip.h"
#include "bldria64.h"
#include "extern.h"
extern EFI_HANDLE EfiImageHandle;
#endif

#if defined(SECURITY_DOS)
//
// PSECURITY_STRING is not supposed to be used when SECURITY_DOS is
// defined -- it should be a WCHAR*. Unfortunately ntlmsp.h breaks
// this rule and even uses the SECURITY_STRING structure, which there
// is really no equivalent for in 16-bit mode.
//

typedef SEC_WCHAR * SECURITY_STRING;   // more-or-less the intention where it is used
typedef SEC_WCHAR * PSECURITY_STRING;
#endif

#include <ntlmsp.h>


extern ULONG TftpSecurityHandle;
extern CtxtHandle TftpClientContextHandle;
extern BOOLEAN TftpClientContextHandleValid;

//
// From conn.c.
//

ULONG
ConnItoa (
    IN ULONG Value,
    OUT PUCHAR Buffer
    );

ULONG
ConnSafeAtol (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd
    );

// for now, we pull the hack mac list and code so that we only support new ROMs

#ifdef EFI


#pragma pack(1)
typedef struct {
    UINT16      VendorId;
    UINT16      DeviceId;
    UINT16      Command;
    UINT16      Status;
    UINT8       RevisionID;
    UINT8       ClassCode[3];
    UINT8       CacheLineSize;
    UINT8       LaytencyTimer;
    UINT8       HeaderType;
    UINT8       BIST;
} PCI_DEVICE_INDEPENDENT_REGION;

typedef struct {
    UINT32      Bar[6];
    UINT32      CISPtr;
    UINT16      SubsystemVendorID;
    UINT16      SubsystemID;
    UINT32      ExpansionRomBar;
    UINT32      Reserved[2];
    UINT8       InterruptLine;
    UINT8       InterruptPin;
    UINT8       MinGnt;
    UINT8       MaxLat;     
} PCI_DEVICE_HEADER_TYPE_REGION;

typedef struct {
    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
    PCI_DEVICE_HEADER_TYPE_REGION   Device;
} PCI_TYPE00;

typedef struct {              
    UINT32      Bar[2];
    UINT8       PrimaryBus;
    UINT8       SecondaryBus;
    UINT8       SubordinateBus;
    UINT8       SecondaryLatencyTimer;
    UINT8       IoBase;
    UINT8       IoLimit;
    UINT16      SecondaryStatus;
    UINT16      MemoryBase;
    UINT16      MemoryLimit;
    UINT16      PrefetchableMemoryBase;
    UINT16      PrefetchableMemoryLimit;
    UINT32      PrefetchableBaseUpper32;
    UINT32      PrefetchableLimitUpper32;
    UINT16      IoBaseUpper16;
    UINT16      IoLimitUpper16;
    UINT32      Reserved;
    UINT32      ExpansionRomBAR;
    UINT8       InterruptLine;
    UINT8       InterruptPin;
    UINT16      BridgeControl;
} PCI_BRIDGE_CONTROL_REGISTER;

typedef struct {
    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
    PCI_BRIDGE_CONTROL_REGISTER     Bridge;
} PCI_TYPE01;


NTSTATUS
GetBusNumberFromAcpiPath(
    IN EFI_DEVICE_IO_INTERFACE *DeviceIo,
    IN UINTN UID,
    IN UINTN HID, 
    OUT UINT16 *BusNumber
    )
/*++

Routine Description:

    Given an ACPI UID and HID, find the bus # corresponding to this data.

Arguments:

    DeviceIo - pointer to device io interface.
    UID - unique id for acpi device
    HID - hardware id for acpi device
    BusNumber - receives bus # for device if found.
    
    This entire routine runs in physical mode.
      
Return Value:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL

--*/
{
    EFI_STATUS       SegStatus = EFI_SUCCESS;
    EFI_STATUS       BusStatus = EFI_SUCCESS;
    UINT32           Seg;
    UINT8            Bus;
    UINT64           PciAddress;
    EFI_DEVICE_PATH  *PciDevicePath;
    EFI_DEVICE_PATH_ALIGNED DevicePathAligned;
    NTSTATUS ReturnCode = STATUS_UNSUCCESSFUL;

    //
    // walk through every segment and every bus looking for a bus that matches
    // the UID/HID that we're looking for.
    //
    for (Seg=0;!EFI_ERROR (SegStatus);Seg++) {
        PciAddress = Seg << 32;
        SegStatus = DeviceIo->PciDevicePath(DeviceIo, PciAddress, &PciDevicePath);
        if (!EFI_ERROR (SegStatus)) {
            //
            // Segment exists
            //
            for (Bus=0;!EFI_ERROR (BusStatus);Bus++) {
                PciAddress = (Seg << 32) | (Bus << 24);
                BusStatus = DeviceIo->PciDevicePath(DeviceIo, PciAddress, &PciDevicePath);
                //
                // Bus exists
                //
                if (!EFI_ERROR (BusStatus)) {

                    EfiAlignDp(
                              &DevicePathAligned,
                              PciDevicePath,
                              DevicePathNodeLength(PciDevicePath) );

                    //
                    // now see if the acpi device path for the bus matches the UID
                    // and HID passed in.
                    //
                    while ( DevicePathAligned.DevPath.Type != END_DEVICE_PATH_TYPE) {

                        if ( (DevicePathAligned.DevPath.Type == ACPI_DEVICE_PATH) &&
                             (DevicePathAligned.DevPath.SubType == ACPI_DP)) {

                            ACPI_HID_DEVICE_PATH *AcpiDevicePath;

                            AcpiDevicePath = (ACPI_HID_DEVICE_PATH *)&DevicePathAligned;
                            if (AcpiDevicePath->UID == UID && 
                                AcpiDevicePath->HID == HID) {
                                //
                                // success.  return bus number.
                                //
                                *BusNumber = Bus;
                                ReturnCode = STATUS_SUCCESS;
                                goto exit;
                            }
                        }

                        //
                        // Get the next structure in our packed array.
                        //
                        PciDevicePath = NextDevicePathNode( PciDevicePath );

                        EfiAlignDp(&DevicePathAligned,
                                   PciDevicePath,
                                   DevicePathNodeLength(PciDevicePath));


                    }            
                }
            }
        }    
    }

exit:
    return(ReturnCode);
}

NTSTATUS
NetQueryCardInfo(
    IN OUT PNET_CARD_INFO CardInfo
    )

/*++

Routine Description:

    This routine queries the ROM for information about the card.

Arguments:

    CardInfo - returns the structure defining the card.

Return Value:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL

--*/

{

    EFI_STATUS              Status = EFI_UNSUPPORTED;
    EFI_DEVICE_PATH         *DevicePath = NULL;
    EFI_DEVICE_PATH         *OriginalRootDevicePath = NULL;
    EFI_DEVICE_PATH_ALIGNED DevicePathAligned;
    UINT16                  BusNumber = 0;
    UINT8                   DeviceNumber = 0;
    UINT8                   FunctionNumber = 0;
    BOOLEAN                 FoundACPIDevice = FALSE;
    BOOLEAN                 FoundPCIDevice = FALSE;
    EFI_GUID                DeviceIoProtocol = DEVICE_IO_PROTOCOL;
    EFI_GUID                EFIPciIoProtocol = EFI_PCI_IO_PROTOCOL;
    EFI_HANDLE              MyHandle;
    EFI_DEVICE_IO_INTERFACE *IoDev;
    EFI_LOADED_IMAGE       *EfiImageInfo;
    EFI_PCI_IO_INTERFACE    *PciIoDev;
    EFI_HANDLE              PciIoHandle;
    UINT16                  SegmentNumber = 0;
    UINTN                   Seg = 0;
    UINTN                   Bus = 0;
    UINTN                   Dev = 0;
    UINTN                   Func = 0;
    
    UINTN                   HID;
    UINTN                   UID;
    BOOLEAN                 PciIoProtocolSupported = TRUE;

    RtlZeroMemory(CardInfo, sizeof(NET_CARD_INFO));

    //
    // Get the image info for the loader
    //
    FlipToPhysical();
    Status = EfiST->BootServices->HandleProtocol (EfiImageHandle,
                                                  &EfiLoadedImageProtocol,
                                                  &EfiImageInfo);
    FlipToVirtual();

    if (Status != EFI_SUCCESS)
    {
        if( BdDebuggerEnabled ) {
            DbgPrint( "NetQueryCardInfo: HandleProtocol failed -LoadedImageProtocol (%d)\n", Status);
        }
        return (NTSTATUS)Status;
    }
    //
    // get the device path to the image
    //
    FlipToPhysical();
    Status = EfiST->BootServices->HandleProtocol (EfiImageInfo->DeviceHandle,
                                                  &EfiDevicePathProtocol,
                                                  &DevicePath);

    FlipToVirtual();

    if (Status != EFI_SUCCESS)
    {
        if( BdDebuggerEnabled ) {
            DbgPrint( "NetQueryCardInfo: HandleProtocol failed -DevicePathProtocol (%d)\n", Status);
        }

        return (NTSTATUS)Status;
    }

    FlipToPhysical();
    EfiAlignDp( &DevicePathAligned,
                DevicePath,
                DevicePathNodeLength(DevicePath));

    Status = EfiST->BootServices->LocateDevicePath ( &EFIPciIoProtocol,
                                                     &DevicePath,
                                                     &PciIoHandle);
    FlipToVirtual();
    
    //
    // we may be on an older system that doesn't support the pci io
    // protocol
    //
    if (Status != EFI_SUCCESS) {
        PciIoProtocolSupported = FALSE;
    }

    //
    // Save off this root DevicePath in case we need it later.
    //
    OriginalRootDevicePath = DevicePath;

    //
    // Now we need to read the PCI header information from the specific
    // card.
    //

    //
    // use the pci io protocol if it's supported to get the bus dev func for
    // the card.
    //
    if (PciIoProtocolSupported) {
        
        FlipToPhysical();
        Status = EfiST->BootServices->HandleProtocol (PciIoHandle,
                                              &EFIPciIoProtocol,
                                              &PciIoDev);

        FlipToVirtual();
    
        if (Status != EFI_SUCCESS)
        {
            if( BdDebuggerEnabled ) {
                DbgPrint( "NetQueryCardInfo: HandleProtocol failed -EFIPciIoProtocol (%d)\n", Status);
            }
            return (NTSTATUS)Status;
        }

        // find the location of the device - segment, bus, dev and func
        FlipToPhysical();
        Status = PciIoDev->GetLocation(PciIoDev,
                                       &Seg,
                                       &Bus,
                                       &Dev,
                                       &Func );
    
        SegmentNumber = (UINT16)Seg;
        BusNumber = (UINT16)Bus;
        DeviceNumber = (UINT8)Dev;
        FunctionNumber = (UINT8)Func;
    
        FlipToVirtual();
    
        if (Status != EFI_SUCCESS)
        {
            if( BdDebuggerEnabled ) {
                DbgPrint( "NetQueryCardInfo: EfiPciIo failed -GetLocation (%d)\n", Status);
            }
            return (NTSTATUS)Status;
        }
    
        FoundPCIDevice = TRUE;
        FoundACPIDevice = TRUE;
    }


    // 
    // if the pci io protocol is not supported we do it the old way.
    // this involves walking the device path till we get to the device.
    // note that we make a questionable assumption here, that the UID for
    // the acpi device path is really the bus number.  it works on some 
    // machines, but the pci io protocol is better as it removes this 
    // assumption.
    //
    // AcpiDevicePath = (ACPI_HID_DEVICE_PATH *)&DevicePathAligned;
    // BusNumber = AcpiDevicePath->UID
    //
    // PciDevicePath = (PCI_DEVICE_PATH *)&DevicePathAligned;
    // DeviceNumber = PciDevicePath->Device
    // FunctionNumber = PciDevicePath->Function
    //
    if (!PciIoProtocolSupported) {
        FlipToPhysical();       

        Status = EfiST->BootServices->LocateDevicePath ( &DeviceIoProtocol,
                                                 &DevicePath,
                                                 &MyHandle);
        
        if (Status != EFI_SUCCESS) {
            FlipToVirtual();
            if( BdDebuggerEnabled ) {
                DbgPrint( "NetQueryCardInfo: LocateDevicePath failed -IoProtocol (%d)\n", Status);
            }
            return (NTSTATUS)Status;
        }

        Status = EfiST->BootServices->HandleProtocol( 
                                                 MyHandle,
                                                 &DeviceIoProtocol,
                                                 &IoDev);

        if (Status != EFI_SUCCESS) {
            FlipToVirtual();
            if( BdDebuggerEnabled ) {
                DbgPrint( "NetQueryCardInfo: HandleProtocol failed -IoProtocol (%d)\n", Status);
            }
            return (NTSTATUS)Status;
        }

        while( DevicePathAligned.DevPath.Type != END_DEVICE_PATH_TYPE) {
    
            if( (DevicePathAligned.DevPath.Type == ACPI_DEVICE_PATH) &&
                (DevicePathAligned.DevPath.SubType == ACPI_DP) && 
                (FoundACPIDevice == FALSE)) {
    
                //
                // We'll find the BusNumber here.
                //
                ACPI_HID_DEVICE_PATH *AcpiDevicePath;
                
                AcpiDevicePath = (ACPI_HID_DEVICE_PATH *)&DevicePathAligned;
                UID = AcpiDevicePath->UID;
                HID = AcpiDevicePath->HID;
                
                Status = (NTSTATUS)GetBusNumberFromAcpiPath(IoDev, UID,HID, &BusNumber);

                FoundACPIDevice = TRUE;

                if (! NT_SUCCESS(Status)) {
                    FlipToVirtual();

                    if (BdDebuggerEnabled) {
                        DbgPrint( "NetQueryCardInfo: GetBusNumberFromAcpiPath failed (%x)\n", Status);
                    }
                    Status = ENODEV;                    
                    return (NTSTATUS)Status;
                }
            }
    
    
            if( (DevicePathAligned.DevPath.Type == HARDWARE_DEVICE_PATH) &&
                (DevicePathAligned.DevPath.SubType == HW_PCI_DP) ) {
    
                //
                // We'll find DeviceNumber and FunctionNumber here.
                //
                PCI_DEVICE_PATH *PciDevicePath;
    
                if ( FoundPCIDevice ) {
                    //
                    // we have already found a PCI device.  that device must have 
                    // been a bridge.  we must find the new bus # on the downstream
                    // side of the bridge 
                    //
                    UINT64                  BridgeAddress;
                    PCI_TYPE01              PciBridge;
                    EFI_DEVICE_PATH        *BridgeDevicePath;
    
                    //
                    // Get a Handle for the device
                    //
                    BridgeDevicePath = OriginalRootDevicePath;
                    Status = EfiST->BootServices->LocateDevicePath( &DeviceIoProtocol,
                                                                    &BridgeDevicePath,
                                                                    &MyHandle );
    
                    if( Status != EFI_SUCCESS ) {
                        FlipToVirtual();
                        if (BdDebuggerEnabled) {
                            DbgPrint( "NetQueryCardInfo: LocateDevicePath(bridge) failed (%x)\n", Status);
                        }
                        return (NTSTATUS)Status;
                    }
    
                    Status = EfiST->BootServices->HandleProtocol( MyHandle,
                                                                  &DeviceIoProtocol,
                                                                  (VOID*)&IoDev );
    
                    if( Status != EFI_SUCCESS ) {
                        FlipToVirtual();
                        if (BdDebuggerEnabled) {
                            DbgPrint( "NetQueryCardInfo: HandleProtocol(bridge) failed (%X)\n", Status);
                        }
                        return (NTSTATUS)Status;
                    }
    
    
                    //
                    // Generate the address, then read the PCI header from the device.
                    //
                    BridgeAddress = EFI_PCI_ADDRESS( BusNumber, DeviceNumber, FunctionNumber );
    
                    RtlZeroMemory(&PciBridge, sizeof(PCI_TYPE01));
    
                    Status = IoDev->Pci.Read( IoDev,
                                              IO_UINT32,
                                              BridgeAddress,
                                              sizeof(PCI_TYPE01) / sizeof(UINT32),
                                              &PciBridge );
    
                    if( Status != EFI_SUCCESS ) {
                        FlipToVirtual();
                        if (BdDebuggerEnabled) {
                            DbgPrint( "NetQueryCardInfo: Pci.Read(bridge) failed (%X)\r\n", Status);
                        }
                        return (NTSTATUS)Status;
                    }
    
                    //
                    // Bridges are requred to store 3 registers.  the PrimaryBus, SecondaryBus and
                    // SubordinateBus.  The PrimaryBus is the Bus number on the upstream side of 
                    // the bridge.  The SecondaryBus is the Bus number on the downstream side
                    // and the SubordinateBus is the greatest bus number that can be reached through
                    // the particular bus.  we simply want to change BusNumber to the SecondaryBus
                    // 
                    BusNumber = (UINT16) PciBridge.Bridge.SecondaryBus;
                }
                
                PciDevicePath = (PCI_DEVICE_PATH *)&DevicePathAligned;
                DeviceNumber = PciDevicePath->Device;
                FunctionNumber = PciDevicePath->Function;
                FoundPCIDevice = TRUE;
            }
        
            //
            // Get the next structure in our packed array.
            //
            DevicePath = NextDevicePathNode( DevicePath );
    
            EfiAlignDp(&DevicePathAligned,
                       DevicePath,
                       DevicePathNodeLength(DevicePath));
        
        
        }
        FlipToVirtual();
    }


    
    //
    // Derive the function pointer that will allow us to read from
    // PCI space.
    //
    DevicePath = OriginalRootDevicePath;
    FlipToPhysical();
    Status = EfiST->BootServices->LocateDevicePath( &DeviceIoProtocol,
                                                    &DevicePath,
                                                    &MyHandle );
    FlipToVirtual();
    if( Status != EFI_SUCCESS ) {
        if (BdDebuggerEnabled) {
            DbgPrint( "NetQueryCardInfo: LocateDevicePath failed (%X)\n", Status);
        }
        return (NTSTATUS)Status;
    }

    FlipToPhysical();
    Status = EfiST->BootServices->HandleProtocol( MyHandle,
                                                  &DeviceIoProtocol,
                                                  (VOID*)&IoDev );
    FlipToVirtual();

    if( Status != EFI_SUCCESS ) {
        if (BdDebuggerEnabled) {
            DbgPrint( "NetQueryCardInfo: HandleProtocol(2) failed (%X)\n", Status);
        }
        return (NTSTATUS)Status;
    }

    //
    // We've got the Bus, Device, and Function number for this device.  Go read
    // his header (with the PCI-Read function that we just derived) and get
    // the information we're after.
    //
    if( FoundPCIDevice && FoundACPIDevice ) {
        UINT64                  Address;
        PCI_TYPE00              Pci;
        
        if (BdDebuggerEnabled) {
            DbgPrint( "NetQueryCardInfo: Found all the config info for the device.\n" );
            DbgPrint( "                  BusNumber: %d  DeviceNumber: %d  FunctionNumber: %d\n", BusNumber, DeviceNumber, FunctionNumber );
        }
        
        //
        // Generate the address, then read the PCI header from the device.
        //
        Address = EFI_PCI_ADDRESS( BusNumber, DeviceNumber, FunctionNumber );
        
        RtlZeroMemory(&Pci, sizeof(PCI_TYPE00));


        FlipToPhysical();
        Status = IoDev->Pci.Read( IoDev,
                                  IO_UINT32,
                                  Address,
                                  sizeof(PCI_TYPE00) / sizeof(UINT32),
                                  &Pci );
        FlipToVirtual();
        if( Status != EFI_SUCCESS ) {
            if (BdDebuggerEnabled) {
                DbgPrint( "NetQueryCardInfo: Pci.Read failed (%X)\n", Status);
            }
            return (NTSTATUS)Status;
        }

        //
        // It all worked.  Copy the information from the device into
        // the CardInfo structure and exit.
        //

        CardInfo->NicType = 2;          // He's PCI
        CardInfo->pci.Vendor_ID = Pci.Hdr.VendorId;
        CardInfo->pci.Dev_ID = Pci.Hdr.DeviceId;
        CardInfo->pci.Rev = Pci.Hdr.RevisionID;
        
        // BusDevFunc is defined as 16 bits built as follows:
        // 15-8 --------------------------- Bus Number
        //      7-3 ----------------------- Device Number
        //          2-0 ------------------- Function Number
        CardInfo->pci.BusDevFunc =  ((BusNumber & 0xFF) << 8);
        CardInfo->pci.BusDevFunc |= ((DeviceNumber & 0x1F) << 3);
        CardInfo->pci.BusDevFunc |= (FunctionNumber & 0x7);



        // SubSys_ID is actually ((SubsystemID << 16) | SubsystemVendorID)
        CardInfo->pci.Subsys_ID = Pci.Device.SubsystemID;
        CardInfo->pci.Subsys_ID = (CardInfo->pci.Subsys_ID << 16) | (Pci.Device.SubsystemVendorID);

#if DBG
        if (BdDebuggerEnabled) {
            DbgPrint( "\n" );
            DbgPrint( "NetQueryCardInfo: Pci.Hdr.VendorId %x\n", Pci.Hdr.VendorId );
            DbgPrint( "                  Pci.Hdr.DeviceId %x\n", Pci.Hdr.DeviceId );
            DbgPrint( "                  Pci.Hdr.Command %x\n", Pci.Hdr.Command );
            DbgPrint( "                  Pci.Hdr.Status %x\n", Pci.Hdr.Status );
            DbgPrint( "                  Pci.Hdr.RevisionID %x\n", Pci.Hdr.RevisionID );
            DbgPrint( "                  Pci.Hdr.HeaderType %x\n", Pci.Hdr.HeaderType );
            DbgPrint( "                  Pci.Hdr.BIST %x\n", Pci.Hdr.BIST );
            DbgPrint( "                  Pci.Device.SubsystemVendorID %x\n", Pci.Device.SubsystemVendorID );    
            DbgPrint( "                  Pci.Device.SubsystemID %x\n", Pci.Device.SubsystemID );    
            DbgPrint( "\n" );
            
            DbgPrint( "NetQueryCardInfo: CardInfo->NicType %x\n", CardInfo->NicType );
            DbgPrint( "                  CardInfo->pci.Vendor_ID %x\n", CardInfo->pci.Vendor_ID );
            DbgPrint( "                  CardInfo->pci.Dev_ID %x\n", CardInfo->pci.Dev_ID );
            DbgPrint( "                  CardInfo->pci.Rev %x\n", CardInfo->pci.Rev );
            DbgPrint( "                  CardInfo->pci.Subsys_ID %x\n", CardInfo->pci.Subsys_ID );
            DbgPrint( "\n" );
        }
#endif

        Status = STATUS_SUCCESS;

    } else {
        if (BdDebuggerEnabled) {
            DbgPrint( "NetQueryCardInfo: Failed to find all the config info for the device.\n" );
        }

        Status = STATUS_UNSUCCESSFUL;
    }


    return (NTSTATUS)Status;


}


#else

NTSTATUS
NetQueryCardInfo(
    IN OUT PNET_CARD_INFO CardInfo
    )

/*++

Routine Description:

    This routine queries the ROM for information about the card.

Arguments:

    CardInfo - returns the structure defining the card.

Return Value:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL

--*/

{
    ULONG status;
    t_PXENV_UNDI_GET_NIC_TYPE nicType;

    RtlZeroMemory(CardInfo, sizeof(NET_CARD_INFO));

    status = RomGetNicType( &nicType );
    if ((status != PXENV_EXIT_SUCCESS) || (nicType.Status != PXENV_EXIT_SUCCESS)) {

#if DBG
        DbgPrint( "RomGetNicType returned 0x%x, nicType.Status = 0x%x. Time to upgrade your netcard ROM\n",
                    status, nicType.Status );
#endif
        status = STATUS_UNSUCCESSFUL;

    } else {

#if DBG
        if ( nicType.NicType == 2 ) {
            DbgPrint( "Vendor_ID: %04x, Dev_ID: %04x\n",
                        nicType.pci_pnp_info.pci.Vendor_ID,
                        nicType.pci_pnp_info.pci.Dev_ID );
            DbgPrint( "Base_Class: %02x, Sub_Class: %02x, Prog_Intf: %02x\n",
                        nicType.pci_pnp_info.pci.Base_Class,
                        nicType.pci_pnp_info.pci.Sub_Class,
                        nicType.pci_pnp_info.pci.Prog_Intf );
            DbgPrint( "Rev: %02x, BusDevFunc: %04x, SubSystem: %04x\n",
                        nicType.pci_pnp_info.pci.Rev,
                        nicType.pci_pnp_info.pci.BusDevFunc,
                        nicType.pci_pnp_info.pci.Subsys_ID );
        } else {
            DbgPrint( "NicType: 0x%x  EISA_Dev_ID: %08x\n",
                        nicType.NicType,
                        nicType.pci_pnp_info.pnp.EISA_Dev_ID );
            DbgPrint( "Base_Class: %02x, Sub_Class: %02x, Prog_Intf: %02x\n",
                        nicType.pci_pnp_info.pnp.Base_Class,
                        nicType.pci_pnp_info.pnp.Sub_Class,
                        nicType.pci_pnp_info.pnp.Prog_Intf );
            DbgPrint( "CardSelNum: %04x\n",
                        nicType.pci_pnp_info.pnp.CardSelNum );
        }
#endif
        //
        // The call worked, so copy the information.
        //

        CardInfo->NicType = nicType.NicType;
        if (nicType.NicType == 2) {

            CardInfo->pci.Vendor_ID = nicType.pci_pnp_info.pci.Vendor_ID;
            CardInfo->pci.Dev_ID = nicType.pci_pnp_info.pci.Dev_ID;
            CardInfo->pci.Base_Class = nicType.pci_pnp_info.pci.Base_Class;
            CardInfo->pci.Sub_Class = nicType.pci_pnp_info.pci.Sub_Class;
            CardInfo->pci.Prog_Intf = nicType.pci_pnp_info.pci.Prog_Intf;
            CardInfo->pci.Rev = nicType.pci_pnp_info.pci.Rev;
            CardInfo->pci.BusDevFunc = nicType.pci_pnp_info.pci.BusDevFunc;
            CardInfo->pci.Subsys_ID = nicType.pci_pnp_info.pci.Subsys_ID;

            status = STATUS_SUCCESS;

        } else {

            status = STATUS_UNSUCCESSFUL;
        }
    }

    return status;
}

#endif  // EFI

NTSTATUS
UdpSendAndReceiveForNetQuery(
    IN PVOID SendBuffer,
    IN ULONG SendBufferLength,
    IN ULONG SendRemoteHost,
    IN USHORT SendRemotePort,
    IN ULONG SendRetryCount,
    IN PVOID ReceiveBuffer,
    IN ULONG ReceiveBufferLength,
    IN ULONG ReceiveTimeout,
    IN ULONG ReceiveSignatureCount,
    IN PCHAR ReceiveSignatures[]
    )
{
    ULONG i, j;
    ULONG length;
    ULONG RemoteHost;
    USHORT RemotePort;

    //
    // Try sending the packet SendRetryCount times, until we receive
    // a response with the right signature, waiting ReceiveTimeout
    // each time.
    //

    for (i = 0; i < SendRetryCount; i++) {

        length = UdpSend(
                    SendBuffer,
                    SendBufferLength,
                    SendRemoteHost,
                    SendRemotePort);

        if ( length != SendBufferLength ) {
            DbgPrint("UdpSend only sent %d bytes, not %d\n", length, SendBufferLength);
            return STATUS_UNEXPECTED_NETWORK_ERROR;
        }

ReReceive:

        //
        // NULL out the first 12 bytes in case we get shorter data.
        //

        memset(ReceiveBuffer, 0x0, 12);

        length = UdpReceive(
                    ReceiveBuffer,
                    ReceiveBufferLength,
                    &RemoteHost,
                    &RemotePort,
                    ReceiveTimeout);

        if ( length == 0 ) {
            DPRINT( ERROR, ("UdpReceive timed out\n") );
            continue;
        }

        //
        // Make sure the signature is one of the ones we expect.
        //

        for (j = 0; j < ReceiveSignatureCount; j++) {
            if (memcmp(ReceiveBuffer, ReceiveSignatures[j], 4) == 0) {
                return STATUS_SUCCESS;
            }
        }

        DbgPrint("UdpReceive got wrong signature\n");

        // ISSUE NTRAID #60513: CLEAN THIS UP -- but the idea is not to UdpSend
        // again just because we got a bad signature. Still need to respect the
        // original ReceiveTimeout however!

        goto ReReceive;

    }

    //
    // We timed out.
    //

    return STATUS_IO_TIMEOUT;
}

#define NETCARD_REQUEST_RESPONSE_BUFFER_SIZE    4096

NTSTATUS
NetQueryDriverInfo(
    IN PNET_CARD_INFO CardInfo,
    IN PCHAR SetupPath,
    IN PCHAR NtBootPathName,
    IN OUT PWCHAR HardwareId,
    IN ULONG HardwareIdLength,
    IN OUT PWCHAR DriverName,
    IN OUT PCHAR DriverNameAnsi OPTIONAL,
    IN ULONG DriverNameLength,
    IN OUT PWCHAR ServiceName,
    IN ULONG ServiceNameLength,
    OUT PCHAR * Registry,
    OUT ULONG * RegistryLength
    )

/*++

Routine Description:

    This routine does an exchange with the server to get information
    about the card described by CardInfo.

Arguments:

    CardInfo - Information about the card.

    SetupPath - UNC path (with only a single leading backslash) to our setup directory

    NtBootPathName - UNC path (with only a single leading backslash) to our boot directory

    HardwareId - returns the hardware ID of the card.

    HardwareIdLength - the length (in bytes) of the passed-in HardwareId buffer.

    DriverName - returns the name of the driver.

    DriverNameAnsi - if present, returns the name of the driver in ANSI.

    DriverNameLength - the length (in bytes) of the passed-in DriverName buffer
        (it is assumed that DriverNameAnsi is at least half this length).

    ServiceName - returns the service key of the driver.

    ServiceNameLength - the length (in bytes) of the passed-in ServiceName buffer.

    Registry - if needed, allocates and returns extra registry parameters
        for the card.

    RegistryLength - the length of Registry.

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_OVERFLOW if either of the buffers are too small.
    STATUS_INSUFFICIENT_RESOURCES if we cannot allocate memory for Registry.
    STATUS_IO_TIMEOUT if we can't get a response from the server.

--*/

{
    NTSTATUS Status;
    USHORT localPort;
    PNETCARD_REQUEST_PACKET requestPacket;
    PCHAR ReceiveSignatures[2];
    PCHAR ReceiveBuffer;
    ULONG GuidLength;
    PUCHAR Guid;
    ULONG sendSize;
    PNETCARD_REQUEST_PACKET allocatedRequestPacket = NULL;
    ARC_STATUS ArcStatus;


    //
    // Get the local UDP port.
    //

    localPort = UdpUnicastDestinationPort;

    //
    // Construct the outgoing packet.  Also allocate memory for 
    // the receive packet.
    //
    sendSize = sizeof(NETCARD_REQUEST_PACKET) + 
               ((SetupPath) ? (strlen(SetupPath) + 1) : 0);

    requestPacket = BlAllocateHeap( sendSize );
    if (requestPacket == NULL) {
        Status = STATUS_BUFFER_OVERFLOW;
        goto done;
    }

    ReceiveBuffer = BlAllocateHeap( NETCARD_REQUEST_RESPONSE_BUFFER_SIZE );
    if (ReceiveBuffer == NULL) {
        Status = STATUS_BUFFER_OVERFLOW;
        goto done;
    }

    RtlCopyMemory(requestPacket->Signature, NetcardRequestSignature, sizeof(requestPacket->Signature));
    requestPacket->Length = sizeof(NETCARD_REQUEST_PACKET) - FIELD_OFFSET(NETCARD_REQUEST_PACKET, Version);
    requestPacket->Version = OSCPKT_NETCARD_REQUEST_VERSION;

#if defined(_IA64_)
    requestPacket->Architecture = PROCESSOR_ARCHITECTURE_IA64;
#endif
#if defined(_X86_)
    requestPacket->Architecture = PROCESSOR_ARCHITECTURE_INTEL;
#endif

    requestPacket->SetupDirectoryLength = SetupPath ? (strlen( SetupPath ) + 1) : 0;

    if (requestPacket->SetupDirectoryLength) {

        requestPacket->SetupDirectoryPath[0] = '\\';
        strcpy( &requestPacket->SetupDirectoryPath[1], SetupPath );
    }

    ArcStatus = GetGuid(&Guid, &GuidLength);
    if (ArcStatus != ESUCCESS) {
        //
        // normalize the error and exit.
        //
        switch (ArcStatus) {
            case ENOMEM:
                Status = STATUS_NO_MEMORY;
                goto done;
                break;
            case ENODEV:
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                goto done;
                break;
            default:
                Status = STATUS_UNSUCCESSFUL;
                goto done;
                break;
        }
    }
    
    if (GuidLength == sizeof(requestPacket->Guid)) {        
        memcpy(requestPacket->Guid, Guid, GuidLength);
    }
    RtlCopyMemory(&requestPacket->CardInfo, CardInfo, sizeof(NET_CARD_INFO));

    ReceiveSignatures[0] = NetcardResponseSignature;
    ReceiveSignatures[1] = NetcardErrorSignature;

    Status = UdpSendAndReceiveForNetQuery(
                 requestPacket,
                 sendSize,
                 NetServerIpAddress,
                 BINL_PORT,
                 100,           // retry count
                 ReceiveBuffer,
                 NETCARD_REQUEST_RESPONSE_BUFFER_SIZE,
                 60,            // receive timeout... may have to parse INF files
                 2,
                 ReceiveSignatures
                 );

    if (Status == STATUS_SUCCESS) {

        PWCHAR stringInPacket;
        ULONG maxOffset;
        UNICODE_STRING uString;
        ULONG len;
        PNETCARD_RESPONSE_PACKET responsePacket;

        responsePacket = (PNETCARD_RESPONSE_PACKET)ReceiveBuffer;

        if (responsePacket->Status != STATUS_SUCCESS) {
            Status = responsePacket->Status;
            goto done;
        }

        if (responsePacket->Length < sizeof( NETCARD_RESPONSE_PACKET )) {
            Status = STATUS_UNSUCCESSFUL;
            goto done;
        }

        //
        // The exchange succeeded, so copy the results back.
        //

        maxOffset = NETCARD_REQUEST_RESPONSE_BUFFER_SIZE -
                    sizeof( NETCARD_RESPONSE_PACKET );

        if (responsePacket->HardwareIdOffset < sizeof(NETCARD_RESPONSE_PACKET) ||
            responsePacket->HardwareIdOffset >= maxOffset ) {

            Status = STATUS_BUFFER_OVERFLOW;
            goto done;
        }

        //
        //  pick up the hardwareId string.  It's given to us as an offset
        //  within the packet to a unicode null terminated string.
        //

        stringInPacket = (PWCHAR)(PCHAR)((PCHAR)responsePacket +
                                   responsePacket->HardwareIdOffset );

        RtlInitUnicodeString( &uString, stringInPacket );

        if (uString.Length + sizeof(WCHAR) > HardwareIdLength) {
            Status = STATUS_BUFFER_OVERFLOW;
            goto done;
        }

        RtlCopyMemory( HardwareId, uString.Buffer, uString.Length + sizeof(WCHAR));

        //
        //  pick up the driverName string.  It's given to us as an offset
        //  within the packet to a unicode null terminated string.
        //

        stringInPacket = (PWCHAR)(PCHAR)((PCHAR)responsePacket +
                                   responsePacket->DriverNameOffset );

        RtlInitUnicodeString( &uString, stringInPacket );

        if (uString.Length + sizeof(WCHAR) > DriverNameLength) {
            Status = STATUS_BUFFER_OVERFLOW;
            goto done;
        }

        RtlCopyMemory( DriverName, uString.Buffer, uString.Length + sizeof(WCHAR));

        //
        //  we convert this one into ansi if the caller requested
        //

        if (ARGUMENT_PRESENT(DriverNameAnsi)) {

            RtlUnicodeToMultiByteN( DriverNameAnsi,
                                    DriverNameLength,
                                    NULL,
                                    uString.Buffer,
                                    uString.Length + sizeof(WCHAR));
        }

        //
        //  pick up the serviceName string.  It's given to us as an offset
        //  within the packet to a unicode null terminated string.
        //

        stringInPacket = (PWCHAR)(PCHAR)((PCHAR)responsePacket +
                                   responsePacket->ServiceNameOffset );

        RtlInitUnicodeString( &uString, stringInPacket );

        if (uString.Length + sizeof(WCHAR) > ServiceNameLength) {
            Status = STATUS_BUFFER_OVERFLOW;
            goto done;
        }

        RtlCopyMemory( ServiceName, uString.Buffer, uString.Length + sizeof(WCHAR));

        //
        // If any extra registry params were passed back, allocate/copy those.
        //

        *RegistryLength = responsePacket->RegistryLength;

        if (*RegistryLength) {

            *Registry = BlAllocateHeap(*RegistryLength);
            if (*Registry == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto done;
            }

            stringInPacket = (PWCHAR)(PCHAR)((PCHAR)responsePacket +
                                       responsePacket->RegistryOffset );

            RtlCopyMemory(*Registry, stringInPacket, *RegistryLength);

        } else {

            *Registry = NULL;
        }
    }

done:
    if (requestPacket) {
        //
        // we would free this memory
        // if the loader had a free routine
        //
        // free(requestPacket);
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\tftplib\conn.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    conn.c

Abstract:

    Boot loader TFTP connection handling routines.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996
        based on code by Mike Massa (mikemas) Feb 21, 1992
        based on SpiderTCP code

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

ULONG
ConnItoa (
    IN ULONG Value,
    OUT PUCHAR Buffer
    );

ULONG
ConnSafeAtol (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd
    );

BOOLEAN
ConnSafeStrequal (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd,
    IN PUCHAR CompareString
    );

ULONG
ConnSafeStrsize (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd
    );

ULONG
ConnStrsize (
    IN PUCHAR Buffer
    );


NTSTATUS
ConnInitialize (
    IN OUT PCONNECTION *Connection,
    IN USHORT Operation,
    IN ULONG RemoteHost,
    IN USHORT RemotePort,
    IN PUCHAR Filename,
    IN ULONG BlockSize,
    IN OUT PULONG FileSize
    )
//
// Open up the connection, make a request packet, and send the
// packet out on it.  Allocate space for the connection control
// block and fill it in. Allocate another packet for data and,
// on writes, another to hold received packets.  Don't wait
// for connection ack; it will be waited for in cn_rcv or cn_wrt.
// Return pointer to the connection control block, or NULL on error.
//
//

{
    NTSTATUS status;
    PCONNECTION connection;
    PTFTP_PACKET packet;
    ULONG length;
    ULONG stringSize;
    PUCHAR options;
    PUCHAR end;
    BOOLEAN blksizeAcked;
    BOOLEAN tsizeAcked;

    DPRINT( TRACE, ("ConnInitialize\n") );

//#if 0 //
#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    return STATUS_SUCCESS;
#endif


    connection = &NetTftpConnection;
    *Connection = connection;

    RtlZeroMemory( connection, sizeof(CONNECTION) );
    connection->Synced = FALSE;             // connection not synchronized yet
    connection->Operation = Operation;
    connection->RemoteHost = RemoteHost;
    connection->LocalPort = UdpAssignUnicastPort();
    connection->RemotePort = RemotePort;
    connection->Timeout = INITIAL_TIMEOUT;
    connection->Retransmissions = 0;

    connection->LastSentPacket = NetTftpPacket[0];
    connection->CurrentPacket = NetTftpPacket[1];

    if ( Operation == TFTP_RRQ ) {
        connection->LastReceivedPacket = connection->CurrentPacket;
    } else {
        connection->LastReceivedPacket = NetTftpPacket[2];
    }

    packet = connection->LastSentPacket;
    packet->Opcode = Operation;

    //
    // TFTP_PACKET structure defines the packet structure for 
    // TFTP ACK/DATA packets.  We're initialing a RRQ/WRQ packet
    // which has a different format.  We overload this structure to
    // the RRQ/WRQ format, graphically depicted below.
    //      2 bytes     string    1 byte     string   1 byte
    //     ------------------------------------------------
    //    | Opcode |  Filename  |   0  |    Mode    |   0  |
    //     ------------------------------------------------
    //
    options = (PUCHAR)&packet->BlockNumber;     // start of file name
    
    //
    // the TFTP spec doesn't impose a limit on path length.  
    //
    ASSERT(ConnStrsize(Filename) < DEFAULT_BLOCK_SIZE);
    strcpy( options, Filename );
    //DPRINT( LOUD, ("ConnInitialize: opening %s\n", options) );
    length = ConnStrsize( options );
    options += length;
    length += sizeof(packet->Opcode);
    ASSERT(length+sizeof("octet") <= MAXIMUM_TFTP_PACKET_LENGTH);
    strcpy( options, "octet" );
    length += sizeof("octet");
    options += sizeof("octet");
    
    if ( BlockSize == 0 ) {
        BlockSize = DEFAULT_BLOCK_SIZE;
    }

    ASSERT(length+sizeof("blksize") <= MAXIMUM_TFTP_PACKET_LENGTH);
    strcpy( options, "blksize" );
    length += sizeof("blksize");
    options += sizeof("blksize");

    ASSERT(length+sizeof("9999") <= MAXIMUM_TFTP_PACKET_LENGTH);
    stringSize = ConnItoa( BlockSize, options );
    DPRINT( REAL_LOUD, ("ConnInitialize: requesting block size = %s\n", options) );
    length += stringSize;
    options += stringSize;

    ASSERT(length+sizeof("tsize") <= MAXIMUM_TFTP_PACKET_LENGTH);
    strcpy( options, "tsize" );
    length += sizeof("tsize");
    options += sizeof("tsize");
    
    stringSize = ConnItoa( (Operation == TFTP_RRQ) ? 0 : *FileSize, options );
    DPRINT( REAL_LOUD, ("ConnInitialize: requesting transfer size = %s\n", options) );
    ASSERT(length+stringSize <= MAXIMUM_TFTP_PACKET_LENGTH);
    length += stringSize;
    options += stringSize;

    ConnSendPacket( connection, packet, length );

    connection->BlockNumber = 0;
    connection->BlockSize = BlockSize;

    status = ConnWait( connection, TFTP_OACK, &packet );
    if ( NT_SUCCESS(status) ) {

        options = (PUCHAR)&packet->BlockNumber;
        end = (PUCHAR)packet + connection->LastReceivedLength;

        blksizeAcked = FALSE;
        tsizeAcked = FALSE;

        while ( (options < end) && (!blksizeAcked || !tsizeAcked
                ) ) {

            if ( ConnSafeStrequal(options, end, "blksize") ) {

                options += sizeof("blksize");
                DPRINT( REAL_LOUD, ("ConnInitialize: received block size = %s\n", options) );
                BlockSize = ConnSafeAtol( options, end );
                if ( (BlockSize < 8) || (BlockSize > connection->BlockSize) ) {
                    goto bad_options;
                }
                options += ConnStrsize(options);
                connection->BlockSize = BlockSize;
                DPRINT( REAL_LOUD, ("ConnInitialize: block size for transfer = %d\n", BlockSize) );
                blksizeAcked = TRUE;

            } else if ( ConnSafeStrequal(options, end, "tsize") ) {

                options += sizeof("tsize");
                DPRINT( REAL_LOUD, ("ConnInitialize: received transfer size = %s\n", options) );
                BlockSize = ConnSafeAtol( options, end );  // use this as a temp variable
                if ( BlockSize == (ULONG)-1 ) {
                    goto bad_options;
                }
                options += ConnStrsize(options);
                if ( Operation == TFTP_RRQ ) {
                    *FileSize = BlockSize;
                }
                tsizeAcked = TRUE;

            } else {

                DPRINT( ERROR, ("ConnInitialize: skipping unrecognized option %s\n", options) );
                options += ConnSafeStrsize( options, end );
                options += ConnSafeStrsize( options, end );
            }
        }

        if ( !blksizeAcked || !tsizeAcked ) {
            goto bad_options;
        }

        if ( Operation == TFTP_RRQ ) {
            DPRINT( REAL_LOUD, ("ConnInitialize: ACKing OACK\n") );
            ConnAck( connection );
        }
    }

    return status;

bad_options:

    DPRINT( ERROR, ("ConnInitialize: bad options in OACK\n") );

    ConnError(
        connection,
        connection->RemoteHost,
        connection->RemotePort,
        TFTP_ERROR_OPTION_NEGOT_FAILED,
        "Bad TFTP options"
        );

    return STATUS_UNSUCCESSFUL;

} // ConnInitialize


NTSTATUS
ConnReceive (
    IN PCONNECTION Connection,
    OUT PTFTP_PACKET *Packet
    )
//
// Receive a tftp packet into the packet buffer pointed to by Connection->CurrentPacket.
// The packet to be received must be a packet of block number Connection->BlockNumber.
// Returns a pointer to the tftp part of received packet.  Also performs
// ack sending and retransmission.
//

{
    NTSTATUS status;


//#if 0 
#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    ASSERT( FALSE );
    return STATUS_SUCCESS;
#endif

    status = ConnWait( Connection, TFTP_DATA, Packet );
    if ( NT_SUCCESS(status) ) {

        Connection->CurrentPacket = Connection->LastReceivedPacket;
        Connection->CurrentLength = Connection->LastReceivedLength;

        ConnAck( Connection );
    }

    return status;

} // ConnReceive


NTSTATUS
ConnSend (
    IN PCONNECTION Connection,
    IN ULONG Length
    )
//
// Write the data packet contained in Connection->CurrentPacket, with data length len,
// to the net.  Wait first for an ack for the previous packet to arrive,
// retransmitting it as needed.  Then fill in the net headers, etc. and
// send the packet out.  Return TRUE if the packet is sent successfully,
// or FALSE if a timeout or error occurs.
//

{
    NTSTATUS status;
    PTFTP_PACKET packet;
    PVOID temp;
    USHORT blockNumber;


//#if 0
#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    ASSERT( FALSE );
    return STATUS_SUCCESS;
#endif


    packet = Connection->CurrentPacket;
    packet->Opcode = TFTP_DATA;
    blockNumber = Connection->BlockNumber + 1;
    if ( blockNumber == 0 ) {
        blockNumber = 1;
    }
    packet->BlockNumber = SWAP_WORD( blockNumber );
    Length += sizeof(packet->Opcode) + sizeof(packet->BlockNumber);

    if ( Connection->BlockNumber != 0 ) {
        status = ConnWait( Connection, TFTP_DACK, NULL );
        if ( !NT_SUCCESS(status) ) {
            return status;
        }
    }

    Connection->BlockNumber = blockNumber;  // next expected block number
    Connection->Retransmissions = 0;

    temp = Connection->LastSentPacket;      // next write packet buffer
    ConnSendPacket( Connection, Connection->CurrentPacket, Length ); // sets up LastSent...
    Connection->CurrentPacket = temp;       // for next ConnPrepareSend

    return STATUS_SUCCESS;

} // ConnSend


NTSTATUS
ConnWait (
    IN PCONNECTION Connection,
    IN USHORT Opcode,
    OUT PTFTP_PACKET *Packet OPTIONAL
    )
//
// Wait for a valid tftp packet of the specified type to arrive on the
// specified tftp connection, retransmitting the previous packet as needed up
// to the timeout period.  When a packet comes in, check it out.
// Return a pointer to the received packet or NULL if error or timeout.
//

{
    ULONG now;
    ULONG timeout;
    ULONG remoteHost;
    USHORT remotePort;
    PTFTP_PACKET packet;
    ULONG length;
    USHORT blockNumber;


//#if 0 
#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    return STATUS_SUCCESS;
#endif


    while ( TRUE) {

        now = SysGetRelativeTime();
        timeout = Connection->NextRetransmit - now;
        DPRINT( REAL_LOUD, ("ConnWait: now=%d, next retransmit=%d, timeout=%d\n",
                        now, Connection->NextRetransmit, timeout) );
        length = UdpReceive(
                    Connection->LastReceivedPacket,
                    sizeof(TFTP_HEADER) + Connection->BlockSize,
                    &remoteHost,
                    &remotePort,
                    timeout
                    );
        if ( length <= 0 ) {
            if ( !ConnRetransmit( Connection, TRUE ) ) {
                break;
            }
            continue;
        }

        //
        // Got a packet; check it out.
        //

        packet = Connection->LastReceivedPacket;

        //
        // First, check the received length for validity.
        //

        Connection->LastReceivedLength = length;
        if ( (length < sizeof(TFTP_HEADER)) ||
             ((packet->Opcode == TFTP_DATA) &&
              (length > (sizeof(TFTP_HEADER) + Connection->BlockSize))) ) {
            ConnError(
                Connection,
                remoteHost,
                remotePort,
                TFTP_ERROR_UNDEFINED,
                "Bad TFTP packet length"
                );
            continue;
        }

        //
        // Next, check for correct remote host.
        //

        if ( remoteHost != Connection->RemoteHost ) {
            ConnError(
                Connection,
                remoteHost,
                remotePort,
                TFTP_ERROR_UNKNOWN_TRANSFER_ID,
                "Sorry, wasn't talking to you!"
                );
            continue;
        }

        //
        // Next, the remote port.  If still unsynchronized, use his port.
        //

        blockNumber = SWAP_WORD( packet->BlockNumber );

        if ( !Connection->Synced &&
             (((packet->Opcode == Opcode) &&
               ((Opcode == TFTP_OACK) || (blockNumber == Connection->BlockNumber))) ||
              (packet->Opcode == TFTP_ERROR)) ) {

            Connection->Synced = TRUE;
            Connection->RemotePort = remotePort;
            Connection->Timeout = TIMEOUT;  // normal data timeout

        } else if ( remotePort != Connection->RemotePort ) {

            ConnError(
                Connection,
                remoteHost,
                remotePort,
                TFTP_ERROR_UNKNOWN_TRANSFER_ID,
                "Unexpected port number"
                );
            continue;
        }

        //
        // Now check out the TFTP opcode.
        //

        if ( packet->Opcode == Opcode ) {

            if ( (Opcode == TFTP_OACK) || (blockNumber == Connection->BlockNumber) ) {

                if ( Packet != NULL ) {
                    *Packet = packet;
                }
                Connection->Timeout = TIMEOUT;  // normal data timeout
                return STATUS_SUCCESS;

            } else if ( (blockNumber == Connection->BlockNumber - 1) &&
                        (Opcode == TFTP_DATA) ) {

                if ( !ConnRetransmit( Connection, FALSE ) ) {
                    break;
                }

            } else if ( blockNumber > Connection->BlockNumber ) {

                DPRINT( ERROR, ("ConnWait: Block number too high (%d vs. %d)\n",
                                blockNumber, Connection->BlockNumber) );
                ConnError(
                    Connection,
                    remoteHost,
                    remotePort,
                    TFTP_ERROR_ILLEGAL_OPERATION,
                    "Block number greater than expected"
                    );

                return STATUS_UNSUCCESSFUL;

            } else {                        // old duplicate; ignore

                continue;
            }

        } else if ( packet->Opcode == TFTP_OACK ) {

            DPRINT( ERROR, ("ConnWait: received duplicate OACK packet\n") );

            if ( Connection->BlockNumber == 1 ) {

                if ( !ConnRetransmit( Connection, FALSE ) ) {
                    break;
                }
            }

        } else if ( packet->Opcode == TFTP_ERROR ) {

            //DPRINT( ERROR, ("ConnWait: received error packet; code %x, msg %s\n",
            //                packet->BlockNumber, packet->Data) );

            return STATUS_UNSUCCESSFUL;

        } else {                            // unexpected TFTP opcode

            DPRINT( ERROR, ("ConnWait: received unknown TFTP opcode %d\n", packet->Opcode) );

            ConnError(
                Connection,
                remoteHost,
                remotePort,
                TFTP_ERROR_ILLEGAL_OPERATION,
                "Bad opcode received"
                );

            return STATUS_UNSUCCESSFUL;
        }
    }

    DPRINT( ERROR, ("ConnWait: timeout\n") );

    ConnError(
        Connection,
        Connection->RemoteHost,
        Connection->RemotePort,
        TFTP_ERROR_UNDEFINED,
        "Timeout on receive" );

    return STATUS_IO_TIMEOUT;

} // ConnWait


VOID
ConnAck (
    IN PCONNECTION Connection
    )
//
// Generate and send an ack packet for the specified connection.  Also
// update the block number.  Use the packet stored in Connection->LastSent to build
// the ack in.
//

{
    PTFTP_PACKET packet;
    ULONG length;


//#if 0
#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    ASSERT( FALSE );
    return;
#endif


    packet = Connection->LastSentPacket;

    length = 4;
    packet->Opcode = TFTP_DACK;
    packet->BlockNumber = SWAP_WORD( Connection->BlockNumber );

    ConnSendPacket( Connection, packet, length );
    Connection->Retransmissions = 0;
    Connection->BlockNumber++;
    if ( Connection->BlockNumber == 0 ) {
        Connection->BlockNumber = 1;
    }

    return;

} // ConnAck


VOID
ConnError (
    IN PCONNECTION Connection,
    IN ULONG RemoteHost,
    IN USHORT RemotePort,
    IN USHORT ErrorCode,
    IN PUCHAR ErrorMessage
    )
//
// Make an error packet to send to the specified foreign host and port
// with the specified error code and error message.  This routine is
// used to send error messages in response to packets received from
// unexpected foreign hosts or tid's as well as those received for the
// current connection.  It allocates a packet specially
// for the error message because such error messages will not be
// retransmitted.  Send it out on the connection.
//

{
    PTFTP_PACKET packet;
    ULONG length;

    DPRINT( CONN_ERROR, ("ConnError: code %x, msg %s\n", ErrorCode, ErrorMessage) );


//#if 0
#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    return;
#endif


    packet = (PTFTP_PACKET)NetTftpPacket[2];

    length = 4;
    packet->Opcode = TFTP_ERROR;
    packet->BlockNumber = ErrorCode;
    strcpy( packet->Data, ErrorMessage );
    length += ConnStrsize(ErrorMessage);

    UdpSend( packet, length, RemoteHost, RemotePort );

    return;

} // ConnError


VOID
ConnSendPacket (
    IN PCONNECTION Connection,
    IN PVOID Packet,
    IN ULONG Length
    )
//
// Send the specified packet, with the specified tftp length (length -
// udp and ip headers) out on the current connection.  Fill in the
// needed parts of the udp and ip headers, byte-swap the tftp packet,
// etc; then write it out.  Then set up for retransmit.
//

{


//#if 0
#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    ASSERT( FALSE );
    return;
#endif


    UdpSend(
        Packet,
        Length,
        Connection->RemoteHost,
        Connection->RemotePort
        );

    Connection->LastSentPacket = Packet;
    Connection->LastSentLength = Length;
    Connection->NextRetransmit = SysGetRelativeTime() + Connection->Timeout;

    return;

} // ConnSendPacket


PTFTP_PACKET
ConnPrepareSend (
    IN PCONNECTION Connection
    )
//
// Return a pointer to the next tftp packet suitable for filling for
// writes on the connection.
//

{
//#if 0
#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    ASSERT( FALSE );
    return NULL;
#endif

    return Connection->CurrentPacket;

} // ConnPrepareSend


NTSTATUS
ConnWaitForFinalAck (
    IN PCONNECTION Connection
    )
//
// Finish off a write connection.  Wait for the last ack, then
// close the connection and return.
//

{
    return ConnWait( Connection, TFTP_DACK, NULL );

} // ConnWaitForFinalAck


BOOLEAN
ConnRetransmit (
    IN PCONNECTION Connection,
    IN BOOLEAN Timeout
    )
//
// Retransmit the last-sent packet, up to MAX_RETRANS times.  Exponentially
// back off the timeout time up to a maximum of MAX_TIMEOUT.  This algorithm
// may be replaced by a better one in which the timeout time is set from
// the maximum round-trip time to date.
// The second argument indicates whether the retransmission is due to the
// arrival of a duplicate packet or a timeout.  If a duplicate, don't include
// this retransmission in the maximum retransmission count.
//

{


//#if 0
#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    ASSERT( FALSE );
    return TRUE;
#endif

    if ( Timeout ) {

        //
        // This is a timeout. Check the retransmit count.
        //

        if ( ++Connection->Retransmissions >= MAX_RETRANS ) {

            //
            // Retransmits exhausted.
            //

            return FALSE;
        }

    } else {

        //
        // Duplicate packet. If we just sent a packet, don't send
        // another one. This deals with the case where we receive
        // multiple identical packets in rapid succession, possibly
        // due to network problems or slowness at the remote computer.
        //

        if ( Connection->NextRetransmit == SysGetRelativeTime() + Connection->Timeout ) {
            return TRUE;
        }
    }

    Connection->Timeout <<= 1;
    if ( Connection->Timeout > MAX_TIMEOUT ) {
        Connection->Timeout = MAX_TIMEOUT;
    }

    ConnSendPacket( Connection, Connection->LastSentPacket, Connection->LastSentLength );

    return TRUE;

} // ConnRetransmit


ULONG
ConnSafeAtol (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd
    )
{
    ULONG value;
    UCHAR c;

    value = 0;

    while ( Buffer < BufferEnd ) {

        c = *Buffer++;

        if ( c == 0 ) {
            return value;
        }

        if ( (c < '0') || (c > '9') ) {
            break;
        }

        value = (value * 10) + (c - '0');
    }

    return (ULONG)-1;

} // ConnSafeAtol


ULONG
ConnItoa (
    IN ULONG Value,
    OUT PUCHAR Buffer
    )
{
    PUCHAR p;
    ULONG digit;
    UCHAR c;

    p = Buffer;

    //
    // Put the value string into the buffer in reverse order.
    //

    do {
        digit = Value % 10;
        Value /= 10;
        *p++ = (UCHAR)(digit + '0');
    } while ( Value > 0 );

    //
    // Terminate the string and move back to the last character in the string.
    //

    digit = (ULONG)(p - Buffer + 1);     // size of string (including terminator)

    *p-- = 0;

    //
    // Reverse the string.
    //

    do {
        c = *p;
        *p-- = *Buffer;
        *Buffer++ = c;
    } while ( Buffer < p );

    return digit;

} // ConnItoa


BOOLEAN
ConnSafeStrequal (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd,
    IN PUCHAR CompareString
    )
{

    while ( Buffer < BufferEnd ) {
        if ( *Buffer != *CompareString ) {
            return FALSE;
        }
        if ( *CompareString == 0 ) {
            return TRUE;
        }
        Buffer++;
        CompareString++;
    }

    return FALSE;

} // ConnSafeStrequal


ULONG
ConnSafeStrsize (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd
    )
{
    PUCHAR eos;

    eos = Buffer;

    while ( eos < BufferEnd ) {
        if ( *eos++ == 0 ) {
            return (ULONG)(eos - Buffer);
        }
    }

    return 0;

} // ConnSafeStrsize


ULONG
ConnStrsize (
    IN PUCHAR Buffer
    )
{
    PUCHAR eos;

    eos = Buffer;

    while ( *eos++ != 0 ) ;

    return (ULONG)(eos - Buffer);

} // ConnStrsize
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\tftplib\tftp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    tftp.c

Abstract:

    Boot loader TFTP routines.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

//
// This removes macro redefinitions which appear because we define __RPC_DOS__,
// but rpc.h defines __RPC_WIN32__
//

#pragma warning(disable:4005)

//
// As of 12/17/98, SECURITY_DOS is *not* defined - adamba
//

#if defined(SECURITY_DOS)
//
// These appear because we defined SECURITY_DOS
//

#define __far
#define __pascal
#define __loadds
#endif

#include <security.h>
#include <rpc.h>
#include <spseal.h>

#if defined(_X86_)
#include <bldrx86.h>
#endif

#if defined(SECURITY_DOS)
//
// PSECURITY_STRING is not supposed to be used when SECURITY_DOS is
// defined -- it should be a WCHAR*. Unfortunately ntlmsp.h breaks
// this rule and even uses the SECURITY_STRING structure, which there
// is really no equivalent for in 16-bit mode.
//

typedef SEC_WCHAR * SECURITY_STRING;   // more-or-less the intention where it is used
typedef SEC_WCHAR * PSECURITY_STRING;
#endif

#include <ntlmsp.h>

#if DBG
ULONG NetDebugFlag =
        DEBUG_ERROR             |
        DEBUG_CONN_ERROR        |
        //DEBUG_LOUD              |
        //DEBUG_REAL_LOUD         |
        //DEBUG_STATISTICS        |
        //DEBUG_SEND_RECEIVE      |
        //DEBUG_TRACE             |
        //DEBUG_ARP               |
        //DEBUG_INITIAL_BREAK     |
        0;
#endif

//
// Global variables
//

CONNECTION NetTftpConnection;

UCHAR NetTftpPacket[3][MAXIMUM_TFTP_PACKET_LENGTH];

//
// Local declarations.
//

NTSTATUS
TftpGet (
    IN PCONNECTION Connection,
    IN PTFTP_REQUEST Request
    );

NTSTATUS
TftpPut (
    IN PCONNECTION Connection,
    IN PTFTP_REQUEST Request
    );


NTSTATUS
TftpGetPut (
    IN PTFTP_REQUEST Request
    )
{
    NTSTATUS status;
    PCONNECTION connection = NULL;
    ULONG FileSize;
    ULONG basePage;
#if 0 && DBG
    LARGE_INTEGER startTime;
    LARGE_INTEGER endTime;
    LARGE_INTEGER elapsedTime;
    LARGE_INTEGER frequency;
    ULONG seconds;
    ULONG secondsFraction;
    ULONG bps;
    ULONG bpsFraction;
#endif

#ifndef EFI
    //
    // We don't need to do any of this initialization if
    // we're in EFI.
    //

    FileSize = Request->MaximumLength;

    status = ConnInitialize(
                &connection,
                Request->Operation,
                Request->ServerIpAddress,
                TFTP_PORT,
                Request->RemoteFileName,
                0,
                &FileSize
                );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

#if 0 && DBG
    IF_DEBUG(STATISTICS) {
        startTime = KeQueryPerformanceCounter( &frequency );
    }
#endif

    if ( Request->Operation == TFTP_RRQ ) {

        if ( Request->MemoryAddress != NULL ) {

            if ( Request->MaximumLength < FileSize ) {
                ConnError(
                    connection,
                    connection->RemoteHost,
                    connection->RemotePort,
                    TFTP_ERROR_UNDEFINED,
                    "File too big"
                    );
                return STATUS_INSUFFICIENT_RESOURCES;
            }

        } else {

            //
            // NB: (ChuckL) Removed code added by MattH to check for
            // allocation >= 1/3 of (BlUsableLimit - BlUsableBase)
            // because calling code now sets BlUsableLimit to 1 GB
            // or higher.
            //


            status = BlAllocateAlignedDescriptor(
                        Request->MemoryType,
                        0,
                        BYTES_TO_PAGES(FileSize),
                        0,
                        &basePage
                        );

            if (status != ESUCCESS) {
                ConnError(
                    connection,
                    connection->RemoteHost,
                    connection->RemotePort,
                    TFTP_ERROR_UNDEFINED,
                    "File too big"
                    );
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            Request->MemoryAddress = (PUCHAR)(KSEG0_BASE | (basePage << PAGE_SHIFT));
            Request->MaximumLength = FileSize;
            DPRINT( REAL_LOUD, ("TftpGetPut: allocated %d bytes at 0x%08x\n",
                    Request->MaximumLength, Request->MemoryAddress) );
        }

        status = TftpGet( connection, Request );

    } else {

        status = TftpPut( connection, Request );
    }

#else  // #ifndef EFI

    if ( Request->Operation == TFTP_RRQ ) {

        status = TftpGet( connection, Request );
    } else {

        status = TftpPut( connection, Request );
    }

    if( status != STATUS_SUCCESS ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

#endif  // #ifndef EFI


    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    return status;

} // TftpGetPut


//#if 0
#ifdef EFI

extern VOID
FlipToPhysical (
    );

extern VOID
FlipToVirtual (
    );

NTSTATUS
TftpGet (
    IN OUT PCONNECTION Connection,
    IN PTFTP_REQUEST Request
    )
{
    EFI_STATUS      Status;
    CHAR16          *Size = NULL;
    PVOID           MyBuffer = NULL;
    EFI_IP_ADDRESS  MyServerIpAddress;
    INTN            Count = 0;
    INTN            BufferSizeX = sizeof(CHAR16);
    ULONG           basePage;
    UINTN           BlockSize = 512;

    //
    // They sent us an IP address as a ULONG.  We need to convert
    // that into an EFI_IP_ADDRESS.
    //
    for( Count = 0; Count < 4; Count++ ) {
        MyServerIpAddress.v4.Addr[Count] = PXEClient->Mode->ProxyOffer.Dhcpv4.BootpSiAddr[Count];
    }


    //
    // Get the file size, allocate some memory, then get the file.
    //
    FlipToPhysical();
    Status = PXEClient->Mtftp( PXEClient,
                               EFI_PXE_BASE_CODE_TFTP_GET_FILE_SIZE,
                               Size,
                               TRUE,
                               &BufferSizeX,
                               &BlockSize,
                               &MyServerIpAddress,
                               Request->RemoteFileName,
                               0,
                               FALSE );
    FlipToVirtual();


    if( Status != EFI_SUCCESS ) {

        return (NTSTATUS)Status;

    }

    Status = BlAllocateAlignedDescriptor(
                Request->MemoryType,
                0,
                (ULONG) BYTES_TO_PAGES(BufferSizeX),
                0,
                &basePage
                );

    if ( Status != ESUCCESS ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "TftpGet: BlAllocate failed! (%d)\n", Status );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Request->MemoryAddress = (PUCHAR)(KSEG0_BASE | ((ULONGLONG)basePage << PAGE_SHIFT) );
    Request->MaximumLength = (ULONG)BufferSizeX;

    //
    // Make sure we send EFI a physical address.
    //
    MyBuffer = (PVOID)((ULONGLONG)(Request->MemoryAddress) & ~KSEG0_BASE);    
    
    FlipToPhysical();
    Status = PXEClient->Mtftp( PXEClient,
                               EFI_PXE_BASE_CODE_TFTP_READ_FILE,
                               MyBuffer,
                               TRUE,
                               &BufferSizeX,
                               NULL,
                               &MyServerIpAddress,
                               Request->RemoteFileName,
                               0,
                               FALSE );
    FlipToVirtual();

    if( Status != EFI_SUCCESS ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "TftpGet: GetFile failed! (%d)\n", Status );
        }
        return (NTSTATUS)Status;

    }



    Request->BytesTransferred = (ULONG)BufferSizeX;

    return (NTSTATUS)Status;

} // TftpGet


NTSTATUS
TftpPut (
    IN OUT PCONNECTION Connection,
    IN PTFTP_REQUEST Request
    )
{
    EFI_STATUS      Status;
    EFI_IP_ADDRESS  MyServerIpAddress;
    INTN            Count = 0;
    PVOID           MyBuffer = NULL;


    //
    // They sent us an IP address as a ULONG.  We need to convert
    // that into an EFI_IP_ADDRESS.
    //
    for( Count = 0; Count < 4; Count++ ) {
        MyServerIpAddress.v4.Addr[Count] = PXEClient->Mode->ProxyOffer.Dhcpv4.BootpSiAddr[Count];
    }

    //
    // Make sure we send EFI a physical address.
    //
    MyBuffer = (PVOID)((ULONGLONG)(Request->MemoryAddress) & ~KSEG0_BASE);    

    FlipToPhysical();
    Status = PXEClient->Mtftp( PXEClient,
                               EFI_PXE_BASE_CODE_TFTP_WRITE_FILE,
                               MyBuffer,
                               TRUE,
                               (UINTN *)(&Request->MaximumLength),
                               NULL,
                               &MyServerIpAddress,
                               Request->RemoteFileName,
                               0,
                               FALSE );
    FlipToVirtual();

    if( Status != EFI_SUCCESS ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "TftpPut: WriteFile failed! (%d)\n", Status );
        }

    }

    return (NTSTATUS)Status;

} // TftpPut

#else  //#ifdef EFI

NTSTATUS
TftpGet (
    IN OUT PCONNECTION Connection,
    IN PTFTP_REQUEST Request
    )
{
    NTSTATUS status;
    PTFTP_PACKET packet;
    ULONG length;
    ULONG offset;
    PUCHAR packetData;
    ULONG lastProgressPercent = -1;
    ULONG currentProgressPercent;

    DPRINT( TRACE, ("TftpGet\n") );

    offset = 0;

    if ( Request->ShowProgress ) {
        BlUpdateProgressBar(0);
    }

    do {

        status = ConnReceive( Connection, &packet );
        if ( !NT_SUCCESS(status) ) {
            break;
        }

        length = Connection->CurrentLength - 4;

        packetData = packet->Data;

        if ( (offset + length) > Request->MaximumLength ) {
            length = Request->MaximumLength - offset;
        }

        RtlCopyMemory( Request->MemoryAddress + offset, packetData, length );

        offset += length;

        if ( Request->ShowProgress ) {
            currentProgressPercent = (ULONG)(((ULONGLONG)offset * 100) / Request->MaximumLength);
            if ( currentProgressPercent != lastProgressPercent ) {
                BlUpdateProgressBar( currentProgressPercent );
            }
            lastProgressPercent = currentProgressPercent;
        }

        //
        // End the loop when we get a packet smaller than the max size --
        // the extra check is to handle the first packet (length == offset)
        // since we get NTLMSSP_MESSAGE_SIGNATURE_SIZE bytes less.
        //

    } while ( (length == Connection->BlockSize));

    Request->BytesTransferred = offset;

    return status;

} // TftpGet


NTSTATUS
TftpPut (
    IN OUT PCONNECTION Connection,
    IN PTFTP_REQUEST Request
    )
{
    NTSTATUS status;
    PTFTP_PACKET packet;
    ULONG length;
    ULONG offset;

    DPRINT( TRACE, ("TftpPut\n") );

    offset = 0;

    do {

        packet = ConnPrepareSend( Connection );

        length = Connection->BlockSize;
        if ( (offset + length) > Request->MaximumLength ) {
            length = Request->MaximumLength - offset;
        }

        RtlCopyMemory( packet->Data, Request->MemoryAddress + offset, length );

        status = ConnSend( Connection, length );
        if ( !NT_SUCCESS(status) ) {
            break;
        }

        offset += length;

    } while ( length == Connection->BlockSize );

    Request->BytesTransferred = offset;

    if ( NT_SUCCESS(status) ) {
        status = ConnWaitForFinalAck( Connection );
    }

    return status;

} // TftpPut
#endif  // #if defined(_IA64_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\tftplib\ia64\rom.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rom.c

Abstract:

    Boot loader ROM routines.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#include <udp_api.h>
#include <tftp_api.h>
#include "bldr.h"
#include "efi.h"
#include "efip.h"
#include "bldria64.h"
#include "extern.h"


//
// We'll use this to keep track of which port we're communicating through.
//
EFI_PXE_BASE_CODE_UDP_PORT      MachineLocalPort = 2000;


#define UDP_STALL_TIME      (40000)
#define UDP_RETRY_COUNT     (10)

extern VOID
FwStallExecution(
    IN ULONG Microseconds
    );




VOID
RomSetReceiveStatus (
    IN USHORT UnicastUdpDestinationPort
#if 0
    ,
    IN USHORT MulticastUdpDestinationPort,
    IN ULONG MulticastUdpDestinationAddress,
    IN USHORT MulticastUdpSourcePort,
    IN ULONG MulticastUdpSourceAddress
#endif
    )
{
    return;

} // RomSetReceiveStatus


ULONG
RomSendUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG RemoteHost,
    IN USHORT pServerPort
    )
{
    EFI_STATUS                      EfiStatus = EFI_SUCCESS;
    EFI_IP_ADDRESS                  DestinationIpAddress;
    INTN                            Count = 0;
    EFI_PXE_BASE_CODE_UDP_PORT      ServerPort = pServerPort;
    UINTN                           BufferLength = Length;
    PVOID                           MyBuffer = NULL;


    //
    // Get the server's EFI_IP_ADDRESS from the handle to the PXE base code.
    //
    for( Count = 0; Count < 4; Count++ ) {
        DestinationIpAddress.v4.Addr[Count] = PXEClient->Mode->ProxyOffer.Dhcpv4.BootpSiAddr[Count];
    }        

    FlipToPhysical();
    
    //
    // Make sure the address is a physical address, then do the UdpWrite.
    //
    MyBuffer = (PVOID)((ULONG_PTR)Buffer & ~KSEG0_BASE);
    Count = UDP_RETRY_COUNT;
    do {
        EfiStatus = PXEClient->UdpWrite( PXEClient,
                                         0,
                                         &DestinationIpAddress,
                                         &ServerPort,
                                         NULL,
                                         NULL,
                                         &MachineLocalPort,
                                         NULL,
                                         NULL,
                                         &BufferLength,
                                         MyBuffer );
    
        //
        // This is really gross, but on retail builds with no debugger, EFI will go
        // off in the weeds unless we slow down transactions over the network.  So
        // after Udp operations, take a short nap.
        //
        if( EfiStatus == EFI_TIMEOUT ) {
            FwStallExecution( UDP_STALL_TIME );
        }
        Count--;
    } while( (EfiStatus == EFI_TIMEOUT) && (Count > 0) );
    
    FlipToVirtual();
    
    
    if( EfiStatus != EFI_SUCCESS ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "RomSendUdpPacket: UdpWrite failed. MachineLocalPort: %d ServerPort: %d (%d)\r\n", MachineLocalPort, ServerPort, EfiStatus );
        }
        return 0;
    }

    return (ULONG)BufferLength;


} // RomSendUdpPacket


ULONG
RomReceiveUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Timeout,
    IN OUT PULONG RemoteHost,
    IN OUT PUSHORT LocalPort
    )
{
    EFI_STATUS                      EfiStatus = EFI_SUCCESS;
    UINTN                           BufferLength = Length;
    EFI_IP_ADDRESS                  ServerIpAddress;
    EFI_IP_ADDRESS                  MyIpAddress;
    INTN                            Count = 0;
    EFI_PXE_BASE_CODE_UDP_PORT      ServerPort = (EFI_PXE_BASE_CODE_UDP_PORT)(0xFAB);    // hardcode to 4011
    PVOID                           MyBuffer = NULL;
    ULONG                           startTime;

    //
    // Get The server's EFI_IP_ADDRESS from the handle to the PXE base code.
    //
    for( Count = 0; Count < 4; Count++ ) {
        ServerIpAddress.v4.Addr[Count] = PXEClient->Mode->ProxyOffer.Dhcpv4.BootpSiAddr[Count];
    }        


    //
    // Get our EFI_IP_ADDRESS from the handle to the PXE base code.
    //
    for( Count = 0; Count < 4; Count++ ) {
        MyIpAddress.v4.Addr[Count] = PXEClient->Mode->StationIp.v4.Addr[Count];
    }        


    startTime = SysGetRelativeTime();
    if ( Timeout < 2 ) Timeout = 2;

    //
    // Make sure the address is a physical address, then do the UdpReceive.
    //
    MyBuffer = (PVOID)((ULONG_PTR)Buffer & ~KSEG0_BASE);
    
    while ( (SysGetRelativeTime() - startTime) < Timeout ) {

        FlipToPhysical();
    
        //
        // By setting flags to 0, we are setting a receive filter
        // which says we'll only receive a packet from the specified
        // IP address and port, sent to the specified IP address and
        // port.
        //
        EfiStatus = PXEClient->UdpRead( PXEClient,
                                    0,
                                    &MyIpAddress,
                                    &MachineLocalPort,
                                    &ServerIpAddress,
                                    &ServerPort,
                                    NULL,                   // &HeaderLength
                                    NULL,                   // HeaderBuffer
                                    &BufferLength,
                                    MyBuffer );
    
        //
        // This is really gross, but on retail builds with no debugger, EFI will go
        // off in the weeds unless we slow down transactions over the network.  So
        // after Udp operations, take a short nap.  We must be in physical mode
        // when we call this API.
        //
        if( EfiStatus == EFI_TIMEOUT ) {
            FwStallExecution( UDP_STALL_TIME );
        }
        
        //
        // back into virtual mode -- we're either going to break out or do another
        // loop, and the SysGetRelativeTime call wants us in physical mode.
        //
        FlipToVirtual();
        if (EfiStatus == EFI_SUCCESS) {
            break;
        }
    }
    

    if( EfiStatus != EFI_SUCCESS ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "RomReceiveUdpPacket: UdpRead failed. MachineLocalPort: %d ServerPort: %d (%d)\r\n", MachineLocalPort, ServerPort, EfiStatus );
        }
        return 0;
    }


    return (ULONG)BufferLength;

} // RomReceiveUdpPacket


ULONG
RomGetNicType (
    OUT t_PXENV_UNDI_GET_NIC_TYPE *NicType
    )
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\tftplib\udp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    udp.c

Abstract:

    Boot loader UDP routines.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

ULONG UdpNextPort = 0;

USHORT UdpUnicastDestinationPort;

#if 0
USHORT UdpMulticastDestinationPort;
ULONG UdpMulticastDestinationAddress;
USHORT UdpMulticastSourcePort;
ULONG UdpMulticastSourceAddress;
#endif


USHORT
UdpAssignUnicastPort (
    VOID
    )
{
    if ( UdpNextPort == 0 ) {
        UdpNextPort = (ArcGetRelativeTime() & 0x7fff) | 0x8000;
    } else if ( ++UdpNextPort > 0xffff ) {
        UdpNextPort = 0x8000;
    }

    UdpUnicastDestinationPort = SWAP_WORD( UdpNextPort );

#if 0
    UdpMulticastDestinationPort = 0;
#endif

    RomSetReceiveStatus(
        UdpUnicastDestinationPort
#if 0
        ,
        UdpMulticastDestinationPort,
        UdpMulticastDestinationAddress,
        UdpMulticastSourcePort,
        UdpMulticastSourceAddress
#endif
        );

    return (USHORT)UdpUnicastDestinationPort;

} // UdpAssignUnicastPort


#if 0
VOID
UdpSetMulticastPort (
    IN USHORT DestinationPort,
    IN ULONG DestinationAddress,
    IN USHORT SourcePort,
    IN ULONG SourceAddress
    )
{
    UdpMulticastDestinationPort = DestinationPort;
    UdpMulticastDestinationAddress = DestinationAddress;
    UdpMulticastSourcePort = SourcePort;
    UdpMulticastSourceAddress = SourceAddress;

    RomSetReceiveStatus(
        UdpUnicastDestinationPort,
        UdpMulticastDestinationPort,
        UdpMulticastDestinationAddress,
        UdpMulticastSourcePort,
        UdpMulticastSourceAddress
        );

    return;

} // UdpSetMulticastPort
#endif


ULONG
UdpReceive (
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG RemoteHost,
    OUT PUSHORT RemotePort,
    IN ULONG Timeout
    )

//
// Read in packet from the specified socket. The host and port
// the packet comes from is filled in fhost and fport.
// The data is put in buffer buf, which should have size len. If no packet
// arrives in tmo seconds, then 0 is returned.
// Otherwise it returns the size of the packet read.
//

{
    return RomReceiveUdpPacket( Buffer, BufferLength, Timeout, RemoteHost, RemotePort );

} // UdpReceive


ULONG
UdpSend (
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG RemoteHost,
    IN USHORT RemotePort
    )

//
// writes a packet to the specified socket. The host and port the packet
// should go to should be in fhost and fport
// The data should be put in buffer buf, and should have size len.
// It usually returns the number of characters sent, or -1 on failure.
//

{
    return RomSendUdpPacket( Buffer, BufferLength, RemoteHost, RemotePort );

} // UdpSend
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\acpienab\idchange.h ===
#pragma once

DWORD
DwRegOpenKeyExWithAdminAccess(HKEY hkey,
			      LPCTSTR szSubKey,
			      DWORD samDesired,
                              HKEY* phkeySubKey,
			      PSECURITY_DESCRIPTOR* ppsd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\acpienab\acpienab.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       acpienab.cpp
//
//  Contents:   Functions to enable ACPI on a machine which has had NT5
//		installed in legacy mode
//
//  Notes:      
//
//  Author:     t-sdey   17 July 98
//
//----------------------------------------------------------------------------

#include <winnt32.h>
#include <devguid.h>
extern "C" {
  #include <cfgmgr32.h>
  #include "idchange.h"
}
#include "acpienab.h"
#include "acpirsrc.h"

// Global Variables
HINSTANCE g_hinst;
TCHAR g_ACPIENAB_INF[] = TEXT(".\\acpienab.inf");  // local directory
TCHAR g_LAYOUT_INF[] = TEXT("layout.inf");         // winnt\inf directory
TCHAR g_HAL_BACKUP[] = TEXT("hal-old.dll");


//+---------------------------------------------------------------------------
//
//  Function:   WinMain
//
//  Purpose:    Run everything
//
//  Arguments:  Standard WinMain arguments
//
//  Author:     t-sdey	27 July 98
//
//  Notes:      
//
int WINAPI WinMain(HINSTANCE hInstance,  
		   HINSTANCE hPrevInstance,  
		   LPSTR lpCmdLine,     
		   int nCmdShow)
{
   g_hinst = hInstance;
   
   // Enable ACPI
   ACPIEnable();
   
   return TRUE;
}


// ----------------------------------------------------------------------
//
// Function:  ACPIEnable
//
// Purpose:   This function performs the steps necessary to enable ACPI
//	      and bring the system to a point where the user can log in
//	      after rebooting.  It leaves finding "new" hardware to after
//	      the user has rebooted and logged in again.
//
// Arguments: 
//
// Returns:   S_OK if successful
//            S_FALSE if unsuccessful
//
// Author:    t-sdey     27 July 98
//
// Notes: 
//
HRESULT ACPIEnable()
{
   //
   // These steps are in order from least to most crucial to the stability
   // of the system, in case of errors.
   //
   // Step 1: Test to see if ACPI can be enabled and warn the user to close 
   //         everything else.
   // Step 2: Prepare a safe configuration in case of errors.
   // Step 3: Set up keyboard and mouse for use after reboot.  This involves
   //         removing them from the CriticalDeviceDatabase so that they will
   //         be reconfigured (according to the new ACPI layout) after reboot.
   //         The current keyboards and mice are in the CDD, but we must 
   //         populate it with all possibilities, because their HardwareIDs 
   //         will probably change once ACPI is enabled.
   // Step 4: Add new values to the registry:
   //         - Add ACPI to the CriticalDeviceDatabase
   //         - Add keyboards and mice to the CriticalDeviceDatabase
   //         - Enable ACPI in the registry
   // Step 5: Copy the ACPI driver.
   // Step 6: Copy the new HAL.
   // Step 7: Reboot.
   //


   //
   // Step 1: Test to see if ACPI can be enabled and warn the user to close
   //         everything else.
   //
   
   // Make sure the user has administrative access
   if (!IsAdministrator()) {
      DisplayDialogBox(ACPI_STR_ERROR_DIALOG_CAPTION,
		       ACPI_STR_ADMIN_ACCESS_REQUIRED,
		       MB_OK | MB_ICONERROR);
      return S_FALSE;
   }

   // Test to see if ACPI is supported on this architecture
   SYSTEM_INFO SystemInfo;  // Will be used later to determine HAL
   GetSystemInfo(&SystemInfo);
   if (SystemInfo.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) {
      // Not supported
      DisplayDialogBox(ACPI_STR_ERROR_DIALOG_CAPTION,
		       ACPI_STR_NOT_SUPPORTED,
		       MB_OK | MB_ICONERROR);
      return S_FALSE;
   }

   // Warn the user to shut down any other programs
   if (DisplayDialogBox(ACPI_STR_WARNING_DIALOG_CAPTION,
			ACPI_STR_SHUTDOWN_WARNING,
			MB_YESNO | MB_ICONWARNING) == IDNO) {
      // The user cancelled
      return S_FALSE;
   }


   //
   // Step 2: Prepare a safe configuration in case of errors.
   //

   // Make a backup copy of the old HAL

   // Get location of the system directory
   TCHAR* szSystemDir = new TCHAR[MAX_PATH+1];
   if (!szSystemDir) {
      // Out of memory
      DisplayGenericErrorAndUndoChanges(); 
      return S_FALSE;
   }
   UINT uiSysDirLen = GetSystemDirectory(szSystemDir, MAX_PATH+1);
   if (uiSysDirLen == 0) {
      // Some error occurred
      DisplayGenericErrorAndUndoChanges(); 
      if (szSystemDir) delete[] szSystemDir;
      return S_FALSE;
   }
      
   // Assemble strings with the locations of the current and backup file
   TCHAR szHal[] = TEXT("hal.dll");
   TCHAR* szHalCurrent = new TCHAR[uiSysDirLen + lstrlen(szHal) + 1];
   TCHAR* szHalBackup = new TCHAR[uiSysDirLen + lstrlen(g_HAL_BACKUP) + 1];
   if (!szHalCurrent || !szHalBackup) {
      // Out of memory
      DisplayGenericErrorAndUndoChanges();
      delete[] szSystemDir;
      if (szHalCurrent) delete[] szHalCurrent;
      if (szHalBackup) delete[] szHalBackup;
      return S_FALSE;
   }
   _tcscpy(szHalCurrent, szSystemDir);
   _tcscat(szHalCurrent, TEXT("\\"));
   _tcscat(szHalCurrent, szHal);
   _tcscpy(szHalBackup, szSystemDir);
   _tcscat(szHalBackup, TEXT("\\"));
   _tcscat(szHalBackup, g_HAL_BACKUP);

   // Copy the HAL
   if (CopyFile(szHalCurrent, szHalBackup, FALSE) == FALSE) {
      // Error copying file
      DisplayGenericErrorAndUndoChanges();
      delete[] szSystemDir;
      delete[] szHalCurrent;
      delete[] szHalBackup;
      return S_FALSE;
   }
   
   delete[] szSystemDir;
   delete[] szHalCurrent;
   delete[] szHalBackup;
   

   // Make it possible to boot with the backup HAL if necessary
   
   // Find the system partition letter

   // Edit boot.ini
   //   -- add new NT5 boot line with "\HAL=hal-old.dll" on the end
   
   // Temporary: tell the user to do it manually
   MessageBox(NULL,
	      TEXT("If you want to ensure that you can recover if this process fails,\nadd a line to your boot.ini with \" /HAL=hal-old.dll\""),
	      TEXT("This is a temporary hack!"),
	      MB_ICONWARNING | MB_OK);



   //
   // Step 3: Set up keyboard and mouse for use after reboot.  This involves
   //         removing them from the CriticalDeviceDatabase so that they will
   //         be reconfigured (according to the new ACPI layout) after reboot.
   //         The current keyboards and mice are in the CDD, but we must 
   //         populate it with all possibilities, because their HardwareIDs 
   //         will probably change once ACPI is enabled.
   //

   //  Set up keyboard(s) for use after reboot
   if (RegDeleteDeviceKey(&GUID_DEVCLASS_KEYBOARD) == FALSE) {
      // Error
      DisplayGenericErrorAndUndoChanges();
      return S_FALSE;
   }

   //  Set up mouse (mice) for use after reboot
   if (RegDeleteDeviceKey(&GUID_DEVCLASS_MOUSE) == FALSE) {
      // Error
      DisplayGenericErrorAndUndoChanges();
      return S_FALSE;
   }

   
   
   //
   // Step 4: Add new values to the registry:
   //         - Add ACPI to the CriticalDeviceDatabase
   //         - Add keyboards and mice to the CriticalDeviceDatabase
   //         - Enable ACPI in the registry
   //

   if (InstallRegistryAndFilesUsingInf(g_ACPIENAB_INF,
				       TEXT("ACPI_REGISTRY.Install")) == 0) {
      // Error
      DisplayGenericErrorAndUndoChanges();
      return S_FALSE;
   }



   //
   // Step 5: Copy the ACPI driver.
   //
   
   // Copy the ACPI driver to the system directory
   if (InstallRegistryAndFilesUsingInf(g_ACPIENAB_INF,
				       TEXT("ACPI_DRIVER.Install")) == 0) {
      // Error
      DisplayGenericErrorAndUndoChanges();
      return S_FALSE;
   }



   //
   // Step 6: Copy the new HAL.
   //
   
   // Determine which HAL will be needed

   TCHAR szHalInstall[50];
   int HAL = 0;
   
   // Determine if it's a single or multi-processor machine
   BOOL SingleProc = (SystemInfo.dwNumberOfProcessors == 1);
   if (SingleProc) {
      HAL += 2;
   }
   
   // Determine if it's a PIC or APIC machine
   BOOL PIC = TRUE;
   if (!SingleProc) {  // Don't run the UsePICHal function unless we have to
      PIC = FALSE;
   } else {
      if (UsePICHal(&PIC) == FALSE) {
	 // An error occurred
	 DisplayGenericErrorAndUndoChanges();
	 return S_FALSE;
      }
   }
   if (PIC) {
      HAL += 1;
   }

   // Lookup table for HALs
   switch (HAL) {
   case 3: // x86 1-proc PIC
      _tcscpy(szHalInstall, TEXT("INTEL_1PROC_PIC_HAL"));
      break;
   case 2: // x86 1-proc APIC
      _tcscpy(szHalInstall, TEXT("INTEL_1PROC_APIC_HAL"));
      break;
   case 1: // x86 multi-proc PIC -- doesn't exist...
      _tcscpy(szHalInstall, TEXT("INTEL_MULTIPROC_PIC_HAL"));
      break;
   case 0: // x86 multi-proc APIC
      _tcscpy(szHalInstall, TEXT("INTEL_MULTIPROC_APIC_HAL"));
      break;
   }
   _tcscat(szHalInstall, TEXT(".Install"));

   // Copy the HAL to the system directory
   if (InstallRegistryAndFilesUsingInf(g_ACPIENAB_INF, szHalInstall) == 0) {
      // Error
      DisplayGenericErrorAndUndoChanges();
      return S_FALSE;
   }



   //
   // Step 7: Reboot.
   //

   // Warn the user that we're going to reboot
   DisplayDialogBox(ACPI_STR_REBOOT_DIALOG_CAPTION,
		    ACPI_STR_REBOOT_WARNING,
		    MB_OK);

   // Get shutdown privilege by opening the process token and adjusting its
   // privileges.
   HANDLE hToken;
   TOKEN_PRIVILEGES tkp;
   if (!OpenProcessToken(GetCurrentProcess(),
			 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
			 &hToken)) {
      // Could not open process token.  Tell the user to reboot manually.
      DisplayDialogBox(ACPI_STR_REBOOT_DIALOG_CAPTION,
		       ACPI_STR_REBOOT_ERROR,
		       MB_OK);
      return S_OK;
   }									
   LookupPrivilegeValue(NULL,
			SE_SHUTDOWN_NAME,
			&tkp.Privileges[0].Luid);
   tkp.PrivilegeCount = 1;
   tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
   AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);

   // Reboot
   if (ExitWindowsEx(EWX_REBOOT | EWX_FORCEIFHUNG, 0) == 0) {
      // An error occurred.  Tell the user to reboot manually.
	 DisplayDialogBox(ACPI_STR_REBOOT_DIALOG_CAPTION,
			  ACPI_STR_REBOOT_ERROR,
			  MB_OK);
   }

   return S_OK;

}


//+---------------------------------------------------------------------------
//
//  Function:   InstallRegistryAndFilesUsingInf
//
//  Purpose:    Open an INF file and perform the registry addition/deletion and
//              file copy operations specified there under a given install 
//              section.
//
//  Arguments:  szInfFileName    [in]    Name of INF file to open
//                                       (should be located in system inf 
//					 directory)
//		szInstallSection [in]    Install section (in INF) to use
//
//  Returns:    TRUE if successful
//              FALSE otherwise
//
//  Author:     t-sdey    14 Aug 98
//
//  Notes:      
//
BOOL InstallRegistryAndFilesUsingInf(IN LPCTSTR szInfFileName,
				     IN LPCTSTR szInstallSection)
{
   HINF hinf;

   //
   // Prepare the file queue
   //

   // Create a file queue
   HSPFILEQ FileQueue = SetupOpenFileQueue();
   if(!FileQueue || (FileQueue == INVALID_HANDLE_VALUE)) {
      // Error
      return FALSE;
   }

   // Initialize the queue callback function
   HWND Window = NULL;
   VOID* DefaultContext = SetupInitDefaultQueueCallback(Window);


   //
   // Open the INF file and perform file installation
   //

   // Open the source INF
   hinf = SetupOpenInfFile(szInfFileName, TEXT("System"), INF_STYLE_WIN4, NULL);
   if (hinf == INVALID_HANDLE_VALUE) {
      // Error
      SetupCloseFileQueue(FileQueue);
      return FALSE;
   }
      
   // Append the layout INF to get the source location for the files
   if (SetupOpenAppendInfFile(g_LAYOUT_INF, hinf, NULL) == FALSE) {
      // Could not open file
      SetupCloseInfFile(hinf);
      SetupCloseFileQueue(FileQueue);
      return FALSE;
   }

   // Read the INF and perform the actions it dictates
   if (SetupInstallFromInfSection(NULL,
				  hinf,
				  szInstallSection,
				  SPINST_REGISTRY | SPINST_FILES,
				  HKEY_LOCAL_MACHINE,
				  NULL,  // Source root path
				  SP_COPY_WARNIFSKIP,
				  (PSP_FILE_CALLBACK)SetupDefaultQueueCallback,
				  DefaultContext,
				  NULL,
				  NULL) == 0) {
      // Error
      SetupCloseInfFile(hinf);
      SetupCloseFileQueue(FileQueue);
      return FALSE;
   }

   // Commit the file queue to make sure all queued file copies are performed
   if (SetupCommitFileQueue(NULL,
			    FileQueue,
			    (PSP_FILE_CALLBACK)SetupDefaultQueueCallback,
			    DefaultContext) == 0) {
      // Error
      SetupCloseInfFile(hinf);
      SetupCloseFileQueue(FileQueue);
      return FALSE;
   }

   // Clean up
   SetupCloseInfFile(hinf);
   SetupCloseFileQueue(FileQueue);

   return TRUE;
} 


//+---------------------------------------------------------------------------
//
//  Function:   RegDeleteDeviceKey
//
//  Purpose:    All devices described by guid are removed from the device 
//              tree (HKLM\SYSTEM\CurrentControlSet\Enum\Root).
//              This forces them to be reconfigured on reboot.
//
//  Arguments:  guid  [in]  GUID of device class
//
//  Returns:    TRUE if successful.
//              FALSE otherwise.
//
//  Author:     t-sdey    14 Aug 98
//
//  Notes:      
//
BOOL RegDeleteDeviceKey(IN const GUID* guid)
{
   // Open the Root key under Enum with administrative access
   HKEY hkey = NULL;
   TCHAR szEnumRoot[] = TEXT("SYSTEM\\CurrentControlSet\\Enum\\Root");
   PSECURITY_DESCRIPTOR psdOriginal = NULL;
   if (DwRegOpenKeyExWithAdminAccess(HKEY_LOCAL_MACHINE,
				     szEnumRoot,
				     KEY_ALL_ACCESS,
				     &hkey,
				     &psdOriginal) != ERROR_SUCCESS) {
      // Error
      RegCloseKey(hkey);
      return FALSE;
   }

   // Get the list of devices with this GUID on the system. Remove each 
   // of them from the device tree, so that the next time the computer boots 
   // it is re-detected and re-configured for the new ACPI setup.
   // (Otherwise the device will be configured incorrectly.)
   
   // Get the list of devices with this GUID on the system
   HDEVINFO hdiDeviceClass = SetupDiGetClassDevs(guid, NULL, NULL, 0);
   
   // Prepare data structures for loop
   SP_DEVINFO_DATA DeviceInfoData;
   DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
   DWORD dwIndex = 0;
   unsigned long BufferMax = 5000;  // 5000 chars better be enough for the HID!
   unsigned long BufferLen;
   TCHAR* szHardwareID = new TCHAR[BufferMax];
   if (szHardwareID == NULL) {
      // Out of memory
      DisplayGenericErrorAndUndoChanges();
      SetupDiDestroyDeviceInfoList(hdiDeviceClass);
      if (psdOriginal) delete psdOriginal;
      RegCloseKey(hkey);
      return FALSE;
   }

   // Loop for each device with this GUID
   while (SetupDiEnumDeviceInfo(hdiDeviceClass, dwIndex, &DeviceInfoData)) {
      // Get the Hardware ID
      BufferLen = BufferMax;
      if (CM_Get_DevInst_Registry_Property_Ex(DeviceInfoData.DevInst,
					      CM_DRP_HARDWAREID,
					      NULL,
					      szHardwareID,
					      &BufferLen,
					      0,
					      0) != CR_SUCCESS) {
	 // Error
	 DisplayGenericErrorAndUndoChanges();
	 SetupDiDestroyDeviceInfoList(hdiDeviceClass);
	 if (szHardwareID) delete[] szHardwareID;
	 if (psdOriginal) delete psdOriginal;
	 RegCloseKey(hkey);
	 return FALSE;
      }
   
      // Remove from the device tree
      if (RegDeleteKeyAndSubkeys(hkey, szHardwareID, TRUE) != ERROR_SUCCESS) {
	 // Error
	 DisplayGenericErrorAndUndoChanges();
         SetupDiDestroyDeviceInfoList(hdiDeviceClass);
	 if (szHardwareID) delete[] szHardwareID;
	 if (psdOriginal) delete psdOriginal;
	 RegCloseKey(hkey);
	 return FALSE;
      }

      dwIndex++;
   }
   
   // Reset the security on the Root key
   if (psdOriginal) {
      RegSetKeySecurity(hkey,
			(SECURITY_INFORMATION) (DACL_SECURITY_INFORMATION),
			psdOriginal);
      delete psdOriginal;
   }

   // Clean up
   SetupDiDestroyDeviceInfoList(hdiDeviceClass);
   if (szHardwareID)
      delete[] szHardwareID;
   if (hkey)
      RegCloseKey(hkey);

   return TRUE;
}

   
//+---------------------------------------------------------------------------
//
//  Function:   DisplayGenericErrorAndUndoChanges
//
//  Purpose:    Pop up a message box with a generic error message and then
//              undo as many changes as possible.  Basically, used to recover
//              from errors which occur before ACPI is fully enabled.
//
//  Arguments:  
//
//  Author:     t-sdey	31 July 98
//
//  Notes:      
//
void DisplayGenericErrorAndUndoChanges()
{
   // Give a generic error message
   DisplayDialogBox(ACPI_STR_ERROR_DIALOG_CAPTION,
		    ACPI_STR_GENERAL_ERROR_MESSAGE,
		    MB_OK | MB_ICONERROR);
   
   // Remove new entries from the CriticalDeviceDatabase
   InstallRegistryAndFilesUsingInf(g_ACPIENAB_INF,
				   TEXT("ACPI_UNDO_CHANGES.Install"));
   
}


//+---------------------------------------------------------------------------
//
//  Function:   DisplayDialogBox
//
//  Purpose:    Display a popup informing the user of a warning or error.
//
//  Arguments:  dwCaptionID  [in]    the ID of the caption for the window
//              dwMessageID  [in]    the ID of the message to display
//              uiBoxType    [in]    the type of box to use
//
//  Returns:    integer flag, as would be returned by MessageBox
//
//  Author:     t-sdey    28 July 98
//
//  Notes:
//
int DisplayDialogBox(IN DWORD dwCaptionID,
		     IN DWORD dwMessageID,
		     IN UINT uiBoxType)
{
   // Prepare the strings
   TCHAR szCaption[512];
   TCHAR szMessage[5000];
   if(!LoadString(g_hinst, dwCaptionID, szCaption, 512)) {
      szCaption[0] = 0;
   }
   if(!LoadString(g_hinst, dwMessageID, szMessage, 5000)) {
      szMessage[0] = 0;
   }

   // Create the dialog box
   return (MessageBox(NULL, szMessage, szCaption, uiBoxType));
}


//+---------------------------------------------------------------------------
//
//  Function:   RegDeleteKeyAndSubkeys
//
//  Purpose:    (Recursively) Remove a registry key and all of its subkeys
//
//  Arguments:  hKey        [in]    Handle to an open registry key
//              lpszSubKey  [in]    Name of a subkey to be deleted along with all
//                                    of its subkeys
//              UseAdminAccess [in] Flag to indicate whether or not to try to
//                                    use administrative access
//
//  Returns:    ERROR_SUCCESS if entire subtree was successfully deleted.
//              ERROR_ACCESS_DENIED if given subkey could not be deleted.
//
//  Author:     t-sdey    15 July 98
//
//  Notes:      Modified from regedit.
//              This specifically does not attempt to deal rationally with the
//              case where the caller may not have access to some of the subkeys
//              of the key to be deleted.  In this case, all the subkeys which
//              the caller can delete will be deleted, but the api will still
//              return ERROR_ACCESS_DENIED.
//
LONG RegDeleteKeyAndSubkeys(IN HKEY hKey,
			    IN LPTSTR lpszSubKey,
			    IN BOOL UseAdminAccess)
{
    DWORD i;
    HKEY Key;
    LONG Status;
    DWORD dwStatus;
    DWORD ClassLength=0;
    DWORD SubKeys;
    DWORD MaxSubKey;
    DWORD MaxClass;
    DWORD Values;
    DWORD MaxValueName;
    DWORD MaxValueData;
    DWORD SecurityLength;
    FILETIME LastWriteTime;
    LPTSTR NameBuffer;
    PSECURITY_DESCRIPTOR psdOriginal = NULL;  // used to remember security settings

    //
    // First open the given key so we can enumerate its subkeys
    //
    if (UseAdminAccess) {
       dwStatus = DwRegOpenKeyExWithAdminAccess(hKey,
						lpszSubKey,
						KEY_ALL_ACCESS,
						&Key,
						&psdOriginal);
       if (dwStatus == ERROR_SUCCESS) {
	  Status = ERROR_SUCCESS;
       } else {
	  Status = !(ERROR_SUCCESS);  // It just has to be something else
       }
    } else {
       Status = RegOpenKeyEx(hKey,
			     lpszSubKey,
			     0,
			     KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
			     &Key);
    }

    if (Status != ERROR_SUCCESS) {
        //
        // possibly we have delete access, but not enumerate/query.
        // So go ahead and try the delete call, but don't worry about
        // any subkeys.  If we have any, the delete will fail anyway.
        //
	Status = RegDeleteKey(hKey, lpszSubKey);
	if (psdOriginal) {
	   // Make sure to reset the subkey security -- probably a paranoid check
	   RegSetKeySecurity(Key,
			     (SECURITY_INFORMATION) (DACL_SECURITY_INFORMATION),
			     psdOriginal);
	   free(psdOriginal);
	}
	return(Status);
    }

    //
    // Use RegQueryInfoKey to determine how big to allocate the buffer
    // for the subkey names.
    //
    Status = RegQueryInfoKey(Key,
                             NULL,
                             &ClassLength,
                             0,
                             &SubKeys,
                             &MaxSubKey,
                             &MaxClass,
                             &Values,
                             &MaxValueName,
                             &MaxValueData,
                             &SecurityLength,
                             &LastWriteTime);
    if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_MORE_DATA) &&
        (Status != ERROR_INSUFFICIENT_BUFFER)) {
       // Make sure to reset the subkey security
       if (psdOriginal) {
	  RegSetKeySecurity(Key,
			    (SECURITY_INFORMATION) (DACL_SECURITY_INFORMATION),
			    psdOriginal);
	  free(psdOriginal);
       }

       RegCloseKey(Key);
       return(Status);
    }

    NameBuffer = (LPTSTR) LocalAlloc(LPTR, (MaxSubKey + 1)*sizeof(TCHAR));
    if (NameBuffer == NULL) {
       // Make sure to reset the subkey security
       if (psdOriginal) {
	  RegSetKeySecurity(Key,
			    (SECURITY_INFORMATION) (DACL_SECURITY_INFORMATION),
			    psdOriginal);
	  free(psdOriginal);
       }
        
       RegCloseKey(Key);
       return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate subkeys and apply ourselves to each one.
    //
    i=0;
    do {
        Status = RegEnumKey(Key, i, NameBuffer, MaxSubKey+1);
        if (Status == ERROR_SUCCESS) {
	   Status = RegDeleteKeyAndSubkeys(Key, NameBuffer, UseAdminAccess);
        }

        if (Status != ERROR_SUCCESS) {
            //
            // Failed to delete the key at the specified index.  Increment
            // the index and keep going.  We could probably bail out here,
	    // since the api is going to fail, but we might as well keep
            // going and delete everything we can.
            //
	    ++i;
        }

    } while ((Status != ERROR_NO_MORE_ITEMS) && (i < SubKeys));
  
    LocalFree((HLOCAL) NameBuffer);
    RegCloseKey(Key);

    // Delete the key
    Status = RegDeleteKey(hKey, lpszSubKey);

    if (psdOriginal)
       free(psdOriginal);

    return (Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsAdministrator
//
//  Purpose:    Determine whether or not the current user has administrative
//              access to the system.
//
//  Arguments:  
//
//  Returns:    TRUE if the current user has administrative access
//              FALSE otherwise
//
//  Author:     t-sdey    17 Aug 98
//
//  Notes:      Copied from \nt\private\tapi\tomahawk\admin\setup\admin.c
//
BOOL IsAdministrator()
{
    PTOKEN_GROUPS           ptgGroups;
    DWORD                   dwSize, dwBufferSize;
    HANDLE                  hThread;
    HANDLE                  hAccessToken;
    PSID                    psidAdministrators;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    UINT                    x;
    BOOL                    bResult = FALSE;
    

    dwSize = 1000;
    ptgGroups = (PTOKEN_GROUPS)GlobalAlloc(GPTR, dwSize);
    hThread = GetCurrentProcess();
    if (!(OpenProcessToken(hThread,
			   TOKEN_READ,
			   &hAccessToken))) {
        CloseHandle(hThread);
        return FALSE;
    }

    dwBufferSize = 0;
    while (TRUE)
    {
        if (GetTokenInformation(hAccessToken,
                                TokenGroups,
                                (LPVOID)ptgGroups,
                                dwSize,
                                &dwBufferSize)) {
            break;
        }

        if (dwBufferSize > dwSize) {
            GlobalFree(ptgGroups);
            ptgGroups = (PTOKEN_GROUPS)GlobalAlloc(GPTR, dwBufferSize);
            dwSize = dwBufferSize;
        } else {
            CloseHandle(hThread);
            CloseHandle(hAccessToken);
            return FALSE;
        }
    }

    if ( !(AllocateAndInitializeSid(&siaNtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &psidAdministrators))) {
        CloseHandle(hThread);
        CloseHandle(hAccessToken);
        GlobalFree( ptgGroups );
        return FALSE;
    }

    for (x = 0; x < ptgGroups->GroupCount; x++) {
        if (EqualSid(psidAdministrators, ptgGroups->Groups[x].Sid)) {
            bResult = TRUE;
            break;
        }
    }

    FreeSid(psidAdministrators);
    CloseHandle(hAccessToken);
    CloseHandle(hThread);
    GlobalFree(ptgGroups);

    return bResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   UsePICHal
//
//  Purpose:    Determine whether this is a PIC machine or not (not=APIC).
//
//  Arguments:  pPIC  [out]  A flag saying whether or not the machine is a PIC
//                           machine.  If it is (and there are no errors) then
//                           pPIC will be set to TRUE.  If it is an APIC machine
//                           pPIC will be FALSE.
//
//  Returns:    TRUE if test was successful
//              FALSE if an error occurred
//
//  Author:     t-sdey    20 Aug 98
//
//  Notes:      
//
BOOL UsePICHal(IN BOOL* PIC)
{
   *PIC = TRUE;

   // Find out which HAL was installed during setup by looking at
   // winnt\repair\setup.log.

   //
   // Determine the location of the setup log
   //

   // Determine the location of the windows directory
   TCHAR* szLogPath = new TCHAR[MAX_PATH+1];
   if (!szLogPath) {
      // Out of memory
      return FALSE;
   }
   if (GetWindowsDirectory(szLogPath, MAX_PATH+1) == 0) {
      // Some error occurred
      if (szLogPath) delete[] szLogPath;
      return FALSE;
   }
	 
   // Complete the log path
   _tcscat(szLogPath, TEXT("\\repair\\setup.log"));

   //
   // Get the string describing the HAL that was used in setup
   //

   TCHAR szSetupHal[100];
   int numchars= GetPrivateProfileString(TEXT("Files.WinNt"),
					 TEXT("\\WINNT\\system32\\hal.dll"),
					 TEXT("DEFAULT"),
					 szSetupHal,
					 100,
					 szLogPath);
   if (numchars == 0) {
      // Could not get string
      if (szLogPath) delete[] szLogPath;
      return FALSE;
   }

   //
   // Determine if the APIC HAL was installed
   //

   // Test to see if the string is "halapic.dll"
   TCHAR szApicHal[] = TEXT("halapic.dll");
   szSetupHal[lstrlen(szApicHal)] = 0;  // make sure it's null-terminated
   if (_tcsstr(szSetupHal, szApicHal) != NULL) {
      // They match...  It's an APIC HAL
      *PIC = FALSE;
   }

   delete[] szLogPath;
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\acpienab\acpirsrc.h ===
// Used by acpienab.rc
#define ACPI_STR_WARNING_DIALOG_CAPTION	1000
#define ACPI_STR_SHUTDOWN_WARNING	1001
#define ACPI_STR_ERROR_DIALOG_CAPTION	1002
#define ACPI_STR_GENERAL_ERROR_MESSAGE	1003
#define ACPI_STR_NOT_SUPPORTED		1004
#define ACPI_STR_ADMIN_ACCESS_REQUIRED	1005
#define ACPI_STR_REBOOT_DIALOG_CAPTION	1006
#define ACPI_STR_REBOOT_WARNING		1007
#define ACPI_STR_REBOOT_ERROR		1008
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\acpienab\makefile.inc ===
acpienab.inf: acpienab.inx acpienab.txt
    copy acpienab.inx+acpienab.txt $@
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\acpienab\acpienab.h ===
#pragma once
#ifndef _ACPIENAB_H
#define _ACPIENAB_H

/* ----------------------------------------------------------------------

Copyright (c) 1998 Microsoft Corporation

Module Name:

    acpienab.h

Abstract:

    Header file for Windows NT DLL which enables ACPI on systems on which
    NT5 has been installed in legacy mode.

Author:

    Susan Dey : 27 July 98

Revision History:

 ---------------------------------------------------------------------- */

// Copy char to wide or char...  (Note: ToSize in wide characters)
#if (defined(_UNICODE) || defined(UNICODE ))
#define CHAR2TCHAR(From, To, ToSize) \
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, From, -1, To, ToSize)
#else
#define CHAR2TCHAR(From, To, ToSize) \
	strcpy(To, From)
#endif  // _UNICODE


// Functions
HRESULT ACPIEnable ();
LONG RegDeleteKeyAndSubkeys(HKEY hKey, LPTSTR lpszSubKey, BOOL UseAdminAccess);
int DisplayDialogBox(DWORD dwCaptionID, DWORD dwMessageID, UINT uiBoxType);
BOOL InstallRegistryAndFilesUsingInf(LPCTSTR szInfFileName,
				     LPCTSTR szInstallSection);
BOOL RegDeleteDeviceKey(IN const GUID* guid);
void DisplayGenericErrorAndUndoChanges();
BOOL IsAdministrator(void);
BOOL UsePICHal(IN BOOL* PIC);


// Variables
extern HINSTANCE g_hinst;

#endif // _ACPIENAB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\acpins.c ===
/*** acpins.c - ACPI Name Space functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     10/18/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***LP  InitNameSpace - Initialize NameSpace
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL InitNameSpace(VOID)
{
    int rc = ASLERR_NONE;

    ENTER((1, "InitNameSpace()\n"));

    if ((rc = CreateNameSpaceObj(NULL, "\\", NULL, NULL, NULL, NSF_EXIST_ERR))
        == ASLERR_NONE)
    {
        static struct _defobj {
            PSZ   pszName;
            USHORT dwObjType;
        } DefinedRootObjs[] = {
            "_GPE", OBJTYPE_UNKNOWN,
            "_PR",  OBJTYPE_UNKNOWN,
            "_SB",  OBJTYPE_UNKNOWN,
            "_SI",  OBJTYPE_UNKNOWN,
            "_TZ",  OBJTYPE_UNKNOWN,
            "_REV", OBJTYPE_INTDATA,
            "_OS",  OBJTYPE_STRDATA,
            "_GL",  OBJTYPE_MUTEX,
            NULL,   0
        };
        int i;
        PNSOBJ pns;

        gpnsCurrentScope = gpnsNameSpaceRoot;

        for (i = 0; DefinedRootObjs[i].pszName != NULL; ++i)
        {
            if ((rc = CreateNameSpaceObj(NULL, DefinedRootObjs[i].pszName, NULL,
                                         NULL, &pns, NSF_EXIST_ERR)) ==
                ASLERR_NONE)
            {
                pns->ObjData.dwDataType = DefinedRootObjs[i].dwObjType;
            }
            else
            {
                break;
            }
        }
    }

    EXIT((1, "InitNameSpace=%d\n", rc));
    return rc;
}       //InitNameSpace

/***LP  GetNameSpaceObj - Find a name space object
 *
 *  ENTRY
 *      pszObjPath -> name path string
 *      pnsScope -> scope to start the search (NULL means root)
 *      ppns -> to hold the nsobj pointer found
 *      dwfNS - flags
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL GetNameSpaceObj(PSZ pszObjPath, PNSOBJ pnsScope, PPNSOBJ ppns,
                          DWORD dwfNS)
{
    int rc = ASLERR_NONE;
    PSZ psz;

    ENTER((1, "GetNameSpaceObj(ObjPath=%s,Scope=%s,ppns=%p,Flags=%x)\n",
           pszObjPath, pnsScope? GetObjectPath(pnsScope): "", ppns, dwfNS));

    if (pnsScope == NULL)
        pnsScope = gpnsNameSpaceRoot;

    if (*pszObjPath == '\\')
    {
        psz = &pszObjPath[1];
        pnsScope = gpnsNameSpaceRoot;
    }
    else
    {
        psz = pszObjPath;

        while ((*psz == '^') && (pnsScope != NULL))
        {
            psz++;
            pnsScope = pnsScope->pnsParent;
        }
    }

    *ppns = pnsScope;

    if (pnsScope == NULL)
        rc = ASLERR_NSOBJ_NOT_FOUND;
    else if (*psz != '\0')
    {
        BOOL fSearchUp;
        PNSOBJ pns;

        fSearchUp = !(dwfNS & NSF_LOCAL_SCOPE) &&
                    (pszObjPath[0] != '\\') &&
                    (pszObjPath[0] != '^') &&
                    (strlen(pszObjPath) <= sizeof(NAMESEG));

        for (;;)
        {
            do
            {
                if ((pns = pnsScope->pnsFirstChild) == NULL)
                    rc = ASLERR_NSOBJ_NOT_FOUND;
                else
                {
                    BOOL fFound;
                    PSZ pszEnd;
                    DWORD dwLen;
                    NAMESEG dwName;

                    if ((pszEnd = strchr(psz, '.')) != NULL)
                        dwLen = (DWORD)(pszEnd - psz);
                    else
                        dwLen = strlen(psz);

                    if (dwLen > sizeof(NAMESEG))
                    {
                        ERROR(("GetNameSpaceObj: invalid name - %s",
                               pszObjPath));
                        rc = ASLERR_INVALID_NAME;
                        fFound = FALSE;
                    }
                    else
                    {
                        dwName = NAMESEG_BLANK;
                        memcpy(&dwName, psz, dwLen);
                        //
                        // Search all siblings for a matching NameSeg.
                        //
                        fFound = FALSE;
                        do
                        {
                            if (pns->dwNameSeg == dwName)
                            {
                                pnsScope = pns;
                                fFound = TRUE;
                                break;
                            }
                            pns = (PNSOBJ)pns->list.plistNext;
                        } while (pns != pns->pnsParent->pnsFirstChild);
                    }

                    if (rc == ASLERR_NONE)
                    {
                        if (!fFound)
                            rc = ASLERR_NSOBJ_NOT_FOUND;
                        else
                        {
                            psz += dwLen;
                            if (*psz == '.')
                            {
                                psz++;
                            }
                            else if (*psz == '\0')
                            {
                                *ppns = pnsScope;
                                break;
                            }
                        }
                    }
                }
            } while (rc == ASLERR_NONE);

            if ((rc == ASLERR_NSOBJ_NOT_FOUND) && fSearchUp &&
                (pnsScope != NULL) && (pnsScope->pnsParent != NULL))
            {
                pnsScope = pnsScope->pnsParent;
                rc = ASLERR_NONE;
            }
            else
            {
                break;
            }
        }
    }

    if (rc != ASLERR_NONE)
    {
        *ppns = NULL;
    }

    EXIT((1, "GetNameSpaceObj=%d (pns=%p)\n", rc, *ppns));
    return rc;
}       //GetNameSpaceObj

/***LP  CreateNameSpaceObj - Create a name space object under current scope
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      pszName -> name path string
 *      pnsScope -> scope to start the search (NULL means root)
 *      pnsOwner -> owner object
 *      ppns -> to hold the nsobj pointer found
 *      dwfNS - flags
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL CreateNameSpaceObj(PTOKEN ptoken, PSZ pszName, PNSOBJ pnsScope,
                             PNSOBJ pnsOwner, PPNSOBJ ppns, DWORD dwfNS)
{
    int rc = ASLERR_NONE;
    PNSOBJ pns;
  #ifndef _UNASM_LIB
    char szMsg[MAX_MSG_LEN + 1];
  #endif

    ENTER((1, "CreateNameSpaceObj(ptoken=%p,Name=%s,pnsScope=%s,pnsOwner=%p,ppns=%p,Flags=%x)\n",
           ptoken, pszName, pnsScope? GetObjectPath(pnsScope): "", pnsOwner,
           ppns, dwfNS));

  #ifdef _UNASM_LIB
    DEREF(ptoken);
  #endif

    ASSERT((pszName != NULL) && (*pszName != '\0'));

    if (pnsScope == NULL)
        pnsScope = gpnsNameSpaceRoot;

    if ((rc = GetNameSpaceObj(pszName, pnsScope, &pns, NSF_LOCAL_SCOPE)) ==
        ASLERR_NONE)
    {
        if (!(dwfNS & NSF_EXIST_OK))
        {
          #ifndef _UNASM_LIB
            if (ptoken != NULL)
            {
                sprintf(szMsg, "%s already exist", pszName);
                PrintTokenErr(ptoken, szMsg, dwfNS & NSF_EXIST_ERR);
            }
            else
            {
                ERROR(("%s: error: %s already exist",
                       gpszASLFile? gpszASLFile: gpszAMLFile, pszName));
            }
          #endif
            rc = ASLERR_NSOBJ_EXIST;
        }
    }
    else if (rc == ASLERR_NSOBJ_NOT_FOUND)
    {
        rc = ASLERR_NONE;
        //
        // Are we creating root?
        //
        if (strcmp(pszName, "\\") == 0)
        {
            ASSERT(gpnsNameSpaceRoot == NULL);
            ASSERT(pnsOwner == NULL);

            if ((pns = MEMALLOC(sizeof(NSOBJ))) == NULL)
            {
                ERROR(("CreateNameSpaceObj: fail to allocate name space object"));
                rc = ASLERR_OUT_OF_MEM;
            }
            else
            {
                memset(pns, 0, sizeof(NSOBJ));
                pns->dwNameSeg = NAMESEG_ROOT;
                pns->hOwner = (HANDLE)pnsOwner;
                gpnsNameSpaceRoot = pns;
            }
        }
        else
        {
            PSZ psz;
            PNSOBJ pnsParent;

            if ((psz = strrchr(pszName, '.')) != NULL)
            {
                *psz = '\0';
                psz++;
                if ((rc = GetNameSpaceObj(pszName, pnsScope, &pnsParent,
                                          NSF_LOCAL_SCOPE)) ==
                    ASLERR_NSOBJ_NOT_FOUND)
                {
                  #ifndef _UNASM_LIB
                    if (ptoken != NULL)
                    {
                        sprintf(szMsg, "parent object %s does not exist",
                                pszName);
                        PrintTokenErr(ptoken, szMsg, TRUE);
                    }
                    else
                    {
                        ERROR(("%s: error: parent object %s does not exist",
                               gpszASLFile? gpszASLFile: gpszAMLFile, pszName));
                    }
                  #endif
                }
            }
            else if (*pszName == '\\')
            {
                psz = &pszName[1];
                //
                // By this time, we'd better created root already.
                //
                ASSERT(gpnsNameSpaceRoot != NULL);
                pnsParent = gpnsNameSpaceRoot;
            }
            else if (*pszName == '^')
            {
                psz = pszName;
                pnsParent = pnsScope;
                while ((*psz == '^') && (pnsParent != NULL))
                {
                    pnsParent = pnsParent->pnsParent;
                    psz++;
                }
            }
            else
            {
                ASSERT(pnsScope != NULL);
                psz = pszName;
                pnsParent = pnsScope;
            }

            if (rc == ASLERR_NONE)
            {
                int iLen = strlen(psz);

                if ((*psz != '\0') && (iLen > sizeof(NAMESEG)))
                {
                    ERROR(("CreateNameSpaceObj: invalid name - %s", psz));
                    rc = ASLERR_INVALID_NAME;
                }
                else if ((pns = MEMALLOC(sizeof(NSOBJ))) == NULL)
                {
                    ERROR(("CreateNameSpaceObj: fail to allocate name space object"));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    memset(pns, 0, sizeof(NSOBJ));
                    pns->dwNameSeg = NAMESEG_BLANK;
                    memcpy(&(pns->dwNameSeg), psz, iLen);
                    pns->hOwner = (HANDLE)pnsOwner;
                    pns->pnsParent = pnsParent;
                    ListInsertTail(&pns->list,
                                   (PPLIST)&pnsParent->pnsFirstChild);
                }
            }
        }
    }

    if ((rc == ASLERR_NONE) && (ppns != NULL))
        *ppns = pns;

    EXIT((1, "CreateNameSpaceObj=%d (pns=%p)\n", rc, pns));
    return rc;
}       //CreateNameSpaceObj

/***LP  DumpNameSpacePaths - Dump all the name space object paths
 *
 *  ENTRY
 *      pnsObj -> name space subtree root
 *      pfileOut -> output device
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpNameSpacePaths(PNSOBJ pnsObj, FILE *pfileOut)
{
    PNSOBJ pns, pnsNext;

    ENTER((3, "DumpNameSpacePaths(pns=%x,pfileOut=%p)\n", pnsObj, pfileOut));
    //
    // First, dump myself
    //
    fprintf(pfileOut, "%13s: [%08x] %s",
            GetObjectTypeName(pnsObj->ObjData.dwDataType), pnsObj->dwRefCount,
            GetObjectPath(pnsObj));

    if (pnsObj->ObjData.dwDataType == OBJTYPE_METHOD)
    {
        fprintf(pfileOut, " (cArgs=%d)", pnsObj->ObjData.uipDataValue);
    }
    else if (pnsObj->ObjData.dwDataType == OBJTYPE_RES_FIELD)
    {
        fprintf(pfileOut, " (BitOffset=0x%x, BitSize=0x%x)",
                pnsObj->ObjData.uipDataValue, pnsObj->ObjData.dwDataLen);
    }

    fprintf(pfileOut, "%s\n", pnsObj->hOwner? "*": "");

    //
    // Then, recursively dump each of my children
    //
    for (pns = pnsObj->pnsFirstChild; pns != NULL; pns = pnsNext)
    {
        //
        // If this is the last child, we have no more.
        //
        if ((pnsNext = (PNSOBJ)pns->list.plistNext) == pnsObj->pnsFirstChild)
            pnsNext = NULL;
        //
        // Dump a child
        //
        DumpNameSpacePaths(pns, pfileOut);
    }

    EXIT((3, "DumpNameSpacePaths!\n"));
}       //DumpNameSpacePaths

/***LP  GetObjectPath - get object namespace path
 *
 *  ENTRY
 *      pns -> object
 *
 *  EXIT
 *      returns name space path
 */

PSZ LOCAL GetObjectPath(PNSOBJ pns)
{
    static char szPath[MAX_NSPATH_LEN + 1] = {0};
    int i;

    ENTER((4, "GetObjectPath(pns=%x)\n", pns));

    if (pns != NULL)
    {
        if (pns->pnsParent == NULL)
            strcpy(szPath, "\\");
        else
        {
            GetObjectPath(pns->pnsParent);
            if (pns->pnsParent->pnsParent != NULL)
            {
                strcat(szPath, ".");
            }
            strncat(szPath, (PSZ)&pns->dwNameSeg, sizeof(NAMESEG));
        }


        for (i = strlen(szPath) - 1; i >= 0; --i)
        {
            if (szPath[i] == '_')
                szPath[i] = '\0';
            else
                break;
        }
    }
    else
    {
        szPath[0] = '\0';
    }

    EXIT((4, "GetObjectPath=%s\n", szPath));
    return szPath;
}       //GetObjectPath

/***LP  GetObjectTypeName - get object type name
 *
 *  ENTRY
 *      dwObjType - object type
 *
 *  EXIT
 *      return object type name
 */

PSZ LOCAL GetObjectTypeName(DWORD dwObjType)
{
    PSZ psz = NULL;
    int i;
    static struct
    {
        ULONG dwObjType;
        PSZ   pszObjTypeName;
    } ObjTypeTable[] =
        {
            OBJTYPE_UNKNOWN,    "Unknown",
            OBJTYPE_INTDATA,    "Integer",
            OBJTYPE_STRDATA,    "String",
            OBJTYPE_BUFFDATA,   "Buffer",
            OBJTYPE_PKGDATA,    "Package",
            OBJTYPE_FIELDUNIT,  "FieldUnit",
            OBJTYPE_DEVICE,     "Device",
            OBJTYPE_EVENT,      "Event",
            OBJTYPE_METHOD,     "Method",
            OBJTYPE_MUTEX,      "Mutex",
            OBJTYPE_OPREGION,   "OpRegion",
            OBJTYPE_POWERRES,   "PowerResource",
            OBJTYPE_PROCESSOR,  "Processor",
            OBJTYPE_THERMALZONE,"ThermalZone",
            OBJTYPE_BUFFFIELD,  "BuffField",
            OBJTYPE_DDBHANDLE,  "DDBHandle",
            OBJTYPE_DEBUG,      "Debug",
            OBJTYPE_OBJALIAS,   "ObjAlias",
            OBJTYPE_DATAALIAS,  "DataAlias",
            OBJTYPE_BANKFIELD,  "BankField",
            OBJTYPE_FIELD,      "Field",
            OBJTYPE_INDEXFIELD, "IndexField",
            OBJTYPE_DATA,       "Data",
            OBJTYPE_DATAFIELD,  "DataField",
            OBJTYPE_DATAOBJ,    "DataObject",
            OBJTYPE_PNP_RES,    "PNPResource",
            OBJTYPE_RES_FIELD,  "ResField",
            0,                  NULL
        };

    ENTER((4, "GetObjectTypeName(Type=%x)\n", dwObjType));

    for (i = 0; ObjTypeTable[i].pszObjTypeName != NULL; ++i)
    {
        if (dwObjType == ObjTypeTable[i].dwObjType)
        {
            psz = ObjTypeTable[i].pszObjTypeName;
            break;
        }
    }

    EXIT((4, "GetObjectTypeName=%s\n", psz? psz: "NULL"));
    return psz;
}       //GetObjectTypeName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\acpienab\idchange.c ===
// Copied from \nt\private\net\config\upgrade\netupgrd
// August 98  --  t-sdey

#pragma hdrstop
#include <winnt32.h>
#include "idchange.h"



DWORD
DwRegKeySetAdministratorSecurity(HKEY hkey, DWORD samDesired,
                                 PSECURITY_DESCRIPTOR* ppsdOld);

DWORD
DwRegCreateOrOpenKeyExWithAdminAccess(HKEY hkey, LPCTSTR szSubKey,
                                      DWORD samDesired, 
                                      BOOL fCreate, HKEY* phkeySubKey,
                                      PSECURITY_DESCRIPTOR* ppsd);

DWORD
DwRegOpenKeyExWithAdminAccess(HKEY hkey, LPCTSTR szSubKey, DWORD samDesired,
                              HKEY* phkeySubKey, PSECURITY_DESCRIPTOR* ppsd)
{
    return DwRegCreateOrOpenKeyExWithAdminAccess(hkey, szSubKey, samDesired,
            FALSE, phkeySubKey, ppsd);
}


//+--------------------------------------------------------------------------
//
//  Function:   DwRegCreateOrOpenKeyExWithAdminAccess
//
//  Purpose:    Creates/Opens a subkey.  If the key exists but the local
//                  administrators group does not have samDesired access to 
//                  it, the function will add the access needed to the 
//                  security descriptor
//
//  Arguments:
//      hkeyParent [in]  The key to create the subkey in
//      szSubKey   [in]  The subkey name
//      samDesired [in]  The desired access for phkey
//      fCreate    [in]  TRUE if the key is to be created.  
//      phSubkey   [out] The handle to the subkey
//      ppsdOrig   [out] The previous security settings of the key
//                          if it already existed, optional
//
//  Returns:    DWORD. ERROR_SUCCESS or a failure code from winerror.h
//
//  Author:     billbe   15 Dec 1997
//
//  Notes:      
//
DWORD
DwRegCreateOrOpenKeyExWithAdminAccess(HKEY hkey, LPCTSTR szSubKey,
                                      DWORD samDesired, 
                                      BOOL fCreate, HKEY* phkeySubKey,
                                      PSECURITY_DESCRIPTOR* ppsd)
{
    DWORD dwError = ERROR_SUCCESS;

    if (ppsd)
    {
        *ppsd = NULL;
    }

    // Create or open the key based on fCreate
    //
    if (fCreate)
    {
        dwError = RegCreateKeyEx(hkey, szSubKey, 0, NULL,
                REG_OPTION_NON_VOLATILE, samDesired, NULL, phkeySubKey,
                NULL);
    }
    else
    {
        dwError = RegOpenKeyEx(hkey, szSubKey, 0, samDesired,
                phkeySubKey);
    }

    // If access was denied we either tried to create or open a prexisting 
    // key that we didn't have access to. We need to grant ourselves
    // permission.  
    //
    if (ERROR_ACCESS_DENIED == dwError)
    {
        // open with access to read and set security
        dwError = RegOpenKeyEx(hkey, szSubKey, 0,
            WRITE_DAC | READ_CONTROL, phkeySubKey);

        if (ERROR_SUCCESS == dwError)
        {
            // Grant samDesired access to the local Administrators group
            dwError = DwRegKeySetAdministratorSecurity(*phkeySubKey, samDesired,
                    ppsd);

            // Close and reopen the key with samDesired access
            RegCloseKey(*phkeySubKey);
            if (ERROR_SUCCESS == dwError)
            {
                dwError = RegOpenKeyEx(hkey, szSubKey, 0, samDesired,
                        phkeySubKey);
            }
        }
    }

    return dwError;
}


//+--------------------------------------------------------------------------
//
//  Function:   DwAddToRegKeySecurityDescriptor
//
//  Purpose:    Adds access for a specified SID to a registry key
//
//  Arguments:
//      hkey         [in]  The registry key that will receive the
//                            modified security descriptor
//      psidGroup    [in]  The SID (in self-relative mode) that will be 
//                            granted access to the key 
//      dwAccessMask [in]  The access level to grant
//      ppsd         [out] The previous security descriptor
//
//  Returns:    DWORD. ERROR_SUCCESS or a failure code from winerror.h
//
//  Author:     billbe   13 Dec 1997
//
//  Notes:      This function is based on AddToRegKeySD in the MSDN
//                  article Windows NT Security by Christopher Nefcy
//
DWORD 
DwAddToRegKeySecurityDescriptor(HKEY hkey, PSID psidGroup,
                                DWORD dwAccessMask,
                                PSECURITY_DESCRIPTOR* ppsd)
{ 
    PSECURITY_DESCRIPTOR        psdAbsolute = NULL;
    PACL                        pdacl;
    DWORD                       cbSecurityDescriptor = 0;
    DWORD                       dwSecurityDescriptorRevision;
    DWORD                       cbDacl = 0;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    PACL                        pdaclNew = NULL; 
    DWORD                       cbAddDaclLength = 0; 
    BOOL                        fAceFound = FALSE;
    BOOL                        fHasDacl  = FALSE;
    BOOL                        fDaclDefaulted = FALSE; 
    ACCESS_ALLOWED_ACE*         pAce;
    DWORD                       i;
    BOOL                        fAceForGroupPresent = FALSE;
    DWORD                       dwMask;
    PSECURITY_DESCRIPTOR        psdRelative = NULL;
    DWORD                       cbSize = 0;

    // Get the current security descriptor for hkey
    //
    DWORD dwError = RegGetKeySecurity(hkey, DACL_SECURITY_INFORMATION, 
            psdRelative, &cbSize);

    if (ERROR_INSUFFICIENT_BUFFER == dwError)
    {
        psdRelative = malloc(cbSize);
        
        dwError = RegGetKeySecurity(hkey, DACL_SECURITY_INFORMATION, 
                psdRelative, &cbSize);
    }

    // get security descriptor control from the security descriptor 
    if (!GetSecurityDescriptorControl(psdRelative, 
            (PSECURITY_DESCRIPTOR_CONTROL) &sdc,
             (LPDWORD) &dwSecurityDescriptorRevision))  
    {
         return (GetLastError());
    }

    // check if DACL is present 
    if (SE_DACL_PRESENT & sdc) 
    {
        // get dacl   
        if (!GetSecurityDescriptorDacl(psdRelative, (LPBOOL) &fHasDacl,
                (PACL *) &pdacl, (LPBOOL) &fDaclDefaulted))
        {
            return ( GetLastError());
        }
        // get dacl length  
        cbDacl = pdacl->AclSize;
        // now check if SID's ACE is there  
        for (i = 0; i < pdacl->AceCount; i++)  
        {
            if (!GetAce(pdacl, i, (LPVOID *) &pAce))
            {
                return ( GetLastError());   
            }
            // check if group sid is already there
            if (EqualSid((PSID) &(pAce->SidStart), psidGroup))    
            {
                // If the correct access is present, return success
                if ((pAce->Mask & dwAccessMask) == dwAccessMask)
                {
                    return ERROR_SUCCESS;
                }
                fAceForGroupPresent = TRUE;
                break;  
            }
        }
        // if the group did not exist, we will need to add room
        // for another ACE
        if (!fAceForGroupPresent)  
        {
            // get length of new DACL  
            cbAddDaclLength = sizeof(ACCESS_ALLOWED_ACE) - 
                sizeof(DWORD) + GetLengthSid(psidGroup); 
        }
    } 
    else
    {
        // get length of new DACL
        cbAddDaclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - 
            sizeof(DWORD) + GetLengthSid (psidGroup);
    }


    // get memory needed for new DACL
    pdaclNew = (PACL) malloc (cbDacl + cbAddDaclLength);
    if (!pdaclNew)
    {
        return (GetLastError()); 
    }

    // get the sd length
    cbSecurityDescriptor = GetSecurityDescriptorLength(psdRelative); 

    // get memory for new SD
    psdAbsolute = (PSECURITY_DESCRIPTOR) 
            malloc(cbSecurityDescriptor + cbAddDaclLength);
    if (!psdAbsolute) 
    {  
        dwError = GetLastError();
        goto ErrorExit; 
    }
    
    // change self-relative SD to absolute by making new SD
    if (!InitializeSecurityDescriptor(psdAbsolute, 
        SECURITY_DESCRIPTOR_REVISION)) 
    {  
        dwError = GetLastError();
        goto ErrorExit; 
    }
    
    // init new DACL
    if (!InitializeAcl(pdaclNew, cbDacl + cbAddDaclLength, 
           ACL_REVISION)) 
    {  
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // now add in all of the ACEs into the new DACL (if org DACL is there)
    if (SE_DACL_PRESENT & sdc) 
    {
        for (i = 0; i < pdacl->AceCount; i++)
        {   
            // get ace from original dacl
            if (!GetAce(pdacl, i, (LPVOID*) &pAce))   
            {
                dwError = GetLastError();    
                goto ErrorExit;   
            }
        
            // If an ACE for our SID exists, we just need to bump
            // up the access level instead of creating a new ACE
            //
            if (EqualSid((PSID) &(pAce->SidStart), psidGroup))    
                dwMask = dwAccessMask | pAce->Mask;
            else
                dwMask = pAce->Mask;

            // now add ace to new dacl   
            if (!AddAccessAllowedAce(pdaclNew, 
                    ACL_REVISION, dwMask,
                    (PSID) &(pAce->SidStart)))   
            {
                dwError = GetLastError();
                goto ErrorExit;   
            }  
        } 
    } 

    // Add a new ACE for our SID if one was not already present
    if (!fAceForGroupPresent)
    {
        // now add new ACE to new DACL
        if (!AddAccessAllowedAce(pdaclNew, ACL_REVISION, dwAccessMask,
                psidGroup)) 
        {  
            dwError = GetLastError();  
            goto ErrorExit; 
        }
    }

    // check if everything went ok 
    if (!IsValidAcl(pdaclNew)) 
    {
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // now set security descriptor DACL
    if (!SetSecurityDescriptorDacl(psdAbsolute, TRUE, pdaclNew, 
            fDaclDefaulted)) 
    {  
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // check if everything went ok 
    if (!IsValidSecurityDescriptor(psdAbsolute)) 
    {
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // now set the reg key security (this will overwrite any
    // existing security)
    dwError = RegSetKeySecurity(hkey, 
          (SECURITY_INFORMATION)(DACL_SECURITY_INFORMATION), psdAbsolute);

    if (ppsd)
    {
        *ppsd = psdRelative;
    }
ErrorExit: 
    // free memory
    if (psdAbsolute)  
    {
        free (psdAbsolute); 
        if (pdaclNew)
        {
            free((VOID*) pdaclNew); 
        }
    }

    return dwError;
}

//+--------------------------------------------------------------------------
//
//  Function:   DwRegKeySetAdministratorSecurity
//
//  Purpose:    Grants the local Administrators group full access to
//                  hkey.
//
//  Arguments:
//      hkey    [in]  The registry key
//      ppsdOld [out] The previous security descriptor for hkey
//
//  Returns:    DWORD. ERROR_SUCCESS or a failure code from winerror.h
//
//  Author:     billbe   13 Dec 1997
//
//  Notes:
//
DWORD
DwRegKeySetAdministratorSecurity(HKEY hkey, DWORD samDesired,
                                 PSECURITY_DESCRIPTOR* ppsdOld)
{
    PSID                     psid;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    DWORD                    dwError = ERROR_SUCCESS;

    // Get sid for the local Administrators group
    if (!AllocateAndInitializeSid(&sidAuth, 2,
            SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psid) ) 
    {
        dwError = GetLastError();
    }

    if (ERROR_SUCCESS == dwError)
    {
        // Add all access privileges for the local administrators group
        dwError = DwAddToRegKeySecurityDescriptor(hkey, psid, 
                samDesired, ppsdOld);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\acpins.h ===
/*** acpins.h - ACPI NameSpace definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/05/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _ACPINS_H
#define _ACPINS_H

// NS flags
#define NSF_EXIST_OK            0x00010000
#define NSF_EXIST_ERR           0x00020000

// Misc. constants
#define NAMESEG_BLANK           0x5f5f5f5f      // "____"
#define NAMESEG_ROOT            0x5f5f5f5c      // "\___"
#define SIG_RSDP                'PDSR'
#define SIG_LOW_RSDP            ' DSR'
#define SIG_BOOT                'TOOB'

//
// Local function prototypes
//
VOID LOCAL DumpNameSpacePaths(PNSOBJ pnsObj, FILE *pfileOut);
PSZ LOCAL GetObjectPath(PNSOBJ pns);
PSZ LOCAL GetObjectTypeName(DWORD dwObjType);

//
// Exported function prototypes
//
int LOCAL InitNameSpace(VOID);
int LOCAL GetNameSpaceObj(PSZ pszObjPath, PNSOBJ pnsScope, PPNSOBJ ppns,
                          DWORD dwfNS);
int LOCAL CreateNameSpaceObj(PTOKEN ptoken, PSZ pszName, PNSOBJ pnsScope,
                             PNSOBJ pnsOwner, PPNSOBJ ppns, DWORD dwfNS);

#endif  //ifndef _ACPINS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\aslp.h ===
/*** aslp.h - ASL Private Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/05/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _ASLP_H
#define _ASLP_H

/*** Constants
 */

// String constants
#define STR_PROGDESC            "ACPI Source Language Assembler"
#define STR_COPYRIGHT           "Copyright (c) 1996,1999 Microsoft Corporation"
#define STR_MS          "MSFT"

// Error codes
#define ASLERR_NONE             0
#define ASLERR_INVALID_PARAM    -1
#define ASLERR_OPEN_FILE        -2
#define ASLERR_CREATE_FILE      -3
#define ASLERR_READ_FILE        -4
#define ASLERR_WRITE_FILE       -5
#define ASLERR_SEEK_FILE        -6
#define ASLERR_INIT_SCANNER     -7
#define ASLERR_OUT_OF_MEM       -8
#define ASLERR_NAME_TOO_LONG    -9
#define ASLERR_NEST_DDB         -10
#define ASLERR_SYNTAX           -11
#define ASLERR_PKTLEN_TOO_LONG  -12
#define ASLERR_NAME_EXIST       -13
#define ASLERR_NSOBJ_EXIST      -14
#define ASLERR_NSOBJ_NOT_FOUND  -15
#define ASLERR_INVALID_NAME     -16
#define ASLERR_INTERNAL_ERROR   -17
#define ASLERR_INVALID_EISAID   -18
#define ASLERR_EXPECT_EOF       -19
#define ASLERR_INVALID_OPCODE   -20
#define ASLERR_SIG_NOT_FOUND    -21
#define ASLERR_GET_TABLE        -22
#define ASLERR_CHECKSUM         -23
#define ASLERR_INVALID_ARGTYPE  -24
#define ASLERR_INVALID_OBJTYPE  -25
#define ASLERR_OPEN_VXD         -26

// Misc. constants
#define VERSION_MAJOR           1
#define VERSION_MINOR           0
#define VERSION_RELEASE         14
#define VERSION_DWORD           ((VERSION_MAJOR << 24) | \
                                 (VERSION_MINOR << 16) | \
                                 VERSION_RELEASE)

// Implementation constants
#define MAX_STRING_LEN          199
#define MAX_NAMECODE_LEN        1300    //approx. 255*4 + 2 + 255
#define MAX_MSG_LEN             127
#define MAX_PACKAGE_LEN         0x0fffffff

// gdwfASL flags
#define ASLF_NOLOGO             0x00000001
#define ASLF_UNASM              0x00000002
#define ASLF_GENASM             0x00000004
#define ASLF_GENSRC             0x00000008
#define ASLF_NT                 0x00000010
#define ASLF_DUMP_NONASL        0x00000020
#define ASLF_DUMP_BIN           0x00000040
#define ASLF_CREAT_BIN          0x00000080

// Code flags
#define CF_MISSING_ARG          0x00000001
#define CF_PARSING_FIXEDLIST    0x00000002
#define CF_PARSING_VARLIST      0x00000004
#define CF_CREATED_NSOBJ        0x00000008

// Data types
#define CODETYPE_UNKNOWN        0
#define CODETYPE_ASLTERM        1
#define CODETYPE_NAME           2
#define CODETYPE_DATAOBJ        3
#define CODETYPE_FIELDOBJ       4
#define CODETYPE_INTEGER        5
#define CODETYPE_STRING         6
#define CODETYPE_KEYWORD        7
#define CODETYPE_USERTERM       8
#define CODETYPE_QWORD          9

/*** Macros
 */

#define MODNAME                 ProgInfo.pszProgName
#define ISLEADNAMECHAR(c)       (((c) >= 'A') && ((c) <= 'Z') || ((c) == '_'))
#define ISNAMECHAR(c)           (ISLEADNAMECHAR(c) || ((c) >= '0') && ((c) <= '9'))
#define OPCODELEN(d)            (((d) == OP_NONE)? 0: (((d) & 0x0000ff00)? 2: 1))
#ifdef DEBUG
  #define MEMALLOC(n)           (++gdwcMemObjs, malloc(n))
  #define MEMFREE(p)            {ASSERT(gdwcMemObjs > 0); free(p); --gdwcMemObjs;}
#else
  #define MEMALLOC(n)           malloc(n)
  #define MEMFREE(p)            free(p)
#endif

/*** Type definitions
 */

typedef struct _codeobj
{
    LIST   list;                //link to siblings
    struct _codeobj *pcParent;
    struct _codeobj *pcFirstChild;
    PNSOBJ pnsObj;
    DWORD  dwTermIndex;
    DWORD  dwfCode;
    DWORD  dwCodeType;
    DWORD  dwCodeValue;
    DWORD  dwDataLen;
    PBYTE  pbDataBuff;
    DWORD  dwCodeLen;
    BYTE   bCodeChkSum;
} CODEOBJ, *PCODEOBJ;

typedef struct _nschk
{
    struct _nschk *pnschkNext;
    char   szObjName[MAX_NSPATH_LEN + 1];
    PSZ    pszFile;
    PNSOBJ pnsScope;
    PNSOBJ pnsMethod;
    ULONG  dwExpectedType;
    ULONG  dwChkData;
    WORD   wLineNum;
} NSCHK, *PNSCHK;

typedef struct _resfield
{
    PSZ   pszName;
    DWORD dwBitOffset;
    DWORD dwBitSize;
} RESFIELD, *PRESFIELD;

#endif  //ifndef _ASLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\asl.c ===
/*** asl.c - Main module of the ASL assembler
 *
 *  This program compiles the ASL language into AML (p-code).
 *
 *  Copyright (c) 1996 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     07/23/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***EP  main - main program
 *
 *  ENTRY
 *      icArg - command line arguments count
 *      apszArg - command line arguments array
 *
 *  EXIT-SUCCESS
 *      program terminates with return code ASLERR_NONE
 *  EXIT-FAILURE
 *      program terminates with negative error code
 */

int EXPORT main(int icArg, char **apszArg)
{
    int rc = ASLERR_NONE;

    ParseProgInfo(apszArg[0], &ProgInfo);
    icArg--;
    apszArg++;

    if ((ParseSwitches(&icArg, &apszArg, ArgTypes, &ProgInfo) != ARGERR_NONE) ||
        (gpszTabSig == NULL) && ((icArg != 1) || (gdwfASL & ASLF_CREAT_BIN)) ||
        (gpszTabSig != NULL) && ((icArg != 0) || (gdwfASL & ASLF_UNASM)))
    {
        MSG(("invalid command line options"));
        PrintUsage();
        rc = ASLERR_INVALID_PARAM;
    }
    else
    {
      #ifdef __UNASM
        PBYTE pbTable = NULL;
        DWORD dwTableSig = 0;
        PSZ psz;
      #endif

        OPENTRACE(gpszTraceFile);
        PrintLogo();

        if ((rc = InitNameSpace()) == ASLERR_NONE)
        {
          #ifdef __UNASM
          #pragma message("Building with __UNASM option\r\n")

            if (gdwfASL & ASLF_DUMP_BIN)
            {
                if (((rc = ReadBinFile(*apszArg, &pbTable, &dwTableSig)) ==
                     ASLERR_NONE) &&
                    (gpszLSTFile == NULL))
                {
                    strncpy(gszLSTName, (PSZ)&dwTableSig, sizeof(DWORD));
                    strcpy(&gszLSTName[sizeof(DWORD)], ".TXT");
                    gpszLSTFile = gszLSTName;
                    gdwfASL |= ASLF_DUMP_NONASL | ASLF_UNASM;
                }
            }
            else if (gdwfASL & ASLF_UNASM)
            {
                gpszAMLFile = *apszArg;
                if (gpszLSTFile == NULL)
                {
                    strncpy(gszLSTName, gpszAMLFile, _MAX_FNAME - 1);
                    if ((psz = strchr(gszLSTName, '.')) != NULL)
                    {
                        *psz = '\0';
                    }
                    strcpy(&gszLSTName[strlen(gszLSTName)], ".ASL");
                    gpszLSTFile = gszLSTName;
                    gdwfASL |= ASLF_GENSRC;
                }
            }
            else if (gpszTabSig != NULL)
            {
                gdwfASL |= ASLF_UNASM;
                if (IsWinNT())
                {
                    gdwfASL |= ASLF_NT;
                }

                _strupr(gpszTabSig);
                if ((strcmp(gpszTabSig, "DSDT") != 0) &&
                    (strcmp(gpszTabSig, "SSDT") != 0) &&
                    (strcmp(gpszTabSig, "PSDT") != 0))
                {
                    gdwfASL |= ASLF_DUMP_NONASL;
                }

                if (gpszLSTFile == NULL)
                {
                    gpszLSTFile = gszLSTName;
                    if (gdwfASL & ASLF_DUMP_NONASL)
                    {
                        if (strcmp(gpszTabSig, "*") == 0)
                        {
                            strcpy(gszLSTName, "ACPI");
                        }
                        else
                        {
                            strcpy(gszLSTName, gpszTabSig);
                        }
                        strcpy(&gszLSTName[strlen(gszLSTName)], ".TXT");
                    }
                    else
                    {
                        strcpy(gszLSTName, gpszTabSig);
                        strcpy(&gszLSTName[strlen(gszLSTName)], ".ASL");
                        gdwfASL |= ASLF_GENSRC;
                    }
                }

              #ifndef WINNT
                if (!(gdwfASL & ASLF_NT) && ((ghVxD = OpenVxD()) == NULL))
                {
                    rc = ASLERR_OPEN_VXD;
                }
              #endif
            }
            else
            {
          #endif
                rc = ParseASLFile(*apszArg);
          #ifdef __UNASM
            }
          #endif
        }

        if (rc == ASLERR_NONE)
        {
            FILE *pfileOut;

            if (!(gdwfASL & ASLF_DUMP_NONASL))
            {
                if (gpszAMLFile == NULL)
                {
                    if (gpszTabSig == NULL)
                    {
                        ERROR(("%s has no DefinitionBlock", *apszArg));
                    }
                    else
                    {
                        strcpy(gszAMLName, gpszTabSig);
                        strcat(gszAMLName, ".AML");
                    }
                }

                if (gpszASMFile != NULL)
                {
                    if ((pfileOut = fopen(gpszASMFile, "w")) == NULL)
                    {
                        ERROR(("failed to open ASM file - %s", gpszASMFile));
                    }
                    else
                    {
                        gdwfASL |= ASLF_GENASM;
                        UnAsmFile(gpszAMLFile? gpszAMLFile: gszAMLName,
                                  (PFNPRINT)fprintf, pfileOut);
                        gdwfASL &= ~ASLF_GENASM;
                        fclose(pfileOut);
                    }
                }
            }

            if (gpszLSTFile != NULL)
            {
              #ifdef __UNASM
                if (gdwfASL & ASLF_CREAT_BIN)
                {
                    rc = DumpTableBySig(NULL, *((PDWORD)gpszTabSig));
                }
                else if ((pfileOut = fopen(gpszLSTFile, "w")) == NULL)
                {
                    ERROR(("failed to open LST file - %s", gpszLSTFile));
                }
                else
                {
                    if (gdwfASL & ASLF_DUMP_BIN)
                    {
                        ASSERT(pbTable != NULL);
                        ASSERT(dwTableSig != 0);
                        rc = DumpTable(pfileOut, pbTable, 0, dwTableSig);
                        MEMFREE(pbTable);
                    }
                    else if (gdwfASL & ASLF_DUMP_NONASL)
                    {
                        DWORD dwAddr;

                        if (((dwAddr = strtoul(gpszTabSig, &psz, 16)) != 0) &&
                            (*psz == 0))
                        {
                            rc = DumpTableByAddr(pfileOut, dwAddr);
                        }
                        else
                        {
                            rc = DumpTableBySig(pfileOut, *((PDWORD)gpszTabSig));
                        }
                    }
                    else
                    {
                        rc = UnAsmFile(gpszAMLFile? gpszAMLFile: gszAMLName,
                                       (PFNPRINT)fprintf, pfileOut);
                    }
                    fclose(pfileOut);
                }
              #else
                if ((pfileOut = fopen(gpszLSTFile, "w")) != NULL)
                {
                    rc = UnAsmFile(gpszAMLFile? gpszAMLFile: gszAMLName,
                                   (PFNPRINT)fprintf, pfileOut);
                    fclose(pfileOut);
                }
                else
                {
                    ERROR(("failed to open LST file - %s", gpszLSTFile));
                }
              #endif
            }

            if (gpszNSDFile != NULL)
            {
                if ((pfileOut = fopen(gpszNSDFile, "w")) == NULL)
                {
                    ERROR(("failed to open NameSpace dump file - %s",
                           gpszNSDFile));
                }
                else
                {
                    fprintf(pfileOut, "Name Space Objects:\n");
                    DumpNameSpacePaths(gpnsNameSpaceRoot, pfileOut);
                    fclose(pfileOut);
                }
            }
        }

      #ifdef __UNASM
      #ifndef WINNT
        if (ghVxD != NULL)
        {
            CloseVxD(ghVxD);
            ghVxD = NULL;
        }
      #endif
      #endif

        CLOSETRACE();
    }

    return rc;
}       //main

#ifdef __UNASM
/***LP  ReadBinFile - Read table from binary file
 *
 *  ENTRY
 *      pszFile -> binary file name
 *      ppb -> to hold the binary buffer pointer
 *      pdwTableSig -> to hold the table signature
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ReadBinFile(PSZ pszFile, PBYTE *ppb, PDWORD pdwTableSig)
{
    int rc = ASLERR_NONE;
    FILE *pfileBin;
    DESCRIPTION_HEADER dh;

    ENTER((1, "ReadBinFile(File=%s,ppb=%p,pdwTableSig=%p)\n",
           pszFile, ppb, pdwTableSig));

    if ((pfileBin = fopen(pszFile, "rb")) == NULL)
    {
        ERROR(("ReadBinFile: failed to open file %s", pszFile));
        rc = ASLERR_OPEN_FILE;
    }
    else if (fread(&dh, 1, sizeof(dh), pfileBin) < 2*sizeof(DWORD))
    {
        ERROR(("ReadBinFile: failed to read file %s", pszFile));
        rc = ASLERR_READ_FILE;
    }
    else if (fseek(pfileBin, 0, SEEK_SET) != 0)
    {
        ERROR(("ReadBinFile: failed to reset file %s", pszFile));
        rc = ASLERR_SEEK_FILE;
    }
    else
    {
        DWORD dwLen = (dh.Signature == SIG_LOW_RSDP)? sizeof(RSDP): dh.Length;

        if ((*ppb = MEMALLOC(dwLen)) == NULL)
        {
            ERROR(("ReadBinFile: failed to allocate table buffer for %s",
                   pszFile));
            rc = ASLERR_OUT_OF_MEM;
        }
        else if (fread(*ppb, dwLen, 1, pfileBin) != 1)
        {
            MEMFREE(*ppb);
            *ppb = NULL;
            ERROR(("ReadBinFile: failed to read file %s", pszFile));
            rc = ASLERR_READ_FILE;
        }
        else if (dh.Signature == SIG_LOW_RSDP)
        {
            *pdwTableSig = SIG_RSDP;
        }
        else
        {
            *pdwTableSig = dh.Signature;
        }
    }

    if (pfileBin != NULL)
    {
        fclose(pfileBin);
    }

    EXIT((1, "ReadBinFile=%d (pbTable=%p,TableSig=%s)\n",
          rc, *ppb, GetTableSigStr(*pdwTableSig)));
    return rc;
}       //ReadBinFile
#endif

/***LP  PrintLogo - Print logo message
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintLogo(VOID)
{
    if ((gdwfASL & ASLF_NOLOGO) == 0)
    {
        printf("%s Version %d.%d.%d%s [%s, %s]\n%s\n",
               STR_PROGDESC, VERSION_MAJOR, VERSION_MINOR, VERSION_RELEASE,
             #ifdef WINNT
               "NT",
	     #else
	       "",
	     #endif
               __DATE__, __TIME__, STR_COPYRIGHT);
	printf("Compliant with ACPI 1.0 specification\n\n");
    }
}       //PrintLogo

/***LP  PrintHelp - Print help messages
 *
 *  ENTRY
 *      ppszArg -> pointer to argument (not used)
 *      pAT -> argument type structure (not used)
 *
 *  EXIT
 *      program terminated with exit code 0
 */

int LOCAL PrintHelp(char **ppszArg, PARGTYPE pAT)
{
    DEREF(ppszArg);
    DEREF(pAT);

    PrintLogo();
    PrintUsage();
    printf("\t?            - Print this help message.\n");
    printf("\tnologo       - Supress logo banner.\n");
    printf("\tFo=<AMLFile> - Override the AML file name in the DefinitionBlock.\n");
    printf("\tFa=<ASMFile> - Generate .ASM file with the name <ASMFile>.\n");
    printf("\tFl=<LSTFile> - Generate .LST file with the name <LSTFile>.\n");
    printf("\tFn=<NSDFile> - Generate NameSpace Dump file with the name <NSDFile>.\n");
  #ifdef __UNASM
    printf("\td            - Dump the binary file in text form.\n");
    printf("\tu            - Unassemble AML file to an .ASL file (default)\n"
           "\t               or a .LST file.\n");
    printf("\ttab=<TabSig> - Unassemble ASL table to an .ASL file (default)\n"
           "\t               or a .LST file.\n");
    printf("\t               Dump non ASL table to an .TXT file.\n");
    printf("\t               If <TabSig> is '*', all tables are dump to ACPI.TXT.\n");
    printf("\t               <TabSig> can also be the physical address of the table.\n");
    printf("\tc            - Create binary files from tables.\n");
  #endif
  #ifdef TRACING
    printf("\tt=<n>        - Enable tracing at trace level n.\n");
    printf("\tl=<LogFile>  - Overriding the default trace log file name.\n");
  #endif
    exit(0);

    return ASLERR_NONE;
}       //PrintHelp

/***LP  PrintUsage - Print program usage syntax
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintUsage(VOID)
{
    printf("Usage:\n%s /?\n", MODNAME);
  #ifdef __UNASM
    printf("%s [/nologo] /d <BinFile>\n", MODNAME);
    printf("%s [/nologo] /u [/Fa=<ASMFile>] [/Fl=<LSTFile>] [/Fn=<NSDFile>] <AMLFile>\n",
           MODNAME);
    printf("%s [/nologo] /tab=<TabSig> [/c] [/Fa=<ASMfile>] [/Fl=<LSTFile>] [/Fn=<NSDFile>]\n",
           MODNAME);
  #endif
  #ifdef TRACING
    printf("%s [/nologo] [/Fo=<AMLFile>] [/Fa=<ASMFile>] [/Fl=<LSTFile>] [/Fn=<NSDFile>] [/t=<n>] [/l=<LogFile>] <ASLFile>\n",
           MODNAME);
  #else
    printf("%s [/nologo] [/Fo=<AMLFile>] [/Fa=<ASMFile>] [/Fl=<LSTFile>] [/Fn=<NSDFile>] <ASLFile>\n",
           MODNAME);
  #endif
  printf("\n");
}       //PrintUsage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\data.c ===
/*** data.c - Global Data
 *
 *  This module contains global data declaration.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/07/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef DEBUG
DWORD gdwcMemObjs = 0;
#endif

#pragma warning(disable: 4054)
ARGTYPE FAR ArgTypes[] =
{
    {"?",     AT_ACTION, 0,            (VOID *)PrintHelp, 0,             NULL},
    {"Fo",    AT_STRING, PF_SEPARATOR, &gpszAMLFile,      0,             NULL},
    {"Fa",    AT_STRING, PF_SEPARATOR, &gpszASMFile,      0,             NULL},
    {"Fl",    AT_STRING, PF_SEPARATOR, &gpszLSTFile,      0,             NULL},
    {"Fn",    AT_STRING, PF_SEPARATOR, &gpszNSDFile,      0,             NULL},
  #ifdef __UNASM
    {"d",     AT_ENABLE, 0,            &gdwfASL,          ASLF_DUMP_BIN, NULL},
    {"u",     AT_ENABLE, 0,            &gdwfASL,          ASLF_UNASM,    NULL},
    {"c",     AT_ENABLE, 0,            &gdwfASL,          ASLF_CREAT_BIN,NULL},
    {"tab",   AT_STRING, PF_SEPARATOR, &gpszTabSig,       0,             NULL},
  #endif
  #ifdef TRACING
    {"t",     AT_NUM,    PF_SEPARATOR, &giTraceLevel,     0,             NULL},
    {"l",     AT_STRING, PF_SEPARATOR, &gpszTraceFile,    0,             NULL},
  #endif
    {"nologo",AT_ENABLE, 0,            &gdwfASL,          ASLF_NOLOGO,   NULL},
    {"",      0,         0,            NULL,              0,             NULL}
};
#pragma warning(default: 4054)

PROGINFO ProgInfo = {NULL, NULL, NULL, NULL};

#ifdef __UNASM
HANDLE ghVxD = NULL;
#endif
char gszAMLName[_MAX_FNAME] = {0};
char gszLSTName[_MAX_FNAME] = {0};
PSZ gpszASLFile = NULL;
PSZ gpszAMLFile = NULL;
PSZ gpszASMFile = NULL;
PSZ gpszLSTFile = NULL;
PSZ gpszNSDFile = NULL;
PSZ gpszTabSig = NULL;
DWORD gdwfASL = 0;
PCODEOBJ gpcodeRoot = NULL;
PCODEOBJ gpcodeScope = NULL;
PNSOBJ gpnsNameSpaceRoot = NULL;
PNSOBJ gpnsCurrentScope = NULL;
PNSOBJ gpnsCurrentOwner = NULL;
PNSCHK gpnschkHead = NULL;
PNSCHK gpnschkTail = NULL;
DWORD gdwFieldAccSize = 0;
DESCRIPTION_HEADER ghdrDDB = {0};
char SymCharTable[] = "{}(),/*";
char * FAR gapszTokenType[] = {"ASL/User Term", "String", "Character", "Number",
                               "Symbol", "Space"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\binfmt.h ===
/*** binfmt.h - Format services definitions
 *
 *  Copyright (c) 1995,1996 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/06/95
 *
 *  MODIFICATION HISTORY
 */

#ifndef _BITFMT_H
#define _BITFMT_H

#ifndef ENTER
  #define ENTER(n,p)
#endif

#ifndef EXIT
  #define EXIT(n,p)
#endif

#ifndef TRACENAME
  #define TRACENAME(s)
#endif

#include <ctype.h>
#ifdef USE_CRUNTIME
    #include <stdio.h>
    #include <string.h>
    #define PRINTF		printf
    #define FPRINTF		fprintf
    #define SPRINTF             sprintf
    #define STRCPY              strcpy
    #define STRCPYN             strncpy
    #define STRCAT              strcat
    #define STRLEN              strlen
#else
  #ifdef WINAPP
    #define SPRINTF             wsprintf
    #define STRCPY              lstrcpy
    #define STRCPYN             lstrcpyn
    #define STRCAT              lstrcat
    #define STRLEN              lstrlen
  #else         //assume VxD
    #define SPRINTF             _Sprintf
    #define STRCPY(s1,s2)       _lstrcpyn(s1,s2,(DWORD)(-1))
    #define STRCPYN(s1,s2,n)    _lstrcpyn(s1,s2,(n)+1)
    #define STRCAT(s1,s2)       _lstrcpyn((s1)+_lstrlen(s1),s2,(DWORD)(-1))
    #define STRLEN              _lstrlen
  #endif
#endif

//
// Error Codes
//
#define FERR_NONE               0
#define FERR_INVALID_FORMAT     -1
#define FERR_INVALID_UNITSIZE   -2

//
// String Constants
//
#define SZ_SEP_SPACE            " "
#define SZ_SEP_TAB              "\t"
#define SZ_SEP_COMMA            ","
#define SZ_SEP_SEMICOLON        ";"
#define SZ_SEP_COLON            ":"
#define SZ_FMT_DEC              "%d"
#define SZ_FMT_HEX              "%x"
#define SZ_FMT_HEX_BYTE         "%02x"
#define SZ_FMT_HEX_WORD         "%04x"
#define SZ_FMT_HEX_DWORD        "%08lx"
#define SZ_FMT_WORDOFFSET       SZ_FMT_HEX_WORD SZ_SEP_COLON
#define SZ_FMT_DWORDOFFSET      SZ_FMT_HEX_DWORD SZ_SEP_COLON

//
// bFmtType Values
//
#define FMT_NUMBER              0
#define FMT_ENUM                1
#define FMT_BITS                2
#define FMT_STRING              3

//
// bUnitSize Values
//
#define UNIT_BYTE               sizeof(BYTE)
#define UNIT_WORD               sizeof(WORD)
#define UNIT_DWORD              sizeof(DWORD)

//
// dwfFormat Flags
//
#define FMTF_NO_EOL             0x80000000
#define FMTF_NO_INC_OFFSET      0x40000000
#define FMTF_NO_SEP             0x20000000
#define FMTF_NO_PRINT_DATA      0x10000000
#define FMTF_PRINT_OFFSET       0x08000000
#define FMTF_NO_RAW_DATA        0x04000000
#define FMTF_STR_ASCIIZ         0x00000001
#define FMTF_FIRST_FIELD        (FMTF_NO_EOL | FMTF_NO_INC_OFFSET | \
				 FMTF_NO_PRINT_DATA)
#define FMTF_MIDDLE_FIELD       (FMTF_NO_EOL | FMTF_NO_INC_OFFSET | \
                                 FMTF_NO_PRINT_DATA)
#define FMTF_LAST_FIELD         FMTF_NO_PRINT_DATA

//
// Structure and Type Definitions
//
typedef VOID (*LPFN)(FILE *, BYTE *, DWORD);

typedef struct fmthdr_s
{
    BYTE bFmtType;              //Format type: see FMT_*
    BYTE bUnitSize;             //Data unit size: see UNIT_*
    BYTE bUnitCnt;              //Data unit count for a format record
    DWORD dwfFormat;            //Format flags: see FMTF_*
    int iRepeatCnt;             //Repeat count for this format record
    char *pszOffsetFmt;         //Offset format
    char *pszFieldSep;          //Field separator between bUnitCnt of data
    char *pszLabel;             //LHS label
} FMTHDR, *PFMTHDR;

typedef struct fmt_s
{
    char *pszLabel;
    PFMTHDR pfmtType;
    LPFN lpfn;
} FMT, *PFMT;

typedef struct fmtnum_s
{
    FMTHDR hdr;
    DWORD dwMask;
    BYTE bShiftCnt;
    char *pszNumFmt;
} FMTNUM, *PFMTNUM;

typedef struct fmtenum_s
{
    FMTHDR hdr;
    DWORD dwMask;
    BYTE bShiftCnt;
    DWORD dwStartEnum;
    DWORD dwEndEnum;
    char **ppszEnumNames;
    char *pszOutOfRange;
} FMTENUM, *PFMTENUM;

typedef struct fmtbits_s
{
    FMTHDR hdr;
    DWORD dwMask;
    char **ppszOnNames;
    char **ppszOffNames;
} FMTBITS, *PFMTBITS;

typedef struct fmtstr_s
{
    FMTHDR hdr;
} FMTSTR, *PFMTSTR;

typedef struct fmtchar_s
{
    FMTHDR hdr;
} FMTCHAR, *PFMTCHAR;

//
// API Prototypes
//
#ifdef FPRINTF
int BinFPrintf(FILE *pfile, char *pszBuffer, PFMT pfmt, BYTE *pb,
	       DWORD *pdwOffset, char *pszOffsetFormat);
#endif
int BinSprintf(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset);

#endif	//ifndef _BINFMT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\binfmt.c ===
/*** binfmt.c - Binary Data Format services
 *
 *  This module contains format services for converting binary data into format
 *  text strings according to the format record.
 *
 *  Copyright (c) 1995,1996 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/06/95
 *
 *  MODIFICATION HISTORY
 */

#ifdef __UNASM

#pragma warning (disable: 4001)
#include "basedef.h"
#define USE_CRUNTIME
#include "binfmt.h"

typedef int (*PFNFMT)(char *, PFMTHDR, BYTE *, DWORD *);

//Local function prototypes
int FormatNum(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset);
int FormatEnum(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset);
int FormatBits(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset);
int FormatString(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset);
int GetData(BYTE bUnitSize, BYTE *pb, DWORD dwOffset, DWORD *pdwData);
int PrintData(char *pszBuffer, BYTE bUnitSize, DWORD dwData, BOOL fPadSpace);

char szDefSep[] = SZ_SEP_SPACE;
char szDefOffsetFmt[] = SZ_FMT_WORDOFFSET;
PFNFMT FmtFuncTable[] =
{
    FormatNum,          //0: FMT_NUMBER
    FormatEnum,         //1: FMT_ENUM
    FormatBits,         //2: FMT_BITS
    FormatString,       //3: FMT_STRING
};
#define NUM_FMT_FUNCS   (sizeof(FmtFuncTable)/sizeof(PFNFMT))

#ifdef FPRINTF
/***EP  BinFPrintf - Binary fprintf
 *
 *  ENTRY
 *      pfile -> output file
 *      pszBuffer -> buffer to hold the formatted string
 *                   (if NULL, use internal buffer)
 *      pfmt -> format record array
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer (if NULL, use internal)
 *      pszOffsetFormat -> offset format string (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int BinFPrintf(FILE *pfile, char *pszBuffer, PFMT pfmt, BYTE *pb,
              DWORD *pdwOffset, char *pszOffsetFormat)
{
    TRACENAME("BINFPRINTF")
    int rc = FERR_NONE;
    DWORD dwOffset = 0, dwOldOffset;
    DWORD dwData;
    char szBuff[256];
    char *psz = pszBuffer? pszBuffer: szBuff;
    DWORD *pdw = pdwOffset? pdwOffset: &dwOffset;

    ENTER(4, ("BinFPrintf(pszBuff=%lx,pfmt=%lx,pdwOffset=%lx,Offset=%lx)\n",
              pszBuffer, pfmt, pdwOffset, pdwOffset? *pdwOffset: 0));

    if (pfmt != NULL)
    {
        BYTE i, j;

        for (i = 0; pfmt[i].pfmtType != NULL; ++i)
        {
            if (pfmt[i].pszLabel != NULL)
            {
                if (pszOffsetFormat != NULL)
                {
                    FPRINTF(pfile, pszOffsetFormat,
                            *pdw, pfmt[i].pfmtType->bUnitSize);
                    if (pfmt[i].pfmtType->dwfFormat & FMTF_NO_RAW_DATA)
                    {
                        FPRINTF(pfile, "        ");
                    }
                    else
                    {
                        if (GetData(pfmt[i].pfmtType->bUnitSize, pb, *pdw,
                                    &dwData) == FERR_NONE)
                        {
                            PrintData(psz, pfmt[i].pfmtType->bUnitSize, dwData,
                                      TRUE);
                            FPRINTF(pfile, psz);
                        }

                        for (j = 1; j < pfmt[i].pfmtType->bUnitCnt; ++j)
                        {
                            if (GetData(pfmt[i].pfmtType->bUnitSize, pb,
                                        *pdw + j*pfmt[i].pfmtType->bUnitSize,
                                        &dwData) == FERR_NONE)
                            {
                                FPRINTF(pfile, ",");
                                PrintData(psz, pfmt[i].pfmtType->bUnitSize,
                                          dwData, FALSE);
                                FPRINTF(pfile, psz);
                            }
                        }
                    }
                }
                if (pfmt[i].pszLabel[0] != '\0')
                    FPRINTF(pfile, ";%s", pfmt[i].pszLabel);
                else
                    FPRINTF(pfile, "\n");
            }

            dwOldOffset = *pdw;
	    if ((pfmt[i].pszLabel != NULL) && (pfmt[i].pszLabel[0] == '\0'))
	    {
                *pdw += pfmt[i].pfmtType->bUnitCnt*pfmt[i].pfmtType->bUnitSize;
	    }
            else
            {
                if (pfmt[i].pszLabel == NULL)
                    FPRINTF(pfile, ",");
                rc = BinSprintf(psz, pfmt[i].pfmtType, pb, pdw);
                if (rc == FERR_NONE)
                {
                    char *psz1, *psz2;
                    BOOL fSpace = FALSE, fInQuote = FALSE, fInString = FALSE;

                    for (psz1 = psz2 = psz; *psz2 != '\0'; ++psz2)
                    {
                        if (*psz2 == '"')
                        {
                            fSpace = FALSE;
                            fInString = ~fInString;
                            *psz1 = *psz2;
                            psz1++;
                        }
                        else if (*psz2 == '\'')
                        {
                            fSpace = FALSE;
                            fInQuote = ~fInQuote;
                            *psz1 = *psz2;
                            psz1++;
                        }
                        else if (*psz2 == ' ')
                        {
                            if (!fSpace && !fInString && !fInQuote &&
                                (psz1 != psz))
                            {
                                *psz1 = ',';
                                psz1++;
                            }
                            else if (fInString || fInQuote)
                            {
                                *psz1 = *psz2;
                                psz1++;
                            }
                            fSpace = TRUE;
                        }
                        else
                        {
                            fSpace = FALSE;
                            *psz1 = *psz2;
                            psz1++;
                        }
                    }


                    if ((psz1 > psz) && (*(psz1 - 1) == ','))
                        *(psz1 - 1) = '\0';
                    else if ((psz1 > psz) && (*(psz1 - 1) == '\n') &&
                             (*(psz1 - 2) == ','))
                    {
                        *(psz1 - 2) = '\n';
                        *(psz1 - 1) = '\0';
                    }
                    else
                        *psz1 = '\0';
                    FPRINTF(pfile, psz);
                }
            }

            if (pfmt[i].lpfn != NULL)
                (*pfmt[i].lpfn)(pfile, pb, dwOldOffset);
        }
    }

    EXIT(4, ("BinFPrintf=%d (Offset=%lx,Buff=%s)\n",
         rc, *pdwOffset, pszBuffer));
    return rc;
}       //BinFPrintf
#endif  //ifdef FPRINTF

/***EP  BinSprintf - Binary sprintf
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold the formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int BinSprintf(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset)
{
    TRACENAME("BINSPRINTF")
    int rc = FERR_NONE;

    ENTER(4, ("BinSprintf(fmt=%d,Offset=%lx)\n", pfmt->bFmtType, *pdwOffset));

    if (pfmt->bFmtType >= NUM_FMT_FUNCS)
        rc = FERR_INVALID_FORMAT;
    else
    {
        int i;
        BYTE j;
        DWORD dwData;

        *pszBuffer = '\0';
        for (i = 0; (rc == FERR_NONE) && (i < pfmt->iRepeatCnt); ++i)
        {
            if (pfmt->dwfFormat & FMTF_PRINT_OFFSET)
            {
                SPRINTF(pszBuffer,
                        pfmt->pszOffsetFmt? pfmt->pszOffsetFmt: szDefOffsetFmt,
                        *pdwOffset);
            }

            if (!(pfmt->dwfFormat & FMTF_NO_PRINT_DATA) &&
                (GetData(pfmt->bUnitSize, pb, *pdwOffset, &dwData) ==
                 FERR_NONE))
            {
                PrintData(pszBuffer, pfmt->bUnitSize, dwData, FALSE);
                STRCAT(pszBuffer, ";");
            }

            if (pfmt->pszLabel)
                STRCAT(pszBuffer, pfmt->pszLabel);

            for (j = 0; (rc == FERR_NONE) && (j < pfmt->bUnitCnt); ++j)
            {
                rc = (*FmtFuncTable[pfmt->bFmtType])
                        (&pszBuffer[STRLEN(pszBuffer)], pfmt, pb, pdwOffset);

                if (rc == FERR_NONE)
                {
                    if (!(pfmt->dwfFormat & FMTF_NO_SEP))
                    {
                        STRCAT(pszBuffer,
                               pfmt->pszFieldSep? pfmt->pszFieldSep: szDefSep);
                    }

                    if (!(pfmt->dwfFormat & FMTF_NO_INC_OFFSET))
                        *pdwOffset += pfmt->bUnitSize;
                }
            }

            if ((rc == FERR_NONE) && !(pfmt->dwfFormat & FMTF_NO_EOL))
            {
                STRCAT(pszBuffer, "\n");
            }
        }
    }

    EXIT(4, ("BinSprintf=%d (Offset=%lx,Buff=%s)\n",
             rc, *pdwOffset, pszBuffer));
    return rc;
}       //BinSprintf

/***LP  FormatNum - Format numbers
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int FormatNum(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset)
{
    TRACENAME("FORMATNUM")
    int rc;
    PFMTNUM pfmtNum = (PFMTNUM)pfmt;
    DWORD dwData;

    ENTER(5, ("FormatNum(Offset=%lx)\n", *pdwOffset));

    if ((rc = GetData(pfmt->bUnitSize, pb, *pdwOffset, &dwData)) == FERR_NONE)
    {
        dwData &= pfmtNum->dwMask;
        dwData >>= pfmtNum->bShiftCnt;

        SPRINTF(&pszBuffer[STRLEN(pszBuffer)], pfmtNum->pszNumFmt, dwData);
    }

    EXIT(5, ("FormatNum=%d (Offset=%lx,Buff=%s)\n",
         rc, *pdwOffset, pszBuffer));
    return rc;
}       //FormatNum

/***LP  FormatEnum - Format enumerated values
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int FormatEnum(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset)
{
    TRACENAME("FORMATENUM")
    int rc = FERR_NONE;
    PFMTENUM pfmtEnum = (PFMTENUM)pfmt;
    DWORD dwData;

    ENTER(5, ("FormatEnum(Offset=%lx)\n", *pdwOffset));

    if ((rc = GetData(pfmt->bUnitSize, pb, *pdwOffset, &dwData)) == FERR_NONE)
    {
        dwData &= pfmtEnum->dwMask;
        dwData >>= pfmtEnum->bShiftCnt;

        if ((dwData < pfmtEnum->dwStartEnum) || (dwData > pfmtEnum->dwEndEnum))
            STRCAT(pszBuffer, pfmtEnum->pszOutOfRange);
        else
        {
            dwData -= pfmtEnum->dwStartEnum;
            STRCAT(pszBuffer, pfmtEnum->ppszEnumNames[dwData]);
        }
    }

    EXIT(5, ("FormatEnum=%d (Offset=%lx,Buff=%s)\n",
             rc, *pdwOffset, pszBuffer));
    return rc;
}       //FormatEnum

/***LP  FormatBits - Format bit values
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int FormatBits(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset)
{
    TRACENAME("FORMATBITS")
    int rc = FERR_NONE;
    PFMTBITS pfmtBits = (PFMTBITS)pfmt;
    DWORD dwData;

    ENTER(5, ("FormatBits(Offset=%lx)\n", *pdwOffset));

    if ((rc = GetData(pfmt->bUnitSize, pb, *pdwOffset, &dwData)) == FERR_NONE)
    {
        int i, j;
        DWORD dw;

        for (i = 31, j = 0; i >= 0; --i)
        {
            dw = 1L << i;
            if (pfmtBits->dwMask & dw)
            {
                if (dwData & dw)
                {
                    if ((pfmtBits->ppszOnNames != NULL) &&
                        (pfmtBits->ppszOnNames[j] != NULL))
                    {
                        STRCAT(pszBuffer, pfmtBits->ppszOnNames[j]);
                    }
                }
                else
                {
                    if ((pfmtBits->ppszOffNames != NULL) &&
                        (pfmtBits->ppszOffNames[j] != NULL))
                    {
                        STRCAT(pszBuffer, pfmtBits->ppszOffNames[j]);
                    }
                }

                if (!(pfmt->dwfFormat & FMTF_NO_SEP))
                {
                    STRCAT(pszBuffer,
                           pfmt->pszFieldSep? pfmt->pszFieldSep: szDefSep);
                }

                j++;
            }
        }
    }

    EXIT(5, ("FormatBits=%d (Offset=%lx,Buff=%s)\n",
             rc, *pdwOffset, pszBuffer));
    return rc;
}       //FormatBits

/***LP  FormatString - Format string data
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int FormatString(char *pszBuffer, PFMTHDR pfmt, BYTE *pb, DWORD *pdwOffset)
{
    TRACENAME("FORMATSTRING")
    int rc = FERR_NONE;

    ENTER(5, ("FormatString(Offset=%lx)\n", *pdwOffset));

    pb += *pdwOffset;
    if (pfmt->dwfFormat & FMTF_STR_ASCIIZ)
    {
        pszBuffer[0] = '"';
        STRCPY(pszBuffer + 1, (char *)pb);
        pszBuffer[STRLEN(pszBuffer)] = '"';
        if ((pfmt->bUnitSize == 0) && !(pfmt->dwfFormat & FMTF_NO_INC_OFFSET))
            *pdwOffset += STRLEN((char *)pb) + 3;
    }
    else if (pfmt->bUnitSize != 0)
    {
        if (isalnum(*pb) || (*pb == ' '))
        {
            pszBuffer[0] = '\'';
            STRCPYN(pszBuffer + 1, (char *)pb, pfmt->bUnitSize);
            pszBuffer[pfmt->bUnitSize + 1] = '\'';
            pszBuffer[pfmt->bUnitSize + 2] = '\0';
        }
        else
        {
            rc = PrintData(pszBuffer, pfmt->bUnitSize, *((PDWORD)pb), FALSE);
        }
    }

    EXIT(5, ("FormatString=%d (Offset=%lx,Buff=%s)\n",
             rc, *pdwOffset, pszBuffer));
    return rc;
}       //FormatString

/***LP  GetData - Get data of appropriate size from the binary buffer
 *
 *  ENTRY
 *      bUnitSize - size of data unit
 *      pb -> data buffer
 *      dwOffset - offset into data buffer
 *      pdwData -> to hold data
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int GetData(BYTE bUnitSize, BYTE *pb, DWORD dwOffset, DWORD *pdwData)
{
    TRACENAME("GETDATA")
    int rc = FERR_NONE;

    ENTER(6, ("GetData(UnitSize=%d,Data=%lx,Offset=%lx)\n",
              bUnitSize, *(DWORD *)pb, dwOffset));

    pb += dwOffset;
    switch (bUnitSize)
    {
        case UNIT_BYTE:
            *pdwData = (DWORD)(*pb);
            break;
        case UNIT_WORD:
            *pdwData = (DWORD)(*((WORD *)pb));
            break;
        case UNIT_DWORD:
            *pdwData = *(DWORD *)pb;
            break;
        default:
            rc = FERR_INVALID_UNITSIZE;
    }

    EXIT(6, ("GetData=%d (Data=%lx)\n", rc, *pdwData));
    return rc;
}       //GetData

/***LP  PrintData - Print data value according to its size
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      bUnitSize - size of data unit
 *      dwData - number
 *      fPadSpace - if TRUE pad space to 8 chars
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int PrintData(char *pszBuffer, BYTE bUnitSize, DWORD dwData, BOOL fPadSpace)
{
    TRACENAME("PRINTDATA")
    int rc = FERR_NONE;

    ENTER(6, ("PrintData(UnitSize=%d,Data=%lx)\n", bUnitSize, dwData));

    switch (bUnitSize)
    {
        case UNIT_BYTE:
            SPRINTF(pszBuffer, "%02x", (BYTE)dwData);
            if (fPadSpace)
                STRCAT(pszBuffer, "      ");
            break;
        case UNIT_WORD:
            SPRINTF(pszBuffer, "%04x", (WORD)dwData);
            if (fPadSpace)
                STRCAT(pszBuffer, "    ");
            break;
        case UNIT_DWORD:
            SPRINTF(pszBuffer, "%08lx", dwData);
            break;
        default:
            rc = FERR_INVALID_UNITSIZE;
    }

    EXIT(6, ("PrintData=%d (Buff=%s)\n", rc, pszBuffer));
    return rc;
}       //PrintData

#endif  //ifdef __UNASM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\aslterms.c ===
/*** aslterms.c - Parse ASL terms
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/10/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***LP  DefinitionBlock - Generate code for DefinitionBlock
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DefinitionBlock(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;
    #define OFLAGS  (_O_BINARY | _O_CREAT | _O_RDWR | _O_TRUNC)
    #define PMODE   (_S_IREAD | _S_IWRITE)

    ENTER((1, "DefinitionBlock(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (fActionFL)
    {
        if (gpcodeScope->pcParent != NULL)
        {
            PrintTokenErr(ptoken, "Definition block cannot nest", TRUE);
            rc = ASLERR_NEST_DDB;
        }
        else if (strlen((PSZ)pArgs[1].pbDataBuff) != sizeof(ghdrDDB.Signature))
        {
            ERROR(("DefinitionBlock: DDB signature too long - %s",
                   pArgs[1].pbDataBuff));
            rc = ASLERR_SYNTAX;
        }
        else if (strlen((PSZ)pArgs[3].pbDataBuff) > sizeof(ghdrDDB.OEMID))
        {
            ERROR(("DefinitionBlock: OEM ID too long - %s",
                   pArgs[3].pbDataBuff));
            rc = ASLERR_SYNTAX;
        }
        else if (strlen((PSZ)pArgs[4].pbDataBuff) > sizeof(ghdrDDB.OEMTableID))
        {
            ERROR(("DefinitionBlock: OEM Table ID too long - %s",
                   pArgs[4].pbDataBuff));
            rc = ASLERR_SYNTAX;
        }
        else
        {
            memset(&ghdrDDB, 0, sizeof(DESCRIPTION_HEADER));
            memcpy(&ghdrDDB.Signature, pArgs[1].pbDataBuff,
                   sizeof(ghdrDDB.Signature));
            memcpy(&ghdrDDB.Revision, &pArgs[2].dwCodeValue,
                   sizeof(ghdrDDB.Revision));
            memcpy(ghdrDDB.OEMID, pArgs[3].pbDataBuff,
                   strlen((PSZ)pArgs[3].pbDataBuff));
            memcpy(ghdrDDB.OEMTableID, pArgs[4].pbDataBuff,
                   strlen((PSZ)pArgs[4].pbDataBuff));
            memcpy(&ghdrDDB.OEMRevision, &pArgs[5].dwCodeValue,
                   sizeof(ghdrDDB.OEMRevision));
            memcpy(ghdrDDB.CreatorID, STR_MS, sizeof(ghdrDDB.CreatorID));
            ghdrDDB.CreatorRev = VERSION_DWORD;
        }
    }
    else
    {
    int fhAML = 0;
        PBYTE pb;
        DWORD dwCodeOffset = sizeof(ghdrDDB);

        ASSERT(gpcodeScope->pcParent == NULL);
        ghdrDDB.Length = gpcodeRoot->dwCodeLen + sizeof(DESCRIPTION_HEADER);
        ghdrDDB.Checksum = (BYTE)(-(gpcodeRoot->bCodeChkSum +
                                    ComputeDataChkSum((PBYTE)&ghdrDDB,
                                                      sizeof(DESCRIPTION_HEADER))));

        if ((gpnschkHead == NULL) ||
            ((rc = ValidateNSChkList(gpnschkHead)) == ASLERR_NONE))
        {
            if (gpszAMLFile == NULL)
            {
                strncpy(gszAMLName, (PSZ)pArgs[0].pbDataBuff,
                        _MAX_FNAME - 1);
                gpszAMLFile = gszAMLName;
            }

            if ((fhAML = _open(gpszAMLFile, OFLAGS, PMODE))== -1)
            {
                ERROR(("DefinitionBlock: failed to open AML file - %s",
                       pArgs[0].pbDataBuff));
                rc = ASLERR_CREATE_FILE;
            }
            else if (_write(fhAML, &ghdrDDB, sizeof(ghdrDDB)) != sizeof(ghdrDDB))
            {
                ERROR(("DefinitionBlock: failed to write DDB header"));
                rc = ASLERR_WRITE_FILE;
            }
            else if ((rc = WriteAMLFile(fhAML, gpcodeRoot, &dwCodeOffset)) !=
                     ASLERR_NONE)
            {
                ERROR(("DefinitionBlock: failed to write AML file"));
            }
            else if ((pb = MEMALLOC(ghdrDDB.Length)) != NULL)
            {
                if (_lseek(fhAML, 0, SEEK_SET) == -1)
                {
                    ERROR(("DefinitionBlock: failed seeking to beginning of image file"));
                }
                else if (_read(fhAML, pb, ghdrDDB.Length) != (int)ghdrDDB.Length)
                {
                    ERROR(("DefinitionBlock: failed to read back image file"));
                }
                else if (ComputeDataChkSum(pb, ghdrDDB.Length) != 0)
                {
                    ERROR(("DefinitionBlock: failed to verify checksum of image file"));
                }
                MEMFREE(pb);
            }

            if (rc == ASLERR_NONE)
            {
                printf("%s(%s): Image Size=%ld, Image Checksum=0x%x\n\n",
                       MODNAME, pArgs[0].pbDataBuff, ghdrDDB.Length, ghdrDDB.Checksum);
            }

            if (fhAML != 0)
            {
                _close(fhAML);
            }
        }
        FreeCodeObjs(gpcodeRoot);
        gpcodeRoot = NULL;
    }

    EXIT((1, "DefinitionBlock=%d\n", rc));
    return rc;
}       //DefinitionBlock

/***LP  Include - Include an ASL file
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Include(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;
    PCODEOBJ pArgs;

    ENTER((1, "Include(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    rc = ParseASLFile((PSZ)pArgs[0].pbDataBuff);

    EXIT((1, "Include=%d\n", rc));
    return rc;
}       //Include

/***LP  External - Declaring external object
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL External(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "External(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x02, 1);
    gpcodeScope->pnsObj->ObjData.dwDataType = (USHORT) pArgs[1].dwCodeValue;
    if (!(pArgs[2].dwfCode & CF_MISSING_ARG))
    {
        gpcodeScope->pnsObj->ObjData.uipDataValue = pArgs[2].dwCodeValue;
    }

    EXIT((1, "External=%d\n", rc));
    return rc;
}       //External

/***LP  Method - Parse Method statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Method(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "Method(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (pArgs[1].dwfCode & CF_MISSING_ARG)
    {
        pArgs[1].dwfCode &= ~CF_MISSING_ARG;
        SetIntObject(&pArgs[1], 0, sizeof(BYTE));
    }
    else if (pArgs[1].dwCodeValue > MAX_ARGS)
    {
        PrintTokenErr(ptoken, "Method has too many formal arguments", TRUE);
        rc = ASLERR_SYNTAX;
    }

    ASSERT(gpcodeScope->pnsObj != NULL);
    ASSERT(gpcodeScope->pnsObj->ObjData.dwDataType == OBJTYPE_METHOD);
    gpcodeScope->pnsObj->ObjData.uipDataValue = pArgs[1].dwCodeValue;

    if ((rc == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[2], ID_NOTSERIALIZED)) == ASLERR_NONE))
    {
        pArgs[1].dwCodeValue |= TermTable[pArgs[2].dwTermIndex].dwTermData &
                                0xff;
        pArgs[1].bCodeChkSum = (BYTE)pArgs[1].dwCodeValue;
    }

    EXIT((1, "Method=%d\n", rc));
    return rc;
}       //Method

/***LP  Field - Parse Field statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Field(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "Field(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x0e, 1);
    gdwFieldAccSize =
        ACCSIZE(((PCODEOBJ)gpcodeScope->pbDataBuff)[1].dwCodeValue);

    EXIT((1, "Field=%d\n", rc));
    return rc;
}       //Field

/***LP  IndexField - Parse IndexField statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL IndexField(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "IndexField(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x1c, 2);
    gdwFieldAccSize =
        ACCSIZE(((PCODEOBJ)gpcodeScope->pbDataBuff)[2].dwCodeValue);

    EXIT((1, "IndexField=%d\n", rc));
    return rc;
}       //IndexField

/***LP  BankField - Parse BankField statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL BankField(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "BankField(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x38, 3);
    gdwFieldAccSize =
        ACCSIZE(((PCODEOBJ)gpcodeScope->pbDataBuff)[3].dwCodeValue);

    EXIT((1, "BankField=%d\n", rc));
    return rc;
}       //BankField

/***LP  OpRegion - Parse OperationRegion statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL OpRegion(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "OpRegion(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x02, 1);
    ASSERT(gpcodeScope->pnsObj != NULL);
    ASSERT(gpcodeScope->pnsObj->ObjData.dwDataType == OBJTYPE_OPREGION);
    gpcodeScope->pnsObj->ObjData.uipDataValue =
        (pArgs[3].dwCodeType != CODETYPE_DATAOBJ)? 0xffffffff:
        (pArgs[3].pbDataBuff[0] == OP_BYTE)? pArgs[3].pbDataBuff[1]:
        (pArgs[3].pbDataBuff[0] == OP_WORD)? *(PWORD)(&pArgs[3].pbDataBuff[1]):
                                             *(PDWORD)(&pArgs[3].pbDataBuff[1]);

    EXIT((1, "OpRegion=%d\n", rc));
    return rc;
}       //OpRegion

/***LP  EISAID - Parse EISAID statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL EISAID(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;
    PCODEOBJ pArgs;
    DWORD dwEISAID;

    ENTER((1, "EISAID(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if ((rc = ComputeEISAID((PSZ)pArgs[0].pbDataBuff, &dwEISAID)) ==
        ASLERR_NONE)
    {
        DWORD dwLen;

        MEMFREE(pArgs[0].pbDataBuff);
        pArgs[0].pbDataBuff = NULL;
        dwLen = (dwEISAID & 0xffff0000)? sizeof(DWORD):
                (dwEISAID & 0xffffff00)? sizeof(WORD): sizeof(BYTE);
        SetIntObject(&pArgs[0], dwEISAID, dwLen);
        pArgs[0].pcParent->dwCodeValue = (dwLen == sizeof(DWORD))? OP_DWORD:
                                         (dwLen == sizeof(WORD))? OP_WORD:
                                                                  OP_BYTE;
    }
    else
    {
        ERROR(("EISAID: invalid EISAID - %s", pArgs[0].pbDataBuff));
    }

    EXIT((1, "EISAID=%d\n", rc));
    return rc;
}       //EISAID

/***LP  Match - Parse Match statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Match(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "Match(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x02, 1);
    EncodeKeywords((PCODEOBJ)gpcodeScope->pbDataBuff, 0x08, 3);

    EXIT((1, "Match=%d\n", rc));
    return rc;
}       //Match

/***LP  AccessAs - Parse AccessAs macro
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL AccessAs(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "AccessAs(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x01, 0);
    if (pArgs[1].dwfCode & CF_MISSING_ARG)
    {
        pArgs[1].dwfCode &= ~CF_MISSING_ARG;
        SetIntObject(&pArgs[1], 0, sizeof(BYTE));
    }
    else if (pArgs[1].dwCodeType == CODETYPE_KEYWORD) {
        EncodeKeywords(pArgs, 0x02, 1);
    }
    else if ((pArgs[1].dwCodeType == CODETYPE_INTEGER) && pArgs[1].dwCodeValue > MAX_BYTE)
    {
        PrintTokenErr(ptoken, "Access Attribute can only be a byte value",
                      TRUE);
        rc = ASLERR_SYNTAX;
    }

    EXIT((1, "AccessAs=%d\n", rc));
    return rc;
}       //AccessAs

/***LP  Else - Parse Else statement
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Else(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pcPrevSibling = (PCODEOBJ)gpcodeScope->list.plistPrev;

    ENTER((1, "Else(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    if ((pcPrevSibling->dwCodeType != CODETYPE_ASLTERM) ||
        (TermTable[pcPrevSibling->dwTermIndex].lID != ID_IF))
    {
        PrintTokenErr(ptoken, "Else statement has no matching If", TRUE);
        rc = ASLERR_SYNTAX;
    }

    EXIT((1, "Else=%d\n", rc));
    return rc;
}       //Else
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\basedef.h ===
/*** basedef.h - Basic definitions
 *
 *  Copyright (c) 1989,1992,1993 Microsoft Corporation
 *  Author:     Michael Tsang (MTS)
 *  Created     01/06/89
 *
 *  This module contains basic constants and types
 *
 *  MODIFICATION HISTORY
 */

#pragma warning (disable: 4001)

/***    Commonly used constants
 */

#ifndef NULL
#define NULL            0
#endif

#ifndef FALSE
#define FALSE           0
#endif

#ifndef TRUE
#define TRUE            1
#endif

#define CDECL           __cdecl
#define PASCAL          __pascal

#if defined(IS_32) || defined(_WIN32_WINNT)
#define FAR
#define NEAR
#else
#define FAR             __far
#define NEAR            __near
#endif

/***    Base type declarations
 */

typedef void             VOID;
typedef char             CHAR;          //ch
typedef unsigned char    UCHAR;         //uch
typedef int              INT;           //i
typedef unsigned int     UINT;          //ui
typedef short            SHORT;         //s
typedef unsigned short   USHORT;        //us
typedef long             LONG;          //l
typedef unsigned long    ULONG;         //ul
typedef __int64          LONGLONG;      //ll
typedef unsigned __int64 ULONGLONG;     //ull
typedef ULONG            ULONG_PTR;     //uip

typedef UCHAR           BYTE;           //b
typedef USHORT          WORD;           //w
typedef ULONG           DWORD;          //dw
typedef ULONGLONG	QWORD;		//qw

typedef UINT            BOOL;           //f
typedef UCHAR           BBOOL;          //bf
typedef USHORT          SBOOL;          //sf
typedef ULONG           LBOOL;          //lf
typedef ULONG           FLAGS;          //fl
#if defined(_WIN64)
typedef unsigned __int64 HANDLE;        //h
#else
typedef ULONG           HANDLE;         //h
#endif

/***    Pointer types to base types declarations
 */

typedef VOID *          PVOID;          //pv
typedef VOID FAR *      LPVOID;         //lpv
typedef CHAR *          PCHAR;          //pch
typedef CHAR FAR *      LPCHAR;         //lpch
typedef UCHAR *         PUCHAR;         //puch
typedef UCHAR FAR *     LPUCHAR;        //lpuch
typedef INT *           PINT;           //pi
typedef INT FAR *       LPINT;          //lpi
typedef UINT *          PUINT;          //pui
typedef UINT FAR *      LPUINT;         //lpui
typedef SHORT *         PSHORT;         //ps
typedef SHORT FAR *     LPSHORT;        //lps
typedef USHORT *        PUSHORT;        //pus
typedef USHORT FAR *    LPUSHORT;       //lpus
typedef LONG *          PLONG;          //pl
typedef LONG FAR *      LPLONG;         //lpl
typedef ULONG *         PULONG;         //pul
typedef ULONG FAR *     LPULONG;        //lpul

typedef BYTE *          PBYTE;          //pb
typedef BYTE FAR *      LPBYTE;         //lpb
typedef WORD *          PWORD;          //pw
typedef WORD FAR *      LPWORD;         //lpw
typedef DWORD *         PDWORD;         //pdw
typedef DWORD FAR *     LPDWORD;        //lpdw

typedef BOOL *          PBOOL;          //pf
typedef BOOL FAR *      LPBOOL;         //lpf
typedef BBOOL *         PBBOOL;         //pbf
typedef BBOOL FAR *     LPBBOOL;        //lpbf
typedef SBOOL *         PSBOOL;         //psf
typedef SBOOL FAR *     LPSBOOL;        //lpsf
typedef LBOOL *         PLBOOL;         //plf
typedef LBOOL FAR *     LPLBOOL;        //lplf
typedef FLAGS *         PFLAGS;         //pfl
typedef FLAGS FAR *     LPFLAGS;        //lpfl

/***    Double indirection pointer types to base types declarations
 */

typedef PVOID *         PPVOID;         //ppv
typedef PVOID FAR *     LPPVOID;        //lppv

/***    Other common types (and their pointers)
 */

typedef CHAR *          PSZ;            //psz
typedef CHAR FAR *      LPSZ;           //lpsz
typedef CHAR FAR *      LPSTR;          //lpstr

/***    Constants
 */

#define MAX_BYTE        0xff
#define MAX_WORD        0xffff
#define MAX_DWORD       0xffffffff

/***    Macros
 */

#define DEREF(x)        ((x) = (x))
#define EXPORT          CDECL
#define LOCAL           CDECL
#define BYTEOF(d,i)     (((BYTE *)&(d))[i])
#define WORDOF(d,i)     (((WORD *)&(d))[i])

//
// EFNfix:  This is a slimy hack to include acpitabl.h, why are we not using
// standard types ?
//
typedef BOOL BOOLEAN;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\data.h ===
/*** data.h - Global Data Definitions
 *
 *  This module contains global data definitions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/07/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _DATA_H
#define _DATA_H

#ifdef DEBUG
extern DWORD gdwcMemObjs;
#endif

extern ARGTYPE FAR ArgTypes[];
extern PROGINFO ProgInfo;

#ifdef __UNASM
extern HANDLE ghVxD;
#endif
extern char gszAMLName[];
extern char gszLSTName[];
extern PSZ gpszASLFile;
extern PSZ gpszAMLFile;
extern PSZ gpszASMFile;
extern PSZ gpszLSTFile;
extern PSZ gpszNSDFile;
extern PSZ gpszTabSig;
extern DWORD gdwfASL;
extern PCODEOBJ gpcodeRoot;
extern PCODEOBJ gpcodeScope;
extern PNSOBJ gpnsNameSpaceRoot;
extern PNSOBJ gpnsCurrentScope;
extern PNSOBJ gpnsCurrentOwner;
extern PNSCHK gpnschkHead;
extern PNSCHK gpnschkTail;
extern DWORD gdwFieldAccSize;
extern DESCRIPTION_HEADER ghdrDDB;
extern char FAR SymCharTable[];
extern char * FAR gapszTokenType[];

#endif  //ifndef _DATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\fmtdata.h ===
/*** fmtdata.h - Format Data
 *
 *  This module contains all the format data.
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     04/08/99
 *
 *  MODIFICATION HISTORY
 */

//
// Common Strings
//
char szReserved[] = "Reserved";
char szLabelReserved[] = "Reserved        =";
char szNull[] = "";
char szDecFmt[] = SZ_FMT_DEC;
char szHexFmt[] = SZ_FMT_HEX;
char szByteFmt[] = SZ_FMT_HEX_BYTE;
char szWordFmt[] = SZ_FMT_HEX_WORD;
char szDWordFmt[] = SZ_FMT_HEX_DWORD;
char szOffsetFmt[] = "%02x: ";
char szSectFmt[] = "\n[%08lx: %s]\n";

//
// Common Formats
//
FMTNUM fmtHexByteNoEOL =
{
    {FMT_NUMBER, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA | FMTF_NO_EOL, 1, NULL, NULL,
     NULL},
    0xff, 0, szByteFmt
};

FMTNUM fmtHexByte =
{
    {FMT_NUMBER, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, szByteFmt
};

FMTNUM fmt3HexByte =
{
    {FMT_NUMBER, UNIT_BYTE, 3, FMTF_NO_PRINT_DATA | FMTF_NO_RAW_DATA, 1, NULL,
     NULL, NULL},
    0xff, 0, szByteFmt
};

FMTNUM fmtHexWord =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffff, 0, szWordFmt
};

FMTNUM fmtHexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, szDWordFmt
};

FMTNUM fmt2HexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 2, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, szDWordFmt
};

FMTNUM fmt4HexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 4, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, szDWordFmt
};

FMTNUM fmt6HexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 6, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, szDWordFmt
};

FMTNUM fmt8HexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 8, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, szDWordFmt
};

FMTNUM fmtDecNum =
{
    {FMT_NUMBER, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, szDecFmt
};

FMTSTR fmtChar4 =
{
    {FMT_STRING, UNIT_BYTE, 4, FMTF_NO_PRINT_DATA | FMTF_NO_RAW_DATA, 1, NULL,
     NULL, NULL}
};

FMTSTR fmtChar6 =
{
    {FMT_STRING, UNIT_BYTE, 6, FMTF_NO_PRINT_DATA | FMTF_NO_RAW_DATA, 1, NULL,
     NULL, NULL}
};

FMTSTR fmtChar8 =
{
    {FMT_STRING, UNIT_BYTE, 8, FMTF_NO_PRINT_DATA | FMTF_NO_RAW_DATA, 1, NULL,
     NULL, NULL}
};

//
// RSD PTR Table
//
FMT afmtRSDPTR[] =
{
    {"Signature       =", (PFMTHDR)&fmtChar8,       NULL},
    {"Checksum        =", (PFMTHDR)&fmtHexByte,     NULL},
    {"OEMID           =", (PFMTHDR)&fmtChar6,       NULL},
    {szLabelReserved,     (PFMTHDR)&fmtHexByte,     NULL},
    {"RSDTAddr        =", (PFMTHDR)&fmtHexDWord,    NULL},
    {NULL,                NULL,                     NULL}
};

//
// Common Table Header
//
FMT afmtTableHdr[] =
{
    {"Signature       =", (PFMTHDR)&fmtChar4,       NULL},
    {"Length          =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"Revision        =", (PFMTHDR)&fmtHexByte,     NULL},
    {"Checksum        =", (PFMTHDR)&fmtHexByte,     NULL},
    {"OEMID           =", (PFMTHDR)&fmtChar6,       NULL},
    {"OEMTableID      =", (PFMTHDR)&fmtChar8,       NULL},
    {"OEMTableRev     =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"CreatorID       =", (PFMTHDR)&fmtChar4,       NULL},
    {"CreatorRev      =", (PFMTHDR)&fmtHexDWord,    NULL},
    {NULL,                NULL,                     NULL}
};

//
// Generic Register Address Structure
//
char *ppszAddrSpaceNames[] = {"SystemMemory", "SystemIO", "PCIConfigSpace"};
FMTENUM fmtAddrSpaceID =
{
    {FMT_ENUM, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, 0, 2, ppszAddrSpaceNames, szReserved
};

FMT afmtGRASCommon[] =
{
    {"RegAddrSpce     =", (PFMTHDR)&fmtAddrSpaceID, NULL},
    {"RegBitWidth     =", (PFMTHDR)&fmtHexByte,     NULL},
    {"RegBitOffset    =", (PFMTHDR)&fmtHexByte,     NULL},
    {szLabelReserved,     (PFMTHDR)&fmtHexByte,     NULL},
    {NULL,                NULL,                     NULL}
};

FMT afmtGRASPCICS[] =
{
    {szLabelReserved,     (PFMTHDR)&fmtHexWord,     NULL},
    {"DeviceNum       =", (PFMTHDR)&fmtHexWord,     NULL},
    {"FunctionNum     =", (PFMTHDR)&fmtHexWord,     NULL},
    {"CfgSpaceOffset  =", (PFMTHDR)&fmtHexWord,     NULL},
    {NULL,                NULL,                     NULL}
};

FMT afmtGRASRegAddr[] =
{
    {"RegAddrLo       =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"RegAddrHi       =", (PFMTHDR)&fmtHexDWord,    NULL},
    {NULL,                NULL,                     NULL}
};

//
// FACP Table
//
char *ppszIntModelNames[] = {"DualPIC", "MultipleAPIC"};
FMTENUM fmtIntModel =
{
    {FMT_ENUM, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, 0, 0x01, ppszIntModelNames, szReserved
};

char *ppszBootArchFlagNames[] = {"8042", "LegacyDevices"};
FMTBITS fmtBootArch =
{
    {FMT_BITS, UNIT_WORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0x0003, ppszBootArchFlagNames, NULL
};

char *ppszFACPFlagNames[] = {"ResetRegSupported", "DckCap", "TmrValExt",
                             "RTCS4", "FixRTC", "SlpButton", "PwrButton",
                             "PLvl2UP", "ProcC1", "WBINVDFlush", "WBINVD"};
FMTBITS fmtFACPFlags =
{
    {FMT_BITS, UNIT_DWORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0x000007ff, ppszFACPFlagNames, NULL
};

FMT afmtFACP[] =
{
    {"FACSAddr        =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"DSDTAddr        =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"IntModel        =", (PFMTHDR)&fmtIntModel,    NULL},
    {szLabelReserved,     (PFMTHDR)&fmtHexByte,     NULL},
    {"SCIInt          =", (PFMTHDR)&fmtHexWord,     NULL},
    {"SMICmdAddr      =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"ACPIEnableValue =", (PFMTHDR)&fmtHexByte,     NULL},
    {"ACPIDisableValue=", (PFMTHDR)&fmtHexByte,     NULL},
    {"S4BIOSReqValue  =", (PFMTHDR)&fmtHexByte,     NULL},
    {szLabelReserved,     (PFMTHDR)&fmtHexByte,     NULL},
    {"PM1aEvtBlkAddr  =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"PM1bEvtBlkAddr  =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"PM1aCtrlBlkAddr =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"PM1bCtrlBlkAddr =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"PM2CtrlBlkAddr  =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"PMTmrBlkAddr    =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"GPE0BlkAddr     =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"GPE1BlkAddr     =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"PM1EvtBlkLen    =", (PFMTHDR)&fmtHexByte,     NULL},
    {"PM1CtrlBlkLen   =", (PFMTHDR)&fmtHexByte,     NULL},
    {"PM2CtrlBlkLen   =", (PFMTHDR)&fmtHexByte,     NULL},
    {"PMTmrBlkLen     =", (PFMTHDR)&fmtHexByte,     NULL},
    {"GPE0BlkLen      =", (PFMTHDR)&fmtHexByte,     NULL},
    {"GPE1BlkLen      =", (PFMTHDR)&fmtHexByte,     NULL},
    {"GPE1BaseOffset  =", (PFMTHDR)&fmtHexByte,     NULL},
    {szLabelReserved,     (PFMTHDR)&fmtHexByte,     NULL},
    {"PLvl2Latency    =", (PFMTHDR)&fmtHexWord,     NULL},
    {"PLvl3Latency    =", (PFMTHDR)&fmtHexWord,     NULL},
    {"FlushSize       =", (PFMTHDR)&fmtHexWord,     NULL},
    {"FlushStride     =", (PFMTHDR)&fmtHexWord,     NULL},
    {"DutyOffset      =", (PFMTHDR)&fmtHexByte,     NULL},
    {"DutyWidth       =", (PFMTHDR)&fmtHexByte,     NULL},
    {"DayAlarmIndex   =", (PFMTHDR)&fmtHexByte,     NULL},
    {"MonthAlarmIndex =", (PFMTHDR)&fmtHexByte,     NULL},
    {"CenturyIndex    =", (PFMTHDR)&fmtHexByte,     NULL},
    {"BootArchFlags   =", (PFMTHDR)&fmtBootArch,    NULL},
    {szLabelReserved,     (PFMTHDR)&fmtHexByte,     NULL},
    {"Flags           =", (PFMTHDR)&fmtFACPFlags,   NULL},
    {NULL,                NULL,                     NULL}
};

FMT afmtFACP2[] =
{
    {"ResetValue      =", (PFMTHDR)&fmtHexByte,     NULL},
    {szLabelReserved,     (PFMTHDR)&fmt3HexByte,    NULL},
    {NULL,                NULL,                     NULL}
};

//
// FACS Table
//
char *ppszGLNames[] = {"Owned", "Pending"};
FMTBITS fmtGlobalLock =
{
    {FMT_BITS, UNIT_DWORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0x00000003, ppszGLNames, NULL
};

char *ppszFACSFlagNames[] = {"S4BIOS"};
FMTBITS fmtFACSFlags =
{
    {FMT_BITS, UNIT_DWORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0x00000001, ppszFACSFlagNames, NULL
};

FMT afmtFACS[] =
{
    {"Signature       =", (PFMTHDR)&fmtChar4,       NULL},
    {"Length          =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"HWSignature     =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"FirmwareWakeVect=", (PFMTHDR)&fmtHexDWord,    NULL},
    {"GlobalLock      =", (PFMTHDR)&fmtGlobalLock,  NULL},
    {"Flags           =", (PFMTHDR)&fmtFACSFlags,   NULL},
    {szNull,              (PFMTHDR)&fmt2HexDWord,   NULL},
    {szNull,              (PFMTHDR)&fmt8HexDWord,   NULL},
    {NULL,                NULL,                     NULL}
};

//
// APIC Table
//
char *ppszAPICFlagNames[] = {"PCATCompat"};
FMTBITS fmtAPICFlags =
{
    {FMT_BITS, UNIT_DWORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0x00000001, ppszAPICFlagNames, NULL
};

FMT afmtAPIC[] =
{
    {"LocalAPICAddr   =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"Flags           =", (PFMTHDR)&fmtAPICFlags,   NULL},
    {NULL,                NULL,                     NULL}
};

//
// SBST Table
//
FMT afmtSBST[] =
{
    {"WarnEnergyLevel =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"LowEnergyLevel  =", (PFMTHDR)&fmtHexDWord,    NULL},
    {"CritEnergyLevel =", (PFMTHDR)&fmtHexDWord,    NULL},
    {NULL,                NULL,                     NULL}
};

//
// BOOT Table
//
FMT afmtBOOT[] =
{
    {"CMOSOffset      =", (PFMTHDR)&fmtHexByte,     NULL},
    {szLabelReserved,     (PFMTHDR)&fmt3HexByte,    NULL},
    {NULL,                NULL,                     NULL}
};

//
// DBGP Table
//
char *ppszInterfaceNames[] = {"16550Full", "16550Subset"};
FMTENUM fmtInterfaceType =
{
    {FMT_ENUM, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, 0, 0x01, ppszIntModelNames, szReserved
};

FMT afmtDBGP[] =
{
    {"InterfaceType   =", (PFMTHDR)&fmtInterfaceType,NULL},
    {szLabelReserved,     (PFMTHDR)&fmt3HexByte,     NULL},
    {NULL,                NULL,                     NULL}
};

typedef struct _fmtentry
{
    DWORD dwTableSig;
    DWORD dwFlags;
    PFMT  pfmt;
} FMTENTRY, *PFMTENTRY;

#define TF_NOHDR                0x00000001
#define SIG_DBGP                'PGBD'

FMTENTRY FmtTable[] = {
    {FADT_SIGNATURE, 0,        afmtFACP},
    {FACS_SIGNATURE, TF_NOHDR, afmtFACS},
    {APIC_SIGNATURE, 0,        afmtAPIC},
    {SBST_SIGNATURE, 0,        afmtSBST},
    {SIG_BOOT,       0,        afmtBOOT},
    {SIG_DBGP,       0,        afmtDBGP},
    {RSDT_SIGNATURE, 0,        NULL},
    {DSDT_SIGNATURE, 0,        NULL},
    {PSDT_SIGNATURE, 0,        NULL},
    {SSDT_SIGNATURE, 0,        NULL},
    {0,              0,        NULL}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\debug.c ===
/*** debug.c - Debug functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/07/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"
#include <stdarg.h>     //for va_*

#ifdef TRACING

#define TRACEFILE_NAME  "tracelog.txt"

FILE *gpfileTrace = NULL;
PSZ gpszTraceFile = NULL;
int giTraceLevel = 0;
int giIndent = 0;

/***LP  OpenTrace - Initialize tracing
 *
 *  This function opens the device that the trace output will go to.
 *  It will first try the caller's filename, or else the default filenmae.
 *
 *  ENTRY
 *      pszTraceOut -> output device name
 *
 *  EXIT
 *      None
 */

VOID LOCAL OpenTrace(char *pszTraceOut)
{
    if ((gpfileTrace == NULL) && (giTraceLevel > 0))
    {
        if ((pszTraceOut == NULL) ||
            ((gpfileTrace = fopen(pszTraceOut, "w")) == NULL))
        {
            gpfileTrace = fopen(TRACEFILE_NAME, "w");
        }
    }
}       //OpenTrace

/***LP  CloseTrace - Finish tracing
 *
 *  This function close the device that the trace output will go to.
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL CloseTrace(VOID)
{
    if (gpfileTrace != NULL)
    {
        fclose(gpfileTrace);
        gpfileTrace = NULL;
    }
    giTraceLevel = 0;
}       //CloseTrace

/***LP  EnterProc - Entering a procedure
 *
 *  ENTRY
 *      n - trace level of this procedure
 *      pszFormat -> format string
 *      ... - variable arguments according to format string
 *
 *  EXIT
 *      None
 */

VOID CDECL EnterProc(int n, char *pszFormat, ...)
{
    int i;
    va_list marker;

    if (n <= giTraceLevel)
    {
        if (gpfileTrace != NULL)
        {
            fprintf(gpfileTrace, "%s:", MODNAME);
            for (i = 0; i < giIndent; ++i)
                fprintf(gpfileTrace, "| ");
            va_start(marker, pszFormat);
            vfprintf(gpfileTrace, pszFormat, marker);
            fflush(gpfileTrace);
            va_end(marker);
        }
        ++giIndent;
    }
}       //EnterProc

/***LP  ExitProc - Exiting a procedure
 *
 *  ENTRY
 *      n - trace level of this procedure
 *      pszFormat -> format string
 *      ... - variable arguments according to format string
 *
 *  EXIT
 *      None
 */

VOID CDECL ExitProc(int n, char *pszFormat, ...)
{
    int i;
    va_list marker;

    if (n <= giTraceLevel)
    {
        --giIndent;
        if (gpfileTrace != NULL)
        {
            fprintf(gpfileTrace, "%s:", MODNAME);
            for (i = 0; i < giIndent; ++i)
                fprintf(gpfileTrace, "| ");
            va_start(marker, pszFormat);
            vfprintf(gpfileTrace, pszFormat, marker);
            fflush(gpfileTrace);
            va_end(marker);
        }
    }
}       //ExitProc

#endif  //ifdef TRACING

/***LP  ErrPrintf - Print to stderr
 *
 *  ENTRY
 *      pszFormat -> format string
 *      ... - variable arguments according to format string
 *
 *  EXIT
 *      None
 */

VOID CDECL ErrPrintf(char *pszFormat, ...)
{
    va_list marker;

    va_start(marker, pszFormat);
    vfprintf(stdout, pszFormat, marker);
    va_end(marker);
}       //ErrPrintf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\line.h ===
/*** line.h - Line stream definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/04/96
 *
 *  This file contains the implementation constants,
 *  imported/exported data types, exported function
 *  prototypes of the line.c module.
 *
 *  MODIFICATION HISTORY
 */

#ifndef _LINE_H
#define _LINE_H

/*** Constants
 */

#define MAX_LINE_LEN            255
#define LINEF_LONGLINE          0x0001

/***    Imported data types
 */

/***    Exported data types
 */

typedef struct line_s
{
    FILE *pfileSrc;
    WORD wfLine;
    WORD wLineNum;
    WORD wLinePos;
    WORD wLineLen;
    char szLineBuff[MAX_LINE_LEN + 1];
} LINE;

typedef LINE *PLINE;

/***    Exported function prototypes
 */

PLINE EXPORT OpenLine(FILE *pfileSrc);
VOID EXPORT CloseLine(PLINE pline);
int EXPORT LineGetC(PLINE pline);
int EXPORT LineUnGetC(int ch, PLINE pline);
VOID EXPORT LineFlush(PLINE pline);

#endif  //ifndef _LINE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\line.c ===
/*** line.c - Line stream related functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/04/96
 *
 *  This module implements the line stream layer so that it can
 *  keep track of the information such as line number and line
 *  position.  This information is necessary for the scanner or
 *  even the parser to accurately pin point the error location
 *  in case of syntax or semantic errors.
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***EP  OpenLine - allocate and initialize line structure
 *
 *  ENTRY
 *      pfileSrc -> source file
 *
 *  EXIT-SUCCESS
 *      returns the pointer to the allocated line structure.
 *  EXIT-FAILURE
 *      returns NULL.
 */

PLINE EXPORT OpenLine(FILE *pfileSrc)
{
    PLINE pline;

    ENTER((5, "OpenLine(pfileSrc=%p)\n", pfileSrc));

    if ((pline = malloc(sizeof(LINE))) == NULL)
        MSG(("OpenLine: failed to allocate line structure"))
    else
    {
        memset(pline, 0, sizeof(LINE));
        pline->pfileSrc = pfileSrc;
    }

    EXIT((5, "OpenLine=%p\n", pline));
    return pline;
}       //OpenLine

/***EP  CloseLine - free line structure
 *
 *  ENTRY
 *      pline->line structure
 *
 *  EXIT
 *      None
 */

VOID EXPORT CloseLine(PLINE pline)
{
    ENTER((5, "CloseLine(pline=%p)\n", pline));

    free(pline);

    EXIT((5, "CloseLine!\n"));
}       //CloseLine

/***EP  LineGetC - get a character from the line stream
 *
 *  This is equivalent to fgetc() except that it has the line
 *  stream layer below it instead of directly from the file.  It
 *  is done this way to preserve the line number and line position
 *  information for accurately pin pointing the error location
 *  if necessary.
 *
 *  ENTRY
 *      pline -> line structure
 *
 *  EXIT-SUCCESS
 *      returns the character
 *  EXIT-FAILURE
 *      returns error code - EOF (end-of-file)
 */

int EXPORT LineGetC(PLINE pline)
{
    int ch = 0;

    ENTER((5, "LineGetC(pline=%p)\n", pline));

    if (pline->wLinePos >= pline->wLineLen)
    {
        //
        // EOL is encountered
        //
        if (fgets(pline->szLineBuff, sizeof(pline->szLineBuff), pline->pfileSrc)
            != NULL)
        {
            pline->wLinePos = 0;
            if (!(pline->wfLine & LINEF_LONGLINE))
                pline->wLineNum++;

            pline->wLineLen = (WORD)strlen(pline->szLineBuff);

            if (pline->szLineBuff[pline->wLineLen - 1] == '\n')
                pline->wfLine &= ~LINEF_LONGLINE;
            else
                pline->wfLine |= LINEF_LONGLINE;
        }
        else
            ch = EOF;
    }

    if (ch == 0)
        ch = (int)pline->szLineBuff[pline->wLinePos++];

    EXIT((5, "LineGetC=%x (ch=%c,Line=%u,NextPos=%u,LineLen=%u)\n",
          ch, ch, pline->wLineNum, pline->wLinePos, pline->wLineLen));
    return ch;
}       //LineGetC

/***EP  LineUnGetC - push a character back to the line stream
 *
 *  This is equivalent to fungetc() except that it's source is
 *  the line stream not the file stream.  Refer to LineGetC for
 *  explanation on this implementation.
 *
 *  ENTRY
 *      ch - character being pushed back
 *      pline -> line structure
 *
 *  EXIT-SUCCESS
 *      returns the character being pushed
 *  EXIT-FAILURE
 *      returns -1
 */

int EXPORT LineUnGetC(int ch, PLINE pline)
{
    ENTER((5, "LineUnGetC(ch=%c,pline=%p)\n", ch, pline));

    ASSERT(pline->wLinePos != 0);
    if (ch != EOF)
    {
        pline->wLinePos--;
        ASSERT((int)pline->szLineBuff[pline->wLinePos] == ch);
    }

    EXIT((5, "LineUnGetC=%x (ch=%c)\n", ch, ch));
    return ch;
}       //LineUnGetC

/***EP  LineFlush - flush a line
 *
 *  The scanner may want to discard the rest of the line when it
 *  detects an in-line comment symbol, for example.
 *
 *  ENTRY
 *      pline -> line structure
 *
 *  EXIT
 *      none
 */

VOID EXPORT LineFlush(PLINE pline)
{
    ENTER((5, "LineFlush(pline=%p)\n", pline));

    pline->wLinePos = pline->wLineLen;

    EXIT((5, "LineFlush!\n"));
}       //LineFlush
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\debug.h ===
/*** debug.h - debug related definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/05/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _DEBUG_H
#define _DEBUG_H

/*** Macros
 */

/*XLATOFF*/

#pragma warning (disable: 4704) //don't complain about in-line assembly

#define MSG(x)          {                                               \
                            ErrPrintf("%s: ", MODNAME);                 \
                            ErrPrintf x;                                \
                            ErrPrintf("\n");                            \
                        }
#define WARN(x)         {                                               \
                            ErrPrintf("%s_WARN: ", MODNAME);            \
                            ErrPrintf x;                                \
                            ErrPrintf("\n");                            \
                        }
#define ERROR(x)        {                                               \
                            ErrPrintf("%s_ERR: ", MODNAME);             \
                            ErrPrintf x;                                \
			    ErrPrintf("\n");				\
                        }

#ifndef DEBUG
  #define WARN1(x)      {}
  #define WARN2(x)      {}
  #define ASSERT(x)     {}
#else
  #define ASSERT(x)   if (!(x))                                         \
                      {                                                 \
                          ErrPrintf("%s_ASSERT: (" #x                   \
                                    ") in line %d of file %s\n",        \
                                    MODNAME, __LINE__, __FILE__);       \
                      }
  #ifndef MAXDEBUG
    #define WARN1       WARN
    #define WARN2(x)    {}
  #else
    #define WARN1       WARN
    #define WARN2       WARN
  #endif
#endif

#ifdef TRACING
  #define OPENTRACE     OpenTrace
  #define CLOSETRACE    CloseTrace
  #define ENTER(p)      EnterProc p
  #define EXIT(p)       ExitProc p
#else
  #define OPENTRACE(x)
  #define CLOSETRACE()
  #define ENTER(p)
  #define EXIT(p)
#endif

/*XLATON*/

//
// Exported data definitions
//
#ifdef TRACING
extern FILE *gpfileTrace;
extern PSZ gpszTraceFile;
extern int giTraceLevel;
extern int giIndent;
#endif


//
// Exported function prototypes
//
VOID CDECL ErrPrintf(char *pszFormat, ...);
#ifdef TRACING
VOID LOCAL OpenTrace(char *pszTraceOut);
VOID LOCAL CloseTrace(VOID);
VOID CDECL EnterProc(int n, char *pszFormat, ...);
VOID CDECL ExitProc(int n, char *pszFormat, ...);
#endif

#endif  //ifndef _DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\parseasl.c ===
/*** parseasl.c - Parse ASL source file
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/07/96
 *
 *  This module implements a recursive decent parser for the ASL language.
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***LP  ParseASLFile - Parse the ASL source file
 *
 *  ENTRY
 *      pszFile -> file name string
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseASLFile(PSZ pszFile)
{
    int rc = ASLERR_NONE;
    FILE *pfileSrc;
    PTOKEN ptoken;
    PSZ pszOldFile;

    ENTER((1, "ParseASLFile(File=%s)\n", pszFile));

    if ((pfileSrc = fopen(pszFile, "r")) == NULL)
    {
        ERROR(("ParseASLFile: failed to open source file - %s", pszFile));
        rc = ASLERR_OPEN_FILE;
    }
    else
    {
        if ((ptoken = OpenScan(pfileSrc)) == NULL)
        {
            ERROR(("ParseASLFile: failed to initialize scanner"));
            rc = ASLERR_INIT_SCANNER;
        }
        else
        {
            pszOldFile = gpszASLFile;
            gpszASLFile = pszFile;
            printf("%s:\n", pszFile);
            if ((rc = ParseASLTerms(ptoken, 0)) == TOKERR_EOF)
                rc = ASLERR_NONE;
            else if (rc == ASLERR_EXPECT_EOF)
            {
                PrintTokenErr(ptoken, "Expecting end-of-file", TRUE);
            }

            gpszASLFile = pszOldFile;
            CloseScan(ptoken);
        }

        fclose(pfileSrc);
    }

    EXIT((1, "ParseASLFile=%d\n", rc));
    return rc;
}       //ParseASLFile

/***LP  ParseASLTerms - Parse all ASL statements
 *
 *  ENTRY
 *      ptoken - token stream
 *      iNestLevel - nesting level of current file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseASLTerms(PTOKEN ptoken, int iNestLevel)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pcode;

    ENTER((1, "ParseASLTerms(ptoken=%p,Level=%d)\n", ptoken, iNestLevel));

    do
    {
        if ((pcode = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
        {
            ERROR(("ParseASLTerms: failed to allocate code object"));
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            memset(pcode, 0, sizeof(CODEOBJ));

            if (gpcodeRoot == NULL)
                gpcodeRoot = pcode;
            else if (gpcodeScope != NULL)
            {
                pcode->pcParent = gpcodeScope;
                ListInsertTail(&pcode->list,
                               (PPLIST)&gpcodeScope->pcFirstChild);
            }

            gpcodeScope = pcode;
            rc = ParseASLTerm(ptoken, iNestLevel);
            gpcodeScope = pcode->pcParent;

            if (rc != ASLERR_NONE)
            {
                if (gpcodeRoot == pcode)
                    gpcodeRoot = NULL;
                else if (gpcodeScope != NULL)
                {
                    ListRemoveEntry(&pcode->list,
                                    (PPLIST)&gpcodeScope->pcFirstChild);
                }

                MEMFREE(pcode);
            }
        }
    } while (rc == ASLERR_NONE);

    EXIT((1, "ParseASLTerms=%d\n", rc));
    return rc;
}       //ParseASLTerms

/***LP  ValidateTermClass - Validate term class with parent
 *
 *  ENTRY
 *      dwTermClass - term class of child
 *      pcParent -> parent
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL LOCAL ValidateTermClass(DWORD dwTermClass, PCODEOBJ pcParent)
{
    BOOL rc = TRUE;

    ENTER((2, "ValidateTermClass(TermClass=%x,Parent=%p)\n",
           dwTermClass, pcParent));

    if ((dwTermClass & TC_COMPILER_DIRECTIVE) == 0)
    {
        while (pcParent != NULL)
        {
            //
            // Go upward to find a parent that is not "Include".
            //
            if (TermTable[pcParent->dwTermIndex].lID == ID_INCLUDE)
            {
                pcParent = pcParent->pcParent;
            }
            else
            {
                break;
            }
        }

        if ((pcParent != NULL) && (pcParent->dwfCode & CF_PARSING_VARLIST))
        {
            rc = (dwTermClass & TermTable[pcParent->dwTermIndex].dwfTerm) != 0;
        }
    }

    EXIT((2, "ValidateTermClass=%d\n", rc));
    return rc;
}       //ValidateTermClass

/***LP  ParseASLTerm - Parse an ASL statement
 *
 *  ENTRY
 *      ptoken - token stream
 *      iNestLevel - nesting level of current file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseASLTerm(PTOKEN ptoken, int iNestLevel)
{
    int rc;

    ENTER((1, "ParseASLTerm(ptoken=%p,Level=%d)\n", ptoken, iNestLevel));

    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_RBRACE, MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        if (iNestLevel == 0)
            rc = ASLERR_EXPECT_EOF;
        else
        {
            //
            // We have no more terms in the current scope
            //
            UnGetToken(ptoken);
            rc = TOKERR_NO_MATCH;
        }
    }
    else if ((rc != TOKERR_EOF) &&
             ((rc = MatchToken(ptoken, TOKTYPE_ID, 0, MTF_ANY_VALUE, NULL)) ==
              TOKERR_NONE))
    {
        if ((gpcodeRoot == NULL) &&
            ((ptoken->llTokenValue < 0) ||
             (TermTable[ptoken->llTokenValue].lID != ID_DEFBLK)))
        {
            //
            // outside of definition block
            //
            rc = ASLERR_EXPECT_EOF;
        }
        else if (ptoken->llTokenValue == ID_USER)       //user term
        {
            if ((rc = ParseUserTerm(ptoken, FALSE)) == TOKERR_NO_MATCH)
            {
                PrintTokenErr(ptoken, "User ID is not a method", TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
        else if (ptoken->llTokenValue >= 0)             //ASL term
        {
            PNSOBJ pnsScopeSave = gpnsCurrentScope;
            PNSOBJ pnsOwnerSave = gpnsCurrentOwner;
            PASLTERM pterm;
            int iNumArgs;

            pterm = &TermTable[ptoken->llTokenValue];
            iNumArgs = pterm->pszArgTypes? strlen(pterm->pszArgTypes): 0;
            gpcodeScope->dwCodeType = CODETYPE_ASLTERM;
            gpcodeScope->dwTermIndex = (DWORD)ptoken->llTokenValue;
            gpcodeScope->dwCodeValue = pterm->dwOpcode;
            gpcodeScope->dwDataLen = (DWORD)iNumArgs;

            if (!ValidateTermClass(pterm->dwfTermClass, gpcodeScope->pcParent))
            {
                PrintTokenErr(ptoken, "unexpected ASL term type", TRUE);
                rc = ASLERR_SYNTAX;
            }
            else if (pterm->pszArgTypes != NULL)        //there is a fixed list
                rc = ParseArgs(ptoken, pterm, iNumArgs);

            if ((rc == ASLERR_NONE) && (pterm->dwfTerm & TF_ACTION_FLIST))
            {
                ASSERT(pterm->pfnTerm != NULL);
                rc = pterm->pfnTerm(ptoken, TRUE);
            }

            if (rc == ASLERR_NONE)
            {
                if (pterm->dwfTerm & TF_ALL_LISTS)
                {
                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_LBRACE, 0,
                                         NULL)) == TOKERR_NONE)
                    {
                        if (pterm->dwfTerm & TF_CHANGE_CHILDSCOPE)
                        {
                            ASSERT(gpcodeScope->pnsObj != NULL);
                            gpnsCurrentScope = gpcodeScope->pnsObj;
                        }

                        if (pterm->lID == ID_METHOD)
                        {
                            gpnsCurrentOwner = gpcodeScope->pnsObj;
                        }

                        gpcodeScope->dwfCode |= CF_PARSING_VARLIST;

                        if (pterm->dwfTerm & TF_FIELD_LIST)
                            rc = ParseFieldList(ptoken);
                        else if (pterm->dwfTerm & TF_PACKAGE_LIST)
                            rc = ParsePackageList(ptoken);
                        else if (pterm->dwfTerm & TF_DATA_LIST)
                            rc = ParseBuffList(ptoken);
                        else if (pterm->dwfTerm & TF_BYTE_LIST)
                            rc = ParseDataList(ptoken, sizeof(BYTE));
                        else if (pterm->dwfTerm & TF_DWORD_LIST)
                            rc = ParseDataList(ptoken, sizeof(DWORD));
                        else
                            rc = ParseASLTerms(ptoken, iNestLevel + 1);

                        gpcodeScope->dwfCode &= ~CF_PARSING_VARLIST;

                        if (((rc == TOKERR_NO_MATCH) || (rc == TOKERR_EOF)) &&
                            ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL,
                                              SYM_RBRACE, 0, NULL)) ==
                             TOKERR_NONE))
                        {
                            ComputeChkSumLen(gpcodeScope);
                            if (pterm->dwfTerm & TF_ACTION_VLIST)
                            {
                                ASSERT(pterm->pfnTerm != NULL);
                                rc = pterm->pfnTerm(ptoken, FALSE);
                            }
                        }
                    }
                }
                else
                {
                    ComputeChkSumLen(gpcodeScope);
                }
            }
            gpnsCurrentScope = pnsScopeSave;
            gpnsCurrentOwner = pnsOwnerSave;
        }
        else
        {
            PrintTokenErr(ptoken, "unexpected term type", TRUE);
            rc = ASLERR_SYNTAX;
        }
    }

    EXIT((1, "ParseASLTerm=%d\n", rc));
    return rc;
}       //ParseASLTerm

/***LP  ParseFieldList - Parse Field List
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseFieldList(PTOKEN ptoken)
{
    int rc = ASLERR_NONE;
    NAMESEG NameSeg;
    DWORD dwcbLen;
    DWORD dwcBits = 0, dwcTotalBits = 0;
    PCODEOBJ pc;
    PNSOBJ pns;

    ENTER((1, "ParseFieldList(ptoken=%p,AccSize=%ld)\n",
           ptoken, gdwFieldAccSize));

    while ((rc == ASLERR_NONE) &&
           (((rc = MatchToken(ptoken, TOKTYPE_ID, 0,
                              MTF_ANY_VALUE | MTF_NOT_ERR, NULL)) ==
             TOKERR_NONE) ||
            ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA, MTF_NOT_ERR,
                              NULL)) == TOKERR_NONE)))
    {
        pns = NULL;
        if (ptoken->iTokenType == TOKTYPE_SYMBOL)
        {
            NameSeg = 0;
            rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0, MTF_ANY_VALUE, NULL);
            dwcBits = (DWORD)ptoken->llTokenValue;
        }
        else if (ptoken->llTokenValue >= 0)
        {
            if (TermTable[ptoken->llTokenValue].lID == ID_OFFSET)
            {
                if (((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_LPARAN, 0,
                                      NULL)) == TOKERR_NONE) &&
                    ((rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0, MTF_ANY_VALUE,
                                      NULL)) == TOKERR_NONE))
                {
                    NameSeg = 0;
                    if ((DWORD)ptoken->llTokenValue*8 >= dwcTotalBits)
                    {
                        dwcBits = (DWORD)ptoken->llTokenValue*8 - dwcTotalBits;
                        rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_RPARAN, 0,
                                        NULL);
                    }
                    else
                    {
                        PrintTokenErr(ptoken, "backward offset is not allowed",
                                      TRUE);
                        rc = ASLERR_SYNTAX;
                    }
                }
            }
            else if (TermTable[ptoken->llTokenValue].lID == ID_ACCESSAS)
            {
                PCODEOBJ pcode;

                UnGetToken(ptoken);
                if ((pcode = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
                {
                    ERROR(("ParseFieldList: failed to allocate code object"));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    ASSERT(gpcodeScope != NULL);
                    memset(pcode, 0, sizeof(CODEOBJ));
                    pcode->pcParent = gpcodeScope;
                    ListInsertTail(&pcode->list,
                                   (PPLIST)&gpcodeScope->pcFirstChild);

                    gpcodeScope = pcode;
                    rc = ParseASLTerm(ptoken, 0);
                    gpcodeScope = pcode->pcParent;

                    if (rc != ASLERR_NONE)
                    {
                        ListRemoveEntry(&pcode->list,
                                        (PPLIST)&gpcodeScope->pcFirstChild);
                        MEMFREE(pcode);
                    }
                    else if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA,
                                              MTF_NOT_ERR, NULL)) ==
                             TOKERR_NONE)
                    {
                        continue;
                    }
                }
            }
            else
            {
                PrintTokenErr(ptoken, "unexpected ASL term in field list",
                              TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
        else
        {
            //
            // expecting a NameSeg and an integer
            //
            dwcbLen = sizeof(NAMESEG);
            if ((ptoken->llTokenValue >= 0) ||      //an ASL term?
                !ValidASLNameSeg(ptoken, ptoken->szToken, strlen(ptoken->szToken)) ||
                ((rc = EncodeName(ptoken->szToken, (PBYTE)&NameSeg, &dwcbLen)) !=
                 ASLERR_NONE) ||
                (dwcbLen != sizeof(NAMESEG)))
            {
                PrintTokenErr(ptoken, "not a valid NameSeg", TRUE);
                rc = ASLERR_SYNTAX;
            }
            else if ((rc = CreateNameSpaceObj(ptoken, ptoken->szToken,
                                              gpnsCurrentScope,
                                              gpnsCurrentOwner,
                                              &pns, NSF_EXIST_ERR)) ==
                     ASLERR_NONE)
            {
                pns->ObjData.dwDataType = OBJTYPE_FIELDUNIT;
                if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA, 0,
                                     NULL)) == TOKERR_NONE)
                {
                    rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0, MTF_ANY_VALUE, NULL);
                    dwcBits = (DWORD)ptoken->llTokenValue;
                }
            }
        }

        if  (rc == ASLERR_NONE)
        {
            if ((NameSeg == 0) && (dwcBits == 0))
            {
                rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA, MTF_NOT_ERR,
                                NULL);
            }
            else if ((pc = MEMALLOC(sizeof(CODEOBJ))) == NULL)
            {
                ERROR(("ParseFieldList: failed to allocate field code object"));
                rc = ASLERR_OUT_OF_MEM;
            }
            else
            {
                int icb;

                memset(pc, 0, sizeof(CODEOBJ));
                if ((rc = EncodePktLen(dwcBits, &pc->dwDataLen, &icb)) ==
                    ASLERR_NONE)
                {
                    dwcTotalBits += dwcBits;
                    if (gpcodeScope->pnsObj != NULL)
                    {
                        ASSERT(gpcodeScope->pnsObj->ObjData.dwDataType ==
                               OBJTYPE_OPREGION);
                        if ((gpcodeScope->pnsObj->ObjData.uipDataValue !=
                             0xffffffff) &&
                            ((dwcTotalBits + 7)/8 >
                             gpcodeScope->pnsObj->ObjData.uipDataValue))
                        {
                            char szMsg[MAX_MSG_LEN + 1];

                            sprintf(szMsg,
                                    "field offset is exceeding operation region range (offset=0x%x)",
                                    (dwcTotalBits + 7)/8);
                            PrintTokenErr(ptoken, szMsg, TRUE);
                            rc = ASLERR_SYNTAX;
                            break;
                        }
                    }

                    pc->pcParent = gpcodeScope;
                    ListInsertTail(&pc->list,
                                   (PPLIST)&gpcodeScope->pcFirstChild);
                    pc->dwCodeType = CODETYPE_FIELDOBJ;
                    if (pns != NULL)
                    {
                        pc->dwfCode |= CF_CREATED_NSOBJ;
                        pc->pnsObj = pns;
                        pns->Context = pc;
                    }
                    pc->dwCodeValue = NameSeg;
                    pc->dwCodeLen = (NameSeg == 0)? sizeof(BYTE):
                                                    sizeof(NAMESEG);
                    pc->dwCodeLen += icb;
                    pc->bCodeChkSum = ComputeDataChkSum((PBYTE)&NameSeg,
                                                        sizeof(NAMESEG));
                    pc->bCodeChkSum = (BYTE)
                        (pc->bCodeChkSum +
                         ComputeDataChkSum((PBYTE)&pc->dwDataLen, icb));

                    rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_COMMA,
                                    MTF_NOT_ERR, NULL);
                }
                else
                {
                    MEMFREE(pc);
                    PrintTokenErr(ptoken, "exceeding maximum encoding limit",
                                  TRUE);
                }
            }
        }
    }

    EXIT((1, "ParseFieldList=%d\n", rc));
    return rc;
}       //ParseFieldList

/***LP  ParsePackageList - Parse Package List
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParsePackageList(PTOKEN ptoken)
{
    int rc;
    PCODEOBJ pc;
    int icElements = 0;
    PCODEOBJ pArgs;

    ENTER((1, "ParsePackageList(ptoken=%p)\n", ptoken));

    do
    {
        if ((pc = MEMALLOC(sizeof(CODEOBJ))) == NULL)
        {
            ERROR(("ParsePackageList: failed to allocate package object"));
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            memset(pc, 0, sizeof(CODEOBJ));
            pc->pcParent = gpcodeScope;
            ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);

            gpcodeScope = pc;
            if ((rc = ParseData(ptoken)) == TOKERR_NO_MATCH)
            {
                UnGetToken(ptoken);
                rc = ParseName(ptoken, TRUE);
            }
            gpcodeScope = pc->pcParent;

            if (rc != ASLERR_NONE)
            {
                ListRemoveEntry(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
                MEMFREE(pc);
            }
            else if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0, MTF_ANY_VALUE,
                                      NULL)) == TOKERR_NONE)
            {
                icElements++;
                if (ptoken->llTokenValue == SYM_RBRACE)
                {
                    UnGetToken(ptoken);
                    rc = TOKERR_NO_MATCH;
                }
                else if (ptoken->llTokenValue != SYM_COMMA)
                {
                    PrintTokenErr(ptoken, "expecting ',' or '}'", TRUE);
                    rc = ASLERR_SYNTAX;
                }
            }
        }
    } while (rc == ASLERR_NONE);

    if (rc == TOKERR_NO_MATCH)
    {
        pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
        if (pArgs[0].dwfCode & CF_MISSING_ARG)
        {
            pArgs[0].dwfCode &= ~CF_MISSING_ARG;
            SetIntObject(&pArgs[0], (DWORD)icElements, sizeof(BYTE));
        }
        else if (pArgs[0].dwCodeValue < (DWORD)icElements)
        {
            PrintTokenErr(ptoken, "Package has too many elements", TRUE);
            rc = ASLERR_SYNTAX;
        }
    }

    EXIT((1, "ParsePackageList=%d\n", rc));
    return rc;
}       //ParsePackageList

/***LP  ParseBuffList - Parse Buffer List
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseBuffList(PTOKEN ptoken)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pc;

    ENTER((1, "ParseBuffList(ptoken=%p)\n", ptoken));

    if ((pc = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
    {
        ERROR(("ParseBuffList: failed to allocate buffer code object"))
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        #define MAX_TEMP_BUFF   256
        PCODEOBJ pArgs;
        DWORD dwReservedLen;
        PBYTE pbBuff;
        DWORD dwBuffSize = MAX_TEMP_BUFF;

        memset(pc, 0, sizeof(CODEOBJ));
        pc->pcParent = gpcodeScope;
        ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
        pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
        pc->dwCodeType = CODETYPE_DATAOBJ;

        if ((rc = MatchToken(ptoken, TOKTYPE_STRING, 0,
                             MTF_ANY_VALUE | MTF_NOT_ERR, NULL)) == TOKERR_NONE)
        {
            pc->dwDataLen = strlen(ptoken->szToken) + 1;

            if (!(pArgs[0].dwfCode & CF_MISSING_ARG) &&
                (pArgs[0].dwCodeType == CODETYPE_DATAOBJ) &&
                ((rc = GetIntData(&pArgs[0], &dwReservedLen)) == ASLERR_NONE) &&
                (pc->dwDataLen > dwReservedLen))
            {
                PrintTokenErr(ptoken, "Buffer has too many initializers", TRUE);
                rc = ASLERR_SYNTAX;
            }
            else
            {
                if ((pc->pbDataBuff = MEMALLOC((size_t)pc->dwDataLen)) == NULL)
                {
                    ERROR(("ParseBuffList: failed to allocate string object - %s",
                           ptoken->szToken));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    memset(pc->pbDataBuff, 0, pc->dwDataLen);
                    memcpy(pc->pbDataBuff, ptoken->szToken, pc->dwDataLen);
                    pc->dwCodeLen = pc->dwDataLen;
                    pc->bCodeChkSum =
                        ComputeDataChkSum(pc->pbDataBuff, pc->dwDataLen);
                }
            }
        }
        else if ((pbBuff = MEMALLOC(dwBuffSize)) == NULL)
        {
            ERROR(("ParseBuffList: failed to allocate temp. buffer"))
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            DWORD dwLen = 0;

            while ((rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0,
                                    MTF_ANY_VALUE | MTF_NOT_ERR, NULL)) ==
                   TOKERR_NONE)
            {
                if (ptoken->llTokenValue > MAX_BYTE)
                {
                    PrintTokenErr(ptoken, "expecting byte value", TRUE);
                    rc = ASLERR_SYNTAX;
                    break;
                }
                else if (dwLen >= MAX_PACKAGE_LEN)
                {
                    PrintTokenErr(ptoken, "data exceeding Buffer limit", TRUE);
                    rc = ASLERR_SYNTAX;
                    break;
                }
                else
                {
                    if (dwLen >= dwBuffSize)
                    {
                        PBYTE pb;

                        dwBuffSize += MAX_TEMP_BUFF;
                        if ((pb = MEMALLOC(dwBuffSize)) == NULL)
                        {
                            ERROR(("ParseBuffList: failed to resize temp. buffer (size=%ld)",
                                   dwBuffSize))
                            rc = ASLERR_OUT_OF_MEM;
                            break;
                        }
                        else
                        {
                            memcpy(pb, pbBuff, dwLen);
                            MEMFREE(pbBuff);
                            pbBuff = pb;
                        }
                    }

                    pbBuff[dwLen++] = (BYTE)ptoken->llTokenValue;
                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0,
                                         MTF_ANY_VALUE, NULL)) == TOKERR_NONE)
                    {
                        if (ptoken->llTokenValue == SYM_RBRACE)
                        {
                            UnGetToken(ptoken);
                            break;
                        }
                        else if (ptoken->llTokenValue != SYM_COMMA)
                        {
                            PrintTokenErr(ptoken, "expecting ',' or '}'", TRUE);
                            rc = ASLERR_SYNTAX;
                            break;
                        }
                    }
                    else
                        break;
                }
            }

            if (rc == TOKERR_NO_MATCH)
                rc = ASLERR_NONE;

            if (rc == ASLERR_NONE)
            {
                pc->dwDataLen = dwLen;
                if (!(pArgs[0].dwfCode & CF_MISSING_ARG) &&
                    (pArgs[0].dwCodeType == CODETYPE_DATAOBJ) &&
                    ((rc = GetIntData(&pArgs[0], &dwReservedLen)) ==
                     ASLERR_NONE) &&
                    (pc->dwDataLen > dwReservedLen))
                {
                    PrintTokenErr(ptoken, "Buffer has too many initializers",
                                  TRUE);
                    rc = ASLERR_SYNTAX;
                }
                else
                {
                    if ((pc->pbDataBuff = MEMALLOC((size_t)pc->dwDataLen)) ==
                        NULL)
                    {
                        ERROR(("ParseBuffList: failed to allocate data object"));
                        rc = ASLERR_OUT_OF_MEM;
                    }
                    else
                    {
                        memset(pc->pbDataBuff, 0, pc->dwDataLen);
                        memcpy(pc->pbDataBuff, pbBuff, pc->dwDataLen);
                        pc->dwCodeLen = pc->dwDataLen;
                        pc->bCodeChkSum =
                            ComputeDataChkSum(pc->pbDataBuff, pc->dwDataLen);
                    }
                }
            }
            MEMFREE(pbBuff);
        }

        if ((rc == ASLERR_NONE) && (pArgs[0].dwfCode & CF_MISSING_ARG))
        {
            pArgs[0].dwfCode &= ~CF_MISSING_ARG;
            rc = MakeIntData(pc->dwDataLen, &pArgs[0]);
        }

        if (rc == ASLERR_NONE)
            rc = TOKERR_NO_MATCH;
    }

    EXIT((1, "ParseBuffList=%d\n", rc));
    return rc;
}       //ParseBuffList

/***LP  ParseDataList - Parse Data List
 *
 *  ENTRY
 *      ptoken - token stream
 *      icbDataSize - data size in bytes
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseDataList(PTOKEN ptoken, int icbDataSize)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pc;

    ENTER((1, "ParseDataList(ptoken=%p,DataSize=%d)\n", ptoken, icbDataSize));

    if ((pc = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
    {
        ERROR(("ParseDataList: failed to allocate buffer code object"))
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        #define MAX_TEMP_BUFF   256
        PBYTE pbBuff;
        DWORD dwBuffSize = MAX_TEMP_BUFF*icbDataSize;

        memset(pc, 0, sizeof(CODEOBJ));
        pc->pcParent = gpcodeScope;
        ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
        pc->dwCodeType = CODETYPE_DATAOBJ;

        if ((pbBuff = MEMALLOC(dwBuffSize)) == NULL)
        {
            ERROR(("ParseDataList: failed to allocate temp. buffer"))
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            DWORD dwLen = 0;

            while ((rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0,
                                    MTF_ANY_VALUE | MTF_NOT_ERR, NULL)) ==
                   TOKERR_NONE)
            {
                switch (icbDataSize)
                {
                    case sizeof(BYTE):
                        if (ptoken->llTokenValue > MAX_BYTE)
                        {
                            PrintTokenErr(ptoken, "expecting byte value", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        break;

                    case sizeof(WORD):
                        if (ptoken->llTokenValue > MAX_WORD)
                        {
                            PrintTokenErr(ptoken, "expecting word value", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        break;

                    case sizeof(DWORD):
                        if (ptoken->llTokenValue > MAX_DWORD)
                        {
                            PrintTokenErr(ptoken, "expecting dword value", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        break;

                    default:
                        ERROR(("ParseDataList: unexpected data size - %d",
                               icbDataSize));
                        rc = ASLERR_INTERNAL_ERROR;
                }

                if (rc != ASLERR_NONE)
                    break;

                if (dwLen + icbDataSize > MAX_PACKAGE_LEN)
                {
                    PrintTokenErr(ptoken, "data exceeding Buffer limit", TRUE);
                    rc = ASLERR_SYNTAX;
                    break;
                }
                else
                {
                    if (dwLen + icbDataSize > dwBuffSize)
                    {
                        PBYTE pb;

                        dwBuffSize += MAX_TEMP_BUFF*icbDataSize;
                        if ((pb = MEMALLOC(dwBuffSize)) == NULL)
                        {
                            ERROR(("ParseDataList: failed to resize temp. buffer (size=%ld)",
                                   dwBuffSize))
                            rc = ASLERR_OUT_OF_MEM;
                            break;
                        }
                        else
                        {
                            memcpy(pb, pbBuff, dwLen);
                            MEMFREE(pbBuff);
                            pbBuff = pb;
                        }
                    }

                    switch (icbDataSize)
                    {
                        case sizeof(BYTE):
                            pbBuff[dwLen] = (BYTE)ptoken->llTokenValue;
                            break;

                        case sizeof(WORD):
                            *((PWORD)&pbBuff[dwLen]) = (WORD)
                                ptoken->llTokenValue;
                            break;

                        case sizeof(DWORD):
                            *((PDWORD)&pbBuff[dwLen]) = (DWORD)
                                ptoken->llTokenValue;
                            break;
                    }
                    dwLen += icbDataSize;

                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0,
                                         MTF_ANY_VALUE, NULL)) == TOKERR_NONE)
                    {
                        if (ptoken->llTokenValue == SYM_RBRACE)
                        {
                            UnGetToken(ptoken);
                            break;
                        }
                        else if (ptoken->llTokenValue != SYM_COMMA)
                        {
                            PrintTokenErr(ptoken, "expecting ',' or '}'", TRUE);
                            rc = ASLERR_SYNTAX;
                            break;
                        }
                    }
                    else
                        break;
                }
            }

            if (rc == TOKERR_NO_MATCH)
                rc = ASLERR_NONE;

            if (rc == ASLERR_NONE)
            {
                pc->dwDataLen = dwLen;
                if ((pc->pbDataBuff = MEMALLOC(pc->dwDataLen)) == NULL)
                {
                    ERROR(("ParseDataList: failed to allocate data object"));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    memcpy(pc->pbDataBuff, pbBuff, pc->dwDataLen);
                    pc->dwCodeLen = pc->dwDataLen;
                    pc->bCodeChkSum =
                        ComputeDataChkSum(pc->pbDataBuff, pc->dwDataLen);
                }
            }
            MEMFREE(pbBuff);
        }

        if (rc == ASLERR_NONE)
            rc = TOKERR_NO_MATCH;
    }

    EXIT((1, "ParseDataList=%d\n", rc));
    return rc;
}       //ParseDataList

/***LP  ParseArgs - Parse ASL term arguments
 *
 *  ENTRY
 *      ptoken - token stream
 *      pterm -> asl term
 *      iNumArgs - number of arguments
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseArgs(PTOKEN ptoken, PASLTERM pterm, int iNumArgs)
{
    int rc = ASLERR_NONE;

    ENTER((1, "ParseArgs(ptoken=%p,pterm=%p,NumArgs=%d)\n",
           ptoken, pterm, iNumArgs));

    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_LPARAN, 0, NULL)) ==
        TOKERR_NONE)
    {
        PCODEOBJ pArgs = NULL;

        if ((iNumArgs != 0) &&
            ((pArgs = MEMALLOC(sizeof(CODEOBJ)*iNumArgs)) == NULL))
        {
            ERROR(("ParseArgs: failed to allocate argument objects"))
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            int i;
            char chArgType;
            char szNameBuff[MAX_NSPATH_LEN + 1];
            BOOL fOptional;
            PSZ pszArgType = "Unknown";

            gpcodeScope->dwfCode |= CF_PARSING_FIXEDLIST;
            if (pArgs != NULL)
            {
                gpcodeScope->pbDataBuff = (PBYTE)pArgs;
                memset(pArgs, 0, sizeof(CODEOBJ)*iNumArgs);
            }

            for (i = 0; (rc == ASLERR_NONE) && (i < iNumArgs); ++i)
            {
                chArgType = pterm->pszArgTypes[i];
                if (islower(chArgType))
                {
                    chArgType = (char)_toupper(chArgType);
                    fOptional = TRUE;
                }
                else
                    fOptional = FALSE;

                pArgs[i].pcParent = gpcodeScope;

                gpcodeScope = &pArgs[i];
                switch (chArgType)
                {
                    case 'N':
                    case 'R':
                        rc = ParseName(ptoken, (chArgType == 'N')? TRUE: FALSE);
                        pszArgType = "Name";
                        break;

                    case 'S':
                        if (((rc = ParseSuperName(ptoken)) ==
                             TOKERR_NO_MATCH) && fOptional)
                        {
                            pArgs[i].dwCodeType = CODETYPE_ASLTERM;
                            pArgs[i].dwCodeValue = OP_ZERO;
                            pArgs[i].dwCodeLen = 0;
                            pArgs[i].bCodeChkSum = OP_ZERO;
                            rc = LookupIDIndex(ID_ZERO,
                                               &pArgs[i].dwTermIndex);
                        }
                        pszArgType = "SuperName";
                        break;

                    case 'O':
                        rc = ParseData(ptoken);
                        pszArgType = "DataObject";
                        break;

                    case 'B':
                    case 'W':
                    case 'D':
                    case 'U':
                    case 'Q':
                        rc = ParseInteger(ptoken, chArgType);
                        if (chArgType == 'B')
                            pszArgType = "ByteInteger";
                        else if (chArgType == 'W')
                            pszArgType = "WordInteger";
                        else if (chArgType == 'D')
                            pszArgType = "DWordInteger";
                        else if (chArgType == 'Q')
                            pszArgType = "QWordInteger";
                        else
                            pszArgType = "Integer";
                        break;

                    case 'C':
                    case 'M':
                    case 'P':
                        rc = ParseOpcode(ptoken, chArgType);
                        pszArgType = "Opcode";
                        break;

                    case 'E':
                    case 'K':
                        rc = ParseKeyword(ptoken, pterm->pszArgActions[i]);
                        pszArgType = "Keyword";
                        if ((chArgType == 'E') && (rc == TOKERR_NO_MATCH))
                        {
                            if ((rc = ParseInteger(ptoken, 'B')) == ASLERR_NONE)
                            {
                                if ((pterm->pszArgActions[i] != 'Y') &&
                                    //
                                    // AccessAttribKeyword ( pszArgActions type 'Y' ) may be replaced
                                    // by any integer value.  
                                    // Size checking is performed in AccessAs function.
                                    //
                                    ((gpcodeScope->dwCodeValue <
                                      (pterm->dwTermData >> 24)) ||
                                     (gpcodeScope->dwCodeValue >
                                      ((pterm->dwTermData >> 16) & 0xff))))
                                {
                                    PrintTokenErr(ptoken,
                                                  "invalid integer range",
                                                  TRUE);
                                    rc = ASLERR_SYNTAX;
                                }
                            }
                        }
                        break;

                    case 'Z':
                        rc = ParseString(ptoken);
                        pszArgType = "String";
                        break;
                }
                gpcodeScope = pArgs[i].pcParent;

                if (rc == TOKERR_NO_MATCH)
                {
                    if (fOptional)
                    {
                        pArgs[i].dwfCode |= CF_MISSING_ARG;
                        rc = ASLERR_NONE;
                    }
                    else
                    {
                        char szMsg[MAX_MSG_LEN + 1];

                        sprintf(szMsg, "expecting argument type \"%s\"",
                                pszArgType);
                        PrintTokenErr(ptoken, szMsg, TRUE);
                        rc = ASLERR_SYNTAX;
                    }
                }

                if ((rc == ASLERR_NONE) && (pterm->pszArgActions != NULL) &&
                    ((chArgType == 'N') || (chArgType == 'S') ||
                     (chArgType == 'C') || (chArgType == 'M') ||
                     (chArgType == 'P')) &&
                    (pArgs[i].dwCodeType == CODETYPE_NAME) &&
                    ((rc = DecodeName(pArgs[i].pbDataBuff, szNameBuff,
                                      sizeof(szNameBuff))) == ASLERR_NONE))
                {
                    char chActType = pterm->pszArgActions[i];

                    if (islower(chActType))
                    {
                        rc = CreateObject(ptoken, szNameBuff,
                                          (char)_toupper(chActType), NULL);
                    }
                    else
                    {
                        rc = ValidateObject(ptoken, szNameBuff, chActType,
                                            chArgType);
                    }
                }

                if (rc == ASLERR_NONE)
                {   //
                    // expecting either a comma or a close paran.
                    //
                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0,
                                         MTF_ANY_VALUE, NULL)) == TOKERR_NONE)
                    {
                        if (ptoken->llTokenValue == SYM_RPARAN)
                        {
                            UnGetToken(ptoken);
                        }
                        else if (ptoken->llTokenValue != SYM_COMMA)
                        {
                            PrintTokenErr(ptoken, "expecting ',' or ')'", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        else if (i == iNumArgs - 1)     //last argument
                        {
                            PrintTokenErr(ptoken, "expecting ')'", TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                    }
                }
            }
            gpcodeScope->dwfCode &= ~CF_PARSING_FIXEDLIST;

            if (rc == ASLERR_NONE)
                rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_RPARAN, 0, NULL);
        }

    }

    EXIT((1, "ParseArgs=%d\n", rc));
    return rc;
}       //ParseArgs

/***LP  ParseUserTerm - Parse user method name
 *
 *  ENTRY
 *      ptoken - token stream
 *      fNonMethodOK - if TRUE, user term can be a non-method
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseUserTerm(PTOKEN ptoken, BOOL fNonMethodOK)
{
    int rc;

    ENTER((1, "ParseUserTerm(ptoken=%p,fNonMethodOK=%d)\n",
           ptoken, fNonMethodOK));

    //
    // Max number of argument is 7 but we need to store the user term name too,
    // we will store it in Arg0, so we will make it 8.
    //
    if ((gpcodeScope->pbDataBuff = MEMALLOC(sizeof(CODEOBJ)*(MAX_ARGS + 1))) ==
        NULL)
    {
        ERROR(("ParseUserTerm: failed to allocate user term object"));
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        PCODEOBJ pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
        int i;

        gpcodeScope->dwCodeType = CODETYPE_USERTERM;
        gpcodeScope->dwDataLen = MAX_ARGS + 1;
        memset(pArgs, 0, sizeof(CODEOBJ)*gpcodeScope->dwDataLen);

        pArgs[0].pcParent = gpcodeScope;
        gpcodeScope = &pArgs[0];
        UnGetToken(ptoken);
        if ((rc = ParseName(ptoken, TRUE)) == TOKERR_NONE)
        {
            PNSOBJ pns;
            char szName[MAX_NSPATH_LEN + 1];

            strcpy(szName, ptoken->szToken);
            GetNameSpaceObj(szName, gpnsCurrentScope, &pns, 0);

            gpcodeScope = pArgs[0].pcParent;
            if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_LPARAN,
                                 fNonMethodOK? MTF_NOT_ERR: 0, NULL)) ==
                TOKERR_NONE)
            {
                for (i = 1;
                     (rc == TOKERR_NONE) && (i < (int)gpcodeScope->dwDataLen);
                     ++i)
                {
                    pArgs[i].pcParent = gpcodeScope;
                    gpcodeScope = &pArgs[i];
                    if ((rc = ParseOpcode(ptoken, 'C')) == TOKERR_NONE)
                    {
                        if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, 0,
                                             MTF_ANY_VALUE, NULL)) ==
                            TOKERR_NONE)
                        {
                            if (ptoken->llTokenValue == SYM_RPARAN)
                            {
                                UnGetToken(ptoken);
                                gpcodeScope = pArgs[i].pcParent;
                                //
                                // Readjust the number of arguments
                                //
                                gpcodeScope->dwDataLen = i + 1;
                                break;
                            }
                            else if (ptoken->llTokenValue != SYM_COMMA)
                            {
                                PrintTokenErr(ptoken, "expecting ',' or ')'",
                                              TRUE);
                                rc = ASLERR_SYNTAX;
                            }
                        }
                    }
                    else if (rc == TOKERR_NO_MATCH)
                    {
                        gpcodeScope = pArgs[i].pcParent;
                        //
                        // Readjust the number of arguments
                        //
                        gpcodeScope->dwDataLen = i;
                        rc = TOKERR_NONE;
                        break;
                    }

                    gpcodeScope = pArgs[i].pcParent;
                }

                if (rc == TOKERR_NONE)
                {
                    ComputeArgsChkSumLen(gpcodeScope);
                    if ((rc = MatchToken(ptoken, TOKTYPE_SYMBOL, SYM_RPARAN, 0,
                                         NULL)) == ASLERR_NONE)
                    {
                        char szMsg[MAX_MSG_LEN + 1];

                        if (pns == NULL)
                        {
                            rc = QueueNSChk(ptoken, szName, OBJTYPE_METHOD,
                                            gpcodeScope->dwDataLen - 1);
                        }
                        else if (pns->ObjData.dwDataType != OBJTYPE_METHOD)
                        {
                            sprintf(szMsg, "%s is not a method", szName);
                            PrintTokenErr(ptoken, szMsg, TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        else if (pns->ObjData.uipDataValue <
                                 gpcodeScope->dwDataLen - 1)
                        {
                            sprintf(szMsg, "%s has too many arguments", szName);
                            PrintTokenErr(ptoken, szMsg, TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                        else if (pns->ObjData.uipDataValue >
                                 gpcodeScope->dwDataLen - 1)
                        {
                            sprintf(szMsg, "%s has too few arguments", szName);
                            PrintTokenErr(ptoken, szMsg, TRUE);
                            rc = ASLERR_SYNTAX;
                        }
                    }
                }
            }
            else if (rc == TOKERR_NO_MATCH)
            {
                gpcodeScope->dwCodeType = pArgs[0].dwCodeType;
                gpcodeScope->dwDataLen = pArgs[0].dwDataLen;
                gpcodeScope->pbDataBuff = pArgs[0].pbDataBuff;
                gpcodeScope->dwCodeLen = pArgs[0].dwCodeLen;
                gpcodeScope->bCodeChkSum = pArgs[0].bCodeChkSum;
                MEMFREE(pArgs);
                if (pns == NULL)
                {
                    rc = QueueNSChk(ptoken, szName, OBJTYPE_UNKNOWN, 0);
                }
                else
                {
                    rc = TOKERR_NONE;
                }
            }
        }
    }

    EXIT((1, "ParseUserTerm=%d\n", rc));
    return rc;
}       //ParseUserTerm

/***LP  ParseName - Parse ASL name
 *
 *  ENTRY
 *      ptoken - token stream
 *      fEncode - TRUE if encode name else store it raw as string
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseName(PTOKEN ptoken, BOOL fEncode)
{
    int rc;
    BYTE abBuff[MAX_NAMECODE_LEN];
    DWORD dwLen = sizeof(abBuff);

    ENTER((1, "ParseName(ptoken=%p,fEncode=%x)\n", ptoken, fEncode));

    if ((rc = MatchToken(ptoken, TOKTYPE_ID, ID_USER, MTF_NOT_ERR, NULL)) ==
        TOKERR_NONE)
    {
        if (!ValidASLName(ptoken, ptoken->szToken))
        {
            PrintTokenErr(ptoken, "expecting ASL name", TRUE);
            rc = ASLERR_SYNTAX;
        }
        else if (fEncode)
        {
            if ((rc = EncodeName(ptoken->szToken, abBuff, &dwLen)) ==
                ASLERR_NONE)
            {
                if ((gpcodeScope->pbDataBuff = MEMALLOC((size_t)dwLen)) == NULL)
                {
                    ERROR(("ParseName: failed to allocate name string object - %s",
                           ptoken->szToken));
                    rc = ASLERR_OUT_OF_MEM;
                }
                else
                {
                    memcpy(gpcodeScope->pbDataBuff, abBuff, (int)dwLen);
                    gpcodeScope->dwCodeType = CODETYPE_NAME;
                    gpcodeScope->dwDataLen = dwLen;
                    gpcodeScope->dwCodeLen = dwLen;
                    gpcodeScope->bCodeChkSum =
                        ComputeDataChkSum(gpcodeScope->pbDataBuff, dwLen);
                }
            }
            else
            {
                PrintTokenErr(ptoken, "name too long", TRUE);
            }
        }
        else
        {
            gpcodeScope->dwDataLen = strlen(ptoken->szToken) + 1;
            if ((gpcodeScope->pbDataBuff = MEMALLOC(gpcodeScope->dwDataLen)) !=
                NULL)
            {
                memcpy(gpcodeScope->pbDataBuff, ptoken->szToken,
                       gpcodeScope->dwDataLen);
                gpcodeScope->dwCodeType = CODETYPE_STRING;
                gpcodeScope->dwCodeLen = gpcodeScope->dwDataLen;
                gpcodeScope->bCodeChkSum =
                    ComputeDataChkSum(gpcodeScope->pbDataBuff,
                                      gpcodeScope->dwDataLen);
            }
            else
            {
                ERROR(("ParseName: failed to allocate raw name string object - %s",
                       ptoken->szToken));
                rc = ASLERR_OUT_OF_MEM;
            }
        }
    }

    EXIT((1, "ParseName=%d (Name=%s)\n", rc, ptoken->szToken));
    return rc;
}       //ParseName

/***LP  ParseSuperName - Parse ASL super name
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseSuperName(PTOKEN ptoken)
{
    int rc;

    ENTER((1, "ParseSuperName(ptoken=%p)\n", ptoken));

    if ((rc = MatchToken(ptoken, TOKTYPE_ID, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        if (ptoken->llTokenValue == ID_USER)
        {
            UnGetToken(ptoken);
            rc = ParseName(ptoken, TRUE);
        }
        else
        {
            if (TermTable[ptoken->llTokenValue].dwfTermClass &
                TC_SHORT_NAME)
            {
                gpcodeScope->dwCodeType = CODETYPE_ASLTERM;
                gpcodeScope->dwTermIndex = (DWORD)ptoken->llTokenValue;
                gpcodeScope->dwCodeValue =
                    TermTable[ptoken->llTokenValue].dwOpcode;
            }
            else if (TermTable[ptoken->llTokenValue].dwfTermClass &
                     TC_REF_OBJECT)
            {
                UnGetToken(ptoken);
                rc = ParseASLTerm(ptoken, 0);
            }
            else
            {
                UnGetToken(ptoken);
                rc = TOKERR_NO_MATCH;
            }
        }
    }

    EXIT((1, "ParseSuperName=%d\n", rc));
    return rc;
}       //ParseSuperName

/***LP  MakeIntData - make integer data object
 *
 *  ENTRY
 *      dwData - integer data
 *      pc -> code object
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL MakeIntData(DWORD dwData, PCODEOBJ pc)
{
    int rc = ASLERR_NONE;
    DWORD dwLen;
    BYTE bOp;

    ENTER((1, "MakeIntData(Data=%lx,pc=%p)\n", dwData, pc));

    pc->dwCodeType = CODETYPE_DATAOBJ;
    if ((dwData & 0xffffff00) == 0)
    {
        bOp = OP_BYTE;
        dwLen = 2;
    }
    else if ((dwData & 0xffff0000) == 0)
    {
        bOp = OP_WORD;
        dwLen = 3;
    }
    else
    {
        bOp = OP_DWORD;
        dwLen = 5;
    }

    if ((pc->pbDataBuff = MEMALLOC((size_t)dwLen)) == NULL)
    {
        ERROR(("MakeIntData: failed to allocate data object - %lx", dwData));
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        pc->dwDataLen = dwLen;
        pc->dwCodeLen = dwLen;
        pc->pbDataBuff[0] = bOp;
        memcpy(&pc->pbDataBuff[1], &dwData, (int)(dwLen - 1));
        pc->bCodeChkSum = ComputeDataChkSum(pc->pbDataBuff, dwLen);
    }

    EXIT((1, "MakeIntData=%d\n", rc));
    return rc;
}       //MakeIntData

/***LP  GetIntData - get integer from a data object
 *
 *  ENTRY
 *      pc -> code object
 *      pdwData -> to hold integer data
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL GetIntData(PCODEOBJ pc, PDWORD pdwData)
{
    int rc = ASLERR_NONE;

    ENTER((1, "GetIntData(pc=%p,pdwData=%p)\n", pc, pdwData));

    ASSERT(pc->dwCodeType == CODETYPE_DATAOBJ);
    switch (pc->pbDataBuff[0])
    {
        case OP_BYTE:
            *pdwData = (DWORD)(*((PBYTE)&pc->pbDataBuff[1]));
            break;

        case OP_WORD:
            *pdwData = (DWORD)(*((PWORD)&pc->pbDataBuff[1]));
            break;

        case OP_DWORD:
            *pdwData = *((PDWORD)&pc->pbDataBuff[1]);
            break;

        default:
            ERROR(("GetIntData: data object is not integer type"));
            rc = ASLERR_INVALID_OBJTYPE;
    }

    EXIT((1, "GetIntData=%d (Data=%lx)\n", rc, *pdwData));
    return rc;
}       //GetIntData

/***LP  ParseData - Parse ASL data object
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseData(PTOKEN ptoken)
{
    int rc;

    ENTER((1, "ParseData(ptoken=%p)\n", ptoken));

    if ((rc = GetToken(ptoken)) == TOKERR_NONE)
    {
        if (ptoken->iTokenType == TOKTYPE_NUMBER)
        {
            if (ptoken->llTokenValue <= MAX_DWORD)
            {
                rc = MakeIntData((DWORD)ptoken->llTokenValue, gpcodeScope);
            }
            else
            {
                PrintTokenErr(ptoken, "data value exceeding DWORD maximum",
                              TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
        else if (ptoken->iTokenType == TOKTYPE_STRING)
        {
            DWORD dwLen;

            gpcodeScope->dwCodeType = CODETYPE_DATAOBJ;
            dwLen = strlen(ptoken->szToken) + 2;
            if ((gpcodeScope->pbDataBuff = MEMALLOC((size_t)dwLen)) == NULL)
            {
                ERROR(("ParseData: failed to allocate string object - %s",
                       ptoken->szToken));
                rc = ASLERR_OUT_OF_MEM;
            }
            else
            {
                gpcodeScope->dwDataLen = dwLen;
                gpcodeScope->dwCodeLen = dwLen;
                gpcodeScope->pbDataBuff[0] = OP_STRING;
                memcpy(&gpcodeScope->pbDataBuff[1], ptoken->szToken,
                       (int)(dwLen - 1));
                gpcodeScope->bCodeChkSum =
                    ComputeDataChkSum(gpcodeScope->pbDataBuff, dwLen);
            }
        }
        else if ((ptoken->iTokenType != TOKTYPE_ID) ||
                 (ptoken->llTokenValue < 0) ||
                 ((TermTable[ptoken->llTokenValue].dwfTermClass &
                   (TC_DATA_OBJECT | TC_CONST_NAME)) == 0))
        {
            UnGetToken(ptoken);
            rc = TOKERR_NO_MATCH;
        }
        else
        {
            UnGetToken(ptoken);
            rc = ParseASLTerm(ptoken, 0);
        }
    }

    EXIT((1, "ParseData=%d\n", rc));
    return rc;
}       //ParseData

/***LP  ParseInteger - Parse integer data
 *
 *  ENTRY
 *      ptoken - token stream
 *      c - integer type
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseInteger(PTOKEN ptoken, char c)
{
    int rc;

    ENTER((1, "ParseInteger(ptoken=%p,ch=%c)\n", ptoken, c));

    if ((rc = MatchToken(ptoken, TOKTYPE_NUMBER, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        gpcodeScope->dwCodeValue = 0;
        if ((c == 'B') && ((ptoken->llTokenValue & 0xffffffffffffff00) != 0) ||
            (c == 'W') && ((ptoken->llTokenValue & 0xffffffffffff0000) != 0) ||
            (c == 'D') && ((ptoken->llTokenValue & 0xffffffff00000000) != 0))
        {
            char szMsg[MAX_MSG_LEN + 1];

            sprintf(szMsg, "expecting %s value",
                    (c == 'B')? "byte":
                    (c == 'W')? "word": "dword");
            PrintTokenErr(ptoken, szMsg, TRUE);
            rc = ASLERR_SYNTAX;
        }
        else if (c == 'U')
        {
            if (ptoken->llTokenValue <= MAX_DWORD)
            {
                rc = MakeIntData((DWORD)ptoken->llTokenValue, gpcodeScope);
            }
            else
            {
                PrintTokenErr(ptoken, "data value exceeding DWORD maximum",
                              TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
        else if (c != 'Q')
        {
            gpcodeScope->dwCodeType = CODETYPE_INTEGER;
            gpcodeScope->dwDataLen = (c == 'B')? sizeof(BYTE):
                                     (c == 'W')? sizeof(WORD):
                                     (c == 'D')? sizeof(DWORD):
                                     ((ptoken->llTokenValue &
                                       0xffffffffffffff00) == 0)? sizeof(BYTE):
                                     ((ptoken->llTokenValue &
                                       0xffffffffffff0000) == 0)? sizeof(WORD):
                                     sizeof(DWORD);
            gpcodeScope->dwCodeLen = gpcodeScope->dwDataLen;
            gpcodeScope->dwCodeValue = (DWORD)ptoken->llTokenValue;
            gpcodeScope->bCodeChkSum =
                ComputeDataChkSum((PBYTE)&ptoken->llTokenValue,
                                  gpcodeScope->dwDataLen);
        }
        else if ((gpcodeScope->pbDataBuff =
                  MEMALLOC(gpcodeScope->dwDataLen = sizeof(QWORD))) != NULL)
        {
            gpcodeScope->dwCodeType = CODETYPE_QWORD;
            memcpy(gpcodeScope->pbDataBuff, &ptoken->llTokenValue,
                   gpcodeScope->dwDataLen);
            gpcodeScope->dwCodeLen = gpcodeScope->dwDataLen;
            gpcodeScope->bCodeChkSum =
                ComputeDataChkSum(gpcodeScope->pbDataBuff,
                                  gpcodeScope->dwDataLen);
        }
        else
        {
            ERROR(("ParseInteger: failed to allocate QWord object - %s",
                   ptoken->szToken));
            rc = ASLERR_OUT_OF_MEM;
        }
    }

    EXIT((1, "ParseInteger=%d\n", rc));
    return rc;
}       //ParseInteger

/***LP  ParseOpcode - Parse ASL opcode: MachineCode, FunctionCode, SuperName
 *
 *  ENTRY
 *      ptoken - token stream
 *      c - opcode type
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseOpcode(PTOKEN ptoken, char c)
{
    int rc;

    ENTER((1, "ParseOpcode(ptoken=%p,ch=%c)\n", ptoken, c));

    if ((rc = MatchToken(ptoken, TOKTYPE_ID, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        if (ptoken->llTokenValue == ID_USER)
        {
            PNSOBJ pns;

            if ((GetNameSpaceObj(ptoken->szToken, gpnsCurrentScope, &pns, 0) ==
                 ASLERR_NONE) &&
                (pns->ObjData.dwDataType == OBJTYPE_RES_FIELD) &&
                ((c == 'M') || (c == 'P')))
            {
                DWORD dwValue = 0;

                if (c == 'P')
                {
                    dwValue = pns->ObjData.uipDataValue;
                }
                else if (pns->ObjData.uipDataValue%8 == 0)
                {
                    dwValue = pns->ObjData.uipDataValue/8;
                }
                else
                {
                    PrintTokenErr(ptoken,
                                  "object can only be used in CreateField "
                                  "or CreateBitField statements",
                                  TRUE);
                    rc = ASLERR_SYNTAX;
                }

                if (rc == ASLERR_NONE)
                {
                    rc = MakeIntData(dwValue, gpcodeScope);
                }
            }
            else
            {
                rc = ParseUserTerm(ptoken, TRUE);
            }
        }
        else
        {
            UnGetToken(ptoken);
            if (TermTable[ptoken->llTokenValue].dwfTermClass & TC_OPCODE)
            {
                rc = ParseASLTerm(ptoken, 0);
            }
            else
            {
                rc = TOKERR_NO_MATCH;
            }
        }
    }
    else
        rc = ParseData(ptoken);

    EXIT((1, "ParseOpcode=%d\n", rc));
    return rc;
}       //ParseOpcode

/***LP  ParseKeyword - Parse ASL keyword
 *
 *  ENTRY
 *      ptoken - token stream
 *      chExpectType - expected keyword type
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 *
 *  NOTE
 *      DATATYPE_KEYWORD is a transient type.  It will be lumped together with
 *      other keyword type arguments and be converted into one DATATYPE_INTEGER.
 */

int LOCAL ParseKeyword(PTOKEN ptoken, char chExpectType)
{
    int rc;

    ENTER((1, "ParseKeyword(ptoken=%p,ExpectedType=%c)\n",
           ptoken, chExpectType));

    if ((rc = MatchToken(ptoken, TOKTYPE_ID, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        if ((ptoken->llTokenValue == ID_USER) ||
            !(TermTable[ptoken->llTokenValue].dwfTermClass & TC_KEYWORD))
        {
            UnGetToken(ptoken);
            rc = TOKERR_NO_MATCH;
        }
        else if (TermTable[ptoken->llTokenValue].pszArgActions[0] !=
                 chExpectType)
        {
            PrintTokenErr(ptoken, "incorrect keyword type", TRUE);
            rc = ASLERR_SYNTAX;
        }
        else
        {
            gpcodeScope->dwCodeType = CODETYPE_KEYWORD;
            gpcodeScope->dwTermIndex = (DWORD)ptoken->llTokenValue;
            gpcodeScope->dwCodeValue = TOKID(ptoken->llTokenValue);
        }
    }

    EXIT((1, "ParseKeyword=%d\n", rc));
    return rc;
}       //ParseKeyword

/***LP  ParseString - Parse string object
 *
 *  ENTRY
 *      ptoken - token stream
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseString(PTOKEN ptoken)
{
    int rc;

    ENTER((1, "ParseString(ptoken=%p)\n", ptoken));

    if ((rc = MatchToken(ptoken, TOKTYPE_STRING, 0, MTF_ANY_VALUE | MTF_NOT_ERR,
                         NULL)) == TOKERR_NONE)
    {
        gpcodeScope->dwDataLen = strlen(ptoken->szToken) + 1;
        if (gpcodeScope->dwDataLen > MAX_STRING_LEN + 1)
        {
            ERROR(("ParseString: string too big - %s", ptoken->szToken));
            rc = ASLERR_SYNTAX;
        }
        else if ((gpcodeScope->pbDataBuff =
                  MEMALLOC((size_t)gpcodeScope->dwDataLen)) == NULL)
        {
            ERROR(("ParseString: failed to allocate string object - %s",
                   ptoken->szToken));
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            gpcodeScope->dwCodeType = CODETYPE_STRING;
            memcpy(gpcodeScope->pbDataBuff, ptoken->szToken,
                   (int)gpcodeScope->dwDataLen);
            gpcodeScope->dwCodeLen = gpcodeScope->dwDataLen;
            gpcodeScope->bCodeChkSum =
                ComputeDataChkSum(gpcodeScope->pbDataBuff,
                                  gpcodeScope->dwDataLen);
        }
    }

    EXIT((1, "ParseString=%d\n", rc));
    return rc;
}       //ParseString

/***LP  ValidateObject - Validate the existence and type of the object
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      pszName -> object name
 *  chActType - action type
 *      chArgType - argument type
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ValidateObject(PTOKEN ptoken, PSZ pszName, char chActType,
                         char chArgType)
{
    int rc = ASLERR_NONE;
    ULONG dwDataType = OBJTYPE_UNKNOWN;

    ENTER((2, "ValidateObject(ptoken=%p,Name=%s,ActType=%c,ArgType=%c)\n",
           ptoken, pszName, chActType, chArgType));

    switch (chActType)
    {
        case NSTYPE_UNKNOWN:
        case NSTYPE_SCOPE:
            break;

        case NSTYPE_FIELDUNIT:
            dwDataType = OBJTYPE_FIELDUNIT;
            break;

        case NSTYPE_DEVICE:
            dwDataType = OBJTYPE_DEVICE;
            break;

        case NSTYPE_EVENT:
            dwDataType = OBJTYPE_EVENT;
            break;

        case NSTYPE_METHOD:
            dwDataType = OBJTYPE_METHOD;
            break;

        case NSTYPE_MUTEX:
            dwDataType = OBJTYPE_MUTEX;
            break;

        case NSTYPE_OPREGION:
            dwDataType = OBJTYPE_OPREGION;
            break;

        case NSTYPE_POWERRES:
            dwDataType = OBJTYPE_POWERRES;
            break;

        case NSTYPE_PROCESSOR:
            dwDataType = OBJTYPE_PROCESSOR;
            break;

        case NSTYPE_THERMALZONE:
            dwDataType = OBJTYPE_THERMALZONE;
            break;

        case NSTYPE_OBJALIAS:
            dwDataType = OBJTYPE_OBJALIAS;
            break;

        case NSTYPE_BUFFFIELD:
            dwDataType = OBJTYPE_BUFFFIELD;
            break;

        default:
            ERROR(("ValidateObject: invalid object type %c", chActType));
            rc = ASLERR_INVALID_OBJTYPE;
    }

    if ((rc == ASLERR_NONE) && (strcmp(pszName, "\\_OSI") != 0))
    {
        PNSOBJ pns;
        char szMsg[MAX_MSG_LEN + 1];

        if (((rc = GetNameSpaceObj(pszName, gpnsCurrentScope, &pns, 0)) ==
             ASLERR_NONE) &&
            ((pns->hOwner == NULL) ||
             ((PNSOBJ)pns->hOwner == gpnsCurrentOwner)))
        {
        if ((pns->ObjData.dwDataType == OBJTYPE_RES_FIELD) &&
            (chArgType != 'M') && (chArgType != 'P'))
        {
                PrintTokenErr(ptoken,
                              "object can only be used in the index argument "
                              "of CreateXField or Index statements",
                              TRUE);
                rc = ASLERR_SYNTAX;
        }
            else if ((dwDataType != OBJTYPE_UNKNOWN) &&
                (pns->ObjData.dwDataType != dwDataType))
            {
                sprintf(szMsg,
                        "%s has an incorrect type (ObjType=%s, ExpectedType=%s)",
                        pszName, GetObjectTypeName(pns->ObjData.dwDataType),
                        GetObjectTypeName(dwDataType));
                PrintTokenErr(ptoken, szMsg, TRUE);
                rc = ASLERR_SYNTAX;
            }
            else if ((chActType == NSTYPE_SCOPE) ||
                 (chActType == NSTYPE_OPREGION))
            {
                ASSERT(gpcodeScope->pnsObj == NULL);
                gpcodeScope->pnsObj = pns;
            }
        }
        else if ((rc == ASLERR_NSOBJ_NOT_FOUND) && (gpnsCurrentOwner != NULL))
        {
            //
            // We are in a method referring to something not yet defined.
            // Let's queue it and check it after we are done.
            //
            rc = QueueNSChk(ptoken, pszName, dwDataType, 0);
        }
        else
        {
            sprintf(szMsg, "%s does not exist or not in accessible scope",
                    pszName);
            PrintTokenErr(ptoken, szMsg, FALSE);
            rc = ASLERR_NONE;
        }
    }

    EXIT((2, "ValidateObject=%d\n", rc));
    return rc;
}       //ValidateObject

/***LP  ValidateNSChkList - Validate objects in NSCHK list
 *
 *  ENTRY
 *      pnschkHead -> NSCHK list
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ValidateNSChkList(PNSCHK pnschkHead)
{
    int rc = ASLERR_NONE;
    PNSOBJ pns;
    ENTER((2, "ValidateNSChkList(Head=%p)\n", pnschkHead));

    while ((rc == ASLERR_NONE) && (pnschkHead != NULL))
    {
        if ((GetNameSpaceObj(pnschkHead->szObjName, pnschkHead->pnsScope, &pns,
                             0) == ASLERR_NONE) &&
            ((pns->hOwner == NULL) ||
             ((PNSOBJ)pns->hOwner == pnschkHead->pnsMethod)))
        {
            if (pns->ObjData.dwDataType == OBJTYPE_RES_FIELD)
            {
                ErrPrintf("%s(%d): error: cannot make forward reference to PNP resource object %s\n",
                          pnschkHead->pszFile, pnschkHead->wLineNum,
                          pnschkHead->szObjName);
                rc = ASLERR_SYNTAX;
            }
            else if ((pnschkHead->dwExpectedType != OBJTYPE_UNKNOWN) &&
                     (pns->ObjData.dwDataType != pnschkHead->dwExpectedType))
            {
                ErrPrintf("%s(%d): warning: %s has incorrect type (ObjType=%s, ExpectedType=%s)\n",
                          pnschkHead->pszFile,
                          pnschkHead->wLineNum,
                          pnschkHead->szObjName,
                          GetObjectTypeName(pns->ObjData.dwDataType),
                          GetObjectTypeName(pnschkHead->dwExpectedType));
            }
            else if (pnschkHead->dwExpectedType == OBJTYPE_METHOD)

            {
                if (pns->ObjData.uipDataValue < pnschkHead->dwChkData)
                {
                    ErrPrintf("%s(%d): error: %s has too many arguments\n",
                              pnschkHead->pszFile,
                              pnschkHead->wLineNum,
                              pnschkHead->szObjName);
                    rc = ASLERR_SYNTAX;
                }
                else if (pns->ObjData.uipDataValue > pnschkHead->dwChkData)
                {
                    ErrPrintf("%s(%d): error: %s has too few arguments\n",
                              pnschkHead->pszFile,
                              pnschkHead->wLineNum,
                              pnschkHead->szObjName);
                    rc = ASLERR_SYNTAX;
                }
            }
        }
        else
        {
            if(strcmp(pnschkHead->szObjName, "\\_OSI") != 0)
            {
                ErrPrintf("%s(%d): warning: %s does not exist or not in accessible scope\n",
                          pnschkHead->pszFile,
                          pnschkHead->wLineNum,
                          pnschkHead->szObjName);
            }
        }

        pnschkHead = pnschkHead->pnschkNext;
    }

    EXIT((2, "ValidateNSChkList=%d\n", rc));
    return rc;
}       //ValidateNSChkList

/***LP  QueueNSChk - Queue a NSChk request
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      pszObjName -> object name
 *      dwExpectedType - expected object type
 *      dwChkData - object specific check data
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL QueueNSChk(PTOKEN ptoken, PSZ pszObjName, ULONG dwExpectedType,
                     ULONG dwChkData)
{
    int rc = ASLERR_NONE;
    PNSCHK pnschk;

    ENTER((2, "QueueNSChk(ptoken=%p,Obj=%s,ExpectedType=%s,ChkData=%x)\n",
           ptoken, pszObjName, GetObjectTypeName(dwExpectedType), dwChkData));

    if ((pnschk = MEMALLOC(sizeof(NSCHK))) == NULL)
    {
        ERROR(("QueueNSChk: failed to allocate NSCHK object"));
        rc = ASLERR_OUT_OF_MEM;
    }
    else
    {
        memset(pnschk, 0, sizeof(NSCHK));
        strcpy(pnschk->szObjName, pszObjName);
        pnschk->pszFile = gpszASLFile;
        pnschk->pnsScope = gpnsCurrentScope;
        pnschk->pnsMethod = gpnsCurrentOwner;
        pnschk->dwExpectedType = dwExpectedType;
        pnschk->dwChkData = dwChkData;
        pnschk->wLineNum = ptoken->pline->wLineNum;
        if (gpnschkTail != NULL)
        {
            gpnschkTail->pnschkNext = pnschk;
            gpnschkTail = pnschk;
        }
        else
        {
            gpnschkHead = gpnschkTail = pnschk;
        }
    }

    EXIT((2, "QueueNSChk=%d\n"));
    return rc;
}       //QueueNSChk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\list.c ===
/*** list.c - Miscellaneous functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/13/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***LP  ListRemoveEntry - Remove an entry from the list
 *
 *  ENTRY
 *      plist -> list object to be removed
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListRemoveEntry(PLIST plist, PPLIST pplistHead)
{
    ASSERT(pplistHead);
    ENTER((4, "ListRemoveEntry(plist=%p,plistHead=%p)\n", plist, *pplistHead));

    ASSERT(plist != NULL);
    if (plist->plistNext == plist)
    {
        //
        // This is the only object in the list, it must be the head too.
        //
        ASSERT(plist == *pplistHead);
        *pplistHead = NULL;
    }
    else
    {
        if (plist == *pplistHead)
        {
            //
            // The entry is at the head, so the next one becomes the new
            // head.
            //
            *pplistHead = (*pplistHead)->plistNext;
        }

        plist->plistNext->plistPrev = plist->plistPrev;
        plist->plistPrev->plistNext = plist->plistNext;
    }

    EXIT((4, "ListRemoveEntry! (plistHead=%p)\n", *pplistHead));
}       //ListRemoveEntry

/***LP  ListRemoveHead - Remove the head entry of the list
 *
 *  ENTRY
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      returns the removed entry
 */

PLIST EXPORT ListRemoveHead(PPLIST pplistHead)
{
    PLIST plist;

    ASSERT(pplistHead);
    ENTER((4, "ListRemoveHead(plistHead=%p)\n", *pplistHead));

    if ((plist = *pplistHead) != NULL)
        ListRemoveEntry(plist, pplistHead);

    EXIT((4, "ListRemoveHead=%p (plistHead=%p)\n", plist, *pplistHead));
    return plist;
}       //ListRemoveHead

/***LP  ListRemoveTail - Remove the tail entry of the list
 *
 *  ENTRY
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      returns the removed entry
 */

PLIST EXPORT ListRemoveTail(PPLIST pplistHead)
{
    PLIST plist;

    ASSERT(pplistHead);
    ENTER((4, "ListRemoveTail(plistHead=%p)\n", *pplistHead));

    if (*pplistHead == NULL)
        plist = NULL;
    else
    {
        //
        // List is not empty, so find the tail.
        //
        plist = (*pplistHead)->plistPrev;
        ListRemoveEntry(plist, pplistHead);
    }

    EXIT((4, "ListRemoveTail=%p (plistHead=%p)\n", plist, *pplistHead));
    return plist;
}       //ListRemoveTail

/***LP  ListInsertHead - Insert an entry at the head of the list
 *
 *  ENTRY
 *      plist -> list object to be inserted
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListInsertHead(PLIST plist, PPLIST pplistHead)
{
    ASSERT(pplistHead != NULL);
    ENTER((4, "ListInsertHead(plist=%p,plistHead=%p)\n", plist, *pplistHead));

    ASSERT(plist != NULL);
    ListInsertTail(plist, pplistHead);
    *pplistHead = plist;

    EXIT((4, "ListInsertHead! (plistHead=%p)\n", *pplistHead));
}       //ListInsertHead

/***LP  ListInsertTail - Insert an entry at the tail of the list
 *
 *  ENTRY
 *      plist -> list object to be inserted
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListInsertTail(PLIST plist, PPLIST pplistHead)
{
    ASSERT(pplistHead != NULL);
    ENTER((4, "ListInsertTail(plist=%p,plistHead=%p)\n", plist, *pplistHead));

    ASSERT(plist != NULL);
    if (*pplistHead == NULL)
    {
        //
        // List is empty, so this becomes the head.
        //
        *pplistHead = plist;
        plist->plistPrev = plist->plistNext = plist;
    }
    else
    {
        plist->plistNext = *pplistHead;
        plist->plistPrev = (*pplistHead)->plistPrev;
        (*pplistHead)->plistPrev->plistNext = plist;
        (*pplistHead)->plistPrev = plist;
    }

    EXIT((4, "ListInsertTail! (plistHead=%p)\n", *pplistHead));
}       //ListInsertTail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\parsearg.h ===
/*** parsearg.h - Exported definitions for parsearg.c
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/05/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _PARSEARG_H
#define _PARSEARG_H

// Error codes
#define ARGERR_NONE             0
#define ARGERR_UNKNOWN_SWITCH   1
#define ARGERR_NO_SEPARATOR     2
#define ARGERR_INVALID_NUM      3
#define ARGERR_INVALID_TAIL     4

#define DEF_SWITCHCHARS         "/-"
#define DEF_SEPARATORS          ":="

typedef struct argtype_s    ARGTYPE;
typedef ARGTYPE *           PARGTYPE;
typedef int (*PFNARG)(char **, PARGTYPE);

// Argument types
#define AT_STRING       1
#define AT_NUM          2
#define AT_ENABLE       3
#define AT_DISABLE      4
#define AT_ACTION       5

//Parse flags
#define PF_NOI          0x0001  //No-Ignore-Case
#define PF_SEPARATOR    0x0002  //parse for separator

struct argtype_s
{
    char        *pszArgID;      //argument ID string
    unsigned    uArgType;       //see argument types defined above
    unsigned    uParseFlags;    //see parse flags defined above
    VOID        *pvArgData;     //ARG_STRING: (char **) - ptr to string ptr
                                //ARG_NUM: (int *) - ptr to integer number
                                //ARG_ENABLE: (unsigned *) - ptr to flags
                                //ARG_DISABLE: (unsigned *) - ptr to flags
                                //ARG_ACTION: ptr to function
    unsigned    uArgParam;      //ARG_STRING: none
                                //ARG_NUM: base
                                //ARG_ENABLE: flag bit mask
                                //ARG_DISABLE: flag bit mask
                                //ARG_ACTION: none
    PFNARG      pfnArgVerify;   //pointer to argument verification function
                                //this will be ignored for ARG_ACTION
};

typedef struct proginfo_s
{
    char *pszSwitchChars;       //if null, DEF_SWITCHCHARS is used
    char *pszSeparators;        //if null, DEF_SEPARATORS is used
    char *pszProgPath;          //ParseProgInfo set this ptr to prog. path
    char *pszProgName;          //ParseProgInfo set this ptr to prog. name
} PROGINFO;
typedef PROGINFO *PPROGINFO;

//Export function prototypes
VOID EXPORT ParseProgInfo(char *, PPROGINFO);
int  EXPORT ParseSwitches(int *, char ***, PARGTYPE, PPROGINFO);

#endif  //ifndef _PARSEARG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\nt.c ===
/*** nt.c - NT specific functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    11/03/97
 *
 *  MODIFICATION HISTORY
 */

#ifdef ___UNASM

#pragma warning (disable: 4201 4214 4514)

typedef unsigned __int64 ULONGLONG;
#define LOCAL   __cdecl
#define EXPORT  __cdecl
#include <stdarg.h>
#ifndef WINNT
#define _X86_
#endif
#include <windef.h>
#include <winbase.h>
#include <winreg.h>
#define EXCL_BASEDEF
#include "aslp.h"

/***LP  IsWinNT - check if OS is NT
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns TRUE - OS is NT
 *  EXIT-FAILURE
 *      returns FALSE - OS is not NT
 */

BOOL LOCAL IsWinNT(VOID)
{
    BOOL rc = FALSE;
    OSVERSIONINFO osinfo;

    ENTER((2, "IsWinNT()\n"));

    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osinfo) && (osinfo.dwPlatformId == VER_PLATFORM_WIN32_NT))
    {
        rc = TRUE;
    }

    EXIT((2, "IsWinNT=%x\n", rc));
    return rc;
}       //IsWinNT

/***LP  EnumSubKey - enumerate subkey
 *
 *  ENTRY
 *      hkey - key to enumerate
 *      dwIndex - subkey index
 *
 *  EXIT-SUCCESS
 *      returns subkey
 *  EXIT-FAILURE
 *      returns NULL
 */

HKEY LOCAL EnumSubKey(HKEY hkey, DWORD dwIndex)
{
    HKEY hkeySub = NULL;
    char szSubKey[32];
    DWORD dwSubKeySize = sizeof(szSubKey);

    ENTER((2, "EnumSubKey(hkey=%x,Index=%d)\n", hkey, dwIndex));

    if ((RegEnumKeyEx(hkey, dwIndex, szSubKey, &dwSubKeySize, NULL, NULL, NULL,
                      NULL) == ERROR_SUCCESS) &&
        (RegOpenKeyEx(hkey, szSubKey, 0, KEY_READ, &hkeySub) != ERROR_SUCCESS))
    {
        hkeySub = NULL;
    }

    EXIT((2, "EnumSubKey=%x\n", hkeySub));
    return hkeySub;
}       //EnumSubKey

/***LP  OpenNTTable - Open ACPI table in NT registry
 *
 *  ENTRY
 *      pszTabSig -> table signature string
 *
 *  EXIT-SUCCESS
 *      returns table registry handle
 *  EXIT-FAILURE
 *      returns NULL
 */

HKEY LOCAL OpenNTTable(PSZ pszTabSig)
{
    HKEY hkeyTab = NULL, hkey1 = NULL, hkey2 = NULL;
    static char szTabKey[] = "Hardware\\ACPI\\xxxx";

    ENTER((2, "OpenNTTable(TabSig=%s)\n", pszTabSig));

    lstrcpyn(&szTabKey[lstrlen(szTabKey) - 4], pszTabSig, 5);
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTabKey, 0, KEY_READ, &hkey1) ==
        ERROR_SUCCESS)
    {
        //
        // hkey1 is now "Hardware\ACPI\<TabSig>"
        //
        if ((hkey2 = EnumSubKey(hkey1, 0)) != NULL)
        {
            //
            // hkey2 is now "Hardware\ACPI\<TabSig>\<OEMID>"
            //
            RegCloseKey(hkey1);
            if ((hkey1 = EnumSubKey(hkey2, 0)) != NULL)
            {
                //
                // hkey1 is now "Hardware\ACPI\<TabSig>\<OEMID>\<OEMTabID>"
                //
                RegCloseKey(hkey2);
                if ((hkey2 = EnumSubKey(hkey1, 0)) != NULL)
                {
                    //
                    // hkey2 is now
                    // "Hardware\ACPI\<TabSig>\<OEMID>\<OEMTabID>\<OEMRev>"
                    //
                    hkeyTab = hkey2;
                }
            }
        }
    }

    if (hkey1 != NULL)
    {
        RegCloseKey(hkey1);
    }

    if ((hkey2 != NULL) && (hkeyTab != hkey2))
    {
        RegCloseKey(hkey2);
    }

    EXIT((2, "OpenNTTable=%x\n", hkeyTab));
    return hkeyTab;
}       //OpenNTTable

/***LP  GetNTTable - Get ACPI table from NT registry
 *
 *  ENTRY
 *      pszTabSig -> table signature string
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL GetNTTable(PSZ pszTabSig)
{
    PBYTE pb = NULL;
    HKEY hkeyTab;

    ENTER((2, "GetNTTable(TabSig=%s)\n", pszTabSig));

    if ((hkeyTab = OpenNTTable(pszTabSig)) != NULL)
    {
        DWORD dwLen = 0;
        PSZ pszTabKey = "00000000";

        if (RegQueryValueEx(hkeyTab, pszTabKey, NULL, NULL, NULL, &dwLen) ==
            ERROR_SUCCESS)
        {
            if ((pb = MEMALLOC(dwLen)) != NULL)
            {
                if (RegQueryValueEx(hkeyTab, pszTabKey, NULL, NULL, pb, &dwLen)
                    != ERROR_SUCCESS)
                {
                    ERROR(("GetNTTable: failed to read table"));
                }
            }
            else
            {
                ERROR(("GetNTTable: failed to allocate table buffer"));
            }
        }
        else
        {
            ERROR(("GetNTTable: failed to read table key"));
        }
        RegCloseKey(hkeyTab);
    }
    else
    {
        ERROR(("GetNTTable: failed to get table %s", pszTabSig));
    }

    EXIT((2, "GetNTTable=%x\n", pb));
    return pb;
}       //GetNTTable

#endif  //ifdef __UNASM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\parsearg.c ===
/*** parsearg.c - Library functions for parsing command line arguments
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/05/96
 *
 *  This module provides general purpose services to parse
 *  command line arguments.
 *
 *  MODIFICATION HISTORY
 */

#include "basedef.h"
#include "parsearg.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*** Local function prototypes
 */

int LOCAL ParseArgSwitch(char **, PARGTYPE, PPROGINFO);
VOID LOCAL PrintError(int, char *, PPROGINFO);

/***EP  ParseProgInfo - parse program path and module name
 *
 *  ENTRY
 *      pszArg0 -> argument 0
 *      pPI -> program info structure
 *
 *  EXIT
 *      None
 */

VOID EXPORT ParseProgInfo(char *pszArg0, PPROGINFO pPI)
{
    char *pch;

    pPI->pszProgPath = _strlwr(pszArg0);
    if ((pch = strrchr(pszArg0, '\\')) != NULL)
    {
        *pch = '\0';
        pPI->pszProgName = pch + 1;
    }
    else
    {
	pPI->pszProgName = pszArg0;
    }

    if ((pch = strchr(pPI->pszProgName, '.')) != NULL)
        *pch = '\0';
}       //ParseProgInfo

/***EP  ParseSwitches - parse command switches
 *
 *  ENTRY
 *      pcArg -> argument count
 *      pppszArg -> pointer to array of pointers to argument strings
 *      pAT -> argument type array
 *      pPI -> program info. structure
 *
 *  EXIT-SUCCESS
 *      returns ARGERR_NONE
 *  EXIT-FAILURE
 *      returns error code, *pppszArg -> error argument
 */

int EXPORT ParseSwitches(int *pcArg, char ***pppszArg, PARGTYPE pAT, PPROGINFO pPI)
{
    int  rc = ARGERR_NONE;
    char *pszArg;

    if (pPI->pszSwitchChars == NULL)
        pPI->pszSwitchChars = DEF_SWITCHCHARS;

    if (pPI->pszSeparators == NULL)
        pPI->pszSeparators = DEF_SEPARATORS;

    for (; *pcArg; (*pcArg)--, (*pppszArg)++)
    {
        pszArg = **pppszArg;
        if (strchr(pPI->pszSwitchChars, *pszArg))
        {
            pszArg++;
            if ((rc = ParseArgSwitch(&pszArg, pAT, pPI)) != ARGERR_NONE)
            {
                PrintError(rc, pszArg, pPI);
                break;
            }
        }
        else
            break;
    }

    return rc;
}       //ParseSwitches


/***LP  ParseArgSwitch - parse a command line switch
 *
 *  ENTRY
 *      ppszArg -> pointer to argument
 *      pAT -> argument type table
 *      pPI -> program info. structure
 *
 *  EXIT
 *      return argument parsed status - ARGERR_NONE
 *                                    - ARGERR_UNKNOWN_SWITCH
 *                                    - ARGERR_INVALID_NUM
 *                                    - ARGERR_NO_SEPARATOR
 *                                    - ARGERR_INVALID_TAIL
 */

int LOCAL ParseArgSwitch(char **ppszArg, PARGTYPE pAT, PPROGINFO pPI)
{
    int rc = ARGERR_NONE;
    char *pEnd;
    PARGTYPE pAT1;
    int fFound = FALSE;
    int lenMatch = 0;

    pAT1 = pAT;
    while (pAT1->pszArgID[0])
    {
        lenMatch = strlen(pAT1->pszArgID);
        if (pAT1->uParseFlags & PF_NOI)
            fFound = (strncmp(pAT1->pszArgID, *ppszArg, lenMatch) == 0);
        else
            fFound = (_strnicmp(pAT1->pszArgID, *ppszArg, lenMatch) == 0);

        if (fFound)
            break;
        else
            pAT1++;
    }

    if (fFound)
    {
        *ppszArg += lenMatch;
        switch (pAT1->uArgType)
        {
            case AT_STRING:
            case AT_NUM:
                if (pAT1->uParseFlags & PF_SEPARATOR)
                {
                    if (**ppszArg && strchr(pPI->pszSeparators, **ppszArg))
                        (*ppszArg)++;
                    else
                    {
                        rc = ARGERR_NO_SEPARATOR;
                        break;
                    }
                }

                if (pAT1->uArgType == AT_STRING)
                    *(char **)pAT1->pvArgData = *ppszArg;
                else
                {
                    *(int *)pAT1->pvArgData = (int)
                        strtol(*ppszArg, &pEnd, pAT1->uArgParam);
                    if (*ppszArg == pEnd)
                    {
                        rc = ARGERR_INVALID_NUM;
                        break;
                    }
                    else
                        *ppszArg = pEnd;
                }
                if (pAT1->pfnArgVerify)
                    rc = (*pAT1->pfnArgVerify)(ppszArg, pAT1);
                break;

            case AT_ENABLE:
            case AT_DISABLE:
                if (pAT1->uArgType == AT_ENABLE)
                    *(unsigned *)pAT1->pvArgData |= pAT1->uArgParam;
                else
                    *(unsigned *)pAT1->pvArgData &= ~pAT1->uArgParam;

                if ((pAT1->pfnArgVerify) &&
                    ((rc = (*pAT1->pfnArgVerify)(ppszArg, pAT1)) !=
                     ARGERR_NONE))
                {
                    break;
                }

                if (**ppszArg)
                {
                    if (strchr(pPI->pszSwitchChars, **ppszArg))
                        (*ppszArg)++;
                    rc = ParseArgSwitch(ppszArg, pAT, pPI);
                }
                break;

            case AT_ACTION:
#pragma warning(disable: 4055)
                rc = (*(PFNARG)pAT1->pvArgData)(ppszArg, pAT1);
#pragma warning(default: 4055)
                break;
        }
    }
    else
        rc = ARGERR_UNKNOWN_SWITCH;

    return rc;
}       //ParseArgSwitch


/***LP  PrintError - print appropriate error message according to error code
 *
 *  ENTRY
 *      iErr = error code
 *      pszArg -> argument in error
 *      pPI -> program info. structure
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintError(int iErr, char *pszArg, PPROGINFO pPI)
{
    switch (iErr)
    {
        case ARGERR_UNKNOWN_SWITCH:
            printf("%s: unknown switch \"%s\"\n", pPI->pszProgName, pszArg);
            break;

        case ARGERR_NO_SEPARATOR:
            printf("%s: separator missing after the switch char '%c'\n",
                   pPI->pszProgName, *(pszArg-1));
            break;

        case ARGERR_INVALID_NUM:
            printf("%s: invalid numeric switch \"%s\"\n",
                   pPI->pszProgName, pszArg);
            break;

        case ARGERR_INVALID_TAIL:
            printf("%s: invalid argument tail \"%s\"\n",
                   pPI->pszProgName, pszArg);
    }
}       //PrintError
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\misc.c ===
/*** misc.c - Miscellaneous functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/14/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***LP  ValidASLNameSeg - Check if the token is an ASL NameSeg
 *
 *  ENTRY
 *      ptoken - token stream
 *      pszToken -> token string
 *      icbLen - length of the token to be considered a NameSeg
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL LOCAL ValidASLNameSeg(PTOKEN ptoken, PSZ pszToken, int icbLen)
{
    BOOL rc = TRUE;
    int i, j;
    static PSZ apszReservedNames[] = {
        "AC0", "AC1", "AC2", "AC3", "AC4", "AC5", "AC6", "AC7", "AC8", "AC9",
        "AL0", "AL1", "AL2", "AL3", "AL4", "AL5", "AL6", "AL7", "AL8", "AL9",
        "ADR", "ALN", "BAS", "BBN", "BCL", "BCM", "BDN", "BIF", "BM_", "BST",
        "BTP", "CID", "CRS", "CRT", "CST", "DCK", "DCS", "DDC", "DDN", "DEC", 
        "DGS", "DIS", "DMA", "DOD", "DOS", "DSS", "EC_", "EJD", "EC0", "EC1", 
        "EC2", "EC3", "EC4", "EC5", "EC6", "EC7", "EC7", "EC9", "EJ0", "EJ1",
        "EJ2", "EJ3", "EJ4", "Exx", "FDE", "FDI", "GL_", "GLK", "GPE", "GRA",
        "GTF", "GTM", "HE_", "HID", "INI", "INT", "IRC", "LCK", "LEN", "LID",
        "LL_", "Lxx", "MAF", "MAX", "MEM", "MIF", "MIN", "MSG", "OFF", "ON_",
        "OS_", "OSI", "PCL", "PIC", "PCT", "PPC", "PR_", "PR0", "PR1", "PR2",
        "PRS", "PRT", "PRW", "PS0", "PS1", "PS2", "PS3", "PSC", "PSL", "PSR",
        "PSS", "PSV", "PSW", "PTC", "PTS", "PWR", "Qxx", "REG", "REV", "RMV",
        "RNG", "ROM", "RQ_", "RW_", "S0_", "S0D", "S1_", "S1D", "S2_", "S2D",
        "S3_", "S3D", "S4_", "S4D", "S5_", "S5D", "SB_", "SBS", "SCP", "SHR",
        "SI_", "SIZ", "SRS", "SST", "STA", "STM", "SUN", "TC1", "TC2", "TMP",
        "TRA", "TSP", "TYP", "TZ_", "UID", "WAK",             
    };
    
    #define NUM_RESERVED_NAMES  (sizeof(apszReservedNames)/sizeof(PSZ))

    ENTER((1, "ValidASLNameSeg(ptoken=%p, Token=%s,Len=%d)\n",
           ptoken, pszToken, icbLen));

    pszToken[0] = (char)toupper(pszToken[0]);
    if ((icbLen > sizeof(NAMESEG)) || !ISLEADNAMECHAR(pszToken[0]))
    {
        rc = FALSE;
    }
    else
    {
        for (i = 1; i < icbLen; ++i)
        {
            pszToken[i] = (char)toupper(pszToken[i]);
            if (!ISNAMECHAR(pszToken[i]))
            {
                rc = FALSE;
                break;
            }
        }

        if ((rc == TRUE) && (*pszToken == '_'))
        {
            char szName[sizeof(NAMESEG)] = "___";

            memcpy(szName, &pszToken[1], icbLen - 1);
            for (i = 0; i < NUM_RESERVED_NAMES; ++i)
            {
                if (strcmp(szName, apszReservedNames[i]) == 0)
                    break;
                else
                {
                    for (j = 0; j < sizeof(NAMESEG) - 1; ++j)
                    {
                        if (apszReservedNames[i][j] != szName[j])
                        {
                            if ((apszReservedNames[i][j] != 'x') ||
                                !isxdigit(szName[j]))
                            {
                                break;
                            }
                        }
                    }

                    if (j == sizeof(NAMESEG) - 1)
                    {
                        break;
                    }
                }
            }

            if (i == NUM_RESERVED_NAMES)
            {
                PrintTokenErr(ptoken, "not a valid reserved NameSeg", FALSE);
            }
        }
    }

    EXIT((1, "ValidASLNameSeg=%d\n", rc));
    return rc;
}       //ValidASLNameSeg

/***LP  ValidASLName - Check if the token is an ASL name
 *
 *  ENTRY
 *      ptoken - token stream
 *      pszToken -> token string
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL LOCAL ValidASLName(PTOKEN ptoken, PSZ pszToken)
{
    BOOL rc = TRUE;
    PSZ psz1, psz2 = NULL;
    int icbLen;

    ENTER((1, "ValidASLName(ptoken=%p,Token=%s)\n", ptoken, pszToken));

    if (*pszToken == CH_ROOT_PREFIX)
    {
        pszToken++;
    }
    else
    {
        while (*pszToken == CH_PARENT_PREFIX)
        {
            pszToken++;
        }
    }

    for (psz1 = pszToken;
         (rc == TRUE) && (psz1 != NULL) && (*psz1 != '\0');
         psz1 = psz2)
    {
        psz2 = strchr(psz1, CH_NAMESEG_SEP);
        icbLen = (psz2 != NULL)? (int)(psz2 - psz1): strlen(psz1);
        if (((rc = ValidASLNameSeg(ptoken, psz1, icbLen)) == TRUE) &&
            (psz2 != NULL))
        {
            psz2++;
        }
    }

    EXIT((1, "ValidASLName=%d\n", rc));
    return rc;
}       //ValidASLName

/***LP  EncodeName - Encode name string
 *
 *  ENTRY
 *      pszName -> name string
 *      pbBuff -> buffer to hold name encoding
 *      pdwLen -> initially contains buffer size, but will be updated to show
 *                actual encoding length
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL EncodeName(PSZ pszName, PBYTE pbBuff, PDWORD pdwLen)
{
    int rc = ASLERR_NONE;
    PBYTE pb = pbBuff;
    PSZ psz;
    int icNameSegs, i;

    ENTER((1, "EncodeName(Name=%s,pbBuff=%p,Len=%d)\n",
           pszName, pbBuff, *pdwLen));

    if (*pszName == CH_ROOT_PREFIX)
    {
        if (*pdwLen >= 1)
        {
            *pb = OP_ROOT_PREFIX;
            pb++;
            (*pdwLen)--;
            pszName++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }
    else
    {
        while (*pszName == CH_PARENT_PREFIX)
        {
            if (*pdwLen >= 1)
            {
                *pb = OP_PARENT_PREFIX;
                pb++;
                (*pdwLen)--;
                pszName++;
            }
            else
            {
                rc = ASLERR_NAME_TOO_LONG;
                break;
            }
        }
    }

    for (psz = pszName, icNameSegs = 0; (psz != NULL) && (*psz != '\0');)
    {
        icNameSegs++;
        if ((psz = strchr(psz, CH_NAMESEG_SEP)) != NULL)
            psz++;
    }

    if (icNameSegs > 255)
        rc = ASLERR_NAME_TOO_LONG;
    else if (icNameSegs > 2)
    {
        if (*pdwLen >= sizeof(NAMESEG)*icNameSegs + 2)
        {
            *pb = OP_MULTI_NAME_PREFIX;
            pb++;
            *pb = (BYTE)icNameSegs;
            pb++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }
    else if (icNameSegs == 2)
    {
        if (*pdwLen >= sizeof(NAMESEG)*2 + 1)
        {
            *pb = OP_DUAL_NAME_PREFIX;
            pb++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }

    if (rc == ASLERR_NONE)
    {
        //
        // If we have only name prefix characters, we must put a null name
        // separator to tell the boundary from the next opcode which may happen
        // to be a NameSeg.
        //
        if (icNameSegs == 0)
        {
            *pb = 0;
            pb++;
        }
        else
        {
            while (icNameSegs > 0)
            {
                *((PDWORD)pb) = NAMESEG_BLANK;
                for (i = 0;
                     (i < sizeof(NAMESEG)) && ISNAMECHAR(*pszName);
                     ++i, pszName++)
                {
                    pb[i] = *pszName;
                }

                if (*pszName == CH_NAMESEG_SEP)
                    pszName++;

                pb += 4;
                icNameSegs--;
            }
        }

        *pdwLen = (DWORD)(pb - pbBuff);
    }

    EXIT((1, "EncodeName=%d (Len=%d)\n", rc, *pdwLen));
    return rc;
}       //EncodeName

/***LP  EncodePktLen - Encode packet length
 *
 *  ENTRY
 *      dwCodeLen - actual code length
 *      pdwPktLen -> to hold the encoded packet length
 *      picbEncoding -> to hold the number of encoding bytes
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL EncodePktLen(DWORD dwCodeLen, PDWORD pdwPktLen, PINT picbEncoding)
{
    int rc = ASLERR_NONE;

    ENTER((1, "EncodePktLen(CodeLen=%ld,pdwPktLen=%p)\n",
           dwCodeLen, pdwPktLen));

    if (dwCodeLen <= 0x3f)
    {
        *pdwPktLen = dwCodeLen;
        *picbEncoding = 1;
    }
    else
    {
        *pdwPktLen = (dwCodeLen & 0x0ffffff0) << 4;
        *pdwPktLen |= (dwCodeLen & 0xf);

        if (dwCodeLen <= 0x0fff)
            *picbEncoding = 2;
        else if (dwCodeLen <= 0x0fffff)
            *picbEncoding = 3;
        else if (dwCodeLen <= 0x0fffffff)
            *picbEncoding = 4;
        else
            rc = ASLERR_PKTLEN_TOO_LONG;

        if (rc == ASLERR_NONE)
            *pdwPktLen |= (*picbEncoding - 1) << 6;
    }

    EXIT((1, "EncodePktLen=%d (Encoding=%lx,icbEncoding=%d)\n",
          rc, *pdwPktLen, *picbEncoding));
    return rc;
}       //EncodePktLen

/***LP  EncodeKeywords - Encode keyword arguments
 *
 *  ENTRY
 *      pArgs -> argument array
 *      dwSrcArgs - source argument bit vector
 *      iDstArgNum - destination argument number
 *
 *  EXIT
 *      None
 */

VOID LOCAL EncodeKeywords(PCODEOBJ pArgs, DWORD dwSrcArgs, int iDstArgNum)
{
    int i;
    DWORD dwData = 0;

    ENTER((1, "EncodeKeywords(pArgs=%p,SrcArgs=%lx,DstArgNum=%d)\n",
           pArgs, dwSrcArgs, iDstArgNum));

    for (i = 0; i < MAX_ARGS; ++i)
    {
        if (dwSrcArgs & (1 << i))
        {
            if (pArgs[i].dwCodeType == CODETYPE_KEYWORD)
            {
                dwData |= TermTable[pArgs[i].dwTermIndex].dwTermData & 0xff;
            }
            else if (pArgs[i].dwCodeType == CODETYPE_INTEGER)
            {
                pArgs[i].dwCodeType = CODETYPE_UNKNOWN;
                dwData |= pArgs[i].dwCodeValue;
            }
            else
            {
                ASSERT(pArgs[i].dwCodeType == CODETYPE_INTEGER);
            }
        }
    }

    SetIntObject(&pArgs[iDstArgNum], dwData, sizeof(BYTE));

    EXIT((1, "EncodeKeywords!\n"));
}       //EncodeKeywords

/***LP  DecodeName - Decode name encoding back to a name string
 *
 *  ENTRY
 *      pb -> name encoding buffer
 *      pszName -> to hold the decoded name string
 *      iLen - length of name string buffer
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DecodeName(PBYTE pb, PSZ pszName, int iLen)
{
    int rc = ASLERR_NONE;
    int i = 0, icNameSegs;

    ENTER((1, "DecodeName(pb=%p,pszName=%p,iLen=%d)\n", pb, pszName, iLen));

    iLen--;     //reserve one space for NULL character
    pszName[iLen] = '\0';
    if (*pb == OP_ROOT_PREFIX)
    {
        if (i < iLen)
        {
            pszName[i] = CH_ROOT_PREFIX;
            i++;
            pb++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }

    while (*pb == OP_PARENT_PREFIX)
    {
        if (i < iLen)
        {
            pszName[i] = CH_PARENT_PREFIX;
            i++;
            pb++;
        }
        else
            rc = ASLERR_NAME_TOO_LONG;
    }

    if (*pb == OP_DUAL_NAME_PREFIX)
    {
        icNameSegs = 2;
        pb++;
    }
    else if (*pb == OP_MULTI_NAME_PREFIX)
    {
        pb++;
        icNameSegs = (int)(*pb);
        pb++;
    }
    else if (*pb == 0)
    {
        icNameSegs = 0;
    }
    else
    {
        icNameSegs = 1;
    }

    if (icNameSegs > 0)
    {
        do
        {
            if ((int)(i + sizeof(NAMESEG)) <= iLen)
            {
                strncpy(&pszName[i], (PCHAR)pb, sizeof(NAMESEG));
                pb += sizeof(NAMESEG);
                i += sizeof(NAMESEG);
                icNameSegs--;

                if (icNameSegs > 0)
                {
                    if (i < iLen)
                    {
                        pszName[i] = CH_NAMESEG_SEP;
                        i++;
                    }
                    else
                        rc = ASLERR_NAME_TOO_LONG;
                }
            }
            else
                rc = ASLERR_NAME_TOO_LONG;

        } while ((rc == ASLERR_NONE) && (icNameSegs > 0));
    }

    if (rc == ASLERR_NONE)
        pszName[i] = '\0';
    else
    {
        ERROR(("DecodeName: Name is too long - %s", pszName));
    }

    EXIT((1, "DecodeName=%d (Name=%s)\n", rc, pszName));
    return rc;
}       //DecodeName

/***LP  SetDefMissingKW - Set default missing keyword
 *
 *  ENTRY
 *      pArg -> argument code object
 *      dwDefID - default ID to be used if argument is missing
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL SetDefMissingKW(PCODEOBJ pArg, DWORD dwDefID)
{
    int rc = ASLERR_NONE;

    ENTER((2, "SetDefMissingKW(pArg=%p,ID=%d)\n", pArg, dwDefID));

    if (pArg->dwfCode & CF_MISSING_ARG)
    {
        pArg->dwfCode &= ~CF_MISSING_ARG;
        pArg->dwCodeType = CODETYPE_KEYWORD;
        pArg->dwCodeValue = dwDefID;
        rc = LookupIDIndex(pArg->dwCodeValue, &pArg->dwTermIndex);
    }

    EXIT((2, "SetDefMissingKW=%d (TermIndex=%ld)\n", rc, pArg->dwTermIndex));
    return rc;
}       //SetDefMissingKW

/***LP  SetIntObject - Set an object to type integer
 *
 *  ENTRY
 *      pc -> object
 *      dwData - integer data
 *      dwLen - data length
 *
 *  EXIT
 *      None
 */

VOID LOCAL SetIntObject(PCODEOBJ pc, DWORD dwData, DWORD dwLen)
{
    ENTER((2, "SetIntObject(pc=%p,Data=%x,Len=%d)\n", pc, dwData, dwLen));

    pc->dwCodeType = CODETYPE_INTEGER;
    pc->dwCodeValue = dwData;
    pc->dwDataLen = pc->dwCodeLen = dwLen;
    pc->bCodeChkSum = ComputeDataChkSum((PBYTE)&dwData, dwLen);

    EXIT((2, "SetIntObject!\n"));
}       //SetIntObject

/***LP  ComputeChildChkSumLen - Compute len and chksum of child for parent
 *
 *  ENTRY
 *      pcParent -> code block of parent
 *      pcChild -> code block of child
 *
 *  EXIT
 *      None
 */

VOID LOCAL ComputeChildChkSumLen(PCODEOBJ pcParent, PCODEOBJ pcChild)
{
    ENTER((1, "ComputeChildChkSumLen(pcParent=%p,pcChild=%p,ChildLen=%ld,ChildChkSum=%x)\n",
           pcParent, pcChild, pcChild->dwCodeLen, pcChild->bCodeChkSum));

    pcParent->dwCodeLen += pcChild->dwCodeLen;
    pcParent->bCodeChkSum = (BYTE)(pcParent->bCodeChkSum +
                                   pcChild->bCodeChkSum);

    if (pcChild->dwCodeType == CODETYPE_ASLTERM)
    {
        int i;

        for (i = 0; i < OPCODELEN(pcChild->dwCodeValue); ++i)
        {
            pcParent->bCodeChkSum = (BYTE)(pcParent->bCodeChkSum +
                                           ((PBYTE)(&pcChild->dwCodeValue))[i]);
            pcParent->dwCodeLen++;
        }
    }

    EXIT((1, "ComputeChildChkSumLen! (Len=%ld,ChkSum=%x)\n",
          pcParent->dwCodeLen, pcParent->bCodeChkSum));
}       //ComputeChildChkSumLen

/***LP  ComputeArgsChkSumLen - Compute length and checksum of arguments
 *
 *  ENTRY
 *      pcode -> code block
 *
 *  EXIT
 *      None
 */

VOID LOCAL ComputeArgsChkSumLen(PCODEOBJ pcode)
{
    PCODEOBJ pc;
    int i;

    ENTER((1, "ComputeArgsChkSumLen(pcode=%p)\n", pcode));

    ASSERT((pcode->dwCodeType == CODETYPE_ASLTERM) ||
           (pcode->dwCodeType == CODETYPE_USERTERM));
    //
    // Sum the length of arguments
    //
    for (i = 0, pc = (PCODEOBJ)pcode->pbDataBuff;
         i < (int)pcode->dwDataLen;
         ++i)
    {
        ComputeChildChkSumLen(pcode, &pc[i]);
    }

    EXIT((1, "ComputeArgsChkSumLen! (Len=%ld,ChkSum=%x)\n",
          pcode->dwCodeLen, pcode->bCodeChkSum));
}       //ComputeArgsChkSumLen

/***LP  ComputeChkSumLen - Compute length and checksum of code block
 *
 *  Compute the length of the given code block and store it in the dwCodeLen
 *  field of the code block.
 *  Compute the checksum of the given code block and store it in the
 *  bCodeChkSum field of the code block.
 *
 *  ENTRY
 *      pcode -> code block
 *
 *  EXIT
 *      None
 *
 *  NOTE
 *      This function does not count the opcode length of the given ASLTERM.
 *      The caller is responsible for adding it if necessary.
 */

VOID LOCAL ComputeChkSumLen(PCODEOBJ pcode)
{
    PCODEOBJ pc;
    int i, j;

    ENTER((1, "ComputeChkSumLen(pcode=%p)\n", pcode));

    ASSERT(pcode->dwCodeType == CODETYPE_ASLTERM);

    if (!(TermTable[pcode->dwTermIndex].dwfTermClass & TC_COMPILER_DIRECTIVE))
    {
        ComputeArgsChkSumLen(pcode);
    }
    //
    // Sum the lengths of children
    //
    for (pc = pcode->pcFirstChild; pc != NULL;)
    {
        ComputeChildChkSumLen(pcode, pc);

        if ((PCODEOBJ)pc->list.plistNext == pcode->pcFirstChild)
            pc = NULL;
        else
            pc = (PCODEOBJ)pc->list.plistNext;
    }
    //
    // If this term requires a PkgLength encoding, we must include it in the
    // length.
    //
    if (TermTable[pcode->dwTermIndex].dwfTerm & TF_PACKAGE_LEN)
    {
        DWORD dwPktLen;

        if (pcode->dwCodeLen <= 0x3f - 1)
            pcode->dwCodeLen++;
        else if (pcode->dwCodeLen <= 0xfff - 2)
            pcode->dwCodeLen += 2;
        else if (pcode->dwCodeLen <= 0xfffff - 3)
            pcode->dwCodeLen += 3;
        else
            pcode->dwCodeLen += 4;

        if (EncodePktLen(pcode->dwCodeLen, &dwPktLen, &j) == ASLERR_NONE)
        {
            for (i = 0; i < j; ++i)
            {
                pcode->bCodeChkSum = (BYTE)(pcode->bCodeChkSum +
                                            ((PBYTE)&dwPktLen)[i]);
            }
        }
    }

    EXIT((1, "ComputeChkSumLen! (len=%ld,ChkSum=%x)\n",
	  pcode->dwCodeLen, pcode->bCodeChkSum));
}       //ComputeChkSumLen

/***LP  ComputeEISAID - Compute EISA ID from the ID string
 *
 *  ENTRY
 *      pszID -> ID string
 *      pdwEISAID -> to hold the EISA ID
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ComputeEISAID(PSZ pszID, PDWORD pdwEISAID)
{
    int rc = ASLERR_NONE;

    ENTER((1, "ComputeEISAID(pszID=%s,pdwEISAID=%p)\n", pszID, pdwEISAID));

    if (*pszID == '*')
        pszID++;

    if (strlen(pszID) != 7)
        rc = ASLERR_INVALID_EISAID;
    else
    {
        int i;

        *pdwEISAID = 0;
        for (i = 0; i < 3; ++i)
        {
            if ((pszID[i] < '@') || (pszID[i] > '_'))
            {
                rc = ASLERR_INVALID_EISAID;
                break;
            }
            else
            {
                (*pdwEISAID) <<= 5;
                (*pdwEISAID) |= pszID[i] - '@';
            }
        }

        if (rc == ASLERR_NONE)
        {
            PSZ psz;
            WORD wData;

            (*pdwEISAID) = ((*pdwEISAID & 0x00ff) << 8) |
                           ((*pdwEISAID & 0xff00) >> 8);
            wData = (WORD)strtoul(&pszID[3], &psz, 16);

            if (*psz != '\0')
            {
                rc = ASLERR_INVALID_EISAID;
            }
            else
            {
                wData = (WORD)(((wData & 0x00ff) << 8) |
                               ((wData & 0xff00) >> 8));
                (*pdwEISAID) |= (DWORD)wData << 16;
            }
        }
    }

    EXIT((1, "ComputeEISAID=%d (EISAID=%lx)\n", rc, *pdwEISAID));
    return rc;
}       //ComputeEISAID

/***LP  LookupIDIndex - lookup the given ID in the TermTable and return index
 *
 *  ENTRY
 *      lID - ID to look up
 *      pdwTermIndex -> to hold term index found
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL LookupIDIndex(LONG lID, PDWORD pdwTermIndex)
{
    int rc = ASLERR_NONE;
    int i;

    ENTER((1, "LookupIDIndex(ID=%ld,pdwTermIndex=%p)\n", lID, pdwTermIndex));

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if (lID == TermTable[i].lID)
        {
            *pdwTermIndex = (DWORD)i;
            break;
        }
    }

    if (TermTable[i].pszID == NULL)
    {
        ERROR(("LookupIDIndex: failed to find ID %ld in TermTable", lID));
        rc = ASLERR_INTERNAL_ERROR;
    }

    EXIT((1, "LookupIDIndex=%d (Index=%d)\n", rc, *pdwTermIndex));
    return rc;
}       //LookupIDIndex

/***LP  WriteAMLFile - Write code block to AML file
 *
 *  ENTRY
 *      fhAML - AML image file handle
 *      pcode -> code block
 *      pdwOffset -> file offset
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL WriteAMLFile(int fhAML, PCODEOBJ pcode, PDWORD pdwOffset)
{
    int rc = ASLERR_NONE;
    int iLen;
    DWORD dwPktLen, dwLen;

    ENTER((1, "WriteAMLFile(fhAML=%x,pcode=%p,FileOffset=%x)\n",
           fhAML, pcode, *pdwOffset));

    if (pcode->dwfCode & CF_CREATED_NSOBJ)
    {
        ASSERT(pcode->pnsObj != NULL);
        ASSERT(pcode->pnsObj->dwRefCount == 0);
        pcode->pnsObj->dwRefCount = *pdwOffset;
    }

    switch (pcode->dwCodeType)
    {
        case CODETYPE_ASLTERM:
            if (pcode->dwCodeValue != OP_NONE)
            {
                iLen = OPCODELEN(pcode->dwCodeValue);
                *pdwOffset += iLen;

                if (_write(fhAML, &pcode->dwCodeValue, iLen) != iLen)
                    rc = ASLERR_WRITE_FILE;
                else if (TermTable[pcode->dwTermIndex].dwfTerm & TF_PACKAGE_LEN)
                {
                    if ((rc = EncodePktLen(pcode->dwCodeLen, &dwPktLen, &iLen))
                        == ASLERR_NONE)
                    {
                        *pdwOffset += iLen;
                        if (_write(fhAML, &dwPktLen, iLen) != iLen)
                        {
                            rc = ASLERR_WRITE_FILE;
                        }
                    }
                }

                if (rc == ASLERR_NONE)
                {
                    if (pcode->pbDataBuff != NULL)
                    {
                        PCODEOBJ pc;
                        int i;

                        for (i = 0, pc = (PCODEOBJ)pcode->pbDataBuff;
                             i < (int)pcode->dwDataLen;
                             ++i)
                        {
                            if ((rc = WriteAMLFile(fhAML, &pc[i], pdwOffset))
                                != ASLERR_NONE)
                            {
                                break;
                            }
                        }
                    }
                }
            }

            if (rc == ASLERR_NONE)
            {
                PCODEOBJ pc;

                for (pc = pcode->pcFirstChild; pc != NULL;)
                {
                    if ((rc = WriteAMLFile(fhAML, pc, pdwOffset)) !=
                        ASLERR_NONE)
                    {
                        break;
                    }

                    if ((PCODEOBJ)pc->list.plistNext ==
                        pcode->pcFirstChild)
                    {
                        pc = NULL;
                    }
                    else
                        pc = (PCODEOBJ)pc->list.plistNext;
                }
            }
            break;

        case CODETYPE_USERTERM:
            if (pcode->pbDataBuff != NULL)
            {
                PCODEOBJ pc;
                int i;

                for (i = 0, pc = (PCODEOBJ)pcode->pbDataBuff;
                     i < (int)pcode->dwDataLen;
                     ++i)
                {
                    if ((rc = WriteAMLFile(fhAML, &pc[i], pdwOffset)) !=
                        ASLERR_NONE)
                    {
                        break;
                    }
                }
            }
            break;

        case CODETYPE_FIELDOBJ:
            dwPktLen = pcode->dwCodeValue? sizeof(NAMESEG): sizeof(BYTE);
            dwLen = ((pcode->dwDataLen & 0xc0) >> 6) + 1;
            *pdwOffset += dwPktLen + dwLen;
            if ((_write(fhAML, &pcode->dwCodeValue, dwPktLen) !=
                 (int)dwPktLen) ||
                (_write(fhAML, &pcode->dwDataLen, dwLen) != (int)dwLen))
            {
                rc = ASLERR_WRITE_FILE;
            }
            break;

        case CODETYPE_NAME:
        case CODETYPE_DATAOBJ:
            *pdwOffset += pcode->dwDataLen;
            if (_write(fhAML, pcode->pbDataBuff, (int)pcode->dwDataLen) !=
                (int)pcode->dwDataLen)
            {
                rc = ASLERR_WRITE_FILE;
            }
            break;

        case CODETYPE_INTEGER:
            *pdwOffset += pcode->dwDataLen;
            if (_write(fhAML, &pcode->dwCodeValue, (int)pcode->dwDataLen) !=
                (int)pcode->dwDataLen)
            {
                rc = ASLERR_WRITE_FILE;
            }
            break;

        case CODETYPE_UNKNOWN:
        case CODETYPE_KEYWORD:
            break;

        default:
            ERROR(("WriteAMLFile: unexpected code type - %x",
                   pcode->dwCodeType));
            rc = ASLERR_INTERNAL_ERROR;
    }

    EXIT((1, "WriteAMLFile=%d\n", rc));
    return rc;
}       //WriteAMLFile

/***LP  FreeCodeObjs - free code object tree
 *
 *  ENTRY
 *      pcodeRoot -> root of code object subtree to be free
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeCodeObjs(PCODEOBJ pcodeRoot)
{
    PCODEOBJ pcode, pcodeNext;

    ENTER((1, "FreeCodeObjs(pcodeRoot=%p,Type=%d,Term=%s,Buff=%p)\n",
           pcodeRoot, pcodeRoot->dwCodeType,
           pcodeRoot->dwCodeType == CODETYPE_ASLTERM?
               TermTable[pcodeRoot->dwTermIndex].pszID: "<null>",
           pcodeRoot->pbDataBuff));
    //
    // Free all my children
    //
    for (pcode = pcodeRoot->pcFirstChild; pcode != NULL; pcode = pcodeNext)
    {
        if ((pcodeNext = (PCODEOBJ)pcode->list.plistNext) ==
            pcodeRoot->pcFirstChild)
        {
            pcodeNext = NULL;
        }

        FreeCodeObjs(pcode);
    }

    if (pcodeRoot->pbDataBuff != NULL)
        MEMFREE(pcodeRoot->pbDataBuff);

    MEMFREE(pcodeRoot);

    EXIT((1, "FreeCodeObjs!\n"));
}       //FreeCodeObjs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\pnpmacro.c ===
/*** pnpmacro.c - Parse PNP Macro terms
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    05/05/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

RESFIELD IRQFields[] =
{
    "_INT", 1*8 + 0, 16,
    "_HE",  3*8 + 0, 1,
    "_LL",  3*8 + 3, 1,
    "_SHR", 3*8 + 4, 1,
    NULL,   0,       0
};

RESFIELD IRQNoFlagsFields[] =
{
    "_INT", 1*8 + 0, 16,
    NULL,   0,       0
};

RESFIELD DMAFields[] =
{
    "_DMA", 1*8 + 0, 8,
    "_SIZ", 2*8 + 0, 2,
    "_BM",  2*8 + 2, 1,
    "_TYP", 2*8 + 5, 2,
    NULL,   0,       0
};

RESFIELD IOFields[] =
{
    "_DEC", 1*8 + 0, 1,
    "_MIN", 2*8 + 0, 16,
    "_MAX", 4*8 + 0, 16,
    "_ALN", 6*8 + 0, 8,
    "_LEN", 7*8 + 0, 8,
    NULL,   0,       0
};

RESFIELD FixedIOFields[] =
{
    "_BAS", 1*8 + 0, 16,
    "_LEN", 3*8 + 0, 8,
    NULL,   0,       0
};

RESFIELD Mem24Fields[] =
{
    "_RW",  3*8 + 0, 1,
    "_MIN", 4*8 + 0, 16,
    "_MAX", 6*8 + 0, 16,
    "_ALN", 8*8 + 0, 16,
    "_LEN", 10*8+ 0, 16,
    NULL,   0,       0
};

RESFIELD Mem32Fields[] =
{
    "_RW",  3*8 + 0, 1,
    "_MIN", 4*8 + 0, 32,
    "_MAX", 8*8 + 0, 32,
    "_ALN", 12*8+ 0, 32,
    "_LEN", 16*8+ 0, 32,
    NULL,   0,       0
};

RESFIELD FixedMem32Fields[] =
{
    "_RW",  3*8 + 0, 1,
    "_BAS", 4*8 + 0, 32,
    "_LEN", 8*8 + 0, 32,
    NULL,   0,       0
};

RESFIELD GenFlagFields[] =
{
    "_DEC", 4*8 + 1, 1,
    "_MIF", 4*8 + 2, 1,
    "_MAF", 4*8 + 3, 1,
    NULL,   0,       0
};

RESFIELD MemTypeFields[] =
{
    "_RW",  5*8 + 0, 1,
    "_MEM", 5*8 + 1, 3,
    NULL,   0,       0
};

RESFIELD IOTypeFields[] =
{
    "_RNG", 5*8 + 0, 2,
    NULL,   0,       0
};

RESFIELD DWordFields[] =
{
    "_GRA", 6*8 + 0, 32,
    "_MIN", 10*8+ 0, 32,
    "_MAX", 14*8+ 0, 32,
    "_TRA", 18*8+ 0, 32,
    "_LEN", 22*8+ 0, 32,
    NULL,   0,       0
};

RESFIELD WordFields[] =
{
    "_GRA", 6*8 + 0, 16,
    "_MIN", 8*8 + 0, 16,
    "_MAX", 10*8+ 0, 16,
    "_TRA", 12*8+ 0, 16,
    "_LEN", 14*8+ 0, 16,
    NULL,   0,       0
};

RESFIELD QWordFields[] =
{
    "_GRA", 6*8 + 0, 64,
    "_MIN", 14*8+ 0, 64,
    "_MAX", 22*8+ 0, 64,
    "_TRA", 30*8+ 0, 64,
    "_LEN", 38*8+ 0, 64,
    NULL,   0,       0
};

RESFIELD IRQExFields[] =
{
    "_HE",  3*8 + 1, 1,
    "_LL",  3*8 + 2, 1,
    "_SHR", 3*8 + 3, 1,
    NULL,   0,       0
};

ULONG dwResBitOffset = 0;

/***LP  XferCodeToBuff - Transfer code object tree to buffer
 *
 *  ENTRY
 *      pbBuff -> buffer
 *      pdwcb -> length
 *      pcCode -> code object tree
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL XferCodeToBuff(PBYTE pbBuff, PDWORD pdwcb, PCODEOBJ pcCode)
{
    int rc = ASLERR_NONE;
    DWORD dwLen;
    int iLen;
    PCODEOBJ pc, pcNext;

    ENTER((2, "XferCodeToBuff(pbBuff=%x,Len=%x,pcCode=%x,CodeType=%x)\n",
           pbBuff, *pdwcb, pcCode, pcCode->dwCodeType));

    switch (pcCode->dwCodeType)
    {
        case CODETYPE_ASLTERM:
            if (pcCode->dwCodeValue != OP_NONE)
            {
                iLen = OPCODELEN(pcCode->dwCodeValue);
                memcpy(&pbBuff[*pdwcb], &pcCode->dwCodeValue, iLen);
                *pdwcb += (DWORD)iLen;

                if ((TermTable[pcCode->dwTermIndex].dwfTerm & TF_PACKAGE_LEN) &&
                    ((rc = EncodePktLen(pcCode->dwCodeLen, &dwLen, &iLen)) ==
                     ASLERR_NONE))
                {
                    memcpy(&pbBuff[*pdwcb], &dwLen, iLen);
                    *pdwcb += (DWORD)iLen;
                }

                if ((rc == ASLERR_NONE) && (pcCode->pbDataBuff != NULL))
                {
                    int i;

                    for (i = 0, pc = (PCODEOBJ)pcCode->pbDataBuff;
                         i < (int)pcCode->dwDataLen;
                         ++i)
                    {
                        if ((rc = XferCodeToBuff(pbBuff, pdwcb, &pc[i])) !=
                            ASLERR_NONE)
                        {
                            break;
                        }
                    }

                    if (rc == ASLERR_NONE)
                    {
                        MEMFREE(pcCode->pbDataBuff);
                        pcCode->pbDataBuff = NULL;
                    }
                }
            }

            if (rc == ASLERR_NONE)
            {
                for (pc = pcCode->pcFirstChild; pc != NULL; pc = pcNext)
                {
                    if ((rc = XferCodeToBuff(pbBuff, pdwcb, pc)) != ASLERR_NONE)
                        break;
                    //
                    // Am I the only one left in the list?
                    //
                    if (pc->list.plistNext == &pc->list)
                        pcNext = NULL;
                    else
                        pcNext = (PCODEOBJ)pc->list.plistNext;

                    ListRemoveEntry(&pc->list,
                                    (PPLIST)&pcCode->pcFirstChild);
                    MEMFREE(pc);
                }
            }
            break;

        case CODETYPE_DATAOBJ:
        case CODETYPE_STRING:
        case CODETYPE_QWORD:
            memcpy(&pbBuff[*pdwcb], pcCode->pbDataBuff, pcCode->dwDataLen);
            *pdwcb += pcCode->dwDataLen;
            break;

        case CODETYPE_INTEGER:
            memcpy(&pbBuff[*pdwcb], &pcCode->dwCodeValue, pcCode->dwDataLen);
            *pdwcb += pcCode->dwDataLen;
            break;

        case CODETYPE_KEYWORD:
        case CODETYPE_UNKNOWN:
            break;

        default:
            ERROR(("XferCodeToBuff: unexpected code object type - %d",
                   pcCode->dwCodeType));
            rc = ASLERR_INTERNAL_ERROR;
    }

    EXIT((2, "XferCodeToBuff=%x (Len=%x)\n", rc, *pdwcb));
    return rc;
}       //XferCodeToBuff

/***LP  ResourceTemplate - Start of PNP Resource Template
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ResourceTemplate(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pcData;

    ENTER((1, "ResourceTemplate(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);

    if (fActionFL)
    {
        dwResBitOffset = 0;
    }
    else
    {
        if ((pcData = (PCODEOBJ)MEMALLOC(sizeof(CODEOBJ))) == NULL)
        {
            ERROR(("ResourceTemplate: failed to allocate buffer object"));
            rc = ASLERR_OUT_OF_MEM;
        }
        else
        {
            memset(pcData, 0, sizeof(CODEOBJ));
            pcData->dwCodeType = CODETYPE_DATAOBJ;
            if (gpcodeScope->dwCodeLen <= 0x3f)
                pcData->dwDataLen = gpcodeScope->dwCodeLen - 1;
            else if (gpcodeScope->dwCodeLen <= 0xfff)
                pcData->dwDataLen = gpcodeScope->dwCodeLen - 2;
            else if (gpcodeScope->dwCodeLen <= 0xfffff)
                pcData->dwDataLen = gpcodeScope->dwCodeLen - 3;
            else
                pcData->dwDataLen = gpcodeScope->dwCodeLen - 4;

            pcData->dwDataLen += 2;         //add length of EndTag

            if ((pcData->pbDataBuff = MEMALLOC(pcData->dwDataLen)) == NULL)
            {
                ERROR(("ResourceTemplate: failed to allocate data buffer"));
                rc = ASLERR_OUT_OF_MEM;
            }
            else
            {
                PCODEOBJ pc, pcNext;
                DWORD dwcb = 0;

                for (pc = gpcodeScope->pcFirstChild; pc != NULL; pc = pcNext)
                {
                    if ((rc = XferCodeToBuff(pcData->pbDataBuff, &dwcb, pc)) !=
                        ASLERR_NONE)
                    {
                        break;
                    }
                    //
                    // Am I the only one left in the list?
                    //
                    if (pc->list.plistNext == &pc->list)
                        pcNext = NULL;
                    else
                        pcNext = (PCODEOBJ)pc->list.plistNext;

                    ListRemoveEntry(&pc->list,
                                    (PPLIST)&gpcodeScope->pcFirstChild);
                    MEMFREE(pc);
                }

                if (rc == ASLERR_NONE)
                {
                    pcData->pbDataBuff[dwcb] = 0x79;        //EndTag
                    dwcb++;
                    //
                    // Generate a zero-checksum EndTag because the ASL code
                    // will probably change the resources anyway.
                    //
                    pcData->pbDataBuff[dwcb] = 0;

                    pcData->pcParent = gpcodeScope;
                    ListInsertTail(&pcData->list,
                                   (PPLIST)&gpcodeScope->pcFirstChild);
                    ASSERT(dwcb + 1 == pcData->dwDataLen);
                    pcData->dwCodeLen = pcData->dwDataLen;
                    pcData->bCodeChkSum = ComputeDataChkSum(pcData->pbDataBuff,
                                                            pcData->dwDataLen);
                    if ((gpcodeScope->pbDataBuff = MEMALLOC(sizeof(CODEOBJ))) ==
                        NULL)
                    {
                        ERROR(("ResourceTemplate: failed to allocate buffer argument object"));
                        rc = ASLERR_OUT_OF_MEM;
                    }
                    else
                    {
                        memset(gpcodeScope->pbDataBuff, 0, sizeof(CODEOBJ));
                        if ((rc = MakeIntData(pcData->dwDataLen,
                                              (PCODEOBJ)gpcodeScope->pbDataBuff))
                            == ASLERR_NONE)
                        {
                            gpcodeScope->dwDataLen = 1;
                            gpcodeScope->dwCodeLen = 0;
                            gpcodeScope->bCodeChkSum = 0;
                            ComputeChkSumLen(gpcodeScope);
                        }
                    }
                }
            }
        }
    }

    EXIT((1, "ResourceTemplate=%d\n", rc));
    return rc;
}       //ResourceTemplate

/***LP  AddSmallOffset - Add code length to cumulative bit offset
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL AddSmallOffset(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;

    ENTER((1, "AddSmallOffset(ptoken=%p,fActionFL=%d)\n",
           ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);
    ASSERT((gpcodeScope->dwCodeValue & 0x80) == 0);

    dwResBitOffset += ((gpcodeScope->dwCodeValue & 0x07) + 1)*8;

    EXIT((1, "AddSmallOffset=%d\n", rc));
    return rc;
}       //AddSmallOffset

/***LP  StartDependentFn - Start of Dependent Function
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL StartDependentFn(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "StartDependentFn(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (pArgs[0].dwCodeValue > 2)
    {
        PrintTokenErr(ptoken, "Arg0 should be between 0-2", TRUE);
        rc = ASLERR_SYNTAX;
    }
    else if (pArgs[1].dwCodeValue > 2)
    {
        PrintTokenErr(ptoken, "Arg1 should be between 0-2", TRUE);
        rc = ASLERR_SYNTAX;
    }
    else
    {
        pArgs[0].dwCodeValue |= pArgs[1].dwCodeValue << 2;
        pArgs[0].bCodeChkSum = (BYTE)pArgs[0].dwCodeValue;
        gpcodeScope->dwDataLen = 1;
        ASSERT((gpcodeScope->dwCodeValue & 0x80) == 0);
        dwResBitOffset += ((gpcodeScope->dwCodeValue & 0x07) + 1)*8;
    }

    EXIT((1, "StartDependentFn=%d\n", rc));
    return rc;
}       //StartDependentFn

/***LP  IRQDesc - IRQ resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL IRQDesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;
    DWORD dwLen, dwIRQ = 0, dw;
    PCODEOBJ pc;
    #define MAX_IRQ     0x0f

    ENTER((1, "IRQDesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == FALSE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (gpcodeScope->dwDataLen == 4)    //IRQ
    {
        dwLen = 3;

        if ((rc = SetDefMissingKW(&pArgs[2], ID_EXCLUSIVE)) == ASLERR_NONE)
        {
            EncodeKeywords(pArgs, 0x07, 0);
            if ((pArgs[0].dwCodeValue & (_LL | _HE)) == (_LL | _HE))
            {
                PrintTokenErr(ptoken,
                              "Illegal combination of interrupt level and trigger mode",
                              TRUE);
                rc = ASLERR_SYNTAX;
            }
        }
    }
    else                                //IRQNoFlags
    {
        ASSERT(gpcodeScope->dwDataLen == 1);

        dwLen = 2;
    }

    if (rc == ASLERR_NONE)
    {
        pc = gpcodeScope->pcFirstChild;
        if (pc != NULL)
        {
            ASSERT(pc->dwCodeType == CODETYPE_DATAOBJ);
            for (dw = 0; dw < pc->dwDataLen; ++dw)
            {
                if (pc->pbDataBuff[dw] > MAX_IRQ)
                {
                    PrintTokenErr(ptoken, "Invalid IRQ number", TRUE);
                    rc = ASLERR_SYNTAX;
                    break;
                }
                else
                {
                    dwIRQ |= 1 << pc->pbDataBuff[dw];
                }
            }

            if (rc == ASLERR_NONE)
            {
                MEMFREE(pc->pbDataBuff);
                pc->pbDataBuff = NULL;
            }
        }
        else if ((pc = MEMALLOC(sizeof(CODEOBJ))) != NULL)
        {
            memset(pc, 0, sizeof(CODEOBJ));
            pc->pcParent = gpcodeScope;
            ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
        }
        else
        {
            ERROR(("IRQDesc: failed to allocate DMA descriptor"));
            rc = ASLERR_OUT_OF_MEM;
        }

        if (rc == ASLERR_NONE)
        {
            PCODEOBJ pa;

            if (dwLen == 3)
                dwIRQ |= (pArgs[0].dwCodeValue & 0xff) << 16;

            SetIntObject(pc, dwIRQ, dwLen);

            pa = &pArgs[gpcodeScope->dwDataLen == 4? 3: 0];
            if (pa->dwCodeType == CODETYPE_STRING)
            {
                PNSOBJ pns;

                if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pa->pbDataBuff,
                                             gpnsCurrentScope, gpnsCurrentOwner,
                                             &pns, NSF_EXIST_ERR)) ==
                    ASLERR_NONE)
                {
                    pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
                    rc = CreateResFields(ptoken, pns,
                                         gpcodeScope->dwDataLen == 4?
                                             IRQFields: IRQNoFlagsFields);
                }
                MEMFREE(pa->pbDataBuff);
                memset(pa, 0, sizeof(CODEOBJ));
            }

            if (rc == ASLERR_NONE)
            {
                gpcodeScope->dwDataLen = 0;
                MEMFREE(gpcodeScope->pbDataBuff);
                gpcodeScope->pbDataBuff = NULL;
                gpcodeScope->dwCodeLen = 0;
                gpcodeScope->bCodeChkSum = 0;
                ComputeChkSumLen(gpcodeScope);
                ASSERT((gpcodeScope->dwCodeValue & 0x80) == 0);
                dwResBitOffset += ((gpcodeScope->dwCodeValue & 0x07) + 1)*8;
            }
        }
    }

    EXIT((1, "IRQDesc=%d\n", rc));
    return rc;
}       //IRQDesc

/***LP  DMADesc - DMA resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DMADesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;
    DWORD dwDMA = 0, dw;
    PCODEOBJ pc;
    #define MAX_DMA     0x07

    ENTER((1, "DMADesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == FALSE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x07, 0);
    pc = gpcodeScope->pcFirstChild;
    if (pc != NULL)
    {
        ASSERT(pc->dwCodeType == CODETYPE_DATAOBJ);
        for (dw = 0; dw < pc->dwDataLen; ++dw)
        {
            if (pc->pbDataBuff[dw] > MAX_DMA)
            {
                PrintTokenErr(ptoken, "Invalid DMA number", TRUE);
                rc = ASLERR_SYNTAX;
                break;
            }
            else
            {
                dwDMA |= 1 << pc->pbDataBuff[dw];
            }
        }

        if (rc == ASLERR_NONE)
        {
            MEMFREE(pc->pbDataBuff);
            pc->pbDataBuff = NULL;
        }
    }
    else if ((pc = MEMALLOC(sizeof(CODEOBJ))) != NULL)
    {
        memset(pc, 0, sizeof(CODEOBJ));
        pc->pcParent = gpcodeScope;
        ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
    }
    else
    {
        ERROR(("DMADesc: failed to allocate DMA descriptor"));
        rc = ASLERR_OUT_OF_MEM;
    }

    if (rc == ASLERR_NONE)
    {
        dwDMA |= (pArgs[0].dwCodeValue & 0xff) << 8;

        SetIntObject(pc, dwDMA, sizeof(WORD));

        if (pArgs[3].dwCodeType == CODETYPE_STRING)
        {
            PNSOBJ pns;

            if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[3].pbDataBuff,
                                         gpnsCurrentScope, gpnsCurrentOwner,
                                         &pns, NSF_EXIST_ERR)) ==
                ASLERR_NONE)
            {
                pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
                rc = CreateResFields(ptoken, pns, DMAFields);
            }
            MEMFREE(pArgs[3].pbDataBuff);
            memset(&pArgs[3], 0, sizeof(CODEOBJ));
        }

        if (rc == ASLERR_NONE)
        {
            gpcodeScope->dwDataLen = 0;
            MEMFREE(gpcodeScope->pbDataBuff);
            gpcodeScope->pbDataBuff = NULL;
            gpcodeScope->dwCodeLen = 0;
            gpcodeScope->bCodeChkSum = 0;
            ComputeChkSumLen(gpcodeScope);
            ASSERT((gpcodeScope->dwCodeValue & 0x80) == 0);
            dwResBitOffset += ((gpcodeScope->dwCodeValue & 0x07) + 1)*8;
        }
    }

    EXIT((1, "DMADesc=%d\n", rc));
    return rc;
}       //DMADesc

/***LP  IODesc - IO resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL IODesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "IODesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x01, 0);

    if (pArgs[5].dwCodeType == CODETYPE_STRING)
    {
        PNSOBJ pns;

        if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[5].pbDataBuff,
                                     gpnsCurrentScope, gpnsCurrentOwner,
                                     &pns, NSF_EXIST_ERR)) ==
            ASLERR_NONE)
        {
            pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
            rc = CreateResFields(ptoken, pns, IOFields);
        }
        MEMFREE(pArgs[5].pbDataBuff);
        memset(&pArgs[5], 0, sizeof(CODEOBJ));
    }

    if (rc == ASLERR_NONE)
    {
        ASSERT((gpcodeScope->dwCodeValue & 0x80) == 0);
        dwResBitOffset += ((gpcodeScope->dwCodeValue & 0x07) + 1)*8;
    }

    EXIT((1, "IODesc=%d\n", rc));
    return rc;
}       //IODesc

/***LP  FixedIODesc - FixedIO resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL FixedIODesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;

    ENTER((1, "FixedIODesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    if (pArgs[2].dwCodeType == CODETYPE_STRING)
    {
        PNSOBJ pns;

        if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[2].pbDataBuff,
                                     gpnsCurrentScope, gpnsCurrentOwner,
                                     &pns, NSF_EXIST_ERR)) ==
            ASLERR_NONE)
        {
            pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
            rc = CreateResFields(ptoken, pns, FixedIOFields);
        }
        MEMFREE(pArgs[2].pbDataBuff);
        memset(&pArgs[2], 0, sizeof(CODEOBJ));
    }

    if (rc == ASLERR_NONE)
    {
        ASSERT((gpcodeScope->dwCodeValue & 0x80) == 0);
        dwResBitOffset += ((gpcodeScope->dwCodeValue & 0x07) + 1)*8;
    }

    EXIT((1, "FixedIODesc=%d\n", rc));
    return rc;
}       //FixedIODesc

/***LP  VendorDesc - Vendor-defined resource
 *
 *  ENTRY
 *      ptoken -> token stream
 *      dwMaxSize - 0x07 if short resource, 0xffff if long resource
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL VendorDesc(PTOKEN ptoken, DWORD dwMaxSize)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pc;
    PBYTE pbOldBuff = NULL;
    DWORD dwOldLen = 0;
    #define SHORT_MAX_SIZE      0x07
    #define LONG_MAX_SIZE       0xffff

    ENTER((1, "VendorDesc(ptoken=%p,MaxSize=%d)\n", ptoken, dwMaxSize));

    ASSERT((dwMaxSize == SHORT_MAX_SIZE) || (dwMaxSize == LONG_MAX_SIZE));
    pc = gpcodeScope->pcFirstChild;
    if (pc != NULL)
    {
        ASSERT(pc->dwCodeType == CODETYPE_DATAOBJ);
        if (pc->dwDataLen > dwMaxSize)
        {
            PrintTokenErr(ptoken, "Vendor resource data can only be up to "
                          "7 bytes for short descriptor and 64K-1 bytes for "
                          "long descriptor", TRUE);
            rc = ASLERR_SYNTAX;
        }
        else
        {
            pbOldBuff = pc->pbDataBuff;
            dwOldLen = pc->dwDataLen;
        }
    }
    else if ((pc = MEMALLOC(sizeof(CODEOBJ))) != NULL)
    {
        memset(pc, 0, sizeof(CODEOBJ));
        pc->pcParent = gpcodeScope;
        ListInsertTail(&pc->list, (PPLIST)&gpcodeScope->pcFirstChild);
    }
    else
    {
        ERROR(("VendorDesc: failed to allocate vendor-defined resource object"));
        rc = ASLERR_OUT_OF_MEM;
    }

    if (rc == ASLERR_NONE)
    {
        int i;

        pc->dwCodeType = CODETYPE_DATAOBJ;
        if (dwMaxSize == SHORT_MAX_SIZE)
            pc->dwDataLen = dwOldLen + 1;
        else
            pc->dwDataLen = dwOldLen + sizeof(WORD);

        if ((pc->pbDataBuff = MEMALLOC(pc->dwDataLen)) != NULL)
        {
            PCODEOBJ pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;

            if (dwMaxSize == SHORT_MAX_SIZE)
            {
                pc->pbDataBuff[0] = (BYTE)(0x70 | dwOldLen);
                i = 1;
            }
            else
            {
                *((PWORD)&pc->pbDataBuff[0]) = (WORD)dwOldLen;
                i = sizeof(WORD);
            }

            if (pbOldBuff != NULL)
            {
                memcpy(&pc->pbDataBuff[i], pbOldBuff, dwOldLen);
                MEMFREE(pbOldBuff);
            }
            pc->dwCodeLen = pc->dwDataLen;
            pc->bCodeChkSum = ComputeDataChkSum((PBYTE)&pc->pbDataBuff,
                                                pc->dwCodeLen);

            if (pArgs[0].dwCodeType == CODETYPE_STRING)
            {
                PNSOBJ pns;

                if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[0].pbDataBuff,
                                             gpnsCurrentScope, gpnsCurrentOwner,
                                             &pns, NSF_EXIST_ERR)) ==
                    ASLERR_NONE)
                {
                    pns->ObjData.dwDataType = OBJTYPE_RES_FIELD;
                    pns->ObjData.uipDataValue = dwResBitOffset +
                                               (dwMaxSize == SHORT_MAX_SIZE?
                                                8: 8*3);
                    pns->ObjData.dwDataLen = 8*dwOldLen;
                }
                MEMFREE(pArgs[0].pbDataBuff);
                memset(&pArgs[0], 0, sizeof(CODEOBJ));
            }

            if (rc == ASLERR_NONE)
            {
                gpcodeScope->dwDataLen = 0;
                MEMFREE(gpcodeScope->pbDataBuff);
                gpcodeScope->pbDataBuff = NULL;
                gpcodeScope->dwCodeLen = 0;
                gpcodeScope->bCodeChkSum = 0;
                ComputeChkSumLen(gpcodeScope);

                if (dwMaxSize == SHORT_MAX_SIZE)
                {
                    dwResBitOffset += ((pc->pbDataBuff[0] & 0x07) + 1)*8;
                }
                else
                {
                    dwResBitOffset += (*((PWORD)&pc->pbDataBuff[0]) + 3)*8;
                }
            }
        }
        else
        {
            ERROR(("VendorDesc: failed to allocate vendor-defined resource buffer"));
            rc = ASLERR_OUT_OF_MEM;
        }
    }

    EXIT((1, "VendorDesc=%d\n", rc));
    return rc;
}       //VendorDesc

/***LP  VendorShort - Vendor-defined short resource
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL VendorShort(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "VendorShort(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == FALSE);

    rc = VendorDesc(ptoken, 0x07);

    EXIT((1, "VendorShort=%d\n", rc));
    return rc;
}       //VendorShort

/***LP  InsertDescLength - Insert long descriptor length
 *
 *  ENTRY
 *      pcode -> code object
 *      dwDescLen - length of descriptor
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL InsertDescLength(PCODEOBJ pcode, DWORD dwDescLen)
{
    int rc;
    PCODEOBJ pNewArgs;

    ENTER((2, "InsertDescLength(pcode=%x,DescLen=%d)\n", pcode, dwDescLen));

    if ((pNewArgs = MEMALLOC((pcode->dwDataLen + 1)*sizeof(CODEOBJ))) != NULL)
    {
        memcpy(&pNewArgs[1], pcode->pbDataBuff,
               pcode->dwDataLen*sizeof(CODEOBJ));
        memset(&pNewArgs[0], 0, sizeof(CODEOBJ));
        SetIntObject(&pNewArgs[0], dwDescLen, sizeof(WORD));
        MEMFREE(pcode->pbDataBuff);
        pcode->dwDataLen++;
        pcode->pbDataBuff = (PBYTE)pNewArgs;

        rc = ASLERR_NONE;
    }
    else
    {
        ERROR(("InsertDescLength: failed to allocate new argument objects"));
        rc = ASLERR_OUT_OF_MEM;
    }

    EXIT((2, "InsertDescLength=%d\n", rc));
    return rc;
}       //InsertDescLength

/***LP  Memory24Desc - 24-bit memory resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Memory24Desc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "Memory24Desc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x01, 0);

    if (pArgs[5].dwCodeType == CODETYPE_STRING)
    {
        PNSOBJ pns;

        if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[5].pbDataBuff,
                                     gpnsCurrentScope, gpnsCurrentOwner,
                                     &pns, NSF_EXIST_ERR)) ==
            ASLERR_NONE)
        {
            pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
            rc = CreateResFields(ptoken, pns, Mem24Fields);
        }
        MEMFREE(pArgs[5].pbDataBuff);
        memset(&pArgs[5], 0, sizeof(CODEOBJ));
    }

    if ((rc == ASLERR_NONE) &&
        ((rc = InsertDescLength(gpcodeScope, 9)) == ASLERR_NONE))
    {
        dwResBitOffset += 12*8;
    }

    EXIT((1, "Memory24Desc=%d\n", rc));
    return rc;
}       //Memory24Desc

/***LP  VendorLong - Vendor-defined long resource
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL VendorLong(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "VendorLong(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == FALSE);

    rc = VendorDesc(ptoken, 0xffff);

    EXIT((1, "VendorLong=%d\n", rc));
    return rc;
}       //VendorLong

/***LP  Memory32Desc - 32-bit memory resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL Memory32Desc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "Memory32Desc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x01, 0);

    if (pArgs[5].dwCodeType == CODETYPE_STRING)
    {
        PNSOBJ pns;

        if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[5].pbDataBuff,
                                     gpnsCurrentScope, gpnsCurrentOwner,
                                     &pns, NSF_EXIST_ERR)) ==
            ASLERR_NONE)
        {
            pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
            rc = CreateResFields(ptoken, pns, Mem32Fields);
        }
        MEMFREE(pArgs[5].pbDataBuff);
        memset(&pArgs[5], 0, sizeof(CODEOBJ));
    }

    if ((rc == ASLERR_NONE) &&
        ((rc = InsertDescLength(gpcodeScope, 17)) == ASLERR_NONE))
    {
        dwResBitOffset += 20*8;
    }

    EXIT((1, "Memory32Desc=%d\n", rc));
    return rc;
}       //Memory32Desc

/***LP  FixedMemory32Desc - 32-bit fixed memory resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL FixedMemory32Desc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;

    ENTER((1, "FixedMemory32Desc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    EncodeKeywords(pArgs, 0x01, 0);

    if (pArgs[3].dwCodeType == CODETYPE_STRING)
    {
        PNSOBJ pns;

        if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[3].pbDataBuff,
                                     gpnsCurrentScope, gpnsCurrentOwner,
                                     &pns, NSF_EXIST_ERR)) ==
            ASLERR_NONE)
        {
            pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
            rc = CreateResFields(ptoken, pns, FixedMem32Fields);
        }
        MEMFREE(pArgs[3].pbDataBuff);
        memset(&pArgs[3], 0, sizeof(CODEOBJ));
    }

    if ((rc == ASLERR_NONE) &&
        ((rc = InsertDescLength(gpcodeScope, 9)) == ASLERR_NONE))
    {
        dwResBitOffset += 12*8;
    }

    EXIT((1, "FixedMemory32Desc=%d\n", rc));
    return rc;
}       //FixedMemory32Desc

#define RESTYPE_MEM     0
#define RESTYPE_IO      1
#define RESTYPE_BUSNUM  2

/***LP  MemSpaceDesc - Memory space descriptor
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      dwMinLen - minimum descriptor length
 *      ResFields -> resource fields table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL MemSpaceDesc(PTOKEN ptoken, DWORD dwMinLen, PRESFIELD ResFields)
{
    int rc;
    PCODEOBJ pArgs;

    ENTER((1, "MemSpaceDesc(ptoken=%p,MinLen=%d,ResFields=%p)\n",
           ptoken, dwMinLen, ResFields));

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (((rc = SetDefMissingKW(&pArgs[0], ID_RESCONSUMER)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[1], ID_POSDECODE)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[2], ID_MINNOTFIXED)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[3], ID_MAXNOTFIXED)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[4], ID_NONCACHEABLE)) == ASLERR_NONE))
    {
        EncodeKeywords(pArgs, 0x0f, 2);
        EncodeKeywords(pArgs, 0x30, 3);
        SetIntObject(&pArgs[1], RESTYPE_MEM, sizeof(BYTE));

        if (!(pArgs[11].dwfCode & CF_MISSING_ARG))
            dwMinLen++;

        if (!(pArgs[12].dwfCode & CF_MISSING_ARG))
        {
            ASSERT(pArgs[12].dwCodeType == CODETYPE_STRING);
            dwMinLen += pArgs[12].dwDataLen;
        }

        SetIntObject(&pArgs[0], dwMinLen, sizeof(WORD));

        if (pArgs[13].dwCodeType == CODETYPE_STRING)
        {
            PNSOBJ pns;

            if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[13].pbDataBuff,
                                         gpnsCurrentScope, gpnsCurrentOwner,
                                         &pns, NSF_EXIST_ERR)) ==
                ASLERR_NONE)
            {
                pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
                if (((rc = CreateResFields(ptoken, pns, GenFlagFields)) ==
                     ASLERR_NONE) &&
                    ((rc = CreateResFields(ptoken, pns, MemTypeFields)) ==
                     ASLERR_NONE))
                {
                    rc = CreateResFields(ptoken, pns, ResFields);
                }
            }
            MEMFREE(pArgs[13].pbDataBuff);
            memset(&pArgs[13], 0, sizeof(CODEOBJ));
        }

        if (rc == ASLERR_NONE)
        {
            dwResBitOffset += (dwMinLen + 3)*8;
        }
    }

    EXIT((1, "MemSpaceDesc=%d\n", rc));
    return rc;
}       //MemSpaceDesc

/***LP  IOSpaceDesc - IO space descriptor
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      dwMinLen - minimum descriptor length
 *      ResFields -> resource fields table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL IOSpaceDesc(PTOKEN ptoken, DWORD dwMinLen, PRESFIELD ResFields)
{
    int rc;
    PCODEOBJ pArgs;

    ENTER((2, "IOSpaceDesc(ptoken=%p,MinLen=%d,ResFields=%p)\n",
           ptoken, dwMinLen, ResFields));

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (((rc = SetDefMissingKW(&pArgs[0], ID_RESCONSUMER)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[1], ID_MINNOTFIXED)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[2], ID_MAXNOTFIXED)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[3], ID_POSDECODE)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[4], ID_ENTIRERNG)) == ASLERR_NONE))
    {
        EncodeKeywords(pArgs, 0x0f, 2);
        EncodeKeywords(pArgs, 0x10, 3);
        SetIntObject(&pArgs[1], RESTYPE_IO, sizeof(BYTE));

        if (!(pArgs[10].dwfCode & CF_MISSING_ARG))
            dwMinLen++;

        if (!(pArgs[11].dwfCode & CF_MISSING_ARG))
        {
            ASSERT(pArgs[11].dwCodeType == CODETYPE_STRING);
            dwMinLen += pArgs[11].dwDataLen;
        }

        SetIntObject(&pArgs[0], dwMinLen, sizeof(WORD));

        if (pArgs[12].dwCodeType == CODETYPE_STRING)
        {
            PNSOBJ pns;

            if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[12].pbDataBuff,
                                         gpnsCurrentScope, gpnsCurrentOwner,
                                         &pns, NSF_EXIST_ERR)) ==
                ASLERR_NONE)
            {
                pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
                if (((rc = CreateResFields(ptoken, pns, GenFlagFields)) ==
                     ASLERR_NONE) &&
                    ((rc = CreateResFields(ptoken, pns, MemTypeFields)) ==
                     ASLERR_NONE))
                {
                    rc = CreateResFields(ptoken, pns, ResFields);
                }
            }
            MEMFREE(pArgs[12].pbDataBuff);
            memset(&pArgs[12], 0, sizeof(CODEOBJ));
        }

        if (rc == ASLERR_NONE)
        {
            dwResBitOffset += (dwMinLen + 3)*8;
        }
    }

    EXIT((2, "IOSpaceDesc=%d\n", rc));
    return rc;
}       //IOSpaceDesc

/***LP  DWordMemDesc - DWord memory descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DWordMemDesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "DWordMemDesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    rc = MemSpaceDesc(ptoken, 23, DWordFields);

    EXIT((1, "DWordMemDesc=%d\n", rc));
    return rc;
}       //DWordMemDesc

/***LP  DWordIODesc - DWord IO descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DWordIODesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "DWordIODesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    rc = IOSpaceDesc(ptoken, 23, DWordFields);

    EXIT((1, "DWordIODesc=%d\n", rc));
    return rc;
}       //DWordIODesc

/***LP  WordIODesc - Word IO descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL WordIODesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "WordIODesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    rc = IOSpaceDesc(ptoken, 13, WordFields);

    EXIT((1, "WordIODesc=%d\n", rc));
    return rc;
}       //WordIODesc

/***LP  WordBusNumDesc - Word BusNum descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL WordBusNumDesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;
    PCODEOBJ pArgs;

    ENTER((1, "WordBusNumDesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    if (((rc = SetDefMissingKW(&pArgs[0], ID_RESCONSUMER)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[1], ID_MINNOTFIXED)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[2], ID_MAXNOTFIXED)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[3], ID_POSDECODE)) == ASLERR_NONE))
    {
        DWORD dwLen;

        EncodeKeywords(pArgs, 0x0f, 2);
        SetIntObject(&pArgs[1], RESTYPE_BUSNUM, sizeof(BYTE));
        SetIntObject(&pArgs[3], 0, sizeof(BYTE));

        dwLen = 13;
        if (!(pArgs[9].dwfCode & CF_MISSING_ARG))
            dwLen++;

        if (!(pArgs[10].dwfCode & CF_MISSING_ARG))
        {
            ASSERT(pArgs[10].dwCodeType == CODETYPE_STRING);
            dwLen += pArgs[10].dwDataLen;
        }

        SetIntObject(&pArgs[0], dwLen, sizeof(WORD));

        if (pArgs[11].dwCodeType == CODETYPE_STRING)
        {
            PNSOBJ pns;

            if ((rc = CreateNameSpaceObj(ptoken, (PSZ)pArgs[11].pbDataBuff,
                                         gpnsCurrentScope, gpnsCurrentOwner,
                                         &pns, NSF_EXIST_ERR)) ==
                ASLERR_NONE)
            {
                pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
                if ((rc = CreateResFields(ptoken, pns, GenFlagFields)) ==
                    ASLERR_NONE)
                {
                    rc = CreateResFields(ptoken, pns, WordFields);
                }
            }
            MEMFREE(pArgs[11].pbDataBuff);
            memset(&pArgs[11], 0, sizeof(CODEOBJ));
        }

        if (rc == ASLERR_NONE)
        {
            dwResBitOffset += (dwLen + 3)*8;
        }
    }

    EXIT((1, "WordBusNumDesc=%d\n", rc));
    return rc;
}       //WordBusNumDesc

/***LP  InterruptDesc - Extended Interrupt resource descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL InterruptDesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc = ASLERR_NONE;
    PCODEOBJ pArgs;
    PCODEOBJ pc;

    ENTER((1, "InterruptDesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(fActionFL);
    ASSERT(fActionFL == FALSE);

    pArgs = (PCODEOBJ)gpcodeScope->pbDataBuff;
    pc = gpcodeScope->pcFirstChild;
    if (((rc = SetDefMissingKW(&pArgs[0], ID_RESCONSUMER)) == ASLERR_NONE) &&
        ((rc = SetDefMissingKW(&pArgs[3], ID_EXCLUSIVE)) == ASLERR_NONE))
    {
        if (pArgs[1].dwCodeValue == ID_EDGE)
            pArgs[1].dwCodeValue = ID_EXT_EDGE;
        else if (pArgs[1].dwCodeValue == ID_LEVEL)
            pArgs[1].dwCodeValue = ID_EXT_LEVEL;

        if (pArgs[2].dwCodeValue == ID_ACTIVEHI)
            pArgs[2].dwCodeValue = ID_EXT_ACTIVEHI;
        else if (pArgs[2].dwCodeValue == ID_ACTIVELO)
            pArgs[2].dwCodeValue = ID_EXT_ACTIVELO;

        if (pArgs[3].dwCodeValue == ID_SHARED)
            pArgs[3].dwCodeValue = ID_EXT_SHARED;
        else if (pArgs[3].dwCodeValue == ID_EXCLUSIVE)
            pArgs[3].dwCodeValue = ID_EXT_EXCLUSIVE;

        if (((rc = LookupIDIndex(pArgs[1].dwCodeValue, &pArgs[1].dwTermIndex))
             == ASLERR_NONE) &&
            ((rc = LookupIDIndex(pArgs[2].dwCodeValue, &pArgs[2].dwTermIndex))
             == ASLERR_NONE) &&
            ((rc = LookupIDIndex(pArgs[3].dwCodeValue, &pArgs[3].dwTermIndex))
             == ASLERR_NONE))
        {
            EncodeKeywords(pArgs, 0x0f, 1);
            {
                DWORD dwNumIRQs = 0;
                DWORD dwLen;

                if (pc != NULL)
                {
                    ASSERT(pc->dwCodeType == CODETYPE_DATAOBJ);
                    dwNumIRQs = pc->dwDataLen/sizeof(DWORD);
                }

                SetIntObject(&pArgs[2], dwNumIRQs, sizeof(BYTE));
                memcpy(&pArgs[3], pc, sizeof(CODEOBJ));
                MEMFREE(pc);
                gpcodeScope->pcFirstChild = NULL;

                dwLen = 2 + dwNumIRQs*sizeof(DWORD);
                if (!(pArgs[4].dwfCode & CF_MISSING_ARG))
                    dwLen++;

                if (!(pArgs[5].dwfCode & CF_MISSING_ARG))
                {
                    ASSERT(pArgs[5].dwCodeType == CODETYPE_STRING);
                    dwLen += pArgs[5].dwDataLen;
                }

                SetIntObject(&pArgs[0], dwLen, sizeof(WORD));

                if (pArgs[6].dwCodeType == CODETYPE_STRING)
                {
                    PNSOBJ pns;
                    static RESFIELD IRQTabFields[] =
                    {
                        "_INT", 5*8 + 0, 0,
                        NULL,   0,       0
                    };

                    IRQTabFields[0].dwBitSize = dwNumIRQs*32;
                    if ((rc = CreateNameSpaceObj(ptoken,
                                                 (PSZ)pArgs[6].pbDataBuff,
                                                 gpnsCurrentScope,
                                                 gpnsCurrentOwner,
                                                 &pns, NSF_EXIST_ERR)) ==
                        ASLERR_NONE)
                    {
                        pns->ObjData.dwDataType = OBJTYPE_PNP_RES;
                        if ((rc = CreateResFields(ptoken, pns, IRQExFields)) ==
                            ASLERR_NONE)
                        {
                            rc = CreateResFields(ptoken, pns, IRQTabFields);
                        }
                    }
                    MEMFREE(pArgs[6].pbDataBuff);
                    memset(&pArgs[6], 0, sizeof(CODEOBJ));
                }

                if (rc == ASLERR_NONE)
                {
                    gpcodeScope->dwCodeLen = 0;
                    gpcodeScope->bCodeChkSum = 0;
                    ComputeChkSumLen(gpcodeScope);
                    dwResBitOffset = (dwLen + 3)*8;
                }
            }
        }
    }

    EXIT((1, "InterruptDesc=%d\n", rc));
    return rc;
}       //InterruptDesc

/***LP  QWordMemDesc - QWord memory descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL QWordMemDesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "QWordMemDesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    rc = MemSpaceDesc(ptoken, 43, QWordFields);

    EXIT((1, "QWordMemDesc=%d\n", rc));
    return rc;
}       //QWordMemDesc

/***LP  QWordIODesc - QWord IO descriptor
 *
 *  ENTRY
 *      ptoken -> token stream
 *      fActionFL - TRUE if this is a fixed list action
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL QWordIODesc(PTOKEN ptoken, BOOL fActionFL)
{
    int rc;

    ENTER((1, "QWordIODesc(ptoken=%p,fActionFL=%d)\n", ptoken, fActionFL));

    DEREF(ptoken);
    DEREF(fActionFL);
    ASSERT(fActionFL == TRUE);

    rc = IOSpaceDesc(ptoken, 43, QWordFields);

    EXIT((1, "QWordIODesc=%d\n", rc));
    return rc;
}       //QWordIODesc

/***LP  CreateResFields - Create resource fields
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      pnsParent -> parent object
 *      prf -> resource fields table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL CreateResFields(PTOKEN ptoken, PNSOBJ pnsParent, PRESFIELD prf)
{
    int rc = ASLERR_NONE;
    int i;
    PNSOBJ pns;

    ENTER((2, "CreateResFields(ptoken=%p,pnsParent=%s,prf=%p)\n",
           ptoken, GetObjectPath(pnsParent), prf));

    for (i = 0; prf[i].pszName != NULL; ++i)
    {
        if ((rc = CreateNameSpaceObj(ptoken, prf[i].pszName, pnsParent,
                                     gpnsCurrentOwner, &pns, NSF_EXIST_ERR))
            == ASLERR_NONE)
        {
            pns->ObjData.dwDataType = OBJTYPE_RES_FIELD;
            pns->ObjData.uipDataValue = dwResBitOffset + prf[i].dwBitOffset;
            pns->ObjData.dwDataLen = prf[i].dwBitSize;
        }
    }

    EXIT((2, "CreateResFields=%d\n", rc));
    return rc;
}      //CreateResFields
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\pch.h ===
#pragma warning (disable: 4201)

/*** Build Options
 */

#ifdef DEBUG
  #define TRACING
  #define TUNE
#endif

#ifndef EXCL_BASEDEF
  #include "basedef.h"
#endif

#include <stdio.h>      //for FILE *
#include <stdlib.h>     //for malloc
#include <string.h>     //for _stricmp
#include <ctype.h>      //for isspace
#ifdef WINNT
  #include <crt\io.h>   //for _open, _close, _read, _write
#else
  #include <io.h>
#endif
#include <fcntl.h>      //for open flags
#include <sys\stat.h>   //for pmode flags

//#define _UNASM_LIB

#include <acpitabl.h>
#include "list.h"
#include "debug.h"
#define _INC_NSOBJ_ONLY
#include "amli.h"
#include "aml.h"
#include "uasmdata.h"

#ifdef _UNASM_LIB
  #define PTOKEN PVOID
#else
  #include "aslp.h"
  #include "parsearg.h"
  #include "line.h"
  #define TOKERR_BASE -100
  #include "token.h"
  #include "scanasl.h"
  #ifdef __UNASM
    #define USE_CRUNTIME
    #include "binfmt.h"
  #endif
  #include "proto.h"
  #include "data.h"
#endif  //ifdef _UNASM_LIB

#include "acpins.h"
#include "unasm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\proto.h ===
/*** proto.h - Local function prototypes
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/07/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _PROTO_H
#define _PROTO_H

// asl.c
int LOCAL ReadBinFile(PSZ pszFile, PBYTE *ppb, PDWORD pdwTableSig);
VOID LOCAL PrintLogo(VOID);
int LOCAL PrintHelp(char **ppszArg, PARGTYPE pAT);
VOID LOCAL PrintUsage(VOID);

// parseasl.c
int LOCAL ParseASLFile(PSZ pszFile);
int LOCAL ParseASLTerms(PTOKEN ptoken, int iNestLevel);
BOOL LOCAL ValidateTermClass(DWORD dwTermClass, PCODEOBJ pcParent);
int LOCAL ParseASLTerm(PTOKEN ptoken, int iNestLevel);
int LOCAL ParseFieldList(PTOKEN ptoken);
int LOCAL ParsePackageList(PTOKEN ptoken);
int LOCAL ParseBuffList(PTOKEN ptoken);
int LOCAL ParseDataList(PTOKEN ptoken, int icbDataSize);
int LOCAL ParseArgs(PTOKEN ptoken, PASLTERM pterm, int iNumArgs);
int LOCAL ParseUserTerm(PTOKEN ptoken, BOOL fNonMethodOK);
int LOCAL ParseName(PTOKEN ptoken, BOOL fEncode);
int LOCAL ParseSuperName(PTOKEN ptoken);
int LOCAL MakeIntData(DWORD dwData, PCODEOBJ pc);
int LOCAL GetIntData(PCODEOBJ pc, PDWORD pdwData);
int LOCAL ParseData(PTOKEN ptoken);
int LOCAL ParseInteger(PTOKEN ptoken, char c);
int LOCAL ParseOpcode(PTOKEN ptoken, char c);
int LOCAL ParseKeyword(PTOKEN ptoken, char chExpectType);
int LOCAL ParseString(PTOKEN ptoken);
int LOCAL ValidateObject(PTOKEN ptoken, PSZ pszName, char chActType,
                         char chArgType);
int LOCAL ValidateNSChkList(PNSCHK pnschkHead);
int LOCAL QueueNSChk(PTOKEN ptoken, PSZ pszObjName, ULONG dwExpectedType,
                     ULONG dwChkData);

// aslterms.c
int LOCAL DefinitionBlock(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Include(PTOKEN ptoken, BOOL fActionFL);
int LOCAL External(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Method(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Alias(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Name(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Scope(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Field(PTOKEN ptoken, BOOL fActionFL);
int LOCAL IndexField(PTOKEN ptoken, BOOL fActionFL);
int LOCAL BankField(PTOKEN ptoken, BOOL fActionFL);
int LOCAL OpRegion(PTOKEN ptoken, BOOL fActionFL);
int LOCAL EISAID(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Match(PTOKEN ptoken, BOOL fActionFL);
int LOCAL AccessAs(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Else(PTOKEN ptoken, BOOL fActionFL);

// pnpmacro.c
int LOCAL XferCodeToBuff(PBYTE pbBuff, PDWORD pdwcb, PCODEOBJ pcCode);
int LOCAL ResourceTemplate(PTOKEN ptoken, BOOL fActionFL);
int LOCAL AddSmallOffset(PTOKEN ptoken, BOOL fActionFL);
int LOCAL StartDependentFn(PTOKEN ptoken, BOOL fActionFL);
int LOCAL IRQDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL DMADesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL IODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL FixedIODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL VendorDesc(PTOKEN ptoken, DWORD dwMaxSize);
int LOCAL VendorShort(PTOKEN ptoken, BOOL fActionFL);
int LOCAL InsertDescLength(PCODEOBJ pcode, DWORD dwDescLen);
int LOCAL Memory24Desc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL VendorLong(PTOKEN ptoken, BOOL fActionFL);
int LOCAL Memory32Desc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL FixedMemory32Desc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL MemSpaceDesc(PTOKEN ptoken, DWORD dwMinLen, PRESFIELD ResFields);
int LOCAL IOSpaceDesc(PTOKEN ptoken, DWORD dwMinLen, PRESFIELD ResFields);
int LOCAL DWordMemDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL DWordIODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL WordIODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL WordBusNumDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL InterruptDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL QWordMemDesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL QWordIODesc(PTOKEN ptoken, BOOL fActionFL);
int LOCAL CreateResFields(PTOKEN ptoken, PNSOBJ pnsParent, PRESFIELD prf);

// misc.c
BOOL LOCAL ValidASLNameSeg(PTOKEN ptoken, PSZ pszToken, int icbLen);
BOOL LOCAL ValidASLName(PTOKEN ptoken, PSZ pszToken);
int LOCAL EncodeName(PSZ pszName, PBYTE pbBuff, PDWORD pdwLen);
int LOCAL EncodePktLen(DWORD dwCodeLen, PDWORD pdwPktLen, PINT picbEncoding);
VOID LOCAL EncodeKeywords(PCODEOBJ pArgs, DWORD dwSrcArgs, int iDstArgNum);
int LOCAL DecodeName(PBYTE pb, PSZ pszName, int iLen);
int LOCAL SetDefMissingKW(PCODEOBJ pArg, DWORD dwDefID);
VOID LOCAL SetIntObject(PCODEOBJ pc, DWORD dwData, DWORD dwLen);
VOID LOCAL ComputeChildChkSumLen(PCODEOBJ pcParent, PCODEOBJ pcChild);
VOID LOCAL ComputeArgsChkSumLen(PCODEOBJ pcode);
VOID LOCAL ComputeChkSumLen(PCODEOBJ pcode);
int LOCAL ComputeEISAID(PSZ pszID, PDWORD pdwEISAID);
int LOCAL LookupIDIndex(LONG lID, PDWORD pdwTermIndex);
int LOCAL WriteAMLFile(int fhAML, PCODEOBJ pcode, PDWORD pdwOffset);
VOID LOCAL FreeCodeObjs(PCODEOBJ pcodeRoot);

#ifdef __UNASM
// tables.c
BOOL LOCAL IsWinNT(VOID);
#ifndef WINNT
HANDLE LOCAL OpenVxD(VOID);
VOID LOCAL CloseVxD(HANDLE hVxD);
PBYTE LOCAL VxDGetTableBySig(DWORD dwTabSig, PDWORD pdwTableAddr);
PBYTE LOCAL VxDGetTableByAddr(DWORD dwTableAddr, PDWORD pdwTableSig);
#endif
PBYTE LOCAL GetNTTable(DWORD dwTabSig);
PBYTE LOCAL GetTableBySig(DWORD dwTabSig, PDWORD pdwTableAddr);
PBYTE LOCAL GetTableByAddr(DWORD dwTableAddr, PDWORD pdwTableSig);
int LOCAL DumpAllTables(FILE *pfileOut);
int LOCAL DumpTableBySig(FILE *pfileOut, DWORD dwTableSig);
int LOCAL DumpTableByAddr(FILE *pfileOut, DWORD dwTableAddr);
int LOCAL DumpRSDP(FILE *pfileOut, PBYTE pb, DWORD dwAddr);
int LOCAL DumpTable(FILE *pfileOut, PBYTE pb, DWORD dwTableAddr,
                    DWORD dwTableSig);
int LOCAL DumpTableTxt(FILE *pfileOut, PBYTE pb, DWORD dwTableAddr,
                       DWORD dwTableSig);
int LOCAL DumpTableBin(DWORD dwTableSig, DWORD dwAddr, PBYTE pb, DWORD dwLen);
int LOCAL FindTableFmt(DWORD dwTableSig, PFMT *ppfmt, PDWORD pdwFlags);
PSZ LOCAL GetTableSigStr(DWORD dwTableSig);
BOOL LOCAL ValidateTable(PBYTE pbTable, DWORD dwLen);
BOOL LOCAL IsALikelySig(DWORD dwTableSig);
#endif

#endif  //ifndef _PROTO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\tables.c ===
/*** tables.c - Dump various ACPI tables
 *
 *  This module provides the functions to dump various ACPI tables.
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     04/08/99
 *
 *  MODIFICATION HISTORY
 */

#ifdef __UNASM

#pragma warning (disable: 4201 4214 4514)

typedef unsigned __int64 ULONGLONG;
#define LOCAL   __cdecl
#define EXPORT  __cdecl
#include <stdarg.h>
//#define _X86_
#include <windef.h>
#include <winbase.h>
#include <winreg.h>
#define ULONG_PTR ULONG
#define EXCL_BASEDEF
#include "pch.h"
#include "fmtdata.h"

#define BYTEOF(d,i)	(((BYTE *)&(d))[i])

/***LP  IsWinNT - check if OS is NT
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns TRUE - OS is NT
 *  EXIT-FAILURE
 *      returns FALSE - OS is not NT
 */

BOOL LOCAL IsWinNT(VOID)
{
    BOOL rc = FALSE;
    OSVERSIONINFO osinfo;

    ENTER((2, "IsWinNT()\n"));

    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osinfo) && (osinfo.dwPlatformId == VER_PLATFORM_WIN32_NT))
    {
        rc = TRUE;
    }

    EXIT((2, "IsWinNT=%x\n", rc));
    return rc;
}       //IsWinNT

#ifndef WINNT
/***LP  OpenVxD - Open ACPITAB.VXD
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns VxD handle
 *  EXIT-FAILURE
 *      returns NULL
 */

HANDLE LOCAL OpenVxD(VOID)
{
    HANDLE hVxD;
    DWORD dwVersion;

    ENTER((2, "OpenVxD()\n"));

    if ((hVxD = CreateFile(ACPITAB_VXD_NAME, 0, 0, NULL, 0,
                           FILE_FLAG_DELETE_ON_CLOSE, NULL)) ==
        INVALID_HANDLE_VALUE)
    {
	ERROR(("OpenVxD: failed to open VxD %s (rc=%x)",
	       ACPITAB_VXD_NAME, GetLastError()));
        hVxD = NULL;
    }
    else if (!DeviceIoControl(hVxD, ACPITAB_DIOC_GETVERSION, NULL, 0,
                              &dwVersion, sizeof(dwVersion), NULL, NULL))
    {
        ERROR(("OpenVxD: failed to get VxD version. (rc=%x)", GetLastError()));
        CloseVxD(hVxD);
        hVxD = NULL;
    }
    else if (dwVersion != ((ACPITAB_MAJOR_VER << 8) | ACPITAB_MINOR_VER))
    {
        ERROR(("OpenVxD: version error (Ver=%x)", dwVersion));
        CloseVxD(hVxD);
        hVxD = NULL;
    }

    EXIT((2, "OpenVxD=%x\n", hVxD));
    return hVxD;
}       //OpenVxD

/***LP  CloseVxD - Close the VxD
 *
 *  ENTRY
 *      hVxD - VxD handle
 *
 *  EXIT
 *      None
 */

VOID LOCAL CloseVxD(HANDLE hVxD)
{
    ENTER((2, "CloseVxD(hVxD=%x)\n", hVxD));

    CloseHandle(hVxD);

    EXIT((2, "CloseVxD!\n"));
}       //CloseVxD

/***LP  VxDGetTableBySig - Get table by its signature
 *
 *  ENTRY
 *      dwTabSig - table signature
 *      pdwTableAddr -> to hold physical address of table (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL VxDGetTableBySig(DWORD dwTabSig, PDWORD pdwTableAddr)
{
    PBYTE pb = NULL;
    TABINFO TabInfo;

    ENTER((2, "VxDGetTableBySig(TabSig=%x,pdwAddr=%p)\n",
           dwTabSig, pdwTableAddr));

    TabInfo.dwTabSig = dwTabSig;
    if (DeviceIoControl(ghVxD, ACPITAB_DIOC_GETTABINFO, NULL, 0, &TabInfo,
                        sizeof(TabInfo), NULL, NULL))
    {
        if (dwTabSig == SIG_RSDP)
        {
            //
            // We are getting RSD PTR
            //
            if ((pb = MEMALLOC(sizeof(RSDP))) != NULL)
            {
                memcpy(pb, &TabInfo.rsdp, sizeof(RSDP));
                if (pdwTableAddr != NULL)
                {
                    *pdwTableAddr = TabInfo.dwPhyAddr;
                }
            }
            else
            {
                ERROR(("VxDGetTableBySig: failed to allocate RSDP buffer"));
            }
        }
        else if (dwTabSig == FACS_SIGNATURE)
        {
            if ((pb = MEMALLOC(sizeof(FACS))) != NULL)
            {
                memcpy(pb, &TabInfo.facs, sizeof(FACS));
                if (pdwTableAddr != NULL)
                {
                    *pdwTableAddr = TabInfo.dwPhyAddr;
                }
            }
            else
            {
                ERROR(("VxDGetTableBySig: failed to allocate FACS buffer"));
            }
        }
        else if ((pb = MEMALLOC(TabInfo.dh.Length)) != NULL)
        {
            if (DeviceIoControl(ghVxD, ACPITAB_DIOC_GETTABLE,
                                (PVOID)TabInfo.dwPhyAddr, 0, pb,
                                TabInfo.dh.Length, NULL, NULL) == 0)
            {
                ERROR(("VxDGetTableBySig: failed to get table %s. (rc=%x)",
                       GetTableSigStr(dwTabSig), GetLastError()));
                MEMFREE(pb);
                pb = NULL;
            }
	    else
	    {
		if (pdwTableAddr != NULL)
		{
                    *pdwTableAddr = TabInfo.dwPhyAddr;
		}

		ValidateTable(pb, TabInfo.dh.Length);
	    }
        }
        else
        {
            ERROR(("VxDGetTableBySig: failed to allocate table buffer (len=%d)",
                   TabInfo.dh.Length));
        }
    }
    else
    {
        ERROR(("VxDGetTableBySig: failed to get table info %s. (rc=%x)",
               GetTableSigStr(dwTabSig), GetLastError()));
    }

    EXIT((2, "VxDGetTableBySig=%x\n", pb));
    return pb;
}       //VxDGetTableBySig

/***LP  VxDGetTableByAddr - Get table by its physical address
 *
 *  ENTRY
 *      dwTableAddr - physical address of table
 *      pdwTableSig -> to hold signature of table (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL VxDGetTableByAddr(DWORD dwTableAddr, PDWORD pdwTableSig)
{
    PBYTE pb = NULL;
    DESCRIPTION_HEADER dh;

    ENTER((2, "VxDGetTableByAddr(TabAddr=%x,pdwSig=%p)\n",
           dwTableAddr, pdwTableSig));

    if (DeviceIoControl(ghVxD, ACPITAB_DIOC_GETTABLE, (PVOID)dwTableAddr, 0,
                        &dh, sizeof(dh), NULL, NULL))
    {
        DWORD dwLen = (dh.Signature == SIG_LOW_RSDP)? sizeof(RSDP): dh.Length;

        if ((pb = MEMALLOC(dwLen)) != NULL)
        {
            if (DeviceIoControl(ghVxD, ACPITAB_DIOC_GETTABLE,
                                (PVOID)dwTableAddr, 0, pb, dwLen, NULL, NULL)
                == 0)
            {
                ERROR(("VxDGetTableByAddr: failed to get table %s at %x. (rc=%x)",
                       GetTableSigStr(dh.Signature), dwTableAddr,
		       GetLastError()));
                MEMFREE(pb);
                pb = NULL;
            }
            else if (pdwTableSig != NULL)
            {
		if (pdwTableSig != NULL)
		{
                    *pdwTableSig = (dh.Signature == SIG_LOW_RSDP)?
                                    SIG_RSDP: dh.Signature;
		}

		ValidateTable(pb, dwLen);
            }
        }
        else
        {
            ERROR(("VxDGetTableByAddr: failed to allocate table buffer (len=%d)",
                   dh.Length));
        }
    }
    else
    {
        ERROR(("VxDGetTableByAddr: failed to get table %s header (rc=%x)",
               GetTableSigStr(dh.Signature), GetLastError()));
    }

    EXIT((2, "VxDGetTableByAddr=%x\n", pb));
    return pb;
}       //VxDGetTableByAddr
#endif  //ifndef WINNT

/***LP  EnumSubKey - enumerate subkey
 *
 *  ENTRY
 *      hkey - key to enumerate
 *      dwIndex - subkey index
 *
 *  EXIT-SUCCESS
 *      returns subkey
 *  EXIT-FAILURE
 *      returns NULL
 */

HKEY LOCAL EnumSubKey(HKEY hkey, DWORD dwIndex)
{
    HKEY hkeySub = NULL;
    char szSubKey[32];
    DWORD dwSubKeySize = sizeof(szSubKey);

    ENTER((2, "EnumSubKey(hkey=%x,Index=%d)\n", hkey, dwIndex));

    if ((RegEnumKeyEx(hkey, dwIndex, szSubKey, &dwSubKeySize, NULL, NULL, NULL,
                      NULL) == ERROR_SUCCESS) &&
        (RegOpenKeyEx(hkey, szSubKey, 0, KEY_READ, &hkeySub) != ERROR_SUCCESS))
    {
        hkeySub = NULL;
    }

    EXIT((2, "EnumSubKey=%x\n", hkeySub));
    return hkeySub;
}       //EnumSubKey

/***LP  OpenNTTable - Open ACPI table in NT registry
 *
 *  ENTRY
 *      dwTabSig - table signature
 *
 *  EXIT-SUCCESS
 *      returns table registry handle
 *  EXIT-FAILURE
 *      returns NULL
 */

HKEY LOCAL OpenNTTable(DWORD dwTabSig)
{
    HKEY hkeyTab = NULL, hkey1 = NULL, hkey2 = NULL;
    static char szTabKey[] = "Hardware\\ACPI\\xxxx";

    ENTER((2, "OpenNTTable(TabSig=%s)\n", GetTableSigStr(dwTabSig)));

    if (dwTabSig == FADT_SIGNATURE)
    {
        memcpy(&szTabKey[strlen(szTabKey) - 4], "FADT", sizeof(ULONG));
    }
    else
    {
        memcpy(&szTabKey[strlen(szTabKey) - 4], &dwTabSig, sizeof(ULONG));
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTabKey, 0, KEY_READ, &hkey1) ==
        ERROR_SUCCESS)
    {
        //
        // hkey1 is now "Hardware\ACPI\<TabSig>"
        //
        if ((hkey2 = EnumSubKey(hkey1, 0)) != NULL)
        {
            //
            // hkey2 is now "Hardware\ACPI\<TabSig>\<OEMID>"
            //
            RegCloseKey(hkey1);
            if ((hkey1 = EnumSubKey(hkey2, 0)) != NULL)
            {
                //
                // hkey1 is now "Hardware\ACPI\<TabSig>\<OEMID>\<OEMTabID>"
                //
                RegCloseKey(hkey2);
                if ((hkey2 = EnumSubKey(hkey1, 0)) != NULL)
                {
                    //
                    // hkey2 is now
                    // "Hardware\ACPI\<TabSig>\<OEMID>\<OEMTabID>\<OEMRev>"
                    //
                    hkeyTab = hkey2;
                }
            }
        }
    }

    if (hkey1 != NULL)
    {
        RegCloseKey(hkey1);
    }

    if ((hkey2 != NULL) && (hkeyTab != hkey2))
    {
        RegCloseKey(hkey2);
    }

    EXIT((2, "OpenNTTable=%x\n", hkeyTab));
    return hkeyTab;
}       //OpenNTTable

/***LP  GetNTTable - Get ACPI table from NT registry
 *
 *  ENTRY
 *      dwTabSig - table signature
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL GetNTTable(DWORD dwTabSig)
{
    PBYTE pb = NULL;
    HKEY hkeyTab;

    ENTER((2, "GetNTTable(TabSig=%s)\n", GetTableSigStr(dwTabSig)));

    if ((hkeyTab = OpenNTTable(dwTabSig)) != NULL)
    {
        DWORD dwLen = 0;
        PSZ pszTabKey = "00000000";

        if (RegQueryValueEx(hkeyTab, pszTabKey, NULL, NULL, NULL, &dwLen) ==
            ERROR_SUCCESS)
        {
            if ((pb = MEMALLOC(dwLen)) != NULL)
            {
                if (RegQueryValueEx(hkeyTab, pszTabKey, NULL, NULL, pb, &dwLen)
                    != ERROR_SUCCESS)
                {
                    ERROR(("GetNTTable: failed to read table"));
                }
            }
            else
            {
                ERROR(("GetNTTable: failed to allocate table buffer"));
            }
        }
        else
        {
            ERROR(("GetNTTable: failed to read table key"));
        }
        RegCloseKey(hkeyTab);
    }
    else
    {
        ERROR(("GetNTTable: failed to get table %s", GetTableSigStr(dwTabSig)));
    }

    EXIT((2, "GetNTTable=%x\n", pb));
    return pb;
}       //GetNTTable

/***LP  GetTableBySig - Get table by its signature
 *
 *  ENTRY
 *      dwTabSig - table signature
 *      pdwTableAddr -> to hold physical address of table (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL GetTableBySig(DWORD dwTabSig, PDWORD pdwTableAddr)
{
    PBYTE pb = NULL;

    ENTER((2, "GetTableBySig(TabSig=%x,pdwAddr=%p)\n", dwTabSig, pdwTableAddr));

    if (gdwfASL & ASLF_NT)
    {
        if (((pb = GetNTTable(dwTabSig)) != NULL) && (pdwTableAddr != NULL))
        {
            *pdwTableAddr = 0;
        }
    }
  #ifndef WINNT
    else
    {
        pb = VxDGetTableBySig(dwTabSig, pdwTableAddr);
    }
  #endif

    EXIT((2, "GetTableBySig=%x\n", pb));
    return pb;
}       //GetTableBySig

/***LP  GetTableByAddr - Get table by its physical address
 *
 *  ENTRY
 *      dwTableAddr - physical address of table
 *      pdwTableSig -> to hold signature of table (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL GetTableByAddr(DWORD dwTableAddr, PDWORD pdwTableSig)
{
    PBYTE pb = NULL;

    ENTER((2, "GetTableByAddr(TabAddr=%x,pdwSig=%p)\n",
           dwTableAddr, pdwTableSig));

    if (gdwfASL & ASLF_NT)
    {
        ERROR(("GetTableByAddr: not supported by NT"));
    }
  #ifndef WINNT
    else
    {
        pb = VxDGetTableByAddr(dwTableAddr, pdwTableSig);
    }
  #endif

    EXIT((2, "GetTableByAddr=%x\n", pb));
    return pb;
}       //GetTableByAddr

/***LP  DumpAllTables - Dump all ACPI tables
 *
 *  ENTRY
 *	pfileOut -> output file
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpAllTables(FILE *pfileOut)
{
    int rc = ASLERR_NONE;
    PBYTE pb;
    DWORD dwAddr;

    ENTER((1, "DumpAllTables(pfileOut=%p)\n", pfileOut));

    if (gdwfASL & ASLF_NT)
    {
        DumpTableBySig(pfileOut, RSDT_SIGNATURE);
        DumpTableBySig(pfileOut, FADT_SIGNATURE);
        DumpTableBySig(pfileOut, FACS_SIGNATURE);
        DumpTableBySig(pfileOut, SBST_SIGNATURE);
        DumpTableBySig(pfileOut, APIC_SIGNATURE);
        DumpTableBySig(pfileOut, SIG_BOOT);
	DumpTableBySig(pfileOut, SIG_DBGP);
        DumpTableBySig(pfileOut, DSDT_SIGNATURE);
        DumpTableBySig(pfileOut, SSDT_SIGNATURE);
        DumpTableBySig(pfileOut, PSDT_SIGNATURE);
    }
    else if ((pb = GetTableBySig(SIG_RSDP, &dwAddr)) != NULL)
    {
        if ((rc = DumpRSDP(pfileOut, pb, dwAddr)) == ASLERR_NONE)
        {
            DWORD dwRSDTAddr = ((PRSDP)pb)->RsdtAddress;
            DWORD dwTableSig;

            MEMFREE(pb);
            if ((pb = GetTableByAddr(dwRSDTAddr, &dwTableSig)) != NULL)
            {
                if ((rc = DumpTable(pfileOut, pb, dwRSDTAddr, dwTableSig)) ==
                    ASLERR_NONE)
                {
                    PRSDT pRSDT = (PRSDT)pb;
                    DWORD i, dwcEntries;

                    dwcEntries = (pRSDT->Header.Length -
                                  sizeof(DESCRIPTION_HEADER))/sizeof(ULONG);

                    for (i = 0; i < dwcEntries; ++i)
                    {
                        if ((rc = DumpTableByAddr(pfileOut, pRSDT->Tables[i]))
                            != ASLERR_NONE)
                        {
                            break;
                        }
                    }
                }

                if ((rc == ASLERR_NONE) &&
                    ((rc = DumpTableBySig(pfileOut, FACS_SIGNATURE)) ==
                     ASLERR_NONE))
                {
                    rc = DumpTableBySig(pfileOut, DSDT_SIGNATURE);
                }
            }
            else
            {
                rc = ASLERR_GET_TABLE;
            }
        }

        if (pb != NULL)
        {
            MEMFREE(pb);
        }
    }
    else
    {
	rc = ASLERR_GET_TABLE;
    }

    EXIT((1, "DumpAllTables=%d\n", rc));
    return rc;
}	//DumpAllTables

/***LP  DumpTableBySig - Dump an ACPI table by its Table Signature
 *
 *  ENTRY
 *	pfileOut -> output file
 *      dwTableSig - table signature
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpTableBySig(FILE *pfileOut, DWORD dwTableSig)
{
    int rc = ASLERR_NONE;
    PBYTE pb;
    DWORD dwTableAddr;

    ENTER((1, "DumpTableBySig(pfileOut=%p,TableSig=%s)\n",
           pfileOut, GetTableSigStr(dwTableSig)));

    if (((PSZ)&dwTableSig)[0] == '*')
    {
        rc = DumpAllTables(pfileOut);
    }
    else if ((pb = GetTableBySig(dwTableSig, &dwTableAddr)) != NULL)
    {
        rc = DumpTable(pfileOut, pb, dwTableAddr, dwTableSig);
        MEMFREE(pb);
    }
    else
    {
        rc = ASLERR_GET_TABLE;
    }

    EXIT((1, "DumpTableBySig=%d\n", rc));
    return rc;
}       //DumpTableBySig

/***LP  DumpTableByAddr - Dump an ACPI table by its address
 *
 *  ENTRY
 *	pfileOut -> output file
 *      dwTableAddr - physical address of the table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpTableByAddr(FILE *pfileOut, DWORD dwTableAddr)
{
    int rc = ASLERR_NONE;
    PBYTE pb;
    DWORD dwTableSig;

    ENTER((1, "DumpTableByAddr(pfileOut=%p,TableAddr=%x)\n",
           pfileOut, dwTableAddr));

    if ((pb = GetTableByAddr(dwTableAddr, &dwTableSig)) != NULL)
    {
        rc = DumpTable(pfileOut, pb, dwTableAddr, dwTableSig);
        MEMFREE(pb);
    }
    else
    {
        rc = ASLERR_GET_TABLE;
    }

    EXIT((1, "DumpTableByAddr=%d\n", rc));
    return rc;
}       //DumpTableByAddr

/***LP  DumpRSDP - Dump the RSD PTR table
 *
 *  ENTRY
 *	pfileOut -> output file
 *      pb -> RSDP structure
 *      dwAddr - physical address of RSDP
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpRSDP(FILE *pfileOut, PBYTE pb, DWORD dwAddr)
{
    int rc = ASLERR_NONE;

    ENTER((1, "DumpRSDP(pfileOut=%p,Addr=%x,pRSDP=%p)\n",
           pfileOut, dwAddr, pb));

    if (pfileOut != NULL)
    {
        DWORD dwOffset = 0;

        fprintf(pfileOut, szSectFmt, dwAddr, "RSD PTR");
        if (BinFPrintf(pfileOut, NULL, afmtRSDPTR, pb, &dwOffset, szOffsetFmt)
            != FERR_NONE)
        {
            ERROR(("DumpRSDP: failed to dump RSD PTR structure"));
            rc = ASLERR_INTERNAL_ERROR;
        }
    }
    else
    {
        rc = DumpTableBin(SIG_RSDP, dwAddr, pb, sizeof(RSDP));
    }

    EXIT((1, "DumpRSDP=%d\n", rc));
    return rc;
}       //DumpRSDP

/***LP  DumpTable - Dump an ACPI table
 *
 *  ENTRY
 *	pfileOut -> output file
 *      pb -> ACPI table
 *      dwTableAddr - physical address of table
 *      dwTableSig - signature of table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpTable(FILE *pfileOut, PBYTE pb, DWORD dwTableAddr,
                    DWORD dwTableSig)
{
    int rc = ASLERR_NONE;

    ENTER((1, "DumpTable(pfileOut=%p,pb=%p,TableAddr=%x,TableSig=%s)\n",
           pfileOut, pb, dwTableAddr, GetTableSigStr(dwTableSig)));

    if (dwTableSig == SIG_RSDP)
    {
        rc = DumpRSDP(pfileOut, pb, dwTableAddr);
    }
    else if (pfileOut != NULL)
    {
        rc = DumpTableTxt(pfileOut, pb, dwTableAddr, dwTableSig);
    }
    else
    {
        rc = DumpTableBin(dwTableSig, dwTableAddr, pb,
                          (dwTableSig == FACS_SIGNATURE)?
                            sizeof(FACS):
                            ((PDESCRIPTION_HEADER)pb)->Length);
    }

    EXIT((1, "DumpTable=%d\n", rc));
    return rc;
}       //DumpTable

/***LP  DumpTableTxt - Dump an ACPI table to a text file
 *
 *  ENTRY
 *	pfileOut -> output file
 *      pb -> ACPI table
 *      dwTableAddr - physical address of table
 *      dwTableSig - signature of table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpTableTxt(FILE *pfileOut, PBYTE pb, DWORD dwTableAddr,
                       DWORD dwTableSig)
{
    int rc = ASLERR_NONE;
    PFMT pfmt;
    DWORD dwFlags;

    ENTER((1, "DumpTableTxt(pfileOut=%p,pb=%p,TableAddr=%x,TableSig=%s)\n",
           pfileOut, pb, dwTableAddr, GetTableSigStr(dwTableSig)));

    if ((rc = FindTableFmt(dwTableSig, &pfmt, &dwFlags)) ==
        ASLERR_SIG_NOT_FOUND)
    {
        rc = ASLERR_NONE;
    }

    if (rc == ASLERR_NONE)
    {
        DWORD dwOffset = 0;

        fprintf(pfileOut, szSectFmt, dwTableAddr, GetTableSigStr(dwTableSig));
        if (!(dwFlags & TF_NOHDR) &&
            (BinFPrintf(pfileOut, NULL, afmtTableHdr, pb, &dwOffset,
                        szOffsetFmt) != FERR_NONE))
        {
            ERROR(("DumpTableTxt: failed to dump %s structure header",
                   GetTableSigStr(dwTableSig)));
            rc = ASLERR_INTERNAL_ERROR;
        }
        else if (pfmt != NULL)
        {
            if (BinFPrintf(pfileOut, NULL, pfmt, pb, &dwOffset, szOffsetFmt) !=
                FERR_NONE)
            {
                ERROR(("DumpTableTxt: failed to dump %s structure",
                       GetTableSigStr(dwTableSig)));
                rc = ASLERR_INTERNAL_ERROR;
            }
            else if ((dwTableSig == FADT_SIGNATURE) &&
                     (((PDESCRIPTION_HEADER)pb)->Revision > 1))
            {
                /*
                pfmt = (((PGRAS)pb)->id == REGSPACE_PCICFG)? afmtGRASPCICS:
                                                             afmtGRASRegAddr;*/
                fprintf(pfileOut, "; Reset Register\n");
                if ((BinFPrintf(pfileOut, NULL, afmtGRASCommon, pb, &dwOffset,
                                szOffsetFmt) != FERR_NONE) ||
                    (BinFPrintf(pfileOut, NULL, pfmt, pb, &dwOffset,
                                szOffsetFmt) != FERR_NONE) ||
                    (BinFPrintf(pfileOut, NULL, afmtFACP2, pb, &dwOffset,
                                szOffsetFmt) != FERR_NONE))
                {
                    ERROR(("DumpTableTxt: failed to dump extended %s structure",
                           GetTableSigStr(dwTableSig)));
                    rc = ASLERR_INTERNAL_ERROR;
                }
            }
            else if (dwTableSig == SIG_DBGP)
            {

                /*
                pfmt = (((PGRAS)pb)->id == REGSPACE_PCICFG)? afmtGRASPCICS:
                                                             afmtGRASRegAddr;*/

                fprintf(pfileOut, "; Debug Port Base Address\n");
                if ((BinFPrintf(pfileOut, NULL, afmtGRASCommon, pb, &dwOffset,
                                szOffsetFmt) != FERR_NONE) ||
                    (BinFPrintf(pfileOut, NULL, pfmt, pb, &dwOffset,
                                szOffsetFmt) != FERR_NONE))
                {
                    ERROR(("DumpTableTxt: failed to dump extended %s structure",
                           GetTableSigStr(dwTableSig)));
                    rc = ASLERR_INTERNAL_ERROR;
                }
            }
        }
        else
        {
            #define NUM_COLS    16
            PRSDT pRSDT;
            DWORD i, dwcEntries;
            PBYTE pbEnd;
            char szAMLName[_MAX_FNAME];
            char szBytes[NUM_COLS + 1];

            switch (dwTableSig)
            {
                case RSDT_SIGNATURE:
                    pRSDT = (PRSDT)pb;
                    dwcEntries = (pRSDT->Header.Length -
                                  sizeof(DESCRIPTION_HEADER))/sizeof(ULONG);
                    for (i = 0; i < dwcEntries; ++i)
                    {
                        fprintf(pfileOut, szOffsetFmt, dwOffset);
                        fprintf(pfileOut, "[%02d] %08lx\n",
                                i, pRSDT->Tables[i]);
                        dwOffset += sizeof(ULONG);
                    }
                    break;

                case DSDT_SIGNATURE:
                case SSDT_SIGNATURE:
                case PSDT_SIGNATURE:
                    strncpy(szAMLName, (PSZ)&dwTableSig, sizeof(DWORD));
                    strcpy(&szAMLName[sizeof(DWORD)], ".AML");
                    rc = UnAsmAML(szAMLName, dwTableAddr, pb,
                                  (PFNPRINT)fprintf, pfileOut);
                    break;

                default:
                    //
                    // Don't return error because we want to continue.
                    //
                    WARN(("DumpTableTxt: unexpected table signature %s",
                          GetTableSigStr(dwTableSig)));

                    pbEnd = pb + ((PDESCRIPTION_HEADER)pb)->Length;
                    pb += sizeof(DESCRIPTION_HEADER);
                    i = 0;
                    while (pb < pbEnd)
                    {
                        szBytes[i] = (char)(isprint(*pb)? *pb: '.');
                        if (i == 0)
                        {
                            fprintf(pfileOut, szOffsetFmt, dwOffset);
                            fprintf(pfileOut, "%02x", *pb);
                        }
                        else if (i == NUM_COLS/2)
                        {
                            fprintf(pfileOut, "-%02x", *pb);
                        }
                        else
                        {
                            fprintf(pfileOut, ",%02x", *pb);
                        }
                        i++;
                        if (i == NUM_COLS)
                        {
                            szBytes[i] = '\0';
                            fprintf(pfileOut, "  ;%s\n", szBytes);
                            i = 0;
                        }
                        dwOffset += sizeof(BYTE);
                        pb += sizeof(BYTE);
                    }

                    if (i < NUM_COLS)
                    {
                        szBytes[i] = '\0';
                        while (i < NUM_COLS)
                        {
                            fprintf(pfileOut, "   ");
                            i++;
                        }
                        fprintf(pfileOut, "  ;%s\n", szBytes);
                    }
            }
        }
    }

    EXIT((1, "DumpTableTxt=%d\n", rc));
    return rc;
}       //DumpTableTxt

/***LP  DumpTableBin - Dump an ACPI table to a binary file
 *
 *  ENTRY
 *      dwTableSig - table signature
 *      dwAddr - physical address of table
 *      pb -> ACPI table
 *      dwLen - length of table
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL DumpTableBin(DWORD dwTableSig, DWORD dwAddr, PBYTE pb, DWORD dwLen)
{
    int rc = ASLERR_NONE;
    char szBinFile[_MAX_FNAME];
    FILE *pfile;

    ENTER((1, "DumpTableBin(TableSig=%s,Addr=%x,pb=%p,Len=%d)\n",
           GetTableSigStr(dwTableSig), dwAddr, pb, dwLen));

    strncpy(szBinFile, (PSZ)&dwTableSig, sizeof(DWORD));
    sprintf(&szBinFile[sizeof(DWORD)], "%04x", (WORD)dwAddr);
    strcpy(&szBinFile[sizeof(DWORD) + 4], ".BIN");
    if ((pfile = fopen(szBinFile, "wb")) == NULL)
    {
        ERROR(("DumpTableBin: failed to create file %s", szBinFile));
        rc = ASLERR_CREATE_FILE;
    }
    else
    {
        if (fwrite(pb, dwLen, 1, pfile) != 1)
        {
            ERROR(("DumpTableBin: failed to write to file %s", szBinFile));
            rc = ASLERR_WRITE_FILE;
        }
        fclose(pfile);
    }

    EXIT((1, "DumpTableBin=%d\n", rc));
    return rc;
}       //DumpTableBin

/***LP  FindTableFmt - Find the appropriate table format structure
 *
 *  ENTRY
 *      dwTableSig - table signature
 *      ppfmt -> to hold pfmt found
 *      pdwFlags -> to hold table flags
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL FindTableFmt(DWORD dwTableSig, PFMT *ppfmt, PDWORD pdwFlags)
{
    int rc = ASLERR_NONE;
    int i;

    ENTER((1, "FindTableFmt(TableSig=%s,ppfmt=%p,pdwFlags=%p)\n",
           GetTableSigStr(dwTableSig), ppfmt, pdwFlags));

    for (i = 0; FmtTable[i].dwTableSig != 0; ++i)
    {
        if (dwTableSig == FmtTable[i].dwTableSig)
        {
            *ppfmt = FmtTable[i].pfmt;
            *pdwFlags = FmtTable[i].dwFlags;
            break;
        }
    }

    if (FmtTable[i].dwTableSig == 0)
    {
        *ppfmt = NULL;
        *pdwFlags = 0;
        rc = ASLERR_SIG_NOT_FOUND;
    }

    EXIT((1, "FindTableFmt=%d (pfmt=%p,Flags=%x)\n", rc, *ppfmt, *pdwFlags));
    return rc;
}       //FindTableFmt

/***LP  GetTableSigStr - Get table signature string
 *
 *  ENTRY
 *      dwTableSig - table signature
 *
 *  EXIT
 *      returns the table signature string
 */

PSZ LOCAL GetTableSigStr(DWORD dwTableSig)
{
    static char szTableSig[5] = {0};

    ENTER((2, "GetTableSigStr(TableSig=%08x)\n", dwTableSig));

    strncpy(szTableSig, (PSZ)&dwTableSig, sizeof(DWORD));

    EXIT((2, "GetTableSigStr=%s\n", szTableSig));
    return szTableSig;
}       //GetTableSigStr

/***LP	ValidateTable - Validate the given table
 *
 *  ENTRY
 *	pbTable -> Table
 *	dwLen - Table length
 *
 *  EXIT-SUCCESS
 *	returns TRUE
 *  EXIT-FAILURE
 *	returns FALSE
 */

BOOL LOCAL ValidateTable(PBYTE pbTable, DWORD dwLen)
{
    BOOL rc = TRUE;
    DWORD dwTableSig, dwTableLen = 0;
    BOOL fNeedChkSum = FALSE;

    ENTER((2, "ValidateTable(pbTable=%x,Len=%d)\n", pbTable, dwLen));

    dwTableSig = ((PDESCRIPTION_HEADER)pbTable)->Signature;
    switch (dwTableSig)
    {
	case SIG_LOW_RSDP:
	    dwTableLen = sizeof(RSDP);
	    fNeedChkSum = TRUE;
	    break;

	case RSDT_SIGNATURE:
	case FADT_SIGNATURE:
	case DSDT_SIGNATURE:
	case SSDT_SIGNATURE:
	case PSDT_SIGNATURE:
	case APIC_SIGNATURE:
	case SBST_SIGNATURE:
	case SIG_BOOT:
	case SIG_DBGP:
	    dwTableLen = ((PDESCRIPTION_HEADER)pbTable)->Length;
	    fNeedChkSum = TRUE;
	    break;

	case FACS_SIGNATURE:
	    dwTableLen = ((PFACS)pbTable)->Length;
	    break;

	default:
	    if (IsALikelySig(dwTableSig) &&
	        (((PDESCRIPTION_HEADER)pbTable)->Length < 256))
	    {
		dwTableLen = ((PDESCRIPTION_HEADER)pbTable)->Length;
		fNeedChkSum = TRUE;
	    }
	    else
	    {
		WARN(("ValidateTable: invalid table signature %s",
                      GetTableSigStr(dwTableSig)));
		rc = FALSE;
	    }
    }

    if (dwTableLen > dwLen)
    {
        WARN(("ValidateTable: invalid length %d in table %s",
              dwTableLen, GetTableSigStr(dwTableSig)));
	rc = FALSE;
    }

    if ((rc == TRUE) && fNeedChkSum &&
        (ComputeDataChkSum(pbTable, dwTableLen) != 0))
    {
        WARN(("ValidateTable: invalid checksum in table %s",
              GetTableSigStr(dwTableSig)));
	rc = FALSE;
    }

    EXIT((2, "ValidateTable=%x\n", rc));
    return rc;
}	//ValidateTable

/***LP	IsALikelySig - Check if a table signature is possibly valid
 *
 *  ENTRY
 *	dwTableSig - table signature
 *
 *  EXIT-SUCCESS
 *	returns TRUE
 *  EXIT-FAILURE
 *	returns FALSE
 */

BOOL LOCAL IsALikelySig(DWORD dwTableSig)
{
    BOOL rc = TRUE;
    int i, ch;

    ENTER((2, "IsALikelySig(dwTableSig=%x)\n", dwTableSig));

    for (i = 0; i < sizeof(DWORD); ++i)
    {
	ch = BYTEOF(dwTableSig, i);
	if ((ch < 'A') || (ch > 'Z'))
	{
	    rc = FALSE;
	    break;
        }
    }

    EXIT((2, "IsALikelySig=%x\n", rc));
    return rc;
}	//IsALikelySig

#endif  //ifdef __UNASM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\scanasl.h ===
/*** scanasl.h - Definitions for scanasl.c
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/05/96
 *
 *  This file contains the implementation constants,
 *  imported/exported data types, exported function
 *  prototypes of the scan.c module.
 *
 *  MODIFICATIONS
 */

/***    Constants
 */

// Return values of Token functions
//   return value is the token type if it is positive
//   return value is the error number if it is negative

// Error values (negative)
#define TOKERR_TOKEN_TOO_LONG   (TOKERR_LANG - 1)
#define TOKERR_UNCLOSED_STRING  (TOKERR_LANG - 2)
#define TOKERR_UNCLOSED_CHAR    (TOKERR_LANG - 3)
#define TOKERR_UNCLOSED_COMMENT (TOKERR_LANG - 4)
#define TOKERR_SYNTAX           (TOKERR_LANG - 5)

// Token types (positive)
#define TOKTYPE_ID              (TOKTYPE_LANG + 1)
#define TOKTYPE_STRING          (TOKTYPE_LANG + 2)
#define TOKTYPE_CHAR            (TOKTYPE_LANG + 3)
#define TOKTYPE_NUMBER          (TOKTYPE_LANG + 4)
#define TOKTYPE_SYMBOL          (TOKTYPE_LANG + 5)
#define TOKTYPE_SPACE           (TOKTYPE_LANG + 6)

#define TOKID(i)                TermTable[i].lID

// Identifier token values
#define ID_DEFBLK               (ID_LANG + 0)
#define ID_INCLUDE              (ID_LANG + 1)
#define ID_EXTERNAL             (ID_LANG + 2)

#define ID_ZERO                 (ID_LANG + 100)
#define ID_ONE                  (ID_LANG + 101)
#define ID_ONES                 (ID_LANG + 102)
#define ID_REVISION             (ID_LANG + 103)
#define ID_ARG0                 (ID_LANG + 104)
#define ID_ARG1                 (ID_LANG + 105)
#define ID_ARG2                 (ID_LANG + 106)
#define ID_ARG3                 (ID_LANG + 107)
#define ID_ARG4                 (ID_LANG + 108)
#define ID_ARG5                 (ID_LANG + 109)
#define ID_ARG6                 (ID_LANG + 110)
#define ID_LOCAL0               (ID_LANG + 111)
#define ID_LOCAL1               (ID_LANG + 112)
#define ID_LOCAL2               (ID_LANG + 113)
#define ID_LOCAL3               (ID_LANG + 114)
#define ID_LOCAL4               (ID_LANG + 115)
#define ID_LOCAL5               (ID_LANG + 116)
#define ID_LOCAL6               (ID_LANG + 117)
#define ID_LOCAL7               (ID_LANG + 118)
#define ID_DEBUG                (ID_LANG + 119)

#define ID_ALIAS                (ID_LANG + 200)
#define ID_NAME                 (ID_LANG + 201)
#define ID_SCOPE                (ID_LANG + 202)

#define ID_BUFFER               (ID_LANG + 300)
#define ID_PACKAGE              (ID_LANG + 301)
#define ID_EISAID               (ID_LANG + 302)

#define ID_ANYACC               (ID_LANG + 400)
#define ID_BYTEACC              (ID_LANG + 401)
#define ID_WORDACC              (ID_LANG + 402)
#define ID_DWORDACC             (ID_LANG + 403)
#define ID_QWORDACC             (ID_LANG + 404)
#define ID_BUFFERACC            (ID_LANG + 405)
#define ID_LOCK                 (ID_LANG + 407)
#define ID_NOLOCK               (ID_LANG + 408)
#define ID_PRESERVE             (ID_LANG + 409)
#define ID_WRONES               (ID_LANG + 410)
#define ID_WRZEROS              (ID_LANG + 411)
#define ID_SYSMEM               (ID_LANG + 412)
#define ID_SYSIO                (ID_LANG + 413)
#define ID_PCICFG               (ID_LANG + 414)
#define ID_EMBCTRL              (ID_LANG + 415)
#define ID_SMBUS                (ID_LANG + 416)
#define ID_SERIALIZED           (ID_LANG + 417)
#define ID_NOTSERIALIZED        (ID_LANG + 418)
#define ID_MTR                  (ID_LANG + 419)
#define ID_MEQ                  (ID_LANG + 420)
#define ID_MLE                  (ID_LANG + 421)
#define ID_MLT                  (ID_LANG + 422)
#define ID_MGE                  (ID_LANG + 423)
#define ID_MGT                  (ID_LANG + 424)
#define ID_EDGE                 (ID_LANG + 425)
#define ID_LEVEL                (ID_LANG + 426)
#define ID_ACTIVEHI             (ID_LANG + 427)
#define ID_ACTIVELO             (ID_LANG + 428)
#define ID_SHARED               (ID_LANG + 429)
#define ID_EXCLUSIVE            (ID_LANG + 430)
#define ID_COMPAT               (ID_LANG + 431)
#define ID_TYPEA                (ID_LANG + 432)
#define ID_TYPEB                (ID_LANG + 433)
#define ID_TYPEF                (ID_LANG + 434)
#define ID_BUSMASTER            (ID_LANG + 435)
#define ID_NOTBUSMASTER         (ID_LANG + 436)
#define ID_TRANSFER8            (ID_LANG + 437)
#define ID_TRANSFER8_16         (ID_LANG + 438)
#define ID_TRANSFER16           (ID_LANG + 439)
#define ID_DECODE16             (ID_LANG + 440)
#define ID_DECODE10             (ID_LANG + 441)
#define ID_READWRITE            (ID_LANG + 442)
#define ID_READONLY             (ID_LANG + 443)
#define ID_RESCONSUMER          (ID_LANG + 444)
#define ID_RESPRODUCER          (ID_LANG + 445)
#define ID_SUBDECODE            (ID_LANG + 446)
#define ID_POSDECODE            (ID_LANG + 447)
#define ID_MINFIXED             (ID_LANG + 448)
#define ID_MINNOTFIXED          (ID_LANG + 449)
#define ID_MAXFIXED             (ID_LANG + 450)
#define ID_MAXNOTFIXED          (ID_LANG + 451)
#define ID_CACHEABLE            (ID_LANG + 452)
#define ID_WRCOMBINING          (ID_LANG + 453)
#define ID_PREFETCHABLE         (ID_LANG + 454)
#define ID_NONCACHEABLE         (ID_LANG + 455)
#define ID_ISAONLYRNG           (ID_LANG + 456)
#define ID_NONISAONLYRNG        (ID_LANG + 457)
#define ID_ENTIRERNG            (ID_LANG + 458)
#define ID_EXT_EDGE             (ID_LANG + 459)
#define ID_EXT_LEVEL            (ID_LANG + 460)
#define ID_EXT_ACTIVEHI         (ID_LANG + 461)
#define ID_EXT_ACTIVELO         (ID_LANG + 462)
#define ID_EXT_SHARED           (ID_LANG + 463)
#define ID_EXT_EXCLUSIVE        (ID_LANG + 464)
#define ID_UNKNOWN_OBJ          (ID_LANG + 465)
#define ID_INT_OBJ              (ID_LANG + 466)
#define ID_STR_OBJ              (ID_LANG + 467)
#define ID_BUFF_OBJ             (ID_LANG + 468)
#define ID_PKG_OBJ              (ID_LANG + 469)
#define ID_FIELDUNIT_OBJ        (ID_LANG + 470)
#define ID_DEV_OBJ              (ID_LANG + 471)
#define ID_EVENT_OBJ            (ID_LANG + 472)
#define ID_METHOD_OBJ           (ID_LANG + 473)
#define ID_MUTEX_OBJ            (ID_LANG + 474)
#define ID_OPREGION_OBJ         (ID_LANG + 475)
#define ID_POWERRES_OBJ         (ID_LANG + 476)
#define ID_THERMAL_OBJ          (ID_LANG + 477)
#define ID_BUFFFIELD_OBJ        (ID_LANG + 478)
#define ID_DDBHANDLE_OBJ        (ID_LANG + 479)
#define ID_CMOSCFG              (ID_LANG + 480)
#define ID_SMBQUICK             (ID_LANG + 481)
#define ID_SMBSENDRECEIVE       (ID_LANG + 482)
#define ID_SMBBYTE              (ID_LANG + 483)
#define ID_SMBWORD              (ID_LANG + 484)
#define ID_SMBBLOCK             (ID_LANG + 485)
#define ID_SMBPROCESSCALL       (ID_LANG + 486)
#define ID_SMBBLOCKPROCESSCALL  (ID_LANG + 487)

#define ID_OFFSET               (ID_LANG + 500)
#define ID_ACCESSAS             (ID_LANG + 501)

#define ID_BANKFIELD            (ID_LANG + 600)
#define ID_DEVICE               (ID_LANG + 601)
#define ID_EVENT                (ID_LANG + 602)
#define ID_FIELD                (ID_LANG + 603)
#define ID_IDXFIELD             (ID_LANG + 604)
#define ID_METHOD               (ID_LANG + 605)
#define ID_MUTEX                (ID_LANG + 606)
#define ID_OPREGION             (ID_LANG + 607)
#define ID_POWERRES             (ID_LANG + 608)
#define ID_PROCESSOR            (ID_LANG + 609)
#define ID_THERMALZONE          (ID_LANG + 610)

#define ID_BREAK                (ID_LANG + 700)
#define ID_BREAKPOINT           (ID_LANG + 701)
#define ID_BITFIELD             (ID_LANG + 702)
#define ID_BYTEFIELD            (ID_LANG + 703)
#define ID_DWORDFIELD           (ID_LANG + 704)
#define ID_CREATEFIELD          (ID_LANG + 705)
#define ID_WORDFIELD            (ID_LANG + 706)
#define ID_ELSE                 (ID_LANG + 707)
#define ID_FATAL                (ID_LANG + 708)
#define ID_IF                   (ID_LANG + 709)
#define ID_LOAD                 (ID_LANG + 710)
#define ID_NOP                  (ID_LANG + 711)
#define ID_NOTIFY               (ID_LANG + 712)
#define ID_RELEASE              (ID_LANG + 713)
#define ID_RESET                (ID_LANG + 714)
#define ID_RETURN               (ID_LANG + 715)
#define ID_SIGNAL               (ID_LANG + 716)
#define ID_SLEEP                (ID_LANG + 717)
#define ID_STALL                (ID_LANG + 718)
#define ID_UNLOAD               (ID_LANG + 719)
#define ID_WHILE                (ID_LANG + 720)

#define ID_ACQUIRE              (ID_LANG + 800)
#define ID_ADD                  (ID_LANG + 801)
#define ID_AND                  (ID_LANG + 802)
#define ID_CONCAT               (ID_LANG + 803)
#define ID_CONDREFOF            (ID_LANG + 804)
#define ID_DECREMENT            (ID_LANG + 805)
#define ID_DEREFOF              (ID_LANG + 806)
#define ID_DIVIDE               (ID_LANG + 807)
#define ID_FINDSETLBIT          (ID_LANG + 808)
#define ID_FINDSETRBIT          (ID_LANG + 809)
#define ID_FROMBCD              (ID_LANG + 810)
#define ID_INCREMENT            (ID_LANG + 811)
#define ID_INDEX                (ID_LANG + 812)
#define ID_LAND                 (ID_LANG + 813)
#define ID_LEQ                  (ID_LANG + 814)
#define ID_LG                   (ID_LANG + 815)
#define ID_LGEQ                 (ID_LANG + 816)
#define ID_LL                   (ID_LANG + 817)
#define ID_LLEQ                 (ID_LANG + 818)
#define ID_LNOT                 (ID_LANG + 819)
#define ID_LNOTEQ               (ID_LANG + 820)
#define ID_LOR                  (ID_LANG + 821)
#define ID_MATCH                (ID_LANG + 822)
#define ID_MULTIPLY             (ID_LANG + 823)
#define ID_NAND                 (ID_LANG + 824)
#define ID_NOR                  (ID_LANG + 825)
#define ID_NOT                  (ID_LANG + 826)
#define ID_OBJTYPE              (ID_LANG + 827)
#define ID_OR                   (ID_LANG + 828)
#define ID_REFOF                (ID_LANG + 829)
#define ID_SHIFTL               (ID_LANG + 830)
#define ID_SHIFTR               (ID_LANG + 831)
#define ID_SIZEOF               (ID_LANG + 832)
#define ID_STORE                (ID_LANG + 833)
#define ID_SUBTRACT             (ID_LANG + 834)
#define ID_TOBCD                (ID_LANG + 835)
#define ID_WAIT                 (ID_LANG + 836)
#define ID_XOR                  (ID_LANG + 837)

#define ID_RESTEMP              (ID_LANG + 1000)
#define ID_STARTDEPFNNOPRI      (ID_LANG + 1001)
#define ID_STARTDEPFN           (ID_LANG + 1002)
#define ID_ENDDEPFN             (ID_LANG + 1003)
#define ID_IRQNOFLAGS           (ID_LANG + 1004)
#define ID_IRQ                  (ID_LANG + 1005)
#define ID_DMA                  (ID_LANG + 1006)
#define ID_IO                   (ID_LANG + 1007)
#define ID_FIXEDIO              (ID_LANG + 1008)
#define ID_VENDORSHORT          (ID_LANG + 1009)
#define ID_MEMORY24             (ID_LANG + 1010)
#define ID_VENDORLONG           (ID_LANG + 1011)
#define ID_MEMORY32             (ID_LANG + 1012)
#define ID_MEMORY32FIXED        (ID_LANG + 1013)
#define ID_DWORDMEMORY          (ID_LANG + 1014)
#define ID_DWORDIO              (ID_LANG + 1015)
#define ID_WORDIO               (ID_LANG + 1016)
#define ID_WORDBUSNUMBER        (ID_LANG + 1017)
#define ID_INTERRUPT            (ID_LANG + 1018)
#define ID_QWORDMEMORY          (ID_LANG + 1019)
#define ID_QWORDIO              (ID_LANG + 1020)

// Symbol token values
#define SYM_ANY                 0
#define SYM_LBRACE              1       // {
#define SYM_RBRACE              2       // }
#define SYM_LPARAN              3       // (
#define SYM_RPARAN              4       // )
#define SYM_COMMA               5       // ,
#define SYM_SLASH               6       // /
#define SYM_ASTERISK            7       // *
#define SYM_INLINECOMMENT       8       // //
#define SYM_OPENCOMMENT         9       // SLASH-STAR
#define SYM_CLOSECOMMENT        10      // STAR-SLASH

#define CH_ROOT_PREFIX          '\\'
#define CH_PARENT_PREFIX        '^'
#define CH_NAMESEG_SEP          '.'

/***    Exported function prototypes
 */

PTOKEN EXPORT OpenScan(FILE *pfileSrc);
VOID EXPORT CloseScan(PTOKEN ptoken);
VOID EXPORT PrintScanErr(PTOKEN ptoken, int rcErr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\scanasl.c ===
/*** scanasl.c - ASL scanner
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/05/96
 *
 *  This module provides the token scanning functions for the ASL language.
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/*** Local function prototypes
 */

int LOCAL ScanSym(int c, PTOKEN ptoken);
int LOCAL ScanSpace(int c, PTOKEN ptoken);
int LOCAL ScanID(int c, PTOKEN ptoken);
int LOCAL ScanNum(int c, PTOKEN ptoken);
int LOCAL ScanString(int c, PTOKEN ptoken);
int LOCAL ScanChar(int c, PTOKEN ptoken);
int LOCAL ProcessInLineComment(PTOKEN ptoken);
int LOCAL ProcessComment(PTOKEN ptoken);
int LOCAL LookupSym(PTOKEN ptoken, int iTable);
LONG LOCAL LookupID(PTOKEN ptoken);
int LOCAL GetEscapedChar(PLINE pline);
BOOL EXPORT StrToQWord(PSZ psz, DWORD dwBase, QWORD *pqw);

/*** Local data
 */

PFNTOKEN apfnToken[] =
{
    ScanSym,
    ScanSpace,
    ScanID,
    ScanNum,
    ScanString,
    ScanChar,
    (PFNTOKEN)NULL
};

#ifdef TUNE
  WORD awcTokenType[] =
  {
        0,              //TOKTYPE_SYMBOL
        0,              //TOKTYPE_SPACE
        0,              //TOKTYPE_ID
        0,              //TOKTYPE_NUM
        0,              //TOKTYPE_STRING
        0               //TOKTYPE_CHAR
  };
#endif

//
// The string positions of the symbol characters in SymCharTable
// is used as an index into the SymTokTable.  Therefore, if anything
// is changed in either SymCharTable or SymTokTable, the other
// table has to be changed correspondingly.
//
typedef struct symtok_s
{
    char chSym;
    int  iSymType;
    int  iLink;
} SYMTOK;
//
// Note that the symbol position in the following array must be the same
// position as in the SymCharTable array.
//
SYMTOK SymTokTable[] =
{
    '{',  SYM_LBRACE,           0,              //0
    '}',  SYM_RBRACE,           0,              //1
    '(',  SYM_LPARAN,           0,              //2
    ')',  SYM_RPARAN,           0,              //3
    ',',  SYM_COMMA,            0,              //4
    '/',  SYM_SLASH,            7,              //5
    '*',  SYM_ASTERISK,         9,              //6
    '/',  SYM_INLINECOMMENT,    8,              //7
    '*',  SYM_OPENCOMMENT,      0,              //8
    '/',  SYM_CLOSECOMMENT,     0,              //9
};

#define SYMTOK_TABLE_SIZE       (sizeof(SymTokTable)/sizeof(SYMTOK))

/***EP  OpenScan - scanner initialization
 *
 *  ENTRY
 *      pfileSrc -> source file
 *
 *  EXIT-SUCCESS
 *      returns the pointer to the allocated token structure;
 *  EXIT-FAILURE
 *      returns NULL
 */

PTOKEN EXPORT OpenScan(FILE *pfileSrc)
{
    PTOKEN ptoken;

    ENTER((4, "OpenScan(pfileSrc=%p)\n", pfileSrc));

  #ifdef TUNE
    ptoken = OpenToken(pfileSrc, apfnToken, awcTokenType);
  #else
    ptoken = OpenToken(pfileSrc, apfnToken);
  #endif

    EXIT((4, "OpenScan=%p\n", ptoken));
    return ptoken;
}       //OpenScan

/***EP  CloseScan - scanner cleanup
 *
 *  ENTRY
 *      ptoken->token structure
 *  EXIT
 *      None
 */

VOID EXPORT CloseScan(PTOKEN ptoken)
{
    ENTER((4, "CloseScan(ptoken=%p)\n", ptoken));

    CloseToken(ptoken);

    EXIT((4, "CloseScan!\n"));
}       //CloseScan

/***LP  ScanSym - scan symbols token
 *
 *  ENTRY
 *      c - first character of the token
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns TOKERR_NO_MATCH - not a symbol token
 */

int LOCAL ScanSym(int c, PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;
    char *pch;

    ENTER((4, "ScanSym(c=%c,ptoken=%p)\n", c, ptoken));

    if ((pch = strchr(SymCharTable, c)) != NULL)
    {
        int i, j;

        i = (int)(pch - SymCharTable);
        if (i != (j = LookupSym(ptoken, i)))
        {
            i = j;
            ptoken->szToken[ptoken->wTokenLen++] = SymTokTable[i].chSym;
        }

        ptoken->iTokenType = TOKTYPE_SYMBOL;
        ptoken->llTokenValue = SymTokTable[i].iSymType;
        ptoken->szToken[ptoken->wTokenLen] = '\0';

        if (ptoken->llTokenValue == SYM_INLINECOMMENT)
            rc = ProcessInLineComment(ptoken);
        else if (ptoken->llTokenValue == SYM_OPENCOMMENT)
            rc = ProcessComment(ptoken);
        else
            rc = TOKERR_NONE;
    }

    EXIT((4, "ScanSym=%d (SymType=%I64d,Symbol=%s)\n",
          rc, ptoken->llTokenValue, ptoken->szToken));
    return rc;
}       //ScanSym

/***LP  ScanSpace - scans and skips all white spaces
 *
 *  ENTRY
 *      c - first character of the token
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns TOKTYPE_NO_MATCH - not a space token
 */

int LOCAL ScanSpace(int c, PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;

    ENTER((4, "ScanSpace(c=%c,ptoken=%p)\n", c, ptoken));

    if (isspace(c))
    {
        rc = TOKERR_NONE;
        while (((c = LineGetC(ptoken->pline)) != EOF) && isspace(c))
            ;

        LineUnGetC(c, ptoken->pline);

        if (ptoken->wfToken & TOKF_NOIGNORESPACE)
        {
            strcpy(ptoken->szToken, " ");
            ptoken->wTokenLen = 1;
            ptoken->iTokenType = TOKTYPE_SPACE;
        }
        else
            ptoken->iTokenType = TOKTYPE_NULL;
    }

    EXIT((4, "ScanSpace=%d\n", rc));
    return rc;
}       //ScanSpace

/***LP  ScanID - scan ID token
 *
 *  ENTRY
 *      c - first character of the token
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns TOKTYPE_NO_MATCH - not an ID token
 *              TOKERR_TOKEN_TOO_LONG - ID too long
 */

int LOCAL ScanID(int c, PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;

    ENTER((4, "ScanID(c=%c,ptoken=%p)\n", c, ptoken));

    if (isalpha(c) || (c == '_') ||
        (c == CH_ROOT_PREFIX) || (c == CH_PARENT_PREFIX))
    {
        BOOL fParentPrefix = (c == CH_PARENT_PREFIX);

        rc = TOKERR_NONE;
        ptoken->iTokenType = TOKTYPE_ID;
        while (((c = LineGetC(ptoken->pline)) != EOF) &&
               (fParentPrefix && (c == CH_PARENT_PREFIX) ||
                isalnum(c) || (c == '_') || (c == CH_NAMESEG_SEP)))
        {
            fParentPrefix = (c == CH_PARENT_PREFIX);
            if (rc == TOKERR_TOKEN_TOO_LONG)
                continue;
            else if (ptoken->wTokenLen < MAX_TOKEN_LEN)
                ptoken->szToken[ptoken->wTokenLen++] = (char)c;
            else
            {
                ptoken->wErrLine = ptoken->pline->wLineNum;
                ptoken->wErrPos = ptoken->pline->wLinePos;
                rc = TOKERR_TOKEN_TOO_LONG;
            }
        }

        ptoken->szToken[ptoken->wTokenLen] = '\0';
        LineUnGetC(c, ptoken->pline);
        if (rc == TOKERR_NONE)
        {
            ptoken->llTokenValue = LookupID(ptoken);
        }
    }

    EXIT((4, "ScanID=%d (IDType=%I64d,ID=%s)\n",
          rc, ptoken->llTokenValue, ptoken->szToken));
    return rc;
}       //ScanID

/***LP  ScanNum - scan number token
 *
 *  ENTRY
 *      c - first character of the token
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns TOKTYPE_NO_MATCH - not a number token
 *              TOKERR_TOKEN_TOO_LONG - number too long
 */

int LOCAL ScanNum(int c, PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;

    ENTER((4, "ScanNum(c=%c,ptoken=%p)\n", c, ptoken));

    if (isdigit(c))
    {
        BOOL fHex = FALSE;

        rc = TOKERR_NONE;
        ptoken->iTokenType = TOKTYPE_NUMBER;
        if ((c == '0') && ((c = LineGetC(ptoken->pline)) != EOF))
        {
            if (c != 'x')
                LineUnGetC(c, ptoken->pline);
            else
            {
                ptoken->szToken[ptoken->wTokenLen++] = (char)c;
                fHex = TRUE;
            }
        }

        while (((c = LineGetC(ptoken->pline)) != EOF) &&
               ((!fHex && isdigit(c)) || fHex && isxdigit(c)))
        {
            if (rc == TOKERR_TOKEN_TOO_LONG)
                continue;
            else if (ptoken->wTokenLen < MAX_TOKEN_LEN)
                ptoken->szToken[ptoken->wTokenLen++] = (char)c;
            else
            {
                ptoken->wErrLine = ptoken->pline->wLineNum;
                ptoken->wErrPos = ptoken->pline->wLinePos;
                rc = TOKERR_TOKEN_TOO_LONG;
            }
        }

        ptoken->szToken[ptoken->wTokenLen] = '\0';
        LineUnGetC(c, ptoken->pline);

        if (rc == TOKERR_NONE)
        {
            if (!StrToQWord(ptoken->szToken, 0, (QWORD *)&ptoken->llTokenValue))
            {
                ptoken->wErrLine = ptoken->pline->wLineNum;
                ptoken->wErrPos = ptoken->pline->wLinePos;
                rc = TOKERR_TOKEN_TOO_LONG;
            }
        }
    }

    EXIT((4, "ScanNum=%d (Num=%I64d,Token=%s)\n",
          rc, ptoken->llTokenValue, ptoken->szToken));
    return rc;
}       //ScanNum

/***LP  ScanString - scan string token
 *
 *  ENTRY
 *      c - first character of the token
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns TOKTYPE_NO_MATCH       - not a string token
 *              TOKERR_TOKEN_TOO_LONG  - string too long
 *              TOKERR_UNCLOSED_STRING - EOF before string close
 */

int LOCAL ScanString(int c, PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;

    ENTER((4, "ScanString(c=%c,ptoken=%p)\n", c, ptoken));

    if (c == '"')
    {
        rc = TOKERR_NONE;
        ptoken->iTokenType = TOKTYPE_STRING;
        ptoken->wTokenLen--;
        while (((c = LineGetC(ptoken->pline)) != EOF) && (c != '"'))
        {
            if (rc == TOKERR_TOKEN_TOO_LONG)
                continue;
            else if (ptoken->wTokenLen >= MAX_TOKEN_LEN)
            {
                ptoken->wErrLine = ptoken->pline->wLineNum;
                ptoken->wErrPos = ptoken->pline->wLinePos;
                rc = TOKERR_TOKEN_TOO_LONG;
            }
            else
            {
                if (c == '\\')
                    c = GetEscapedChar(ptoken->pline);
                ptoken->szToken[ptoken->wTokenLen++] = (char)c;
            }
        }

        ptoken->szToken[ptoken->wTokenLen] = '\0';
        if (c == EOF)
        {
            ptoken->wErrLine = ptoken->pline->wLineNum;
            if ((ptoken->wErrPos = ptoken->pline->wLinePos) != 0)
                ptoken->wErrPos--;
            rc = TOKERR_UNCLOSED_STRING;
        }
    }

    EXIT((4, "ScanString=%d (string=%s)\n", rc, ptoken->szToken));
    return rc;
}       //ScanString

/***LP  ScanChar - scan character token
 *
 *  ENTRY
 *      c - first character of the token
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns TOKERR_NO_MATCH       - not a character token
 *              TOKERR_TOKEN_TOO_LONG - token too long
 *              TOKERR_UNCLOSED_CHAR  - cannot find character close
 */

int LOCAL ScanChar(int c, PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;

    ENTER((4, "ScanChar(c=%c,ptoken=%p)\n", c, ptoken));

    if (c == '\'')
    {
        rc = TOKERR_NONE;
        ptoken->iTokenType = TOKTYPE_CHAR;
        ptoken->wTokenLen--;
        if (((c = LineGetC(ptoken->pline)) == EOF) ||
            (c == '\\') && ((c = GetEscapedChar(ptoken->pline)) == EOF))
        {
            rc = TOKERR_UNCLOSED_CHAR;
        }
        else
        {
            ptoken->szToken[ptoken->wTokenLen++] = (char)c;
            ptoken->szToken[ptoken->wTokenLen] = '\0';
            ptoken->llTokenValue = c;
            if ((c = LineGetC(ptoken->pline)) == EOF)
                rc = TOKERR_UNCLOSED_CHAR;
            else if (c != '\'')
                rc = TOKERR_TOKEN_TOO_LONG;
        }

        if (rc != TOKERR_NONE)
        {
            ptoken->wErrLine = ptoken->pline->wLineNum;
            if ((ptoken->wErrPos = ptoken->pline->wLinePos) != 0)
                ptoken->wErrPos--;

            if (rc == TOKERR_TOKEN_TOO_LONG)
            {
                while (((c = LineGetC(ptoken->pline)) != EOF) && (c != '\''))
                    ;

                if (c == EOF)
                    rc = TOKERR_UNCLOSED_CHAR;
            }
        }
    }

    EXIT((4, "ScanChar=%d (Value=%I64d,Char=%s)\n",
          rc, ptoken->llTokenValue, ptoken->szToken));
    return rc;
}       //ScanChar

/***LP  ProcessInLineComment - handle inline comment
 *
 *  ENTRY
 *      ptoken -> token structure
 *
 *  EXIT
 *      always returns TOKERR_NONE
 */

int LOCAL ProcessInLineComment(PTOKEN ptoken)
{
    ENTER((4, "ProcessInLineComment(ptoken=%p,Token=%s,Comment=%s)\n",
           ptoken, ptoken->szToken,
           &ptoken->pline->szLineBuff[ptoken->pline->wLinePos]));

    LineFlush(ptoken->pline);
    ptoken->iTokenType = TOKTYPE_NULL;

    EXIT((4, "ProcessInLineComment=%d\n", TOKERR_NONE));
    return TOKERR_NONE;
}       //ProcessInLineComment

/***LP  ProcessComment - handle comment
 *
 *  ENTRY
 *      ptoken -> token structure
 *
 *  EXIT
 *      always returns TOKERR_NONE
 */

int LOCAL ProcessComment(PTOKEN ptoken)
{
    int rc = TOKERR_UNCLOSED_COMMENT;
    int c;
    char *pch;

    ENTER((4, "ProcessComment(ptoken=%p,Token=%s,Comment=%s)\n",
           ptoken, ptoken->szToken,
           &ptoken->pline->szLineBuff[ptoken->pline->wLinePos]));

    while ((c = LineGetC(ptoken->pline)) != EOF)
    {
        if ((pch = strchr(SymCharTable, c)) != NULL)
        {
            int i;

            i = LookupSym(ptoken, (int)(pch - SymCharTable));
            if (SymTokTable[i].iSymType == SYM_CLOSECOMMENT)
            {
                ptoken->iTokenType = TOKTYPE_NULL;
                rc = TOKERR_NONE;
                break;
            }
        }
    }

    if (rc != TOKERR_NONE)
    {
        ptoken->wErrLine = ptoken->pline->wLineNum;
        if ((ptoken->wErrPos = ptoken->pline->wLinePos) != 0)
            ptoken->wErrPos--;
    }

    EXIT((4, "ProcessComment=%d\n", rc));
    return rc;
}       //ProcessComment

/***LP  LookupSym - match for 2-char. symbols
 *
 *  ENTRY
 *      ptoken -> token structure
 *      iTable = SymCharTable index
 *
 *  EXIT-SUCCESS
 *      returns a different index than iTable;
 *  EXIT-FAILURE
 *      returns iTable;
 */

int LOCAL LookupSym(PTOKEN ptoken, int iTable)
{
    int i = iTable;
    int c;

    ENTER((4, "LookupSym(ptoken=%p,iTable=%d)\n", ptoken, iTable));

    if ((SymTokTable[iTable].iLink != 0) &&
        ((c = LineGetC(ptoken->pline)) != EOF))
    {
        i = SymTokTable[iTable].iLink;
        while ((c != SymTokTable[i].chSym) && (SymTokTable[i].iLink != 0))
            i = SymTokTable[i].iLink;

        if (c != SymTokTable[i].chSym)
        {
            LineUnGetC(c, ptoken->pline);
            i = iTable;
        }
    }

    EXIT((4, "LookupSym=%d\n", i));
    return i;
}       //LookupSym

/***LP  LookupID - lookup the token in our reserved ID list
 *
 *  ENTRY
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns index of TermTable
 *  EXIT-FAILURE
 *      returns ID_USER
 */

LONG LOCAL LookupID(PTOKEN ptoken)
{
    LONG lID = ID_USER;
    LONG i;

    ENTER((4, "LookupID(ptoken=%p)\n", ptoken));

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if (_stricmp(TermTable[i].pszID, ptoken->szToken) == 0)
        {
            lID = i;
            break;
        }
    }

    EXIT((4, "LookupID=%ld\n", lID));
    return lID;
}       //LookupID

/***LP  GetEscapedChar - read and translate escape character
 *
 *  ENTRY
 *      pline -> line structure
 *
 *  EXIT-SUCCESS
 *      returns the escape character
 *  EXIT-FAILURE
 *      returns EOF - eof encountered
 */

int LOCAL GetEscapedChar(PLINE pline)
{
    int c;
    #define ESCAPE_BUFF_SIZE    5
    char achEscapedBuff[ESCAPE_BUFF_SIZE];
    int i;

    ENTER((4, "GetEscapedChar(pline=%p)\n", pline));

    if ((c = LineGetC(pline)) != EOF)
    {
        switch(c)
        {
            case '0':
                achEscapedBuff[0] = (char)c;
                for (i = 1; i < 4; i++) //maximum 3 digits
                {
                    if (((c = LineGetC(pline)) != EOF) &&
                        (c >= '0') && (c <= '7'))
                    {
                        achEscapedBuff[i] = (char)c;
                    }
                    else
                    {
                        LineUnGetC(c, pline);
                        break;
                    }
                }
                achEscapedBuff[i] = '\0';
                c = (int)strtoul(achEscapedBuff, NULL, 8);
                break;

            case 'a':
                c = '\a';       //alert (bell)
                break;

            case 'b':
                c = '\b';       //backspace
                break;

            case 'f':
                c = '\f';       //form feed
                break;

            case 'n':
                c = '\n';       //newline
                break;

            case 'r':
                c = '\r';       //carriage return
                break;

            case 't':
                c = '\t';       //horizontal tab
                break;

            case 'v':
                c = '\v';       //vertical tab
                break;

            case 'x':
                for (i = 0; i < 2; i++) //maximum 2 digits
                {
                    if (((c = LineGetC(pline)) != EOF) && isxdigit(c))
                        achEscapedBuff[i] = (char)c;
                    else
                    {
                        LineUnGetC(c, pline);
                        break;
                    }
                }
                achEscapedBuff[i] = '\0';
                c = (int)strtoul(achEscapedBuff, NULL, 16);
        }
    }

    EXIT((4, "GetEscapedChar=%x\n", c));
    return c;
}       //GetEscapedChar

/***EP  PrintScanErr - print scan error
 *
 *  ENTRY
 *      ptoken -> token structure
 *      rcErr - error code
 *
 *  EXIT
 *      None
 */

VOID EXPORT PrintScanErr(PTOKEN ptoken, int rcErr)
{
    WORD i;

    ENTER((4, "PrintScanErr(ptoken=%p,Err=%d)\n", ptoken, rcErr));

    ASSERT(ptoken->wTokenLine == ptoken->wErrLine);

    ErrPrintf("%5u: %s\n       ",
              ptoken->wTokenLine, ptoken->pline->szLineBuff);

    for (i = 0; i < ptoken->wErrPos; ++i)
    {
        if (ptoken->pline->szLineBuff[i] == '\t')
        {
            ErrPrintf("\t");
        }
        else
        {
            ErrPrintf(" ");
        }
    }

    ErrPrintf("^***\n");

    switch (rcErr)
    {
        case TOKERR_TOKEN_TOO_LONG:
            ErrPrintf("ScanErr: Token too long\n");
            break;

        case TOKERR_UNCLOSED_STRING:
            ErrPrintf("ScanErr: Unclosed string\n");
            break;

        case TOKERR_UNCLOSED_CHAR:
            ErrPrintf("ScanErr: Unclosed character quote\n");
            break;

        default:
            ErrPrintf("ScanErr: Syntax error\n");
            break;
    }

    EXIT((4, "PrintScanErr!\n"));
}       //PrintScanErr

/***EP  StrToQWord - convert the number in a string to a QWord
 *
 *  ENTRY
 *      psz -> string
 *      dwBase - the base of the number (if 0, auto-detect base)
 *      pqw -> to hold the resulting QWord
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL EXPORT StrToQWord(PSZ psz, DWORD dwBase, QWORD *pqw)
{
    BOOL rc = TRUE;
    ULONG m;

    ENTER((4, "StrToQWord(Str=%s,Base=%x,pqw=%p)\n", psz, dwBase, pqw));

    *pqw = 0;
    if (dwBase == 0)
    {
        if (psz[0] == '0')
        {
            if ((psz[1] == 'x') || (psz[1] == 'X'))
            {
                dwBase = 16;
                psz += 2;
            }
            else
            {
                dwBase = 8;
                psz++;
            }
        }
        else
            dwBase = 10;
    }

    while (*psz != '\0')
    {
        if ((*psz >= '0') && (*psz <= '9'))
            m = *psz - '0';
        else if ((*psz >= 'A') && (*psz <= 'Z'))
            m = *psz - 'A' + 10;
        else if ((*psz >= 'a') && (*psz <= 'z'))
            m = *psz - 'a' + 10;
	else
        {
            rc = FALSE;
	    break;
        }

        if (m < dwBase)
        {
            *pqw = (*pqw * dwBase) + m;
            psz++;
        }
        else
        {
            rc = FALSE;
            break;
        }
    }

    EXIT((4, "StrToQWord=%x (QWord=0x%I64x)\n", rc, *pqw));
    return rc;
}       //StrToQWord
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\vxd.c ===
/*** vxd.c - ACPITAB.VXD related functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/09/97
 *
 *  MODIFICATION HISTORY
 */

#ifdef ___UNASM

#pragma warning (disable: 4201 4214 4514)

typedef unsigned __int64 ULONGLONG;
#define LOCAL   __cdecl
#define EXPORT  __cdecl
#include <stdarg.h>
#define _X86_
#include <windef.h>
#include <winbase.h>
#define EXCL_BASEDEF
#include "aslp.h"
#include "..\acpitab\acpitab.h"

/***LP  OpenVxD - Open ACPITAB.VXD
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns VxD handle
 *  EXIT-FAILURE
 *      returns NULL
 */

HANDLE LOCAL OpenVxD(VOID)
{
    HANDLE hVxD;
    DWORD dwVersion;

    ENTER((2, "OpenVxD()\n"));

    if ((hVxD = CreateFile(ACPITAB_VXD_NAME, 0, 0, NULL, 0,
                           FILE_FLAG_DELETE_ON_CLOSE, NULL)) ==
        INVALID_HANDLE_VALUE)
    {
        hVxD = NULL;
    }
    else if (!DeviceIoControl(hVxD, ACPITAB_DIOC_GETVERSION, NULL, 0,
                              &dwVersion, sizeof(dwVersion), NULL, NULL) ||
             (dwVersion != (ACPITAB_MAJOR_VER << 8) | ACPITAB_MINOR_VER))
    {
        ERROR(("OpenVxD: version error"));
        CloseVxD(hVxD);
        hVxD = NULL;
    }

    EXIT((2, "OpenVxD=%x\n", hVxD));
    return hVxD;
}       //OpenVxD

/***LP  CloseVxD - Close the VxD
 *
 *  ENTRY
 *      hVxD - VxD handle
 *
 *  EXIT
 *      None
 */

VOID LOCAL CloseVxD(HANDLE hVxD)
{
    ENTER((2, "CloseVxD(hVxD=%x)\n", hVxD));

    CloseHandle(hVxD);

    EXIT((2, "CloseVxD!\n"));
}       //CloseVxD

/***LP  GetTable - Get table
 *
 *  ENTRY
 *      hVxD - VxD handle
 *      dwTabSig - table signature
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */

PBYTE LOCAL GetTable(HANDLE hVxD, DWORD dwTabSig)
{
    PBYTE pb = NULL;
    TABINFO TabInfo;

    ENTER((2, "GetTable(hVxD=%x,TabSig=%x)\n", hVxD, dwTabSig));

    TabInfo.dwTabSig = dwTabSig;
    if (DeviceIoControl(hVxD, ACPITAB_DIOC_GETTABINFO, NULL, 0, &TabInfo,
                         sizeof(TabInfo), NULL, NULL))
    {
        if ((pb = MEMALLOC(TabInfo.dh.Length)) != NULL)
        {
            if (DeviceIoControl(hVxD, ACPITAB_DIOC_GETTABLE,
                                (PVOID)TabInfo.dwPhyAddr, 0, pb,
                                TabInfo.dh.Length, NULL, NULL) == 0)
            {
                ERROR(("GetTable: failed to get table. (rc=%x)",
                       GetLastError()));
                MEMFREE(pb);
                pb = NULL;
            }
        }
        else
        {
            ERROR(("GetTable: failed to allocate table buffer"));
        }
    }
    else
    {
        ERROR(("GetTable: failed to get table info. (rc=%x)", GetLastError()));
    }

    EXIT((2, "GetTable=%x\n", pb));
    return pb;
}       //GetTable

#endif  //ifdef __UNASM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\uasmdata.h ===
/*** uasmdata.h - Unassembler Data Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/05/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _UASMDATA_H
#define _UASMDATA_H

// Opcode classes
#define OPCLASS_INVALID         0
#define OPCLASS_DATA_OBJ        1
#define OPCLASS_NAME_OBJ        2
#define OPCLASS_CONST_OBJ       3
#define OPCLASS_CODE_OBJ        4
#define OPCLASS_ARG_OBJ         5
#define OPCLASS_LOCAL_OBJ       6

// Term classes
#define TC_PNP_MACRO            0x00100000
#define TC_REF_OBJECT           0x00200000
#define TC_FIELD_MACRO          0x00400000
#define TC_DATA_OBJECT          0x00800000
#define TC_NAMED_OBJECT         0x01000000
#define TC_NAMESPACE_MODIFIER   0x02000000
#define TC_OPCODE_TYPE1         0x04000000
#define TC_OPCODE_TYPE2         0x08000000
#define TC_CONST_NAME           0x10000000
#define TC_SHORT_NAME           0x20000000
#define TC_COMPILER_DIRECTIVE   0x40000000
#define TC_KEYWORD              0x80000000
#define TC_OPCODE               (TC_OPCODE_TYPE1 | TC_OPCODE_TYPE2 | \
                                 TC_SHORT_NAME | TC_CONST_NAME | TC_DATA_OBJECT)

// Term flags
#define TF_ACTION_FLIST         0x00000001
#define TF_ACTION_VLIST         0x00000002
#define TF_PACKAGE_LEN          0x00000004
#define TF_CHANGE_CHILDSCOPE    0x00000008
#define TF_FIELD_MACRO          TC_FIELD_MACRO
#define TF_DATA_OBJECT          TC_DATA_OBJECT
#define TF_NAMED_OBJECT         TC_NAMED_OBJECT
#define TF_NAMESPACE_MODIFIER   TC_NAMESPACE_MODIFIER
#define TF_OPCODE_TYPE1         TC_OPCODE_TYPE1
#define TF_OPCODE_TYPE2         TC_OPCODE_TYPE2
#define TF_CONST_NAME           TC_CONST_NAME
#define TF_SHORT_NAME           TC_SHORT_NAME
#define TF_COMPILER_DIRECTIVE   TC_COMPILER_DIRECTIVE
#define TF_KEYWORD              TC_KEYWORD
#define TF_PNP_MACRO            TC_PNP_MACRO
#define TF_OBJECT_LIST          (TC_NAMED_OBJECT | TC_NAMESPACE_MODIFIER)
#define TF_CODE_LIST            (TC_OPCODE_TYPE1 | TC_OPCODE_TYPE2)
#define TF_DATA_LIST            0x00010000
#define TF_FIELD_LIST           0x00020000
#define TF_BYTE_LIST            0x00040000
#define TF_DWORD_LIST           0x00080000
#define TF_PACKAGE_LIST         (TC_DATA_OBJECT | TC_SHORT_NAME | \
                                 TC_CONST_NAME)
#define TF_ALL_LISTS            (TF_DATA_OBJECT | TF_NAMED_OBJECT | \
                                 TF_NAMESPACE_MODIFIER | TF_OPCODE_TYPE1 | \
                                 TF_OPCODE_TYPE2 | TF_SHORT_NAME | \
                                 TF_CONST_NAME | TF_COMPILER_DIRECTIVE | \
                                 TF_DATA_LIST | TF_PACKAGE_LIST | \
                                 TF_FIELD_LIST | TF_PNP_MACRO | TF_BYTE_LIST |\
                                 TF_DWORD_LIST)

// NameSpace object types
#define NSTYPE_UNKNOWN          'U'
#define NSTYPE_SCOPE            'S'
#define NSTYPE_FIELDUNIT        'F'
#define NSTYPE_DEVICE           'D'
#define NSTYPE_EVENT            'E'
#define NSTYPE_METHOD           'M'
#define NSTYPE_MUTEX            'X'
#define NSTYPE_OPREGION         'O'
#define NSTYPE_POWERRES         'P'
#define NSTYPE_PROCESSOR        'C'
#define NSTYPE_THERMALZONE      'T'
#define NSTYPE_OBJALIAS         'A'
#define NSTYPE_BUFFFIELD        'B'

// Object types
#define OBJTYPE_PRIVATE         0xf0
#define OBJTYPE_PNP_RES         (OBJTYPE_PRIVATE + 0x00)
#define OBJTYPE_RES_FIELD       (OBJTYPE_PRIVATE + 0x01)
#define OBJTYPE_EXTERNAL        (OBJTYPE_PRIVATE + 0x02)

// Identifier token values
#define ID_LANG                 0
#define ID_DEFBLK               (ID_LANG + 0)
#define ID_INCLUDE              (ID_LANG + 1)
#define ID_EXTERNAL             (ID_LANG + 2)

#define ID_ZERO                 (ID_LANG + 100)
#define ID_ONE                  (ID_LANG + 101)
#define ID_ONES                 (ID_LANG + 102)
#define ID_REVISION             (ID_LANG + 103)
#define ID_ARG0                 (ID_LANG + 104)
#define ID_ARG1                 (ID_LANG + 105)
#define ID_ARG2                 (ID_LANG + 106)
#define ID_ARG3                 (ID_LANG + 107)
#define ID_ARG4                 (ID_LANG + 108)
#define ID_ARG5                 (ID_LANG + 109)
#define ID_ARG6                 (ID_LANG + 110)
#define ID_LOCAL0               (ID_LANG + 111)
#define ID_LOCAL1               (ID_LANG + 112)
#define ID_LOCAL2               (ID_LANG + 113)
#define ID_LOCAL3               (ID_LANG + 114)
#define ID_LOCAL4               (ID_LANG + 115)
#define ID_LOCAL5               (ID_LANG + 116)
#define ID_LOCAL6               (ID_LANG + 117)
#define ID_LOCAL7               (ID_LANG + 118)
#define ID_DEBUG                (ID_LANG + 119)

#define ID_ALIAS                (ID_LANG + 200)
#define ID_NAME                 (ID_LANG + 201)
#define ID_SCOPE                (ID_LANG + 202)

#define ID_BUFFER               (ID_LANG + 300)
#define ID_PACKAGE              (ID_LANG + 301)
#define ID_EISAID               (ID_LANG + 302)

#define ID_ANYACC               (ID_LANG + 400)
#define ID_BYTEACC              (ID_LANG + 401)
#define ID_WORDACC              (ID_LANG + 402)
#define ID_DWORDACC             (ID_LANG + 403)
#define ID_QWORDACC             (ID_LANG + 404)
#define ID_BUFFERACC            (ID_LANG + 405)
#define ID_LOCK                 (ID_LANG + 407)
#define ID_NOLOCK               (ID_LANG + 408)
#define ID_PRESERVE             (ID_LANG + 409)
#define ID_WRONES               (ID_LANG + 410)
#define ID_WRZEROS              (ID_LANG + 411)
#define ID_SYSMEM               (ID_LANG + 412)
#define ID_SYSIO                (ID_LANG + 413)
#define ID_PCICFG               (ID_LANG + 414)
#define ID_EMBCTRL              (ID_LANG + 415)
#define ID_SMBUS                (ID_LANG + 416)
#define ID_SERIALIZED           (ID_LANG + 417)
#define ID_NOTSERIALIZED        (ID_LANG + 418)
#define ID_MTR                  (ID_LANG + 419)
#define ID_MEQ                  (ID_LANG + 420)
#define ID_MLE                  (ID_LANG + 421)
#define ID_MLT                  (ID_LANG + 422)
#define ID_MGE                  (ID_LANG + 423)
#define ID_MGT                  (ID_LANG + 424)
#define ID_EDGE                 (ID_LANG + 425)
#define ID_LEVEL                (ID_LANG + 426)
#define ID_ACTIVEHI             (ID_LANG + 427)
#define ID_ACTIVELO             (ID_LANG + 428)
#define ID_SHARED               (ID_LANG + 429)
#define ID_EXCLUSIVE            (ID_LANG + 430)
#define ID_COMPAT               (ID_LANG + 431)
#define ID_TYPEA                (ID_LANG + 432)
#define ID_TYPEB                (ID_LANG + 433)
#define ID_TYPEF                (ID_LANG + 434)
#define ID_BUSMASTER            (ID_LANG + 435)
#define ID_NOTBUSMASTER         (ID_LANG + 436)
#define ID_TRANSFER8            (ID_LANG + 437)
#define ID_TRANSFER8_16         (ID_LANG + 438)
#define ID_TRANSFER16           (ID_LANG + 439)
#define ID_DECODE16             (ID_LANG + 440)
#define ID_DECODE10             (ID_LANG + 441)
#define ID_READWRITE            (ID_LANG + 442)
#define ID_READONLY             (ID_LANG + 443)
#define ID_RESCONSUMER          (ID_LANG + 444)
#define ID_RESPRODUCER          (ID_LANG + 445)
#define ID_SUBDECODE            (ID_LANG + 446)
#define ID_POSDECODE            (ID_LANG + 447)
#define ID_MINFIXED             (ID_LANG + 448)
#define ID_MINNOTFIXED          (ID_LANG + 449)
#define ID_MAXFIXED             (ID_LANG + 450)
#define ID_MAXNOTFIXED          (ID_LANG + 451)
#define ID_CACHEABLE            (ID_LANG + 452)
#define ID_WRCOMBINING          (ID_LANG + 453)
#define ID_PREFETCHABLE         (ID_LANG + 454)
#define ID_NONCACHEABLE         (ID_LANG + 455)
#define ID_ISAONLYRNG           (ID_LANG + 456)
#define ID_NONISAONLYRNG        (ID_LANG + 457)
#define ID_ENTIRERNG            (ID_LANG + 458)
#define ID_EXT_EDGE             (ID_LANG + 459)
#define ID_EXT_LEVEL            (ID_LANG + 460)
#define ID_EXT_ACTIVEHI         (ID_LANG + 461)
#define ID_EXT_ACTIVELO         (ID_LANG + 462)
#define ID_EXT_SHARED           (ID_LANG + 463)
#define ID_EXT_EXCLUSIVE        (ID_LANG + 464)
#define ID_UNKNOWN_OBJ          (ID_LANG + 465)
#define ID_INT_OBJ              (ID_LANG + 466)
#define ID_STR_OBJ              (ID_LANG + 467)
#define ID_BUFF_OBJ             (ID_LANG + 468)
#define ID_PKG_OBJ              (ID_LANG + 469)
#define ID_FIELDUNIT_OBJ        (ID_LANG + 470)
#define ID_DEV_OBJ              (ID_LANG + 471)
#define ID_EVENT_OBJ            (ID_LANG + 472)
#define ID_METHOD_OBJ           (ID_LANG + 473)
#define ID_MUTEX_OBJ            (ID_LANG + 474)
#define ID_OPREGION_OBJ         (ID_LANG + 475)
#define ID_POWERRES_OBJ         (ID_LANG + 476)
#define ID_THERMAL_OBJ          (ID_LANG + 477)
#define ID_BUFFFIELD_OBJ        (ID_LANG + 478)
#define ID_DDBHANDLE_OBJ        (ID_LANG + 479)
#define ID_CMOSCFG              (ID_LANG + 480)
#define ID_SMBQUICK             (ID_LANG + 481)
#define ID_SMBSENDRECEIVE       (ID_LANG + 482)
#define ID_SMBBYTE              (ID_LANG + 483)
#define ID_SMBWORD              (ID_LANG + 484)
#define ID_SMBBLOCK             (ID_LANG + 485)
#define ID_SMBPROCESSCALL       (ID_LANG + 486)
#define ID_SMBBLOCKPROCESSCALL  (ID_LANG + 487)

#define ID_OFFSET               (ID_LANG + 500)
#define ID_ACCESSAS             (ID_LANG + 501)

#define ID_BANKFIELD            (ID_LANG + 600)
#define ID_DEVICE               (ID_LANG + 601)
#define ID_EVENT                (ID_LANG + 602)
#define ID_FIELD                (ID_LANG + 603)
#define ID_IDXFIELD             (ID_LANG + 604)
#define ID_METHOD               (ID_LANG + 605)
#define ID_MUTEX                (ID_LANG + 606)
#define ID_OPREGION             (ID_LANG + 607)
#define ID_POWERRES             (ID_LANG + 608)
#define ID_PROCESSOR            (ID_LANG + 609)
#define ID_THERMALZONE          (ID_LANG + 610)

#define ID_BREAK                (ID_LANG + 700)
#define ID_BREAKPOINT           (ID_LANG + 701)
#define ID_BITFIELD             (ID_LANG + 702)
#define ID_BYTEFIELD            (ID_LANG + 703)
#define ID_DWORDFIELD           (ID_LANG + 704)
#define ID_CREATEFIELD          (ID_LANG + 705)
#define ID_WORDFIELD            (ID_LANG + 706)
#define ID_ELSE                 (ID_LANG + 707)
#define ID_FATAL                (ID_LANG + 708)
#define ID_IF                   (ID_LANG + 709)
#define ID_LOAD                 (ID_LANG + 710)
#define ID_NOP                  (ID_LANG + 711)
#define ID_NOTIFY               (ID_LANG + 712)
#define ID_RELEASE              (ID_LANG + 713)
#define ID_RESET                (ID_LANG + 714)
#define ID_RETURN               (ID_LANG + 715)
#define ID_SIGNAL               (ID_LANG + 716)
#define ID_SLEEP                (ID_LANG + 717)
#define ID_STALL                (ID_LANG + 718)
#define ID_UNLOAD               (ID_LANG + 719)
#define ID_WHILE                (ID_LANG + 720)

#define ID_ACQUIRE              (ID_LANG + 800)
#define ID_ADD                  (ID_LANG + 801)
#define ID_AND                  (ID_LANG + 802)
#define ID_CONCAT               (ID_LANG + 803)
#define ID_CONDREFOF            (ID_LANG + 804)
#define ID_DECREMENT            (ID_LANG + 805)
#define ID_DEREFOF              (ID_LANG + 806)
#define ID_DIVIDE               (ID_LANG + 807)
#define ID_FINDSETLBIT          (ID_LANG + 808)
#define ID_FINDSETRBIT          (ID_LANG + 809)
#define ID_FROMBCD              (ID_LANG + 810)
#define ID_INCREMENT            (ID_LANG + 811)
#define ID_INDEX                (ID_LANG + 812)
#define ID_LAND                 (ID_LANG + 813)
#define ID_LEQ                  (ID_LANG + 814)
#define ID_LG                   (ID_LANG + 815)
#define ID_LGEQ                 (ID_LANG + 816)
#define ID_LL                   (ID_LANG + 817)
#define ID_LLEQ                 (ID_LANG + 818)
#define ID_LNOT                 (ID_LANG + 819)
#define ID_LNOTEQ               (ID_LANG + 820)
#define ID_LOR                  (ID_LANG + 821)
#define ID_MATCH                (ID_LANG + 822)
#define ID_MULTIPLY             (ID_LANG + 823)
#define ID_NAND                 (ID_LANG + 824)
#define ID_NOR                  (ID_LANG + 825)
#define ID_NOT                  (ID_LANG + 826)
#define ID_OBJTYPE              (ID_LANG + 827)
#define ID_OR                   (ID_LANG + 828)
#define ID_REFOF                (ID_LANG + 829)
#define ID_SHIFTL               (ID_LANG + 830)
#define ID_SHIFTR               (ID_LANG + 831)
#define ID_SIZEOF               (ID_LANG + 832)
#define ID_STORE                (ID_LANG + 833)
#define ID_SUBTRACT             (ID_LANG + 834)
#define ID_TOBCD                (ID_LANG + 835)
#define ID_WAIT                 (ID_LANG + 836)
#define ID_XOR                  (ID_LANG + 837)

#define ID_RESTEMP              (ID_LANG + 1000)
#define ID_STARTDEPFNNOPRI      (ID_LANG + 1001)
#define ID_STARTDEPFN           (ID_LANG + 1002)
#define ID_ENDDEPFN             (ID_LANG + 1003)
#define ID_IRQNOFLAGS           (ID_LANG + 1004)
#define ID_IRQ                  (ID_LANG + 1005)
#define ID_DMA                  (ID_LANG + 1006)
#define ID_IO                   (ID_LANG + 1007)
#define ID_FIXEDIO              (ID_LANG + 1008)
#define ID_VENDORSHORT          (ID_LANG + 1009)
#define ID_MEMORY24             (ID_LANG + 1010)
#define ID_VENDORLONG           (ID_LANG + 1011)
#define ID_MEMORY32             (ID_LANG + 1012)
#define ID_MEMORY32FIXED        (ID_LANG + 1013)
#define ID_DWORDMEMORY          (ID_LANG + 1014)
#define ID_DWORDIO              (ID_LANG + 1015)
#define ID_WORDIO               (ID_LANG + 1016)
#define ID_WORDBUSNUMBER        (ID_LANG + 1017)
#define ID_INTERRUPT            (ID_LANG + 1018)
#define ID_QWORDMEMORY          (ID_LANG + 1019)
#define ID_QWORDIO              (ID_LANG + 1020)

//
// Type definitions
//
typedef int (LOCAL *PFNTERM)(PTOKEN, BOOL);

typedef struct _aslterm
{
    PSZ     pszID;
    LONG    lID;
    DWORD   dwfTermClass;
    DWORD   dwTermData;
    DWORD   dwOpcode;
    PSZ     pszUnAsmArgTypes;
    PSZ     pszArgTypes;
    PSZ     pszArgActions;
    DWORD   dwfTerm;
    PFNTERM pfnTerm;
} ASLTERM, *PASLTERM;

typedef struct _opmap
{
    BYTE    bExOp;
    BYTE    bOpClass;
} OPMAP, *POPMAP;

//
// Imported data
//
extern PBYTE   gpbOpTop;
extern PBYTE   gpbOpBegin;
extern ASLTERM TermTable[];
extern BYTE    OpClassTable[];
extern OPMAP   ExOpClassTable[];

#endif  //ifndef _UASMDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\token.c ===
/*** token.c - functions dealing with token stream
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    08/05/96
 *
 *  This module implements a general purpose scanner.  The
 *  implementation is language independent.  It is a pseudo
 *  table driven scanner which uses a table to determine
 *  the token type by its first character and calls the
 *  appropriate routine to scan the rest of the token
 *  characters.
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***EP  OpenToken - token stream initialization
 *
 *  ENTRY
 *      pfileSrc -> source file
 *      apfnToken -> table of token parsing functions
 *
 *  EXIT-SUCCESS
 *      returns the pointer to the allocated token structure.
 *  EXIT-FAILURE
 *      returns NULL.
 */

#ifdef TUNE
PTOKEN EXPORT OpenToken(FILE *pfileSrc, PFNTOKEN *apfnToken,
                        WORD *pawcTokenType)
#else
PTOKEN EXPORT OpenToken(FILE *pfileSrc, PFNTOKEN *apfnToken)
#endif
{
    PTOKEN ptoken = NULL;

    ENTER((3, "OpenToken(pfileSrc=%p,apfnToken=%p)\n", pfileSrc, apfnToken));

    if ((ptoken = (PTOKEN)malloc(sizeof(TOKEN))) == NULL)
        MSG(("OpenToken: failed to allocate token structure"))
    else
    {
        memset(ptoken, 0, sizeof(TOKEN));
        if ((ptoken->pline = OpenLine(pfileSrc)) == NULL)
        {
            free(ptoken);
            ptoken = NULL;
        }
        else
        {
            ptoken->papfnToken = apfnToken;
          #ifdef TUNE
            ptoken->pawcTokenType = pawcTokenType;
          #endif
        }
    }

    EXIT((3, "OpenToken=%p\n", ptoken));
    return ptoken;
}       //OpenToken

/***EP  CloseToken - free token structure
 *
 *  ENTRY
 *      ptoken -> token structure
 *
 *  EXIT
 *      None
 */

VOID EXPORT CloseToken(PTOKEN ptoken)
{
    ENTER((3, "CloseToken(ptoken=%p)\n", ptoken));

    CloseLine(ptoken->pline);
    free(ptoken);

    EXIT((3, "CloseToken!\n"));
}       //CloseToken

/***EP  GetToken - get a token from a line buffer
 *
 *  This procedure scans the line buffer and returns a token.
 *
 *  ENTRY
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns error code - TOKERR_*
 */

int EXPORT GetToken(PTOKEN ptoken)
{
    int rc = TOKERR_NO_MATCH;

    ENTER((3, "GetToken(ptoken=%p)\n", ptoken));

    if (ptoken->wfToken & TOKF_CACHED)
    {
        ptoken->wfToken &= ~TOKF_CACHED;
        rc = TOKERR_NONE;
    }
    else
    {
        int c, i;

        do
        {
            if ((c = LineGetC(ptoken->pline)) == EOF)
            {
                ptoken->wErrLine = ptoken->pline->wLineNum;
                ptoken->wErrPos = ptoken->pline->wLinePos;
                rc = TOKERR_EOF;
                break;
            }

            ptoken->wTokenPos = (WORD)(ptoken->pline->wLinePos - 1);
            ptoken->wTokenLine = ptoken->pline->wLineNum;
            ptoken->iTokenType = TOKTYPE_NULL;
            ptoken->llTokenValue = 0;
            ptoken->wTokenLen = 0;

            ptoken->szToken[ptoken->wTokenLen++] = (char)c;

            for (i = 0; ptoken->papfnToken[i]; i++)
            {
                if ((rc = (*ptoken->papfnToken[i])(c, ptoken)) ==
                    TOKERR_NO_MATCH)
                {
                    continue;
                }
                else
                {
                  #ifdef TUNE
                    if (rc == TOKERR_NONE)
                        ptoken->pawcTokenType[i]++;
                  #endif
                    break;
                }
            }

            if (rc == TOKERR_NO_MATCH)
            {
                ptoken->szToken[ptoken->wTokenLen] = '\0';
                ptoken->wErrLine = ptoken->pline->wLineNum;
                if ((ptoken->wErrPos = ptoken->pline->wLinePos) != 0)
                    ptoken->wErrPos--;
                PrintTokenErr(ptoken, "unrecognized token", TRUE);
            }
            else if (rc != TOKERR_NONE)
            {
                PrintScanErr(ptoken, rc);
            }
        } while ((rc == TOKERR_NONE) && (ptoken->iTokenType == TOKTYPE_NULL));
    }

    EXIT((3, "GetToken=%d (Type=%d,Value=%I64d,Token=%s,TokenLine=%d,TokenPos=%d)\n",
          rc, ptoken->iTokenType, ptoken->llTokenValue,
          ptoken->szToken, ptoken->wTokenLine, ptoken->wTokenPos));
    return rc;
}       //GetToken

/***EP  UnGetToken - push a token back to the token stream
 *
 *  This procedure unget the last token.
 *
 *  ENTRY
 *      ptoken -> token structure
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns error code - TOKERR_*
 */

int EXPORT UnGetToken(PTOKEN ptoken)
{
    int rc;

    ENTER((3, "UnGetToken(ptoken=%p)\n", ptoken));

    if (!(ptoken->wfToken & TOKF_CACHED))
    {
        ptoken->wfToken |= TOKF_CACHED;
        rc = TOKERR_NONE;
    }
    else
    {
        ASSERT(ptoken->wfToken & TOKF_CACHED);
        rc = TOKERR_ASSERT_FAILED;
    }

    EXIT((3, "UnGetToken=%d\n", rc));
    return rc;
}       //UnGetToken

/***EP  MatchToken - Match the next token type
 *
 *  ENTRY
 *      ptoken -> token structure
 *      iTokenType - token type to match
 *      lTokenValue - token value to match
 *      dwfMatch - match flags
 *      pszErrMsg -> error message to print if not matched
 *
 *  EXIT-SUCCESS
 *      returns TOKERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int EXPORT MatchToken(PTOKEN ptoken, int iTokenType, LONG lTokenValue,
                      DWORD dwfMatch, PSZ pszErrMsg)
{
    int rc;

    ENTER((3, "MatchToken(ptoken=%p,TokType=%d,TokValue=%ld,dwfMatch=%lx,ErrMsg=%s)\n",
           ptoken, iTokenType, lTokenValue, dwfMatch,
           pszErrMsg? pszErrMsg: "<none>"));

    if (((rc = GetToken(ptoken)) == TOKERR_NONE) &&
        ((ptoken->iTokenType != iTokenType) ||
         !(dwfMatch & MTF_ANY_VALUE) &&
         ((LONG)ptoken->llTokenValue != lTokenValue)))
    {
        if (dwfMatch & MTF_NOT_ERR)
        {
            UnGetToken(ptoken);
            rc = TOKERR_NO_MATCH;
        }
        else
        {
            rc = TOKERR_SYNTAX;
        }
    }

    if ((rc != TOKERR_NONE) && !(dwfMatch & MTF_NOT_ERR))
    {
        char szMsg[MAX_MSG_LEN + 1];

        if (pszErrMsg == NULL)
        {
            sprintf(szMsg, "expecting %s",
                    gapszTokenType[iTokenType - TOKTYPE_LANG - 1]);

            if (!(dwfMatch & MTF_ANY_VALUE) && (iTokenType == TOKTYPE_SYMBOL))
            {
                sprintf(&szMsg[strlen(szMsg)], " '%c'",
                        SymCharTable[lTokenValue - 1]);
            }
            pszErrMsg = szMsg;
        }

        PrintTokenErr(ptoken, pszErrMsg, TRUE);

        if (rc == TOKERR_EOF)
        {
            rc = TOKERR_SYNTAX;
        }
    }

    EXIT((3, "MatchToken=%d (Type=%d,Value=%I64d,Token=%s)\n",
          rc, ptoken->iTokenType, ptoken->llTokenValue, ptoken->szToken));
    return rc;
}       //MatchToken

/***EP  PrintTokenErr - print token error line
 *
 *  ENTRY
 *      ptoken -> token structure
 *      pszErrMsg -> error message string
 *      fErr - TRUE if it is an error, FALSE if warning
 *
 *  EXIT
 *      None
 */

VOID EXPORT PrintTokenErr(PTOKEN ptoken, PSZ pszErrMsg, BOOL fErr)
{
    WORD i;

    ENTER((3, "PrintTokenErr(ptoken=%p,Line=%d,Pos=%d,Msg=%s)\n",
           ptoken, ptoken->wTokenLine, ptoken->wTokenPos, pszErrMsg));

    ErrPrintf("\n%5u: %s",
              ptoken->wTokenLine, ptoken->pline->szLineBuff);

    ErrPrintf("       ");
    for (i = 0; i < ptoken->wTokenPos; ++i)
    {
        if (ptoken->pline->szLineBuff[i] == '\t')
        {
            ErrPrintf("\t");
        }
        else
        {
            ErrPrintf(" ");
        }
    }
    ErrPrintf("^***\n");

    if (pszErrMsg != NULL)
    {
        ErrPrintf("%s(%d): %s: %s\n",
                  gpszASLFile, ptoken->wTokenLine, fErr? "error": "warning",
                  pszErrMsg);
    }

    EXIT((3, "PrintTokenErr!\n"));
}       //PrintTokenErr
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\uasmdata.c ===
/*** uasmdata.c - Unassembler Data
 *
 *  This module contains global data declaration.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/07/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

PBYTE gpbOpTop = NULL;
PBYTE gpbOpBegin = NULL;

//
// N: NameStr
// O: DataObj (num, string, buffer, package)
// K: Keyword (e.g. NoLock, ByteAcc etc.)
// D: DWord integer
// W: Word integer
// B: Byte integer
// U: Numeric (any size integer)
// S: SuperName (NameStr + Localx + Argx + Ret)
// C: Opcode
// Z: ASCIIZ string
//
#define AF      TF_ACTION_FLIST         //process after fixed list is parsed
#define AV      TF_ACTION_VLIST         //process after variable list is parsed
#define LN      TF_PACKAGE_LEN          //term requires package length
#define CC      TF_CHANGE_CHILDSCOPE    //change to child scope
#define DL      TF_DATA_LIST            //term expects buffer data list
#define PL      TF_PACKAGE_LIST         //term expects package list
#define FL      TF_FIELD_LIST           //term expects FieldList
#define OL      TF_OBJECT_LIST          //term expects ObjectList
#define LL      TF_COMPILER_DIRECTIVE   //term expects compiler directives
#define CL      TF_CODE_LIST            //term expects CodeList
#define AL      TF_ALL_LISTS            //term expects anything
#define ML      TF_PNP_MACRO            //term expects PNPMacro
#define BL      TF_BYTE_LIST            //term expects ByteList
#define DD      TF_DWORD_LIST           //term expects DWordList

#define CD      TC_COMPILER_DIRECTIVE
#define FM      TC_FIELD_MACRO
#define CN      TC_CONST_NAME
#define SN      TC_SHORT_NAME
#define NS      TC_NAMESPACE_MODIFIER
#define DO      TC_DATA_OBJECT
#define KW      TC_KEYWORD
#define NO      TC_NAMED_OBJECT
#define C1      TC_OPCODE_TYPE1
#define C2      TC_OPCODE_TYPE2
#define RO      TC_REF_OBJECT
#define PM      TC_PNP_MACRO

#define UNK     OBJTYPE_UNKNOWN
#define INT     OBJTYPE_INTDATA
#define STR     OBJTYPE_STRDATA
#define BUF     OBJTYPE_BUFFDATA
#define PKG     OBJTYPE_PKGDATA
#define FDU     OBJTYPE_FIELDUNIT
#define DEV     OBJTYPE_DEVICE
#define EVT     OBJTYPE_EVENT
#define MET     OBJTYPE_METHOD
#define MUT     OBJTYPE_MUTEX
#define OPR     OBJTYPE_OPREGION
#define PWR     OBJTYPE_POWERRES
#define THM     OBJTYPE_THERMALZONE
#define BFD     OBJTYPE_BUFFFIELD
#define DDB     OBJTYPE_DDBHANDLE

/*** Field flags
 */

#define AANY    (ACCTYPE_ANY | (ACCTYPE_MASK << 8))
#define AB      (ACCTYPE_BYTE | (ACCTYPE_MASK << 8))
#define AW      (ACCTYPE_WORD | (ACCTYPE_MASK << 8))
#define ADW     (ACCTYPE_DWORD | (ACCTYPE_MASK << 8))
#define AQW     (ACCTYPE_QWORD |  (ACCTYPE_MASK << 8))
#define ABFR    (ACCTYPE_BUFFER |  (ACCTYPE_MASK << 8))
#define LK      (LOCKRULE_LOCK | (LOCKRULE_MASK << 8))
#define NOLK    (LOCKRULE_NOLOCK | (LOCKRULE_MASK << 8))
#define PSRV    (UPDATERULE_PRESERVE | (UPDATERULE_MASK << 8))
#define WA1S    (UPDATERULE_WRITEASONES | (UPDATERULE_MASK << 8))
#define WA0S    (UPDATERULE_WRITEASZEROS | (UPDATERULE_MASK << 8))

/*** AccessAttribute
 */

#define SMBQ    0x02
#define SMBS    0x04
#define SMBB    0x06
#define SMBW    0x08
#define SMBK    0x0a
#define SMBP    0x0c
#define SMBC    0x0d

/*** Operation region space
 */

#define MEM     (REGSPACE_MEM       | 0xff00)
#define IO      (REGSPACE_IO        | 0xff00)
#define CFG     (REGSPACE_PCICFG    | 0xff00)
#define EC      (REGSPACE_EC        | 0xff00)
#define SMB     (REGSPACE_SMB       | 0xff00)
#define CMOSCFG (REGSPACE_CMOSCFG   | 0xff00)

/*** Method flags
 */

#define SER     (METHOD_SERIALIZED | (METHOD_SYNCMASK << 8))
#define NOSER   (METHOD_NOTSERIALIZED | (METHOD_SYNCMASK << 8))

/*** Match operation values
 */

#define OMTR    (MTR | 0xff00)
#define OMEQ    (MEQ | 0xff00)
#define OMLE    (MLE | 0xff00)
#define OMLT    (MLT | 0xff00)
#define OMGE    (MGE | 0xff00)
#define OMGT    (MGT | 0xff00)

#ifdef _UNASM_LIB
  #define DefinitionBlock   NULL
  #define Include           NULL
  #define External          NULL
  #define EISAID            NULL
  #define AccessAs          NULL
  #define BankField         NULL
  #define Field             NULL
  #define IndexField        NULL
  #define Method            NULL
  #define OpRegion          NULL
  #define Else              NULL
  #define Match             NULL
  #define ResourceTemplate  NULL
  #define AddSmallOffset    NULL
  #define StartDependentFn  NULL
  #define AddSmallOffset    NULL
  #define IRQDesc           NULL
  #define IRQDesc           NULL
  #define DMADesc           NULL
  #define IODesc            NULL
  #define FixedIODesc       NULL
  #define VendorShort       NULL
  #define Memory24Desc      NULL
  #define VendorLong        NULL
  #define Memory32Desc      NULL
  #define FixedMemory32Desc NULL
  #define DWordMemDesc      NULL
  #define DWordIODesc       NULL
  #define WordIODesc        NULL
  #define WordBusNumDesc    NULL
  #define InterruptDesc     NULL
  #define QWordMemDesc      NULL
  #define QWordIODesc       NULL
#endif

ASLTERM TermTable[] =
{
    "DefinitionBlock",  ID_DEFBLK,       CD, 0, OP_NONE,     NULL, "ZZBZZD", NULL, OL|CL|LL|AF|AV, DefinitionBlock,
    "Include",          ID_INCLUDE,      CD, 0, OP_NONE,     NULL, "Z",      NULL, AF, Include,
    "External",         ID_EXTERNAL,     CD, 0, OP_NONE,     NULL, "Nkd",    "uX", AF, External,

    // Short Objects
    "Zero",             ID_ZERO,         CN, 0, OP_ZERO,     NULL, NULL, NULL, 0, NULL,
    "One",              ID_ONE,          CN, 0, OP_ONE,      NULL, NULL, NULL, 0, NULL,
    "Ones",             ID_ONES,         CN, 0, OP_ONES,     NULL, NULL, NULL, 0, NULL,
    "Revision",         ID_REVISION,     CN, 0, OP_REVISION, NULL, NULL, NULL, 0, NULL,
    "Arg0",             ID_ARG0,         SN, 0, OP_ARG0,     NULL, NULL, NULL, 0, NULL,
    "Arg1",             ID_ARG1,         SN, 0, OP_ARG1,     NULL, NULL, NULL, 0, NULL,
    "Arg2",             ID_ARG2,         SN, 0, OP_ARG2,     NULL, NULL, NULL, 0, NULL,
    "Arg3",             ID_ARG3,         SN, 0, OP_ARG3,     NULL, NULL, NULL, 0, NULL,
    "Arg4",             ID_ARG4,         SN, 0, OP_ARG4,     NULL, NULL, NULL, 0, NULL,
    "Arg5",             ID_ARG5,         SN, 0, OP_ARG5,     NULL, NULL, NULL, 0, NULL,
    "Arg6",             ID_ARG6,         SN, 0, OP_ARG6,     NULL, NULL, NULL, 0, NULL,
    "Local0",           ID_LOCAL0,       SN, 0, OP_LOCAL0,   NULL, NULL, NULL, 0, NULL,
    "Local1",           ID_LOCAL1,       SN, 0, OP_LOCAL1,   NULL, NULL, NULL, 0, NULL,
    "Local2",           ID_LOCAL2,       SN, 0, OP_LOCAL2,   NULL, NULL, NULL, 0, NULL,
    "Local3",           ID_LOCAL3,       SN, 0, OP_LOCAL3,   NULL, NULL, NULL, 0, NULL,
    "Local4",           ID_LOCAL4,       SN, 0, OP_LOCAL4,   NULL, NULL, NULL, 0, NULL,
    "Local5",           ID_LOCAL5,       SN, 0, OP_LOCAL5,   NULL, NULL, NULL, 0, NULL,
    "Local6",           ID_LOCAL6,       SN, 0, OP_LOCAL6,   NULL, NULL, NULL, 0, NULL,
    "Local7",           ID_LOCAL7,       SN, 0, OP_LOCAL7,   NULL, NULL, NULL, 0, NULL,
    "Debug",            ID_DEBUG,        SN, 0, OP_DEBUG,    NULL, NULL, NULL, 0, NULL,

    // Named Terms
    "Alias",            ID_ALIAS,        NS, 0, OP_ALIAS,    "NN", "NN", "Ua", 0, NULL,
    "Name",             ID_NAME,         NS, 0, OP_NAME,     "NO", "NO", "u",  0, NULL,
    "Scope",            ID_SCOPE,        NS, 0, OP_SCOPE,    "N",  "N",  "S",  OL|LN|CC, NULL,

    // Data Objects
    "Buffer",           ID_BUFFER,       DO, 0, OP_BUFFER,   "C", "c",  "U",  DL|LN, NULL,
    "Package",          ID_PACKAGE,      DO, 0, OP_PACKAGE,  "B", "b",  NULL, PL|LN, NULL,
    "EISAID",           ID_EISAID,       DO, 0, OP_DWORD,    NULL,"Z",  NULL, AF, EISAID,

    // Argument Keywords
    "AnyAcc",           ID_ANYACC,       KW, AANY, OP_NONE, NULL, NULL, "A", 0, NULL,
    "ByteAcc",          ID_BYTEACC,      KW, AB,   OP_NONE, NULL, NULL, "A", 0, NULL,
    "WordAcc",          ID_WORDACC,      KW, AW,   OP_NONE, NULL, NULL, "A", 0, NULL,
    "DWordAcc",         ID_DWORDACC,     KW, ADW,  OP_NONE, NULL, NULL, "A", 0, NULL,
    "QWordAcc",         ID_QWORDACC,     KW, AQW,  OP_NONE, NULL, NULL, "A", 0, NULL,
    "BufferAcc",        ID_BUFFERACC,    KW, ABFR, OP_NONE, NULL, NULL, "A", 0, NULL,

    "Lock",             ID_LOCK,         KW, LK,   OP_NONE, NULL, NULL, "B", 0, NULL,
    "NoLock",           ID_NOLOCK,       KW, NOLK, OP_NONE, NULL, NULL, "B", 0, NULL,

    "Preserve",         ID_PRESERVE,     KW, PSRV, OP_NONE, NULL, NULL, "C", 0, NULL,
    "WriteAsOnes",      ID_WRONES,       KW, WA1S, OP_NONE, NULL, NULL, "C", 0, NULL,
    "WriteAsZeros",     ID_WRZEROS,      KW, WA0S, OP_NONE, NULL, NULL, "C", 0, NULL,

    "SystemMemory",     ID_SYSMEM,       KW, MEM,  		OP_NONE, NULL, NULL, "D", 0, NULL,
    "SystemIO",         ID_SYSIO,        KW, IO,   		OP_NONE, NULL, NULL, "D", 0, NULL,
    "PCI_Config",       ID_PCICFG,       KW, CFG,  		OP_NONE, NULL, NULL, "D", 0, NULL,
    "EmbeddedControl",  ID_EMBCTRL,      KW, EC,   		OP_NONE, NULL, NULL, "D", 0, NULL,
    "SMBus",            ID_SMBUS,        KW, SMB,  		OP_NONE, NULL, NULL, "D", 0, NULL,
    "CMOS",             ID_CMOSCFG,      KW, CMOSCFG, 	OP_NONE, NULL, NULL, "D", 0, NULL,

    "Serialized",       ID_SERIALIZED,   KW, SER,  OP_NONE, NULL, NULL, "E", 0, NULL,
    "NotSerialized",    ID_NOTSERIALIZED,KW, NOSER,OP_NONE, NULL, NULL, "E", 0, NULL,

    "MTR",              ID_MTR,          KW, OMTR, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MEQ",              ID_MEQ,          KW, OMEQ, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MLE",              ID_MLE,          KW, OMLE, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MLT",              ID_MLT,          KW, OMLT, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MGE",              ID_MGE,          KW, OMGE, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MGT",              ID_MGT,          KW, OMGT, OP_NONE, NULL, NULL, "F", 0, NULL,

    "Edge",             ID_EDGE,         KW, _HE,  OP_NONE, NULL, NULL, "G", 0, NULL,
    "Level",            ID_LEVEL,        KW, _LL,  OP_NONE, NULL, NULL, "G", 0, NULL,

    "ActiveHigh",       ID_ACTIVEHI,     KW, _HE,  OP_NONE, NULL, NULL, "H", 0, NULL,
    "ActiveLow",        ID_ACTIVELO,     KW, _LL,  OP_NONE, NULL, NULL, "H", 0, NULL,

    "Shared",           ID_SHARED,       KW, _SHR, OP_NONE, NULL, NULL, "I", 0, NULL,
    "Exclusive",        ID_EXCLUSIVE,    KW, _EXC, OP_NONE, NULL, NULL, "I", 0, NULL,

    "Compatibility",    ID_COMPAT,       KW, COMP, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeA",            ID_TYPEA,        KW, TYPA, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeB",            ID_TYPEB,        KW, TYPB, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeF",            ID_TYPEF,        KW, TYPF, OP_NONE, NULL, NULL, "J", 0, NULL,

    "BusMaster",        ID_BUSMASTER,    KW, BM,   OP_NONE, NULL, NULL, "K", 0, NULL,
    "NotBusMaster",     ID_NOTBUSMASTER, KW, NOBM, OP_NONE, NULL, NULL, "K", 0, NULL,

    "Transfer8",        ID_TRANSFER8,    KW, X8,   OP_NONE, NULL, NULL, "L", 0, NULL,
    "Transfer8_16",     ID_TRANSFER8_16, KW, X816, OP_NONE, NULL, NULL, "L", 0, NULL,
    "Transfer16",       ID_TRANSFER16,   KW, X16,  OP_NONE, NULL, NULL, "L", 0, NULL,

    "Decode16",         ID_DECODE16,     KW, DC16, OP_NONE, NULL, NULL, "M", 0, NULL,
    "Decode10",         ID_DECODE10,     KW, DC10, OP_NONE, NULL, NULL, "M", 0, NULL,

    "ReadWrite",        ID_READWRITE,    KW, _RW,  OP_NONE, NULL, NULL, "N", 0, NULL,
    "ReadOnly",         ID_READONLY,     KW, _ROM, OP_NONE, NULL, NULL, "N", 0, NULL,

    "ResourceConsumer", ID_RESCONSUMER,  KW, RCS,  OP_NONE, NULL, NULL, "O", 0, NULL,
    "ResourceProducer", ID_RESPRODUCER,  KW, RPD,  OP_NONE, NULL, NULL, "O", 0, NULL,

    "SubDecode",        ID_SUBDECODE,    KW, BSD,  OP_NONE, NULL, NULL, "P", 0, NULL,
    "PosDecode",        ID_POSDECODE,    KW, BPD,  OP_NONE, NULL, NULL, "P", 0, NULL,

    "MinFixed",         ID_MINFIXED,     KW, MIF,  OP_NONE, NULL, NULL, "Q", 0, NULL,
    "MinNotFixed",      ID_MINNOTFIXED,  KW, NMIF, OP_NONE, NULL, NULL, "Q", 0, NULL,

    "MaxFixed",         ID_MAXFIXED,     KW, MAF,  OP_NONE, NULL, NULL, "R", 0, NULL,
    "MaxNotFixed",      ID_MAXNOTFIXED,  KW, NMAF, OP_NONE, NULL, NULL, "R", 0, NULL,

    "Cacheable",        ID_CACHEABLE,    KW, CACH, OP_NONE, NULL, NULL, "S", 0, NULL,
    "WriteCombining",   ID_WRCOMBINING,  KW, WRCB, OP_NONE, NULL, NULL, "S", 0, NULL,
    "Prefetchable",     ID_PREFETCHABLE, KW, PREF, OP_NONE, NULL, NULL, "S", 0, NULL,
    "NonCacheable",     ID_NONCACHEABLE, KW, NCAC, OP_NONE, NULL, NULL, "S", 0, NULL,

    "ISAOnlyRanges",    ID_ISAONLYRNG,   KW, ISA,  OP_NONE, NULL, NULL, "T", 0, NULL,
    "NonISAOnlyRanges", ID_NONISAONLYRNG,KW, NISA, OP_NONE, NULL, NULL, "T", 0, NULL,
    "EntireRange",      ID_ENTIRERNG,    KW, ERNG, OP_NONE, NULL, NULL, "T", 0, NULL,

    "ExtEdge",          ID_EXT_EDGE,     KW, $EDG, OP_NONE, NULL, NULL, "U", 0, NULL,
    "ExtLevel",         ID_EXT_LEVEL,    KW, $LVL, OP_NONE, NULL, NULL, "U", 0, NULL,

    "ExtActiveHigh",    ID_EXT_ACTIVEHI, KW, $HGH, OP_NONE, NULL, NULL, "V", 0, NULL,
    "ExtActiveLow",     ID_EXT_ACTIVELO, KW, $LOW, OP_NONE, NULL, NULL, "V", 0, NULL,

    "ExtShared",        ID_EXT_SHARED,   KW, $SHR, OP_NONE, NULL, NULL, "W", 0, NULL,
    "ExtExclusive",     ID_EXT_EXCLUSIVE,KW, $EXC, OP_NONE, NULL, NULL, "W", 0, NULL,

    "UnknownObj",       ID_UNKNOWN_OBJ,  KW, UNK,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "IntObj",           ID_INT_OBJ,      KW, INT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "StrObj",           ID_STR_OBJ,      KW, STR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "BuffObj",          ID_BUFF_OBJ,     KW, BUF,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "PkgObj",           ID_PKG_OBJ,      KW, PKG,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "FieldUnitObj",     ID_FIELDUNIT_OBJ,KW, FDU,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "DeviceObj",        ID_DEV_OBJ,      KW, DEV,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "EventObj",         ID_EVENT_OBJ,    KW, EVT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "MethodObj",        ID_METHOD_OBJ,   KW, MET,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "MutexObj",         ID_MUTEX_OBJ,    KW, MUT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "OpRegionObj",      ID_OPREGION_OBJ, KW, OPR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "PowerResObj",      ID_POWERRES_OBJ, KW, PWR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "ThermalZoneObj",   ID_THERMAL_OBJ,  KW, THM,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "BuffFieldObj",     ID_BUFFFIELD_OBJ,KW, BFD,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "DDBHandleObj",     ID_DDBHANDLE_OBJ,KW, DDB,  OP_NONE, NULL, NULL, "X", 0, NULL,

    "SMBQuick",            ID_SMBQUICK,            KW, SMBQ, OP_NONE, NULL, NULL, "Y", 0, NULL,
    "SMBSendReceive",      ID_SMBSENDRECEIVE,      KW, SMBS, OP_NONE, NULL, NULL, "Y", 0, NULL,
    "SMBByte",             ID_SMBBYTE,             KW, SMBB, OP_NONE, NULL, NULL, "Y", 0, NULL,
    "SMBWord",             ID_SMBWORD,             KW, SMBW, OP_NONE, NULL, NULL, "Y", 0, NULL,
    "SMBBlock",            ID_SMBBLOCK,            KW, SMBK, OP_NONE, NULL, NULL, "Y", 0, NULL,
    "SMBProcessCall",      ID_SMBPROCESSCALL,      KW, SMBP, OP_NONE, NULL, NULL, "Y", 0, NULL,
    "SMBBlockProcessCall", ID_SMBBLOCKPROCESSCALL, KW, SMBC, OP_NONE, NULL, NULL, "Y", 0, NULL,

    // Field Macros
    "Offset",           ID_OFFSET,       FM, 0, OP_NONE, NULL, "B",  NULL, 0,  NULL,
    "AccessAs",         ID_ACCESSAS,     FM, 0, 0x01,    NULL, "Ke", "AY", AF, AccessAs,

    // Named Object Creators
    "BankField",        ID_BANKFIELD,    NO, 0, OP_BANKFIELD,  "NNCKkk","NNCKKK","OFUABC", FL|FM|LN|AF, BankField,
    "CreateBitField",   ID_BITFIELD,     NO, 0, OP_BITFIELD,   "CCN", "CPN", "UUb",0, NULL,
    "CreateByteField",  ID_BYTEFIELD,    NO, 0, OP_BYTEFIELD,  "CCN", "CMN", "UUb",0, NULL,
    "CreateDWordField", ID_DWORDFIELD,   NO, 0, OP_DWORDFIELD, "CCN", "CMN", "UUb",0, NULL,
    "CreateField",      ID_CREATEFIELD,  NO, 0, OP_CREATEFIELD,"CCCN","CPCN","UUUb",0,NULL,
    "CreateWordField",  ID_WORDFIELD,    NO, 0, OP_WORDFIELD,  "CCN", "CMN", "UUb",0, NULL,
    "Device",           ID_DEVICE,       NO, 0, OP_DEVICE,     "N",    "N",      "d",      OL|LN|CC, NULL,
    "Event",            ID_EVENT,        NO, 0, OP_EVENT,      "N",    "N",      "e",      0, NULL,
    "Field",            ID_FIELD,        NO, 0, OP_FIELD,      "NKkk", "NKKK",   "OABC",   FL|FM|LN|AF, Field,
    "IndexField",       ID_IDXFIELD,     NO, 0, OP_IDXFIELD,   "NNKkk","NNKKK",  "FFABC",  FL|FM|LN|AF, IndexField,
    "Method",           ID_METHOD,       NO, 0, OP_METHOD,     "NKk",  "Nbk",    "m!E",    CL|OL|LN|AF|CC, Method,
    "Mutex",            ID_MUTEX,        NO, 0, OP_MUTEX,      "NB",   "NB",     "x",      0,  NULL,
    "OperationRegion",  ID_OPREGION,     NO, 0x80ff00ff,OP_OPREGION,"NECC","NECC","oDUU",  AF, OpRegion,
    "PowerResource",    ID_POWERRES,     NO, 0, OP_POWERRES,   "NBW",  "NBW",    "p",      OL|LN|CC, NULL,
    "Processor",        ID_PROCESSOR,    NO, 0, OP_PROCESSOR,  "NBDB", "NBDB",   "c",      OL|LN|CC, NULL,
    "ThermalZone",      ID_THERMALZONE,  NO, 0, OP_THERMALZONE,"N",    "N",      "t",      OL|LN|CC, NULL,

    // Type 1 Opcode Terms
    "Break",            ID_BREAK,        C1, 0, OP_BREAK,       NULL,  NULL,  NULL, 0, NULL,
    "BreakPoint",       ID_BREAKPOINT,   C1, 0, OP_BREAKPOINT,  NULL,  NULL,  NULL, 0, NULL,
    "Else",             ID_ELSE,         C1, 0, OP_ELSE,        NULL,  NULL,  NULL, AF|CL|OL|LN, Else,
    "Fatal",            ID_FATAL,        C1, 0, OP_FATAL,       "BDC", "BDC", "  U",0, NULL,
    "If",               ID_IF,           C1, 0, OP_IF,          "C",   "C",   "U",  CL|OL|LN, NULL,
    "Load",             ID_LOAD,         C1, 0, OP_LOAD,        "NS",  "NS",  "UU", 0, NULL,
    "Noop",             ID_NOP,          C1, 0, OP_NOP,         NULL,  NULL,  NULL, 0, NULL,
    "Notify",           ID_NOTIFY,       C1, 0, OP_NOTIFY,      "SC",  "SC",  "UU", 0, NULL,
    "Release",          ID_RELEASE,      C1, 0, OP_RELEASE,     "S",   "S",   "X",  0, NULL,
    "Reset",            ID_RESET,        C1, 0, OP_RESET,       "S",   "S",   "E",  0, NULL,
    "Return",           ID_RETURN,       C1, 0, OP_RETURN,      "C",   "C",   "U",  0, NULL,
    "Signal",           ID_SIGNAL,       C1, 0, OP_SIGNAL,      "S",   "S",   "E",  0, NULL,
    "Sleep",            ID_SLEEP,        C1, 0, OP_SLEEP,       "C",   "C",   "U",  0, NULL,
    "Stall",            ID_STALL,        C1, 0, OP_STALL,       "C",   "C",   "U",  0, NULL,
    "Unload",           ID_UNLOAD,       C1, 0, OP_UNLOAD,      "S",   "S",   "U",  0, NULL,
    "While",            ID_WHILE,        C1, 0, OP_WHILE,       "C",   "C",   "U",  CL|OL|LN, NULL,

    // Type 2 Opcode Terms
    "Acquire",          ID_ACQUIRE,      C2, 0, OP_ACQUIRE,     "SW",     "SW",     "X",  0, NULL,
    "Add",              ID_ADD,          C2, 0, OP_ADD,         "CCS",    "CCs",    "UUU",0, NULL,
    "And",              ID_AND,          C2, 0, OP_AND,         "CCS",    "CCs",    "UUU",0, NULL,
    "Concatenate",      ID_CONCAT,       C2, 0, OP_CONCAT,      "CCS",    "CCS",    "UUU",0, NULL,
    "CondRefOf",        ID_CONDREFOF,    C2, 0, OP_CONDREFOF,   "SS",     "SS",     "UU", 0, NULL,
    "Decrement",        ID_DECREMENT,    C2, 0, OP_DECREMENT,   "S",      "S",      "U",  0, NULL,
    "DerefOf",		ID_DEREFOF,	 C2, 0, OP_DEREFOF,	"C",      "C",	    "U",  0, NULL,
    "Divide",           ID_DIVIDE,       C2, 0, OP_DIVIDE,      "CCSS",   "CCss",   "UUUU",0,NULL,
    "FindSetLeftBit",   ID_FINDSETLBIT,  C2, 0, OP_FINDSETLBIT, "CS",     "Cs",     "UU", 0, NULL,
    "FindSetRightBit",  ID_FINDSETRBIT,  C2, 0, OP_FINDSETRBIT, "CS",     "Cs",     "UU", 0, NULL,
    "FromBCD",          ID_FROMBCD,      C2, 0, OP_FROMBCD,     "CS",     "Cs",     "UU", 0, NULL,
    "Increment",        ID_INCREMENT,    C2, 0, OP_INCREMENT,   "S",      "S",      "U",  0, NULL,
    "Index",            ID_INDEX,     RO|C2, 0, OP_INDEX,       "CCS",    "CMs",    "UUU",0, NULL,
    "LAnd",             ID_LAND,         C2, 0, OP_LAND,        "CC",     "CC",     "UU", 0, NULL,
    "LEqual",           ID_LEQ,          C2, 0, OP_LEQ,         "CC",     "CC",     "UU", 0, NULL,
    "LGreater",         ID_LG,           C2, 0, OP_LG,          "CC",     "CC",     "UU", 0, NULL,
    "LGreaterEqual",    ID_LGEQ,         C2, 0, OP_LGEQ,        "CC",     "CC",     "UU", 0, NULL,
    "LLess",            ID_LL,           C2, 0, OP_LL,          "CC",     "CC",     "UU", 0, NULL,
    "LLessEqual",       ID_LLEQ,         C2, 0, OP_LLEQ,        "CC",     "CC",     "UU", 0, NULL,
    "LNot",             ID_LNOT,         C2, 0, OP_LNOT,        "C",      "C",      "U",  0, NULL,
    "LNotEqual",        ID_LNOTEQ,       C2, 0, OP_LNOTEQ,      "CC",     "CC",     "UU", 0, NULL,
    "LOr",              ID_LOR,          C2, 0, OP_LOR,         "CC",     "CC",     "UU", 0, NULL,
    "Match",            ID_MATCH,        C2, 0, OP_MATCH,       "CKCKCC", "CKCKCC", "UFUFUU",AF,Match,
    "Multiply",         ID_MULTIPLY,     C2, 0, OP_MULTIPLY,    "CCS",    "CCs",    "UUU",0, NULL,
    "NAnd",             ID_NAND,         C2, 0, OP_NAND,        "CCS",    "CCs",    "UUU",0, NULL,
    "NOr",              ID_NOR,          C2, 0, OP_NOR,         "CCS",    "CCs",    "UUU",0, NULL,
    "Not",              ID_NOT,          C2, 0, OP_NOT,         "CS",     "Cs",     "UU", 0, NULL,
    "ObjectType",       ID_OBJTYPE,      C2, 0, OP_OBJTYPE,     "S",      "S",      "U",  0, NULL,
    "Or",               ID_OR,           C2, 0, OP_OR,          "CCS",    "CCs",    "UUU",0, NULL,
    "RefOf",            ID_REFOF,        C2, 0, OP_REFOF,       "S",      "S",      "U",  0, NULL,
    "ShiftLeft",        ID_SHIFTL,       C2, 0, OP_SHIFTL,      "CCS",    "CCs",    "UUU",0, NULL,
    "ShiftRight",       ID_SHIFTR,       C2, 0, OP_SHIFTR,      "CCS",    "CCs",    "UUU",0, NULL,
    "SizeOf",           ID_SIZEOF,       C2, 0, OP_SIZEOF,      "S",      "S",      "U",  0, NULL,
    "Store",            ID_STORE,        C2, 0, OP_STORE,       "CS",     "CS",     "UU", 0, NULL,
    "Subtract",         ID_SUBTRACT,     C2, 0, OP_SUBTRACT,    "CCS",    "CCs",    "UUU",0, NULL,
    "ToBCD",            ID_TOBCD,        C2, 0, OP_TOBCD,       "CS",     "Cs",     "UU", 0, NULL,
    "Wait",             ID_WAIT,         C2, 0, OP_WAIT,        "SC",     "SC",     "E",  0, NULL,
    "XOr",              ID_XOR,          C2, 0, OP_XOR,         "CCS",    "CCs",    "UUU",0, NULL,

    // PNP Macros
    "ResourceTemplate", ID_RESTEMP,      DO, 0, OP_BUFFER, NULL, "",       NULL, ML|AF|AV|LN,ResourceTemplate,
    "StartDependentFnNoPri",ID_STARTDEPFNNOPRI,PM,0,0x30,  NULL, "",       NULL, ML|AF,   AddSmallOffset,
    "StartDependentFn", ID_STARTDEPFN,   PM, 0, 0x31,      NULL, "BB",     NULL, ML|AF,   StartDependentFn,
    "EndDependentFn",   ID_ENDDEPFN,     PM, 0, 0x38,      NULL, "",       NULL, AF,      AddSmallOffset,
    "IRQNoFlags",       ID_IRQNOFLAGS,   PM, 0, 0x22,      NULL, "r",      NULL, BL|AV,   IRQDesc,
    "IRQ",              ID_IRQ,          PM, 0, 0x23,      NULL, "KKkr",   "GHI",BL|AV,   IRQDesc,
    "DMA",              ID_DMA,          PM, 0, 0x2a,      NULL, "KKKr",   "JKL",BL|AV,   DMADesc,
    "IO",               ID_IO,           PM, 0, 0x47,      NULL, "KWWBBr", "M",  AF,      IODesc,
    "FixedIO",          ID_FIXEDIO,      PM, 0, 0x4b,      NULL, "WBr",    NULL, AF,      FixedIODesc,
    "VendorShort",      ID_VENDORSHORT,  PM, 0, OP_NONE,   NULL, "r",      NULL, BL|AV,   VendorShort,
    "Memory24",         ID_MEMORY24,     PM, 0, 0x81,      NULL, "KWWWWr", "N",  AF,      Memory24Desc,
    "VendorLong",       ID_VENDORLONG,   PM, 0, 0x84,      NULL, "r",      NULL, BL|AV,   VendorLong,
    "Memory32",         ID_MEMORY32,     PM, 0, 0x85,      NULL, "KDDDDr", "N",  AF,      Memory32Desc,
    "Memory32Fixed",    ID_MEMORY32FIXED,PM, 0, 0x86,      NULL, "KDDr",   "N",  AF,      FixedMemory32Desc,
    "DWORDMemory",      ID_DWORDMEMORY,  PM, 0, 0x87,      NULL, "kkkkkKDDDDDbzr","OPQRSN",AF,  DWordMemDesc,
    "DWORDIO",          ID_DWORDIO,      PM, 0, 0x87,      NULL, "kkkkkDDDDDbzr", "OQRPT", AF,  DWordIODesc,
    "WORDIO",           ID_WORDIO,       PM, 0, 0x88,      NULL, "kkkkkWWWWWbzr", "OQRPT", AF,  WordIODesc,
    "WORDBusNumber",    ID_WORDBUSNUMBER,PM, 0, 0x88,      NULL, "kkkkWWWWWbzr",  "OQRP",  AF,  WordBusNumDesc,
    "Interrupt",        ID_INTERRUPT,    PM, 0, 0x89,      NULL, "kKKkbzr",       "OGHI",DD|AV, InterruptDesc,
    "QWORDMemory",	ID_QWORDMEMORY,	 PM, 0, 0x8a,      NULL, "kkkkkKQQQQQbzr","OPQRSN",AF,  QWordMemDesc,
    "QWORDIO",		ID_QWORDIO,	 PM, 0, 0x8a,	   NULL, "kkkkkQQQQQbzr", "OQRPT", AF,  QWordIODesc,

    NULL,               0,               0,  0, OP_NONE,   NULL, NULL, NULL, 0, NULL
};

#define INVALID  OPCLASS_INVALID
#define DATAOBJ  OPCLASS_DATA_OBJ
#define NAMEOBJ  OPCLASS_NAME_OBJ
#define CONSTOBJ OPCLASS_CONST_OBJ
#define CODEOBJ  OPCLASS_CODE_OBJ
#define ARGOBJ   OPCLASS_ARG_OBJ
#define LOCALOBJ OPCLASS_LOCAL_OBJ

BYTE OpClassTable[256] =
{ //0x00                0x01                0x02                0x03
    CONSTOBJ,           CONSTOBJ,           INVALID,            INVALID,
  //0x04                0x05                0x06                0x07
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0x08                0x09                0x0a                0x0b
    CODEOBJ,            INVALID,            DATAOBJ,            DATAOBJ,
  //0x0c                0x0d                0x0e                0x0f
    DATAOBJ,            DATAOBJ,            INVALID,            INVALID,
  //0x10                0x11                0x12                0x13
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x14                0x15                0x16                0x17
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0x18                0x19                0x1a                0x1b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x1c                0x1d                0x1e                0x1f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x20                0x21                0x22                0x23
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x24                0x25                0x26                0x27
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x28                0x29                0x2a                0x2b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x2c                0x2d                0x2e                0x2f
    INVALID,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x30                0x31                0x32                0x33
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x34                0x35                0x36                0x37
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x38                0x39                0x3a                0x3b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x3c                0x3d                0x3e                0x3f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x40                0x41                0x42                0x43
    INVALID,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x44                0x45                0x46                0x47
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x48                0x49                0x4a                0x4b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x4c                0x4d                0x4e                0x4f
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x50                0x51                0x52                0x53
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x54                0x55                0x56                0x57
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x58                0x59                0x5a                0x5b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            INVALID,
  //0x5c                0x5d                0x5e                0x5f
    NAMEOBJ,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x60                0x61                0x62                0x63
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x64                0x65                0x66                0x67
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x68                0x69                0x6a                0x6b
    ARGOBJ,             ARGOBJ,             ARGOBJ,             ARGOBJ,
  //0x6c                0x6d                0x6e                0x6f
    ARGOBJ,             ARGOBJ,             ARGOBJ,             INVALID,
  //0x70                0x71                0x72                0x73
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x74                0x75                0x76                0x77
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x78                0x79                0x7a                0x7b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x7c                0x7d                0x7e                0x7f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x80                0x81                0x82                0x83
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x84                0x85                0x86                0x87
    INVALID,            INVALID,            CODEOBJ,            CODEOBJ,
  //0x88                0x89                0x8a                0x8b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x8c                0x8d                0x8e                0x8f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x90                0x91                0x92                0x93
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x94                0x95                0x96                0x97
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0x98                0x99                0x9a                0x9b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x9c                0x9d                0x9e                0x9f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xa0                0xa1                0xa2                0xa3
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0xa4                0xa5                0xa6                0xa7
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0xa8                0xa9                0xaa                0xab
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xac                0xad                0xae                0xaf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb0                0xb1                0xb2                0xb3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb4                0xb5                0xb6                0xb7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb8                0xb9                0xba                0xbb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xbc                0xbd                0xbe                0xbf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc0                0xc1                0xc2                0xc3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc4                0xc5                0xc6                0xc7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc8                0xc9                0xca                0xcb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xcc                0xcd                0xce                0xcf
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0xd0                0xd1                0xd2                0xd3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd4                0xd5                0xd6                0xd7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd8                0xd9                0xda                0xdb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xdc                0xdd                0xde                0xdf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe0                0xe1                0xe2                0xe3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe4                0xe5                0xe6                0xe7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe8                0xe9                0xea                0xeb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xec                0xed                0xee                0xef
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf0                0xf1                0xf2                0xf3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf4                0xf5                0xf6                0xf7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf8                0xf9                0xfa                0xfb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xfc                0xfd                0xfe                0xff
    INVALID,            INVALID,            INVALID,            CONSTOBJ
};

OPMAP ExOpClassTable[] =
{
    EXOP_MUTEX,         CODEOBJ,
    EXOP_EVENT,         CODEOBJ,
    EXOP_CONDREFOF,     CODEOBJ,
    EXOP_CREATEFIELD,   CODEOBJ,
    EXOP_LOAD,          CODEOBJ,
    EXOP_STALL,         CODEOBJ,
    EXOP_SLEEP,         CODEOBJ,
    EXOP_ACQUIRE,       CODEOBJ,
    EXOP_SIGNAL,        CODEOBJ,
    EXOP_WAIT,          CODEOBJ,
    EXOP_RESET,         CODEOBJ,
    EXOP_RELEASE,       CODEOBJ,
    EXOP_FROMBCD,       CODEOBJ,
    EXOP_TOBCD,         CODEOBJ,
    EXOP_UNLOAD,        CODEOBJ,
    EXOP_REVISION,      CODEOBJ,
    EXOP_DEBUG,         CODEOBJ,
    EXOP_FATAL,         CODEOBJ,
    EXOP_OPREGION,      CODEOBJ,
    EXOP_FIELD,         CODEOBJ,
    EXOP_DEVICE,        CODEOBJ,
    EXOP_PROCESSOR,     CODEOBJ,
    EXOP_POWERRES,      CODEOBJ,
    EXOP_THERMALZONE,   CODEOBJ,
    EXOP_IDXFIELD,      CODEOBJ,
    EXOP_BANKFIELD,     CODEOBJ,
    0,                  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\token.h ===
/*** token.h - Token definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    09/04/96
 *
 *  This file contains the implementation constants,
 *  imported/exported data types, exported function
 *  prototypes of the token.c module.
 *
 *  MODIFICATIONS
 */

#ifndef _TOKEN_H
#define _TOKEN_H

/*** Constants
 */

// GetToken return values
//   return value is the token type if it is positive
//   return value is the error number if it is negative

// Error values (negative)
#define TOKERR_NONE             0
#define TOKERR_EOF              (TOKERR_BASE - 0)
#define TOKERR_NO_MATCH         (TOKERR_BASE - 1)
#define TOKERR_ASSERT_FAILED    (TOKERR_BASE - 2)

// TOKERR_LANG must always be the last TOKERR from the above list
#define TOKERR_LANG             TOKERR_ASSERT_FAILED

// Token type
#define TOKTYPE_NULL            0

#define TOKTYPE_LANG            TOKTYPE_NULL

// Identifier token types
#define ID_USER                 -1      //user identifier

#define ID_LANG                 0       //language specific ID base

//Token flags values
#define TOKF_NOIGNORESPACE      0x0001
#define TOKF_CACHED             0x8000

//Match token flags
#define MTF_NOT_ERR             0x00000001
#define MTF_ANY_VALUE           0x00000002

/***    Exported data types
 */

#define MAX_TOKEN_LEN           255

typedef struct token_s TOKEN;
typedef TOKEN *PTOKEN;
typedef int (LOCAL *PFNTOKEN)(int, PTOKEN);

struct token_s
{
    PLINE       pline;
    PFNTOKEN    *papfnToken;
    WORD        wfToken;
    int         iTokenType;
    LONGLONG    llTokenValue;
    WORD        wTokenLine;
    WORD        wTokenPos;
    WORD        wErrLine;
    WORD        wErrPos;
    WORD        wTokenLen;
    char        szToken[MAX_TOKEN_LEN + 1];
  #ifdef TUNE
    WORD        *pawcTokenType;
  #endif
};

/***    Imported data types
 */

/***    Exported function prototypes
 */

#ifdef TUNE
PTOKEN EXPORT OpenToken(FILE *pfileSrc, PFNTOKEN *apfnToken,
                        WORD *pawcTokenType);
#else
PTOKEN EXPORT OpenToken(FILE *pfileSrc, PFNTOKEN *apfnToken);
#endif
VOID EXPORT CloseToken(PTOKEN ptoken);
int EXPORT GetToken(PTOKEN ptoken);
int EXPORT UnGetToken(PTOKEN ptoken);
int EXPORT MatchToken(PTOKEN ptoken, int iTokenType, LONG lTokenValue,
                      DWORD dwfMatch, PSZ pszErrMsg);
VOID EXPORT PrintTokenErr(PTOKEN ptoken, PSZ pszErrMsg, BOOL fErr);

#endif  //ifndef _TOKEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\unasm.h ===
/*** unasm.h - Unassembler Private Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/05/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _UNASM_H
#define _UNASM_H

#ifdef _UNASM_LIB

//
// Constant definitions
//

#ifndef MODNAME
  #define MODNAME             "UnAsm"
#endif

// Error codes
#define ASLERR_NONE                     0
#define ASLERR_OUT_OF_MEM               -1
#define ASLERR_OPEN_FILE                -2
#define ASLERR_SEEK_FILE                -3
#define ASLERR_READ_FILE                -4
#define ASLERR_GET_TABLE                -5
#define ASLERR_CHECKSUM                 -6
#define ASLERR_INVALID_OPCODE           -7
#define ASLERR_INTERNAL_ERROR           -8
#define ASLERR_NAME_TOO_LONG            -9
#define ASLERR_NSOBJ_NOT_FOUND          -10
#define ASLERR_INVALID_NAME             -11
#define ASLERR_INVALID_ARGTYPE          -12
#define ASLERR_INVALID_OBJTYPE          -13
#define ASLERR_NSOBJ_EXIST              -14

// gdwfASL flags
#define ASLF_UNASM              0x00000001
#define ASLF_GENASM             0x00000002
#define ASLF_GENSRC             0x00000004

//
// Imported data
//
extern DWORD gdwfASL;
extern PNSOBJ gpnsNameSpaceRoot;
extern PNSOBJ gpnsCurrentScope;
extern PNSOBJ gpnsCurrentOwner;
extern PSZ gpszAMLFile;
extern PSZ gpszTabSig;

#endif  //ifdef _UNASM_LIB

#ifndef MEMALLOC
  #define MEMALLOC malloc
#endif

#ifndef MEMFREE
  #define MEMFREE free
#endif

//
// Type definitions
//
typedef int (*PFNPRINT)(PVOID, PSZ, ...);

//
// Local function prototypes
//
int LOCAL UnAsmHeader(PSZ pszAMLName, PDESCRIPTION_HEADER pdh,
                      PFNPRINT pfnPrint, PVOID pv);
VOID LOCAL DumpBytes(PBYTE pb, DWORD dwLen, PFNPRINT pfnPrint, PVOID pv);
VOID LOCAL DumpCode(PBYTE pbOp, PFNPRINT pfnPrint, PVOID pv);
VOID LOCAL PrintIndent(int iLevel, PFNPRINT pfnPrint, PVOID pv);
BYTE LOCAL FindOpClass(BYTE bOp, POPMAP pOpTable);
PASLTERM LOCAL FindOpTerm(DWORD dwOpcode);
PASLTERM LOCAL FindKeywordTerm(char cKWGroup, BYTE bDate);
int LOCAL UnAsmOpcode(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv);
int LOCAL UnAsmDataObj(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv);
int LOCAL UnAsmNameObj(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv, PNSOBJ *ppns,
                       char c);
int LOCAL ParseNameTail(PBYTE *ppbOp, PSZ pszBuff, int iLen);
int LOCAL UnAsmTermObj(PASLTERM pterm, PBYTE *ppbOp, PFNPRINT pfnPrint,
                       PVOID pv);
int LOCAL UnAsmSuperName(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv);
int LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, DWORD dwTermData,
                    PBYTE *ppbOp, PNSOBJ *ppns, PFNPRINT pfnPrint, PVOID pv);
DWORD LOCAL ParsePackageLen(PBYTE *ppbOp, PBYTE *ppbOpNext);
int LOCAL UnAsmDataList(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv);
int LOCAL UnAsmPkgList(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv);
int LOCAL UnAsmFieldList(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint,
                         PVOID pv);
int LOCAL UnAsmField(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv,
                     PDWORD pdwBitPos);
int LOCAL CreateObject(PTOKEN ptoken, PSZ pszName, char c, PNSOBJ *ppns);
int LOCAL CreateScopeObj(PSZ pszName, PNSOBJ *ppns);
BYTE LOCAL ComputeDataChkSum(PBYTE pb, DWORD dwLen);

//
// Exported function prototypes
//
int LOCAL UnAsmFile(PSZ pszAMLName, PFNPRINT pfnPrint, PVOID pv);
int LOCAL BuildNameSpace(PSZ pszAMLName, DWORD dwAddr, PBYTE pb);
int LOCAL UnAsmAML(PSZ pszAMLName, DWORD dwAddr, PBYTE pb, PFNPRINT pfnPrint,
                   PVOID pv);
int LOCAL UnAsmScope(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv);

#endif  //ifndef _UNASM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\battc\battc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    battc.c

Abstract:

    Battery Class Driver

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "battcp.h"

#include <initguid.h>
#include <batclass.h>


WMIGUIDREGINFO BattWmiGuidList[BattWmiTotalGuids] =
{
    {
        &BATTERY_STATUS_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_RUNTIME_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_TEMPERATURE_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_FULL_CHARGED_CAPACITY_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_CYCLE_COUNT_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_STATIC_DATA_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_STATUS_CHANGE_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    },
    {
        &BATTERY_TAG_CHANGE_WMI_GUID, 1, WMIREG_FLAG_INSTANCE_PDO
    }
};


//
// Prototypes
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );





#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,BatteryClassInitializeDevice)
#pragma alloc_text(PAGE,BatteryClassUnload)
#pragma alloc_text(PAGE,BatteryClassIoctl)
#endif


#if DEBUG
    #if DBG
        ULONG       BattDebug = BATT_ERROR|BATT_WARN;
    #else
        ULONG       BattDebug = 0x0;
    #endif

    ULONG           NextDeviceNum = 0;  // Used to assign a unique number to each device for debugging.

#endif


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{

    return STATUS_SUCCESS;
}





NTSTATUS
BATTERYCLASSAPI
BatteryClassInitializeDevice (
    IN PBATTERY_MINIPORT_INFO MiniportInfo,
    IN PVOID *ClassData
    )
/*++

Routine Description:

    Initializes a new battery class device.

    N.B. The caller needs to reserve 1 IRP stack location for the
    battery class driver

Arguments:

    MiniportInfo - Pointer to registration structure for driver
                   registering as a battery miniport

    ClassData    - Returned battery class handle for use by the
                   miniport when invoking furture battery class functions

Return Value:

    On sucess the battery has been registered.

--*/
{
    PBATT_NP_INFO           BattNPInfo;
    PBATT_INFO              BattInfo;

    NTSTATUS                status  = STATUS_SUCCESS;

    PAGED_CODE();

#if DEBUG
    if (MiniportInfo->DeviceName && MiniportInfo->DeviceName->Buffer) {
        BattPrint ((BATT_TRACE), ("BattC (%d): InitializeDevice (Pdo = 0x%08lx) (DeviceName = %ws)\n", NextDeviceNum, MiniportInfo->Pdo, MiniportInfo->DeviceName->Buffer));
    } else {
        BattPrint ((BATT_TRACE), ("BattC (%d): InitializeDevice (Pdo = 0x%08lx)\n", NextDeviceNum, MiniportInfo->Pdo));
    }
#endif

    if (MiniportInfo->MajorVersion != BATTERY_CLASS_MAJOR_VERSION) {
        return STATUS_REVISION_MISMATCH;
    }


    //
    // Allocate space for the class info to be kept with this device instance
    //

    BattNPInfo = ExAllocatePoolWithTag(NonPagedPool, sizeof(BATT_NP_INFO), 'ttaB');
    if (!BattNPInfo) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    BattInfo = ExAllocatePoolWithTag(PagedPool, sizeof(BATT_INFO), 'ttaB');
    if (!BattInfo) {
        ExFreePool (BattNPInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory (BattNPInfo, sizeof(*BattNPInfo));
    RtlZeroMemory (BattInfo, sizeof(*BattInfo));


    //
    // Capture Miniport info
    //

    RtlCopyMemory (&BattInfo->Mp, MiniportInfo, sizeof(*MiniportInfo));


    //
    // Initilize class driver values
    //

    KeInitializeTimer (&BattNPInfo->WorkerTimer);
    KeInitializeTimer (&BattNPInfo->TagTimer);
    KeInitializeDpc (&BattNPInfo->WorkerDpc, BattCWorkerDpc, BattNPInfo);
    KeInitializeDpc (&BattNPInfo->TagDpc, BattCTagDpc, BattNPInfo);
    ExInitializeWorkItem (&BattNPInfo->WorkerThread, BattCWorkerThread, BattNPInfo);
    ExInitializeFastMutex (&BattNPInfo->Mutex);
    BattNPInfo->TagNotified = TRUE;
    BattNPInfo->StatusNotified = TRUE;

    BattNPInfo->BattInfo = BattInfo;
#if DEBUG
    BattInfo->BattNPInfo = BattNPInfo;
#endif

    BattInfo->Tag = BATTERY_TAG_INVALID;
    InitializeListHead (&BattInfo->IoQueue);
    InitializeListHead (&BattInfo->StatusQueue);
    InitializeListHead (&BattInfo->TagQueue);
    InitializeListHead (&BattInfo->WmiQueue);

    //
    // Removal lock initialization
    //
    BattNPInfo->WantToRemove = FALSE;
    //
    // InUseCount is set to 2.  1 lock is always held until the removal time.
    //
    // 1 additional lock is held for the worker thread which only releases it
    // at removal time.  Rather than aquiring and releasing each time, it just
    // checks WantToRemove to determine if it should release the lock.  
    // This means that the worker thread must be queued at least once after 
    // WantToRemove is set to TRUE.
    //
    BattNPInfo->InUseCount = 2;
    KeInitializeEvent(&BattNPInfo->ReadyToRemove, SynchronizationEvent, FALSE);

#if DEBUG // Set device Number for debug prints.
    BattNPInfo->DeviceNum = NextDeviceNum;
    NextDeviceNum++;
#endif

    *ClassData = BattNPInfo;


    //
    // Check to see if this is a battery other than the composite
    //

    if (MiniportInfo->Pdo) {

        // Blank UNICODE_STRING so IoRegisterDeviceInterface will allocate space.
        RtlInitUnicodeString (&BattInfo->SymbolicLinkName, NULL);

        //
        //  Create the symbolic link
        //

        status = IoRegisterDeviceInterface(
                            MiniportInfo->Pdo,
                            (LPGUID)&GUID_DEVICE_BATTERY,
                            NULL,
                            &BattInfo->SymbolicLinkName);

        if (NT_SUCCESS(status)) {

            //
            //  Now set the symbolic link for the association and store it..
            //

            BattPrint ((BATT_NOTE), ("BattC (%d): Making SetDeviceInterfaceState call.\n", BattNPInfo->DeviceNum));

            status = IoSetDeviceInterfaceState(&BattInfo->SymbolicLinkName, TRUE);

            if (status == STATUS_OBJECT_NAME_EXISTS) {
                // The device interface was already enabled.  Continue anyway.
                BattPrint ((BATT_WARN), ("BattC (%d): Got STATUS_OBJECT_NAME_EXISTS for SetDeviceInterfaceState\n", BattNPInfo->DeviceNum));

                status = STATUS_SUCCESS;
            }
        }
    }

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassInitializeDevice (status = 0x%08lx).\n", BattNPInfo->DeviceNum, status));

    return status;
}   // BatteryClassInitializeDevice






NTSTATUS
BATTERYCLASSAPI
BatteryClassUnload (
    IN PVOID ClassData
    )
/*++

Routine Description:

    Called by the miniport when it has received a remove request.
    The miniclass driver must syncronize itself so that this API is
    not called while any of the others are not yet completed.

Arguments:

    ClassData   - Handle to class driver

Return Value:

    This routine must not fail.  It returns STATUS_SUCCESS

--*/
{
    NTSTATUS            status;
    PBATT_INFO          BattInfo;
    PBATT_NP_INFO       BattNPInfo;


    PAGED_CODE();

    BattNPInfo = (PBATT_NP_INFO) ClassData;
    BattInfo = BattNPInfo->BattInfo;

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassUnload called.\n", BattNPInfo->DeviceNum));


    //
    //  Disable the symbolic link
    //

    ASSERT(BattInfo->SymbolicLinkName.Buffer);

    status = IoSetDeviceInterfaceState(&BattInfo->SymbolicLinkName, FALSE);
    if (!NT_SUCCESS(status)) {
        BattPrint (BATT_ERROR, ("BattC (%d) Unload: IoSetDeviceInterface returned 0x%08lx\n", BattNPInfo->DeviceNum, status));
    }

    //
    // Syncronization with the worker thread.
    // We can't return because the worker may be in the middle of something.
    // By returning, the battery class driver gives up the right to call miniport routines.
    //
    // This needs to be done before canceling the timers so that the worker
    // thread doesn't reset them.
    //

    BattNPInfo->WantToRemove = TRUE;

    //
    // Cancel timers
    // If a timer had been waiting,we need to release the remove lock that was
    // aquired before the timer was set since it will not be released in the DPC.
    //
    if (KeCancelTimer (&BattNPInfo->WorkerTimer)) {
        // Release Removal Lock
        // "InUseCount can never be 0 after this operation.
        InterlockedDecrement(&BattNPInfo->InUseCount);
        BattPrint ((BATT_LOCK), ("BatteryClassUnload: Released WorkerTimer remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

    }
    if (KeCancelTimer (&BattNPInfo->TagTimer)) {
        // Release Removal Lock
        // "InUseCount can never be 0 after this operation.
        InterlockedDecrement(&BattNPInfo->InUseCount);
        BattPrint ((BATT_LOCK), ("BatteryClassUnload: Released TagTimer remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

    }

    //
    // Queue the worker thread once more to make sure that the remove lock for
    // the worker thread is released.
    //
    BattCQueueWorker (BattNPInfo, FALSE);

    // Finish syncronization
    if (InterlockedDecrement (&BattNPInfo->InUseCount) > 0) {
        KeWaitForSingleObject (&BattNPInfo->ReadyToRemove,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL
                               );
    }
    BattPrint ((BATT_LOCK), ("BatteryClassUnload: Done waiting for remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));


    //
    // Free Structures
    //
    ExFreePool (BattInfo->SymbolicLinkName.Buffer);
    ExFreePool (BattInfo);
    ExFreePool (BattNPInfo);


    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassUnload returning.\n", BattNPInfo->DeviceNum));

    return STATUS_SUCCESS;
}




NTSTATUS
BATTERYCLASSAPI
BatteryClassIoctl (
    IN PVOID ClassData,
    IN PIRP Irp
    )
/*++

Routine Description:

    Called by the miniport to handle battery ioctl requests.  If handled,
    the battery class driver owns the IRP.  If not handled, it belongs to
    the caller.

Arguments:

    ClassData   - Handle to class driver

    Irp         - ICOTL irp to check

Return Value:

    If handled, the battery class driver owns the IRP and will complete it
    once its handled; otherwise, the error STATUS_NOT_SUPPORTED is returned.

--*/
{
    NTSTATUS            status;
    PBATT_INFO          BattInfo;
    PBATT_NP_INFO       BattNPInfo;
    PIO_STACK_LOCATION  IrpSp;


    PAGED_CODE();

    BattNPInfo = (PBATT_NP_INFO) ClassData;
    BattInfo = BattNPInfo->BattInfo;

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassIoctl called.\n", BattNPInfo->DeviceNum));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Assume it's not our IRP
    //

    status = STATUS_NOT_SUPPORTED;

    //
    // Check IOCTL code to see if it's our IRP
    //

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_BATTERY_QUERY_TAG:
        case IOCTL_BATTERY_QUERY_INFORMATION:
        case IOCTL_BATTERY_SET_INFORMATION:
        case IOCTL_BATTERY_QUERY_STATUS:

            //
            // Acquire remove lock.
            // We don't want to queue anything more if we're being removed.
            //

            InterlockedIncrement (&BattNPInfo->InUseCount);
            BattPrint ((BATT_LOCK), ("BatteryClassIoctl: Aqcuired remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

            if (BattNPInfo->WantToRemove == TRUE) {
                if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
                    KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
                }
                BattPrint ((BATT_LOCK), ("BatteryClassIoctl: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

                status = STATUS_DEVICE_REMOVED;

            } else {

                //
                // Irp to handle.  Put it in the queue worker threads list
                //

                status = STATUS_PENDING;
                Irp->IoStatus.Status = STATUS_PENDING;
                IoMarkIrpPending (Irp);
                ExAcquireFastMutex (&BattNPInfo->Mutex);
                InsertTailList (&BattInfo->IoQueue, &Irp->Tail.Overlay.ListEntry);
                ExReleaseFastMutex (&BattNPInfo->Mutex);
                BattCQueueWorker (BattNPInfo, FALSE);

                //
                // Release Remove Lock.
                //

                if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
                    KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
                }
                BattPrint ((BATT_LOCK), ("BatteryClassIoctl: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));
            }

            break;

        default:
            BattPrint ((BATT_ERROR|BATT_IOCTL),
                      ("BattC (%d): unknown battery ioctl - %x\n",
                      BattNPInfo->DeviceNum,
                      IrpSp->Parameters.DeviceIoControl.IoControlCode));
            break;
    }

    if ((status != STATUS_PENDING) && (status != STATUS_NOT_SUPPORTED)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassIoctl returning (status = 0x%08lx).\n", BattNPInfo->DeviceNum, status));

    return status;
}



NTSTATUS
BATTERYCLASSAPI
BatteryClassStatusNotify (
    IN PVOID ClassData
    )
/*++

Routine Description:

    Called by the miniport to signify that something interesting concerning
    the battery status has occured.  Calling this function will cause the
    battery class driver to obtain the battery status if there are any pending
    status requests pending.

    If the miniport supports SetNotify from the class driver, then the miniport
    only needs to call this function once when the notification crtierea is
    met.

    If the miniport does not support SetNotify from the class driver, then
    the class driver will poll (at a slow rate) but the miniport should still
    call this function at least when the batteries power status changes such
    that timely updates of at least the power status will occur in the UI.

Arguments:

    ClassData   - Handle to class driver

Return Value:

    Status

--*/
{
    PBATT_NP_INFO   BattNPInfo;

    BattNPInfo = (PBATT_NP_INFO) ClassData;

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassStatusNotify called\n", BattNPInfo->DeviceNum));

    InterlockedExchange (&BattNPInfo->StatusNotified, 1);
    InterlockedExchange (&BattNPInfo->TagNotified, 1);
    BattCQueueWorker (BattNPInfo, TRUE);
    return STATUS_SUCCESS;
}


NTSTATUS
BATTERYCLASSAPI
BatteryClassSystemControl (
    IN  PVOID ClassData,
    IN  PWMILIB_CONTEXT WmiLibContext,
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP Irp,
    OUT PSYSCTL_IRP_DISPOSITION Disposition
    )
/*++

Routine Description:

    The miniport driver calls this instead of WmiSystemControl.

Arguments:

    ClassData   - Handle to class driver

    The other parameters are the parameters for WmiSystemControl.

Return Value:

    STATUS_SUCCESS or one of the following error codes:

    STATUS_INVALID_DEVICE_REQUEST

    STATUS_WMI_GUID_NOT_FOUND

    STATUS_WMI_INSTANCE_NOT_FOUND

--*/

{
    NTSTATUS            status = STATUS_NOT_SUPPORTED;
    PBATT_INFO          BattInfo;
    PBATT_NP_INFO       BattNPInfo;
    PIO_STACK_LOCATION  IrpSp;


    PAGED_CODE();

    BattNPInfo = (PBATT_NP_INFO) ClassData;
    BattInfo = BattNPInfo->BattInfo;
    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryClassSystemControl called.\n", BattNPInfo->DeviceNum));

    //
    // Initialize the WmiLibContext structure if this is the first time.
    //
    if (BattInfo->WmiLibContext.GuidCount == 0) {
        RtlCopyMemory(&BattInfo->WmiLibContext,     // Copy all callback routines set by minidriver
                      WmiLibContext,
                      sizeof(*WmiLibContext));

        BattInfo->WmiLibContext.GuidCount = WmiLibContext->GuidCount + BattWmiTotalGuids;
        BattInfo->WmiGuidIndex = WmiLibContext->GuidCount;
        BattInfo->WmiLibContext.GuidList = ExAllocatePoolWithTag(PagedPool, BattInfo->WmiLibContext.GuidCount * sizeof(WMIGUIDREGINFO), 'ttaB');
        if (!BattInfo->WmiLibContext.GuidList) {
            //
            // Fail.  If the miniclass tries again, this might work the next time.
            //
            BattInfo->WmiLibContext.GuidCount = 0;
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            *Disposition = IrpNotCompleted;
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory(BattInfo->WmiLibContext.GuidList,
                      WmiLibContext->GuidList,
                      WmiLibContext->GuidCount * sizeof(WMIGUIDREGINFO));
        RtlCopyMemory(&BattInfo->WmiLibContext.GuidList [WmiLibContext->GuidCount],
                      BattWmiGuidList, BattWmiTotalGuids * sizeof(WMIGUIDREGINFO));
    }

    //
    // Acquire remove lock.
    // We don't want to queue anything more if we're being removed.
    //

    InterlockedIncrement (&BattNPInfo->InUseCount);
    BattPrint ((BATT_LOCK), ("BatteryClassSystemControl: Aqcuired remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

    if (BattNPInfo->WantToRemove == TRUE) {
        if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
            KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
        }
        BattPrint ((BATT_LOCK), ("BatteryClassSystemControl: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

        status = STATUS_DEVICE_REMOVED;

    } else {

        status = WmiSystemControl(&BattInfo->WmiLibContext,
                                  DeviceObject,
                                  Irp,
                                  Disposition);

        BattPrint ((BATT_DEBUG), ("BattC (%d): BatteryClassSystemControl Returned from WmiSystemControl (status = 0x%08x).\n", BattNPInfo->DeviceNum, status));

        //
        // For IRP_MN_REGINFO BattC needs to add additional data to the IRP
        // about the battery class MOF resource.
        //

        if ((*Disposition == IrpNotCompleted) &&
            ((IrpSp->MinorFunction == IRP_MN_REGINFO) ||
            (IrpSp->MinorFunction == IRP_MN_REGINFO_EX)) &&
            (IrpSp->Parameters.WMI.DataPath == WMIREGISTER)) {

            //
            // Original structure
            //
            PWMIREGINFO regInfoPtr = IrpSp->Parameters.WMI.Buffer;

            BattPrint ((BATT_DEBUG), ("BattC (%d): BatteryClassSystemControl Adding Resource.\n", BattNPInfo->DeviceNum));
            //
            // If WmiSystemControl returned STATUS_BUFFER_TOO_SMALL or entered
            // the correct size as a ULONG in IoStatus.Information.
            // Increase the required size to accomodate battery class data
            // before returning
            //

            if (Irp->IoStatus.Information == sizeof(ULONG) ||
                Irp->IoStatus.Status == STATUS_BUFFER_TOO_SMALL) {

                //
                // Aditional battery class data includes one WMIREGINFO structure
                // Followed strings for the regstry path and resource name.
                // (Plus two WCHARS because these need to be counted strings.)
                // Round this up to the nearest 8 bytes.
                //
                regInfoPtr->BufferSize =
                    (regInfoPtr->BufferSize +
                     sizeof(WMIREGINFO) +
                     sizeof(MOFREGISTRYPATH) +
                     sizeof(MOFRESOURCENAME) + 2 * sizeof(WCHAR) + 7) & 0xFFFFFFF8;

                BattPrint ((BATT_DEBUG), ("BattC (%d): BatteryClassSystemControl Buffer Too Small:\n"
                                          "    Information = %08x\n"
                                          "    BufferSize = %08x\n"
                                          "    NewSize = %08x\n",
                                          BattNPInfo->DeviceNum,
                                          Irp->IoStatus.Information,
                                          IrpSp->Parameters.WMI.BufferSize,
                                          regInfoPtr->BufferSize));

                //
                // Make sure IRP is set up to fail correctly.
                //
                Irp->IoStatus.Information = sizeof(ULONG);
                Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                ULONG size;
                PWCHAR tempString;

                //
                // Assume that there is only one WmiRegInfo Structure so far.
                //
                ASSERT (regInfoPtr->NextWmiRegInfo == 0);

                regInfoPtr->NextWmiRegInfo = (regInfoPtr->BufferSize + 7) & 0xFFFFFFF8;
                size = regInfoPtr->NextWmiRegInfo + sizeof(WMIREGINFO) +
                       sizeof(MOFRESOURCENAME) + sizeof(MOFREGISTRYPATH) + 2 * sizeof(WCHAR);

                //
                // Set BufferSize Whether we succeed or not.
                //
                ((PWMIREGINFO)IrpSp->Parameters.WMI.Buffer)->BufferSize = size;

                if (size > IrpSp->Parameters.WMI.BufferSize) {
                    //
                    // If WmiSystemControl was successful, but there isnt room
                    // for the extra data, this request needs to fail
                    //
                    Irp->IoStatus.Information = sizeof(ULONG);
                    Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
                    status = STATUS_BUFFER_TOO_SMALL;
                    BattPrint ((BATT_DEBUG), ("BattC (%d): BatteryClassSystemControl Buffer Too Small.\n"
                                              "    BufferSize = %08x\n"
                                              "    Size = %08x\n",
                                              BattNPInfo->DeviceNum,
                                              IrpSp->Parameters.WMI.BufferSize,
                                              size));
                } else {
                    Irp->IoStatus.Information = size;

                    BattPrint ((BATT_DEBUG), ("BattC (%d): BatteryClassSystemControl Munging Structures:\n"
                                              "    Buffer = %08x\n"
                                              "    temp = %08x\n",
                                              BattNPInfo->DeviceNum,
                                              (ULONG_PTR) IrpSp->Parameters.WMI.Buffer,
                                              (ULONG_PTR) regInfoPtr));
                    //
                    // Intialize new structure
                    //

                    // Set teporary pointer to point at data structure we are adding.
                    (ULONG_PTR)regInfoPtr += (ULONG_PTR)regInfoPtr->NextWmiRegInfo;

                    regInfoPtr->BufferSize = sizeof(WMIREGINFO) +
                                             sizeof(MOFRESOURCENAME) +
                                             sizeof(MOFREGISTRYPATH) + 2 * sizeof(WCHAR);
                    regInfoPtr->NextWmiRegInfo = 0;

                    // Initialize RegistryPath counted string.
                    regInfoPtr->RegistryPath = sizeof(WMIREGINFO);
                    tempString = (PWCHAR)((ULONG_PTR)regInfoPtr + sizeof(WMIREGINFO));
                    *tempString++ = sizeof(MOFREGISTRYPATH);
                    RtlCopyMemory(tempString, MOFREGISTRYPATH, sizeof(MOFREGISTRYPATH));

                    // Initialize MofResourceName counted string.
                    regInfoPtr->MofResourceName = sizeof(WMIREGINFO) + sizeof(MOFREGISTRYPATH) + sizeof(WCHAR);
                    tempString = (PWCHAR)((ULONG_PTR)regInfoPtr + regInfoPtr->MofResourceName);
                    *tempString++ = sizeof(MOFRESOURCENAME);
                    RtlCopyMemory(tempString, MOFRESOURCENAME, sizeof(MOFRESOURCENAME));

                    regInfoPtr->GuidCount = 0;

                }
            }
        }

        //
        // Release Remove Lock.
        //

        if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
            KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
        }
        BattPrint ((BATT_LOCK), ("BatteryClassSystemControl: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));
    }

    return status;
}


NTSTATUS
BATTERYCLASSAPI
BatteryClassQueryWmiDataBlock(
    IN PVOID ClassData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PBATT_NP_INFO       BattNPInfo = (PBATT_NP_INFO) ClassData;
    PBATT_INFO          BattInfo = BattNPInfo->BattInfo;
    PBATT_WMI_REQUEST   WmiRequest;

    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       size = 0;

    PAGED_CODE();

    BattPrint ((BATT_TRACE|BATT_WMI), ("Entered BatteryClassQueryWmiDataBlock\n"));

    //
    // Don't need to acquire remove lock.  It is already held by SystemControl.
    //

    switch (GuidIndex - BattInfo->WmiGuidIndex) {
    case BattWmiStatusId:
        size = sizeof (BATTERY_WMI_STATUS);
        break;
    case BattWmiRuntimeId:
        size = sizeof (BATTERY_WMI_RUNTIME);
        break;
    case BattWmiTemperatureId:
        size = sizeof (BATTERY_WMI_TEMPERATURE);
        break;
    case BattWmiFullChargedCapacityId:
        size = sizeof (BATTERY_WMI_FULL_CHARGED_CAPACITY);
        break;
    case BattWmiCycleCountId:
        size = sizeof (BATTERY_WMI_CYCLE_COUNT);
        break;
    case BattWmiStaticDataId:
        size = sizeof(BATTERY_WMI_STATIC_DATA)+4*MAX_BATTERY_STRING_SIZE*sizeof(WCHAR);
          // data plus 4 strings
        break;
    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    if (status != STATUS_WMI_GUID_NOT_FOUND) {
        if (OutBufferSize < size ) {
            status = STATUS_BUFFER_TOO_SMALL;
            *InstanceLengthArray = size;

            status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  size,
                                  IO_NO_INCREMENT);
            return status;
        }

        WmiRequest = ExAllocatePoolWithTag (PagedPool, sizeof(BATT_WMI_REQUEST), 'ttaB');
        if (!WmiRequest) {
            BattPrint((BATT_ERROR), ("Failed to allocate memory for WMI request\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  size,
                                  IO_NO_INCREMENT);
            return status;
        }

        WmiRequest->DeviceObject = DeviceObject;
        WmiRequest->Irp = Irp;
        WmiRequest->GuidIndex = GuidIndex - BattInfo->WmiGuidIndex;
        WmiRequest->InstanceLengthArray = InstanceLengthArray;
        WmiRequest->OutBufferSize = OutBufferSize;
        WmiRequest->Buffer = Buffer;

        ExAcquireFastMutex (&BattNPInfo->Mutex);
        InsertTailList (&BattInfo->WmiQueue, &WmiRequest->ListEntry);
        ExReleaseFastMutex (&BattNPInfo->Mutex);
        BattCQueueWorker (BattNPInfo, FALSE);

        status = STATUS_PENDING;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\asl\unasm.c ===
/*** unasm.c - Unassemble AML file and convert to Intel .ASM file
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/01/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

//
// Local data
//
int giLevel = 0;

/***LP  UnAsmFile - Unassemble AML file
 *
 *  ENTRY
 *      pszAMLName -> AML file name
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmFile(PSZ pszAMLName, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    PBYTE pb = NULL;
    DWORD dwAddr = 0;
    int fhAML = 0;
    ULONG dwLen = 0;

    ENTER((1, "UnAsmFile(AMLName=%s,pfnPrint=%p,pv=%p)\n",
           pszAMLName, pfnPrint, pv));
    ASSERT(pfnPrint != NULL);

    if (gpszAMLFile != NULL)
    {
        if ((fhAML = _open(gpszAMLFile, _O_BINARY | _O_RDONLY)) == -1)
        {
            ERROR(("UnAsmFile: failed to open AML file - %s", gpszAMLFile));
            rc = ASLERR_OPEN_FILE;
        }
        else if ((pb = MEMALLOC(sizeof(DESCRIPTION_HEADER))) == NULL)
        {
            ERROR(("UnAsmFile: failed to allocate description header block"));
            rc = ASLERR_OUT_OF_MEM;
        }
        else if (_read(fhAML, pb, sizeof(DESCRIPTION_HEADER)) !=
                 sizeof(DESCRIPTION_HEADER))
        {
            ERROR(("UnAsmFile: failed to read description header block"));
            rc = ASLERR_READ_FILE;
        }
        else if (_lseek(fhAML, 0, SEEK_SET) == -1)
        {
            ERROR(("UnAsmFile: failed seeking to beginning of AML file"));
            rc = ASLERR_SEEK_FILE;
        }
        else
        {
            dwLen = ((PDESCRIPTION_HEADER)pb)->Length;
            MEMFREE(pb);
            if ((pb = MEMALLOC(dwLen)) == NULL)
            {
                ERROR(("UnAsmFile: failed to allocate AML file buffer"));
                rc = ASLERR_OUT_OF_MEM;
            }
            else if (_read(fhAML, pb, dwLen) != (int)dwLen)
            {
                ERROR(("UnAsmFile: failed to read AML file"));
                rc = ASLERR_OUT_OF_MEM;
            }
        }
    }
  #ifdef __UNASM
    else
    {
        DWORD dwTableSig = (gdwfASL & ASLF_DUMP_NONASL)? *((PDWORD)pszAMLName):
                                                         *((PDWORD)gpszTabSig);

        ASSERT(gpszTabSig != NULL);

        if ((pb = GetTableBySig(dwTableSig, &dwAddr)) != NULL)
        {
            dwLen = ((PDESCRIPTION_HEADER)pb)->Length;
        }
        else
        {
            rc = ASLERR_GET_TABLE;
        }
    }
  #endif

    if (rc == ASLERR_NONE)
    {
        rc = UnAsmAML(pszAMLName, dwAddr, pb, pfnPrint, pv);
    }

    if (pb != NULL)
    {
        MEMFREE(pb);
    }

    if (fhAML != 0)
    {
        _close(fhAML);
    }

    EXIT((1, "UnAsmFile=%d\n", rc));
    return rc;
}       //UnAsmFile

/***LP  BuildNameSpace - Do a NameSpace building pass
 *
 *  ENTRY
 *      pszAMLName -> AML file name
 *      dwAddr - physical address of table
 *      pb -> AML buffer
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL BuildNameSpace(PSZ pszAMLName, DWORD dwAddr, PBYTE pb)
{
    typedef struct _AMLName
    {
        struct _AMLName *panNext;
        PSZ              pszAMLName;
        DWORD            dwAddr;
    } AMLNAME, *PAMLNAME;
    int rc = ASLERR_NONE;
    static PAMLNAME panAMLNames = NULL;
    PAMLNAME pan;

    ENTER((2, "BuildNameSpace(AMLName=%s,Addr=%x,pb=%p)\n",
           pszAMLName, dwAddr, pb));

    for (pan = panAMLNames; pan != NULL; pan = pan->panNext)
    {
        if ((strcmp(pszAMLName, pan->pszAMLName) == 0) &&
            (dwAddr == pan->dwAddr))
        {
            break;
        }
    }

    if (pan == NULL)
    {
        if ((pan = MEMALLOC(sizeof(AMLNAME))) != NULL)
        {
            DWORD dwLen = ((PDESCRIPTION_HEADER)pb)->Length;

            pan->pszAMLName = pszAMLName;
            pan->dwAddr = dwAddr;
            pan->panNext = panAMLNames;
            panAMLNames = pan;
            pb += sizeof(DESCRIPTION_HEADER);
            rc = UnAsmScope(&pb, pb + dwLen - sizeof(DESCRIPTION_HEADER), NULL,
                            NULL);
        }
        else
        {
            ERROR(("BuildNameSpace: failed to allocate AMLName entry"));
            rc = ASLERR_OUT_OF_MEM;
        }
    }

    EXIT((2, "BuildNameSpace=%d\n", rc));
    return rc;
}       //BuildNameSpace

/***LP  UnAsmAML - Unassemble AML buffer
 *
 *  ENTRY
 *      pszAMLName -> AML file name
 *      dwAddr - physical address of table
 *      pb -> AML buffer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmAML(PSZ pszAMLName, DWORD dwAddr, PBYTE pb, PFNPRINT pfnPrint,
                   PVOID pv)
{
    int rc = ASLERR_NONE;
    PDESCRIPTION_HEADER pdh = (PDESCRIPTION_HEADER)pb;

    ENTER((2, "UnAsmAML(AMLName=%s,Addr=%x,pb=%p,pfnPrint=%p,pv=%p)\n",
           pszAMLName, dwAddr, pb, pfnPrint, pv));

    ASSERT(gpnsNameSpaceRoot != NULL);
    gpnsCurrentOwner = NULL;
    gpnsCurrentScope = gpnsNameSpaceRoot;

    if (ComputeDataChkSum(pb, pdh->Length) != 0)
    {
        ERROR(("UnAsmAML: failed to verify AML checksum"));
        rc = ASLERR_CHECKSUM;
    }
    else if ((rc = BuildNameSpace(pszAMLName, dwAddr, pb)) == ASLERR_NONE)
    {
        gpbOpTop = gpbOpBegin = pb;
        if ((rc = UnAsmHeader(pszAMLName, pdh, pfnPrint, pv)) == ASLERR_NONE)
        {
            pb += sizeof(DESCRIPTION_HEADER);
            rc = UnAsmScope(&pb, pb + pdh->Length - sizeof(DESCRIPTION_HEADER),
                            pfnPrint, pv);

            if ((rc == ASLERR_NONE) && (pfnPrint != NULL))
            {
                pfnPrint(pv, "\n");
            }
        }
    }

    EXIT((2, "UnAsmAML=%d\n", rc));
    return rc;
}       //UnAsmAML

/***LP  UnAsmHeader - Unassemble table header
 *
 *  ENTRY
 *      pszAMLName -> AML file name
 *      pdh -> DESCRIPTION_HEADER
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmHeader(PSZ pszAMLName, PDESCRIPTION_HEADER pdh,
                      PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    char szSig[sizeof(pdh->Signature) + 1] = {0};
    char szOEMID[sizeof(pdh->OEMID) + 1] = {0};
    char szOEMTableID[sizeof(pdh->OEMTableID) + 1] = {0};
    char szCreatorID[sizeof(pdh->CreatorID) + 1] = {0};

    ENTER((2, "UnAsmHeader(AMLName=%s,pdh=%p,pfnPrint=%p,pv=%p)\n",
           pszAMLName, pdh, pfnPrint, pv));

    if (pfnPrint != NULL)
    {
        strncpy(szSig, (PSZ)&pdh->Signature, sizeof(pdh->Signature));
        strncpy(szOEMID, (PSZ)pdh->OEMID, sizeof(pdh->OEMID));
        strncpy(szOEMTableID, (PSZ)pdh->OEMTableID, sizeof(pdh->OEMTableID));
        strncpy(szCreatorID, (PSZ)pdh->CreatorID, sizeof(pdh->CreatorID));

        if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
        {
            pfnPrint(pv, "; ");
        }

        pfnPrint(pv, "// CreatorID=%s\tCreatorRev=%x.%x.%d\n",
                 szCreatorID, pdh->CreatorRev >> 24,
                 (pdh->CreatorRev >> 16) & 0xff, pdh->CreatorRev & 0xffff);

        if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
        {
            pfnPrint(pv, "; ");
        }

        pfnPrint(pv, "// FileLength=%d\tFileChkSum=0x%x\n\n",
                 pdh->Length, pdh->Checksum);

        if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
        {
            pfnPrint(pv, "; ");
        }

        pfnPrint(pv, "DefinitionBlock(\"%s\", \"%s\", 0x%02x, \"%s\", \"%s\", 0x%08x)",
                 pszAMLName, szSig, pdh->Revision, szOEMID, szOEMTableID,
                 pdh->OEMRevision);
    }

    EXIT((2, "UnAsmHeader=%d\n", rc));
    return rc;
}       //UnAsmHeader

/***LP  DumpBytes - Dump byte stream in ASM file
 *
 *  ENTRY
 *      pb -> buffer
 *      dwLen - length to dump
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpBytes(PBYTE pb, DWORD dwLen, PFNPRINT pfnPrint, PVOID pv)
{
    int i;
    #define MAX_LINE_BYTES  8

    ENTER((2, "DumpBytes(pb=%p,Len=%x,pfnPrint=%p,pv=%p)\n",
           pb, dwLen, pfnPrint, pv));

    while (dwLen > 0)
    {
        pfnPrint(pv, "\tdb\t0%02xh", *pb);
        for (i = 1; i < MAX_LINE_BYTES; ++i)
        {
            if ((int)dwLen - i > 0)
            {
                pfnPrint(pv, ", 0%02xh", pb[i]);
            }
            else
            {
                pfnPrint(pv, "      ");
            }
        }

        pfnPrint(pv, "\t; ");
        for (i = 0; (dwLen > 0) && (i < MAX_LINE_BYTES); ++i)
        {
            pfnPrint(pv, "%c", ((*pb >= ' ') && (*pb <= '~'))? *pb: '.');
            dwLen--;
            pb++;
        }

        pfnPrint(pv, "\n");
    }
    pfnPrint(pv, "\n");

    EXIT((2, "DumpBytes!\n"));
}       //DumpBytes

/***LP  DumpCode - Dump code stream in ASM file
 *
 *  ENTRY
 *      pbOp -> Opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpCode(PBYTE pbOp, PFNPRINT pfnPrint, PVOID pv)
{
    ENTER((2, "DumpCode(pbOp=%p,pfnPrint=%p,pv=%p)\n", pbOp, pfnPrint, pv));

    if (pfnPrint != NULL)
    {
        if (gdwfASL & ASLF_GENASM)
        {
            if (gpbOpBegin != pbOp)
            {
                pfnPrint(pv, "\n");
                pfnPrint(pv, "; %08x:\n", gpbOpBegin - gpbOpTop);
                DumpBytes(gpbOpBegin, (DWORD)(pbOp - gpbOpBegin), pfnPrint, pv);
                gpbOpBegin = pbOp;
            }
        }
        else
        {
            pfnPrint(pv, "\n");
        }
    }

    EXIT((2, "DumpCode!\n"));
}       //DumpCode

/***LP  PrintIndent - Print indent level
 *
 *  ENTRY
 *      iLevel - indent level
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintIndent(int iLevel, PFNPRINT pfnPrint, PVOID pv)
{
    int i;

    ENTER((3, "PrintIndent(Level=%d,pfnPrint=%p,pv=%p)\n",
           iLevel, pfnPrint, pv));

    if (pfnPrint != NULL)
    {
        if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
        {
            pfnPrint(pv, "; ");
        }

        for (i = 0; i < iLevel; ++i)
        {
            pfnPrint(pv,
                     ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))?
                     "| ": "    ");
        }
    }

    EXIT((3, "PrintIndent!\n"));
}       //PrintIndent

/***LP  FindOpClass - Find opcode class of extended opcode
 *
 *  ENTRY
 *      bOp - opcode
 *      pOpTable -> opcode table
 *
 *  EXIT-SUCCESS
 *      returns opcode class
 *  EXIT-FAILURE
 *      returns OPCLASS_INVALID
 */

BYTE LOCAL FindOpClass(BYTE bOp, POPMAP pOpTable)
{
    BYTE bOpClass = OPCLASS_INVALID;

    ENTER((2, "FindOpClass(Op=%x,pOpTable=%x)\n", bOp, pOpTable));

    while (pOpTable->bOpClass != 0)
    {
        if (bOp == pOpTable->bExOp)
        {
            bOpClass = pOpTable->bOpClass;
            break;
        }
        else
            pOpTable++;
    }

    EXIT((2, "FindOpClass=%x\n", bOpClass));
    return bOpClass;
}       //FindOpClass

/***LP  FindOpTerm - Find opcode in TermTable
 *
 *  ENTRY
 *      dwOpcode - opcode
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindOpTerm(DWORD dwOpcode)
{
    PASLTERM pterm = NULL;
    int i;

    ENTER((2, "FindOpTerm(Opcode=%x)\n", dwOpcode));

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwOpcode == dwOpcode) &&
            (TermTable[i].dwfTermClass &
             (TC_CONST_NAME | TC_SHORT_NAME | TC_NAMESPACE_MODIFIER |
              TC_DATA_OBJECT | TC_NAMED_OBJECT | TC_OPCODE_TYPE1 |
              TC_OPCODE_TYPE2)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    EXIT((2, "FindOpTerm=%p (Term=%s)\n", pterm, pterm? pterm->pszID: ""));
    return pterm;
}       //FindOpTerm

/***LP  FindKeywordTerm - Find keyword in TermTable
 *
 *  ENTRY
 *      cKWGroup - keyword group
 *      bData - data to match keyword
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindKeywordTerm(char cKWGroup, BYTE bData)
{
    PASLTERM pterm = NULL;
    int i;

    ENTER((2, "FindKeywordTerm(cKWGroup=%c,Data=%x)\n", cKWGroup, bData));

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwfTermClass == TC_KEYWORD) &&
            (TermTable[i].pszArgActions[0] == cKWGroup) &&
            ((bData & (BYTE)(TermTable[i].dwTermData >> 8)) ==
             (BYTE)(TermTable[i].dwTermData & 0xff)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    EXIT((2, "FindKeywordTerm=%p (Term=%s)\n", pterm, pterm? pterm->pszID: ""));
    return pterm;
}       //FindKeywordTerm

/***LP  UnAsmScope - Unassemble a scope
 *
 *  ENTRY
 *      ppbOp -> Opcode pointer
 *      pbEnd -> end of scope
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmScope(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;

    ENTER((2, "UnAsmScope(pbOp=%p,pbEnd=%p,pfnPrint=%p,pv=%p)\n",
           *ppbOp, pbEnd, pfnPrint, pv));

    DumpCode(*ppbOp, pfnPrint, pv);

    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "{\n");
    }
    giLevel++;

    while ((rc == ASLERR_NONE) && (*ppbOp < pbEnd))
    {
        PrintIndent(giLevel, pfnPrint, pv);
        rc = UnAsmOpcode(ppbOp, pfnPrint, pv);
        if (gpbOpBegin != *ppbOp)
        {
            DumpCode(*ppbOp, pfnPrint, pv);
        }
        else if (pfnPrint != NULL)
        {
            pfnPrint(pv, "\n");
        }
    }

    giLevel--;
    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "}");
    }

    EXIT((2, "UnAsmScope=%d\n", rc));
    return rc;
}       //UnAsmScope

/***LP  UnAsmOpcode - Unassemble an Opcode
 *
 *  ENTRY
 *      ppbOp -> Opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmOpcode(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    DWORD dwOpcode;
    BYTE bOp;
    PASLTERM pterm;
    char szUnAsmArgTypes[MAX_ARGS + 1];
    PNSOBJ pns;
    int i;

    ENTER((2, "UnAsmOpcode(pbOp=%p,pfnPrint=%p,pv=%p)\n",
           *ppbOp, pfnPrint, pv));

    if (**ppbOp == OP_EXT_PREFIX)
    {
        (*ppbOp)++;
        dwOpcode = (((DWORD)**ppbOp) << 8) | OP_EXT_PREFIX;
        bOp = FindOpClass(**ppbOp, ExOpClassTable);
    }
    else
    {
        dwOpcode = (DWORD)(**ppbOp);
        bOp = OpClassTable[**ppbOp];
    }

    switch (bOp)
    {
        case OPCLASS_DATA_OBJ:
            rc = UnAsmDataObj(ppbOp, pfnPrint, pv);
            break;

        case OPCLASS_NAME_OBJ:
            if (((rc = UnAsmNameObj(ppbOp, pfnPrint, pv, &pns, NSTYPE_UNKNOWN))
                 == ASLERR_NONE) &&
                (pns != NULL) &&
                (pns->ObjData.dwDataType == OBJTYPE_METHOD))
            {
                for (i = 0; i < (int)pns->ObjData.uipDataValue; ++i)
                {
                    szUnAsmArgTypes[i] = 'C';
                }
                szUnAsmArgTypes[i] = '\0';
                rc = UnAsmArgs(szUnAsmArgTypes, NULL, 0, ppbOp, NULL, pfnPrint,
                               pv);
            }
            break;

        case OPCLASS_ARG_OBJ:
        case OPCLASS_LOCAL_OBJ:
        case OPCLASS_CODE_OBJ:
        case OPCLASS_CONST_OBJ:
            if ((pterm = FindOpTerm(dwOpcode)) == NULL)
            {
                ERROR(("UnAsmOpcode: invalid opcode 0x%x", dwOpcode));
                rc = ASLERR_INVALID_OPCODE;
            }
            else
            {
                (*ppbOp)++;
                rc = UnAsmTermObj(pterm, ppbOp, pfnPrint, pv);
            }
            break;

        default:
            ERROR(("UnAsmOpcode: invalid opcode class %d", bOp));
            rc = ASLERR_INTERNAL_ERROR;
    }

    EXIT((2, "UnAsmOpcode=%d\n", rc));
    return rc;
}       //UnAsmOpcode

/***LP  UnAsmDataObj - Unassemble data object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmDataObj(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    BYTE bOp = **ppbOp;

    ENTER((2, "UnAsmDataObj(pbOp=%p,bOp=%x,pfnPrint=%p,pv=%p)\n",
           *ppbOp, bOp, pfnPrint, pv));

    (*ppbOp)++;
    switch (bOp)
    {
        case OP_BYTE:
            if (pfnPrint != NULL)
            {
                pfnPrint(pv, "0x%x", **ppbOp);
            }
            *ppbOp += sizeof(BYTE);
            break;

        case OP_WORD:
            if (pfnPrint != NULL)
            {
                pfnPrint(pv, "0x%x", *((PWORD)*ppbOp));
            }
            *ppbOp += sizeof(WORD);
            break;

        case OP_DWORD:
            if (pfnPrint != NULL)
            {
                pfnPrint(pv, "0x%x", *((PDWORD)*ppbOp));
            }
            *ppbOp += sizeof(DWORD);
            break;

        case OP_STRING:
            if (pfnPrint != NULL)
            {
		PSZ psz;

		pfnPrint(pv, "\"");
		for (psz = (PSZ)*ppbOp; *psz != '\0'; psz++)
		{
		    if (*psz == '\\')
		    {
			pfnPrint(pv, "\\");
		    }
		    pfnPrint(pv, "%c", *psz);
		}
		pfnPrint(pv, "\"");
            }
            *ppbOp += strlen((PSZ)*ppbOp) + 1;
            break;

        default:
            ERROR(("UnAsmDataObj: unexpected opcode 0x%x", bOp));
            rc = ASLERR_INVALID_OPCODE;
    }

    EXIT((2, "UnAsmDataObj=%d\n", rc));
    return rc;
}       //UnAsmDataObj

/***LP  UnAsmNameObj - Unassemble name object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *      ppns -> to hold object found or created
 *      c - object type
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmNameObj(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv, PNSOBJ *ppns,
                       char c)
{
    int rc = ASLERR_NONE;
    char szName[MAX_NSPATH_LEN + 1];
    int iLen = 0;

    ENTER((2, "UnAsmNameObj(pbOp=%p,pfnPrint=%p,pv=%p,ppns=%p,c=%c)\n",
           *ppbOp, pfnPrint, pv, ppns, c));

    szName[0] = '\0';
    if (**ppbOp == OP_ROOT_PREFIX)
    {
        szName[iLen] = '\\';
        iLen++;
        (*ppbOp)++;
        rc = ParseNameTail(ppbOp, szName, iLen);
    }
    else if (**ppbOp == OP_PARENT_PREFIX)
    {
        szName[iLen] = '^';
        iLen++;
        (*ppbOp)++;
        while ((**ppbOp == OP_PARENT_PREFIX) && (iLen < MAX_NSPATH_LEN))
        {
            szName[iLen] = '^';
            iLen++;
            (*ppbOp)++;
        }

        if (**ppbOp == OP_PARENT_PREFIX)
        {
            ERROR(("UnAsmNameObj: name too long - \"%s\"", szName));
            rc = ASLERR_NAME_TOO_LONG;
        }
        else
        {
            rc = ParseNameTail(ppbOp, szName, iLen);
        }
    }
    else
    {
        rc = ParseNameTail(ppbOp, szName, iLen);
    }

    if (rc == ASLERR_NONE)
    {
        PNSOBJ pns = NULL;

        if (pfnPrint != NULL)
        {
            pfnPrint(pv, "%s", szName);
        }

        if (islower(c) && (gdwfASL & ASLF_UNASM) &&
            ((pfnPrint == NULL) ||
             (gpnsCurrentScope->ObjData.dwDataType == OBJTYPE_METHOD)))
        {
            rc = CreateObject(NULL, szName, (char)_toupper(c), &pns);
            if ((rc == ASLERR_NSOBJ_EXIST) &&
                (gpnsCurrentScope->ObjData.dwDataType == OBJTYPE_METHOD))
            {
                //
                // If we are creating an object inside a method scope, it
                // may already exist because we may have unassembled this
                // method before.  So it is not an error.
                //
                rc = ASLERR_NONE;
            }
        }
        else if ((rc = GetNameSpaceObj(szName, gpnsCurrentScope, &pns, 0)) ==
                 ASLERR_NSOBJ_NOT_FOUND)
        {
            if (c == NSTYPE_SCOPE)
            {
                rc = CreateScopeObj(szName, &pns);
            }
            else
            {
                rc = ASLERR_NONE;
            }
        }

        if (rc == ASLERR_NONE)
        {
            if ((c == NSTYPE_SCOPE) && (pns != NULL))
            {
                gpnsCurrentScope = pns;
            }

            if (ppns != NULL)
            {
                *ppns = pns;
            }
        }
    }

    EXIT((2, "UnAsmNameObj=%d (pns=%p)\n", rc, ppns? *ppns: 0));
    return rc;
}       //UnAsmNameObj

/***LP  ParseNameTail - Parse AML name tail
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pszBuff -> to hold parsed name
 *      iLen - index to tail of pszBuff
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL ParseNameTail(PBYTE *ppbOp, PSZ pszBuff, int iLen)
{
    int rc = ASLERR_NONE;
    int icNameSegs = 0;

    ENTER((2, "ParseNameTail(pbOp=%x,Name=%s,iLen=%d)\n",
           *ppbOp, pszBuff, iLen));

    //
    // We do not check for invalid NameSeg characters here and assume that
    // the compiler does its job not generating it.
    //
    if (**ppbOp == '\0')
    {
        //
        // There is no NameTail (i.e. either NULL name or name with just
        // prefixes.
        //
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_MULTI_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = (int)**ppbOp;
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_DUAL_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = 2;
    }
    else
        icNameSegs = 1;

    while ((icNameSegs > 0) && (iLen + sizeof(NAMESEG) < MAX_NSPATH_LEN))
    {
        strncpy(&pszBuff[iLen], (PSZ)(*ppbOp), sizeof(NAMESEG));
        iLen += sizeof(NAMESEG);
        *ppbOp += sizeof(NAMESEG);
        icNameSegs--;
        if ((icNameSegs > 0) && (iLen + 1 < MAX_NSPATH_LEN))
        {
            pszBuff[iLen] = '.';
            iLen++;
        }
    }

    if (icNameSegs > 0)
    {
        ERROR(("ParseNameTail: name too long - %s", pszBuff));
        rc = ASLERR_NAME_TOO_LONG;
    }
    else
    {
        pszBuff[iLen] = '\0';
    }

    EXIT((2, "ParseNameTail=%x (Name=%s)\n", rc, pszBuff));
    return rc;
}       //ParseNameTail

/***LP  UnAsmTermObj - Unassemble term object
 *
 *  ENTRY
 *      pterm -> term table entry
 *      ppbOp -> opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmTermObj(PASLTERM pterm, PBYTE *ppbOp, PFNPRINT pfnPrint,
                       PVOID pv)
{
    int rc = ASLERR_NONE;
    PBYTE pbEnd = NULL;
    PNSOBJ pnsScopeSave = gpnsCurrentScope;
    PNSOBJ pns = NULL;

    ENTER((2, "UnAsmTermObj(pterm=%p,Term=%s,pbOp=%p,pfnPrint=%p,pv=%p)\n",
           pterm, pterm->pszID, *ppbOp, pfnPrint, pv));

    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "%s", pterm->pszID);
    }

    if (pterm->dwfTerm & TF_PACKAGE_LEN)
    {
        ParsePackageLen(ppbOp, &pbEnd);
    }

    if (pterm->pszUnAsmArgTypes != NULL)
    {
        rc = UnAsmArgs(pterm->pszUnAsmArgTypes, pterm->pszArgActions,
                       pterm->dwTermData, ppbOp, &pns, pfnPrint, pv);
    }

    if (rc == ASLERR_NONE)
    {
        if (pterm->dwfTerm & TF_DATA_LIST)
        {
            rc = UnAsmDataList(ppbOp, pbEnd, pfnPrint, pv);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LIST)
        {
            rc = UnAsmPkgList(ppbOp, pbEnd, pfnPrint, pv);
        }
        else if (pterm->dwfTerm & TF_FIELD_LIST)
        {
            rc = UnAsmFieldList(ppbOp, pbEnd, pfnPrint, pv);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LEN)
        {
	    if ((pfnPrint == NULL) && (pterm->lID == ID_METHOD))
	    {
		//
		// We are in NameSpace building pass, so don't need to
		// go into methods.
		//
		*ppbOp = pbEnd;
	    }
	    else
	    {
                if (pterm->dwfTerm & TF_CHANGE_CHILDSCOPE)
                {
                    ASSERT(pns != NULL);
                    gpnsCurrentScope = pns;
                }

                rc = UnAsmScope(ppbOp, pbEnd, pfnPrint, pv);
	    }
        }
    }
    gpnsCurrentScope = pnsScopeSave;

    EXIT((2, "UnAsmTermObj=%d\n", rc));
    return rc;
}       //UnAsmTermObj

/***LP  UnAsmArgs - Unassemble arguments
 *
 *  ENTRY
 *      pszUnArgTypes -> UnAsm ArgTypes string
 *      pszArgActions -> Arg Action types
 *      dwTermData - Term data
 *      ppbOp -> opcode pointer
 *      ppns -> to hold created object
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, DWORD dwTermData,
                    PBYTE *ppbOp, PNSOBJ *ppns, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    static BYTE bArgData = 0;
    int iNumArgs, i;
    PASLTERM pterm;

    ENTER((2, "UnAsmArgs(UnAsmArgTypes=%s,ArgActions=%s,TermData=%x,pbOp=%p,ppns=%p,pfnPrint=%p,pv=%p)\n",
           pszUnAsmArgTypes, pszArgActions? pszArgActions: "", dwTermData,
           *ppbOp, ppns, pfnPrint, pv));

    iNumArgs = strlen(pszUnAsmArgTypes);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "(");
    }

    for (i = 0; i < iNumArgs; ++i)
    {
        if ((i != 0) && (pfnPrint != NULL))
        {
            pfnPrint(pv, ", ");
        }

        switch (pszUnAsmArgTypes[i])
        {
            case 'N':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmNameObj(ppbOp, pfnPrint, pv, ppns, pszArgActions[i]);
                break;

            case 'O':
                if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
                    (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
                {
                    pterm = FindOpTerm((DWORD)(**ppbOp));
                    
                    if(pterm)
                    {
                        (*ppbOp)++;
                        rc = UnAsmTermObj(pterm, ppbOp, pfnPrint, pv);
                    }
                    else
                    {
                        ASSERT(pterm != NULL);
                        rc = ASLERR_INVALID_OPCODE;
                    }
                }
                else
                {
                    rc = UnAsmDataObj(ppbOp, pfnPrint, pv);
                }
                break;

            case 'C':
                rc = UnAsmOpcode(ppbOp, pfnPrint, pv);
                break;

            case 'B':
                if (pfnPrint != NULL)
                {
                    pfnPrint(pv, "0x%x", **ppbOp);
                }

                *ppbOp += sizeof(BYTE);
                break;

            case 'E':
            case 'e':
            case 'K':
            case 'k':
                if ((pszUnAsmArgTypes[i] == 'K') ||
                    (pszUnAsmArgTypes[i] == 'E'))
                {
                    bArgData = **ppbOp;
                }

                if ((pszArgActions != NULL) && (pszArgActions[i] == '!'))
                {
                    if ((gdwfASL & ASLF_UNASM) && (*ppns != NULL))
                    {
                        (*ppns)->ObjData.uipDataValue = (DWORD)(**ppbOp & 0x07);
                    }

                    if (pfnPrint != NULL)
                    {
                        pfnPrint(pv, "0x%x", **ppbOp & 0x07);
                    }
                }
                else if (pfnPrint != NULL)
                {
                    pterm = FindKeywordTerm(pszArgActions[i], bArgData);
                    if (pterm != NULL)
                    {
                        pfnPrint(pv, "%s", pterm->pszID);
                    }
                    else
                    {
                        pfnPrint(pv, "0x%x", bArgData & dwTermData & 0xff);
                    }
                }

                if ((pszUnAsmArgTypes[i] == 'K') ||
                    (pszUnAsmArgTypes[i] == 'E'))
                {
                    *ppbOp += sizeof(BYTE);
                }
                break;

            case 'W':
                if (pfnPrint != NULL)
                {
                    pfnPrint(pv, "0x%x", *((PWORD)*ppbOp));
                }

                *ppbOp += sizeof(WORD);
                break;

            case 'D':
                if (pfnPrint != NULL)
                {
                    pfnPrint(pv, "0x%x", *((PDWORD)*ppbOp));
                }

                *ppbOp += sizeof(DWORD);
                break;

            case 'S':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmSuperName(ppbOp, pfnPrint, pv);
                break;

            default:
                ERROR(("UnAsmOpcode: invalid ArgType '%c'", pszUnAsmArgTypes[i]));
                rc = ASLERR_INVALID_ARGTYPE;
        }
    }

    if (pfnPrint != NULL)
    {
        pfnPrint(pv, ")");
    }

    EXIT((2, "UnAsmArgs=%d\n", rc));
    return rc;
}       //UnAsmArgs

/***LP  UnAsmSuperName - Unassemble supername
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmSuperName(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;

    ENTER((2, "UnAsmSuperName(pbOp=%p,pfnPrint=%p,pv=%p)\n",
           *ppbOp, pfnPrint, pv));

    if (**ppbOp == 0)
    {
        (*ppbOp)++;
    }
    else if ((**ppbOp == OP_EXT_PREFIX) && (*(*ppbOp + 1) == EXOP_DEBUG))
    {
        if (pfnPrint != NULL)
        {
            pfnPrint(pv, "Debug");
        }
        *ppbOp += 2;
    }
    else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
    {
        rc = UnAsmNameObj(ppbOp, pfnPrint, pv, NULL, NSTYPE_UNKNOWN);
    }
    else if ((**ppbOp == OP_INDEX) ||
             (OpClassTable[**ppbOp] == OPCLASS_ARG_OBJ) ||
             (OpClassTable[**ppbOp] == OPCLASS_LOCAL_OBJ))
    {
        rc = UnAsmOpcode(ppbOp, pfnPrint, pv);
    }
    else
    {
        ERROR(("UnAsmSuperName: invalid SuperName - 0x%02x", **ppbOp));
        rc = ASLERR_INVALID_NAME;
    }

    EXIT((2, "UnAsmSuperName=%d\n", rc));
    return rc;
}       //UnAsmSuperName

/***LP  ParsePackageLen - parse package length
 *
 *  ENTRY
 *      ppbOp -> instruction pointer
 *      ppbOpNext -> to hold pointer to next instruction (can be NULL)
 *
 *  EXIT
 *      returns package length
 */

DWORD LOCAL ParsePackageLen(PBYTE *ppbOp, PBYTE *ppbOpNext)
{
    DWORD dwLen;
    BYTE bFollowCnt, i;

    ENTER((2, "ParsePackageLen(pbOp=%x,ppbOpNext=%x)\n", *ppbOp, ppbOpNext));

    if (ppbOpNext != NULL)
        *ppbOpNext = *ppbOp;

    dwLen = (DWORD)(**ppbOp);
    (*ppbOp)++;
    bFollowCnt = (BYTE)((dwLen & 0xc0) >> 6);
    if (bFollowCnt != 0)
    {
        dwLen &= 0x0000000f;
        for (i = 0; i < bFollowCnt; ++i)
        {
            dwLen |= (DWORD)(**ppbOp) << (i*8 + 4);
            (*ppbOp)++;
        }
    }

    if (ppbOpNext != NULL)
        *ppbOpNext += dwLen;

    EXIT((2, "ParsePackageLen=%x (pbOp=%x,pbOpNext=%x)\n",
          dwLen, *ppbOp, ppbOpNext? *ppbOpNext: 0));
    return dwLen;
}       //ParsePackageLen

/***LP  UnAsmDataList - Unassemble data list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmDataList(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    int i;

    ENTER((2, "UnAsmDataList(pbOp=%p,pbEnd=%p,pfnPrint=%p,pv=%p)\n",
           *ppbOp, pbEnd, pfnPrint, pv));

    DumpCode(*ppbOp, pfnPrint, pv);

    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "{\n");
    }

    while (*ppbOp < pbEnd)
    {
        if (pfnPrint != NULL)
        {
            if ((gdwfASL & ASLF_GENASM) || !(gdwfASL & ASLF_GENSRC))
            {
                pfnPrint(pv, ";");
            }
            pfnPrint(pv, "\t0x%02x", **ppbOp);
        }

        (*ppbOp)++;
        for (i = 1; (*ppbOp < pbEnd) && (i < 12); ++i)
        {
            if (pfnPrint != NULL)
            {
                pfnPrint(pv, ", 0x%02x", **ppbOp);
            }
            (*ppbOp)++;
        }

        if (pfnPrint != NULL)
        {
            if (*ppbOp < pbEnd)
            {
                pfnPrint(pv, ",");
            }
            pfnPrint(pv, "\n");
        }
    }

    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "}");
    }

    EXIT((2, "UnAsmDataList=%d\n", rc));
    return rc;
}       //UnAsmDataList

/***LP  UnAsmPkgList - Unassemble package list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmPkgList(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    PASLTERM pterm;

    ENTER((2, "UnAsmPkgList(pbOp=%p,pbEnd=%p,pfnPrint=%p,pv=%p)\n",
           *ppbOp, pbEnd, pfnPrint, pv));

    DumpCode(*ppbOp, pfnPrint, pv);

    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "{\n");
    }
    giLevel++;

    while ((*ppbOp < pbEnd) && (rc == ASLERR_NONE))
    {
        PrintIndent(giLevel, pfnPrint, pv);

        if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
            (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
        {
            pterm = FindOpTerm((DWORD)(**ppbOp));
            ASSERT(pterm != NULL);
            (*ppbOp)++;
            rc = UnAsmTermObj(pterm, ppbOp, pfnPrint, pv);
        }
        else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
        {
            rc = UnAsmNameObj(ppbOp, pfnPrint, pv, NULL, NSTYPE_UNKNOWN);
        }
        else
        {
            rc = UnAsmDataObj(ppbOp, pfnPrint, pv);
        }

        if ((*ppbOp < pbEnd) && (rc == ASLERR_NONE) && (pfnPrint != NULL))
        {
            pfnPrint(pv, ",");
        }

        DumpCode(*ppbOp, pfnPrint, pv);
    }

    giLevel--;
    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "}");
    }

    EXIT((2, "UnAsmPkgList=%d\n", rc));
    return rc;
}       //UnAsmPkgList

/***LP  UnAsmFieldList - Unassemble field list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *      pfnPrint -> print function
 *      pv - print function parameter
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmFieldList(PBYTE *ppbOp, PBYTE pbEnd, PFNPRINT pfnPrint, PVOID pv)
{
    int rc = ASLERR_NONE;
    DWORD dwBitPos = 0;

    ENTER((2, "UnAsmFieldList(pbOp=%p,pbEnd=%p,pfnPrint=%p,pv=%p)\n",
           *ppbOp, pbEnd, pfnPrint, pv));

    DumpCode(*ppbOp, pfnPrint, pv);

    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "{\n");
    }
    giLevel++;

    while ((*ppbOp < pbEnd) && (rc == ASLERR_NONE))
    {
        PrintIndent(giLevel, pfnPrint, pv);
        if (((rc = UnAsmField(ppbOp, pfnPrint, pv, &dwBitPos)) ==
             ASLERR_NONE) &&
            (*ppbOp < pbEnd) && (pfnPrint != NULL))
        {
            pfnPrint(pv, ",");
        }
        DumpCode(*ppbOp, pfnPrint, pv);
    }

    giLevel--;
    PrintIndent(giLevel, pfnPrint, pv);
    if (pfnPrint != NULL)
    {
        pfnPrint(pv, "}");
    }

    EXIT((2, "UnAsmFieldList=%d\n", rc));
    return rc;
}       //UnAsmFieldList

/***LP  UnAsmField - Unassemble field
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pfnPrint -> print function
 *      pv - print function parameter
 *      pdwBitPos -> to hold cumulative bit position
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL UnAsmField(PBYTE *ppbOp, PFNPRINT pfnPrint, PVOID pv,
                     PDWORD pdwBitPos)
{
    int rc = ASLERR_NONE;

    ENTER((2, "UnAsmField(pbOp=%p,pfnPrint=%p,pv=%p,BitPos=%x)\n",
           *ppbOp, pfnPrint, pv, *pdwBitPos));

    if (**ppbOp == 0x01)
    {
        (*ppbOp)++;
        if (pfnPrint != NULL)
        {
            PASLTERM pterm;

            pterm = FindKeywordTerm('A', **ppbOp);
            if(pterm)
                pfnPrint(pv, "AccessAs(%s, 0x%x)",
                     pterm->pszID, *(*ppbOp + 1));
            else
                pfnPrint(pv, "FindKeywordTerm('A', **ppbOp); returned NULL");
        }
        *ppbOp += 2;
    }
    else
    {
        char szNameSeg[sizeof(NAMESEG) + 1];
        DWORD dwcbBits;

        if (**ppbOp == 0)
        {
            szNameSeg[0] = '\0';
            (*ppbOp)++;
        }
        else
        {
            strncpy(szNameSeg, (PSZ)*ppbOp, sizeof(NAMESEG));
            szNameSeg[4] = '\0';
            *ppbOp += sizeof(NAMESEG);
        }

        dwcbBits = ParsePackageLen(ppbOp, NULL);
        if (szNameSeg[0] == '\0')
        {
            if (pfnPrint != NULL)
            {
                if ((dwcbBits > 32) && (((*pdwBitPos + dwcbBits) % 8) == 0))
                {
                    pfnPrint(pv, "Offset(0x%x)", (*pdwBitPos + dwcbBits)/8);
                }
                else
                {
                    pfnPrint(pv, ", %d", dwcbBits);
                }
            }
        }
        else
        {
            if (pfnPrint != NULL)
            {
                pfnPrint(pv, "%s, %d", szNameSeg, dwcbBits);
            }

            if ((gdwfASL & ASLF_UNASM) && (pfnPrint == NULL))
            {
                rc = CreateObject(NULL, szNameSeg, NSTYPE_FIELDUNIT, NULL);
            }
        }

        *pdwBitPos += dwcbBits;
    }

    EXIT((2, "UnAsmField=%d\n", rc));
    return rc;
}       //UnAsmField

/***LP  CreateObject - Create NameSpace object for the term
 *
 *  ENTRY
 *      ptoken -> TOKEN
 *      pszName -> object name
 *      c - object type to be created
 *      ppns -> to hold object created
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL CreateObject(PTOKEN ptoken, PSZ pszName, char c, PNSOBJ *ppns)
{
    int rc = ASLERR_NONE;
    PNSOBJ pns;

    ENTER((2, "CreateObject(ptoken=%p,Name=%s,Type=%c)\n",
           ptoken, pszName, c));

    if (((rc = GetNameSpaceObj(pszName, gpnsCurrentScope, &pns, 0)) ==
         ASLERR_NONE) &&
        (pns->ObjData.dwDataType == OBJTYPE_EXTERNAL) ||
        ((rc = CreateNameSpaceObj(ptoken, pszName, gpnsCurrentScope,
                                  gpnsCurrentOwner, &pns, NSF_EXIST_ERR)) ==
         ASLERR_NONE))
    {
#ifndef _UNASM_LIB
        if (!(gdwfASL & ASLF_UNASM))
        {
            ASSERT(gpcodeScope->pnsObj == NULL);
            gpcodeScope->dwfCode |= CF_CREATED_NSOBJ;
            gpcodeScope->pnsObj = pns;
            pns->Context = gpcodeScope;
        }
#endif  //ifndef _UNASM_LIB

        switch (c)
        {
            case NSTYPE_UNKNOWN:
                break;

            case NSTYPE_FIELDUNIT:
                pns->ObjData.dwDataType = OBJTYPE_FIELDUNIT;
                break;

            case NSTYPE_DEVICE:
                pns->ObjData.dwDataType = OBJTYPE_DEVICE;
                break;

            case NSTYPE_EVENT:
                pns->ObjData.dwDataType = OBJTYPE_EVENT;
                break;

            case NSTYPE_METHOD:
                pns->ObjData.dwDataType = OBJTYPE_METHOD;
                break;

            case NSTYPE_MUTEX:
                pns->ObjData.dwDataType = OBJTYPE_MUTEX;
                break;

            case NSTYPE_OPREGION:
                pns->ObjData.dwDataType = OBJTYPE_OPREGION;
                break;

            case NSTYPE_POWERRES:
                pns->ObjData.dwDataType = OBJTYPE_POWERRES;
                break;

            case NSTYPE_PROCESSOR:
                pns->ObjData.dwDataType = OBJTYPE_PROCESSOR;
                break;

            case NSTYPE_THERMALZONE:
                pns->ObjData.dwDataType = OBJTYPE_THERMALZONE;
                break;

            case NSTYPE_OBJALIAS:
                pns->ObjData.dwDataType = OBJTYPE_OBJALIAS;
                break;

            case NSTYPE_BUFFFIELD:
                pns->ObjData.dwDataType = OBJTYPE_BUFFFIELD;
                break;

            default:
                ERROR(("CreateObject: invalid object type %c", c));
                rc = ASLERR_INVALID_OBJTYPE;
        }

        if (ppns != NULL)
        {
            *ppns = pns;
        }
    }

    EXIT((2, "CreateObject=%d\n", rc));
    return rc;
}       //CreateObject

/***LP  CreateScopeObj - Create Scope object
 *
 *  ENTRY
 *      pszName -> object name
 *      ppns -> to hold object created
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL CreateScopeObj(PSZ pszName, PNSOBJ *ppns)
{
    int rc = ASLERR_NONE;
    PNSOBJ pnsScope;
    PSZ psz;

    ENTER((2, "CreateScopeObj(Name=%s)\n", pszName));
    ASSERT(ppns != NULL);

    if ((psz = strrchr(pszName, '.')) != NULL)
    {
        *psz = '\0';
        if ((rc = GetNameSpaceObj(pszName, gpnsCurrentScope, &pnsScope, 0)) ==
            ASLERR_NSOBJ_NOT_FOUND)
        {
            rc = CreateScopeObj(pszName, &pnsScope);
        }
        *psz = '.';
        psz++;
    }
    else if (pszName[0] == '\\')
    {
        pnsScope = gpnsNameSpaceRoot;
        psz = &pszName[1];
    }
    else
    {
        pnsScope = gpnsCurrentScope;
        psz = pszName;
    }

    if ((rc == ASLERR_NONE) &&
        ((rc = CreateNameSpaceObj(NULL, psz, pnsScope, NULL, ppns,
                                  NSF_EXIST_OK)) == ASLERR_NONE))
    {
        (*ppns)->ObjData.dwDataType = OBJTYPE_EXTERNAL;
    }

    EXIT((2, "CreateScopeObj=%d (pns=%p)\n", rc, *ppns));
    return rc;
}       //CreateScopeObj

/***LP  ComputeDataChkSum - Compute checksum of a data buffer
 *
 *  ENTRY
 *      pb -> data buffer
 *      dwLen - size of data buffer
 *
 *  EXIT
 *      returns the checksum byte
 */

BYTE LOCAL ComputeDataChkSum(PBYTE pb, DWORD dwLen)
{
    BYTE bChkSum = 0;

    ENTER((1, "ComputeDataChkSum(pb=%p,Len=%ld)\n", pb, dwLen));

    while (dwLen > 0)
    {
        bChkSum = (BYTE)(bChkSum + *pb);
        pb++;
        dwLen--;
    }

    EXIT((1, "ComputeDataChkSum=%x\n", bChkSum));
    return bChkSum;
}       //ComputeDataChkSum
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\battc\battcp.h ===
#define BATTERYCLASS    1

#ifndef FAR
#define FAR
#endif

#include <wdm.h>
#include <wmistr.h>
#include <wmilib.h>
#include <batclass.h>

//
// Debug
//

#define DEBUG   DBG

#if DEBUG
    extern ULONG BattDebug;
    extern ULONG NextDeviceNum;
    #define BattPrint(l,m)    if(l & BattDebug) DbgPrint m
#else
    #define BattPrint(l,m)
#endif

#define BATT_LOW            0x00000001
#define BATT_NOTE           0x00000002
#define BATT_WARN           0x00000004
#define BATT_ERROR          0x00000008
#define BATT_TRACE          0x00000010
#define BATT_MP_ERROR       0x00000100
#define BATT_MP_DATA        0x00000200
#define BATT_IOCTL          0x00001000
#define BATT_IOCTL_DATA     0x00002000
#define BATT_IOCTL_QUEUE    0x00004000
#define BATT_WMI            0x00008000
#define BATT_LOCK           0x00010000
#define BATT_DEBUG          0x80000000


//
// Battery class info
//

#define NTMS    10000L                          // 1 millisecond is ten thousand 100ns
#define NTSEC   (NTMS * 1000L)
#define NTMIN   ((ULONGLONG) 60 * NTSEC)

#define SEC     1000
#define MIN     (60 * SEC)

#define MIN_STATUS_POLL_RATE        (3L * NTMIN)
// This is the slowest rate at which we should ever poll
// the battery when doing polling.

#define MAX_STATUS_POLL_RATE        (20 * NTSEC)
// This is in general the fastest we should ever poll the battery.

#define INVALID_DATA_POLL_RATE      (1 * NTSEC)
// If the battery returned invalid information, we want to poll
// it more frequesntly, since invalid information generally
// indicates that the battery was in a transition state.  The user
// will not want to wait 20 seconds for the UI to update, but we don't
// want to poll too fast and hurt the performance of a machine with a
// poorly designed battery too much.
#define INVALID_DATA_MAX_RETRY      10
// Only retry 20 time before giving up.
// This should be reset on any notifiation from the battery.

#define STATUS_VALID_TIME           (2 * NTSEC)
// If a request is received within STATUS_VALID_TIME of the last request
// time information was read, and there hasn't been a notification from
// the battery, the driver will assume that the cached values are good enough.

//
// WMI info
//

#define MOFRESOURCENAME L"BATTCWMI"
#define MOFREGISTRYPATH L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\BattC"
//#define MOFREGISTRYPATH L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{72631E54-78A4-11D0-BCF7-00AA00B7B32A}"

typedef enum {
    BattWmiStatusId,
    BattWmiRuntimeId,
    BattWmiTemperatureId,
    BattWmiFullChargedCapacityId,
    BattWmiCycleCountId,
    BattWmiStaticDataId,
    BattWmiStatusChangeId,
    BattWmiTagChangeId,
    BattWmiTotalGuids
} BATT_WMI_GUID_INDEX;


//
// Non-paged battery class information
//

typedef struct {

    //
    // Pointer to paged information
    //
    struct _BATT_INFO       *BattInfo;          // Pointer to paged portion

    //
    // General
    //

    KTIMER                  WorkerTimer;        // Timer to get worker thread
    KDPC                    WorkerDpc;          // DPC to get worker thread
    KTIMER                  TagTimer;           // Timer for query tag requests
    KDPC                    TagDpc;
    WORK_QUEUE_ITEM         WorkerThread;       // WORK_QUEUE to get worker thread
    ULONG                   WorkerActive;
    ULONG                   CheckStatus;        // Worker to check status
    ULONG                   CheckTag;           // Worker to check for battery tag
    ULONG                   StatusNotified;     // Notification has occured (must re-read)
    ULONG                   TagNotified;

    FAST_MUTEX              Mutex;              // Synchorize with worker thread

    BOOLEAN                 WantToRemove;       // Syncronize device removal
    LONG                    InUseCount;
    KEVENT                  ReadyToRemove;

#if DEBUG
    ULONG                   DeviceNum;          // Device number for debug prints
#endif

} BATT_NP_INFO, *PBATT_NP_INFO;



//
// Paged battery class information
//

typedef struct _BATT_INFO {

    WMILIB_CONTEXT          WmiLibContext;
    ULONG                   WmiGuidIndex;       // Used to ignore miniclass WMI
                                                // GUIDs

    //
    // IO
    //

    ULONG                   Tag;                // Current battery tag

    LIST_ENTRY              IoQueue;            // IRPs waiting to be processed
    LIST_ENTRY              StatusQueue;        // Waiting status requests
    LIST_ENTRY              TagQueue;           // Waiting battery tag requests
    LIST_ENTRY              WmiQueue;

    ULONGLONG               TagTime;            // Time when tag was read
    ULONGLONG               StatusTime;         // Time when status was read
    BATTERY_STATUS          Status;             // The status
    ULONG                   InvalidRetryCount;  // How many times ni a row has the battery returned invalid data?
#if DEBUG
    ULONG                   FullChargedCap;
    PBATT_NP_INFO           BattNPInfo;
#endif
    ULONG                   NotifyTimeout;      // LCD timeout of wat
    BATTERY_MINIPORT_INFO   Mp;                 // Miniport Info

    UNICODE_STRING          SymbolicLinkName;   // Name returned by IoRegisterDeviceInterface

} BATT_INFO, *PBATT_INFO;

//
// WmiQueue entry
//

typedef struct _BATT_WMI_REQUEST {
    LIST_ENTRY              ListEntry;

    PDEVICE_OBJECT          DeviceObject;
    PIRP                    Irp;
    BATT_WMI_GUID_INDEX     GuidIndex;
    IN OUT PULONG           InstanceLengthArray;
    IN ULONG                OutBufferSize;
    OUT PUCHAR              Buffer;

} BATT_WMI_REQUEST, *PBATT_WMI_REQUEST;


//
// Prototypes
//


VOID
BattCWorkerDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
BattCWorkerThread (
    IN PVOID Context
    );

VOID
BattCQueueWorker (
    IN PBATT_NP_INFO BattNPInfo,
    IN BOOLEAN       CheckStatus
    );

NTSTATUS
BatteryIoctl(
    IN ULONG            Ioctl,
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    IN PVOID            OutputBuffer,
    IN ULONG            OutputBufferLength,
    IN BOOLEAN          PrivateIoctl
    );

VOID
BattCTagDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
BattCCancelTag (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\cmbatt\cmbatt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CmBatt.c

Abstract:

    Control Method Battery Miniport Driver

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode

Revision History:

--*/

#include "CmBattp.h"


#if DEBUG
#if DBG
    ULONG       CmBattDebug     = CMBATT_ERROR;
#else
    // Turn off all debug info by default for free builds.
    ULONG       CmBattDebug     = 0;
#endif //DBG
#endif //DEBUG

#ifndef _WIN32_WINNT
ULONG       CmBattPrevPowerSource = 1;
#endif //_WIN32_WINNT

UNICODE_STRING GlobalRegistryPath;

PVOID CmBattPowerCallBackRegistration;
PCALLBACK_OBJECT CmBattPowerCallBackObject;
KDPC CmBattWakeDpcObject;
KTIMER CmBattWakeDpcTimerObject;

LARGE_INTEGER    CmBattWakeDpcDelay = WAKE_DPC_DELAY;

//
// Prototypes
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

NTSTATUS
CmBattOpenClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CmBattIoctl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
CmBattUnload(
    IN PDRIVER_OBJECT   DriverObject
    );

NTSTATUS
CmBattGetBatteryStatus(
    PCM_BATT            CmBatt,
    IN ULONG            BatteryTag
    );

NTSTATUS
CmBattGetSetAlarm(
    IN PCM_BATT         CmBatt,
    IN OUT PULONG       AlarmPtr,
    IN UCHAR            OpType
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,CmBattQueryTag)
#pragma alloc_text(PAGE,CmBattQueryInformation)
#pragma alloc_text(PAGE,CmBattQueryStatus)
#pragma alloc_text(PAGE,CmBattSetStatusNotify)
#pragma alloc_text(PAGE,CmBattDisableStatusNotify)
#pragma alloc_text(PAGE,CmBattUnload)
#pragma alloc_text(PAGE,CmBattOpenClose)
#pragma alloc_text(PAGE,CmBattIoctl)
#pragma alloc_text(PAGE,CmBattGetBatteryStatus)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    This routine initializes the ACPI Embedded Controller Driver

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objAttributes;
    UNICODE_STRING      callBackName;


    //
    // Save the RegistryPath.
    //

    GlobalRegistryPath.MaximumLength = RegistryPath->Length +
                                          sizeof(UNICODE_NULL);
    GlobalRegistryPath.Length = RegistryPath->Length;
    GlobalRegistryPath.Buffer = ExAllocatePoolWithTag (
                                       PagedPool,
                                       GlobalRegistryPath.MaximumLength,
                                       'MtaB');

    if (!GlobalRegistryPath.Buffer) {

        CmBattPrint ((CMBATT_ERROR),("CmBatt: Couldn't allocate pool for registry path."));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyUnicodeString(&GlobalRegistryPath, RegistryPath);

    CmBattPrint (CMBATT_TRACE, ("CmBatt DriverEntry - Obj (%08x) Path \"%ws\"\n",
                                 DriverObject, RegistryPath->Buffer));
    //
    // Set up the device driver entry points.
    //
    DriverObject->DriverUnload                          = CmBattUnload;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = CmBattIoctl;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = CmBattOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = CmBattOpenClose;

    DriverObject->MajorFunction[IRP_MJ_POWER]           = CmBattPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = CmBattPnpDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = CmBattSystemControl;
    DriverObject->DriverExtension->AddDevice            = CmBattAddDevice;


    //
    // Register a callback that tells us when the system is in the
    // process of sleeping or waking.
    //
    RtlInitUnicodeString( &callBackName, L"\\Callback\\PowerState" );
    InitializeObjectAttributes(
        &objAttributes,
        &callBackName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL
        );
    status = ExCreateCallback(
        &CmBattPowerCallBackObject,
        &objAttributes,
        FALSE,
        TRUE
        );
    if (NT_SUCCESS(status)) {

        CmBattPowerCallBackRegistration = ExRegisterCallback(
            CmBattPowerCallBackObject,
            (PCALLBACK_FUNCTION) CmBattPowerCallBack,
            DriverObject
            );
        if (CmBattPowerCallBackRegistration) {
            KeInitializeDpc (&CmBattWakeDpcObject,
                             (PKDEFERRED_ROUTINE) CmBattWakeDpc,
                             DriverObject);
            KeInitializeTimer (&CmBattWakeDpcTimerObject);
        } else {
            ObDereferenceObject (CmBattPowerCallBackObject);
            CmBattPrint (CMBATT_ERROR, ("CmBattRegisterPowerCallBack: ExRegisterCallback failed.\n"));
        }
    } else {
        CmBattPowerCallBackObject = NULL;
        CmBattPrint (CMBATT_ERROR, ("CmBattRegisterPowerCallBack: failed status=0x%08x\n", status));
    }

    return STATUS_SUCCESS;

}



VOID
CmBattUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Cleanup all devices and unload the driver

Arguments:

    DriverObject - Driver object for unload

Return Value:

    Status

--*/
{

    CmBattPrint (CMBATT_TRACE, ("CmBattUnload: \n"));

    if (CmBattPowerCallBackObject) {
        ExUnregisterCallback (CmBattPowerCallBackRegistration);
        ObDereferenceObject (CmBattPowerCallBackObject);
    }

    if (GlobalRegistryPath.Buffer) {
        ExFreePool (GlobalRegistryPath.Buffer);
    }

    if (DriverObject->DeviceObject != NULL) {
        CmBattPrint (CMBATT_ERROR, ("Unload called before all devices removed.\n"));
    }
}



NTSTATUS
CmBattOpenClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This is the routine called as a result of a Open or Close on the device

Arguments:


    DeviceObject    - Battery for request
    Irp             - IO request

Return Value:

    STATUS_SUCCESS - no way to fail this puppy
    If Device has received a query remove, this will fail.
    STATUS_NO_SUCH_DEVICE

--*/
{
    PCM_BATT            CmBatt;
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpStack;

    PAGED_CODE();

    CmBattPrint (CMBATT_TRACE, ("CmBattOpenClose\n"));

    CmBatt = (PCM_BATT) DeviceObject->DeviceExtension;

    //
    // A remove lock is not needed in this dispatch function because
    // all data accessed is in the device extension.  If any other functionality was
    // added to this routine, a remove lock might be neccesary.
    //

    status = STATUS_SUCCESS;  // Success by default.

    ExAcquireFastMutex (&CmBatt->OpenCloseMutex);
    if (CmBatt->OpenCount == (ULONG) -1) {          // A query remove has come requested
        status = STATUS_NO_SUCH_DEVICE;
        CmBattPrint (CMBATT_PNP, ("CmBattOpenClose: Failed (UID = %x)(device being removed).\n", CmBatt->Info.Tag));
    } else {
        irpStack = IoGetCurrentIrpStackLocation(Irp);
        if (irpStack->MajorFunction ==  IRP_MJ_CREATE) {
            CmBatt->OpenCount++;
            CmBattPrint (CMBATT_PNP, ("CmBattOpenClose: Open (DeviceNumber = %x)(count = %x).\n",
                         CmBatt->DeviceNumber, CmBatt->OpenCount));
        } else if (irpStack->MajorFunction ==  IRP_MJ_CLOSE) {
            CmBatt->OpenCount--;
            CmBattPrint (CMBATT_PNP, ("CmBattOpenClose: Close (DeviceNumber = %x)(count = %x).\n",
                         CmBatt->DeviceNumber, CmBatt->OpenCount));
        }
    }
    ExReleaseFastMutex (&CmBatt->OpenCloseMutex);

    //
    // Complete Irp.
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;

}



NTSTATUS
CmBattIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    IOCTL handler.  As this is an exclusive battery device, send the
    Irp to the battery class driver to handle battery IOCTLs.

Arguments:

    DeviceObject    - Battery for request
    Irp             - IO request

Return Value:

    Status of request

--*/
{
    NTSTATUS        Status = STATUS_NOT_SUPPORTED;
    PCM_BATT        CmBatt;


#if DIRECT_ACCESS

    PIO_STACK_LOCATION      IrpSp;

#endif //DIRECT_ACCESS

    PAGED_CODE();

    CmBattPrint (CMBATT_TRACE, ("CmBattIoctl\n"));

    CmBatt = (PCM_BATT) DeviceObject->DeviceExtension;

    //
    // Aquire remove lock
    //

    InterlockedIncrement (&CmBatt->InUseCount);
    if (CmBatt->WantToRemove == TRUE) {
        if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
            KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
        }
        Status = STATUS_DEVICE_REMOVED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return Status;
    }

    if (CmBatt->Type == CM_BATTERY_TYPE) {
        Status = BatteryClassIoctl (CmBatt->Class, Irp);

#if DIRECT_ACCESS
        if (Status == STATUS_NOT_SUPPORTED) {

            //
            // Is it a Direct Access IOCTL?
            //

            IrpSp = IoGetCurrentIrpStackLocation(Irp);

            CmBattPrint((CMBATT_BIOS),
                        ("CmBattIoctl: Received  Direct Access IOCTL %x\n",
                         IrpSp->Parameters.DeviceIoControl.IoControlCode));

            switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
            case IOCTL_CMBATT_UID:
                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (ULONG)) {
                    Status = CmBattGetUniqueId (CmBatt->Pdo, Irp->AssociatedIrp.SystemBuffer);
                    if (NT_SUCCESS(Status)) {
                        Irp->IoStatus.Information = sizeof (ULONG);
                    } else {
                        Irp->IoStatus.Information = 0;
                    }
                } else {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                };
                break;
            case IOCTL_CMBATT_STA:
                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (ULONG)) {
                    Status = CmBattGetStaData (CmBatt->Pdo, Irp->AssociatedIrp.SystemBuffer);
                    if (NT_SUCCESS(Status)) {
                        Irp->IoStatus.Information = sizeof (ULONG);
                    } else {
                        Irp->IoStatus.Information = 0;
                    }
                } else {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                };
                break;
            case IOCTL_CMBATT_PSR:
                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (ULONG)) {
                    if (AcAdapterPdo != NULL) {
                        Status = CmBattGetPsrData (AcAdapterPdo, Irp->AssociatedIrp.SystemBuffer);
                    } else {
                        Status = STATUS_NO_SUCH_DEVICE;
                    }
                    if (NT_SUCCESS(Status)) {
                        Irp->IoStatus.Information = sizeof (ULONG);
                    } else {
                        Irp->IoStatus.Information = 0;
                    }
                } else {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                };
                break;
            case IOCTL_CMBATT_BTP:
                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof (ULONG)) {
                    Status = CmBattSetTripPpoint (CmBatt, *((PULONG) (Irp->AssociatedIrp.SystemBuffer)));
                    Irp->IoStatus.Information = 0;
                } else {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                };
                break;
            case IOCTL_CMBATT_BIF:
                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (CM_BIF_BAT_INFO)) {
                    Status = CmBattGetBifData (CmBatt, Irp->AssociatedIrp.SystemBuffer);
                    if (NT_SUCCESS(Status)) {
                        Irp->IoStatus.Information = sizeof (CM_BIF_BAT_INFO);
                    } else {
                        Irp->IoStatus.Information = 0;
                    }
                } else {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                };
                break;
            case IOCTL_CMBATT_BST:
                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (CM_BST_BAT_INFO)) {
                    Status = CmBattGetBstData (CmBatt, Irp->AssociatedIrp.SystemBuffer);
                    if (NT_SUCCESS(Status)) {
                        Irp->IoStatus.Information = sizeof (CM_BST_BAT_INFO);
                    } else {
                        Irp->IoStatus.Information = 0;
                    }
                } else {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                };
                break;

            default:
                CmBattPrint((CMBATT_ERROR),
                            ("CmBattIoctl: Unknown IOCTL %x\n",
                             IrpSp->Parameters.DeviceIoControl.IoControlCode));

            }

            if (Status != STATUS_NOT_SUPPORTED) {

                //
                // We just handled this IOCTL.  Complete it.
                //

                Irp->IoStatus.Status = Status;
                IoCompleteRequest (Irp, IO_NO_INCREMENT);
            }
        }
#endif //DIRECT_ACCESS
    }

    if (Status == STATUS_NOT_SUPPORTED) {

        //
        // Not for the battery.  Pass it down the stack.
        //

        IoSkipCurrentIrpStackLocation (Irp);
        Status = IoCallDriver (CmBatt->LowerDeviceObject, Irp);

    }

    //
    // Release Removal Lock
    //
    if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
        KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
    }

    return Status;
}



NTSTATUS
CmBattQueryTag (
    IN  PVOID       Context,
    OUT PULONG      TagPtr
    )
/*++

Routine Description:

    Called by the class driver to retrieve the batteries current tag value

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    TagPtr          - Pointer to return current tag

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    NTSTATUS        Status;
    PCM_BATT        CmBatt = (PCM_BATT) Context;
    ULONG           BatteryStatus;


    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_MINI),
                 ("CmBattQueryTag - Tag (%d), Battery %x, Device %d\n",
                    *TagPtr, CmBatt, CmBatt->DeviceNumber));

    //
    // Check if battery is still there
    //
    CmBatt->ReCheckSta = FALSE;
    Status = CmBattGetStaData (CmBatt->Pdo, &BatteryStatus);

    if (NT_SUCCESS (Status)) {
        if (BatteryStatus & STA_DEVICE_PRESENT) {

            //
            // If the tag isn't assigned, assign a new one
            //

            if (CmBatt->Info.Tag == BATTERY_TAG_INVALID) {

                //
                // See if there is a battery out there.
                //

                CmBatt->TagCount += 1;
                if (CmBatt->TagCount == BATTERY_TAG_INVALID) {
                     CmBatt->TagCount += 1;
                }

                CmBatt->Info.Tag = CmBatt->TagCount;

                RtlZeroMemory (&CmBatt->Alarm, sizeof(BAT_ALARM_INFO));
                CmBatt->Alarm.Setting = CM_ALARM_INVALID;
                CmBattPrint (CMBATT_TRACE, ("CmBattQueryTag - New Tag: (%d)\n", CmBatt->Info.Tag));
                InterlockedExchange (&CmBatt->CacheState, 0);
                CmBatt->DischargeTime = KeQueryInterruptTime();
            }

        } else {

            CmBatt->Info.Tag = BATTERY_TAG_INVALID;
            Status =  STATUS_NO_SUCH_DEVICE;

        }
    }

    //
    // Done
    //

    CmBattPrint ((CMBATT_MINI),
                 ("CmBattQueryTag: Returning Tag: 0x%x, status 0x%x\n",
                    CmBatt->Info.Tag, Status));

    *TagPtr = CmBatt->Info.Tag;
    return Status;
}



NTSTATUS
CmBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN LONG                             AtRate OPTIONAL,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    )
/*++

Routine Description:

    Called by the class driver to retrieve battery information

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

    We return invalid parameter when we can't handle a request for a
    specific level of information.  This is defined in the battery class spec.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    Level           - type of information required
    AtRate          - Used only when Level==BatteryEstimatedTime
    Buffer          - Location for the information
    BufferLength    - Length in bytes of the buffer
    ReturnedLength  - Length in bytes of the returned data

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    PCM_BATT            CmBatt = (PCM_BATT) Context;
    ULONG               ResultData;
    NTSTATUS            Status;
    PVOID               ReturnBuffer;
    ULONG               ReturnBufferLength;
    WCHAR               scratchBuffer[CM_MAX_STRING_LENGTH];
    WCHAR               buffer2[CM_MAX_STRING_LENGTH];
    UNICODE_STRING      tmpUnicodeString;
    UNICODE_STRING      unicodeString;
    ANSI_STRING         ansiString;

    BATTERY_REMAINING_SCALE     ScalePtr[2];


    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_MINI),
                 ("CmBattQueryInformation - Tag (%d) Device %d, Informationlevel %d\n",
                    BatteryTag, CmBatt->DeviceNumber, Level));

    //
    //  Be sure there's a battery out there
    //  This also checks BatteryTag
    //

    Status = CmBattVerifyStaticInfo (CmBatt, BatteryTag);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ResultData = 0;
    ReturnBuffer = NULL;
    ReturnBufferLength = 0;
    Status = STATUS_SUCCESS;

    //
    // Get the info requested
    //

    switch (Level) {
        case BatteryInformation:
            //
            //  This data structure is populated by CmBattVerifyStaticInfo
            //
            ReturnBuffer = (PVOID) &CmBatt->Info.ApiInfo;
            ReturnBufferLength = sizeof (CmBatt->Info.ApiInfo);
            break;

        case BatteryGranularityInformation:
            //
            //  Get the granularity from the static info structure
            //  This data structure is populated by CmBattVerifyStaticInfo
            //
            {
                ScalePtr[0].Granularity     = CmBatt->Info.ApiGranularity_1;
                ScalePtr[0].Capacity        = CmBatt->Info.ApiInfo.DefaultAlert1;
                ScalePtr[1].Granularity     = CmBatt->Info.ApiGranularity_2;
                ScalePtr[1].Capacity        = CmBatt->Info.ApiInfo.DesignedCapacity;

                ReturnBuffer        = ScalePtr;
                ReturnBufferLength  = 2 * sizeof (BATTERY_REMAINING_SCALE);
            }
            break;

        case BatteryTemperature:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case BatteryEstimatedTime:
            
            //
            // Return unknown time if battery has been discharging less than 15 seconds
            //
            if (KeQueryInterruptTime() > (CmBatt->DischargeTime + CM_ESTIMATED_TIME_DELAY)) {

                //
                // The BatteryEstimatedTime for the control method batteries is defined
                // by the following formula:
                //
                // EstimatedTime [min] = RemainingCapacity [mAh|mWh] * 60 [min/hr] * 60 [sec/min]
                //                     ----------------------------------
                //                     PresentRate [mA|mW]
                //

                //
                // Rerun _BST since we don't have a timeout on this data.
                // Also Calculate API status values from CM values
                //

                CmBattGetBatteryStatus (CmBatt, CmBatt->Info.Tag);

                //
                // If AtRate is zero, we need to use the present rate
                //

                if (AtRate == 0) {
                    AtRate = CmBatt->Info.ApiStatus.Rate;
                }

                if (AtRate >= 0) {
                    AtRate = BATTERY_UNKNOWN_RATE;
                }
                if ((AtRate != BATTERY_UNKNOWN_RATE) &&
                    (CmBatt->Info.ApiStatus.Capacity != BATTERY_UNKNOWN_CAPACITY)) {

                    // Calculate estimated time.
#if DEBUG
                    // Make sure we don't overflow...
                    if (CmBatt->Info.ApiStatus.Capacity > (0xffffffff/3600)) {
                        CmBattPrint (CMBATT_ERROR_ONLY, ("CmBattQueryInformation: Data Overflow in calculating Remaining Capacity.\n"));
                    }
#endif //DEBUG
                    ResultData = (ULONG) (CmBatt->Info.ApiStatus.Capacity * 3600) / (-AtRate);

                } else {
                    //
                    // We don't know have enough information to calculate the value.
                    // Return BATTERY_UNKNONW_TIME.
                    //
                    // If this battery is incapable of returning estimated time, return with
                    // STATUS_INVALID_DEVICE_REQUEST
                    //

#if DEBUG
                    if (CmBatt->Info.Status.BatteryState & CM_BST_STATE_DISCHARGING) {
                        CmBattPrint (CMBATT_WARN,
                            ("CmBattQueryInformation: Can't calculate EstimatedTime.\n"));
                    }
#endif //DEBUG

                    if (CmBatt->Info.ApiStatus.Rate == BATTERY_UNKNOWN_RATE &&
                        (CmBatt->Info.Status.BatteryState & CM_BST_STATE_DISCHARGING)) {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        CmBattPrint (CMBATT_WARN,
                                    ("----------------------   PresentRate = BATTERY_UNKNOWN_RATE\n"));
                    }
                    if (CmBatt->Info.ApiStatus.Capacity == BATTERY_UNKNOWN_CAPACITY) {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        CmBattPrint (CMBATT_WARN,
                                    ("----------------------   RemainingCapacity = BATTERY_UNKNOWN_CAPACITY\n"));
                    }

                    ResultData = BATTERY_UNKNOWN_TIME;
                }
            } else { // if (KeQueryInterruptTime() > CmBatt->DischargeTime + CM_ESTIMATED_TIME_DELAY)
                
                //
                // Return unknown time if battery has been discharging less than 15 seconds
                //
                ResultData = BATTERY_UNKNOWN_TIME;
            }

            ReturnBuffer        = &ResultData;
            ReturnBufferLength  = sizeof(ResultData);
            break;

        case BatteryDeviceName:
            //
            // Model Number must be returned as a wide string
            //
            unicodeString.Buffer        = scratchBuffer;
            unicodeString.MaximumLength = CM_MAX_STRING_LENGTH;

            RtlInitAnsiString (&ansiString, CmBatt->Info.ModelNum);
            Status = RtlAnsiStringToUnicodeString (&unicodeString, &ansiString, FALSE);

            ReturnBuffer        = unicodeString.Buffer;
            ReturnBufferLength  = unicodeString.Length;
            break;

        case BatteryManufactureDate:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case BatteryManufactureName:
            //
            // Oem Info must be returned as wide string
            //
            unicodeString.Buffer        = scratchBuffer;
            unicodeString.MaximumLength = CM_MAX_STRING_LENGTH;

            RtlInitAnsiString (&ansiString, CmBatt->Info.OEMInfo);
            Status = RtlAnsiStringToUnicodeString (&unicodeString, &ansiString, FALSE);

            ReturnBuffer        = unicodeString.Buffer;
            ReturnBufferLength  = unicodeString.Length;
            break;

        case BatteryUniqueID:
            //
            //  Concatenate the serial #, OEM info, and Model #
            //

            unicodeString.Buffer            = scratchBuffer;
            unicodeString.MaximumLength     = CM_MAX_STRING_LENGTH;

            tmpUnicodeString.Buffer         = buffer2;
            tmpUnicodeString.MaximumLength  = CM_MAX_STRING_LENGTH;

            RtlInitAnsiString (&ansiString, CmBatt->Info.SerialNum);
            RtlAnsiStringToUnicodeString (&unicodeString, &ansiString, FALSE);

            if (CmBatt->Info.OEMInfo[0]) {
                RtlInitAnsiString (&ansiString, CmBatt->Info.OEMInfo);
                RtlAnsiStringToUnicodeString (&tmpUnicodeString, &ansiString, FALSE);
                    RtlAppendUnicodeStringToString (&unicodeString, &tmpUnicodeString);
            }

            RtlInitAnsiString (&ansiString, CmBatt->Info.ModelNum);
            RtlAnsiStringToUnicodeString (&tmpUnicodeString, &ansiString, FALSE);
                RtlAppendUnicodeStringToString (&unicodeString, &tmpUnicodeString);

            ReturnBuffer        = unicodeString.Buffer;
            ReturnBufferLength  = unicodeString.Length;
            break;

        default:
            Status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Done, return buffer if needed
    //

    *ReturnedLength = ReturnBufferLength;
    if (BufferLength < ReturnBufferLength) {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    if (NT_SUCCESS(Status) && ReturnBuffer) {
        RtlCopyMemory (Buffer, ReturnBuffer, ReturnBufferLength);   // Copy what's needed
    }
    return Status;
}



NTSTATUS
CmBattQueryStatus (
    IN PVOID            Context,
    IN ULONG            BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
    )
/*++

Routine Description:

    Called by the class driver to retrieve the batteries current status

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    BatteryStatus   - Pointer to structure to return the current battery status

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    PCM_BATT    CmBatt = (PCM_BATT) Context;
    NTSTATUS    Status;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_MINI), ("CmBattQueryStatus - Tag (%d) Device %x\n",
                    BatteryTag, CmBatt->DeviceNumber));


    Status = CmBattGetBatteryStatus (CmBatt, BatteryTag);

    if (NT_SUCCESS(Status)) {
        RtlCopyMemory (BatteryStatus, &CmBatt->Info.ApiStatus, sizeof(BATTERY_STATUS));
    }
    CmBattPrint ((CMBATT_MINI), ("CmBattQueryStatus: Returning [%#08lx][%#08lx][%#08lx][%#08lx]\n",
                    BatteryStatus->PowerState, BatteryStatus->Capacity, BatteryStatus->Voltage, BatteryStatus->Rate));

    return Status;
}



NTSTATUS
CmBattSetStatusNotify (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN PBATTERY_NOTIFY Notify
    )
/*++

Routine Description:

    Called by the class driver to set the batteries current notification
    setting.  When the battery trips the notification, one call to
    BatteryClassStatusNotify is issued.   If an error is returned, the
    class driver will poll the battery status - primarily for capacity
    changes.  Which is to say the miniport should still issue BatteryClass-
    StatusNotify whenever the power state changes.

    The class driver will always set the notification level it needs
    after each call to BatteryClassStatusNotify.

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    BatteryNotify   - The notification setting

Return Value:

    Status

--*/
{
    PCM_BATT    CmBatt;
    NTSTATUS    Status;
    ULONG       Target;
    LONG        ActualAlarm;   // Value after adjusting for limit conditions.
    CM_BST_BAT_INFO bstData;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_MINI), ("CmBattSetStatusNotify: Tag (%d) Target(0x%x)\n",
            BatteryTag, Notify->LowCapacity));

    Status = STATUS_SUCCESS;
    CmBatt = (PCM_BATT) Context;

    Status = CmBattVerifyStaticInfo (CmBatt, BatteryTag);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // If _BTP doesn't exist, don't call it again.
    //

    if (!CmBatt->Info.BtpExists) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    if ((Notify->HighCapacity == BATTERY_UNKNOWN_CAPACITY) ||
        (Notify->LowCapacity == BATTERY_UNKNOWN_CAPACITY)) {
        CmBattPrint (CMBATT_WARN, ("CmBattSetStatusNotify: Failing request because of BATTERY_UNKNOWN_CAPACITY.\n"));
        return STATUS_NOT_SUPPORTED;
    }

    if (CmBatt->Info.Status.BatteryState & CM_BST_STATE_CHARGING) {
        Target = Notify->HighCapacity;
    } else if (CmBatt->Info.Status.BatteryState & CM_BST_STATE_DISCHARGING) {
        Target = Notify->LowCapacity;
    } else {
        // No trip point needs to be set, the battery will trip as soon as it starts
        // charging or discharging.
        //return STATUS_SUCCESS;
        // but it doesn't hurt to set the trip point just in case the battery
        // system screws up and doesn't send the notification when the status changed.
        Target = Notify->LowCapacity;
    }

    ActualAlarm = Target;

    //
    // If the battery operates on mA we need to convert the trip point from mW
    // to mA.  The formula for doing this is:
    //
    // mA = mW / V      or     mA = (mW / mV) * 1000
    //

    if (CmBatt->Info.StaticData.PowerUnit & CM_BIF_UNITS_AMPS) {
        if ((CmBatt->Info.StaticData.DesignVoltage == CM_UNKNOWN_VALUE) ||
            (CmBatt->Info.StaticData.DesignVoltage == 0)) {

            CmBattPrint (CMBATT_ERROR_ONLY,
                        ("CmBattSetStatusNotify: Can't calculate BTP, DesignVoltage = 0x%08x\n",
                         CmBatt->Info.StaticData.DesignVoltage));
            return STATUS_NOT_SUPPORTED;
        }
            
        //
        // Calculate optimized Ah target
        //
        if (CmBatt->Info.Status.BatteryState & CM_BST_STATE_CHARGING) {

            //
            // (ActualAlarm * 1000 + 500) / DesignVoltage + 1 will generate
            // the correct battery trip point, except in cases when 
            // (ActualAlarm * 1000)+ 500) is evenly  divisible by the 
            // DesignVoltage.  In that case, it will be 1 mAh higher than
            // it should be.
            //
            // This is in the form of a single expression rather than an 
            // "if" statement to encourage the compiler to use the remainder
            // from the original div operation rather than performing div 
            // twice
            //

            ActualAlarm = (ActualAlarm * 1000 + 500) / CmBatt->Info.StaticData.DesignVoltage + 
                ( ((ActualAlarm * 1000 + 500) % CmBatt->Info.StaticData.DesignVoltage == 0)? 0 : 1 );

        } else {

            //
            // (ActualAlarm * 1000 - 500) / DesignVoltage will generate
            // the correct battery trip point, except in cases when 
            // (ActualAlarm * 1000)+ 500) is evenly  divisible by the 
            // DesignVoltage.  In that case, it will be 1 mAh higher than
            // it should be
            //

            ActualAlarm = (ActualAlarm * 1000 - 500) / CmBatt->Info.StaticData.DesignVoltage - 
                ( ((ActualAlarm * 1000 - 500) % CmBatt->Info.StaticData.DesignVoltage == 0)? 1 : 0);

        }

    } else {
        // Increment or decrement the alarm value by 1 since the input to this
        // function is < or >, but _BTP is <= or >=
        if (CmBatt->Info.Status.BatteryState & CM_BST_STATE_CHARGING) {
            ActualAlarm++;
        } else {
            if (ActualAlarm > 0) {
                ActualAlarm--;
            }
        }
    }

    if (ActualAlarm == CmBatt->Alarm.Setting) {
        //
        // Don't need to reset the alarm to the same value.
        //
    
        CmBattPrint(CMBATT_LOW,
                ("CmBattSetStatusNotify: Keeping original setting: %X\n",
                CmBatt->Alarm.Setting
                ));
        
        return STATUS_SUCCESS;
    }
    
    //
    // Save current setting, so we won't waste time setting it twice.
    //
    CmBatt->Alarm.Setting = ActualAlarm;

    //
    // Set the alarm
    //
    Status = CmBattSetTripPpoint (CmBatt, ActualAlarm);

    if ((ActualAlarm == 0) && (Target != 0)) {
        // If the driver really wanted to be notified when the capacity
        // reached 0, return STATUS_NOT_SUPPORTED because seting _BTP to zero
        // disables notification.  The battery class will perform polling since
        // STATUS_NOT_SUPPORTED was returned.

        Status = STATUS_NOT_SUPPORTED;
    }

    if (!NT_SUCCESS (Status)) {
        //
        //  Something failed in the Trip point call, get out
        //
        CmBattPrint (CMBATT_ERROR, ("CmBattSetStatusNotify: SetTripPoint failed - %x\n",
                                        Status));
        CmBatt->Alarm.Setting = CM_ALARM_INVALID;
        return Status;
    }

    // Make sure that the trip point hasn't been passed already.
    Status = CmBattGetBstData (CmBatt, &bstData);

    if (!NT_SUCCESS (Status)) {
        //
        //  Something failed in the Trip point call, get out
        //
        CmBattPrint (CMBATT_ERROR, ("CmBattSetStatusNotify: GetBstData - %x\n",
                                        Status));
    } else {
        if (CmBatt->Info.Status.BatteryState & CM_BST_STATE_CHARGING) {
            if (bstData.RemainingCapacity >= (ULONG)ActualAlarm) {
                CmBattPrint (CMBATT_WARN, ("CmBattSetStatusNotify: Trip point already crossed (1): TP = %08x, remaining capacity = %08x\n",
                                           ActualAlarm, bstData.RemainingCapacity));
                CmBattNotifyHandler (CmBatt, BATTERY_STATUS_CHANGE);
            }
        } else {
            if ((bstData.RemainingCapacity <= (ULONG)ActualAlarm) && (Target != 0)) {
                CmBattPrint (CMBATT_WARN, ("CmBattSetStatusNotify: Trip point already crossed (1): TP = %08x, remaining capacity = %08x\n",
                                           ActualAlarm, bstData.RemainingCapacity));
                CmBattNotifyHandler (CmBatt, BATTERY_STATUS_CHANGE);
            }
        }

    }

    CmBattPrint(CMBATT_LOW,
            ("CmBattSetStatusNotify: Want %X CurrentCap %X\n",
            Target,
            CmBatt->Info.ApiStatus.Capacity
            ));

    CmBattPrint ((CMBATT_MINI),
                 ("CmBattSetStatusNotify: Set to: [%#08lx][%#08lx][%#08lx] Status %x\n",
                 Notify->PowerState, Notify->LowCapacity, Notify->HighCapacity));

    return Status;
}



NTSTATUS
CmBattDisableStatusNotify (
    IN PVOID Context
    )
/*++

Routine Description:

    Called by the class driver to disable the notification setting
    for the battery supplied by Context.  Note, to disable a setting
    does not require the battery tag.   Any notification is to be
    masked off until a subsequent call to CmBattSetStatusNotify.

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery

Return Value:

    Status

--*/
{
    PCM_BATT    CmBatt;
    NTSTATUS    Status;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_MINI), ("CmBattDisableStatusNotify\n"));

    CmBatt = (PCM_BATT) Context;

    //
    // If _BTP doesn't exist, don't call it again.
    //

    if (!CmBatt->Info.BtpExists) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    if (CmBatt->Alarm.Setting != CM_BATT_CLEAR_TRIP_POINT) {
        
        CmBatt->Alarm.Setting = CM_BATT_CLEAR_TRIP_POINT;
        
        //
        // Clear the trip point.
        //

        Status = CmBattSetTripPpoint (CmBatt, CM_BATT_CLEAR_TRIP_POINT);

        if (!NT_SUCCESS (Status)) {
            CmBattPrint ((CMBATT_MINI),
                         ("CmBattDisableStatusNotify: SetTripPoint failed - %x\n",
                                            Status));
            CmBatt->Alarm.Setting = CM_ALARM_INVALID;
        }
    } else {
        //
        // Don't need to disable alarm is it's already been disabled.
        //

        Status = STATUS_SUCCESS;
    }


    return Status;
}



NTSTATUS
CmBattGetBatteryStatus (
    PCM_BATT        CmBatt,
    IN ULONG        BatteryTag
    )
/*++

Routine Description:

    Called to setup the status data required by the IOCTL API defined for
    the battery class.  This is the data defined in the BATTERY_STATUS
    structure.

Arguments:

    CmBatt          - The extension for this device.

Return Value:

    Status

--*/

{
    NTSTATUS            Status = STATUS_SUCCESS;
    PBATTERY_STATUS     ApiStatus;
    PCM_BST_BAT_INFO    CmBattStatus;
    ULONG               AcStatus = 0;
    ULONG               LastPowerState;


    PAGED_CODE();

    CmBattPrint (CMBATT_TRACE, ("CmBattGetBatteryStatus - CmBatt (%08x) Tag (%d)\n",
                                CmBatt, BatteryTag));


    Status = CmBattVerifyStaticInfo (CmBatt, BatteryTag);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (CmBatt->Sleeping) {
        //
        // Return cached data, and ensure that this gets requeried when we are fully awake.
        //
        CmBattNotifyHandler (CmBatt, BATTERY_STATUS_CHANGE);
        return Status;
    }

    CmBattStatus = &CmBatt->Info.Status;
    Status = CmBattGetBstData(CmBatt, CmBattStatus);
    if (!NT_SUCCESS(Status)) {
        InterlockedExchange (&CmBatt->CacheState, 0);
        return Status;
    }

    ApiStatus = &CmBatt->Info.ApiStatus;
    LastPowerState = ApiStatus->PowerState;
    RtlZeroMemory (ApiStatus, sizeof(BATTERY_STATUS));

    //
    // Decode the state bits
    //
#if DEBUG
    if (((CmBattStatus->BatteryState & CM_BST_STATE_DISCHARGING) &&
         (CmBattStatus->BatteryState & CM_BST_STATE_CHARGING)   )) {
        CmBattPrint ((CMBATT_ERROR),
                       ("************************ ACPI BIOS BUG ********************\n"
                        "* CmBattGetBatteryStatus: Invalid state: _BST method returned 0x%08x for Battery State.\n"
                        "* One battery cannot be charging and discharging at the same time.\n",
                        CmBattStatus->BatteryState));
    }
//    ASSERT(!((CmBattStatus->BatteryState & CM_BST_STATE_DISCHARGING) &&
//             (CmBattStatus->BatteryState & CM_BST_STATE_CHARGING)   ));

#endif

    if (CmBattStatus->BatteryState & CM_BST_STATE_DISCHARGING) {
        ApiStatus->PowerState |= BATTERY_DISCHARGING;
        if (!(LastPowerState & BATTERY_DISCHARGING)) {
            //
            // Keep track of when battery started discharging.
            //
            CmBatt->DischargeTime = KeQueryInterruptTime();
        }
    } else if (CmBattStatus->BatteryState & CM_BST_STATE_CHARGING) {
        ApiStatus->PowerState |= (BATTERY_CHARGING | BATTERY_POWER_ON_LINE);
    }

    if (CmBattStatus->BatteryState & CM_BST_STATE_CRITICAL)
        ApiStatus->PowerState |= BATTERY_CRITICAL;

    ApiStatus->Voltage = CmBattStatus->PresentVoltage;

    //
    // Run the _PSR method on the AC adapter to get the current power status.
    // Otherwise, we don't know if it is connected, unless the battery reports charging.
    // This isn't enough information for the upper software to work properly, so
    // just find out for sure.
    //
    if (AcAdapterPdo != NULL) {

        CmBattGetPsrData (AcAdapterPdo, &AcStatus);

    } else {
        // If the AcAdapterPdo is NULL, then we need to assume the AC status from
        // the battery charging status.
        if (CmBattStatus->BatteryState & CM_BST_STATE_CHARGING) {
            AcStatus = 1;
        } else {
            AcStatus = 0;
        }
    }

    if (AcStatus == 0x01) {
        ApiStatus->PowerState |= BATTERY_POWER_ON_LINE;

        CmBattPrint ((CMBATT_TRACE | CMBATT_DATA),
                    ("CmBattGetBatteryStatus: AC adapter is connected\n"));
    } else {

        CmBattPrint ((CMBATT_TRACE | CMBATT_DATA),
                    ("CmBattGetBatteryStatus: AC adapter is NOT connected\n"));
    }

// The following is an awful hack put into the win98 version that really
// shouldn't be there.  The purpose of this is reduce the delay in notification
// when AC status changes, but this doesn't help the problem of delays when
// other events such as battery insertion or removal happen.  In addition it
// violates the priciple of WDM drivers being binary compatible, and this fix
// does nothing for any other battery driver that may later be added by a third
// party.  This should be handled by the OS maintianing an outstanding long term
// status or tag request to the composite battery at all times.  That would
// involve starting the Irps then recycleing it in the completion routine doing
// what this hack does if there was a change to report.

#ifndef _WIN32_WINNT

    // JASONCL:  check for a power source change and notify vpowerd if there has been one.

    if ( ((AcStatus & 0x01) && (CmBattPrevPowerSource == 0)) ||
            (!(AcStatus & 0x01) && (CmBattPrevPowerSource == 1)) )   {

        CmBattPrint ((CMBATT_TRACE | CMBATT_DATA),
                    ("CmBattGetBatteryStatus: Detected Power Source Change\n"));

        CmBattPrevPowerSource = AcStatus & 0x01;

        CmBattNotifyVPOWERDOfPowerChange (1);

    }

#endif

    //
    //  Decode the power/current
    //
    if (CmBatt->Info.StaticData.PowerUnit == CM_BIF_UNITS_AMPS) {
        //
        //  This battery expresses power in terms of amps.  The system expects
        //  it to be Watts, so we have to do a conversion.  The Conversion is:
        //
        //  mW = mA * Volts     or     mW = mA * mV / 1000
        //

        // Using DesignVoltage for conversions since presentvoltage
        // may vary over time, giving inconsistent results.

        if ((CmBatt->Info.StaticData.DesignVoltage != CM_UNKNOWN_VALUE) &&
            (CmBatt->Info.StaticData.DesignVoltage != 0)) {
            if (CmBattStatus->RemainingCapacity != CM_UNKNOWN_VALUE) {

                ApiStatus->Capacity = (CmBattStatus->RemainingCapacity *
                                       CmBatt->Info.StaticData.DesignVoltage +
                                       500) / 1000;
            } else {
                CmBattPrint (CMBATT_ERROR_ONLY,
                            ("CmBattGetBatteryStatus - Can't calculate RemainingCapacity \n"));
                CmBattPrint (CMBATT_ERROR_ONLY,
                            ("----------------------   RemainingCapacity = CM_UNKNOWN_VALUE\n"));

                ApiStatus->Capacity = BATTERY_UNKNOWN_CAPACITY;
            }

            if (CmBattStatus->PresentRate != CM_UNKNOWN_VALUE) {

                if (CmBattStatus->PresentRate > ((MAXULONG - 500)/ CmBatt->Info.StaticData.DesignVoltage)) {                    CmBattPrint (CMBATT_ERROR_ONLY,
                                ("CmBattGetBatteryStatus - Can't calculate Rate \n"));
                    CmBattPrint (CMBATT_ERROR_ONLY,
                                ("----------------------   Overflow: PresentRate = 0x%08x\n", CmBattStatus->PresentRate));

                    ApiStatus->Rate = BATTERY_UNKNOWN_RATE;
                }

                ApiStatus->Rate = (CmBattStatus->PresentRate      *
                                     CmBatt->Info.StaticData.DesignVoltage +
                                     500) / 1000;
            } else {
                CmBattPrint (CMBATT_ERROR_ONLY,
                            ("CmBattGetBatteryStatus - Can't calculate Rate \n"));
                CmBattPrint (CMBATT_ERROR_ONLY,
                            ("----------------------   Present Rate = CM_UNKNOWN_VALUE\n"));

                ApiStatus->Rate = BATTERY_UNKNOWN_RATE;
            }

        } else {
            CmBattPrint (CMBATT_ERROR_ONLY,
                        ("CmBattGetBatteryStatus - Can't calculate RemainingCapacity and Rate \n"));
            CmBattPrint (CMBATT_ERROR_ONLY,
                        ("----------------------   DesignVoltage = 0x%08x\n", 
                         CmBatt->Info.StaticData.DesignVoltage));
            ApiStatus->Capacity = BATTERY_UNKNOWN_CAPACITY;

            ApiStatus->Rate = BATTERY_UNKNOWN_RATE;
        }

    } else {
        //
        //  This battery expresses power in terms of Watts
        //

        ApiStatus->Capacity = CmBattStatus->RemainingCapacity;
        ApiStatus->Rate  = CmBattStatus->PresentRate;
        if (CmBattStatus->PresentRate > CM_MAX_VALUE) {
            ApiStatus->Rate = BATTERY_UNKNOWN_RATE;
            if (CmBattStatus->PresentRate != CM_UNKNOWN_VALUE) {
                CmBattPrint (CMBATT_ERROR_ONLY,
                            ("CmBattGetBatteryStatus - Rate is greater than CM_MAX_VALUE\n"));
                CmBattPrint (CMBATT_ERROR_ONLY,
                            ("----------------------   PresentRate = 0x%08x\n", CmBattStatus->PresentRate));
            }
        }
    }

    //
    // If the rate is "unkown" set it to zero
    //
    if (ApiStatus->Rate == BATTERY_UNKNOWN_RATE) {

        //
        // This is only allowed when -c-h-a-r-g-i-n-g- not discharging.
        // Batteries are allowed to return UNKNOWN_RATE when AC is online
        // but they aren't being charged.
        //
        if (CmBattStatus->BatteryState & CM_BST_STATE_DISCHARGING) {

            CmBattPrint(
                CMBATT_ERROR,
                ("CmBattGetBatteryStatus: battery rate is unkown when battery "
                 "is not charging!\n")
                );

        }

    } else {
        //
        // The OS expects the PresentRate to be a signed value, with positive values
        // indicating a charge and negative values indicating a discharge.  Since the
        // control methods only return unsigned values we need to do the conversion here.
        //

        if (ApiStatus->PowerState & BATTERY_DISCHARGING) {
            ApiStatus->Rate = 0 - ApiStatus->Rate;

        } else if (!(ApiStatus->PowerState & BATTERY_CHARGING) && (ApiStatus->Rate != 0)) {
            CmBattPrint ((CMBATT_BIOS), ("CmBattGetBatteryStatus: battery is not charging or discharging, but rate = %x\n", ApiStatus->Rate));
            ApiStatus->Rate = 0;
        } else {
            // Rate already equals 0.  Battery is not Charging or discharging.
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
CmBattVerifyStaticInfo (
    IN PCM_BATT         CmBatt,
    IN ULONG            BatteryTag
    )
/*++

Routine Description:

    In order to detect battery changes, we'll check to see if any part of the data
    returned by the cm is different from what we had read in the past.

Arguments:

    CmBatt          - Battery to read
    BatteryTag      - Tag of battery as expected by the caller

Return Value:

    Returns a boolean to indicate to the caller that IO was performed.
    This allows the caller to iterate on changes it may be making until
    the battery state is correct.

--*/
{
    NTSTATUS                Status;
    CM_BIF_BAT_INFO         NewInfo;
    ULONG                   StaResult;
    PBATTERY_INFORMATION    ApiData = &CmBatt->Info.ApiInfo;
    PCM_BIF_BAT_INFO        BIFData = &CmBatt->Info.StaticData;

    PAGED_CODE();


    CmBattPrint (CMBATT_TRACE, ("CmBattVerifyStaticInfo - CmBatt (%08x) Tag (%d) Device %d\n",
                                CmBatt, BatteryTag, CmBatt->DeviceNumber));

    Status = STATUS_SUCCESS;
    if ((CmBatt->Info.Tag == BATTERY_TAG_INVALID) || (BatteryTag != CmBatt->Info.Tag)) {
        return STATUS_NO_SUCH_DEVICE;
    }

    if ((CmBatt->CacheState == 2) && (!CmBatt->ReCheckSta)) {
        return Status;
    }

    if (CmBatt->Sleeping) {
        //
        // Return cached data, and ensure that this gets requeried when we are fully awake.
        //
        CmBattNotifyHandler (CmBatt, BATTERY_STATUS_CHANGE);
        return Status;
    }

    // Check to make sure that the battery does exist
    // before continuing
    if (CmBatt->ReCheckSta) {
        CmBatt->ReCheckSta = FALSE;
        Status = CmBattGetStaData (CmBatt->Pdo, &StaResult);
        if (NT_SUCCESS (Status)) {
            if (!(StaResult & STA_DEVICE_PRESENT)) {
                CmBatt->Info.Tag = BATTERY_TAG_INVALID;
                Status = STATUS_NO_SUCH_DEVICE;
                return Status;
            }
        }
    }

    //
    // The first time through the loop, CacheState will be 1
    // If a notification occurs, this will be reset to 0, and the loop will run again.
    // If no notification occurs, it will increment to 2, the "Valid" value.
    //

    while (NT_SUCCESS(Status)  &&  (InterlockedIncrement (&CmBatt->CacheState) == 1)) {

        //
        // Go get fresh data
        // Issue the Control method
        //

        if (CmBatt->ReCheckSta) {
            CmBatt->ReCheckSta = FALSE;
            Status = CmBattGetStaData (CmBatt->Pdo, &StaResult);

            if (NT_SUCCESS (Status)) {
                if (!(StaResult & STA_DEVICE_PRESENT)) {
                    CmBatt->Info.Tag = BATTERY_TAG_INVALID;
                    Status = STATUS_NO_SUCH_DEVICE;
                }
            }
        }

        if (NT_SUCCESS (Status)) {
            Status = CmBattGetBifData(CmBatt, &NewInfo);
        }

        if (NT_SUCCESS (Status)) {

            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("CmBattGetStaticInfo: _BIF Returned: PowerUnit=%x DesignCapacity=%x LastFull=%x\n",
                            NewInfo.PowerUnit, NewInfo.DesignCapacity, NewInfo.LastFullChargeCapacity ));

            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("    ---------------- Technology=%x Voltage=%x DesignWarning=%x\n",
                            NewInfo.BatteryTechnology, NewInfo.DesignVoltage,
                            NewInfo.DesignCapacityOfWarning ));

            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("    ---------------- DesignLow=%x Gran1=%x Gran2=%x\n",
                            NewInfo.DesignCapacityOfLow, NewInfo.BatteryCapacityGran_1,
                            NewInfo.BatteryCapacityGran_2 ));

            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("    ---------------- ModelNumber=%s \n",
                            NewInfo.ModelNumber));
            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("    ---------------- SerialNumber=%s \n",
                            NewInfo.SerialNumber));
            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("    ---------------- BatteryType=%s \n",
                            NewInfo.BatteryType));
            CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
                           ("    ---------------- OEMInformation=%s \n",
                            NewInfo.OEMInformation));

            //
            // Update static area with the new data
            //

            if ((CmBatt->Info.Tag == CmBatt->Info.StaticDataTag) && 
                (CmBatt->Info.StaticDataTag != BATTERY_TAG_INVALID)) {
                if (RtlCompareMemory (&NewInfo, BIFData, sizeof(NewInfo)) == sizeof(NewInfo)) {
                    //
                    // Nothing has changed.  Don't need to update anything.
                    //
                    continue;
                } else {
                    //
                    // Something has changed.  The tag should have been invalidated.
                    //
                    CmBattPrint ((CMBATT_BIOS | CMBATT_ERROR),
                                  ("CmBattVerifyStaticInfo: Static data changed without recieving notify 0x81.\n"));

                    CmBatt->Info.Tag = BATTERY_TAG_INVALID;
                    Status = STATUS_NO_SUCH_DEVICE;
                    CmBatt->Info.StaticDataTag = BATTERY_TAG_INVALID;

                }

            }
            CmBatt->Info.StaticDataTag = CmBatt->Info.Tag;

            RtlCopyMemory (BIFData, &NewInfo, sizeof(CM_BIF_BAT_INFO));

            RtlZeroMemory (ApiData, sizeof(BATTERY_INFORMATION));
            ApiData->Capabilities           = BATTERY_SYSTEM_BATTERY;
            ApiData->Technology             = (UCHAR) BIFData->BatteryTechnology;

            //
            // Use first four chars of BatteryType as Chemistry string
            //
            ApiData->Chemistry[0]           = BIFData->BatteryType[0];
            ApiData->Chemistry[1]           = BIFData->BatteryType[1];
            ApiData->Chemistry[2]           = BIFData->BatteryType[2];
            ApiData->Chemistry[3]           = BIFData->BatteryType[3];
            
            ApiData->CriticalBias           = 0;
            ApiData->CycleCount             = 0;

            if (BIFData->PowerUnit & CM_BIF_UNITS_AMPS) {

                //
                // This battery reports in mA we need to convert all the capacities to
                // mW because this is what the OS expects.  The algorithm for doing this
                // is:
                //
                //  mW = mA * Volts     or     mW = mA * mV / 1000
                //

                if (BIFData->DesignVoltage != CM_UNKNOWN_VALUE) {

                    //
                    // Convert the DesignCapacity
                    //

                    if (BIFData->DesignCapacity != CM_UNKNOWN_VALUE) {
                        ApiData->DesignedCapacity = (BIFData->DesignCapacity *
                                                     BIFData->DesignVoltage +
                                                     500) / 
                                                    1000;
                    } else {
                        ApiData->DesignedCapacity = BATTERY_UNKNOWN_CAPACITY;
                        
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("CmBattGetStaticInfo - Can't calculate DesignCapacity \n"));
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("--------------------  DesignCapacity = CM_UNKNOWN_VALUE\n"));
                    }


                    //
                    // Convert the LastFullChargeCapacity
                    //

                    if (BIFData->LastFullChargeCapacity != CM_UNKNOWN_VALUE) {
                        ApiData->FullChargedCapacity = (BIFData->LastFullChargeCapacity *
                                                        BIFData->DesignVoltage +
                                                        500) /
                                                       1000;
                    } else {
                        ApiData->FullChargedCapacity = BATTERY_UNKNOWN_CAPACITY;
                        
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("CmBattGetStaticInfo - Can't calculate LastFullChargeCapacity \n"));
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("--------------------  LastFullChargeCapacity = CM_UNKNOWN_VALUE\n"));
                    }


                    //
                    // Convert the DesignCapacityOfWarning
                    //

                    if (BIFData->DesignCapacityOfWarning != CM_UNKNOWN_VALUE) {
                        ApiData->DefaultAlert2 = (BIFData->DesignCapacityOfWarning *
                                                  BIFData->DesignVoltage +
                                                  500) /
                                                 1000;
                    } else {
                        ApiData->DefaultAlert2 = BATTERY_UNKNOWN_CAPACITY;
                        
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("CmBattGetStaticInfo - Can't calculate DesignCapacityOfWarning \n"));
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("--------------------  DesignCapacityOfWarning = CM_UNKNOWN_VALUE\n"));
                    }


                    //
                    // Convert the DesignCapacityOfLow
                    //

                    if (BIFData->DesignCapacityOfLow != CM_UNKNOWN_VALUE) {
                        ApiData->DefaultAlert1 = (BIFData->DesignCapacityOfLow *
                                                  BIFData->DesignVoltage +
                                                  500) /
                                                 1000;
                    } else {
                        ApiData->DefaultAlert1 = BATTERY_UNKNOWN_CAPACITY;
                        
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("CmBattGetStaticInfo - Can't calculate DesignCapacityOfLow \n"));
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("--------------------  DesignCapacityOfLow = CM_UNKNOWN_VALUE\n"));
                    }


                    //
                    // Convert the BatteryCapacityGran_1
                    //

                    if (BIFData->BatteryCapacityGran_1 != CM_UNKNOWN_VALUE) {
                        CmBatt->Info.ApiGranularity_1 = (BIFData->BatteryCapacityGran_1 *
                                                         BIFData->DesignVoltage +
                                                         500) /
                                                        1000;
                    } else {
                        CmBatt->Info.ApiGranularity_1 = BATTERY_UNKNOWN_CAPACITY;
                        
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("CmBattGetStaticInfo - Can't calculate BatteryCapacityGran_1 \n"));
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("--------------------  BatteryCapacityGran_1 = CM_UNKNOWN_VALUE\n"));
                    }


                    //
                    // Convert the BatteryCapacityGran_2
                    //

                    if (BIFData->BatteryCapacityGran_2 != CM_UNKNOWN_VALUE) {
                        CmBatt->Info.ApiGranularity_2 = (BIFData->BatteryCapacityGran_2 *
                                                         BIFData->DesignVoltage +
                                                         500) /
                                                        1000;
                    } else {
                        CmBatt->Info.ApiGranularity_2 = BATTERY_UNKNOWN_CAPACITY;
                        
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("CmBattGetStaticInfo - Can't calculate BatteryCapacityGran_2 \n"));
                        CmBattPrint (CMBATT_ERROR_ONLY,
                                    ("--------------------  BatteryCapacityGran_2 = CM_UNKNOWN_VALUE\n"));
                    }
                } else {

                    CmBattPrint (CMBATT_ERROR_ONLY,
                                ("CmBattGetStaticInfo - Can't calculate Capacities \n"));
                    CmBattPrint (CMBATT_ERROR_ONLY,
                                ("--------------------  DesignVoltage = CM_UNKNOWN_VALUE\n"));

                    ApiData->DesignedCapacity       = BATTERY_UNKNOWN_CAPACITY;
                    ApiData->FullChargedCapacity    = BATTERY_UNKNOWN_CAPACITY;
                    ApiData->DefaultAlert1          = BATTERY_UNKNOWN_CAPACITY;
                    ApiData->DefaultAlert2          = BATTERY_UNKNOWN_CAPACITY;
                    CmBatt->Info.ApiGranularity_1   = BATTERY_UNKNOWN_CAPACITY;
                    CmBatt->Info.ApiGranularity_2   = BATTERY_UNKNOWN_CAPACITY;
                }
            } else {
                ApiData->DesignedCapacity       = BIFData->DesignCapacity;
                ApiData->FullChargedCapacity    = BIFData->LastFullChargeCapacity;
                ApiData->DefaultAlert1          = BIFData->DesignCapacityOfLow;
                ApiData->DefaultAlert2          = BIFData->DesignCapacityOfWarning;
                CmBatt->Info.ApiGranularity_1   = BIFData->BatteryCapacityGran_1;
                CmBatt->Info.ApiGranularity_2   = BIFData->BatteryCapacityGran_2;

            }

            CmBatt->Info.ModelNum       = (PUCHAR) &BIFData->ModelNumber;
            CmBatt->Info.ModelNumLen    = (ULONG) strlen (CmBatt->Info.ModelNum);

            CmBatt->Info.SerialNum      = (PUCHAR) &BIFData->SerialNumber;
            CmBatt->Info.SerialNumLen   = (ULONG) strlen (CmBatt->Info.SerialNum);

            CmBatt->Info.OEMInfo        = (PUCHAR) &BIFData->OEMInformation;
            CmBatt->Info.OEMInfoLen     = (ULONG) strlen (CmBatt->Info.OEMInfo);

        }

    }

    if ((CmBatt->Info.Tag) == BATTERY_TAG_INVALID || (BatteryTag != CmBatt->Info.Tag)) {
        // If the tag has been invalidated since we started, fail the request.
        Status = STATUS_NO_SUCH_DEVICE;
    }

    if (!NT_SUCCESS (Status)) {
        // If somthing failed, make sure the cache is marked as invalid.
        InterlockedExchange (&CmBatt->CacheState, 0);
    }

    CmBattPrint (CMBATT_TRACE ,("CmBattGetStaticInfo: Exit\n"));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\cmbatt\cmbattp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CmBattp.h

Abstract:

    Control Method Battery Miniport Driver

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode

Revision History:

--*/

#ifndef FAR
#define FAR
#endif

#include <wdm.h>
#include <wmilib.h>
#include <batclass.h>
#include <devioctl.h>
#include <acpiioct.h>


#define DIRECT_ACCESS DBG
#if DIRECT_ACCESS
    #define CMB_DIRECT_IOCTL_ONLY 1
    #include "cmbdrect.h"
#endif

//
// Debug
//

#define DEBUG   DBG
#if DEBUG
    extern ULONG CmBattDebug;
    #define CmBattPrint(l,m)    if(l & CmBattDebug) DbgPrint m
#else
    #define CmBattPrint(l,m)
#endif

#define CMBATT_LOW          0x00000001
#define CMBATT_NOTE         0x00000002
#define CMBATT_WARN         0x00000004
#define CMBATT_ERROR_ONLY   0x00000008
#define CMBATT_ERROR        (CMBATT_ERROR_ONLY | CMBATT_WARN)
#define CMBATT_POWER        0x00000010
#define CMBATT_PNP          0x00000020
#define CMBATT_CM_EXE       0x00000040
#define CMBATT_DATA         0x00000100
#define CMBATT_TRACE        0x00000200
#define CMBATT_BIOS         0x00000400  // Show message to verify BIOS/HW functionality
#define CMBATT_MINI         0x00000800  // Show message to verify miniport retun data


extern UNICODE_STRING GlobalRegistryPath;

extern PDEVICE_OBJECT               AcAdapterPdo;
extern KDPC CmBattWakeDpcObject;
extern KTIMER CmBattWakeDpcTimerObject;

//
// Delay before notifications on wake = 0 seconds * 10,000,000 (100-ns/s)
//
#define WAKE_DPC_DELAY          {0,0}

//
// Delay on switch to DC before showing estimated time. 
// 15 seconds * 10,000,000 (100-ns/s)
//
#define CM_ESTIMATED_TIME_DELAY 150000000

extern LARGE_INTEGER            CmBattWakeDpcDelay;

#define MAX_DEVICE_NAME_LENGTH  100

//
// WaitWake registry key
//
extern PCWSTR                   WaitWakeEnableKey;

//
// Host Controller Device object extenstion
//

#define CM_MAX_DATA_SIZE            64
#define CM_MAX_STRING_LENGTH        256

//
//  Control Methods defined for the Control Method Batteries
//
#define CM_BIF_METHOD               (ULONG) ('FIB_')
#define CM_BST_METHOD               (ULONG) ('TSB_')
#define CM_BTP_METHOD               (ULONG) ('PTB_')
#define CM_PCL_METHOD               (ULONG) ('LCP_')
#define CM_PSR_METHOD               (ULONG) ('RSP_')
#define CM_STA_METHOD               (ULONG) ('ATS_')
#define CM_UID_METHOD               (ULONG) ('DIU_')

#define CM_OP_TYPE_READ             0
#define CM_OP_TYPE_WRITE            1


#define NUMBER_OF_BIF_ELEMENTS      13
#define NUMBER_OF_BST_ELEMENTS      4


//
// Value to send to _BTP to clear the trip point.
//

#define CM_BATT_CLEAR_TRIP_POINT   0x00000000

//
// Special values retuned from control methods.
//

#define CM_UNKNOWN_VALUE    0xffffffff
#define CM_MAX_VALUE        0x7fffffff

//
// STA control method return values
//

#define STA_DEVICE_PRESENT          0x10
#define STA_DEVICE_FUNCTIONAL       0x80

//
// Control method battery device notification values
//

#define BATTERY_DEVICE_CHECK        0x00
#define BATTERY_EJECT               0x01
#define BATTERY_STATUS_CHANGE       0x80
#define BATTERY_INFO_CHANGE         0x81

//
//  This is the static data defined by the ACPI spec for the control method battery
//  It is returned by the _BIF control method
//
typedef struct {
    ULONG                   PowerUnit;                  // units used by interface 0:mWh or 1:mAh
    ULONG                   DesignCapacity;             // Nominal capacity of a new battery
    ULONG                   LastFullChargeCapacity;     // Predicted capacity when fully charged
    ULONG                   BatteryTechnology;          // 0:Primary (not rechargable), 1:Secondary (rechargable)
    ULONG                   DesignVoltage;              // Nominal voltage of a new battery
    ULONG                   DesignCapacityOfWarning;    // OEM-designed battery warning capacity
    ULONG                   DesignCapacityOfLow;        // OEM-designed battery low capacity
    ULONG                   BatteryCapacityGran_1;      // capacity granularity between low and warning
    ULONG                   BatteryCapacityGran_2;      // capacity granularity between warning and full
    UCHAR                   ModelNumber[CM_MAX_STRING_LENGTH];
    UCHAR                   SerialNumber[CM_MAX_STRING_LENGTH];
    UCHAR                   BatteryType[CM_MAX_STRING_LENGTH];
    UCHAR                   OEMInformation[CM_MAX_STRING_LENGTH];
} CM_BIF_BAT_INFO, *PCM_BIF_BAT_INFO;

//
//  Definitions for the PowerUnit field of CM_BIF_BAT_INFO
//
#define CM_BIF_UNITS_WATTS          0   //  All units are in mWh
#define CM_BIF_UNITS_AMPS           1   //  All units are in mAh

//
//  This is the battery status data defined by the ACPI spec for a control method battery
//  It is returned by the _BST control method
//
typedef struct {
    ULONG                   BatteryState;       // Charging/Discharging/Critical
    ULONG                   PresentRate;        // Present draw rate in units defined by PowerUnit
                                                // Unsigned value, direction is determined by BatteryState
    ULONG                   RemainingCapacity;  // Estimated remaining capacity, units defined by PowerUnit
    ULONG                   PresentVoltage;     // Present voltage across the battery terminals

} CM_BST_BAT_INFO, *PCM_BST_BAT_INFO;

//
//  Bit definitions for the BatteryState field of CM_BST_BAT_INFO
//
#define CM_BST_STATE_DISCHARGING    0x00000001  //  Battery is discharging
#define CM_BST_STATE_CHARGING       0x00000002  //  Battery is charging
#define CM_BST_STATE_CRITICAL       0x00000004  //  Battery is critical

//
// Cached battery info
//

typedef struct {
    ULONG                   Tag;                // Unique tag for this battery,
    ULONG                   ModelNumLen;        // Length of ModelNumber string in StringBuffer
    PUCHAR                  ModelNum;           // Ptr to ModelNumber in StringBuffer
    ULONG                   SerialNumLen;       // Length of SerialNumber string in StringBuffer
    PUCHAR                  SerialNum;          // Ptr to SerialNumber in StringBuffer
    ULONG                   OEMInfoLen;         // Length of OEMInformation string in StringBuffer
    PUCHAR                  OEMInfo;            // Ptr to OEMInformation in StringBuffer

    CM_BST_BAT_INFO         Status;             // Last Status read from battery
    CM_BIF_BAT_INFO         StaticData;         // Last valid data
    ULONG                   StaticDataTag;      // Tag when static data was last read

    BATTERY_STATUS          ApiStatus;          // Status info, class driver structure
    BATTERY_INFORMATION     ApiInfo;            // Battery info, class driver structure
    ULONG                   ApiGranularity_1;
    ULONG                   ApiGranularity_2;

    BOOLEAN                 BtpExists;          // Remeber if _BTP method exists

} STATIC_BAT_INFO, *PSTATIC_BAT_INFO;


typedef struct {
    ULONG                   Granularity;
    ULONG                   Capacity;

} BATTERY_REMAINING_SCALE, *PBATTERY_REMAINING_SCALE;

typedef struct {
    ULONG                   Setting;            // The alarm value
    BOOLEAN                 Supported;          // Set to false when _BTP fails
                                                //  don't bother calling _BTP again
} BAT_ALARM_INFO, *PBAT_ALARM_INFO;

#define CM_ALARM_INVALID 0xffffffff;

//
// Types for the different FDOs created by this driver.
//

#define AC_ADAPTER_TYPE     0x00
#define CM_BATTERY_TYPE     0x01



//
// Pagable device extension for control method battery
//

typedef struct _CM_BATT {

    ULONG                   Type;               // Battery or AC Adapter

    PDEVICE_OBJECT          DeviceObject;       // Battery device object
    PDEVICE_OBJECT          Fdo;                // Functional Device Object
    PDEVICE_OBJECT          Pdo;                // Physical Device Object
    PDEVICE_OBJECT          LowerDeviceObject;  // Detected at AddDevice time

    FAST_MUTEX              OpenCloseMutex;
    ULONG                   OpenCount;          // Count open file handles to device

    PIRP                    WaitWakeIrp;        // Pointer to Wait Wake Irp
    POWER_STATE             WakeSupportedState;
    WMILIB_CONTEXT          WmiLibContext;
    BOOLEAN                 WakeEnabled;

    BOOLEAN                 WantToRemove;       // Syncronize device removal
    LONG                    InUseCount;
    KEVENT                  ReadyToRemove;

    ULONG                   DeviceNumber;

    PUNICODE_STRING         DeviceName;

    ACPI_INTERFACE_STANDARD AcpiInterfaces;

    BOOLEAN                 Sleeping;
    UCHAR                   ActionRequired;

    //
    // All fields before this point are common between _CM_BATT and _AC_ADAPTER
    //

    PVOID                   Class;              // Battery Class handle

    BOOLEAN                 IsStarted;          // if non zero, the device is started
    BOOLEAN                 ReCheckSta;
    LONG                    CacheState;         // 0 = invalid
                                                // 1 = updating values
                                                // 2 = valid
    //
    // Battery
    //
    ULONG                   TagCount;           // Tag for next battery
    STATIC_BAT_INFO         Info;
    BAT_ALARM_INFO          Alarm;
    ULONGLONG               DischargeTime;      // Time battery started discharging.

} CM_BATT, *PCM_BATT;


//
// Pagable device extension for AC Adapter
//

typedef struct _AC_ADAPTER {

    ULONG                   Type;               // Battery or AC Adapter

    PDEVICE_OBJECT          DeviceObject;       // Battery device object
    PDEVICE_OBJECT          Fdo;                // Functional Device Object
    PDEVICE_OBJECT          Pdo;                // Physical Device Object
    PDEVICE_OBJECT          LowerDeviceObject;  // Detected at AddDevice time

    FAST_MUTEX              OpenCloseMutex;
    ULONG                   OpenCount;          // Count open file handles to device

    PIRP                    WaitWakeIrp;        // Pointer to Wait Wake Irp
    POWER_STATE             WakeSupportedState;
    WMILIB_CONTEXT          WmiLibContext;
    BOOLEAN                 WakeEnabled;

    BOOLEAN                 WantToRemove;       // Syncronize device removal
    LONG                    InUseCount;
    KEVENT                  ReadyToRemove;

    ULONG                   DeviceNumber;

    PUNICODE_STRING         DeviceName;

    ACPI_INTERFACE_STANDARD AcpiInterfaces;

    BOOLEAN                 Sleeping;
    UCHAR                   ActionRequired;

} AC_ADAPTER, *PAC_ADAPTER;

// Action required (AR) flags
#define CMBATT_AR_NO_ACTION 0
#define CMBATT_AR_NOTIFY 1
#define CMBATT_AR_INVALIDATE_CACHE 2
#define CMBATT_AR_INVALIDATE_TAG 4

//
// Use the IoSkipCurrentIrpStackLocation routine because the we
// don't need to change arguments, or a completion routine
//

#define CmBattCallLowerDriver(Status, DeviceObject, Irp) { \
                  IoSkipCurrentIrpStackLocation(Irp);         \
                  Status = IoCallDriver(DeviceObject,Irp); \
                  }

#define GetTid() PsGetCurrentThread()

//
// Prototypes
//

VOID
CmBattAlarm (
    IN PVOID                Context,
    IN UCHAR                Address,
    IN USHORT               Data
    );

NTSTATUS
CmBattVerifyStaticInfo (
    IN PCM_BATT             CmBatt,
    IN ULONG                BatteryTag
    );

NTSTATUS
CmBattPnpDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
CmBattPowerDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
CmBattSystemControl(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    );

NTSTATUS
CmBattForwardRequest(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    );

NTSTATUS
CmBattAddDevice(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       Pdo
    );

NTSTATUS
CmBattQueryTag (
    IN PVOID                Context,
    OUT PULONG              BatteryTag
    );

NTSTATUS
CmBattSetStatusNotify (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    IN PBATTERY_NOTIFY      BatteryNotify
    );

NTSTATUS
CmBattDisableStatusNotify (
    IN PVOID                Context
    );

NTSTATUS
CmBattQueryStatus (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    OUT PBATTERY_STATUS     BatteryStatus
    );

NTSTATUS
CmBattGetBifData(
    IN PCM_BATT             CmBatt,
    OUT PCM_BIF_BAT_INFO    BifBuf
    );

NTSTATUS
CmBattGetUniqueId(
    IN PDEVICE_OBJECT       Pdo,
    OUT PULONG              UniqueId
    );

NTSTATUS
CmBattGetStaData(
    IN PDEVICE_OBJECT        Pdo,
    OUT PULONG              ReturnStatus
    );

NTSTATUS
CmBattGetPsrData(
    IN PDEVICE_OBJECT   Pdo,
    OUT PULONG          ReturnStatus
    );

NTSTATUS
CmBattIoCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PKEVENT              pdoIoCompletedEvent
    );

NTSTATUS
CmBattSetTripPpoint(
    IN PCM_BATT             CmBatt,
    IN ULONG                TripPoint
    );

NTSTATUS
CmBattGetBstData(
    IN PCM_BATT             CmBatt,
    OUT PCM_BST_BAT_INFO    BstBuf
    );

NTSTATUS
GetDwordElement (
    IN  PACPI_METHOD_ARGUMENT   Argument,
    OUT PULONG                  PDword
    );

NTSTATUS
GetStringElement (
    IN  PACPI_METHOD_ARGUMENT   Argument,
    OUT PUCHAR                  PBuffer
    );

VOID
CmBattPowerCallBack(
    IN  PVOID   CallBackContext,
    IN  PVOID   Argument1,
    IN  PVOID   Argument2
    );

VOID
CmBattWakeDpc (
    IN  PKDPC   Dpc,
    IN  PVOID   DefferedContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    );

VOID
CmBattNotifyHandler (
    IN PVOID                Context,
    IN ULONG                NotifyValue
    );

NTSTATUS
CmBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN LONG                             AtRate OPTIONAL,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    );

NTSTATUS
CmBattSendDownStreamIrp(
    IN  PDEVICE_OBJECT      Pdo,
    IN  ULONG               Ioctl,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputSize,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputSize
    );

NTSTATUS
CmBattWaitWakeLoop(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    );

NTSTATUS
CmBattWmiRegistration(
    PCM_BATT CmBatt
);

NTSTATUS
CmBattWmiDeRegistration(
    PCM_BATT CmBatt
);

#ifndef _WIN32_WINNT

VOID
CmBattNotifyVPOWERDOfPowerChange (
    IN  ULONG PowerSourceChange
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\battc\app\compbatt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

Abstract:

Author:

   Ken Reneris

Environment:

   console

--*/

//
// set variable to define global variables
//

#include <tchar.h>
#include <wchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <initguid.h>
#include <devguid.h>

#include <errno.h>
//#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>
#include <batclass.h>

#include <setupapi.h>

//
// Misc constants
//
#define RANGE                           1
#define MAX_NUMBER_OF_BATTERIES         8
#define MAX_DEVICE_NAME_LENGTH          100

//
// Battery Device Names
//
PVOID COMPOSITE_NAME    = _T("\\Device\\CompositeBattery");

//
// Globals
//
BOOLEAN                 LongTerm = FALSE;

#pragma pack(1)
typedef struct          _ID_MAP {
    UCHAR                   LocalId;
    UCHAR                   ActualId;
} ID_MAP, *PID_MAP;
#pragma pack()


#pragma pack(1)
typedef struct _MFG_DATE {

    UCHAR               Day;            // 1-31
    UCHAR               Month;          // 1-12
    USHORT          Year;               // 1996 - ?
} MFG_DATE, *PMFG_DATE;
#pragma pack()




/*******************************************************************************
*
*  GetBatteryDriverNames
*
*  DESCRIPTION: Finds all battery class devices
*
*  PARAMETERS:
*      DriverNames - pointer to an array of UNICODE_STRING structures to fill in
*      MaxBatteries - number of elements in DriverNames array
*
*  RETURN VALUE: The number of batteries found
*                Will always find the Composite battery whether it exists or not
*
*******************************************************************************/

UCHAR GetBatteryDriverNames(UNICODE_STRING * DriverNames, UCHAR MaxBatteries)
{
    UCHAR                               driverCount, index;
    DWORD                               reqSize;
    HDEVINFO                            devInfo;
    SP_INTERFACE_DEVICE_DATA            interfaceDevData;
    PSP_INTERFACE_DEVICE_DETAIL_DATA    funcClassDevData;

    if ((MaxBatteries == 0) || (DriverNames == NULL)) {
        return 0;
    }

    driverCount = 0;

    // Hard code the first battery to be the composite battery.

    RtlInitUnicodeString (&DriverNames[driverCount], COMPOSITE_NAME);
    driverCount++;

    // Use the SETUPAPI.DLL interface to get the
    // possible battery driver names.
    devInfo = SetupDiGetClassDevs((LPGUID)&GUID_DEVICE_BATTERY, NULL, NULL,
                                   DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);

    if (devInfo != INVALID_HANDLE_VALUE) {
        interfaceDevData.cbSize = sizeof(SP_DEVINFO_DATA);

        index = 0;
        while (driverCount < MaxBatteries) {
            if (SetupDiEnumInterfaceDevice(devInfo,
                                           0,
                                           (LPGUID)&GUID_DEVICE_BATTERY,
                                           index,
                                           &interfaceDevData)) {

                // Get the required size of the function class device data.
                SetupDiGetInterfaceDeviceDetail(devInfo,
                                                &interfaceDevData,
                                                NULL,
                                                0,
                                                &reqSize,
                                                NULL);

                funcClassDevData = LocalAlloc(0, reqSize);
                if (funcClassDevData != NULL) {
                    funcClassDevData->cbSize =
                        sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);

                    if (SetupDiGetInterfaceDeviceDetail(devInfo,
                                                        &interfaceDevData,
                                                        funcClassDevData,
                                                        reqSize,
                                                        &reqSize,
                                                        NULL)) {

                        reqSize = (lstrlen(funcClassDevData->DevicePath) + 1)
                                    * sizeof(TCHAR);

                            RtlInitUnicodeString(
                                &DriverNames[driverCount],
                                funcClassDevData->DevicePath
                            );
                            driverCount++;
                    }
                    else {
                        printf("SetupDiGetInterfaceDeviceDetail, failed: %d", GetLastError());
                    }

                    LocalFree(funcClassDevData);
                }
            } else {
                if (ERROR_NO_MORE_ITEMS == GetLastError()) {
                    break;
                }
                else {
                    printf ("SetupDiEnumInterfaceDevice, failed: %d", GetLastError());
                }
            }
            index++;
        }
        SetupDiDestroyDeviceInfoList(devInfo);
    }
    else {
        printf("SetupDiGetClassDevs on GUID_DEVICE_BATTERY, failed: %d", GetLastError());
    }
    return driverCount;
}


HANDLE
OpenBattery (PUNICODE_STRING BatteryName)
{
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   ObjA;
    IO_STATUS_BLOCK     IOSB;
    HANDLE              driverHandle;

    DWORD               lastError;


    // HACK: I can't seems to find the correct device
    // names, so I can't open the composite battery using CreateFile()
    // and I can't open the detected batteries using NtOpenFile(), so I
    // have to use a different method of opening the battery depending on
    // which battery it is.
    if (BatteryName->Buffer == COMPOSITE_NAME) {
        InitializeObjectAttributes(
            &ObjA,
            BatteryName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

        status = NtOpenFile (
            &driverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,     // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

        if (!NT_SUCCESS(status)) {
            printf ("Error opening %ws: NTSTATUS = 0x%08lx\n",
                    BatteryName->Buffer, status);
            return NULL;
        }
    } else {
        driverHandle = CreateFile (BatteryName->Buffer,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

        if (INVALID_HANDLE_VALUE == driverHandle) {
            lastError = GetLastError ();
            printf ("Error opening %ws: GetLastError = 0x%08lx \n",
                    BatteryName->Buffer, lastError);
            return NULL;
        }
    }

    printf("Opened %ws \n", BatteryName->Buffer);

    return driverHandle;
}


ULONG
GetBatteryTag (HANDLE DriverHandle)
{
    NTSTATUS        Status;
    IO_STATUS_BLOCK IOSB;
    ULONG           BatteryTag;
    ULONG           Timeout = 0;

    if (LongTerm) {
        Timeout = (ULONG)-1;
    }

    Status = NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            IOCTL_BATTERY_QUERY_TAG,
            &Timeout,                   // input buffer
            sizeof (Timeout),
            &BatteryTag,            // output buffer
            sizeof (BatteryTag)
            );


    if (!NT_SUCCESS(Status)) {
        BatteryTag = BATTERY_TAG_INVALID;
        if (Status == STATUS_NO_SUCH_DEVICE) {
            printf ("(Battery is not physically present or is not connected)\n");
        } else {
            printf ("Query Battery tag failed: Status = %x\n", Status);
        }

    }

    printf("Battery Tag = 0x%08lx.\n", BatteryTag);
    return BatteryTag;
}


BOOLEAN
GetBatteryInfo (
    HANDLE DriverHandle,
    ULONG BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    OUT PVOID Buffer,
    IN ULONG BufferLength
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    BATTERY_QUERY_INFORMATION   BInfo;

    memset (Buffer, 0, BufferLength);
    BInfo.BatteryTag = BatteryTag;
    BInfo.InformationLevel = Level;
    BInfo.AtRate = 0;                       // This is needed for reading estimated time correctly.

    Status = NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            IOCTL_BATTERY_QUERY_INFORMATION,
            &BInfo,                 // input buffer
            sizeof (BInfo),
            Buffer,                 // output buffer
            BufferLength
            );


    if (!NT_SUCCESS(Status)) {

        if ((Status == STATUS_INVALID_PARAMETER)        ||
            (Status == STATUS_INVALID_DEVICE_REQUEST)   ||
            (Status == STATUS_NOT_SUPPORTED)) {

            printf ("Not Supported by Battery, Level %x, Status: %x\n", Level, Status);
        } else {
            printf ("Query failed: Level %x, Status = %x\n", Level, Status);
        }

        return FALSE;
    }

    return TRUE;
}




VOID
GetBatteryStatus (
    HANDLE DriverHandle,
    IN  PBATTERY_WAIT_STATUS    WaitStatus,
    IN  PBATTERY_INFORMATION    BInfo,
    OUT PBATTERY_STATUS         BatteryStatus
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    ULONG                       Volts;


    memset (BatteryStatus, 0xAB, sizeof(BatteryStatus));

    Status = NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            IOCTL_BATTERY_QUERY_STATUS,
            WaitStatus,            // input buffer
            sizeof (BATTERY_WAIT_STATUS),
            BatteryStatus,         // output buffer
            sizeof (BATTERY_STATUS)
            );

    //
    // dump battery status
    //
    printf ("[Current Status Information]\n");
    printf ("    Power State...........: ");

    if (!NT_SUCCESS(Status)) {
        printf ("Query failed: Status = %x\n", Status);
        return ;
    }


    //
    // Print the PowerState
    //

    printf ("%08x  ", BatteryStatus->PowerState);

    if (BatteryStatus->PowerState & BATTERY_POWER_ON_LINE) {
        printf ("Power_Online ");
    }

    if (BatteryStatus->PowerState & BATTERY_DISCHARGING) {
        printf ("Discharging ");
    }

    if (BatteryStatus->PowerState & BATTERY_CHARGING) {
        printf ("Charging ");
    }

    if (BatteryStatus->PowerState & BATTERY_CRITICAL) {
        printf ("Critical! ");
    }

    if (BatteryStatus->PowerState == 0) {
        printf ("No flags set.");
    }

    printf ("\n");


    //
    // Print the Voltage
    //

    Volts = BatteryStatus->Voltage;
    if (Volts == BATTERY_UNKNOWN_VOLTAGE) {
        printf ("    Voltage...............: %08x  UNKNOWN\n", Volts);
    } else {
        printf ("    Voltage...............: %08x  %d.%03d V\n", Volts, (Volts/1000), Volts - ((Volts/1000)*1000));
    }


    //
    // Print the Rate
    //

    if (BatteryStatus->Rate == BATTERY_UNKNOWN_RATE) {
        printf ("    Rate..................: %08x  UNKNOWN\n",  BatteryStatus->Rate);
    } else {
        if (BInfo->Capabilities & BATTERY_CAPACITY_RELATIVE) {
            printf ("    Rate..................: %08x  %d % per hour  ",  BatteryStatus->Rate,  BatteryStatus->Rate);
        } else {
            printf ("    Rate..................: %08x  %d mW  ",  BatteryStatus->Rate,  BatteryStatus->Rate);
        }

        if (BatteryStatus->PowerState & BATTERY_CHARGING) {
            printf ("(Charging)\n");
        } else if (BatteryStatus->PowerState & BATTERY_DISCHARGING) {
            printf ("(Discharging)\n");
        } else {
            printf ("(Quiescent)\n");
        }
    }


    //
    // Print the Current Capacity
    //

    if (BatteryStatus->Capacity == BATTERY_UNKNOWN_CAPACITY) {
        printf ("    Current Battery Charge: %08x  UNKNOWN\n");
    } else {
        printf ("    Current Battery Charge: %08x  ",  BatteryStatus->Capacity);

        if (BatteryStatus->Capacity == 0xFFFF) {
            printf ("Invalid");
        } else {
            printf ("%d mWh ", BatteryStatus->Capacity);
        }
        if ((BInfo->FullChargedCapacity != 0) &
            (BInfo->FullChargedCapacity != BATTERY_UNKNOWN_CAPACITY)){
            printf ("(%d%%)",
                    BatteryStatus->Capacity * 100 / BInfo->FullChargedCapacity);
        }
        printf ("\n");
    }

    printf ("\n");
}




void
QueryBattery (PUNICODE_STRING BatteryName)
{
    HANDLE                  driverHandle;
    ULONG                   batteryTag;
    BATTERY_INFORMATION     BInfo;
    ULONG                   BETime;
    WCHAR                   BDeviceName[MAX_BATTERY_STRING_SIZE];
    MFG_DATE                BManDate;
    WCHAR                   BManName[MAX_BATTERY_STRING_SIZE];
    ULONG                   BETemp;
    WCHAR                   BEUID[MAX_BATTERY_STRING_SIZE];
    BATTERY_REPORTING_SCALE BEGran[4];
    BATTERY_WAIT_STATUS     WStat;
    BATTERY_STATUS          BStat;
    ULONG                   i;
    ULONG                   Cent;
    ULONG                   Far;

    if ((driverHandle = OpenBattery (BatteryName)) == NULL) {
        return;
    }

    printf ("Opened driver w/handle %d\n", driverHandle);

    batteryTag = GetBatteryTag (driverHandle);
    if (batteryTag == BATTERY_TAG_INVALID) {
        NtClose(driverHandle);
        return;
    }

    printf ("[Static Information]\n");
    printf ("    Battery Tag...........: %x\n", batteryTag);

    //
    // Get generic info
    //

    if (GetBatteryInfo (driverHandle, batteryTag, BatteryInformation, &BInfo, sizeof(BInfo))) {

        //
        // Print the Capabilities
        //

        printf ("    Capabilities..........: ");

        printf ("%08x  ",  BInfo.Capabilities);

        if (BInfo.Capabilities & BATTERY_SYSTEM_BATTERY) {
            printf ("System ");
        }

        if (BInfo.Capabilities & BATTERY_CAPACITY_RELATIVE) {
            printf ("Capacity_Relative ");
        }

        if (BInfo.Capabilities & BATTERY_IS_SHORT_TERM) {
            printf ("Short_Term ");
        }
        printf ("\n");


        //
        // Print the Technology
        //

        printf ("    Technology............: %08x  ",  BInfo.Technology);

        if (BInfo.Technology == 0) {
            printf ("Primary Battery ");
        } else if (BInfo.Technology == 1) {
            printf ("Secondary Battery ");
        } else {
            printf ("Unknown ");
        }
        printf ("\n");


        //
        // Print the Chemistry
        //

        printf ("    Chemistry.............: %4.4s\n", BInfo.Chemistry);


        //
        // Print the Designed Capacity
        //

        printf ("    Designed Capacity.....: ");

        if (BInfo.DesignedCapacity == BATTERY_UNKNOWN_CAPACITY) {
            printf ("%08x  UNKNOWN\n", BInfo.DesignedCapacity);
        } else {
            if (BInfo.Capabilities & BATTERY_CAPACITY_RELATIVE) {
                printf ("%08x  %d%%\n", BInfo.DesignedCapacity, BInfo.DesignedCapacity);
            } else {
                printf ("%08x  %d mWh\n", BInfo.DesignedCapacity, BInfo.DesignedCapacity);
            }
        }


        //
        // Print the Full Charged Capacity
        //

        printf ("    Full Charged Capacity.: ");

        if (BInfo.FullChargedCapacity == BATTERY_UNKNOWN_CAPACITY) {
            printf ("%08x  UNKNOWN\n", BInfo.FullChargedCapacity);
        } else {
            if (BInfo.Capabilities & BATTERY_CAPACITY_RELATIVE) {
                printf ("%08x  %d%%\n", BInfo.FullChargedCapacity, BInfo.FullChargedCapacity);
            } else {
                printf ("%08x  %d mWh\n", BInfo.FullChargedCapacity, BInfo.FullChargedCapacity);
            }
        }

        if ((BInfo.FullChargedCapacity == 0) ||
            (BInfo.FullChargedCapacity == BATTERY_UNKNOWN_CAPACITY)){
            //
            // Print Alert 1
            //

            printf ("    Default Alert1 (crit).: %08x  %d mWh\n",
                    BInfo.DefaultAlert1, BInfo.DefaultAlert1);


            //
            // Print Alert 2
            //

            printf ("    Default Alert2 (low)..: %08x  %d mWh (%d%%)\n",
                    BInfo.DefaultAlert2, BInfo.DefaultAlert2);

        } else {

            //
            // Print Alert 1
            //

            printf ("    Default Alert1 (crit).: %08x  %d mWh (%d%%)\n",
                    BInfo.DefaultAlert1, BInfo.DefaultAlert1,
                    (BInfo.DefaultAlert1*100)/BInfo.FullChargedCapacity);


            //
            // Print Alert 2
            //

            printf ("    Default Alert2 (low)..: %08x  %d mWh (%d%%)\n",
                    BInfo.DefaultAlert2, BInfo.DefaultAlert2,
                    (BInfo.DefaultAlert2*100)/BInfo.FullChargedCapacity);
        }

        //
        // Print the Critical Bias
        //

        printf ("    Critical Bias.........: %08x\n", BInfo.CriticalBias);


        //
        // Print the Cycle Count
        //

        printf ("    Cycle Count...........: %08x  %d\n", BInfo.CycleCount, BInfo.CycleCount);
    }


    //
    // Print the battery granularity
    //

    printf ("    Granularity...........: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryGranularityInformation, BEGran, sizeof(BEGran))) {

        printf ("%08x  Capacity(1) %08x\n", BEGran[0].Granularity, BEGran[0].Capacity);

        for (i = 1; i < 4; i++) {
            if ((BEGran[i].Granularity != -1) && (BEGran[i].Granularity != 0)) {
            printf ("                            %08x  Capacity(%d) %08x\n",
                BEGran[i].Granularity, (i+1), BEGran[i].Capacity);
            }
        }
    }


    //
    // Print the temperature
    //

    printf ("    Temperature...........: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryTemperature,     &BETemp,      sizeof(BETemp))) {
        printf ("%08x", BETemp);

        //
        // Print temp as something reasonable - Centigrade and Fahrenheit
        //
        if (BETemp > 0) {
            Cent = (BETemp/10) - 273;
            Far = ((Cent*2) - (Cent/5)) + 32;
            printf ("  %d C  %d F", Cent, Far);
        }
        printf ("\n");
    }


    //
    // Print the Unique ID
    //

    printf ("    Unique ID.............: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryUniqueID,        BEUID,       sizeof(BEUID))) {
        printf ("%ws\n",  BEUID);
    }


    //
    // Print the estimated run time
    //

    printf ("    Estimated Runtime.....: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryEstimatedTime,   &BETime,      sizeof(BETime))) {
        printf ("%08x  ", BETime);

        if (BETime != BATTERY_UNKNOWN_TIME) {
            printf ("%d Seconds ", BETime);
            printf ("(%d:%d:%d)", BETime / 3600, (BETime % 3600) / 60, (BETime % 3600) % 60);
        } else {
            printf ("Not Available");
        }
        printf ("\n");
    }


    //
    // Print the device name
    //

    printf ("    Device Name...........: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryDeviceName,       BDeviceName, sizeof(BDeviceName))) {
        printf ("%ws\n",  BDeviceName);
    }


    //
    // Print the manufacture date
    //

    printf ("    Manufacture Date......: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryManufactureDate,  &BManDate,    sizeof(BManDate))) {
        printf ("%02X%02X%04X  %02d/%02d/%d\n", BManDate.Month, BManDate.Day, BManDate.Year,
                        BManDate.Month, BManDate.Day, BManDate.Year);
    }


    //
    // Print the manufacturer name
    //

    printf ("    Manufacturer Name.....: ");
    if (GetBatteryInfo (driverHandle, batteryTag, BatteryManufactureName,  BManName,    sizeof(BManName))) {
        printf ("%ws\n",  BManName);
    }

    printf ("\n");


    //
    // Get the battery status and print it out
    //

    memset (&WStat, 0, sizeof(WStat));
    WStat.BatteryTag = batteryTag;

    GetBatteryStatus (driverHandle, &WStat, &BInfo, &BStat);

    //
    // If the user requested it perform a long term status change request
    //

    if (LongTerm) {

        printf ("Starting long-term status change request (5 min.)\n");

        WStat.PowerState = BStat.PowerState;
        WStat.LowCapacity = BStat.Capacity - RANGE;
        WStat.HighCapacity = BStat.Capacity + RANGE;
        WStat.Timeout = 50000000;  // 5 min
        GetBatteryStatus (driverHandle, &WStat, &BInfo, &BStat);
    }

    NtClose(driverHandle);
}


int
__cdecl
main(USHORT argc, CHAR **argv)
{
    ULONG           battTag;
    ULONG           battNum;
    ULONG           RetVal;
    UCHAR           param;
    UNICODE_STRING  batteries [MAX_NUMBER_OF_BATTERIES];
    UCHAR           numBatts;


    RtlZeroMemory (batteries, sizeof(UNICODE_STRING)*MAX_NUMBER_OF_BATTERIES);

    _tprintf (_T("Parameters: [L] - Issue Long-term status change request\n"));

    if (argc > 1) {
        param = argv[1][0];

        if ((param == 'l') || param == 'L') {
            LongTerm = TRUE;
        }
    }



    while (1) {

        numBatts = GetBatteryDriverNames (batteries, MAX_NUMBER_OF_BATTERIES);

        printf ("\n");
        for (battNum = 0; battNum < numBatts; battNum++) {
            _tprintf(_T("Batt#%d: %s \n"), battNum, batteries[battNum].Buffer);
        }

        printf ("\nBattery Number: ");
        if (scanf ("%d", &battNum) != 1) {
            return 0;                                   // Program exit
        }
        printf ("\n");

        if (battNum < numBatts) {

            QueryBattery (&batteries [battNum]);

        } else {
            printf ("Invalid Battery Number\n");
        }

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\cmbatt\cmbdrect.h ===
//
// Direct Access IOCTLs
//

#define IOCTL_CMBATT_UID      \
    CTL_CODE(FILE_DEVICE_BATTERY, 0x101, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CMBATT_STA      \
    CTL_CODE(FILE_DEVICE_BATTERY, 0x102, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CMBATT_PSR      \
    CTL_CODE(FILE_DEVICE_BATTERY, 0x103, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CMBATT_BTP      \
    CTL_CODE(FILE_DEVICE_BATTERY, 0x104, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CMBATT_BIF      \
    CTL_CODE(FILE_DEVICE_BATTERY, 0x105, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CMBATT_BST      \
    CTL_CODE(FILE_DEVICE_BATTERY, 0x106, METHOD_BUFFERED, FILE_READ_ACCESS)
    

#if (CMB_DIRECT_IOCTL_ONLY != 1)

#define CM_MAX_STRING_LENGTH        256

//
//  This is the static data defined by the ACPI spec for the control method battery
//  It is returned by the _BIF control method
//
typedef struct {
    ULONG                   PowerUnit;                  // units used by interface 0:mWh or 1:mAh
    ULONG                   DesignCapacity;             // Nominal capacity of a new battery
    ULONG                   LastFullChargeCapacity;     // Predicted capacity when fully charged
    ULONG                   BatteryTechnology;          // 0:Primary (not rechargable), 1:Secondary (rechargable)
    ULONG                   DesignVoltage;              // Nominal voltage of a new battery
    ULONG                   DesignCapacityOfWarning;    // OEM-designed battery warning capacity
    ULONG                   DesignCapacityOfLow;        // OEM-designed battery low capacity
    ULONG                   BatteryCapacityGran_1;      // capacity granularity between low and warning
    ULONG                   BatteryCapacityGran_2;      // capacity granularity between warning and full
    UCHAR                   ModelNumber[CM_MAX_STRING_LENGTH];
    UCHAR                   SerialNumber[CM_MAX_STRING_LENGTH];
    UCHAR                   BatteryType[CM_MAX_STRING_LENGTH];
    UCHAR                   OEMInformation[CM_MAX_STRING_LENGTH];
} CM_BIF_BAT_INFO, *PCM_BIF_BAT_INFO;

//
//  This is the battery status data defined by the ACPI spec for a control method battery
//  It is returned by the _BST control method
//
typedef struct {
    ULONG                   BatteryState;       // Charging/Discharging/Critical
    ULONG                   PresentRate;        // Present draw rate in units defined by PowerUnit
                                                // Unsigned value, direction is determined by BatteryState
    ULONG                   RemainingCapacity;  // Estimated remaining capacity, units defined by PowerUnit
    ULONG                   PresentVoltage;     // Present voltage across the battery terminals

} CM_BST_BAT_INFO, *PCM_BST_BAT_INFO;

#endif // (CMB_DIRECT_IOCTL_ONLY != 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\battc\bsrv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    bsrv.c

Abstract:

    Service battery class device

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "battcp.h"

VOID
BattCIoctl (
    IN PBATT_INFO           BattInfo,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp
    );

VOID
BattCCheckTagQueue (
    IN PBATT_NP_INFO    BattNPInfo,
    IN PBATT_INFO       BattInfo
    );

VOID
BattCCheckStatusQueue (
    IN PBATT_NP_INFO    BattNPInfo,
    IN PBATT_INFO       BattInfo
    );

VOID
BattCWmi (
    IN PBATT_NP_INFO    BattNPInfo,
    IN PBATT_INFO       BattInfo,
    IN PBATT_WMI_REQUEST WmiRequest
    );

VOID
BattCMiniportStatus (
    IN PBATT_INFO   BattInfo,
    IN NTSTATUS     Status
    );

VOID
BattCCompleteIrpQueue (
    IN PLIST_ENTRY  Queue,
    IN NTSTATUS     Status
    );

VOID
BattCCompleteWmiQueue (
    IN PLIST_ENTRY  Queue,
    IN NTSTATUS     Status
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,BattCCheckStatusQueue)
#pragma alloc_text(PAGE,BattCCheckTagQueue)
#pragma alloc_text(PAGE,BattCWorkerThread)
#pragma alloc_text(PAGE,BattCIoctl)
#endif

VOID
BattCWorkerDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    DPC used to get worker thread when status needs to be checked.

Arguments:

    Dpc     - the worker dpc

Return Value:

    None.

--*/
{
    PBATT_NP_INFO   BattNPInfo;

    BattNPInfo = (PBATT_NP_INFO) DeferredContext;
    BattCQueueWorker (BattNPInfo, TRUE);
    // Release Removal Lock
    if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
        KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
    }
    BattPrint ((BATT_LOCK), ("BattCWorkerDpc: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

}



VOID
BattCTagDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    DPC used to get worker thread when status needs to be checked.

Arguments:

    Dpc     - the worker dpc

Return Value:

    None.

--*/
{
    PBATT_NP_INFO   BattNPInfo;

    BattNPInfo = (PBATT_NP_INFO) DeferredContext;
    InterlockedExchange(&BattNPInfo->CheckTag, 1);
    BattCQueueWorker (BattNPInfo, FALSE);
    // Release Removal Lock
    if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
        KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
    }
    BattPrint ((BATT_LOCK), ("BattCTagDpc: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));
}



VOID
BattCCancelStatus (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Queued status IRP is being canceled

Arguments:

    DeviceObject    - Device object of the miniport.  Not useful to the
                      class driver - ignored.

    Irp             - Irp being cancelled

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION      IrpNextSp;
    PBATT_NP_INFO           BattNPInfo;

    //
    // IRP is flagged as needing cancled, cause a check status which will
    // complete any pending cancled irps
    //

    IrpNextSp = IoGetNextIrpStackLocation(Irp);
    BattNPInfo = (PBATT_NP_INFO) IrpNextSp->Parameters.Others.Argument4;

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryCCancelStatus. Irp - %08x\n", BattNPInfo->DeviceNum, Irp));

    BattCQueueWorker (BattNPInfo, TRUE);

    //
    // The cancel Spinlock must be released after attempting to queue the
    // worker thread so that there is no timeing problems on remove.
    //
    IoReleaseCancelSpinLock(Irp->CancelIrql);
}



VOID
BattCCancelTag (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Queued tag IRP is being canceled

Arguments:

    DeviceObject    - Device object of the miniport.  Not useful to the
                      class driver - ignored.

    Irp             - Irp being cancelled

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION      IrpNextSp;
    PBATT_NP_INFO           BattNPInfo;

    //
    // IRP is flagged as needing canceled.  Cause a check tag which will
    // complete any pending cancled irps
    //

    IrpNextSp = IoGetNextIrpStackLocation(Irp);
    BattNPInfo = (PBATT_NP_INFO) IrpNextSp->Parameters.Others.Argument4;

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryCCancelTag. Irp - %08x\n", BattNPInfo->DeviceNum, Irp));

    InterlockedExchange(&BattNPInfo->CheckTag, 1);
    BattCQueueWorker (BattNPInfo, FALSE);

    //
    // The cancel Spinlock must be released after attempting to queue the
    // worker thread so that there is no timeing problems on remove.
    //
    IoReleaseCancelSpinLock(Irp->CancelIrql);
}



VOID
BattCQueueWorker (
    IN PBATT_NP_INFO BattNPInfo,
    IN BOOLEAN       CheckStatus
    )
/*++

Routine Description:

    Get worker thread to check the battery state (IoQueue).   The
    battery IOs are serialized here as only one worker thread is
    used to process the battery IOs.  If the worker thread is already
    running, it is flagged to loop are re-check the state.  If the
    worker thread is not running, one is queued.

    If CheckStatus is set, the worker thread is informed that the
    batteries current status is read and the pending status queue
    is checked.

Arguments:

    BattNPInfo      - Battery to check

    CheckStatus     - Whether or not the status also needs checked

Return Value:

    None.

--*/
{
    PBATT_INFO      BattInfo = BattNPInfo->BattInfo;

    //
    // Add 1 to the WorkerActive value, if this is the first count
    // queue a worker thread
    //

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryCQueueWorker.\n", BattNPInfo->DeviceNum));

    if (CheckStatus) {
        InterlockedExchange(&BattNPInfo->CheckStatus, 1);
        InterlockedExchange (&BattNPInfo->CheckTag, 1);
    }

    //
    // Increment WorkerActive count.  If the worker thread is already running,
    // there is no need to requeue it.
    //
    if (InterlockedIncrement(&BattNPInfo->WorkerActive) == 1) {
        // Removal lock.
        if ((BattNPInfo->WantToRemove == TRUE) && (KeGetCurrentIrql() == PASSIVE_LEVEL)) {
            // Check Irql to make sure this wasn't called by an ISR.  If so,
            // queue the worker rather than complete the requests in this thread.

            //
            // Empty IRP queues.
            //
            BattCCompleteIrpQueue(&(BattInfo->IoQueue), STATUS_DEVICE_REMOVED);
            BattCCompleteIrpQueue(&(BattInfo->TagQueue), STATUS_DEVICE_REMOVED);
            BattCCompleteIrpQueue(&(BattInfo->StatusQueue), STATUS_DEVICE_REMOVED);
            BattCCompleteIrpQueue(&(BattInfo->WmiQueue), STATUS_DEVICE_REMOVED);

            //
            // Remove lock and trigger Remove function if necessary.
            //
            if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
                KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
            }
            BattPrint ((BATT_LOCK), ("BattCQueueWorker: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

        } else {
            ExQueueWorkItem (&BattNPInfo->WorkerThread, DelayedWorkQueue);
        }
    }
}

VOID
BattCWorkerThread (
    IN PVOID Context
    )
/*++

Routine Description:

    Battery IO worker thread entry point.

    N.B. There is only one worker thread handling the battery at any one time

Arguments:

    Context         - BattInfo.  Battery to check

Return Value:

    None.

--*/
{
    PBATT_INFO              BattInfo;
    PBATT_NP_INFO           BattNPInfo;
    PLIST_ENTRY             Entry;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    ULONG                   i;


    PAGED_CODE();

    BattNPInfo = (PBATT_NP_INFO) Context;
    BattInfo = BattNPInfo->BattInfo;

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryCWorkerThread entered.\n", BattNPInfo->DeviceNum));


    //
    // Loop while there is work to check
    //

    for (; ;) {
        // Removal code.  This makes sure that the structures aren't freed in the middle of
        // processing.  All Irp Queues will be emptied by BatteryClassUnload.
        if (BattNPInfo->WantToRemove == TRUE) {
            //
            // Empty IRP queues.
            //
            BattCCompleteIrpQueue(&(BattInfo->IoQueue), STATUS_DEVICE_REMOVED);
            BattCCompleteIrpQueue(&(BattInfo->TagQueue), STATUS_DEVICE_REMOVED);
            BattCCompleteIrpQueue(&(BattInfo->StatusQueue), STATUS_DEVICE_REMOVED);
            BattCCompleteIrpQueue(&(BattInfo->WmiQueue), STATUS_DEVICE_REMOVED);
            //
            // Signal BatteryClassUnload that it is safe to return.
            //
            if (0 == InterlockedDecrement(&BattNPInfo->InUseCount)) {
                KeSetEvent (&BattNPInfo->ReadyToRemove, IO_NO_INCREMENT, FALSE);
            }
            BattPrint ((BATT_LOCK), ("BattCWorkerThread: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

            return;
        }

        //
        // Acquire queue locks
        //

        ExAcquireFastMutex (&BattNPInfo->Mutex);

        //
        // While there are IRPs in the IoQueue handle them
        //

        while (!IsListEmpty(&BattInfo->IoQueue)) {

            //
            // Remove entry from IoQueue and drop device lock
            //

            Entry = RemoveHeadList(&BattInfo->IoQueue);
            ExReleaseFastMutex (&BattNPInfo->Mutex);


            //
            // Handle this entry
            //

            Irp = CONTAINING_RECORD (
                        Entry,
                        IRP,
                        Tail.Overlay.ListEntry
                        );

            BattPrint (BATT_IOCTL, ("BattC (%d): WorkerThread, Got Irp - %x\n", BattNPInfo->DeviceNum, Irp));

            IrpSp = IoGetCurrentIrpStackLocation(Irp);


            if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_BATTERY_QUERY_STATUS  &&
                IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof (BATTERY_WAIT_STATUS) &&
                IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (BATTERY_STATUS)) {

                BattPrint (BATT_IOCTL,
                          ("BattC (%d): Received QueryStatus Irp - %x, timeout - %x\n",
                          BattNPInfo->DeviceNum,
                          Irp,
                          ((PBATTERY_WAIT_STATUS)Irp->AssociatedIrp.SystemBuffer)->Timeout));

                //
                // Valid query status irp, put it on the StatusQueue and handle later
                //

                InterlockedExchange (&BattNPInfo->CheckStatus, 1);
                IrpSp = IoGetNextIrpStackLocation(Irp);
                IrpSp->Parameters.Others.Argument1 = (PVOID) 0;
                IrpSp->Parameters.Others.Argument2 = (PVOID) 0;
                IrpSp->Parameters.Others.Argument3 = NULL;
                IrpSp->Parameters.Others.Argument4 = BattNPInfo;

                //
                // Set IRPs cancel routine
                //

                IoSetCancelRoutine (Irp, BattCCancelStatus);

                //
                // Queue it
                //

                InsertTailList (
                    &BattInfo->StatusQueue,
                    &Irp->Tail.Overlay.ListEntry
                    );

            } else if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_BATTERY_QUERY_TAG &&
                       (IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof (ULONG) ||
                       IrpSp->Parameters.DeviceIoControl.InputBufferLength == 0) &&
                       IrpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (ULONG)) {

                BattPrint (BATT_IOCTL,
                          ("BattC (%d): Received QueryTag with timeout %x\n",
                          BattNPInfo->DeviceNum,
                          *((PULONG) Irp->AssociatedIrp.SystemBuffer))
                          );

                //
                // Valid query tag irp, put it on the TagQueue and handle later
                //

                InterlockedExchange (&BattNPInfo->CheckTag, 1);
                IrpSp = IoGetNextIrpStackLocation(Irp);
                IrpSp->Parameters.Others.Argument1 = (PVOID) 0;
                IrpSp->Parameters.Others.Argument2 = (PVOID) 0;
                IrpSp->Parameters.Others.Argument3 = NULL;
                IrpSp->Parameters.Others.Argument4 = BattNPInfo;


                //
                // Set IRPs cancel routine
                //

                IoSetCancelRoutine (Irp, BattCCancelTag);

                InsertTailList (
                    &BattInfo->TagQueue,
                    &Irp->Tail.Overlay.ListEntry
                    );

            } else {
                //
                // Handle IRP now
                //

                BattPrint (BATT_IOCTL, ("BattC (%d): Calling BattCIoctl with irp %x\n", BattNPInfo->DeviceNum, Irp));
                BattCIoctl (BattInfo, Irp, IrpSp);
            }

            //
            // Acquire IoQueue lock and check for anything else in the IoQueueu
            //

            ExAcquireFastMutex (&BattNPInfo->Mutex);
        }

        //
        // Done with the IoQueue
        //

        ExReleaseFastMutex (&BattNPInfo->Mutex);

        //
        // Check pending status queue
        //

        if (BattNPInfo->CheckStatus) {
            BattCCheckStatusQueue (BattNPInfo, BattInfo);
        }


        //
        // Check pending tag queue
        //

        if (BattNPInfo->CheckTag) {
            BattCCheckTagQueue (BattNPInfo, BattInfo);
        }


        //
        // Acquire queue locks
        //

        ExAcquireFastMutex (&BattNPInfo->Mutex);

        //
        // While there are outstanding WMI requests handle them
        //

        while (!IsListEmpty(&BattInfo->WmiQueue)) {
            PBATT_WMI_REQUEST WmiRequest;

            //
            // Remove entry from WmiQueue and drop device lock
            //

            Entry = RemoveHeadList(&BattInfo->WmiQueue);
            ExReleaseFastMutex (&BattNPInfo->Mutex);


            //
            // Handle this entry
            //

            WmiRequest = CONTAINING_RECORD (
                        Entry,
                        BATT_WMI_REQUEST,
                        ListEntry
                        );

            BattPrint (BATT_WMI, ("BattC (%d): WorkerThread, Got WMI Rewest - %x\n", BattNPInfo->DeviceNum, WmiRequest));

            //
            // Process the request here.
            //

            BattCWmi (BattNPInfo, BattInfo, WmiRequest);

            //
            // Acquire IoQueue lock and check for anything else in the IoQueueu
            //

            ExAcquireFastMutex (&BattNPInfo->Mutex);
        }

        //
        // Done with the IoQueue
        //

        ExReleaseFastMutex (&BattNPInfo->Mutex);

        //
        // See if we need to recheck
        //

        i = InterlockedDecrement(&BattNPInfo->WorkerActive);
        BattPrint (BATT_TRACE, ("BattC (%d): WorkerActive count=%x\n", BattNPInfo->DeviceNum, i));


        if (i == 0) {
            // done
            BattPrint (BATT_TRACE, ("BattC (%d): WorkerActive count is zero!\n", BattNPInfo->DeviceNum));
            break;
        }

        //
        // No need to loop multiple times, if count is not one lower it
        //

        if (i != 1) {
            BattPrint (BATT_TRACE, ("BattC (%d): WorkerActive set to 1\n", BattNPInfo->DeviceNum));
            InterlockedExchange(&BattNPInfo->WorkerActive, 1);
        }
    }

    BattPrint ((BATT_TRACE), ("BattC (%d): BatteryCWorkerThread exiting.\n", BattNPInfo->DeviceNum));

}

VOID
BattCIoctl (
    IN PBATT_INFO           BattInfo,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp
    )
/*++

Routine Description:

    Completes the battery IOCTL request.

    N.B. must be invoked from the non-rentrant worker thread

Arguments:

    BattInfo        - Battery

    Irp             - IOCTL request

    IrpSp           - Current stack location


Return Value:

    IRP has been completed

--*/
{
    ULONG                       InputLen, OutputLen;
    PVOID                       IOBuffer;
    NTSTATUS                    Status;
    PBATTERY_QUERY_INFORMATION  QueryInfo;
    PBATTERY_SET_INFORMATION    SetInformation;
#if DEBUG
    BATTERY_QUERY_INFORMATION_LEVEL inflevel;
#endif

    PAGED_CODE();

    BattPrint ((BATT_TRACE), ("BattC (%d): BattCIoctl called\n", BattInfo->BattNPInfo->DeviceNum));

    IOBuffer    = Irp->AssociatedIrp.SystemBuffer;
    InputLen    = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    OutputLen   = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Dispatch IOCtl request to proper miniport function
    //

    Status = STATUS_INVALID_BUFFER_SIZE;
    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_BATTERY_QUERY_TAG:
        //
        // Query tag only gets here if the input or output buffer lengths are
        // wrong.  Return STATUS_INVALID_BUFFER_SIZE
        //
        break;

    case IOCTL_BATTERY_QUERY_INFORMATION:
        if (InputLen != sizeof (BATTERY_QUERY_INFORMATION)) {
            //
            // Don't check size of the output buffer since it is variable size.
            // This is checked in Mp.QueryInformation
            //
            // Return STATUS_INVALID_BUFFER_SIZE
            //
            break;
        }
        QueryInfo = (PBATTERY_QUERY_INFORMATION) IOBuffer;

#if DEBUG
        inflevel = QueryInfo->InformationLevel;
#endif

        Status = BattInfo->Mp.QueryInformation (
                    BattInfo->Mp.Context,
                    QueryInfo->BatteryTag,
                    QueryInfo->InformationLevel,
                    QueryInfo->AtRate,
                    IOBuffer,
                    OutputLen,
                    &OutputLen
                    );
#if DEBUG
        if (inflevel == BatteryInformation) {
            BattInfo->FullChargedCap = ((PBATTERY_INFORMATION)IOBuffer)->FullChargedCapacity;
        }
#endif
        BattPrint ((BATT_MP_DATA), ("BattC (%d): Mp.QueryInformation status = %08x, Level = %d\n",
                   BattInfo->BattNPInfo->DeviceNum, Status, QueryInfo->InformationLevel));
        break;

    case IOCTL_BATTERY_QUERY_STATUS:

        //
        // Query status only gets here if the input or output buffer lengths are
        // wrong.  Return STATUS_INVALID_BUFFER_SIZE
        //
        break;

    case IOCTL_BATTERY_SET_INFORMATION:
        if ((InputLen < sizeof(BATTERY_SET_INFORMATION)) || (OutputLen != 0)) {
            // Make Sure InputLen is at least the minimum size.  It may be 
            // depending on the InformationLevel.
            //
            // This is checked in Mp.QueryInformation
            break;
        }

        SetInformation = (PBATTERY_SET_INFORMATION) IOBuffer;
        if (BattInfo->Mp.SetInformation != NULL) {
            Status = BattInfo->Mp.SetInformation (
                        BattInfo->Mp.Context,
                        SetInformation->BatteryTag,
                        SetInformation->InformationLevel,
                        SetInformation->Buffer
                        );
            BattPrint ((BATT_MP_DATA), ("BattC (%d): Mp.SetInformation status = %08x, Level = %d\n",
                       BattInfo->BattNPInfo->DeviceNum, Status, SetInformation->InformationLevel));
        } else {
            Status = STATUS_NOT_SUPPORTED;
        }

        break;

    default:
        Status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    BattCMiniportStatus (BattInfo, Status);
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = OutputLen;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
}

VOID
BattCCheckStatusQueue (
    IN PBATT_NP_INFO    BattNPInfo,
    IN PBATT_INFO       BattInfo
    )
/*++

Routine Description:

    Gets the batteries current status, and checks the pending
    status queue for possible IRP completion.  Resets the miniport
    notification settings if needed.

    N.B. Must be invoked from the non-rentrant worker thread.
         BattNPInfo->CheckStatus must be non-zero.

Arguments:

    BattNPInfo      - Battery

    BattInfo        - Battery

Return Value:

    None

--*/
{
    PLIST_ENTRY             Entry;
    PBATTERY_WAIT_STATUS    BatteryWaitStatus;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp, IrpNextSp;
    BATTERY_NOTIFY          Notify;
    LARGE_INTEGER           NextTime;
    LARGE_INTEGER           CurrentTime;
    LARGE_INTEGER           li;
    ULONG                   TimeIncrement;
    BOOLEAN                 ReturnCurrentStatus;
    NTSTATUS                Status;
    BOOLEAN                 StatusNotified = FALSE;

    BattPrint ((BATT_TRACE), ("BattC (%d): BattCCheckStatusQueue called\n", BattInfo->BattNPInfo->DeviceNum));

    PAGED_CODE();
    TimeIncrement = KeQueryTimeIncrement();

    //
    // Loop while status needs checked, check pending status IRPs
    //

    while (InterlockedExchange(&BattNPInfo->CheckStatus, 0)) {

        Notify.PowerState   = BattInfo->Status.PowerState;
        Notify.LowCapacity  = 0;
        Notify.HighCapacity = (ULONG) -1;

        //
        // Set to recheck no later than MIN_STATUS_POLL_RATE (3 min) from now.
        //

        NextTime.QuadPart = MIN_STATUS_POLL_RATE;


        //
        // If the StatusQueue is empty, the status doesn't need to be read
        // at this time.  BattNPInfo->StatusNotified is not modified
        // so the next time an IRP comes through, we'll re-read the status.
        // The local value of StatusNotified needs to be set correctly to
        // disable notifications if necessary.
        //

        if (IsListEmpty (&BattInfo->StatusQueue)) {
            StatusNotified = (BOOLEAN)BattNPInfo->StatusNotified;
            break;
        }

        StatusNotified = FALSE;

        //
        // Pickup status notified flag
        //

        if (BattNPInfo->StatusNotified) {

            InterlockedExchange (&BattNPInfo->StatusNotified, 0);
            StatusNotified = TRUE;

            // Reset the invalid data retry count when we get a notification.
#if DEBUG
            if (BattInfo->InvalidRetryCount != 0) {
                BattPrint (BATT_DEBUG, ("BattC (%d) Reset InvalidRetryCount\n", BattNPInfo->DeviceNum));
            }
#endif
            BattInfo->InvalidRetryCount = 0;
        }

        KeQueryTickCount (&CurrentTime);
        CurrentTime.QuadPart = CurrentTime.QuadPart * TimeIncrement;

        if (StatusNotified ||
            CurrentTime.QuadPart - BattInfo->StatusTime > STATUS_VALID_TIME) {

            //
            // Get the batteries current status
            //

            Status = BattInfo->Mp.QueryStatus (
                            BattInfo->Mp.Context,
                            BattInfo->Tag,
                            &BattInfo->Status
                            );

            if (!NT_SUCCESS(Status)) {
                //
                // Battery status is not valid, complete all pending status irps
                //

                BattPrint ((BATT_MP_ERROR), ("BattC (%d) CheckStatus: Status read err = %x\n", BattNPInfo->DeviceNum, Status));

                BattCCompleteIrpQueue (&(BattInfo->StatusQueue), Status);
                break;
            }

            BattPrint ((BATT_MP_DATA), ("BattC (%d) MP.QueryStatus: st[%08X] Cap[%08X] V[%08x] R[%08x]\n",
                BattNPInfo->DeviceNum,
                BattInfo->Status.PowerState,
                BattInfo->Status.Capacity,
                BattInfo->Status.Voltage,
                BattInfo->Status.Rate
                ));

            Notify.PowerState = BattInfo->Status.PowerState;

            //
            // Get the current time to compute timeouts on status query requests
            //

            KeQueryTickCount (&CurrentTime);
            CurrentTime.QuadPart = CurrentTime.QuadPart * TimeIncrement;
            BattInfo->StatusTime = CurrentTime.QuadPart;
        }

        //
        // Check each pending Status IRP
        //

        BattPrint ((BATT_IOCTL_QUEUE), ("BattC (%d) Processing StatusQueue\n", BattNPInfo->DeviceNum));

        Entry = BattInfo->StatusQueue.Flink;
        while  (Entry != &BattInfo->StatusQueue) {

            //
            // Get IRP to check
            //

            Irp = CONTAINING_RECORD (
                        Entry,
                        IRP,
                        Tail.Overlay.ListEntry
                        );

            IrpSp = IoGetCurrentIrpStackLocation(Irp);
            IrpNextSp = IoGetNextIrpStackLocation(Irp);
            BatteryWaitStatus = (PBATTERY_WAIT_STATUS) Irp->AssociatedIrp.SystemBuffer;

#if DEBUG
    if (BattInfo->FullChargedCap == 0) {
        BattInfo->FullChargedCap = 1000;
    }
#endif
            BattPrint ((BATT_IOCTL_QUEUE), ("BattC (%d) StatusQueue: 0x%08x=%d -- 0x%08x=%d  time=%08x, st=%08x\n",
                       BattNPInfo->DeviceNum,
                       BatteryWaitStatus->HighCapacity, (ULONG) (((LONGLONG) BatteryWaitStatus->HighCapacity * 1000) / BattInfo->FullChargedCap),
                       BatteryWaitStatus->LowCapacity, (ULONG) (((LONGLONG) BatteryWaitStatus->LowCapacity * 1000) / BattInfo->FullChargedCap),
                       BatteryWaitStatus->Timeout,
                       BatteryWaitStatus->PowerState));

            //
            // Get next request
            //

            Entry = Entry->Flink;

            //
            // If status is in error, or tag no longer matches abort the
            // request accordingly
            //

            if (BattInfo->Tag != BatteryWaitStatus->BatteryTag) {
                Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
            }

            //
            // If IRP is flagged as cancelled, complete it
            //

            if (Irp->Cancel) {
                Irp->IoStatus.Status = STATUS_CANCELLED;
            }

            //
            // If request is still pending, check it
            //

            if (Irp->IoStatus.Status == STATUS_PENDING) {

                ReturnCurrentStatus = FALSE;

                if (BattInfo->Status.PowerState != BatteryWaitStatus->PowerState ||
                    BattInfo->Status.Capacity   <  BatteryWaitStatus->LowCapacity  ||
                    BattInfo->Status.Capacity   >  BatteryWaitStatus->HighCapacity) {

                    BattPrint((BATT_IOCTL_DATA), ("BattC (%d) CheckStatusQueue, Returning Current Status, Asked For:\n"
                                          "----------- Irp.PowerState      = %x\n"
                                          "----------- Irp.LowCapacity     = %x\n"
                                          "----------- Irp.HighCapacity    = %x\n"
                                          "----------- BattInfo.PowerState = %x\n"
                                          "----------- BattInfo.Capacity   = %x\n",
                                          BattNPInfo->DeviceNum,
                                          BatteryWaitStatus->PowerState,
                                          BatteryWaitStatus->LowCapacity,
                                          BatteryWaitStatus->HighCapacity,
                                          BattInfo->Status.PowerState,
                                          BattInfo->Status.Capacity)
                                          );

                    //
                    // Complete this IRP with the current status
                    //

                    ReturnCurrentStatus = TRUE;

                } else {

                    //
                    // Compute time when the request expires
                    //

                    BattPrint ((BATT_IOCTL_DATA), ("BattC (%d) CheckStatusQueue: Status Request %x Waiting For:\n"
                                            "----------- Timeout          = %x\n"
                                            "----------- Irp.PowerState   = %x\n"
                                            "----------- Irp.LowCapacity  = %x\n"
                                            "----------- Irp.HighCapacity = %x\n",
                                            BattNPInfo->DeviceNum,
                                            Irp,
                                            BatteryWaitStatus->Timeout,
                                            BatteryWaitStatus->PowerState,
                                            BatteryWaitStatus->LowCapacity,
                                            BatteryWaitStatus->HighCapacity)
                                            );

                    if (BatteryWaitStatus->Timeout &&
                        IrpNextSp->Parameters.Others.Argument1 == NULL &&
                        IrpNextSp->Parameters.Others.Argument2 == NULL) {

                        // initialize it
                        li.QuadPart = CurrentTime.QuadPart +
                            ((ULONGLONG) BatteryWaitStatus->Timeout * NTMS);

                        IrpNextSp->Parameters.Others.Argument1 = (PVOID)((ULONG_PTR)li.LowPart);
                        IrpNextSp->Parameters.Others.Argument2 = (PVOID)((ULONG_PTR)li.HighPart);
                    }

                    li.LowPart   = (ULONG)((ULONG_PTR)IrpNextSp->Parameters.Others.Argument1);
                    li.HighPart  = (ULONG)((ULONG_PTR)IrpNextSp->Parameters.Others.Argument2);
                    li.QuadPart -= CurrentTime.QuadPart;

                    if (li.QuadPart <= 0) {

                        //
                        // Time's up, complete it
                        //

                        ReturnCurrentStatus = TRUE;

                    } else {

                        //
                        // If waiting forever, no need to set a timer
                        //
                        if (BatteryWaitStatus->Timeout != 0xFFFFFFFF) {

                            //
                            // Check if this will be the next timeout time -- we will use
                            // the minimum timeout of the pending requests.
                            //

                            if (li.QuadPart < NextTime.QuadPart) {
                                NextTime.QuadPart = li.QuadPart;
                            }
                        }
                    }
                }

                if (!ReturnCurrentStatus) {

                    //
                    // IRP is still pending, calculate LCD of all waiting IRPs
                    //

                    if (BatteryWaitStatus->LowCapacity > Notify.LowCapacity) {
                        Notify.LowCapacity = BatteryWaitStatus->LowCapacity;
                    }

                    if (BatteryWaitStatus->HighCapacity < Notify.HighCapacity) {
                        Notify.HighCapacity = BatteryWaitStatus->HighCapacity;
                    }

                } else {

                    //
                    // Return current battery status
                    //

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = sizeof(BattInfo->Status);
                    RtlCopyMemory (
                        Irp->AssociatedIrp.SystemBuffer,
                        &BattInfo->Status,
                        sizeof(BattInfo->Status)
                        );
                }
            }

            //
            // If this request is no longer pending, complete it
            //

            if (Irp->IoStatus.Status != STATUS_PENDING) {
                BattPrint (BATT_IOCTL,
                          ("BattC (%d): completing QueryStatus irp - %x, status - %x\n",
                          BattNPInfo->DeviceNum,
                          Irp,
                          Irp->IoStatus.Status));

                RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
                IoSetCancelRoutine (Irp, NULL);
                IoCompleteRequest (Irp, IO_NO_INCREMENT);
            }
        }
    }

    //
    // Status check complete
    //

    if (IsListEmpty (&BattInfo->StatusQueue)) {

        //
        // Nothing pending, if being notified disable the notifications
        //

        if (StatusNotified) {
            BattInfo->Mp.DisableStatusNotify (BattInfo->Mp.Context);
            BattInfo->StatusTime = 0;
            BattPrint ((BATT_MP_DATA), ("BattC (%d) CheckStatus: called Mp.DisableStatusNotify\n", BattNPInfo->DeviceNum));
        }

    } else {

        //
        // Set notification setting
        //

        Status = BattInfo->Mp.SetStatusNotify (
                        BattInfo->Mp.Context,
                        BattInfo->Tag,
                        &Notify
                        );

        if (NT_SUCCESS(Status)) {

            //
            // New notification set, remember it
            //

            BattPrint (BATT_MP_DATA, ("BattC (%d) Mp.SetStatusNotify: Notify set for: State=%x, Low=%x, High=%x\n",
                BattNPInfo->DeviceNum,
                Notify.PowerState,
                Notify.LowCapacity,
                Notify.HighCapacity
                ));

        } else {

            //
            // Could not set notification, handle error
            //

            BattPrint (BATT_MP_ERROR, ("BattC (%d) Mp.SetStatusNotify: failed (%x), will poll\n", BattNPInfo->DeviceNum, Status));
            BattCMiniportStatus (BattInfo, Status);

            //
            // Compute poll time
            //

            li.QuadPart = MIN_STATUS_POLL_RATE;
            if (BattInfo->Status.Capacity == BATTERY_UNKNOWN_CAPACITY) {
                // Retry 10 times at a polling rate of 1 second.
                // Then revert to the slow polling rate.
                if (BattInfo->InvalidRetryCount < INVALID_DATA_MAX_RETRY) {
                    BattInfo->InvalidRetryCount++;
                    li.QuadPart = INVALID_DATA_POLL_RATE;
                    BattPrint (BATT_DEBUG, ("BattC (%d) InvalidRetryCount = %d\n",
                            BattNPInfo->DeviceNum, BattInfo->InvalidRetryCount));
                } else {
                    BattPrint (BATT_DEBUG, ("BattC (%d) InvalidRetryCount = %d.  Using slow polling rate.\n",
                            BattNPInfo->DeviceNum, BattInfo->InvalidRetryCount));
                    li.QuadPart = MIN_STATUS_POLL_RATE;
                }
            } else if ((BattInfo->Status.Rate != 0) && (BattInfo->Status.Rate != BATTERY_UNKNOWN_RATE)) {

                if (BattInfo->Status.Rate > 0) {

                    li.QuadPart = Notify.HighCapacity - BattInfo->Status.Capacity;

                } else if (BattInfo->Status.Rate < 0) {

                    li.QuadPart = Notify.LowCapacity - BattInfo->Status.Capacity;
                }

                // convert to 3/4 its target time

                li.QuadPart = li.QuadPart * ((ULONGLONG) NTMIN * 45);
                li.QuadPart = li.QuadPart / (LONGLONG)(BattInfo->Status.Rate);

                //
                // Bound it
                //

                if (li.QuadPart > MIN_STATUS_POLL_RATE) {
                    // poll at least this fast
                    li.QuadPart = MIN_STATUS_POLL_RATE;
                } else if (li.QuadPart < MAX_STATUS_POLL_RATE) {
                    // but not faster then this
                    li.QuadPart = MAX_STATUS_POLL_RATE;
                }
            }

            //
            // If sooner then NextTime, adjust NextTime
            //

            if (li.QuadPart < NextTime.QuadPart) {
                NextTime.QuadPart = li.QuadPart;
            }
        }

        //
        // If there's a NextTime, queue the timer to recheck
        //

        if (NextTime.QuadPart) {
            NextTime.QuadPart = -NextTime.QuadPart;

            //
            // Acquire a remove lock.
            //

            InterlockedIncrement (&BattNPInfo->InUseCount);
            BattPrint ((BATT_LOCK), ("BattCCheckStatusQueue: Aqcuired remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

            if (BattNPInfo->WantToRemove == TRUE) {
                //
                // If BatteryClassUnload is waiting to remove the device:
                //   Don't set the timer.
                //   Release the remove lock just acquired.
                //   No need to notify BatteryclassUnload because
                //    at this point there is at least one other lock held.
                //

                InterlockedDecrement(&BattNPInfo->InUseCount);
                BattPrint (BATT_NOTE,
                        ("BattC (%d) CheckStatus: Poll cancel because of device removal.\n",
                        BattNPInfo->DeviceNum));
                BattPrint ((BATT_LOCK), ("BattCCheckStatusQueue: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

            } else {
                if (KeSetTimer (&BattNPInfo->WorkerTimer, NextTime, &BattNPInfo->WorkerDpc)) {
                    //
                    // If the timer was already set, we need to release a remove lock since
                    // there was already one aquired the last time this timer was set.
                    //

                    InterlockedDecrement(&BattNPInfo->InUseCount);
                    BattPrint ((BATT_LOCK), ("BattCCheckStatusQueue: Released extra remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));
                }
#if DEBUG
                NextTime.QuadPart = (-NextTime.QuadPart) / (ULONGLONG) NTSEC;
                BattPrint (BATT_NOTE, ("BattC (%d) CheckStatus: Poll in %d seconds (%d minutes)\n",
                                        BattNPInfo->DeviceNum, NextTime.LowPart, NextTime.LowPart/60));
#endif
            }

        } else {
            //
            // There should always be a NextTime.
            //
            ASSERT(FALSE);
        }
    } // if (IsListEmpty (&BattInfo->StatusQueue)) {...} else
}





VOID
BattCCheckTagQueue (
    IN PBATT_NP_INFO    BattNPInfo,
    IN PBATT_INFO       BattInfo
    )
/*++

Routine Description:

    Gets the batteries current tag, and checks the pending
    tag queue for possible IRP completion.  Resets the miniport
    notification settings if needed.

    N.B. must be invoked from the non-reentrant worker thread

Arguments:

    BattNPInfo      - Battery

    BattInfo        - Battery

Return Value:

    None

--*/
{
    PLIST_ENTRY             Entry;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp, IrpNextSp;
    LARGE_INTEGER           NextTime;
    LARGE_INTEGER           CurrentTime;
    LARGE_INTEGER           li;
    ULONG                   TimeIncrement;
    BOOLEAN                 ReturnCurrentStatus;
    NTSTATUS                Status;
    ULONG                   batteryTimeout;
    BOOLEAN                 TagNotified;

    ULONG                   tmpTag      = BATTERY_TAG_INVALID;

    BattPrint ((BATT_TRACE), ("BattC (%d): BattCCheckTagQueue called\n", BattInfo->BattNPInfo->DeviceNum));

    PAGED_CODE();
    TimeIncrement = KeQueryTimeIncrement();

    //
    // Loop while tag needs checked, check pending tag IRPs
    //

    while (InterlockedExchange(&BattNPInfo->CheckTag, 0)) {
        NextTime.QuadPart = 0;

        //
        // If the Tag Queue is empty, done
        // but we need to make sure that we leave TagNotified set to TRUE
        // so the next time an IRP comes through,we'll re-read the tag.
        //

        if (IsListEmpty (&BattInfo->TagQueue)) {
            break;
        }

        TagNotified = FALSE;

        //
        // Pickup tag notified flag
        //

        if (BattNPInfo->TagNotified) {
            InterlockedExchange (&BattNPInfo->TagNotified, 0);
            TagNotified = TRUE;
        }

        KeQueryTickCount (&CurrentTime);
        CurrentTime.QuadPart = CurrentTime.QuadPart * TimeIncrement;

        if (TagNotified ||
            CurrentTime.QuadPart - BattInfo->TagTime > STATUS_VALID_TIME) {

            //
            // Get the battery's current tag
            //

            tmpTag = 0;
            Status = BattInfo->Mp.QueryTag (
                        BattInfo->Mp.Context,
                        &tmpTag
                        );


            if (!NT_SUCCESS(Status) && (Status != STATUS_NO_SUCH_DEVICE)) {
                //
                // Something went wrong, complete all pending tag irps
                //

                BattPrint (BATT_MP_ERROR, ("BattC (%d) CheckTag: Tag read err = %x\n", BattNPInfo->DeviceNum, Status));
                BattCMiniportStatus (BattInfo, Status);
                break;
            }
            BattPrint (BATT_MP_DATA, ("BattC (%d) MP.QueryTag: Status = %08x, Tag = %08x\n",
                    BattNPInfo->DeviceNum, Status, tmpTag));


            if (Status == STATUS_NO_SUCH_DEVICE) {
                //
                // Get the current time to compute timeouts on tag query requests
                //

                KeQueryTickCount (&CurrentTime);
                CurrentTime.QuadPart    = CurrentTime.QuadPart * TimeIncrement;
                BattInfo->TagTime       = CurrentTime.QuadPart;

            }
        }

        //
        // Check each pending Tag IRP
        //

        Entry = BattInfo->TagQueue.Flink;
        while  (Entry != &BattInfo->TagQueue) {

            //
            // Get IRP to check
            //

            Irp = CONTAINING_RECORD (
                        Entry,
                        IRP,
                        Tail.Overlay.ListEntry
                        );

            IrpSp           = IoGetCurrentIrpStackLocation(Irp);
            IrpNextSp       = IoGetNextIrpStackLocation(Irp);
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength == 0) {
                //
                // If no input was given, then use timeout of 0.
                //
                batteryTimeout  = 0;
            } else {
                batteryTimeout  = *((PULONG) Irp->AssociatedIrp.SystemBuffer);
            }

            //
            // Get next request
            //

            Entry = Entry->Flink;


            //
            // If IRP is flagged as cancelled, complete it
            //

            if (Irp->Cancel) {
                BattPrint (BATT_IOCTL, ("BattC (%d): QueryTag irp cancelled - %x\n", BattNPInfo->DeviceNum, Irp));
                Irp->IoStatus.Status = STATUS_CANCELLED;
            }


            //
            // If request is still pending, check it
            //

            if (Irp->IoStatus.Status == STATUS_PENDING) {

                ReturnCurrentStatus = FALSE;
                if (tmpTag != BATTERY_TAG_INVALID) {

                    //
                    // Complete this IRP with the current tag
                    //

                    ReturnCurrentStatus = TRUE;
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                } else {

                    //
                    // Compute time when the request expires, the battery tag
                    // is an input parameter that holds the timeout.
                    //

                    if (batteryTimeout &&
                        IrpNextSp->Parameters.Others.Argument1 == NULL &&
                        IrpNextSp->Parameters.Others.Argument2 == NULL) {

                        // initialize it
                        li.QuadPart = CurrentTime.QuadPart + ((ULONGLONG) batteryTimeout * NTMS);

                        IrpNextSp->Parameters.Others.Argument1 = (PVOID)((ULONG_PTR)li.LowPart);
                        IrpNextSp->Parameters.Others.Argument2 = (PVOID)((ULONG_PTR)li.HighPart);

                    }

                    li.LowPart   = (ULONG)((ULONG_PTR)IrpNextSp->Parameters.Others.Argument1);
                    li.HighPart  = (ULONG)((ULONG_PTR)IrpNextSp->Parameters.Others.Argument2);
                    li.QuadPart -= CurrentTime.QuadPart;

                    if (li.QuadPart <= 0) {

                        //
                        // Time's up, complete it
                        //

                        BattPrint ((BATT_NOTE | BATT_IOCTL), ("BattC (%d): QueryTag irp timeout - %x\n", BattNPInfo->DeviceNum, Irp));
                        ReturnCurrentStatus = TRUE;
                        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

                    } else {

                        //
                        // If waiting forever, no need to set a timer
                        //
                        if (batteryTimeout != 0xFFFFFFFF) {

                            //
                            // Check if this is the next timeout time
                            //

                            if (NextTime.QuadPart == 0  ||  li.QuadPart < NextTime.QuadPart) {
                                NextTime.QuadPart = li.QuadPart;
                            }
                        }
                    }
                }

                if (ReturnCurrentStatus) {

                    //
                    // Return current battery status
                    //

                    *((PULONG) Irp->AssociatedIrp.SystemBuffer)     = tmpTag;
                    Irp->IoStatus.Information                       = sizeof(ULONG);
                    if (BattInfo->Tag != tmpTag) {

                        //
                        // This is a new battery tag, capture tag
                        //

                        BattInfo->Tag = tmpTag;
                    }
                }
            }

            //
            // If this request is no longer pending, complete it
            //

            if (Irp->IoStatus.Status != STATUS_PENDING) {
                RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
                IoSetCancelRoutine (Irp, NULL);

                BattPrint (
                    (BATT_IOCTL),
                    ("BattC (%d): CheckTag completing request, IRP = %x, status = %x\n",
                    BattNPInfo->DeviceNum,
                    Irp,
                    Irp->IoStatus.Status)
                    );

                IoCompleteRequest (Irp, IO_NO_INCREMENT);
            }
        }
    }

    //
    // If there's a NextTime, queue the timer to recheck.
    // This means there is a tag request with a timout other than 0 or -1.
    //

    if (NextTime.QuadPart) {
        NextTime.QuadPart = -NextTime.QuadPart;

        //
        // Acquire a remove lock.
        //

        InterlockedIncrement (&BattNPInfo->InUseCount);
        BattPrint ((BATT_LOCK), ("BattCCheckTagQueue: Aqcuired remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));

        if (BattNPInfo->WantToRemove == TRUE) {
            //
            // If BatteryClassUnload is waiting to remove the device:
            //   Don't set the timer.
            //   Release the remove lock just acquired.
            //   No need to notify BatteryclassUnload because
            //    at this point there is at least one other lock held.
            //

            InterlockedDecrement(&BattNPInfo->InUseCount);
            BattPrint (BATT_NOTE,
                    ("BattC (%d) CheckTag: Poll cancel because of device removal.\n",
                    BattNPInfo->DeviceNum));
            BattPrint ((BATT_LOCK), ("BattCCheckTagQueue: Released remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));
        } else {
            if (KeSetTimer (&BattNPInfo->TagTimer, NextTime, &BattNPInfo->TagDpc)){
                //
                // If the timer was already set, we need to release a remove lock since
                // there was already one aquired the last time this timer was set.
                //

                InterlockedDecrement(&BattNPInfo->InUseCount);
                BattPrint ((BATT_LOCK), ("BattCCheckTagQueue: Released extra remove lock %d (count = %d)\n", BattNPInfo->DeviceNum, BattNPInfo->InUseCount));
            }
#if DEBUG
            NextTime.QuadPart = NextTime.QuadPart / -NTSEC;
            BattPrint (BATT_NOTE, ("BattC (%d) CheckTag: Poll in %x seconds\n", BattNPInfo->DeviceNum, NextTime.LowPart));
#endif
        }
    }

}



VOID
BattCWmi (
    IN PBATT_NP_INFO    BattNPInfo,
    IN PBATT_INFO       BattInfo,
    IN PBATT_WMI_REQUEST WmiRequest
    )
/*++

Routine Description:

    Processes a single WMI request.

    N.B. must be invoked from the non-reentrant worker thread

Arguments:

    BattNPInfo      - Battery

    BattInfo        - Battery

    WmiRequest      - Wmi Request to process

Return Value:

    None

--*/
{

    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       size = 0;
    ULONG       OutputLen;
    BATTERY_INFORMATION batteryInformation;
    PWCHAR      tempString;

    BattPrint((BATT_WMI), ("BattCWmi (%d): GuidIndex = 0x%x\n",
               BattNPInfo->DeviceNum, WmiRequest->GuidIndex));

    switch (WmiRequest->GuidIndex) {
    case BattWmiStatusId:
        size = sizeof (BATTERY_WMI_STATUS);
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->Tag = BattInfo->Tag;
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->RemainingCapacity = BattInfo->Status.Capacity;
        if (BattInfo->Status.Rate < 0) {
            ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->ChargeRate = 0;
            ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->DischargeRate = -BattInfo->Status.Rate;
        } else {
            ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->ChargeRate = BattInfo->Status.Rate;
            ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->DischargeRate = 0;
        }
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->Voltage = BattInfo->Status.Voltage;
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->PowerOnline =
            (BattInfo->Status.PowerState & BATTERY_POWER_ON_LINE) ? TRUE : FALSE;
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->Charging =
            (BattInfo->Status.PowerState & BATTERY_CHARGING) ? TRUE : FALSE;
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->Discharging =
            (BattInfo->Status.PowerState & BATTERY_DISCHARGING) ? TRUE : FALSE;
        ((PBATTERY_WMI_STATUS) WmiRequest->Buffer)->Critical =
            (BattInfo->Status.PowerState & BATTERY_CRITICAL) ? TRUE : FALSE;
        BattPrint((BATT_WMI), ("BattCWmi (%d): BatteryStatus\n",
                   BattNPInfo->DeviceNum));
        break;
    case BattWmiRuntimeId:
        size = sizeof (BATTERY_WMI_RUNTIME);
        ((PBATTERY_WMI_RUNTIME) WmiRequest->Buffer)->Tag = BattInfo->Tag;
        status = BattInfo->Mp.QueryInformation (
            BattInfo->Mp.Context,
            BattInfo->Tag,
            BatteryEstimatedTime,
            0,
            &((PBATTERY_WMI_RUNTIME) WmiRequest->Buffer)->EstimatedRuntime,
            sizeof(ULONG),
            &OutputLen
            );

        BattPrint((BATT_WMI), ("BattCWmi (%d): EstimateRuntime = %08x, Status = 0x%08x\n",
                   BattNPInfo->DeviceNum, &((PBATTERY_WMI_RUNTIME) WmiRequest->Buffer)->EstimatedRuntime, status));
        break;
    case BattWmiTemperatureId:
        size = sizeof (BATTERY_WMI_TEMPERATURE);
        ((PBATTERY_WMI_TEMPERATURE) WmiRequest->Buffer)->Tag = BattInfo->Tag;
        status = BattInfo->Mp.QueryInformation (
            BattInfo->Mp.Context,
            BattInfo->Tag,
            BatteryTemperature,
            0,
            &((PBATTERY_WMI_TEMPERATURE) WmiRequest->Buffer)->Temperature,
            sizeof(ULONG),
            &OutputLen
            );

        BattPrint((BATT_WMI), ("BattCWmi (%d): Temperature = %08x, Status = 0x%08x\n",
                   BattNPInfo->DeviceNum, &((PBATTERY_WMI_TEMPERATURE) WmiRequest->Buffer)->Temperature, status));
        break;
    case BattWmiFullChargedCapacityId:
        size = sizeof (BATTERY_WMI_FULL_CHARGED_CAPACITY);
        ((PBATTERY_WMI_FULL_CHARGED_CAPACITY) WmiRequest->Buffer)->Tag = BattInfo->Tag;
        status = BattInfo->Mp.QueryInformation (
            BattInfo->Mp.Context,
            BattInfo->Tag,
            BatteryInformation,
            0,
            &batteryInformation,
            sizeof(BATTERY_INFORMATION),
            &OutputLen
            );
        ((PBATTERY_WMI_FULL_CHARGED_CAPACITY) WmiRequest->Buffer)->FullChargedCapacity =
            batteryInformation.FullChargedCapacity;

        BattPrint((BATT_WMI), ("BattCWmi (%d): FullChargedCapacity = %08x, Status = 0x%08x\n",
                   BattNPInfo->DeviceNum, ((PBATTERY_WMI_FULL_CHARGED_CAPACITY) WmiRequest->Buffer)->FullChargedCapacity, status));
        break;
    case BattWmiCycleCountId:
        size = sizeof (BATTERY_WMI_CYCLE_COUNT);
        ((PBATTERY_WMI_CYCLE_COUNT) WmiRequest->Buffer)->Tag = BattInfo->Tag;
        status = BattInfo->Mp.QueryInformation (
            BattInfo->Mp.Context,
            BattInfo->Tag,
            BatteryInformation,
            0,
            &batteryInformation,
            sizeof(BATTERY_INFORMATION),
            &OutputLen
            );
        ((PBATTERY_WMI_CYCLE_COUNT) WmiRequest->Buffer)->CycleCount =
            batteryInformation.CycleCount;

        BattPrint((BATT_WMI), ("BattCWmi (%d): CycleCount = %08x, Status = 0x%08x\n",
                   BattNPInfo->DeviceNum, ((PBATTERY_WMI_CYCLE_COUNT) WmiRequest->Buffer)->CycleCount, status));
        break;
    case BattWmiStaticDataId:
        size = sizeof(BATTERY_WMI_STATIC_DATA)+4*MAX_BATTERY_STRING_SIZE*sizeof(WCHAR);
        ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Tag = BattInfo->Tag;
//        ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->ManufacturerDate[0] =
//        ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Granularity =

        status = BattInfo->Mp.QueryInformation (
            BattInfo->Mp.Context,
            BattInfo->Tag,
            BatteryInformation,
            0,
            &batteryInformation,
            sizeof(BATTERY_INFORMATION),
            &OutputLen
            );

        if (NT_SUCCESS(status)) {

            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Capabilities =
                batteryInformation.Capabilities;
            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Technology =
                batteryInformation.Technology;
            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Chemistry =
                *(PULONG)batteryInformation.Chemistry;
            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->DesignedCapacity =
                batteryInformation.DesignedCapacity;
            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->DefaultAlert1 =
                batteryInformation.DefaultAlert1;
            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->DefaultAlert2 =
                batteryInformation.DefaultAlert2;
            ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->CriticalBias =
                batteryInformation.CriticalBias;

            tempString = ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Strings;
            status = BattInfo->Mp.QueryInformation (
                BattInfo->Mp.Context,
                BattInfo->Tag,
                BatteryDeviceName,
                0,
                &tempString[1],
                MAX_BATTERY_STRING_SIZE,
                &OutputLen
                );
            if (!NT_SUCCESS(status)) {
                // Some batteries may not support some types of Information Queries
                // Don't fail request, simply leave this one blank.
                OutputLen = 0;
            }

            tempString[0] = (USHORT) OutputLen;

            tempString = (PWCHAR) ((PCHAR) &tempString[1] + tempString[0]);
            status = BattInfo->Mp.QueryInformation (
                BattInfo->Mp.Context,
                BattInfo->Tag,
                BatteryManufactureName,
                0,
                &tempString[1],
                MAX_BATTERY_STRING_SIZE,
                &OutputLen
                );
            if (!NT_SUCCESS(status)) {
                // Some batteries may not support some types of Information Queries
                // Don't fail request, simply leave this one blank.
                OutputLen = 0;
            }

            tempString[0] = (USHORT) OutputLen;

            tempString = (PWCHAR) ((PCHAR) &tempString[1] + tempString[0]);
            status = BattInfo->Mp.QueryInformation (
                BattInfo->Mp.Context,
                BattInfo->Tag,
                BatterySerialNumber,
                0,
                &tempString[1],
                MAX_BATTERY_STRING_SIZE,
                &OutputLen
                );
            if (!NT_SUCCESS(status)) {
                // Some batteries may not support some types of Information Queries
                // Don't fail request, simply leave this one blank.
                OutputLen = 0;
            }

            tempString[0] = (USHORT) OutputLen;

            tempString = (PWCHAR) ((PCHAR) &tempString[1] + tempString[0]);
            status = BattInfo->Mp.QueryInformation (
                BattInfo->Mp.Context,
                BattInfo->Tag,
                BatteryUniqueID,
                0,
                &tempString[1],
                MAX_BATTERY_STRING_SIZE,
                &OutputLen
                );
            if (!NT_SUCCESS(status)) {
                // Some batteries may not support some types of Information Queries
                // Don't fail request, simply leave this one blank.
                OutputLen = 0;
                status = STATUS_SUCCESS;
            }

            tempString[0] = (USHORT) OutputLen;

            tempString = (PWCHAR) ((PCHAR) &tempString[1] + tempString[0]);
            size = (ULONG)(sizeof(BATTERY_WMI_STATIC_DATA)+(tempString - ((PBATTERY_WMI_STATIC_DATA) WmiRequest->Buffer)->Strings));
        }

        break;
    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    *WmiRequest->InstanceLengthArray = size;
    status = WmiCompleteRequest(WmiRequest->DeviceObject,
                          WmiRequest->Irp,
                          status,
                          size,
                          IO_NO_INCREMENT);


}




VOID
BattCMiniportStatus (
    IN PBATT_INFO   BattInfo,
    IN NTSTATUS     Status
    )
/*++

Routine Description:

    Function to return status from miniport.  If the battery tag has gone
    invalid the pending statuses are aborted.

    N.B. must be invoked from the non-rentrant worker thread

Arguments:

    BattInfo    - Battery

    Status      - Status from miniport.

Return Value:

    None

--*/
{
    if (NT_SUCCESS(Status)) {
        return ;
    }

    switch (Status) {
#if DEBUG
        case STATUS_SUCCESS:
        case STATUS_NOT_IMPLEMENTED:
        case STATUS_BUFFER_TOO_SMALL:
        case STATUS_INVALID_BUFFER_SIZE:
        case STATUS_NOT_SUPPORTED:
        case STATUS_INVALID_PARAMETER:
        case STATUS_OBJECT_NAME_NOT_FOUND:
        case STATUS_INVALID_DEVICE_REQUEST:
            // no action
            break;

        default:
            BattPrint (BATT_ERROR, ("BattCMiniportStatus: unknown status from miniport: %x BattInfo %x\n",
                        Status, BattInfo));
            break;

#endif
        case STATUS_NO_SUCH_DEVICE:

            //
            // Our battery tag is wrong.  Cancel any queued status irps
            //

            BattCCompleteIrpQueue (&(BattInfo->StatusQueue), Status);
            break;
    }
}


VOID
BattCCompleteIrpQueue (
    IN PLIST_ENTRY  Queue,
    IN NTSTATUS     Status
    )
/*++

Routine Description:

    Complete all pending Irps in the IoQueue, TagQueue, or StatusQueue.

    N.B. must be invoked from the non-rentrant worker thread

Arguments:

    BattInfo    - Battery

    Status      - Error status to complete pending status request with

Return Value:

    None

--*/
{
    PLIST_ENTRY     Entry;
    PIRP            Irp;

    ASSERT (!NT_SUCCESS(Status));

    BattPrint (BATT_TRACE, ("BattC: ENTERING BattCCompleteIrpQueue\n"));

    while  (!IsListEmpty(Queue)) {
        Entry = RemoveHeadList (Queue);

        Irp = CONTAINING_RECORD (
                    Entry,
                    IRP,
                    Tail.Overlay.ListEntry
                    );

        //
        // Use Cancel Spinlock to make sure that Completion routine isn't being called
        //

        IoAcquireCancelSpinLock (&Irp->CancelIrql);
        IoSetCancelRoutine (Irp, NULL);
        IoReleaseCancelSpinLock(Irp->CancelIrql);

        BattPrint (BATT_NOTE, ("BattC: Completing IRP 0x%0lx at IRQL %d.\n", Irp, KeGetCurrentIrql()));
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    BattPrint (BATT_TRACE, ("BattC: EXITING BattCCompleteIrpQueue\n"));
}


VOID
BattCCompleteWmiQueue (
    IN PLIST_ENTRY  Queue,
    IN NTSTATUS     Status
    )
/*++

Routine Description:

    Complete all pending Irps in the IoQueue, TagQueue, or StatusQueue.

    N.B. must be invoked from the non-rentrant worker thread

Arguments:

    BattInfo    - Battery

    Status      - Error status to complete pending status request with

Return Value:

    None

--*/
{
    PLIST_ENTRY         Entry;
    PBATT_WMI_REQUEST   WmiRequest;

    ASSERT (!NT_SUCCESS(Status));

    BattPrint (BATT_TRACE, ("BattC: ENTERING BattCCompleteWmiQueue\n"));

    while  (!IsListEmpty(Queue)) {
        Entry = RemoveHeadList (Queue);

        WmiRequest = CONTAINING_RECORD (
                    Entry,
                    BATT_WMI_REQUEST,
                    ListEntry
                    );

        BattPrint (BATT_NOTE, ("BattC: Completing Wmi Request 0x%0lx at IRQL %d.\n", WmiRequest, KeGetCurrentIrql()));

        *WmiRequest->InstanceLengthArray = 0;
        WmiCompleteRequest(WmiRequest->DeviceObject,
                      WmiRequest->Irp,
                      Status,
                      0,
                      IO_NO_INCREMENT);


    }

    BattPrint (BATT_TRACE, ("BattC: EXITING BattCCompleteWmiQueue\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\cmbatt\vxd.c ===
#include "cmbattp.h"
#include <basedef.h>
#include <vmm.h>
#include "vpowerd.h"

VOID CmBattNotifyVPOWERDOfPowerChange (ULONG PowerSourceChange)
{

	POWER_STATUS	powerstatus;
        ULONG		Device;
        
        Device = PowerSourceChange ? 38 : PDI_MANAGED_BY_APM_BIOS;
        
        _asm	{
        
        
        	lea	eax, powerstatus
                push	eax
                mov	eax, Device
                push	eax
                
                VMMCall (_VPOWERD_Get_Power_Status)
                add	esp, 4*2        
        }			
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\cmbatt\cmexe.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CmBatt.c

Abstract:

    Control Method Battery Miniport Driver

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode

Revision History:

--*/

#include "CmBattp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CmBattSendDownStreamIrp)
#pragma alloc_text(PAGE, CmBattGetUniqueId)
#pragma alloc_text(PAGE, CmBattGetStaData)
#pragma alloc_text(PAGE, CmBattSetTripPpoint)
#endif

#define EXPECTED_DATA_SIZE 512

NTSTATUS
CmBattSendDownStreamIrp(
    IN  PDEVICE_OBJECT   Pdo,
    IN  ULONG            Ioctl,
    IN  PVOID            InputBuffer,
    IN  ULONG            InputSize,
    IN  PVOID            OutputBuffer,
    IN  ULONG            OutputSize
)
/*++

Routine Description:

    Called to send a request to the Pdo

Arguments:

    Pdo             - The request is sent to this device object
    Ioctl           - the request
    InputBuffer     - The incoming request
    InputSize       - The size of the incoming request
    OutputBuffer    - The answer
    OutputSize      - The size of the answer buffer

Return Value:

    NT Status of the operation

--*/
{
    IO_STATUS_BLOCK     ioBlock;
    KEVENT              event;
    NTSTATUS            status;
    PIRP                irp;

    PAGED_CODE();

    //
    // Initialize an event to wait on
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Build the request
    //
    irp = IoBuildDeviceIoControlRequest(
        Ioctl,
        Pdo,
        InputBuffer,
        InputSize,
        OutputBuffer,
        OutputSize,
        FALSE,
        &event,
        &ioBlock
        );
    if (!irp) {

        CmBattPrint((CMBATT_ERROR | CMBATT_CM_EXE),
            ("CmBattSendDownStreamIrp: Failed to allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    CmBattPrint(
        CMBATT_CM_EXE,
        ("CmBattSendDownStreamIrp: Irp %x [Tid] %x\n", irp, GetTid() )
        );

    //
    // Pass request to Pdo, always wait for completion routine
    //
    status = IoCallDriver(Pdo, irp);
    if (status == STATUS_PENDING) {

        //
        // Wait for the irp to be completed, then grab the real status code
        //
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = ioBlock.Status;

    }

    //
    // Sanity check the data
    //
    if (OutputBuffer != NULL) {

        if ( ( (PACPI_EVAL_OUTPUT_BUFFER) OutputBuffer)->Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
             ( (PACPI_EVAL_OUTPUT_BUFFER) OutputBuffer)->Count == 0) {

            status = STATUS_ACPI_INVALID_DATA;

        }

    }

    CmBattPrint(
        CMBATT_CM_EXE,
        ("CmBattSendDownStreamIrp: Irp %x completed %x! [Tid] %x\n",
         irp, status, GetTid() )
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
CmBattGetUniqueId(
    IN PDEVICE_OBJECT   Pdo,
    OUT PULONG          UniqueId
    )
/*++

Routine Description:

    Obtain the UID (unique ID) for a battery.

Arguments:

    CmBatt          - The extension for this device.
    UniqueId        - Pointer to where the ID is stored.

Return Value:

    NT Status of the operation

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;

    PAGED_CODE();

    CmBattPrint(
        CMBATT_CM_EXE,
        ("CmBattGetUniqueId: Entered with Pdo %x Tid %x\n", Pdo, GetTid() )
        );

    ASSERT( UniqueId != NULL );
    *UniqueId = 0;

    //
    // Fill in the input data
    //
    inputBuffer.MethodNameAsUlong = CM_UID_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;

    //
    // Send the request along
    //
    status = CmBattSendDownStreamIrp(
       Pdo,
       IOCTL_ACPI_EVAL_METHOD,
       &inputBuffer,
       sizeof(ACPI_EVAL_INPUT_BUFFER),
       &outputBuffer,
       sizeof(ACPI_EVAL_OUTPUT_BUFFER)
       );
    if (!NT_SUCCESS(status)) {

        CmBattPrint(
            (CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetUniqueId: Failed _UID method - Status (0x%x)\n", status)
            );
        return status;

    }

    //
    // Grab the argument
    //
    argument = outputBuffer.Argument;
    status = GetDwordElement( argument, UniqueId );
    CmBattPrint(
        (CMBATT_CM_EXE | CMBATT_BIOS),
        ("CmBattGetUniqueId: _UID method returned 0x%x\n", *UniqueId)
        );

    return status;
}

NTSTATUS
CmBattGetStaData(
    IN PDEVICE_OBJECT   Pdo,
    OUT PULONG          ReturnStatus
    )
/*++

Routine Description:

    Called to get a device status via the _STA method.   Generic, works for
    any device with the _STA method (assuming caller has a Pdo).

Arguments:

    Pdo             - For the device.
    ReturnStatus    - Pointer to where the status data is placed.

Return Value:

    NT Status of the operation

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;

    PAGED_CODE();

    CmBattPrint(
        CMBATT_CM_EXE,
        ("CmBattGetStaData: Entered with Pdo %x Tid %x\n", Pdo, GetTid() )
        );

    ASSERT( ReturnStatus != NULL );
    *ReturnStatus = 0x0;

    //
    // Fill in the input data
    //
    inputBuffer.MethodNameAsUlong = CM_STA_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;

    //
    // Send the request along
    //
    status = CmBattSendDownStreamIrp(
       Pdo,
       IOCTL_ACPI_EVAL_METHOD,
       &inputBuffer,
       sizeof(ACPI_EVAL_INPUT_BUFFER),
       &outputBuffer,
       sizeof(ACPI_EVAL_OUTPUT_BUFFER)
       );
    if (!NT_SUCCESS(status)) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetStaData: Failed _STA method - Status (0x%x)\n", status)
            );
        return STATUS_NO_SUCH_DEVICE;

    }

    //
    // Grab the argument
    //
    argument = outputBuffer.Argument;
    status = GetDwordElement( argument, ReturnStatus );
    CmBattPrint(
        (CMBATT_CM_EXE | CMBATT_BIOS),
        ("CmBattGetStaData: _STA method returned %x \n", *ReturnStatus )
        );
    return status;
}

NTSTATUS
CmBattGetPsrData(
    IN PDEVICE_OBJECT   Pdo,
    OUT PULONG          ReturnStatus
    )
/*++

Routine Description:

    Called to get the AC adapter device status via the _PSR method.


Arguments:

    Pdo             - For the device.
    ReturnStatus    - Pointer to where the status data is placed.

Return Value:

    NT Status of the operation

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;

    PAGED_CODE();

    CmBattPrint(
        CMBATT_CM_EXE,
        ("CmBattGetPsrData: Entered with Pdo %x Tid %x\n", Pdo, GetTid() )
        );

    ASSERT( ReturnStatus != NULL );
    *ReturnStatus = 0x0;

    //
    // Fill in the input data
    //
    inputBuffer.MethodNameAsUlong = CM_PSR_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;

    //
    // Send the request along
    //
    status = CmBattSendDownStreamIrp(
       Pdo,
       IOCTL_ACPI_EVAL_METHOD,
       &inputBuffer,
       sizeof(ACPI_EVAL_INPUT_BUFFER),
       &outputBuffer,
       sizeof(ACPI_EVAL_OUTPUT_BUFFER)
       );
    if (!NT_SUCCESS(status)) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetPsrData: Failed _PSR method - Status (0x%x)\n", status)
            );
        return status;

    }

    //
    // Get the value
    //
    argument = outputBuffer.Argument;
    status = GetDwordElement( argument, ReturnStatus );
    CmBattPrint(
        (CMBATT_CM_EXE | CMBATT_BIOS),
        ("CmBattGetPsrData: _PSR method returned %x \n", *ReturnStatus )
        );
    return status;
}

NTSTATUS
CmBattSetTripPpoint(
    IN PCM_BATT     CmBatt,
    IN ULONG        TripPoint
)
/*++

Routine Description:

    Called to set the tripPoint via the BTP control method.

Arguments:

    CmBatt          - The extension for this device.
    TripPoint       - The desired alarm value

Return Value:

    NT Status of the operation

--*/
{
    ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER   inputBuffer;
    NTSTATUS                                status;

    PAGED_CODE();

    CmBattPrint(
         (CMBATT_CM_EXE | CMBATT_BIOS),
         ("CmBattSetTripPpoint: _BTP Alarm Value %x Device %x Tid %x\n",
          TripPoint, CmBatt->DeviceNumber, GetTid() )
         );

    //
    // Fill in the input data
    //
    inputBuffer.MethodNameAsUlong = CM_BTP_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE;
    inputBuffer.IntegerArgument = TripPoint;

    //
    // Send the request along
    //
    status = CmBattSendDownStreamIrp(
       CmBatt->LowerDeviceObject,
       IOCTL_ACPI_EVAL_METHOD,
       &inputBuffer,
       sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER),
       NULL,
       0
       );
    if (!NT_SUCCESS(status)) {

        CmBattPrint(
            (CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattSetTripPpoint: Failed _BTP method on device %x - Status (0x%x)\n",
             CmBatt->DeviceNumber, status)
            );

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
CmBattGetBifData(
    IN PCM_BATT             CmBatt,
    OUT PCM_BIF_BAT_INFO    BifBuf
)
/*++

Routine Description:

    Called to read the BIF package from ACPI

Arguments:

    CmBatt          - The extension for this device.
    BifBuf          - Output buffer for the BIF data

Return Value:

    NT Status of the operation

--*/
{
    ACPI_EVAL_INPUT_BUFFER      inputBuffer;
    NTSTATUS                    status;
    PACPI_EVAL_OUTPUT_BUFFER    outputBuffer;
    PACPI_METHOD_ARGUMENT       argument;

    CmBattPrint(
        CMBATT_CM_EXE,
        ("CmBattGetBifData: Buffer (0x%x) Device %x Tid %x\n",
         BifBuf, CmBatt->DeviceNumber, GetTid() )
        );

    //
    //  Allocate a buffer for this
    //
    outputBuffer = ExAllocatePoolWithTag(
        PagedPool,
        EXPECTED_DATA_SIZE,
        'MtaB'
        );
    if (!outputBuffer) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE),
             ("CmBattGetBifData: Failed to allocate Buffer\n")
            );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Clear the buffers
    //
    RtlZeroMemory(outputBuffer, EXPECTED_DATA_SIZE);
    RtlZeroMemory(BifBuf, sizeof(CM_BIF_BAT_INFO));

    //
    //  Set the request data
    //
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    inputBuffer.MethodNameAsUlong = CM_BIF_METHOD;

    //
    // Send the request along
    //
    status = CmBattSendDownStreamIrp(
        CmBatt->LowerDeviceObject,
        IOCTL_ACPI_EVAL_METHOD,
        &inputBuffer,
        sizeof(ACPI_EVAL_INPUT_BUFFER),
        outputBuffer,
        EXPECTED_DATA_SIZE
        );
    if (!NT_SUCCESS(status)) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
             ("CmBattGetBifData: Failed _BIF method on device %x - Status (0x%x)\n",
             CmBatt->DeviceNumber, status)
            );
        goto CmBattGetBifDataExit;

    }

    //
    // Sanity check the return count
    //
    if (outputBuffer->Count != NUMBER_OF_BIF_ELEMENTS) {

        //
        //  Package did not contain the correct number of elements to be a BIF
        //
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: _BIF returned %d elements. BIF requires %d\n",
             outputBuffer->Count,
             NUMBER_OF_BIF_ELEMENTS)
            );
        status = STATUS_ACPI_INVALID_DATA;
        goto CmBattGetBifDataExit;

    }

    //
    // Look at the return arguments
    //
    argument = outputBuffer->Argument;

    //
    // Parse the package data that is returned.  This should look like:
    //
    status = GetDwordElement (argument, &BifBuf->PowerUnit);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get PowerUnit\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->DesignCapacity);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get DesignCapacity\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->LastFullChargeCapacity);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get LastFullChargeCapacity\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->BatteryTechnology);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get BatteryTechnology\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->DesignVoltage);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get DesignVoltage\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->DesignCapacityOfWarning);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get DesignCapacityOfWarning\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->DesignCapacityOfLow);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get DesignCapacityOfLow\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->BatteryCapacityGran_1);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get BatteryCapacityGran_1\n")
            );
        goto CmBattGetBifDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BifBuf->BatteryCapacityGran_2);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get BatteryCapacityGran_2\n")
            );
        goto CmBattGetBifDataExit;
    }

    RtlZeroMemory (&BifBuf->ModelNumber[0], CM_MAX_STRING_LENGTH);
    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetStringElement (argument, &BifBuf->ModelNumber[0]);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get ModelNumber\n")
            );
        goto CmBattGetBifDataExit;
    }

    RtlZeroMemory (&BifBuf->SerialNumber[0], CM_MAX_STRING_LENGTH);
    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetStringElement (argument, &BifBuf->SerialNumber[0]);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get SerialNumber\n")
            );
        goto CmBattGetBifDataExit;
    }

    RtlZeroMemory (&BifBuf->BatteryType[0], CM_MAX_STRING_LENGTH);
    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetStringElement (argument, &BifBuf->BatteryType[0]);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBifData: Failed to get BatteryType\n")
            );
        goto CmBattGetBifDataExit;
    }

    RtlZeroMemory (&BifBuf->OEMInformation[0], CM_MAX_STRING_LENGTH);
    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );

    //
    // This returns an ASCIIZ string normally,
    // but returns integer 0x00 if OEMInformation isn't supported.
    //
    if (argument->Type == ACPI_METHOD_ARGUMENT_INTEGER) {
        if (argument->Argument != 0) {
            CmBattPrint(
                (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
                ("CmBattGetBifData: Failed to get OEMInformation\n")
                );
            goto CmBattGetBifDataExit;
        }
        BifBuf->OEMInformation[0] = 0;
        status = STATUS_SUCCESS;
    } else {
        status = GetStringElement (argument, &BifBuf->OEMInformation[0]);
        if (!NT_SUCCESS (status)) {
            CmBattPrint(
                (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
                ("CmBattGetBifData: OEMInformation not supported\n")
                );
        }
    }

CmBattGetBifDataExit:
    //
    // Done
    //
    ExFreePool (outputBuffer);
    return status;
}



NTSTATUS
CmBattGetBstData(
    IN PCM_BATT             CmBatt,
    OUT PCM_BST_BAT_INFO    BstBuf
)
/*++

Routine Description:

    Called to read the BST package from ACPI

Arguments:

    CmBatt          - The extension for this device.
    BstBuf          - Output buffer for the BST data

Return Value:

    NT Status of the operation

--*/
{
    ACPI_EVAL_INPUT_BUFFER      inputBuffer;
    NTSTATUS                    status;
    PACPI_EVAL_OUTPUT_BUFFER    outputBuffer;
    PACPI_METHOD_ARGUMENT       argument;

    CmBattPrint(
         CMBATT_CM_EXE,
         ("CmBattGetBstData: Buffer (0x%x) Device %x Tid %x\n",
          BstBuf, CmBatt->DeviceNumber, GetTid() )
         );

    //
    //  Allocate a buffer for this
    //
    outputBuffer = ExAllocatePoolWithTag(
        PagedPool,
        EXPECTED_DATA_SIZE,
        'MtaB'
        );
    if (!outputBuffer) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE),
             ("CmBattGetBstData: Failed to allocate Buffer\n")
            );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Clear the buffers
    //
    RtlZeroMemory(outputBuffer, EXPECTED_DATA_SIZE);
    RtlZeroMemory(BstBuf, sizeof(CM_BST_BAT_INFO));

    //
    //  Set the request data
    //
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    inputBuffer.MethodNameAsUlong = CM_BST_METHOD;

    //
    // Send the request along
    //
    status = CmBattSendDownStreamIrp(
        CmBatt->LowerDeviceObject,
        IOCTL_ACPI_EVAL_METHOD,
        &inputBuffer,
        sizeof(ACPI_EVAL_INPUT_BUFFER),
        outputBuffer,
        EXPECTED_DATA_SIZE
        );
    if (!NT_SUCCESS(status)) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
             ("CmBattGetBstData: Failed _BST method on device %x - Status (0x%x)\n",
             CmBatt->DeviceNumber, status)
            );
        goto CmBattGetBstDataExit;

    }

    //
    // Sanity check the return value
    //
    if (outputBuffer->Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
        outputBuffer->Count != NUMBER_OF_BST_ELEMENTS) {

        //
        //  Package did not contain the correct number of elements to be a BIF
        //
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBstData: _BST returned %d elements. BIF requires %d\n",
             outputBuffer->Count,
             NUMBER_OF_BST_ELEMENTS)
            );
        status = STATUS_ACPI_INVALID_DATA;
        goto CmBattGetBstDataExit;

    }

    //
    // Look at the return arguments
    //
    argument = outputBuffer->Argument;

    //
    // Parse the package data that is returned.  This should look like:
    //
    status = GetDwordElement (argument, &BstBuf->BatteryState);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBstData: Failed to get BatteryState\n")
            );
        goto CmBattGetBstDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BstBuf->PresentRate);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBstData: Failed to get PresentRate\n")
            );
        goto CmBattGetBstDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BstBuf->RemainingCapacity);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBstData: Failed to get RemainingCapacity\n")
            );
        goto CmBattGetBstDataExit;
    }

    argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    status = GetDwordElement (argument, &BstBuf->PresentVoltage);
    if (!NT_SUCCESS (status)) {
        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE | CMBATT_BIOS),
            ("CmBattGetBstData: Failed to get PresentVoltage\n")
            );
        goto CmBattGetBstDataExit;
    }

    CmBattPrint ((CMBATT_TRACE | CMBATT_DATA | CMBATT_BIOS),
               ("CmBattGetBstData: (BST) State=%x Rate=%x Capacity=%x Volts=%x\n",
                BstBuf->BatteryState, BstBuf->PresentRate,
                BstBuf->RemainingCapacity, BstBuf->PresentVoltage));

    //
    // Done --- cleanup
    //

CmBattGetBstDataExit:
    ExFreePool( outputBuffer );
    return status;
}

NTSTATUS
GetDwordElement (
    IN  PACPI_METHOD_ARGUMENT   Argument,
    OUT PULONG                  PDword
)
/*++

Routine Description:

    This routine cracks the integer value from the argument and stores it
    in the supplied pointer to a ULONG

Arguments:

    Argument    - Points to the argument to parse
    PDword      - Where to store the argument

Return Value:

    NT Status of the operation

--*/
{

    //
    // Check to see if we have the right type of data
    //
    if (Argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE),
            ("GetDwordElement: Object contained wrong data type - %d\n",
             Argument->Type)
            );
        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // Copy the DWORD
    //
    *PDword = Argument->Argument;

    //
    // Success!
    //
    return STATUS_SUCCESS;
}

NTSTATUS
GetStringElement (
    IN  PACPI_METHOD_ARGUMENT   Argument,
    OUT PUCHAR                  PBuffer
)
/*++

Routine Description:

    This routine cracks the string from the argument and stroes it in the
    supplied pointer to a PUCHAR

    Note: A buffer is allowed as well.

Arguments:

    Argument    - Points to the argument to parse
    PBuffer     - Pointer to storage for the string

Return Value:

    NT Status of the operation

--*/
{

    //
    // Check to see if we have the right type of data
    //
    if (Argument->Type != ACPI_METHOD_ARGUMENT_STRING &&
        Argument->Type != ACPI_METHOD_ARGUMENT_BUFFER) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE),
            ("GetStringElement: Object contained wrong data type - %d\n",
             Argument->Type)
            );
        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // Check to see if the return buffer is long enough
    //
    if (Argument->DataLength >= CM_MAX_STRING_LENGTH) {

        CmBattPrint(
            (CMBATT_ERROR | CMBATT_CM_EXE),
            ("GetStringElement: return buffer not big enough - %d\n",
             Argument->DataLength)
            );
        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    // Copy the string
    //
    RtlCopyMemory (PBuffer, Argument->Data, Argument->DataLength);

    //
    // Success
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\cmbatt\cmbpnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cmbpnp.c

Abstract:

    Control Method Battery Plug and Play support

Author:

    Ron Mosgrove

Environment:

    Kernel mode

Revision History:

--*/

#include "CmBattp.h"
#include <wdmguid.h>
#include <string.h>

//
// Power Source Type registry key
//
PCWSTR                      PowerSourceType     = L"PowerSourceType";
#define POWER_SOURCE_TYPE_BATTERY       0
#define POWER_SOURCE_TYPE_AC_ADAPTER    1

//
// WaitWake registry key
//
PCWSTR                      WaitWakeEnableKey     = L"WaitWakeEnabled";

//
// Globals
//
PDEVICE_OBJECT              AcAdapterPdo = NULL;

//
// Prototypes
//
NTSTATUS
CmBattAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );

NTSTATUS
CmBattRemoveDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
CmBattGetAcpiInterfaces(
    IN PDEVICE_OBJECT               LowerDevice,
    OUT PACPI_INTERFACE_STANDARD    AcpiInterfaces
    );

NTSTATUS
CmBattAddBattery(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );

NTSTATUS
CmBattAddAcAdapter(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );

NTSTATUS
CmBattCreateFdo(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       Pdo,
    IN ULONG                ExtensionSize,
    OUT PDEVICE_OBJECT      *NewFdo
    );

VOID
CmBattDestroyFdo(
    IN PDEVICE_OBJECT   Fdo
    );



NTSTATUS
CmBattIoCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          pdoIoCompletedEvent
    )
/*++

Routine Description:

    This routine catches completion notifications.

Arguments:

    DeviceObject        - Pointer to class device object.
    Irp                 - Pointer to the request packet.
    pdoIoCompletedEvent - the just completed event

Return Value:

    Status is returned.

--*/
{

    CmBattPrint (CMBATT_TRACE, ("CmBattIoCompletion: Event (%x)\n", pdoIoCompletedEvent));

    KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
CmBattAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine creates functional device objects for each CmBatt controller in the
    system and attaches them to the physical device objects for the controllers


Arguments:

    DriverObject            - a pointer to the object for this driver
    PhysicalDeviceObject    - a pointer to the physical object we need to attach to

Return Value:

    Status from device creation and initialization

--*/

{
    NTSTATUS                Status;
    HANDLE                  handle;
    UNICODE_STRING          unicodeString;
    CHAR                    buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG)];
    ULONG                   unused;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_PNP), ("CmBattAddDevice: Entered with pdo %x\n", Pdo));

    if (Pdo == NULL) {

        //
        // Have we been asked to do detection on our own?
        // if so just return no more devices
        //

        CmBattPrint((CMBATT_WARN | CMBATT_PNP), ("CmBattAddDevice: Asked to do detection\n"));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Get the software branch.
    //
    Status = IoOpenDeviceRegistryKey (Pdo,
                                      PLUGPLAY_REGKEY_DRIVER,
                                      STANDARD_RIGHTS_READ,
                                      &handle);
    if (!NT_SUCCESS(Status)) {
        CmBattPrint(CMBATT_ERROR, ("CmBattAddDevice: Could not get the software branch: %x\n", Status));
        return Status;
    }

    //
    // Check if this is for an AC adapter or a battery.
    //
    RtlInitUnicodeString (&unicodeString, PowerSourceType);
    Status = ZwQueryValueKey(
        handle,
        &unicodeString,
        KeyValuePartialInformation,
        buffer,
        sizeof(buffer),
        &unused
        );

    ZwClose( handle );

    if (!NT_SUCCESS(Status)) {

        CmBattPrint(CMBATT_ERROR, ("CmBattAddDevice: Could not read the power type identifier: %x\n", Status));

    } else {

        switch (*(PULONG)&((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data) {

            case POWER_SOURCE_TYPE_BATTERY:
                Status = CmBattAddBattery (DriverObject, Pdo);
                break;

            case POWER_SOURCE_TYPE_AC_ADAPTER:
                Status = CmBattAddAcAdapter (DriverObject, Pdo);
                break;

            default:
                CmBattPrint(CMBATT_ERROR, ("CmBattAddDevice: Invalid POWER_SOURCE_TYPE == %d \n", *(PULONG)&((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data));
                Status = STATUS_UNSUCCESSFUL;
                break;
        }
    }

    //
    // Return the status.
    //
    return Status;
}



NTSTATUS
CmBattAddBattery(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    )
/*++

Routine Description:

    This routine creates a functional device object for a CM battery,  and attache it
    to the physical device object for the battery.

Arguments:

    DriverObject            - a pointer to the object for this driver
    PhysicalDeviceObject    - a pointer to the physical object we need to attach to

Return Value:

    Status from device creation and initialization

--*/

{
    PDEVICE_OBJECT          Fdo = NULL;
    PCM_BATT                CmBatt;
    NTSTATUS                Status;
    BATTERY_MINIPORT_INFO   BattInit;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_PNP), ("CmBattAddBattery: pdo %x\n", Pdo));

    //
    // Create and initialize the new functional device object
    //
    Status = CmBattCreateFdo(DriverObject, Pdo, sizeof(CM_BATT), &Fdo);

    if (!NT_SUCCESS(Status)) {
        CmBattPrint(CMBATT_ERROR, ("CmBattAddBattery: error (0x%x) creating Fdo\n", Status));
        return Status;
    }

    //
    // Initialize Fdo device extension data
    //

    CmBatt = (PCM_BATT) Fdo->DeviceExtension;
    CmBatt->Type = CM_BATTERY_TYPE;
    CmBatt->IsStarted = FALSE;
    CmBatt->ReCheckSta = TRUE;
    InterlockedExchange (&CmBatt->CacheState, 0);

    CmBatt->Info.Tag = BATTERY_TAG_INVALID;
    CmBatt->Alarm.Setting = CM_ALARM_INVALID;
    CmBatt->DischargeTime = KeQueryInterruptTime();

    if (CmBattSetTripPpoint (CmBatt, 0) == STATUS_OBJECT_NAME_NOT_FOUND) {
        CmBatt->Info.BtpExists = FALSE;
    } else {
        CmBatt->Info.BtpExists = TRUE;
    }

    //
    //  Attach to the Class Driver
    //

    RtlZeroMemory (&BattInit, sizeof(BattInit));
    BattInit.MajorVersion        = BATTERY_CLASS_MAJOR_VERSION;
    BattInit.MinorVersion        = BATTERY_CLASS_MINOR_VERSION;
    BattInit.Context             = CmBatt;
    BattInit.QueryTag            = CmBattQueryTag;
    BattInit.QueryInformation    = CmBattQueryInformation;
    BattInit.SetInformation      = NULL;                  // tbd
    BattInit.QueryStatus         = CmBattQueryStatus;
    BattInit.SetStatusNotify     = CmBattSetStatusNotify;
    BattInit.DisableStatusNotify = CmBattDisableStatusNotify;

    BattInit.Pdo                 = Pdo;
    BattInit.DeviceName          = CmBatt->DeviceName;

    Status = BatteryClassInitializeDevice (&BattInit, &CmBatt->Class);
    if (!NT_SUCCESS(Status)) {
        //
        //  if we can't attach to class driver we're toast
        //
        CmBattPrint(CMBATT_ERROR, ("CmBattAddBattery: error (0x%x) registering with class\n", Status));
        IoDetachDevice (CmBatt->LowerDeviceObject);
        CmBattDestroyFdo (CmBatt->Fdo);
        return Status;
    }

    //
    // Register WMI support.
    //
    Status = CmBattWmiRegistration(CmBatt);

    if (!NT_SUCCESS(Status)) {
        //
        // WMI support is not critical to operation.  Just log an error.
        //

        CmBattPrint(CMBATT_ERROR,
            ("CmBattAddBattery: Could not register as a WMI provider, status = %Lx\n", Status));
    }

    //
    // Register the battery notify handler for this battery with ACPI
    // This registration is performed after registering with the battery
    // class because CmBattNotifyHandler must not be run until the battery
    // class is ready.
    //
    Status = CmBatt->AcpiInterfaces.RegisterForDeviceNotifications (
                CmBatt->AcpiInterfaces.Context,
                CmBattNotifyHandler,
                CmBatt);

    if (!NT_SUCCESS(Status)) {

        CmBattPrint(CMBATT_ERROR,
            ("CmBattAddBattery: Could not register for battery notify, status = %Lx\n", Status));
        CmBattWmiDeRegistration(CmBatt);
        BatteryClassUnload (CmBatt->Class);
        IoDetachDevice (CmBatt->LowerDeviceObject);
        CmBattDestroyFdo (CmBatt->Fdo);
        return Status;
    }


    return STATUS_SUCCESS;
}


NTSTATUS
CmBattAddAcAdapter(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    )
/*++

Routine Description:

    This routine registers a notify handler for the AC Adapter.  And saves the PDO so we can run
    the _STA method against it to get the AC status.

Arguments:

    DriverObject            - a pointer to the object for this driver
    Pdo                     - a pointer to the Pdo

Return Value:

    Status from device creation and initialization

--*/

{
    PDEVICE_OBJECT          Fdo;
    NTSTATUS                Status;
    PAC_ADAPTER             acExtension;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_PNP), ("CmBattAddAcAdapter: pdo %x\n", Pdo));

    //
    // Save PDO so we can run _STA method on it later
    //

    if (AcAdapterPdo != NULL) {
        CmBattPrint(CMBATT_ERROR, ("CmBatt: Second AC adapter found.  Current version of driver only supports 1 aadapter.\n"));
    } else {
        AcAdapterPdo = Pdo;
    }

    Status = CmBattCreateFdo(DriverObject, Pdo, sizeof(AC_ADAPTER), &Fdo);

    if (!NT_SUCCESS(Status)) {
        CmBattPrint(CMBATT_ERROR, ("CmBattAddAcAdapter: error (0x%x) creating Fdo\n", Status));
        return Status;
    }

    //
    // Initialize Fdo device extension data
    //

    acExtension = (PAC_ADAPTER) Fdo->DeviceExtension;
    acExtension->Type = AC_ADAPTER_TYPE;

    //
    // Register WMI support.
    //
    Status = CmBattWmiRegistration((PCM_BATT)acExtension);

    if (!NT_SUCCESS(Status)) {
        //
        // WMI support is not critical to operation.  Just log an error.
        //

        CmBattPrint(CMBATT_ERROR,
            ("CmBattAddBattery: Could not register as a WMI provider, status = %Lx\n", Status));
    }

    //
    // Register the AC adapter notify handler with ACPI
    //
    Status = acExtension->AcpiInterfaces.RegisterForDeviceNotifications (
                acExtension->AcpiInterfaces.Context,
                CmBattNotifyHandler,
                acExtension);

    //
    // We will ignore errors, since this is not a critical operation
    //

    if (!NT_SUCCESS(Status)) {

        CmBattPrint(CMBATT_ERROR,
        ("CmBattAddAcAdapter: Could not register for power notify, status = %Lx\n", Status));
    }

    //
    // Give one notification, to make sure all batteries get updated.
    //

    CmBattNotifyHandler (acExtension, BATTERY_STATUS_CHANGE);

    return STATUS_SUCCESS;
}



NTSTATUS
CmBattGetAcpiInterfaces(
    IN PDEVICE_OBJECT               LowerDevice,
    OUT PACPI_INTERFACE_STANDARD    AcpiInterfaces
    )

/*++

Routine Description:

    Call ACPI driver to get the direct-call interfaces.  It does
    this the first time it is called, no more.

Arguments:

    None.

Return Value:

    Status

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    KEVENT                  syncEvent;

    //
    // Allocate an IRP for below
    //
    Irp = IoAllocateIrp (LowerDevice->StackSize, FALSE);      // Get stack size from PDO

    if (!Irp) {
        CmBattPrint((CMBATT_ERROR),
            ("CmBattGetAcpiInterfaces: Failed to allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IrpSp = IoGetNextIrpStackLocation(Irp);

    //
    // Use QUERY_INTERFACE to get the address of the direct-call ACPI interfaces.
    //
    IrpSp->MajorFunction = IRP_MJ_PNP;
    IrpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    IrpSp->Parameters.QueryInterface.InterfaceType          = (LPGUID) &GUID_ACPI_INTERFACE_STANDARD;
    IrpSp->Parameters.QueryInterface.Version                = 1;
    IrpSp->Parameters.QueryInterface.Size                   = sizeof (*AcpiInterfaces);
    IrpSp->Parameters.QueryInterface.Interface              = (PINTERFACE) AcpiInterfaces;
    IrpSp->Parameters.QueryInterface.InterfaceSpecificData  = NULL;

    //
    // Initialize an event so this will be a syncronous call.
    //

    KeInitializeEvent(&syncEvent, SynchronizationEvent, FALSE);

    IoSetCompletionRoutine (Irp, CmBattIoCompletion, &syncEvent, TRUE, TRUE, TRUE);

    //
    // Call ACPI
    //

    Status = IoCallDriver (LowerDevice, Irp);

    //
    // Wait if necessary, then clean up.
    //

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&syncEvent, Executive, KernelMode, FALSE, NULL);
        Status = Irp->IoStatus.Status;
    }

    IoFreeIrp (Irp);

    if (!NT_SUCCESS(Status)) {

        CmBattPrint(CMBATT_ERROR,
           ("CmBattGetAcpiInterfaces: Could not get ACPI driver interfaces, status = %x\n", Status));
    }

    return Status;
}



NTSTATUS
CmBattCreateFdo(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       Pdo,
    IN ULONG                ExtensionSize,
    OUT PDEVICE_OBJECT      *NewFdo
    )

/*++

Routine Description:

    This routine will create and initialize a functional device object to
    be attached to a Control Method Battery PDO.

Arguments:

    DriverObject    - a pointer to the driver object this is created under
    ExtensionSize   - device extension size: sizeof (CM_BATT) or sizeof (AC_ADAPTER)
    NewFdo          - a location to store the pointer to the new device object

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{
    PDEVICE_OBJECT          fdo;
    NTSTATUS                status;
    PCM_BATT                cmBatt;
    ULONG                   uniqueId;
    USHORT                  strLength = 0;
    HANDLE                  devInstRegKey;
    UNICODE_STRING          valueName;
    CHAR                    buffer [sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG)];
    ULONG                   returnSize;


    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_PNP), ("CmBattCreateFdo: Entered\n"));

    //
    // Get the unique ID of this device by running the _UID method.
    // If this fails, assume one device.
    //
    status = CmBattGetUniqueId (Pdo, &uniqueId);

    if (!NT_SUCCESS(status)) {
        CmBattPrint(CMBATT_NOTE, ("CmBattCreateFdo: Error %x from _UID, assuming unit #0\n", status));
        uniqueId = 0;
    }

    //
    // Create the FDO
    //

    status = IoCreateDevice(
                DriverObject,
                ExtensionSize,
                NULL,
                FILE_DEVICE_BATTERY,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &fdo
                );

    if (status != STATUS_SUCCESS) {
        CmBattPrint(CMBATT_ERROR, ("CmBattCreateFdo: error (0x%x) creating device object\n", status));
        return(status);
    }

    fdo->Flags |= DO_BUFFERED_IO;
    fdo->Flags |= DO_POWER_PAGABLE;     // Don't want power Irps at irql 2
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Initialize Fdo device extension data
    //

    cmBatt = (PCM_BATT) fdo->DeviceExtension;

    //
    // Note: This is note necessarily a battery.  It could be an AC adapter, so only fields
    // common to both should be initialized here.
    //

    RtlZeroMemory(cmBatt, ExtensionSize);
    //CmBatt->Type must be initialized after this call.
    cmBatt->DeviceObject = fdo;
    cmBatt->Fdo = fdo;
    cmBatt->Pdo = Pdo;

        //
        // Connect to lower device
        //

    cmBatt->LowerDeviceObject = IoAttachDeviceToDeviceStack(fdo, Pdo);
    if (!cmBatt->LowerDeviceObject) {
        CmBattPrint(CMBATT_ERROR, ("CmBattCreateFdo: IoAttachDeviceToDeviceStack failed.\n"));
        CmBattDestroyFdo (cmBatt->Fdo);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Get the direct-call ACPI interfaces
    //
    status = CmBattGetAcpiInterfaces (cmBatt->LowerDeviceObject, &cmBatt->AcpiInterfaces);
    if (!NT_SUCCESS(status)) {
        CmBattPrint(CMBATT_ERROR, ("CmBattCreateFdor: Could not get ACPI interfaces: %x\n", status));
        IoDetachDevice (cmBatt->LowerDeviceObject);
        CmBattDestroyFdo (cmBatt->Fdo);
        return status;
    }

    //
    // Initializes File handle tracking.
    //
    ExInitializeFastMutex (&cmBatt->OpenCloseMutex);
    cmBatt->OpenCount = 0;

    //
    // Removal lock initialization
    //
    cmBatt->WantToRemove = FALSE;
    cmBatt->InUseCount = 1;
    KeInitializeEvent(&cmBatt->ReadyToRemove, SynchronizationEvent, FALSE);

    cmBatt->DeviceNumber = uniqueId;
    cmBatt->DeviceName = NULL;
    cmBatt->Sleeping = FALSE;
    cmBatt->ActionRequired = CMBATT_AR_NO_ACTION;

    //
    // Determine if wake on Battery should be enabled
    //
    cmBatt->WakeEnabled = FALSE;

    status = IoOpenDeviceRegistryKey (Pdo,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      STANDARD_RIGHTS_ALL,
                                      &devInstRegKey);

    if (NT_SUCCESS (status)) {
        RtlInitUnicodeString (&valueName, WaitWakeEnableKey);
        status = ZwQueryValueKey(
            devInstRegKey,
            &valueName,
            KeyValuePartialInformation,
            buffer,
            sizeof(buffer),
            &returnSize
            );

        if (NT_SUCCESS (status)) {
            cmBatt->WakeEnabled = (*(PULONG)((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data ? TRUE : FALSE);
        }
        ZwClose(devInstRegKey);
    }

    *NewFdo = fdo;

    CmBattPrint((CMBATT_TRACE | CMBATT_PNP), ("CmBattCreateFdo: Created FDO %x\n", fdo));
    return STATUS_SUCCESS;
}



VOID
CmBattDestroyFdo(
    IN PDEVICE_OBJECT       Fdo
    )

/*++

Routine Description:

    This routine will deallocate a functional device object.
    This includes calling IoDeleteDevice.

Arguments:

    Fdo       - a pointer to the FDO to destroy.

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE | CMBATT_PNP), ("CmBattDestroyFdo, Battery.\n"));

    IoDeleteDevice (Fdo);

    CmBattPrint((CMBATT_TRACE | CMBATT_PNP), ("CmBattDestroyFdo: done.\n"));
}



NTSTATUS
CmBattPnpDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for plug and play requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PCM_BATT            CmBatt;
    NTSTATUS            status;
    KEVENT              syncEvent;

    PAGED_CODE();

    status = STATUS_NOT_SUPPORTED;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    CmBatt = DeviceObject->DeviceExtension;

    //
    // Aquire remove lock
    //

    InterlockedIncrement (&CmBatt->InUseCount);
    if (CmBatt->WantToRemove == TRUE) {
        //
        // Failed to acquire remove lock.
        //
        status = STATUS_DEVICE_REMOVED;
    } else {
        //
        // Remove lock acquired.
        //

        //
        // Dispatch minor function
        //
        switch (irpStack->MinorFunction) {

            case IRP_MN_START_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_START_DEVICE\n"));

                if (CmBatt->Type == CM_BATTERY_TYPE) {
                    //
                    // We only want to handle batteries, not AC adapters.
                    //

                    CmBatt->IsStarted = TRUE;

                }
                status = STATUS_SUCCESS;

                break;
            }   // IRP_MN_START_DEVICE

            case IRP_MN_STOP_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_STOP_DEVICE\n"));

                if (CmBatt->Type == CM_BATTERY_TYPE) {
                    CmBatt->IsStarted = FALSE;
                }
                status = STATUS_SUCCESS;

                break;
            }   // IRP_MN_STOP_DEVICE

            case IRP_MN_REMOVE_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_REMOVE_DEVICE\n"));

                status = CmBattRemoveDevice(DeviceObject, Irp);
                break;
            }   //  IRP_MN_REMOVE_DEVICE

            case IRP_MN_SURPRISE_REMOVAL: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_SURPRISE_REMOVAL\n"));

                ExAcquireFastMutex (&CmBatt->OpenCloseMutex);
                status = STATUS_SUCCESS;

                CmBatt->OpenCount = (ULONG) -1;

                ExReleaseFastMutex (&CmBatt->OpenCloseMutex);

                break;
            }   //  IRP_MN_QUERY_REMOVE_DEVICE

            case IRP_MN_QUERY_REMOVE_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_QUERY_REMOVE_DEVICE\n"));

                ExAcquireFastMutex (&CmBatt->OpenCloseMutex);
                status = STATUS_SUCCESS;

                if (CmBatt->OpenCount == 0) {
                    CmBatt->OpenCount = (ULONG) -1;
                } else if (CmBatt->OpenCount == (ULONG) -1) {
                    CmBattPrint (CMBATT_WARN, ("CmBattPnpDispatch: Recieved two consecutive QUERY_REMOVE requests.\n"));

                } else {
                    status = STATUS_UNSUCCESSFUL;
                }

                ExReleaseFastMutex (&CmBatt->OpenCloseMutex);

                break;
            }   //  IRP_MN_QUERY_REMOVE_DEVICE

            case IRP_MN_CANCEL_REMOVE_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_CANCEL_REMOVE_DEVICE\n"));

                ExAcquireFastMutex (&CmBatt->OpenCloseMutex);

                if (CmBatt->OpenCount == (ULONG) -1) {
                    CmBatt->OpenCount = 0;
                } else {
                    CmBattPrint (CMBATT_NOTE, ("CmBattPnpDispatch: Received CANCEL_REMOVE when OpenCount == %x\n",
                                 CmBatt->OpenCount));
                }
                status = STATUS_SUCCESS;

                ExReleaseFastMutex (&CmBatt->OpenCloseMutex);

                break;
            }   //  IRP_MN_CANCEL_REMOVE_DEVICE

            case IRP_MN_QUERY_STOP_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_QUERY_STOP_DEVICE\n"));
                status = STATUS_NOT_IMPLEMENTED;
                break;
            }   //  IRP_MN_QUERY_STOP_DEVICE

            case IRP_MN_CANCEL_STOP_DEVICE: {
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_CANCEL_STOP_DEVICE\n"));
                status = STATUS_NOT_IMPLEMENTED;
                break;
            }   //  IRP_MN_CANCEL_STOP_DEVICE

            case IRP_MN_QUERY_PNP_DEVICE_STATE: {

                IoCopyCurrentIrpStackLocationToNext (Irp);

                KeInitializeEvent(&syncEvent, SynchronizationEvent, FALSE);

                IoSetCompletionRoutine(Irp, CmBattIoCompletion, &syncEvent, TRUE, TRUE, TRUE);

                status = IoCallDriver(CmBatt->LowerDeviceObject, Irp);

                if (status == STATUS_PENDING) {
                    KeWaitForSingleObject(&syncEvent, Executive, KernelMode, FALSE, NULL);
                    status = Irp->IoStatus.Status;
                }

                Irp->IoStatus.Information &= ~PNP_DEVICE_NOT_DISABLEABLE;

                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
                    KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
                }
                return status;

            }

            case IRP_MN_QUERY_CAPABILITIES: {

                IoCopyCurrentIrpStackLocationToNext (Irp);

                KeInitializeEvent(&syncEvent, SynchronizationEvent, FALSE);

                IoSetCompletionRoutine(Irp, CmBattIoCompletion, &syncEvent, TRUE, TRUE, TRUE);

                status = IoCallDriver(CmBatt->LowerDeviceObject, Irp);

                if (status == STATUS_PENDING) {
                    KeWaitForSingleObject(&syncEvent, Executive, KernelMode, FALSE, NULL);
                    status = Irp->IoStatus.Status;
                }

                CmBatt->WakeSupportedState.SystemState = irpStack->Parameters.DeviceCapabilities.Capabilities->SystemWake;
                CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_QUERY_CAPABILITIES %d Capabilities->SystemWake = %x\n", CmBatt->Type, CmBatt->WakeSupportedState.SystemState));
                if (CmBatt->WakeSupportedState.SystemState != PowerSystemUnspecified) {
                    if (CmBatt->WaitWakeIrp == NULL && CmBatt->WakeEnabled) {
                        PoRequestPowerIrp(
                            CmBatt->DeviceObject,
                            IRP_MN_WAIT_WAKE,
                            CmBatt->WakeSupportedState,
                            CmBattWaitWakeLoop,
                            NULL,
                            &(CmBatt->WaitWakeIrp)
                            );

                        //
                        // Ignore return value.  Capbilities IRP should still succeed.
                        //

                        CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_QUERY_CAPABILITIES wait/Wake irp sent.\n"));
                    }
                } else {
                    CmBatt->WakeEnabled=FALSE;
                    CmBattPrint (CMBATT_PNP, ("CmBattPnpDispatch: IRP_MN_QUERY_CAPABILITIES Wake not supported.\n"));
                }

                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
                    KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
                }
                return status;

            }

            default: {
                //
                // Unimplemented minor, Pass this down
                //
                CmBattPrint (CMBATT_PNP,
                        ("CmBattPnpDispatch: Unimplemented minor %0x\n", \
                        irpStack->MinorFunction));
            }   //  default

            // Fall through...

            case IRP_MN_QUERY_RESOURCES:
            case IRP_MN_READ_CONFIG:
            case IRP_MN_WRITE_CONFIG:
            case IRP_MN_EJECT:
            case IRP_MN_SET_LOCK:
            case IRP_MN_QUERY_ID:
            case IRP_MN_QUERY_DEVICE_RELATIONS: {

                break ;
            }
        }
    }

    //
    // Release remove lock
    //

    if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
        KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
    }


    //
    // Only set status if we have something to add
    //
    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;

    }

    //
    // Do we need to send it down?
    //
    if (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) {

        CmBattCallLowerDriver(status, CmBatt->LowerDeviceObject, Irp);
        return status;
    }

    //
    // At this point, it must have been passed down and needs recompletion,
    // or the status is unsuccessful.
    //
    ASSERT(!NT_SUCCESS(status) && (status != STATUS_NOT_SUPPORTED));

    status = Irp->IoStatus.Status ;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}


NTSTATUS
CmBattRemoveDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine processes a IRP_MN_REMOVE_DEVICE

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Returns STATUS_SUCCESS.  (This function must not fail.)

--*/

{
    PCM_BATT                cmBatt;
    NTSTATUS                status;

    cmBatt = (PCM_BATT) DeviceObject->DeviceExtension;
    CmBattPrint (CMBATT_TRACE, ("CmBattRemoveDevice: CmBatt (%x), Type %d, _UID %d\n",
                 cmBatt, cmBatt->Type, cmBatt->DeviceNumber));


    //
    // Remove device syncronization
    //

    //
    // Prevent more locks from being acquired.
    //

    cmBatt->WantToRemove = TRUE;

    //
    // Release lock acquired at start of CmBattPnpDispatch
    //
    if (InterlockedDecrement (&cmBatt->InUseCount) <= 0) {
        CmBattPrint (CMBATT_ERROR, ("CmBattRemoveDevice: Remove lock error.\n"));
        ASSERT(FALSE);
    }

    //
    // Final release and wait.
    //
    // Note: there will be one more relase at the end of CmBattPnpDispatch
    // but it will decrement the InUseCount to -1 so it won't set the event.
    //
    if (InterlockedDecrement (&cmBatt->InUseCount) > 0) {
        KeWaitForSingleObject (&cmBatt->ReadyToRemove,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL
                               );
    }

    //
    // Cancel the Wait/wake IRP;
    //
    if (cmBatt->WaitWakeIrp != NULL) {
        IoCancelIrp (cmBatt->WaitWakeIrp);
        cmBatt->WaitWakeIrp = NULL;
    }

    if (cmBatt->Type == CM_BATTERY_TYPE) {
        //
        // This is a control method battery FDO
        //

        //
        // Disconnect from receiving device (battery) notifications
        //

        cmBatt->AcpiInterfaces.UnregisterForDeviceNotifications (
            cmBatt->AcpiInterfaces.Context,
            CmBattNotifyHandler);

        //
        // Unregister as a WMI Provider.
        //
        CmBattWmiDeRegistration(cmBatt);

        //
        //  Tell the class driver we are going away
        //
        status = BatteryClassUnload (cmBatt->Class);
        ASSERT (NT_SUCCESS(status));

    } else {
        //
        // This is an AC adapter FDO
        //

        //
        // Disconnect from receiving device (battery) notifications
        //

        cmBatt->AcpiInterfaces.UnregisterForDeviceNotifications (
            cmBatt->AcpiInterfaces.Context,
            CmBattNotifyHandler);

        //
        // Unregister as a WMI Provider.
        //
        CmBattWmiDeRegistration(cmBatt);

        AcAdapterPdo = NULL;
    }

    //
    //  Clean up, delete the Fdo we created at AddDevice time
    //

    IoDetachDevice (cmBatt->LowerDeviceObject);
    IoDeleteDevice (cmBatt->DeviceObject);

    return STATUS_SUCCESS;

}


NTSTATUS
CmBattPowerDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION  irpStack;
    PCM_BATT            CmBatt;
    NTSTATUS            Status;

    //
    // A remove lock is not needed in this dispatch function because
    // all data accessed is in the device extension.  If any other functionality
    // was added to this routine, a remove lock might be neccesary.
    //

    CmBattPrint ((CMBATT_TRACE | CMBATT_POWER), ("CmBattPowerDispatch\n"));

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    CmBatt = DeviceObject->DeviceExtension;

    //
    // Dispatch minor function
    //
    switch (irpStack->MinorFunction) {

    case IRP_MN_WAIT_WAKE: {
            CmBattPrint (CMBATT_POWER, ("CmBattPowerDispatch: IRP_MN_WAIT_WAKE\n"));
            break;
        }

    case IRP_MN_POWER_SEQUENCE: {
            CmBattPrint (CMBATT_POWER, ("CmBattPowerDispatch: IRP_MN_POWER_SEQUENCE\n"));
            break;
        }

    case IRP_MN_SET_POWER: {
            CmBattPrint (CMBATT_POWER, ("CmBattPowerDispatch: IRP_MN_SET_POWER type: %d, State: %d \n",
                                        irpStack->Parameters.Power.Type,
                                        irpStack->Parameters.Power.State));
            break;
        }

    case IRP_MN_QUERY_POWER: {
            CmBattPrint (CMBATT_POWER, ("CmBattPowerDispatch: IRP_MN_QUERY_POWER\n"));
            break;
        }

    default: {

            CmBattPrint(CMBATT_LOW, ("CmBattPowerDispatch: minor %d\n",
                    irpStack->MinorFunction));

            break;
        }
    }

    //
    // What do we do with the irp?
    //
    PoStartNextPowerIrp( Irp );
    if (CmBatt->LowerDeviceObject != NULL) {

        //
        // Forward the request along
        //
        IoSkipCurrentIrpStackLocation( Irp );
        Status = PoCallDriver( CmBatt->LowerDeviceObject, Irp );

    } else {

        //
        // Complete the request with the current status
        //
        Status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return Status;
}



NTSTATUS
CmBattForwardRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine passes the request down the stack

Arguments:

    DeviceObject    - The target
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PCM_BATT    cmBatt = DeviceObject->DeviceExtension;

    //
    // A remove lock is not needed in this dispatch function because
    // all data accessed is in the device extension.  If any other functionality was
    // added to this routine, a remove lock might be neccesary.
    //

    if (cmBatt->LowerDeviceObject != NULL) {

        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( cmBatt->LowerDeviceObject, Irp );

    } else {

        Irp->IoStatus.Status = status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}

NTSTATUS
CmBattWaitWakeLoop(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called after the WAIT_WAKE has been completed

Arguments:

    DeviceObject    - The PDO
    MinorFunction   - IRP_MN_WAIT_WAKE
    PowerState      - The Sleep state that it could wake from
    Context         - NOT USED
    IoStatus        - The status of the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    PCM_BATT  cmBatt = (PCM_BATT) DeviceObject->DeviceExtension;

    CmBattPrint (CMBATT_PNP, ("CmBattWaitWakeLoop: Entered.\n"));
    if (!NT_SUCCESS(IoStatus->Status) || !cmBatt->WakeEnabled) {

        CmBattPrint (CMBATT_ERROR, ("CmBattWaitWakeLoop: failed: status = 0x%08x.\n", IoStatus->Status));
        cmBatt->WaitWakeIrp = NULL;
        return IoStatus->Status;

    } else {
        CmBattPrint (CMBATT_NOTE, ("CmBattWaitWakeLoop: completed successfully\n"));
    }

    //
    // In this case, we just cause the same thing to happen again
    //
    status = PoRequestPowerIrp(
        DeviceObject,
        MinorFunction,
        PowerState,
        CmBattWaitWakeLoop,
        Context,
        &(cmBatt->WaitWakeIrp)
        );

    CmBattPrint (CMBATT_NOTE, ("CmBattWaitWakeLoop: PoRequestPowerIrp: status = 0x%08x.\n", status));

    //
    // Done
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\cmbatt\cmbwmi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CmbWmi.c

Abstract:

    Wmi section for Control Method Battery Miniport Driver

Author:

    Michael Hills

Environment:

    Kernel mode

Revision History:

--*/

#include "CmBattp.h"
#include <initguid.h>
#include <wdmguid.h>
#include <wmistr.h>
#include <wmilib.h>

NTSTATUS
CmBattSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
CmBattSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
CmBattQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
CmBattQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

#if DEBUG
PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
);
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmBattWmiRegistration)
#pragma alloc_text(PAGE,CmBattWmiDeRegistration)
#pragma alloc_text(PAGE,CmBattSystemControl)
#pragma alloc_text(PAGE,CmBattSetWmiDataItem)
#pragma alloc_text(PAGE,CmBattSetWmiDataBlock)
#pragma alloc_text(PAGE,CmBattQueryWmiDataBlock)
#pragma alloc_text(PAGE,CmBattQueryWmiRegInfo)
#endif


//
// WMI info
//

#define MOFRESOURCENAME L"BATTWMI"

typedef struct _MSPower_DeviceWakeEnable
{
    //
    BOOLEAN Enable;
    #define MSPower_DeviceWakeEnable_Enable_SIZE sizeof(BOOLEAN)
    #define MSPower_DeviceWakeEnable_Enable_ID 1

} MSPower_DeviceWakeEnable, *PMSPower_DeviceWakeEnable;


WMIGUIDREGINFO CmBattWmiGuidList[1] =
{
    {
        &GUID_POWER_DEVICE_WAKE_ENABLE, 1, 0
    }
};


NTSTATUS
CmBattSystemControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine passes the request down the stack

Arguments:

    DeviceObject    - The target
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status = STATUS_NOT_SUPPORTED;
    PCM_BATT        CmBatt;
    PIO_STACK_LOCATION      stack;
    SYSCTL_IRP_DISPOSITION  disposition = IrpForward;

    PAGED_CODE();

    stack = IoGetCurrentIrpStackLocation (Irp);

    CmBattPrint((CMBATT_TRACE), ("CmBatt: SystemControl: %s\n",
                WMIMinorFunctionString(stack->MinorFunction)));

    CmBatt = (PCM_BATT) DeviceObject->DeviceExtension;

    //
    // Aquire remove lock
    //

    InterlockedIncrement (&CmBatt->InUseCount);
    if (CmBatt->WantToRemove == TRUE) {
        if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
            KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
        }
        status = STATUS_DEVICE_REMOVED;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    if (CmBatt->Type == CM_BATTERY_TYPE) {
        status = BatteryClassSystemControl(CmBatt->Class,
                                           &CmBatt->WmiLibContext,
                                           DeviceObject,
                                           Irp,
                                           &disposition);
    } else {
        status = WmiSystemControl(&CmBatt->WmiLibContext,
                                  DeviceObject,
                                  Irp,
                                  &disposition);

    }

    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            CmBattPrint((CMBATT_TRACE), ("CmBatt: SystemControl: Irp Processed\n"));

            break;
        }

        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            CmBattPrint((CMBATT_TRACE), ("CmBatt: SystemControl: Irp Not Completed.\n"));
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targeted
            // at a device lower in the stack.
            CmBattPrint((CMBATT_TRACE), ("CmBatt: SystemControl: Irp Forward.\n"));
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (CmBatt->LowerDeviceObject, Irp);
            break;
        }

        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (CmBatt->LowerDeviceObject, Irp);
            break;
        }
    }

    //
    // Release Removal Lock
    //
    if (0 == InterlockedDecrement(&CmBatt->InUseCount)) {
        KeSetEvent (&CmBatt->ReadyToRemove, IO_NO_INCREMENT, FALSE);
    }

    return status;
}


NTSTATUS
CmBattWmiRegistration(
    PCM_BATT CmBatt
)
/*++
Routine Description

    Registers with WMI as a data provider for this
    instance of the device

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    CmBatt->WmiLibContext.GuidCount = sizeof (CmBattWmiGuidList) /
                                 sizeof (WMIGUIDREGINFO);
    ASSERT (1 == CmBatt->WmiLibContext.GuidCount);
    CmBatt->WmiLibContext.GuidList = CmBattWmiGuidList;
    CmBatt->WmiLibContext.QueryWmiRegInfo = CmBattQueryWmiRegInfo;
    CmBatt->WmiLibContext.QueryWmiDataBlock = CmBattQueryWmiDataBlock;
    CmBatt->WmiLibContext.SetWmiDataBlock = CmBattSetWmiDataBlock;
    CmBatt->WmiLibContext.SetWmiDataItem = CmBattSetWmiDataItem;
    CmBatt->WmiLibContext.ExecuteWmiMethod = NULL;
    CmBatt->WmiLibContext.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //

    status = IoWMIRegistrationControl(CmBatt->Fdo,
                             WMIREG_ACTION_REGISTER
                             );

    return status;

}

NTSTATUS
CmBattWmiDeRegistration(
    PCM_BATT CmBatt
)
/*++
Routine Description

     Inform WMI to remove this DeviceObject from its
     list of providers. This function also
     decrements the reference count of the deviceobject.

--*/
{

    PAGED_CODE();

    return IoWMIRegistrationControl(CmBatt->Fdo,
                                 WMIREG_ACTION_DEREGISTER
                                 );

}

//
// WMI System Call back functions
//

NTSTATUS
CmBattSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PCM_BATT        CmBatt = (PCM_BATT) DeviceObject->DeviceExtension;
    NTSTATUS        status;
    HANDLE          devInstRegKey;
    UNICODE_STRING  valueName;
    ULONG           tmp;


    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE), ("Entered CmBattSetWmiDataItem\n"));

    switch(GuidIndex) {

    case 0:
        if(DataItemId == 0) {
            if (CmBatt->WakeEnabled != *((PBOOLEAN)Buffer)) {
                CmBatt->WakeEnabled = *((PBOOLEAN)Buffer);

                //
                // Save setting in registry
                //

                if ((NT_SUCCESS(IoOpenDeviceRegistryKey (CmBatt->Pdo,
                                                         PLUGPLAY_REGKEY_DEVICE,
                                                         STANDARD_RIGHTS_ALL,
                                                         &devInstRegKey)))) {
                    RtlInitUnicodeString (&valueName, WaitWakeEnableKey);
                    tmp = (ULONG) CmBatt->WakeEnabled;

                    ZwSetValueKey (devInstRegKey,
                                   &valueName,
                                   0,
                                   REG_DWORD,
                                   &tmp,
                                   sizeof(tmp));

                    ZwClose (devInstRegKey);
                }

                if (CmBatt->WakeEnabled) {
                    if (CmBatt->WakeSupportedState.SystemState == PowerSystemUnspecified) {
                        CmBatt->WakeEnabled = FALSE;
                        status = STATUS_UNSUCCESSFUL;
                    } else if (!CmBatt->WaitWakeIrp) {
                        status = PoRequestPowerIrp(
                            CmBatt->DeviceObject,
                            IRP_MN_WAIT_WAKE,
                            CmBatt->WakeSupportedState,
                            CmBattWaitWakeLoop,
                            NULL,
                            &(CmBatt->WaitWakeIrp)
                            );

                        CmBattPrint (CMBATT_PNP, ("CmBattSetWmiDataItem: wait/Wake irp sent.\n"));
                    }

                } else {
                    if (CmBatt->WaitWakeIrp) {
                        status = IoCancelIrp(CmBatt->WaitWakeIrp);
                        CmBattPrint (CMBATT_PNP, ("CmBattSetWmiDataItem: Canceled wait/Wake irp.\n"));
                    }
                }
            }
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_READ_ONLY;
        }
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT);

    return status;
}

NTSTATUS
CmBattSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PCM_BATT        CmBatt = (PCM_BATT) DeviceObject->DeviceExtension;
    NTSTATUS        status;
    HANDLE          devInstRegKey;
    UNICODE_STRING  valueName;
    ULONG           tmp;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE), ("Entered CmBattSetWmiDataBlock\n"));

    switch(GuidIndex) {
    case 0:

        //
        // We will update only writable elements.
        //

        if (CmBatt->WakeEnabled != *((PBOOLEAN)Buffer)) {
            CmBatt->WakeEnabled = *((PBOOLEAN)Buffer);

            //
            // Save setting in registry
            //

            if ((NT_SUCCESS(IoOpenDeviceRegistryKey (CmBatt->Pdo,
                                                     PLUGPLAY_REGKEY_DEVICE,
                                                     STANDARD_RIGHTS_ALL,
                                                     &devInstRegKey)))) {
                RtlInitUnicodeString (&valueName, WaitWakeEnableKey);
                tmp = (ULONG) CmBatt->WakeEnabled;

                ZwSetValueKey (devInstRegKey,
                               &valueName,
                               0,
                               REG_DWORD,
                               &tmp,
                               sizeof(tmp));

                ZwClose (devInstRegKey);
            }

            if (CmBatt->WakeEnabled) {
                if (CmBatt->WakeSupportedState.SystemState == PowerSystemUnspecified) {
                    CmBatt->WakeEnabled = FALSE;
                    status = STATUS_UNSUCCESSFUL;
                } else if (!CmBatt->WaitWakeIrp) {
                    status = PoRequestPowerIrp(
                        CmBatt->DeviceObject,
                        IRP_MN_WAIT_WAKE,
                        CmBatt->WakeSupportedState,
                        CmBattWaitWakeLoop,
                        NULL,
                        &(CmBatt->WaitWakeIrp)
                        );

                    CmBattPrint (CMBATT_PNP, ("CmBattSetWmiDataItem: wait/Wake irp sent.\n"));
                }

            } else {
                if (CmBatt->WaitWakeIrp) {
                    status = IoCancelIrp(CmBatt->WaitWakeIrp);
                    CmBattPrint (CMBATT_PNP, ("CmBattSetWmiDataItem: Canceled wait/Wake irp.\n"));
                }
            }
        }
        status = STATUS_SUCCESS;

        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
CmBattQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instances expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PCM_BATT    CmBatt = (PCM_BATT) DeviceObject->DeviceExtension;
    NTSTATUS    status;
    ULONG       size = 0;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE), ("Entered CmBattQueryWmiDataBlock\n"));

    //
    // Only ever registers 1 instance per guid
    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));

    if (CmBatt->Type == CM_BATTERY_TYPE) {
        status = BatteryClassQueryWmiDataBlock(
            CmBatt->Class,
            DeviceObject,
            Irp,
            GuidIndex,
            InstanceLengthArray,
            OutBufferSize,
            Buffer);

        if (status != STATUS_WMI_GUID_NOT_FOUND) {
            CmBattPrint ((CMBATT_TRACE), ("CmBattQueryWmiDataBlock: Handled by Battery Class.\n"));
            return status;
        }
    }

    CmBattPrint ((CMBATT_TRACE), ("CmBattQueryWmiDataBlock: Handling.\n"));

    switch (GuidIndex) {
    case 0:

        if (CmBatt->WakeSupportedState.SystemState != PowerSystemUnspecified) {
            size = sizeof (BOOLEAN);
            if (OutBufferSize < size ) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            (BOOLEAN) (* Buffer) = CmBatt->WakeEnabled;
            *InstanceLengthArray = size;
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  size,
                                  IO_NO_INCREMENT);

    return status;
}

NTSTATUS
CmBattQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in
        *RegFlags.

Return Value:

    status

--*/
{
    PCM_BATT CmBatt = DeviceObject->DeviceExtension;

    PAGED_CODE();

    CmBattPrint ((CMBATT_TRACE), ("CmBatt: Entered CmBattQueryWmiRegInfo\n"));


    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &GlobalRegistryPath;
    *Pdo = CmBatt->Pdo;
//    RtlInitUnicodeString(MofResourceName, MOFRESOURCENAME);

    return STATUS_SUCCESS;
}

#if DEBUG

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_CHANGE_SINGLE_INSTANCE:
            return "IRP_MN_CHANGE_SINGLE_INSTANCE";
        case IRP_MN_CHANGE_SINGLE_ITEM:
            return "IRP_MN_CHANGE_SINGLE_ITEM";
        case IRP_MN_DISABLE_COLLECTION:
            return "IRP_MN_DISABLE_COLLECTION";
        case IRP_MN_DISABLE_EVENTS:
            return "IRP_MN_DISABLE_EVENTS";
        case IRP_MN_ENABLE_COLLECTION:
            return "IRP_MN_ENABLE_COLLECTION";
        case IRP_MN_ENABLE_EVENTS:
            return "IRP_MN_ENABLE_EVENTS";
        case IRP_MN_EXECUTE_METHOD:
            return "IRP_MN_EXECUTE_METHOD";
        case IRP_MN_QUERY_ALL_DATA:
            return "IRP_MN_QUERY_ALL_DATA";
        case IRP_MN_QUERY_SINGLE_INSTANCE:
            return "IRP_MN_QUERY_SINGLE_INSTANCE";
        case IRP_MN_REGINFO:
            return "IRP_MN_REGINFO";
        default:
            return "IRP_MN_?????";
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\cmbatt\cmhndlr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cmhndlr.c

Abstract:

    Control Method Battery handlers

Author:

    Bob Moore

Environment:

    Kernel mode

Revision History:

--*/

#include "CmBattp.h"


VOID
CmBattPowerCallBack(
    IN  PVOID   CallBackContext,
    IN  PVOID   Argument1,
    IN  PVOID   Argument2
    )
/*++

Routine Description:

    This routine is called when the system changes power states

Arguments:

    CallBackContext - The device extension for the root device
    Argument1

--*/
{

    PDRIVER_OBJECT  CmBattDriver = (PDRIVER_OBJECT) CallBackContext;
    ULONG           action = PtrToUlong( Argument1 );
    ULONG           value  = PtrToUlong( Argument2 );
    BOOLEAN         timerCanceled;
    PDEVICE_OBJECT  CmBattDevice;
    PCM_BATT        CmBatt;

    CmBattPrint (CMBATT_POWER, ("CmBattPowerCallBack: action: %d, value: %d \n", action, value));

    //
    // We are looking for a PO_CB_SYSTEM_STATE_LOCK
    //
    if (action != PO_CB_SYSTEM_STATE_LOCK) {
        return;
    }

    switch (value) {
    case 0:
        CmBattPrint (CMBATT_POWER, ("CmBattPowerCallBack: Delaying Notifications\n"));
        //
        // Get the head of the DeviceObject list
        //

        CmBattDevice = CmBattDriver->DeviceObject;

        while (CmBattDevice) {
            CmBatt = CmBattDevice->DeviceExtension;

            //
            // Cause all notifications to be delayed.
            //
            CmBatt->Sleeping = TRUE;

            CmBattDevice = CmBattDevice->NextDevice;

        }
        break;

    case 1:
        CmBattPrint (CMBATT_POWER, ("CmBattPowerCallBack: Calling CmBattWakeDpc after 10 seconds.\n"));
        timerCanceled = KeSetTimer (&CmBattWakeDpcTimerObject,
                    CmBattWakeDpcDelay,
                    &CmBattWakeDpcObject);
        CmBattPrint (CMBATT_POWER, ("CmBattPowerCallBack: timerCanceled = %d.\n", timerCanceled));
        break;

    default:
        CmBattPrint (CMBATT_POWER, ("CmBattPowerCallBack: unknown argument2 = %08x\n", value));


    }

}

VOID
CmBattWakeDpc (
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )
/*++

Routine Description:

    This routine is called X seconds after the system wakes to proces
    all delayed battery notifications.

Arguments:

    CmBattDriver - Driver object

Return Value:

    None

--*/

{
    PDRIVER_OBJECT  CmBattDriver = (PDRIVER_OBJECT) DeferredContext;
    BOOLEAN         notifyAll = FALSE;
    PDEVICE_OBJECT  CmBattDevice;
    PCM_BATT        CmBatt;

    CmBattPrint (CMBATT_TRACE, ("CmBattWakeDpc: Entered.\n"));
    //
    // Get the head of the DeviceObject list
    //

    CmBattDevice = CmBattDriver->DeviceObject;

    while (CmBattDevice) {
        CmBatt = CmBattDevice->DeviceExtension;

        //
        // We will now process all delayed notifications.
        // For effeiciency, we must go through the devices twice:
        // first to see if any AC devices have been notified, and
        // then to send notifications to all battery devices if necessary.
        //
        CmBatt->Sleeping = FALSE;

        if ((CmBatt->Type == AC_ADAPTER_TYPE) &&
            (CmBatt->ActionRequired & CMBATT_AR_NOTIFY)) {

            //
            // If any AC adapter devices have notified,
            // then we need to notify all battery devices
            //
            CmBattPrint (CMBATT_PNP, ("CmBattWakeDpc: AC adapter notified\n"));
            notifyAll = TRUE;
            CmBatt->ActionRequired = CMBATT_AR_NO_ACTION;
        }

        CmBattDevice = CmBattDevice->NextDevice;

    }

    //
    // Get the head of the DeviceObject list
    //

    CmBattDevice = CmBattDriver->DeviceObject;

    // Walk the list
    while (CmBattDevice) {
        CmBatt = CmBattDevice->DeviceExtension;

        if (CmBatt->Type == CM_BATTERY_TYPE) {
            CmBattPrint (CMBATT_PNP, ("CmBattWakeDpc: Performing delayed ARs: %01x\n", CmBatt->ActionRequired));

            if (CmBatt->ActionRequired & CMBATT_AR_INVALIDATE_CACHE) {
                InterlockedExchange (&CmBatt->CacheState, 0);
            }
            if (CmBatt->ActionRequired & CMBATT_AR_INVALIDATE_TAG) {
                CmBatt->Info.Tag = BATTERY_TAG_INVALID;
            }
            if ((CmBatt->ActionRequired & CMBATT_AR_NOTIFY) || notifyAll) {
                BatteryClassStatusNotify (CmBatt->Class);
            }
        }

        CmBattDevice = CmBattDevice->NextDevice;

    }


}

VOID
CmBattNotifyHandler (
    IN PVOID            Context,
    IN ULONG            NotifyValue
    )
/*++

Routine Description:

    This routine fields battery device notifications from the ACPI driver.

Arguments:


Return Value:

    None

--*/
{
    PCM_BATT            CmBatt = Context;
    PDRIVER_OBJECT      CmBatteryDriver;
    PDEVICE_OBJECT      CmBatteryDevice;
    PCM_BATT            CmBatteryExtension;

    CmBattPrint ((CMBATT_PNP | CMBATT_BIOS), ("CmBattNotifyHandler: CmBatt 0x%08x Type %d Number %d Notify Value: %x\n",
                                CmBatt, CmBatt->Type, CmBatt->DeviceNumber, NotifyValue));

    switch (NotifyValue) {

        case BATTERY_DEVICE_CHECK:
            //
            // A new battery was inserted in the system.
            //

            CmBatt->ActionRequired |= CMBATT_AR_NOTIFY;
            CmBatt->ActionRequired |= CMBATT_AR_INVALIDATE_CACHE;

            //
            // This notification is only received when a battery is inserted.
            // It also occurs after restart from hibernation on some machines.
            // Invalidate battery tag.
            //

            if (CmBatt->Info.Tag != BATTERY_TAG_INVALID) {
                CmBattPrint ((CMBATT_ERROR),
                   ("CmBattNotifyHandler: Received battery #%x insertion, but tag was not invalid.\n",
                    CmBatt->DeviceNumber));
            }

            break;


        case BATTERY_EJECT:
            //
            // A battery was removed from the system
            //

            CmBatt->ActionRequired |= CMBATT_AR_NOTIFY;

            //
            // Invalidate the battery tag and all cached informaion
            // whenever this message is received.
            //
            CmBatt->ActionRequired |= CMBATT_AR_INVALIDATE_CACHE;
            CmBatt->ActionRequired |= CMBATT_AR_INVALIDATE_TAG;

            break;

        case BATTERY_STATUS_CHANGE:                 // Status change only
            CmBatt->ActionRequired |= CMBATT_AR_NOTIFY;

            break;

        case BATTERY_INFO_CHANGE:                   // Info & status change
            CmBatt->ActionRequired |= CMBATT_AR_NOTIFY;
            CmBatt->ActionRequired |= CMBATT_AR_INVALIDATE_CACHE;
            CmBatt->ActionRequired |= CMBATT_AR_INVALIDATE_TAG;
            break;

        default:

            CmBattPrint (CMBATT_PNP, ("CmBattNotifyHandler: Unknown Notify Value: %x\n", NotifyValue));
            break;

    }

    if (CmBatt->Sleeping) {
        CmBattPrint (CMBATT_PNP, ("CmBattNotifyHandler: Notification delayed: ARs = %01x\n", CmBatt->ActionRequired));
    } else {
        CmBattPrint (CMBATT_PNP, ("CmBattNotifyHandler: Performing ARs: %01x\n", CmBatt->ActionRequired));
        if (CmBatt->Type == CM_BATTERY_TYPE) {
            
            //
            // Invalidate last trip point set on battery.
            //
            CmBatt->Alarm.Setting = CM_ALARM_INVALID;
            
            if (CmBatt->ActionRequired & CMBATT_AR_INVALIDATE_CACHE) {
                InterlockedExchange (&CmBatt->CacheState, 0);
            }
            if (CmBatt->ActionRequired & CMBATT_AR_INVALIDATE_TAG) {
                CmBatt->Info.Tag = BATTERY_TAG_INVALID;
            }
            if (CmBatt->ActionRequired & CMBATT_AR_NOTIFY) {
                CmBatt->ReCheckSta = TRUE;
                BatteryClassStatusNotify (CmBatt->Class);                
            }

        } else if ((CmBatt->Type == AC_ADAPTER_TYPE) &&
                    (CmBatt->ActionRequired & CMBATT_AR_NOTIFY)) {

            //
            // Get the Driver Object
            //

            CmBatteryDriver = CmBatt->Fdo->DriverObject;

            //
            // Get the head of the DeviceObject list
            //

            CmBatteryDevice = CmBatteryDriver->DeviceObject;

            //
            // Walk the DeviceObject list to notify the class driver on all batteries
            //
            while (CmBatteryDevice) {

                CmBatteryExtension = CmBatteryDevice->DeviceExtension;

                if (CmBatteryExtension->Type == CM_BATTERY_TYPE) {
                    CmBatteryExtension->ReCheckSta = TRUE;
                    BatteryClassStatusNotify (CmBatteryExtension->Class);
                }

                CmBatteryDevice = CmBatteryDevice->NextDevice;
            }
        }

        CmBatt->ActionRequired = CMBATT_AR_NO_ACTION;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\cmbatt\cmbtest\cmbtest.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

Abstract:

Author:

   Ken Reneris

Environment:

   console

--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>
#include <ntpoapi.h>

#include "..\cmbdrect.h"

//
// Prototypes
//

HANDLE InitDriver ( CHAR *NamePtr );



void Call_UID (HANDLE Driver) {
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    UINT                Data;
        

    Status = NtDeviceIoControlFile(
                    Driver,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_CMBATT_UID,
                    (PVOID) NULL,           // input buffer
                    0,
                    &Data,                 // output buffer
                    sizeof (Data)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("_UID Method failed.  Status = 0x%08lx\n", Status);
    } else {
        printf("_UID returned: 0x%08lx\n", Data);
    };

}


void Call_STA (HANDLE Driver) {
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    ULONG                       Data;
        

    Status = NtDeviceIoControlFile(
                    Driver,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_CMBATT_STA,
                    (PVOID) NULL,           // input buffer
                    0,
                    &Data,                 // output buffer
                    sizeof (Data)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("_STA Method failed.  Status = 0x%08lx\n", Status);
    } else {
        printf("_STA returned: 0x%08lx\n", Data);
    };

}


void Call_PSR (HANDLE Driver) {
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    ULONG                       Data;
        

    Status = NtDeviceIoControlFile(
                    Driver,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_CMBATT_PSR,
                    (PVOID) NULL,           // input buffer
                    0,
                    &Data,                 // output buffer
                    sizeof (Data)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("_PSR Method failed.  Status = 0x%08lx\n", Status);
    } else {
        printf("_PSR returned: 0x%08lx\n", Data);
    };

}


void Call_BTP (HANDLE Driver) {
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    ULONG                       Data;
        

    printf ("Enter the Trip Point value (Hex): ");
    scanf ("%x", &Data);
    Status = NtDeviceIoControlFile(
                    Driver,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_CMBATT_BTP,
                    &Data,                  // input buffer
                    sizeof (Data),
                    (PVOID) NULL,           // output buffer
                    0
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("\n_BTP Method failed.  Status = 0x%08lx\n", Status);
        printf("\nSet trip point to 0x%08lx failed.\n", Data);
    } else {
        printf("\nTrip point set to 0x%08lx\n", Data);
    };

}


void Call_BIF (HANDLE Driver) {
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    CM_BIF_BAT_INFO             Data;
        

    Status = NtDeviceIoControlFile(
                    Driver,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_CMBATT_BIF,
                    (PVOID) NULL,           // input buffer
                    0,
                    &Data,                 // output buffer
                    sizeof (Data)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("_BIF Metod failed.  Status = 0x%08lx\n", Status);
    } else {
        printf("_BIF returned:\n");
        printf("  Power Unit = 0x%08lx\n", Data.PowerUnit);
        printf("  Design Capacity = 0x%08lx\n", Data.DesignCapacity);
        printf("  Last Full Charge Capacity = 0x%08lx\n", Data.LastFullChargeCapacity);
        printf("  Battery Technology = 0x%08lx\n", Data.BatteryTechnology);
        printf("  Design Voltage = 0x%08lx\n", Data.DesignVoltage);
        printf("  Design Capacity Of Warning = 0x%08lx\n", Data.DesignCapacityOfWarning);
        printf("  Design Capacity Of Low = 0x%08lx\n", Data.DesignCapacityOfLow);
        printf("  Battery Capacity Granularity 1 (low -> warning) = 0x%08lx\n", Data.BatteryCapacityGran_1);
        printf("  Battery Capacity Granularity 2 (warning -> full) = 0x%08lx\n", Data.BatteryCapacityGran_2);
        printf("  Model number = \"%s\"\n", Data.ModelNumber);
        printf("  Serial number = \"%s\"\n", Data.SerialNumber);
        printf("  Battery Type = \"%s\"\n", Data.BatteryType);
        printf("  OEM Information = \"%s\"\n", Data.OEMInformation);
    };

}


void Call_BST (HANDLE Driver) {
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    CM_BST_BAT_INFO             Data;
        

    Status = NtDeviceIoControlFile(
                    Driver,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_CMBATT_BST,
                    (PVOID) NULL,           // input buffer
                    0,
                    &Data,                 // output buffer
                    sizeof (Data)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("_BST Metod failed.  Status = 0x%08lx\n", Status);
    } else {
        printf("_BST returned:\n");
        printf("  Battery Status = 0x%08lx\n", Data.BatteryState);
        printf("  Present Rate = 0x%08lx\n", Data.PresentRate);
        printf("  Remaining Capacity = 0x%08lx\n", Data.RemainingCapacity);
        printf("  Present Voltage = 0x%08lx\n", Data.PresentVoltage);
    };

}


int
__cdecl
main(USHORT argc, CHAR **argv)
{
    CHAR *NamePtr;
    ULONG cmd;
    HANDLE DriverHandle;

    if (argc > 1) {
        NamePtr=argv[1];
    } else {
        NamePtr = "ControlMethodBattery1";
    }

    //
    // Locate driver
    //

    if (!(DriverHandle = InitDriver (NamePtr))) {
        printf ("CmBatt not found\n");
        exit (1);
    }


    while (1) {
        printf("\n\nOptions: (1)_UID  (2)_STA  (3)_PSR  (4)_BTP  (5)_BIF  (6)_BST\n");
        printf(    ">>>>>>>> ");
        if (scanf ("%d", &cmd) != 1) {
            return (0);
            printf("\n\n");
        };
        printf("\n");
        switch (cmd) {
        case 1 :
            Call_UID (DriverHandle);
            break;
        case 2 :
            Call_STA (DriverHandle);
            break;
        case 3 :
            Call_PSR (DriverHandle);
            break;
        case 4 :
            Call_BTP (DriverHandle);
            break;
        case 5 :
            Call_BIF (DriverHandle);
            break;
        case 6 :
            Call_BST (DriverHandle);
            break;
        }
    }


}



HANDLE
InitDriver (
    CHAR *NamePtr
)
{
    UNICODE_STRING              DriverName;
    ANSI_STRING                 AnsiName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    UCHAR                       strbuf[100];
    HANDLE DriverHandle;

    SYSTEM_POWER_CAPABILITIES   powerCapabilities;

    if (NT_SUCCESS (NtPowerInformation (SystemPowerCapabilities, 
                                        NULL, 
                                        0, 
                                        &powerCapabilities, 
                                        sizeof (SYSTEM_POWER_CAPABILITIES)
                                        ))) {
        printf("NtPowerInformation returned: \n"
               "  SystemBatteriesPresent = %d\n"
               "  BatteriesAreShortTerm = %d\n",
               powerCapabilities.SystemBatteriesPresent,
               powerCapabilities.BatteriesAreShortTerm);
    }


    
    sprintf (strbuf, "\\Device\\%s",NamePtr);

    RtlInitAnsiString(&AnsiName, strbuf);

    RtlAnsiStringToUnicodeString(&DriverName, &AnsiName, TRUE);

    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,     // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if (!NT_SUCCESS(status)) {
        printf ("Device name %s Error 0x%08lx\n", strbuf, status);
        return NULL;
    } else {
        printf ("Opened Device name %s\n", strbuf);
        return DriverHandle;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\acpisym\acpisym.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    acpisym.c

--*/

#include <ntos.h>
#include <pci.h>
#include <dockintf.h>
#include <wmistr.h>
#include <wmiguid.h>
#include <wmilib.h>
#include <ntacpi.h>
#include <arbiter.h>
#include "acpitabl.h"
#include "amli.h"
#include "aml.h"
#include "amlipriv.h"
#include "ctxt.h"
#include "amldebug.h"
#include "acpios.h"
#include "ospower.h"
#include "callback.h"
#include "acpi.h"
#include "acpidbg.h"
#include "acpiregs.h"
#include "devioctl.h"
#include "acpipriv.h"
#include "acpiioct.h"
#include "acpictl.h"
#include "acpienbl.h"
#include "acpigpio.h"
#include "acpiinit.h"
#include "acpiio.h"
#include "acpilock.h"
#include "acpintfy.h"
#include "acpioprg.h"
#include "acpiterm.h"
#include "acpiirp.h"
#include "acpilog.h"
#include "acpiosnt.h"
#include "..\nt\irqarb.h"

DESCRIPTION_HEADER                  descriptionheader;
FADT                                fadt;
RSDP                                rsdp;
FACS                                facs;
RSDT                                rsdt;
ACPIInformation                     acpiinformation;
RSDTELEMENT                         rsdtelem;
OBJDATA                             objdata;
PACKAGEOBJ                          packageobj;
FIELDUNITOBJ                        fieldunitobj;
METHODOBJ                           methodobj;
POWERRESOBJ                         powerresobj;
PROCESSOROBJ                        processorobj;
BUFFFIELDOBJ                        bufferfieldobj;
NSOBJ                               nsobj;
OPREGIONOBJ                         opregionobj;
DEVICE_EXTENSION                    deviceextension;
RSDTINFORMATION                     rsdtinformation;
ULONG                               ulong;
VECTOR_BLOCK                        vectorblock;
ARBITER_EXTENSION                   arbiterextension;
LINK_NODE                           linknode;
LINK_NODE_ATTACHED_DEVICES          linknodeattacheddevices;
PROCLOCALAPIC                       proclocalapic;
DBGR                                dbgr;
LIST                                list;
CTXTQ								ctxtq;
ULONG								gdwfAMLIInit;
BRKPT								brkpt;
CALL								call;
RESOURCE							resource;
HEAP								heap;
HEAPOBJHDR							heapobjhdr;

int cdecl main() {
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\compbatt\comppnp.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Comppnp.c

Abstract:

    Composite Battery PnP and power functions

Author:

    Scott Brenden

Environment:

Notes:


Revision History:

--*/

#include "compbatt.h"

#include <initguid.h>
#include <wdmguid.h>
#include <batclass.h>




NTSTATUS
CompBattPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    IOCTL handler for the plug and play irps.

Arguments:

    DeviceObject    - Battery for request

    Irp             - IO request

Return Value:

    Status of request

--*/
{
    PIO_STACK_LOCATION      irpStack        = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status          = STATUS_NOT_SUPPORTED;
    PCOMPOSITE_BATTERY      compBatt        = (PCOMPOSITE_BATTERY)DeviceObject->DeviceExtension;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING PnpDispatch\n"));

    switch (irpStack->MinorFunction) {

        case IRP_MN_START_DEVICE: {
            //
            // Register for Pnp notification of batteries coming and going
            //

            status = IoRegisterPlugPlayNotification(
                            EventCategoryDeviceInterfaceChange,
                            0,
                            (LPGUID)&GUID_DEVICE_BATTERY,
                            DeviceObject->DriverObject,
                            CompBattPnpEventHandler,
                            compBatt,
                            &compBatt->NotificationEntry
                            );

            if (!NT_SUCCESS(status)) {
                BattPrint (BATT_ERROR, ("CompBatt: Couldn't register for PnP notification - %x\n", status));

            } else {
                BattPrint (BATT_NOTE, ("CompBatt: Successfully registered for PnP notification\n"));

                //
                // Get the batteries that are already present in the system
                //

                status = CompBattGetBatteries (compBatt);
            }

            break;
        }

        case IRP_MN_QUERY_PNP_DEVICE_STATE: {
            //
            // Prevent device from being manually uninstalled.
            //
            Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
            status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_REMOVE_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_STOP_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE: {
		    status = STATUS_INVALID_DEVICE_REQUEST;
    		break;
        }

        case IRP_MN_CANCEL_REMOVE_DEVICE:
        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_SURPRISE_REMOVAL: {
    		status = STATUS_SUCCESS;
	    	break;
        }
    }

    //
    // Rules for handling PnP IRPs:
    // 1) Don't change the status of any IRP we don't handle. We identify
    //    IRPs we don't handle via the code STATUS_NOT_SUPPORTED. This is
    //    the same code all PNP irps start out with, and as we are not allowed
    //    to fail IRPs with that code, it is the perfect choice to use this
    //    way.
    // 2) Pass down all IRPs that we succeed or do not touch. Immediately
    //    complete any failures (excepting STATUS_NOT_SUPPORTED of course).
    //
    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;
    }

    if (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) {

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver(compBatt->LowerDevice, Irp) ;

    } else {

        status = Irp->IoStatus.Status ;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING PnpDispatch\n"));

    return status;
}





NTSTATUS
CompBattPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    IOCTL handler for the power irps.

Arguments:

    DeviceObject    - Battery for request

    Irp             - IO request

Return Value:

    Status of request

--*/
{
    PCOMPOSITE_BATTERY compBatt = (PCOMPOSITE_BATTERY)DeviceObject->DeviceExtension;

    BattPrint (BATT_TRACE, ("CompBatt: PowerDispatch recieved power IRP.\n"));

    PoStartNextPowerIrp (Irp);
    IoSkipCurrentIrpStackLocation (Irp);

    return PoCallDriver(compBatt->LowerDevice, Irp) ;
}






NTSTATUS
CompBattPnpEventHandler(
    IN PVOID NotificationStructure,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine handles Plug and Play event notifications.  The only ones that
    have been asked for are device interface changes associated with batteries,
    so we will only receive notifications when batteries come and go (provided
    they register their device interface).

Arguments:

    NotificationStructure   - This will be type PDEVICE_INTERFACE_CHANGE_NOTIFICATION

    Context                 - The composite battery device extension

Return Value:

    STATUS_SUCCESS

--*/
{
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION   changeNotification;
    PCOMPOSITE_BATTERY                      compBatt;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING PnpEventHandler\n"));

    compBatt            = (PCOMPOSITE_BATTERY) Context;
    changeNotification  = (PDEVICE_INTERFACE_CHANGE_NOTIFICATION) NotificationStructure;


    BattPrint(BATT_NOTE, ("CompBatt: Received device interface change notification\n"));

    if (IsEqualGUID(&changeNotification->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {

        BattPrint(BATT_NOTE, ("CompBatt: Received notification of battery arrival\n"));
        CompBattAddNewBattery (changeNotification->SymbolicLinkName, compBatt);

    } else if (IsEqualGUID(&changeNotification->Event, &GUID_DEVICE_INTERFACE_REMOVAL)) {

        BattPrint (BATT_NOTE, ("CompBatt: Received notification of battery removal\n"));

        //
        // Nothing to do here.  MonitorIrpComplete will do cleanup when it's requests fail
        // with STATUS_DEVICE_REMOVED.
        //

    } else {

        BattPrint (BATT_NOTE, ("CompBatt: Received unhandled PnP event\n"));
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING PnpEventHandler\n"));

    return STATUS_SUCCESS;

}

NTSTATUS
CompBattRemoveBattery(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    This routine removes an existing battery from the list of batteries kept by the
    composite battery.

Arguments:

    SymbolicLinkName    - Name used to check if battery is on list
                          and to close the battery if so.

    CompBatt            - Device extension for the composite battery

Return Value:

    NTSTATUS

--*/
{
    PCOMPOSITE_ENTRY        Battery;

    // NonPaged code.  This is called by an Irp completion routine.

    BattPrint (BATT_TRACE, ("CompBatt: RemoveBattery\n"));

    //
    // Remove the battery from the list if it is there.
    //

    Battery = RemoveBatteryFromList (SymbolicLinkName, CompBatt);

    if(!Battery) {

        //
        // removed ok if not on list
        //

        return STATUS_SUCCESS;
    }

    //
    // Deallocate the Work Item.
    //

    ObDereferenceObject(Battery->DeviceObject);

    ExFreePool (Battery);

    // Invalidate cached Battery info and send notification
    CompBatt->Info.Valid = 0;
    BatteryClassStatusNotify (CompBatt->Class);

    return STATUS_SUCCESS;
}


NTSTATUS
CompBattAddNewBattery(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    This routine adds a new battery to the list of batteries kept by the
    composite battery.

Arguments:

    SymbolicLinkName    - Name used to check if battery is already on list
                          and to open the battery if not.

    CompBatt            - Device extension for the composite battery

Return Value:

    NTSTATUS

--*/
{
    PCOMPOSITE_ENTRY        newBattery;
    PUNICODE_STRING         battName;
    PFILE_OBJECT            fileObject;
    PIO_STACK_LOCATION      irpSp;
    PIRP                    newIrp;
    BOOLEAN                 onList;

    NTSTATUS                status = STATUS_SUCCESS;

    PAGED_CODE();

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING AddNewBattery \"%w\" \n", SymbolicLinkName->Buffer));

    //
    // Lock the list and see if this new battery is on it
    //

    onList = IsBatteryAlreadyOnList (SymbolicLinkName, CompBatt);

    if (!onList) {

        //
        // Create the node for the new battery
        //

        newBattery = ExAllocatePoolWithTag(
                            NonPagedPool,
                            sizeof (COMPOSITE_ENTRY) + SymbolicLinkName->Length,
                            'CtaB'
                            );

        if (!newBattery) {
            BattPrint (BATT_ERROR, ("CompBatt: Couldn't allocate new battery node\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto AddNewBatteryClean1;
        }


        //
        // Initialize the new battery
        //

        RtlZeroMemory (newBattery, sizeof (COMPOSITE_ENTRY));

        newBattery->Info.Tag    = BATTERY_TAG_INVALID;
        newBattery->NewBatt     = TRUE;

        battName                = &newBattery->BattName;
        battName->MaximumLength = SymbolicLinkName->Length;
        battName->Buffer        = (PWCHAR)(battName + 1);

        RtlCopyUnicodeString (battName, SymbolicLinkName);


        //
        // Get the device object.
        //

        status = CompBattGetDeviceObjectPointer(SymbolicLinkName,
                                                FILE_ALL_ACCESS,
                                                &fileObject,
                                                &newBattery->DeviceObject
                                                );

        if (!NT_SUCCESS(status)) {
            BattPrint (BATT_ERROR, ("CompBattAddNewBattery: Failed to get device Object. status = %lx\n", status));
            goto AddNewBatteryClean2;
        }

        //
        // Increment the reference count to the device object of the battery
        //

        ObReferenceObject(newBattery->DeviceObject);

        //
        // Decrement reference count to file handle,
        // so batteries will not refuse removal requests.
        //

        ObDereferenceObject(fileObject);

        //
        // Allocate a status Irp for the new battery
        //

        newIrp = IoAllocateIrp ((UCHAR)(newBattery->DeviceObject->StackSize + 1), FALSE);

        if (!newIrp) {
            BattPrint (BATT_ERROR, ("CompBatt: Couldn't allocate new battery Irp\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto AddNewBatteryClean3;
        }

        newBattery->StatusIrp = newIrp;


        //
        // Setup control data on irp
        //

        irpSp = IoGetNextIrpStackLocation(newIrp);
        irpSp->Parameters.Others.Argument1 = (PVOID) CompBatt;
        irpSp->Parameters.Others.Argument2 = (PVOID) newBattery;

        //
        // Fill in irp so irp handler will re-dispatch it
        //

        IoSetNextIrpStackLocation (newIrp);

        irpSp                   = IoGetNextIrpStackLocation(newIrp);
        newIrp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
        newBattery->State       = CB_ST_GET_TAG;

        CompbattInitializeDeleteLock (&newBattery->DeleteLock);

        //
        // Put Battery onthe battery list before starting the
        // MonitorIrpComplete loop.
        //

        ExAcquireFastMutex (&CompBatt->ListMutex);
        InsertTailList (&CompBatt->Batteries, &newBattery->Batteries);
        ExReleaseFastMutex (&CompBatt->ListMutex);

        //
        // Initialize Work Item
        //

         ExInitializeWorkItem (&newBattery->WorkItem, CompBattMonitorIrpCompleteWorker, newBattery);

        //
        // Start Monitoring Battery
        //

        CompBattMonitorIrpComplete (newBattery->DeviceObject, newIrp, NULL);

        status = STATUS_SUCCESS;
    }

    goto AddNewBatteryClean1;

AddNewBatteryClean3:
    ObDereferenceObject(newBattery->DeviceObject);

AddNewBatteryClean2:
    ExFreePool (newBattery);

AddNewBatteryClean1:

    BattPrint (BATT_TRACE, ("CompBatt: EXITING AddNewBattery\n"));

    return status;
}





NTSTATUS
CompBattGetBatteries(
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    This routine uses the PnP manager to get all the batteries that have already
    registered their interfaces (that we won't get notifications for) and then
    adds them to the list of batteries.

Arguments:

    CompBatt        - Device extension for the composite battery

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    UNICODE_STRING      tmpString;
    PWSTR               stringPointer;
    int                 i;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING GetBatteries\n"));

    //
    // Call the PnP manager to get the list of devices already register for the
    // battery class.
    //

    status = IoGetDeviceInterfaces(
                    &GUID_DEVICE_BATTERY,
                    NULL,
                    0,
                    &stringPointer
                    );


    if (!NT_SUCCESS(status)) {
        BattPrint (BATT_ERROR, ("CompBatt: Couldn't get list of batteries\n"));

    } else {
        //
        // Now parse the list and try to add them to the composite battery list
        //

        i = 0;
        RtlInitUnicodeString (&tmpString, &stringPointer[i]);

        while (tmpString.Length) {

            status = CompBattAddNewBattery (&tmpString, CompBatt);
            i += (tmpString.Length / sizeof(WCHAR)) + 1;
            RtlInitUnicodeString (&tmpString, &stringPointer[i]);
        }

        ExFreePool (stringPointer);

    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING GetBatteries\n"));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\acpisym\makefile.inc ===
$(O)\acpi.c : acpisym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\cmbatt\testapp\cmbattst.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

Abstract:

Author:

   Ken Reneris

Environment:

   console

--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>
#include <poclass.h>

//
// global handles
//

UCHAR           Usage[] = "batt: \n";
HANDLE          DriverHandle;
ULONG           BatteryTag;
#define RANGE   1

//
// Prototypes
//

BOOLEAN
InitDriver ( CHAR *NamePtr );


int
Nib (
    UCHAR   c
    )
{
    if (c >= '0' &&  c <= '9') {
        return c - '0';
    }

    if (c >= 'A' &&  c <= 'F') {
        return c - 'A' + 10;
    }

    if (c >= 'a' &&  c <= 'f') {
        return c - 'a' + 10;
    }

    printf ("Invalid hex value\n");
    return 0;
}



int
htoi (
    PUCHAR  s
    )
{
    ULONG   i;
    UCHAR   c;

    i = Nib(s[0]);
    if (s[1]) {
        i = i << 4 | Nib(s[1]);
    }
    return i;
}

VOID
GetBatteryTag (
    VOID
    )
{
    NTSTATUS        Status;
    IO_STATUS_BLOCK IOSB;


    Status = NtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_BATTERY_QUERY_TAG,
                    NULL,                   // input buffer
                    0,
                    &BatteryTag,            // output buffer
                    sizeof (BatteryTag)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("Battery tag not available. Status = %x\n", Status);
        BatteryTag = 0xffffffff;
    }
}


VOID
GetBatteryInfo (
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    BATTERY_QUERY_INFORMATION   BInfo;

    memset (Buffer, 0, BufferLength);
    BInfo.BatteryTag = BatteryTag;
    BInfo.InformationLevel = Level;

    Status = NtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_BATTERY_QUERY_INFORMATION,
                    &BInfo,                 // input buffer
                    sizeof (BInfo),
                    Buffer,                 // output buffer
                    BufferLength
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("Query battery information failed. Level %x. Status = %x\n", Level, Status);
    }
}

VOID
GetBatteryStatus (
    IN  PBATTERY_WAIT_STATUS    WaitStatus,
    OUT PBATTERY_STATUS         BatteryStatus
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;

    memset (BatteryStatus, 0xAB, sizeof(BatteryStatus));

    Status = NtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    IOCTL_BATTERY_QUERY_STATUS,
                    WaitStatus,            // input buffer
                    sizeof (BATTERY_WAIT_STATUS),
                    BatteryStatus,         // output buffer
                    sizeof (BATTERY_STATUS)
                    );


    if (!NT_SUCCESS(Status)) {
        printf ("Query battery status failed. Status = %x\n", Status);
        return ;
    }

    // dump battery status

    printf ("Power State.........: %08x\n",      BatteryStatus->PowerState);
    printf ("Capacity............: %08x  %d\n",  BatteryStatus->Capacity, BatteryStatus->Capacity);
    printf ("Voltage.............: %08x  %d\n",  BatteryStatus->Voltage,  BatteryStatus->Voltage);
    printf ("Current.,,,,,,,,,...: %08x  %d\n",  BatteryStatus->Current,  BatteryStatus->Current);
    printf ("\n");
}




int
__cdecl
main(USHORT argc, CHAR **argv)
{
    ULONG                   BattTag;
    BATTERY_INFORMATION     BInfo;
    ULONG                   BETime;
    WCHAR                   BDeviceName[50];
    UCHAR                   BManDate[50];
    WCHAR                   BManName[50];
    ULONG                   BETemp;
    WCHAR                   BEUID [50];
    ULONG                   BEGran[4];
    BATTERY_WAIT_STATUS     WStat;
    BATTERY_STATUS          BStat;
    CHAR *NamePtr;

    if (argc > 1) {
        NamePtr=argv[1];
    } else {
        NamePtr = "CmBatt";
    }

    //
    // Locate pentium perf driver
    //

    if (!InitDriver (NamePtr)) {
        printf ("CmBatt not found\n");
        exit (1);
    }


    GetBatteryTag ();
    printf ("Battery Tag.........: %x\n", BatteryTag);

    //
    // Get generic info
    //

    GetBatteryInfo (BatteryInformation,     &BInfo,       sizeof(BInfo));
    GetBatteryInfo (BatteryEstimatedTime,   &BETime,      sizeof(BETime));
    GetBatteryInfo (BatteryDeviceName,       BDeviceName, sizeof(BDeviceName));
    GetBatteryInfo (BatteryManufactureDate,  BManDate,    sizeof(BManDate));
    GetBatteryInfo (BatteryManufactureName,  BManName,    sizeof(BManName));
    GetBatteryInfo (BatteryTemperature,     &BETemp,      sizeof(BETemp));
    GetBatteryInfo (BatteryUniqueID,         BEUID,       sizeof(BEUID));
    GetBatteryInfo (BatteryGranularityInformation, BEGran, sizeof(BEGran));

    // dump it...
    printf ("Capabilities........: %08x\n",  BInfo.Capabilities);
    printf ("Technology..........: %02x\n",  BInfo.Technology);
    printf ("Chemisttry..........: %4.4s\n", BInfo.Chemistry);
    printf ("Designed Capacity...: %08x\n",  BInfo.DesignedCapacity);
    printf ("FullCharged Capacity: %08x\n",  BInfo.FullChargedCapacity);
    printf ("Default Alert1......: %08x\n",  BInfo.DefaultAlert1);
    printf ("Default Alert2......: %08x\n",  BInfo.DefaultAlert2);
    printf ("Critical Bias.......: %08x\n",  BInfo.CriticalBias);
    printf ("Cycle Count.........: %08x\n",  BInfo.CycleCount);
    printf ("Granularity.........: %x %x %x %x\n", BEGran[0], BEGran[1], BEGran[2], BEGran[3]);
    printf ("Temapture...........: %08x\n",  BETemp);
    wprintf (L"Unique ID...........: %s\n",    BEUID);

    printf ("Estimated Time......: %08x\n",  BETime);
    wprintf (L"Device Name.........: %s\n",  BDeviceName);
    printf ("Manufacture Date....: %d %d %d %d\n",  BManDate[0], BManDate[1], BManDate[2], BManDate[3]);
    wprintf (L"Manufacture Name....: %s\n",  BManName);

    printf ("\n");

    memset (&WStat, 0, sizeof(WStat));
    WStat.BatteryTag = BatteryTag;

    GetBatteryStatus (&WStat, &BStat);

    // Now that we've got the state, let's perform a long term status change request
    WStat.PowerState = BStat.PowerState;
    WStat.LowCapacity = BStat.Capacity - RANGE;
    WStat.HighCapacity = BStat.Capacity + RANGE;
    WStat.Timeout = 50000000;  // 5 min
    GetBatteryStatus (&WStat, &BStat);
}



BOOLEAN
InitDriver (
    CHAR *NamePtr
)
{
    UNICODE_STRING              DriverName;
    ANSI_STRING                 AnsiName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    UCHAR                       strbuf[100];

    sprintf (strbuf, "\\Device\\%s",NamePtr);

    RtlInitAnsiString(&AnsiName, strbuf);

    RtlAnsiStringToUnicodeString(&DriverName, &AnsiName, TRUE);

    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,     // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if (!NT_SUCCESS(status)) {
        printf ("Device name %s Error %x\n", strbuf, status);
        return FALSE;
    } else {
        printf ("Opened Device name %s\n", strbuf);
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\compbatt\compbatt.h ===
#include <wdm.h>
#include <batclass.h>


#ifndef FAR
#define FAR
#endif


//
// Debug
//

#define DEBUG DBG

#if DEBUG
    extern ULONG CompBattDebug;

    #define BattPrint(l,m)    if(l & CompBattDebug) DbgPrint m
#else
    #define BattPrint(l,m)
#endif

#define BATT_LOW        0x00000001
#define BATT_NOTE       0x00000002
#define BATT_WARN       0x00000004
#define BATT_ERROR      0x00000008
#define BATT_ERRORS     (BATT_ERROR | BATT_WARN)
#define BATT_MP         0x00000010
#define BATT_DEBUG      0x00000020
#define BATT_TRACE      0x00000100
#define BATT_DATA       0x00000200


//
// Battery class info
//

#define NTMS    10000L                          // 1 millisecond is ten thousand 100ns
#define NTSEC   (NTMS * 1000L)
#define NTMIN   ((ULONGLONG) 60 * NTSEC)

#define SEC     1000
#define MIN     (60 * SEC)

//
// Poll rates for when a notification alarm cannot be set
//
#define MIN_STATUS_POLL_RATE        (3L * NTMIN)
#define MAX_STATUS_POLL_RATE        (20 * NTSEC)
#define STATUS_VALID_TIME           (2 * NTSEC)

#define MAX_HIGH_CAPACITY           0x7fffffff
#define MIN_LOW_CAPACITY            0x0

//
// Charge/Discharge policy values (in percent)
//
#define BATTERY_MIN_SAFE_CAPACITY   2           // Min we will attempt to run on
#define BATTERY_MAX_CHARGE_CAPACITY 90          // Max we will attempt to charge

//
// Cache expiration timeouts -- when the cached battery status/info expires.
//
#define CACHE_STATUS_TIMEOUT        (4 * NTSEC)
#define CACHE_INFO_TIMEOUT          (4 * NTSEC)

//
// Cached battery info
//

typedef struct {
    ULONG                       Tag;
    ULONG                       Valid;
    BATTERY_INFORMATION         Info;
    ULONGLONG                   InfoTimeStamp;
    UCHAR                       ManufacturerNameLength;
    UCHAR                       ManufacturerName[MAX_BATTERY_STRING_SIZE];
    UCHAR                       DeviceNameLength;
    UCHAR                       DeviceName[MAX_BATTERY_STRING_SIZE];
    BATTERY_MANUFACTURE_DATE    ManufacturerDate;
    ULONG                       SerialNumber;
    BATTERY_STATUS              Status;
    ULONGLONG                   StatusTimeStamp;
} STATIC_BAT_INFO, *PSTATIC_BAT_INFO;


#define VALID_TAG_DATA      0x01            // manufacturer, device, serial #
#define VALID_MODE          0x02
#define VALID_INFO          0x04
#define VALID_CYCLE_COUNT   0x08
#define VALID_SANITY_CHECK  0x10

#define VALID_TAG           0x80
#define VALID_NOTIFY        0x100

#define VALID_ALL           0x1F            // (does not include tag)

//
// Locking mechanism for battery nodes so we don't delete out from under
// ourselves.  I would just use an IO_REMOVE_LOCK, but that's NT not WDM...
//

typedef struct _COMPBATT_DELETE_LOCK {
    BOOLEAN     Deleted;
    BOOLEAN     Reserved [3];
    LONG        RefCount;
    KEVENT      DeleteEvent;

} COMPBATT_DELETE_LOCK, *PCOMPBATT_DELETE_LOCK;

VOID
CompbattInitializeDeleteLock (
        IN PCOMPBATT_DELETE_LOCK Lock
        );

NTSTATUS
CompbattAcquireDeleteLock (
        IN PCOMPBATT_DELETE_LOCK Lock
        );

VOID
CompbattReleaseDeleteLock (
        IN PCOMPBATT_DELETE_LOCK Lock
        );

VOID
CompbattReleaseDeleteLockAndWait (
        IN PCOMPBATT_DELETE_LOCK Lock
        );

//
// Battery node in the composite's list of batteries
//

typedef struct {
    LIST_ENTRY              Batteries;          // All batteries in composite
    COMPBATT_DELETE_LOCK    DeleteLock;
    PDEVICE_OBJECT          DeviceObject;       // device object for the battery
    PIRP                    StatusIrp;          // current status irp at device
    WORK_QUEUE_ITEM         WorkItem;           // Used for restarting status Irp
                                                // if it is completed at DPC level
    BOOLEAN                 NewBatt;            // Is this a new battery on the list


    UCHAR                   State;
    BATTERY_WAIT_STATUS     Wait;

    union {
        BATTERY_STATUS          Status;
        BATTERY_WAIT_STATUS     Wait;
        ULONG                   Tag;
    } IrpBuffer;

    //
    // Keep some static information around so we don't have to go out to the
    // batteries all the time.
    //

    STATIC_BAT_INFO         Info;

    //
    // Symbolic link name for the battery.  Since we calculate the length of this
    // structure based on the structure size plus the length of this string, the
    // string must be the last thing declared in the structure.
    //

    UNICODE_STRING          BattName;

} COMPOSITE_ENTRY, *PCOMPOSITE_ENTRY;


#define CB_ST_GET_TAG       0
#define CB_ST_GET_STATUS    1

//
// Composite battery device extension
//

typedef struct {
    PVOID                   Class;              // Class information
    // ULONG                   Tag;                // Current tag of composite battery
    ULONG                   NextTag;            // Next tag

    LIST_ENTRY              Batteries;          // All batteries
    FAST_MUTEX              ListMutex;          // List synchronization

    //
    // Keep some static information around so we don't have to go out to the
    // batteries all the time.
    //

    STATIC_BAT_INFO         Info;
    BATTERY_WAIT_STATUS     Wait;


    PDEVICE_OBJECT          LowerDevice;        // PDO
    PDEVICE_OBJECT          DeviceObject;       // Compbatt Device
    PVOID                   NotificationEntry;  // PnP registration handle
} COMPOSITE_BATTERY, *PCOMPOSITE_BATTERY;


//
// Prototypes
//


NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PUNICODE_STRING     RegistryPath
    );

NTSTATUS
CompBattIoctl(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    );

NTSTATUS
CompBattSystemControl(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    );

NTSTATUS
CompBattQueryTag (
    IN  PVOID               Context,
    OUT PULONG              BatteryTag
    );

NTSTATUS
CompBattQueryInformation (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    IN LONG                 AtRate,
    OUT PVOID               Buffer,
    IN  ULONG               BufferLength,
    OUT PULONG              ReturnedLength
    );

NTSTATUS
CompBattQueryStatus (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    OUT PBATTERY_STATUS     BatteryStatus
    );

NTSTATUS
CompBattSetStatusNotify (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    IN PBATTERY_NOTIFY      BatteryNotify
    );

NTSTATUS
CompBattDisableStatusNotify (
    IN PVOID                Context
    );

NTSTATUS
CompBattDriverEntry (
    IN PDRIVER_OBJECT       DriverObject,
    IN PUNICODE_STRING      RegistryPath
    );

NTSTATUS
CompBattGetBatteryInformation (
    IN PBATTERY_INFORMATION TotalBattInfo,
    IN PCOMPOSITE_BATTERY   CompBatt
    );

NTSTATUS
CompBattGetBatteryGranularity (
    IN PBATTERY_REPORTING_SCALE GranularityBuffer,
    IN PCOMPOSITE_BATTERY       CompBatt
   );

NTSTATUS
CompBattPrivateIoctl(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CompBattGetEstimatedTime (
    IN PULONG               TimeBuffer,
    IN PCOMPOSITE_BATTERY   CompBatt
    );

NTSTATUS
CompBattAddDevice (
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       PDO
    );

NTSTATUS
CompBattPowerDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
CompBattPnpDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

VOID
CompBattUnload(
    IN PDRIVER_OBJECT       DriverObject
    );

NTSTATUS
CompBattOpenClose(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
BatteryIoctl(
    IN ULONG                Ioctl,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PVOID                InputBuffer,
    IN ULONG                InputBufferLength,
    IN PVOID                OutputBuffer,
    IN ULONG                OutputBufferLength,
    IN BOOLEAN              PrivateIoctl
    );

NTSTATUS
CompBattPnpEventHandler(
    IN PVOID                NotificationStructure,
    IN PVOID                Context
    );

NTSTATUS
CompBattAddNewBattery(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    );

NTSTATUS
CompBattRemoveBattery(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    );

BOOLEAN
IsBatteryAlreadyOnList(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    );

PCOMPOSITE_ENTRY
RemoveBatteryFromList(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    );

NTSTATUS
CompBattGetBatteries(
    IN PCOMPOSITE_BATTERY   CompBatt
    );

BOOLEAN
CompBattVerifyStaticInfo (
    IN  PCOMPOSITE_BATTERY  CompBatt
    );

VOID CompBattMonitorIrpCompleteWorker (
    IN PVOID Context
    );

NTSTATUS
CompBattMonitorIrpComplete (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    );

VOID
CompBattRecalculateTag (
    IN PCOMPOSITE_BATTERY   CompBatt
    );

VOID
CompBattChargeDischarge (
    IN PCOMPOSITE_BATTERY   CompBatt
    );

NTSTATUS
CompBattGetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\compbatt\compbatt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CompBatt.c

Abstract:

    Composite Battery device functions

    The purpose of the composite battery device is to open all batteries
    in the system which supply system power and provide a logical sumation
    of the information under one battery device.

Author:

    Ken Reneris

Environment:

Notes:


Revision History:
    07/02/97:  Local cache timestamps/timeouts

--*/

#include "compbatt.h"

#if DEBUG
    #if DBG
        ULONG   CompBattDebug = BATT_ERRORS;
    #else
        ULONG   CompBattDebug = 0;
    #endif
#endif



#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CompBattUnload)
#pragma alloc_text(PAGE, CompBattIoctl)
#pragma alloc_text(PAGE, CompBattQueryTag)
#pragma alloc_text(PAGE, CompBattQueryInformation)
#pragma alloc_text(PAGE, CompBattQueryStatus)
#pragma alloc_text(PAGE, CompBattSetStatusNotify)
#pragma alloc_text(PAGE, CompBattDisableStatusNotify)
#pragma alloc_text(PAGE, CompBattGetBatteryInformation)
#pragma alloc_text(PAGE, CompBattGetBatteryGranularity)
#pragma alloc_text(PAGE, CompBattGetEstimatedTime)
#endif



NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    The first time the battery class driver is loaded it will check to
    see if the composite battery has been created.  If not, it will create
    a driver object with this routine as the DriverEntry.  This routine
    then does the necessary things to initialize the composite battery.

Arguments:

    DriverObject - Driver object for newly created driver

    RegistryPath - Not used

Return Value:

    Status

--*/
{

    // DbgBreakPoint ();

    //
    // Initialize the driver entry points
    //

    //DriverObject->DriverUnload                          = CompBattUnload;
    DriverObject->DriverExtension->AddDevice            = CompBattAddDevice;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = CompBattIoctl;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = CompBattOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = CompBattOpenClose;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = CompBattPnpDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = CompBattPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = CompBattSystemControl;
    return STATUS_SUCCESS;
}




NTSTATUS
CompBattAddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PDO
    )

/*++

Routine Description:



Arguments:

    DriverObject - Pointer to driver object created by system.

    PDO          - PDO for the new device(s)

Return Value:

    Status

--*/
{
    PDEVICE_OBJECT          fdo;
    BATTERY_MINIPORT_INFO   BattInit;
    UNICODE_STRING          UnicodeString;
    NTSTATUS                Status;
    UNICODE_STRING          DosLinkName;
    PCOMPOSITE_BATTERY      compBatt;


    BattPrint (BATT_NOTE, ("CompBatt: Got an AddDevice - %x\n", PDO));

    //
    // Build the composite battery device and register it to the
    // battery class driver (i.e., ourselves)
    //

    RtlInitUnicodeString(&UnicodeString, L"\\Device\\CompositeBattery");

    Status = IoCreateDevice(
                DriverObject,
                sizeof (COMPOSITE_BATTERY),
                &UnicodeString,
                FILE_DEVICE_BATTERY,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &fdo
                );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    RtlInitUnicodeString(&DosLinkName, L"\\DosDevices\\CompositeBattery");
    IoCreateSymbolicLink(&DosLinkName, &UnicodeString);

    //
    // Layer our FDO on top of the PDO.
    //

    compBatt                = (PCOMPOSITE_BATTERY) fdo->DeviceExtension;
    RtlZeroMemory (compBatt, sizeof(COMPOSITE_BATTERY));

    compBatt->LowerDevice   = IoAttachDeviceToDeviceStack (fdo,PDO);

    compBatt->DeviceObject = fdo;

    //
    // No status. Do the best we can.
    //

    if (!compBatt->LowerDevice) {
        BattPrint (BATT_ERROR, ("CompBattAddDevice: Could not attach to LowerDevice.\n"));
        IoDeleteDevice(fdo);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Initialize composite battery info
    //

    fdo->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    InitializeListHead (&compBatt->Batteries);
    ExInitializeFastMutex (&compBatt->ListMutex);

    compBatt->NextTag           = 1;   // first valid battery tag for composite
    compBatt->Info.Valid        = 0;

    RtlZeroMemory (&BattInit, sizeof(BattInit));
    BattInit.MajorVersion        = BATTERY_CLASS_MAJOR_VERSION;
    BattInit.MinorVersion        = BATTERY_CLASS_MINOR_VERSION;
    BattInit.Context             = compBatt;
    BattInit.QueryTag            = CompBattQueryTag;
    BattInit.QueryInformation    = CompBattQueryInformation;
    BattInit.SetInformation      = NULL;
    BattInit.QueryStatus         = CompBattQueryStatus;
    BattInit.SetStatusNotify     = CompBattSetStatusNotify;
    BattInit.DisableStatusNotify = CompBattDisableStatusNotify;

    BattInit.Pdo                 = NULL;
    BattInit.DeviceName          = &UnicodeString;

    //
    // Register myself with the battery class driver
    //

    Status = BatteryClassInitializeDevice (&BattInit, &compBatt->Class);
    if (!NT_SUCCESS(Status)) {
        IoDetachDevice(compBatt->LowerDevice);
        IoDeleteDevice(fdo);
    }
    return Status;
}






VOID
CompBattUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Cleanup all devices and unload the driver

Arguments:

    DriverObject - Driver object for unload

Return Value:

    Status

--*/
{
    DbgBreakPoint();

    //
    // Unloading the composite battery is not supported.
    //          If it were implemented, we would
    //          need to call the class driver's unload and then
    //          delete all nodes in the battery list, clean up
    //          then delete our FDO.
    //
}




NTSTATUS
CompBattOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING OpenClose\n"));


    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BattPrint (BATT_TRACE, ("CompBatt: Exiting OpenClose\n"));

    return(STATUS_SUCCESS);
}




NTSTATUS
CompBattIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    IOCTL handler.  As this is an exclusive battery device, send the
    Irp to the battery class driver to handle battery IOCTLs.

Arguments:

    DeviceObject    - Battery for request

    Irp             - IO request

Return Value:

    Status of request

--*/
{
    PCOMPOSITE_BATTERY  compBatt;
    NTSTATUS            status;


    PAGED_CODE();

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING Ioctl\n"));

    compBatt = (PCOMPOSITE_BATTERY) DeviceObject->DeviceExtension;
    status   = BatteryClassIoctl (compBatt->Class, Irp);


    if (status == STATUS_NOT_SUPPORTED) {
        //
        // Not for the battery, pass it down the stack.
        //

        Irp->IoStatus.Status = status;

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(compBatt->LowerDevice, Irp);
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING Ioctl\n"));

    return status;
}




NTSTATUS
CompBattSystemControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine forwards System Control requests down the stack

Arguments:

    DeviceObject    - the device object in question
    Irp             - the request to forward

Return Value:

    NTSTATUS

--*/
{
    PCOMPOSITE_BATTERY  compBatt;
    NTSTATUS            status;


    PAGED_CODE();

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING System Control\n"));

    compBatt = (PCOMPOSITE_BATTERY) DeviceObject->DeviceExtension;
    if (compBatt->LowerDevice != NULL) {

        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( compBatt->LowerDevice, Irp );

    } else {

        Irp->IoStatus.Status = status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;

}

NTSTATUS
CompBattQueryTag (
    IN  PVOID Context,
    OUT PULONG BatteryTag
    )
/*++

Routine Description:

    Called by the class driver to retrieve the batteries current tag value

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Pointer to return current tag


Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    PCOMPOSITE_BATTERY      compBatt;
    NTSTATUS                status          = STATUS_SUCCESS;


    PAGED_CODE();


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING QueryTag\n"));

    compBatt = (PCOMPOSITE_BATTERY) Context;

    if (!(compBatt->Info.Valid & VALID_TAG)) {
        //
        // Recalculate the composite's tag.
        //

        CompBattRecalculateTag(compBatt);

    }

    if ((compBatt->Info.Valid & VALID_TAG) && (compBatt->Info.Tag != BATTERY_TAG_INVALID)) {
        *BatteryTag = compBatt->Info.Tag;
        status      = STATUS_SUCCESS;

    } else {
        *BatteryTag = BATTERY_TAG_INVALID;
        status      = STATUS_NO_SUCH_DEVICE;
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING QueryTag\n"));

    return status;
}






NTSTATUS
CompBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN LONG                             AtRate,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    )
{
    ULONG                       resultData;
    NTSTATUS                    status;
    PVOID                       returnBuffer;
    ULONG                       returnBufferLength;
    PCOMPOSITE_BATTERY          compBatt;
    BATTERY_INFORMATION         totalBattInfo;
    BATTERY_REPORTING_SCALE     granularity[4];
    BATTERY_MANUFACTURE_DATE    date;
    WCHAR                       compositeName[] = L"Composite Battery";

    PAGED_CODE();

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING QueryInformation\n"));

    compBatt = (PCOMPOSITE_BATTERY) Context;

    if ((BatteryTag != compBatt->Info.Tag) || !(compBatt->Info.Valid & VALID_TAG)) {
        return STATUS_NO_SUCH_DEVICE;
    }


    returnBuffer        = NULL;
    returnBufferLength  = 0;
    status              = STATUS_SUCCESS;


    //
    // Get the info requested
    //

    switch (Level) {
        case BatteryInformation:

            RtlZeroMemory (&totalBattInfo, sizeof(totalBattInfo));
            status = CompBattGetBatteryInformation (&totalBattInfo, compBatt);

            if (NT_SUCCESS(status)) {
                returnBuffer        = &totalBattInfo;
                returnBufferLength  = sizeof(totalBattInfo);
            }

            break;


        case BatteryGranularityInformation:

            RtlZeroMemory (&granularity[0], sizeof(granularity));
            status = CompBattGetBatteryGranularity (&granularity[0], compBatt);

            if (NT_SUCCESS(status)) {
                returnBuffer        = &granularity[0];
                returnBufferLength  = sizeof(granularity);
            }

            break;


        case BatteryTemperature:
                resultData          = 0;
                returnBuffer        = &resultData;
                returnBufferLength  = sizeof (resultData);
                break;


        case BatteryEstimatedTime:

            RtlZeroMemory (&resultData, sizeof(resultData));
            status = CompBattGetEstimatedTime (&resultData, compBatt);

            if (NT_SUCCESS(status)) {
                returnBuffer        = &resultData;
                returnBufferLength  = sizeof(resultData);

            }

            break;


        case BatteryDeviceName:
                returnBuffer        = compositeName;
                returnBufferLength  = sizeof (compositeName);
                break;


        case BatteryManufactureDate:
                date.Day            = 26;
                date.Month          = 6;
                date.Year           = 1997;
                returnBuffer        = &date;
                returnBufferLength  = sizeof (date);
                break;


        case BatteryManufactureName:
                returnBuffer        = compositeName;
                returnBufferLength  = sizeof (compositeName);
                break;


        case BatteryUniqueID:
                resultData          = 0;
                returnBuffer        = &resultData;
                returnBufferLength  = sizeof (resultData);
                break;

        default:
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Make sure nothing changed while reading batteries.
    //

    if ((BatteryTag != compBatt->Info.Tag) || !(compBatt->Info.Valid & VALID_TAG)) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Done, return buffer if needed
    //

    *ReturnedLength = returnBufferLength;
    if (BufferLength < returnBufferLength) {
        status = STATUS_BUFFER_TOO_SMALL;
    }

    if (NT_SUCCESS(status) && returnBuffer) {
        memcpy (Buffer, returnBuffer, returnBufferLength);
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING QueryInformation\n"));

    return status;
}






NTSTATUS
CompBattQueryStatus (
    IN PVOID Context,
    IN ULONG BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
    )
/*++

Routine Description:

    Called by the class driver to retrieve the batteries current status.  This
    routine loops through all of the batteries in the system and reports a
    composite battery.

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Tag of current battery

    BatteryStatus   - Pointer to structure to return the current battery status

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    NTSTATUS                status      = STATUS_SUCCESS;
    PCOMPOSITE_ENTRY        batt;
    PLIST_ENTRY             entry;
    PBATTERY_STATUS         localBatteryStatus;
    PCOMPOSITE_BATTERY      compBatt;
    BATTERY_WAIT_STATUS     batteryWaitStatus;
    ULONGLONG               wallClockTime;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING QueryStatus\n"));

    compBatt = (PCOMPOSITE_BATTERY) Context;

    if ((BatteryTag != compBatt->Info.Tag) || !(compBatt->Info.Valid & VALID_TAG)) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Initialize Composite data structure.
    //

    BatteryStatus->Rate = BATTERY_UNKNOWN_RATE;
    BatteryStatus->Voltage = BATTERY_UNKNOWN_VOLTAGE;
    BatteryStatus->Capacity = BATTERY_UNKNOWN_CAPACITY;

    // Composite battery will only report POWER_ON_LINE if all batteries report
    // this flag.
    BatteryStatus->PowerState = BATTERY_POWER_ON_LINE;

    //
    // Set up the local battery status structure for calls to the batteries
    //

    RtlZeroMemory (&batteryWaitStatus, sizeof (BATTERY_WAIT_STATUS));

    //
    // Get current time for timestamps
    //

    wallClockTime = KeQueryInterruptTime ();

    //
    // If cache is fresh, no need to do anything
    //

    if ((wallClockTime - compBatt->Info.StatusTimeStamp) <= CACHE_STATUS_TIMEOUT) {

        BattPrint (BATT_NOTE, ("CompBattQueryStatus: Composite battery status cache is [valid]\n"));

        //
        // Copy status info to caller's buffer
        //
        RtlCopyMemory (BatteryStatus, &compBatt->Info.Status, sizeof (BATTERY_STATUS));

        return STATUS_SUCCESS;
    }

    BattPrint (BATT_NOTE, ("CompBattQueryStatus: Composite battery status cache is [stale] - refreshing\n"));

    //
    // Walk the list of batteries, getting status of each
    //

    ExAcquireFastMutex (&compBatt->ListMutex);
    for (entry = compBatt->Batteries.Flink; entry != &compBatt->Batteries; entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }
        ExReleaseFastMutex (&compBatt->ListMutex);

        batteryWaitStatus.BatteryTag    = batt->Info.Tag;
        localBatteryStatus              = &batt->Info.Status;

        if (batt->Info.Valid & VALID_TAG) {

            //
            // If cached status for this battery is stale, refresh it
            //

            if ((wallClockTime - batt->Info.StatusTimeStamp) > CACHE_STATUS_TIMEOUT) {

                BattPrint (BATT_NOTE, ("CompBattQueryStatus: Battery status cache is [stale] - refreshing\n"));

                //
                // issue IOCTL to device
                //

                RtlZeroMemory (localBatteryStatus, sizeof(BATTERY_STATUS));

                status = BatteryIoctl (IOCTL_BATTERY_QUERY_STATUS,
                                       batt->DeviceObject,
                                       &batteryWaitStatus,
                                       sizeof (BATTERY_WAIT_STATUS),
                                       localBatteryStatus,
                                       sizeof (BATTERY_STATUS),
                                       FALSE);

                if (!NT_SUCCESS(status)) {

                    //
                    // In case of failure, this function should simply return the
                    // status code.  Invalidating of data is now performed only
                    // in MonitorIrpComplete.
                    //
                    // This raises the slight possibility that the sender of this
                    // request could retry before the data is properly invalidated,
                    // but worst case, they would again get this same error condition
                    // until the data is properly invalidated by MonitorIrpComplete.
                    //

                    if (status == STATUS_DEVICE_REMOVED) {

                        //
                        // This battery is being removed.
                        // The composite battery tag is or will soon be
                        // invalidated by MonitorIrpComplete.
                        //

                        status = STATUS_NO_SUCH_DEVICE;
                    }

                    //
                    // Return failure code.
                    //

                    ExAcquireFastMutex (&compBatt->ListMutex);
                    CompbattReleaseDeleteLock(&batt->DeleteLock);
                    break;
                }

                // Set new timestamp

                batt->Info.StatusTimeStamp = wallClockTime;

            } else {

                BattPrint (BATT_NOTE, ("CompBattQueryStatus: Battery status cache is [valid]\n"));
            }


            //
            // Accumulate data.
            //


            //
            // Combine the power states.
            //

            // Logical OR CHARGING and DISCHARGING
            BatteryStatus->PowerState  |= (localBatteryStatus->PowerState &
                                           (BATTERY_CHARGING |
                                            BATTERY_DISCHARGING));

            // Logical AND POWER_ON_LINE
            BatteryStatus->PowerState  &= (localBatteryStatus->PowerState |
                                           ~BATTERY_POWER_ON_LINE);

            // Compbatt is critical if one battery is critical and discharging
            if ((localBatteryStatus->PowerState & BATTERY_CRITICAL) &&
                (localBatteryStatus->PowerState & BATTERY_DISCHARGING)) {
                BatteryStatus->PowerState |= BATTERY_CRITICAL;
            }

            //
            // The Capacity could possibly be "Unknown" for CMBatt, and if so
            // we should not add it to the total capacity.
            //

            if (BatteryStatus->Capacity == BATTERY_UNKNOWN_CAPACITY) {
                BatteryStatus->Capacity = localBatteryStatus->Capacity;
            } else if (localBatteryStatus->Capacity != BATTERY_UNKNOWN_CAPACITY) {
                BatteryStatus->Capacity += localBatteryStatus->Capacity;
            }

            //
            // The Voltage should just be the greatest one encountered.
            //

            if (BatteryStatus->Voltage == BATTERY_UNKNOWN_VOLTAGE) {
                BatteryStatus->Voltage = localBatteryStatus->Voltage;
            } else if ((localBatteryStatus->Voltage > BatteryStatus->Voltage) &&
                       (localBatteryStatus->Voltage != BATTERY_UNKNOWN_VOLTAGE)) {
                BatteryStatus->Voltage = localBatteryStatus->Voltage;
            }

            //
            // The Current should just be total of all currents encountered.  This could
            // also possibly be "Unknown" for CMBatt, and if so we should not use it
            // in the calculation.
            //

            if (BatteryStatus->Rate == BATTERY_UNKNOWN_RATE) {
                BatteryStatus->Rate = localBatteryStatus->Rate;
            } else if (localBatteryStatus->Rate != BATTERY_UNKNOWN_RATE) {
                BatteryStatus->Rate += localBatteryStatus->Rate;
            }

        }   // if (batt->Tag != BATTERY_TAG_INVALID)

        ExAcquireFastMutex (&compBatt->ListMutex);
        CompbattReleaseDeleteLock(&batt->DeleteLock);
    }   // for (entry = gBatteries.Flink;  entry != &gBatteries;   entry = entry->Flink)

    ExReleaseFastMutex (&compBatt->ListMutex);


    //
    // If one battery was discharging while another was charging
    // Assume that it is discharging.  (This could happen with a UPS attached)
    //
    if ((BatteryStatus->PowerState & BATTERY_CHARGING) &&
        (BatteryStatus->PowerState & BATTERY_DISCHARGING)) {
        BatteryStatus->PowerState &= ~BATTERY_CHARGING;
    }

    //
    // Make sure nothing changed while reading batteries.
    //

    if ((BatteryTag != compBatt->Info.Tag) || !(compBatt->Info.Valid & VALID_TAG)) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Save the status in the composites cache
    //

    if (NT_SUCCESS(status)) {
        RtlCopyMemory (&compBatt->Info.Status, BatteryStatus, sizeof (BATTERY_STATUS));

        compBatt->Info.StatusTimeStamp = wallClockTime;

        BattPrint (BATT_DATA, ("CompBatt: Composite's new Status\n"
                               "--------  PowerState   = %x\n"
                               "--------  Capacity     = %x\n"
                               "--------  Voltage      = %x\n"
                               "--------  Rate         = %x\n",
                               compBatt->Info.Status.PowerState,
                               compBatt->Info.Status.Capacity,
                               compBatt->Info.Status.Voltage,
                               compBatt->Info.Status.Rate)
                               );

    }



    BattPrint (BATT_TRACE, ("CompBatt: EXITING QueryStatus\n"));

    return status;
}






NTSTATUS
CompBattSetStatusNotify (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN PBATTERY_NOTIFY BatteryNotify
    )
/*++

Routine Description:

    Called by the class driver to set the batteries current notification
    setting.  When the battery trips the notification, one call to
    BatteryClassStatusNotify is issued.   If an error is returned, the
    class driver will poll the battery status - primarily for capacity
    changes.  Which is to say the miniport should still issue BatteryClass-
    StatusNotify whenever the power state changes.


Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Tag of current battery

    BatteryNotify   - The notification setting

Return Value:

    Status

--*/
{
    PCOMPOSITE_ENTRY        batt;
    PLIST_ENTRY             entry;
    PCOMPOSITE_BATTERY      compBatt;
    BATTERY_STATUS          batteryStatus;
    LONG                    totalRate = 0;
    ULONG                   delta;
    ULONG                   highCapacityDelta;
    ULONG                   lowCapacityDelta;
    NTSTATUS                status;
    BOOLEAN                 inconsistent = FALSE;
    ULONG                   battCount = 0;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING SetStatusNotify\n"));

    compBatt = (PCOMPOSITE_BATTERY) Context;

    //
    // Check to see if this is the right battery
    //

    if ((BatteryTag != compBatt->Info.Tag) || !(compBatt->Info.Valid & VALID_TAG)) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Refresh the composite battery status cache if necessary.
    //

    status = CompBattQueryStatus (compBatt, BatteryTag, &batteryStatus);

    if (!NT_SUCCESS(status)) {
        return status;
    }


    //
    // Save away the composite notification parameters for future reference
    //

    compBatt->Wait.PowerState   = BatteryNotify->PowerState;
    compBatt->Wait.LowCapacity  = BatteryNotify->LowCapacity;
    compBatt->Wait.HighCapacity = BatteryNotify->HighCapacity;
    compBatt->Info.Valid |= VALID_NOTIFY;

    BattPrint (BATT_DATA, ("CompBatt: Got SetStatusNotify\n"
                           "--------  PowerState   = %x\n"
                           "--------  LowCapacity  = %x\n"
                           "--------  HighCapacity = %x\n",
                           compBatt->Wait.PowerState,
                           compBatt->Wait.LowCapacity,
                           compBatt->Wait.HighCapacity)
                           );

    //
    // Compute capacity deltas based on the total system capacity
    //

    lowCapacityDelta    = compBatt->Info.Status.Capacity - BatteryNotify->LowCapacity;
    highCapacityDelta   = BatteryNotify->HighCapacity - compBatt->Info.Status.Capacity;

    //
    // Run through the list of batteries and add up the total rate
    //

    //
    // Hold Mutex for this entire loop, since this loop doesn't call any drivers, etc
    //
    ExAcquireFastMutex (&compBatt->ListMutex);

    for (entry = compBatt->Batteries.Flink; entry != &compBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }

        if (!(batt->Info.Valid & VALID_TAG) || (batt->Info.Status.Rate == BATTERY_UNKNOWN_RATE)) {
            CompbattReleaseDeleteLock(&batt->DeleteLock);
            continue;
        }

        battCount++;

        if (((batt->Info.Status.PowerState & BATTERY_DISCHARGING) && (batt->Info.Status.Rate >= 0)) ||
            ((batt->Info.Status.PowerState & BATTERY_CHARGING) && (batt->Info.Status.Rate <= 0)) ||
            (((batt->Info.Status.PowerState & (BATTERY_CHARGING | BATTERY_DISCHARGING)) == 0) && (batt->Info.Status.Rate != 0))) {
            inconsistent = TRUE;
            BattPrint (BATT_ERROR, ("CompBatt: PowerState 0x%08x does not match Rate 0x%08x\n",
                       batt->Info.Status.PowerState,
                       batt->Info.Status.Rate));
        }

        if (((batt->Info.Status.Rate < 0) ^ (totalRate < 0)) && (batt->Info.Status.Rate != 0) && (totalRate != 0)) {
            inconsistent = TRUE;
            BattPrint (BATT_ERROR, ("CompBatt: It appears that one battery is charging while another is discharging.\n"
                                    "     This situation is not handled correctly.\n"));
        }

        totalRate += batt->Info.Status.Rate;

        CompbattReleaseDeleteLock(&batt->DeleteLock);

    }
    ExReleaseFastMutex (&compBatt->ListMutex);

    //
    // Run through the list of batteries and update the new wait status params
    //

    ExAcquireFastMutex (&compBatt->ListMutex);
    for (entry = compBatt->Batteries.Flink; entry != &compBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }

        ExReleaseFastMutex (&compBatt->ListMutex);

        if (!(batt->Info.Valid & VALID_TAG) ||
            (batt->Info.Status.Capacity == BATTERY_UNKNOWN_CAPACITY)) {
            batt->Wait.LowCapacity  = BATTERY_UNKNOWN_CAPACITY;
            batt->Wait.HighCapacity = BATTERY_UNKNOWN_CAPACITY;

#if DEBUG
            if (batt->Info.Status.Capacity == BATTERY_UNKNOWN_CAPACITY) {
                BattPrint (BATT_DEBUG, ("CompBattSetStatusNotify: Unknown Capacity encountered.\n"));
            }
#endif

            ExAcquireFastMutex (&compBatt->ListMutex);
            CompbattReleaseDeleteLock(&batt->DeleteLock);
            continue;
        }

        //
        // Adjust the LowCapacity alarm
        //

        //
        // Calculate the portion of the composite battery delta that belongs to
        // this battery.
        //

        if (inconsistent) {
            //
            // If data returned from batteries was inconsistent, don't do anything intelligent.
            // Just divide the notifications evenly between the batteries as if they were
            // draining at the same rate.  This will most likely result in early notification,
            // but by that time the data on the batteries ought to have settled down.
            //
            delta = lowCapacityDelta/battCount;
        } else if (totalRate != 0) {
            delta = (ULONG) (((LONGLONG) lowCapacityDelta * batt->Info.Status.Rate) / totalRate);
        } else {

            //
            // If total rate is zero, we would expect no change in battery
            // capacity, so we should get notified of any.
            //

            delta = 0;
        }

        //
        // Check for underflow on low capacity
        //


        if (batt->Info.Status.Capacity > delta) {
            batt->Wait.LowCapacity  = batt->Info.Status.Capacity - delta;

        } else {
            //
            // If there is still some charge in the battery set the LowCapacity
            // alarm to 1, else to 0.
            //
            // No need to do that.  If this battery runs out, it doesn't
            // need to notify.  One of the other batteries will be notifying
            // right away.  If there isn't another battery, this shouldn't
            // happen.

            BattPrint (BATT_NOTE, ("CompBatt: Unexpectedly huge delta encountered.  \n"
                                    "    Capacity = %08x\n"
                                    "    LowCapcityDelta = %08x\n"
                                    "    Rate = %08x\n"
                                    "    TotalRate = %08x\n",
                                    batt->Info.Status.Capacity,
                                    lowCapacityDelta,
                                    batt->Info.Status.Rate,
                                    totalRate));
            batt->Wait.LowCapacity  = 0;
        }


        //
        // Adjust the HighCapacity alarm for charging batteries only
        //

        //
        // Calculate the portion of the composite battery delta that belongs to
        // this battery.
        //

        if (inconsistent) {
            delta = highCapacityDelta/battCount;
        } else if (totalRate != 0) {
            delta = (ULONG) (((LONGLONG) highCapacityDelta * batt->Info.Status.Rate) / totalRate);
        } else {

            //
            // If total rate is zero, we would expect no change in battery
            // capacity, so we should get notified of any.
            //

            delta = 0;
        }

        //
        // Check for overflow on high capacity.
        // Allow setting the percentage above full charged capacity
        // since some batteries do that when new.
        //

        if ((MAX_HIGH_CAPACITY - delta) < batt->Info.Status.Capacity) {
            batt->Wait.HighCapacity = MAX_HIGH_CAPACITY;
        } else {
            batt->Wait.HighCapacity = batt->Info.Status.Capacity + delta;
        }

        //
        // If we're currently waiting, and the parameters are in
        // conflict, get the irp back to reset it
        //

        if (batt->State == CB_ST_GET_STATUS &&
            (batt->Wait.PowerState != batt->IrpBuffer.Wait.PowerState       ||
            batt->Wait.LowCapacity != batt->IrpBuffer.Wait.LowCapacity       ||
            batt->Wait.HighCapacity != batt->IrpBuffer.Wait.HighCapacity)) {

            IoCancelIrp (batt->StatusIrp);
        }

        ExAcquireFastMutex (&compBatt->ListMutex);
        CompbattReleaseDeleteLock(&batt->DeleteLock);
    }
    ExReleaseFastMutex (&compBatt->ListMutex);

    //
    // Make sure nothing changed while reading batteries.
    //

    if ((BatteryTag != compBatt->Info.Tag) || !(compBatt->Info.Valid & VALID_TAG)) {
        return STATUS_NO_SUCH_DEVICE;
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING SetStatusNotify\n"));

    return STATUS_SUCCESS;
}





NTSTATUS
CompBattDisableStatusNotify (
    IN PVOID Context
    )
/*++

Routine Description:

    Called by the class driver to disable the notification setting
    for the battery supplied by Context.  Note, to disable a setting
    does not require the battery tag.   Any notification is to be
    masked off until a subsequent call to SmbBattSetStatusNotify.

Arguments:

    Context         - Miniport context value for battery

Return Value:

    Status

--*/
{
    PCOMPOSITE_ENTRY        batt;
    PLIST_ENTRY             entry;
    PCOMPOSITE_BATTERY      compBatt;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING DisableStatusNotify\n"));

    compBatt = (PCOMPOSITE_BATTERY) Context;

    //
    // Run through the list of batteries and disable the wait status params
    // Hold mutex for entire loop, since loop doesn't make any calls.

    ExAcquireFastMutex (&compBatt->ListMutex);
    for (entry = compBatt->Batteries.Flink; entry != &compBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        batt->Wait.LowCapacity  = MIN_LOW_CAPACITY;
        batt->Wait.HighCapacity = MAX_HIGH_CAPACITY;
    }
    ExReleaseFastMutex (&compBatt->ListMutex);

    BattPrint (BATT_TRACE, ("CompBatt: EXITING DisableStatusNotify\n"));

    return STATUS_SUCCESS;
}






NTSTATUS
CompBattGetBatteryInformation (
    IN PBATTERY_INFORMATION TotalBattInfo,
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    The routine loops through the batteries in the system and queries them
    for information. It then forms a composite representation of this
    information to send back to the caller.

Arguments:

    TotalBattInfo   - Buffer to place the composite battery information in

Return Value:

    STATUS_SUCCESS or the status returned by the Ioctl to the battery.

--*/
{
    NTSTATUS                    status;
    PBATTERY_INFORMATION        battInfo;
    PCOMPOSITE_ENTRY            batt;
    PLIST_ENTRY                 entry;
    BATTERY_QUERY_INFORMATION   bInfo;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING GetBatteryInformation\n"));

    TotalBattInfo->DefaultAlert1 = 0;
    TotalBattInfo->DefaultAlert2 = 0;
    TotalBattInfo->CriticalBias  = 0;

    status = STATUS_SUCCESS;

    //
    // Run through the list of batteries getting the information
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }

        ExReleaseFastMutex (&CompBatt->ListMutex);

        bInfo.BatteryTag        = batt->Info.Tag;
        bInfo.InformationLevel  = BatteryInformation;
        bInfo.AtRate            = 0;
        battInfo                = &batt->Info.Info;

        if (batt->Info.Tag != BATTERY_TAG_INVALID) {
            if (!(batt->Info.Valid & VALID_INFO)) {

                //
                // issue IOCTL to device
                //

                RtlZeroMemory (battInfo, sizeof(BATTERY_INFORMATION));

                status = BatteryIoctl (IOCTL_BATTERY_QUERY_INFORMATION,
                                       batt->DeviceObject,
                                       &bInfo,
                                       sizeof (bInfo),
                                       battInfo,
                                       sizeof (BATTERY_INFORMATION),
                                       FALSE);

                if (!NT_SUCCESS(status)) {
                    if (status == STATUS_DEVICE_REMOVED) {
                        //
                        // If one device is removed, that invalidates the tag.
                        //
                        status = STATUS_NO_SUCH_DEVICE;
                    }

                    ExAcquireFastMutex (&CompBatt->ListMutex);
                    CompbattReleaseDeleteLock(&batt->DeleteLock);
                    break;
                }

                BattPrint (BATT_DATA, ("CompBattGetBatteryInformation: Read individual BATTERY_INFORMATION\n"
                                        "--------  Capabilities = %x\n"
                                        "--------  Technology = %x\n"
                                        "--------  Chemistry[4] = %x\n"
                                        "--------  DesignedCapacity = %x\n"
                                        "--------  FullChargedCapacity = %x\n"
                                        "--------  DefaultAlert1 = %x\n"
                                        "--------  DefaultAlert2 = %x\n"
                                        "--------  CriticalBias = %x\n"
                                        "--------  CycleCount = %x\n",
                                        battInfo->Capabilities,
                                        battInfo->Technology,
                                        battInfo->Chemistry[4],
                                        battInfo->DesignedCapacity,
                                        battInfo->FullChargedCapacity,
                                        battInfo->DefaultAlert1,
                                        battInfo->DefaultAlert2,
                                        battInfo->CriticalBias,
                                        battInfo->CycleCount)
                                       );

                batt->Info.Valid |= VALID_INFO;

            }   // if (!(batt->Info.Valid & VALID_INFO))

            //
            // Logically OR the capabilities
            //

            TotalBattInfo->Capabilities |= battInfo->Capabilities;


            //
            // Add the designed capacities.  If this is UNKNOWN (possible
            // with the control method batteries, don't add them in.
            //

            if (battInfo->DesignedCapacity != BATTERY_UNKNOWN_CAPACITY) {
                TotalBattInfo->DesignedCapacity    += battInfo->DesignedCapacity;
            }

            if (battInfo->FullChargedCapacity != BATTERY_UNKNOWN_CAPACITY) {
                TotalBattInfo->FullChargedCapacity += battInfo->FullChargedCapacity;
            }

            if (TotalBattInfo->DefaultAlert1 < battInfo->DefaultAlert1) {
                TotalBattInfo->DefaultAlert1 = battInfo->DefaultAlert1;
            }

            if (TotalBattInfo->DefaultAlert2 < battInfo->DefaultAlert2) {
                TotalBattInfo->DefaultAlert2 = battInfo->DefaultAlert2;
            }

            if (TotalBattInfo->CriticalBias  < battInfo->CriticalBias) {
                TotalBattInfo->CriticalBias  = battInfo->CriticalBias;
            }

        }   // if (batt->Tag != BATTERY_TAG_INVALID)

        ExAcquireFastMutex (&CompBatt->ListMutex);
        CompbattReleaseDeleteLock(&batt->DeleteLock);
    }   // for (entry = gBatteries.Flink;  entry != &gBatteries;   entry = entry->Flink)
    ExReleaseFastMutex (&CompBatt->ListMutex);

    //
    // Save the battery information in the composite battery cache
    //

    if (NT_SUCCESS(status)) {
        //
        // Check to see if we have an UNKNOWN full charge capacity.  If so, set this
        // to the design capacity.
        //

        if (TotalBattInfo->FullChargedCapacity == 0) {
            TotalBattInfo->FullChargedCapacity = TotalBattInfo->DesignedCapacity;
        }

        BattPrint (BATT_DATA, ("CompBattGetBatteryInformation: Returning BATTERY_INFORMATION\n"
                                "--------  Capabilities = %x\n"
                                "--------  Technology = %x\n"
                                "--------  Chemistry[4] = %x\n"
                                "--------  DesignedCapacity = %x\n"
                                "--------  FullChargedCapacity = %x\n"
                                "--------  DefaultAlert1 = %x\n"
                                "--------  DefaultAlert2 = %x\n"
                                "--------  CriticalBias = %x\n"
                                "--------  CycleCount = %x\n",
                                TotalBattInfo->Capabilities,
                                TotalBattInfo->Technology,
                                TotalBattInfo->Chemistry[4],
                                TotalBattInfo->DesignedCapacity,
                                TotalBattInfo->FullChargedCapacity,
                                TotalBattInfo->DefaultAlert1,
                                TotalBattInfo->DefaultAlert2,
                                TotalBattInfo->CriticalBias,
                                TotalBattInfo->CycleCount)
                               );

        RtlCopyMemory (&CompBatt->Info.Info, TotalBattInfo, sizeof(BATTERY_INFORMATION));
        CompBatt->Info.Valid |= VALID_INFO;
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING GetBatteryInformation\n"));

    return status;
}





NTSTATUS
CompBattGetBatteryGranularity (
    IN PBATTERY_REPORTING_SCALE GranularityBuffer,
    IN PCOMPOSITE_BATTERY        CompBatt
    )
/*++

Routine Description:

    The routine queries all the batteries in the system to get their granularity
    settings.  It then returns the setting that has the finest granularity in each range.

Arguments:

    GranularityBuffer   - Buffer for containing the results of the query

Return Value:

    STATUS_SUCCESS or the status returned by the Ioctl to the battery.

--*/
{
    NTSTATUS                    status;
    BATTERY_REPORTING_SCALE     localGranularity[4];
    PCOMPOSITE_ENTRY            batt;
    PLIST_ENTRY                 entry;
    ULONG                       i;
    BATTERY_QUERY_INFORMATION   bInfo;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING GetBatteryGranularity\n"));

    GranularityBuffer[0].Granularity = 0xFFFFFFFF;
    GranularityBuffer[1].Granularity = 0xFFFFFFFF;
    GranularityBuffer[2].Granularity = 0xFFFFFFFF;
    GranularityBuffer[3].Granularity = 0xFFFFFFFF;

    //
    // Run through the list of batteries getting the granularity
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt                    = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }

        ExReleaseFastMutex (&CompBatt->ListMutex);

        bInfo.BatteryTag        = batt->Info.Tag;
        bInfo.InformationLevel  = BatteryGranularityInformation;

        if (batt->Info.Tag != BATTERY_TAG_INVALID) {
            //
            // issue IOCTL to device
            //

            RtlZeroMemory (localGranularity, sizeof(localGranularity));

            status = BatteryIoctl (IOCTL_BATTERY_QUERY_INFORMATION,
                                   batt->DeviceObject,
                                   &bInfo,
                                   sizeof (bInfo),
                                   localGranularity,
                                   sizeof (localGranularity),
                                   FALSE);

            if (!NT_SUCCESS(status)) {
                if (status == STATUS_DEVICE_REMOVED) {
                    //
                    // If one device is removed, that invalidates the tag.
                    //
                    status = STATUS_NO_SUCH_DEVICE;
                }

                ExAcquireFastMutex (&CompBatt->ListMutex);
                CompbattReleaseDeleteLock(&batt->DeleteLock);
                break;
            }


            //
            // Check for the best granularity in each range.
            //

            for (i = 0; i < 4; i++) {

                if (localGranularity[i].Granularity) {

                    if (localGranularity[i].Granularity < GranularityBuffer[i].Granularity) {
                        GranularityBuffer[i].Granularity = localGranularity[i].Granularity;
                    }

                    GranularityBuffer[i].Capacity = localGranularity[i].Capacity;
                }

            }

        }   // if (batt->Tag != BATTERY_TAG_INVALID)

        ExAcquireFastMutex (&CompBatt->ListMutex);
        CompbattReleaseDeleteLock(&batt->DeleteLock);
    }   // for (entry = gBatteries.Flink;  entry != &gBatteries;   entry = entry->Flink)
    ExReleaseFastMutex (&CompBatt->ListMutex);

    BattPrint (BATT_TRACE, ("CompBatt: EXITING GetBatteryGranularity\n"));

    return STATUS_SUCCESS;
}





NTSTATUS
CompBattGetEstimatedTime (
    IN PULONG               TimeBuffer,
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    The routine queries all the batteries in the system to get their estimated time left.
    If one of the batteries in the system does not support this function then an error
    is returned.

Arguments:

    TimeBuffer   - Buffer for containing cumulative time left

Return Value:

    STATUS_SUCCESS or the status returned by the Ioctl to the battery.

--*/
{
    NTSTATUS                    status;
    LONG                        localBuffer = 0;
    PCOMPOSITE_ENTRY            batt;
    PLIST_ENTRY                 entry;
    BATTERY_QUERY_INFORMATION   bInfo;
    BATTERY_STATUS              batteryStatus;
    LONG                        atRate = 0;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING GetEstimatedTime\n"));

    *TimeBuffer = BATTERY_UNKNOWN_TIME;

    //
    // Refresh the composite battery status cache if necessary.
    //

    status = CompBattQueryStatus (CompBatt, CompBatt->Info.Tag, &batteryStatus);

    if (!NT_SUCCESS(status)) {
        return status;
    }


    //
    // If we're on AC then our estimated run time is invalid.
    //

    if (CompBatt->Info.Status.PowerState & BATTERY_POWER_ON_LINE) {
        return STATUS_SUCCESS;
    }

    //
    // We are on battery power and may have more than one battery in the system.
    //
    // We need to find the total rate of power being drawn from all batteries
    // then we need to ask how long each battery would last at that rate (as
    // if they were being discharged one at a time).  This should give us a fairly
    // good measure of how long it will last.
    //
    // To find the power being drawn we read the devide the remaining capacity by
    // the estimated time rather than simply reading the rate.  This is because the
    // rate is theoretically the instantanious current wereas the estimated time
    // should be based on average usage.  This isn't the case for control method
    // batteries, but it is for smart batteries, and could be for others as well.
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }

        ExReleaseFastMutex (&CompBatt->ListMutex);

        if (batt->Info.Valid & VALID_TAG) {

            bInfo.BatteryTag        = batt->Info.Tag;
            bInfo.InformationLevel  = BatteryEstimatedTime;
            bInfo.AtRate = 0;

            //
            // issue IOCTL to device
            //

            status = BatteryIoctl (IOCTL_BATTERY_QUERY_INFORMATION,
                                   batt->DeviceObject,
                                   &bInfo,
                                   sizeof (bInfo),
                                   &localBuffer,
                                   sizeof (localBuffer),
                                   FALSE);


            if ((localBuffer != BATTERY_UNKNOWN_TIME) &&
                (localBuffer != 0) &&
                (NT_SUCCESS(status))) {
                atRate -= ((long)batt->Info.Status.Capacity)*3600 / localBuffer;
                BattPrint (BATT_NOTE, ("CompBattGetEstimatedTime: EstTime: %08x, Capacity: %08x, cumulative AtRate: %08x\n", localBuffer, batt->Info.Status.Capacity, atRate));
            } else {
                BattPrint (BATT_NOTE, ("CompBattGetEstimatedTime: Bad Estimated time.  Status: %08x, localBuffer: %08x, Capacity: %08x, cumulative AtRate: %08x\n",
                        status, localBuffer, batt->Info.Status.Capacity, atRate));
            }
        }

        ExAcquireFastMutex (&CompBatt->ListMutex);
        CompbattReleaseDeleteLock(&batt->DeleteLock);

    }
    ExReleaseFastMutex (&CompBatt->ListMutex);


    BattPrint (BATT_NOTE, ("CompBattGetEstimatedTime: using atRate - %x\n", atRate));

    //
    // Did we find a battery?
    //
    if (atRate == 0) {
        // Code could be added to here to handle batteries that return
        // estimated runtime, but not rate information.

        return STATUS_SUCCESS;

    }

    //
    // Run through the list of batteries getting their estimated time
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
            continue;
        }

        ExReleaseFastMutex (&CompBatt->ListMutex);

        bInfo.BatteryTag        = batt->Info.Tag;
        bInfo.InformationLevel  = BatteryEstimatedTime;

        bInfo.AtRate = atRate;

        if (batt->Info.Valid & VALID_TAG) {
            //
            // issue IOCTL to device
            //

            status = BatteryIoctl (IOCTL_BATTERY_QUERY_INFORMATION,
                                   batt->DeviceObject,
                                   &bInfo,
                                   sizeof (bInfo),
                                   &localBuffer,
                                   sizeof (localBuffer),
                                   FALSE);

            BattPrint (BATT_NOTE, ("CompBattGetEstimatedTime: Status: %08x, EstTime: %08x\n", status, localBuffer));
            if (!NT_SUCCESS(status)) {

                //
                // This could be an invalid device request for this battery.
                // Continue with thte next battery.
                //

                if (status == STATUS_DEVICE_REMOVED) {
                    //
                    // If one device is removed, that invalidates the tag.
                    //
                    status = STATUS_NO_SUCH_DEVICE;
                }

                ExAcquireFastMutex (&CompBatt->ListMutex);
                CompbattReleaseDeleteLock(&batt->DeleteLock);
                continue;

            }

            //
            // Add the estimated time.
            //
            if (localBuffer != BATTERY_UNKNOWN_TIME) {
                if (*TimeBuffer == BATTERY_UNKNOWN_TIME) {
                    *TimeBuffer = localBuffer;
                } else {
                    *TimeBuffer += localBuffer;
                }
            }
            BattPrint (BATT_DATA, ("CompBattGetEstimatedTime: cumulative time: %08x\n", *TimeBuffer));

        }   // if (batt->Tag != BATTERY_TAG_INVALID)

        ExAcquireFastMutex (&CompBatt->ListMutex);
        CompbattReleaseDeleteLock(&batt->DeleteLock);
    }   // for (entry = gBatteries.Flink;  entry != &gBatteries;   entry = entry->Flink)
    ExReleaseFastMutex (&CompBatt->ListMutex);


    BattPrint (BATT_TRACE, ("CompBatt: EXITING GetEstimatedTime\n"));

    return STATUS_SUCCESS;
}




NTSTATUS
CompBattMonitorIrpComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    Constantly keeps an irp at the battery either querying for the tag or the
    status.  This routine fills in the irp, sets itself up as the completion
    routine, and then resends the irp.

Arguments:

    DeviceObject        - Device object for the battery sent the irp.
    Note: In this case DeviceObject is always NULL, so don't use it.

    Irp                 - Current irp to work with

    Context             - Currently unused

Return Value:

    TRUE if there are no changes, FALSE otherwise.

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    PCOMPOSITE_ENTRY        Batt;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING MonitorIrpComplete\n"));

    IrpSp           = IoGetCurrentIrpStackLocation(Irp);
    Batt            = IrpSp->Parameters.Others.Argument2;

    //
    // We always want to queue a work item to recycle the IRP.  There were too many
    // problems that could happen trying to recycle in the completion routine.
    //
    // If this driver ever gets reworked, it could be done that way, but it would take
    // more time to get right than I have now.  Queueing a work item is the safe thing
    // to do.
    //

    ExQueueWorkItem (&Batt->WorkItem, DelayedWorkQueue);

    return STATUS_MORE_PROCESSING_REQUIRED;

}

VOID CompBattMonitorIrpCompleteWorker (
    IN PVOID Context
    )
/*++

Routine Description:

    This is either queued, or called by the completion routine.

    Constantly keeps an irp at the battery either querying for the tag or the
    status.  This routine fills in the irp, sets itself up as the completion
    routine, and then resends the irp.

Arguments:

    Context             - Composite battery entry.

Return Value:

    TRUE if there are no changes, FALSE otherwise.

--*/
{
    PCOMPOSITE_ENTRY        Batt = (PCOMPOSITE_ENTRY) Context;
    PDEVICE_OBJECT          DeviceObject = Batt->DeviceObject;
    PIRP                    Irp = Batt->StatusIrp;
    PIO_STACK_LOCATION      IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PCOMPOSITE_BATTERY      compBatt = IrpSp->Parameters.Others.Argument1;
    BATTERY_STATUS          battStatus;
    ULONG                   oldPowerState;
    NTSTATUS                status;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING MonitorIrpCompleteWorker\n"));

    IrpSp           = IoGetNextIrpStackLocation(Irp);

    //
    // Reissue irp to battery to wait for a status change
    //

    if (NT_SUCCESS(Irp->IoStatus.Status) || Irp->IoStatus.Status == STATUS_CANCELLED) {
        switch (Batt->State) {
            case CB_ST_GET_TAG:
                //
                // A battery was just inserted, so the IOCTL_BATTERY_Query_TAG completed.
                //

                BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: got tag for %x\n", Batt->DeviceObject));

                //
                // Update the tag, and wait on status
                //
                Batt->Wait.BatteryTag   = Batt->IrpBuffer.Tag;
                Batt->Info.Tag          = Batt->IrpBuffer.Tag;
                Batt->Info.Valid        = VALID_TAG;

                // Invalidate all cached info.
                compBatt->Info.Valid    = 0;

                BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: calling StatusNotify\n"));
                BatteryClassStatusNotify (compBatt->Class);
                break;


            case CB_ST_GET_STATUS:
                //
                // IOCTL_BATTERY_QUERY_STATUS just completed.  This could mean that the
                // battery state changed, or the charge has left the acceptable range.
                // If the battery was removed, it would not get here.
                //

                BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: got status for %x\n", Batt->DeviceObject));

                if (!(Irp->IoStatus.Status == STATUS_CANCELLED)) {

                    BattPrint (BATT_NOTE, ("Battery's state is\n"
                               "--------  PowerState   = %x\n"
                               "--------  Capacity     = %x\n"
                               "--------  Voltage      = %x\n"
                               "--------  Rate         = %x\n",
                               Batt->IrpBuffer.Status.PowerState,
                               Batt->IrpBuffer.Status.Capacity,
                               Batt->IrpBuffer.Status.Voltage,
                               Batt->IrpBuffer.Status.Rate)
                               );


                    //
                    // Battery status completed sucessfully.
                    // Update our wait, and wait some more
                    //

                    Batt->Wait.PowerState = Batt->IrpBuffer.Status.PowerState;

                    if (Batt->IrpBuffer.Status.Capacity != BATTERY_UNKNOWN_CAPACITY) {
                        if (Batt->Wait.HighCapacity < Batt->IrpBuffer.Status.Capacity) {
                            Batt->Wait.HighCapacity = Batt->IrpBuffer.Status.Capacity;
                        }

                        if (Batt->Wait.LowCapacity > Batt->IrpBuffer.Status.Capacity) {
                            Batt->Wait.LowCapacity = Batt->IrpBuffer.Status.Capacity;
                        }
                    } else {
                        BattPrint (BATT_DEBUG, ("CompBattMonitorIrpCompleteWorker: Unknown Capacity encountered.\n"));
                        Batt->Wait.LowCapacity = BATTERY_UNKNOWN_CAPACITY;
                        Batt->Wait.HighCapacity = BATTERY_UNKNOWN_CAPACITY;
                    }

                    RtlCopyMemory (&Batt->Info.Status, &Batt->IrpBuffer.Status, sizeof(BATTERY_STATUS));

                    //
                    // Set timestamp to Now.
                    //

                    Batt->Info.StatusTimeStamp = KeQueryInterruptTime ();

                    //
                    // Recalculate the charge/discharge policy and change if needed
                    //

                    // Don't change default BIOS policy for discharge.
                    // CompBattChargeDischarge (compBatt);

                    //
                    // Save the composite's old PowerState and recalculate the composites
                    // overall status.
                    //

                    oldPowerState                   = compBatt->Info.Status.PowerState;
                    compBatt->Info.StatusTimeStamp  = 0; // -CACHE_STATUS_TIMEOUT;        // Invalidate cache
                    CompBattQueryStatus (compBatt, compBatt->Info.Tag, &battStatus);

                    //
                    // Check to see if we need to send a notification on the composite
                    // battery.  This will be done in a couple of different cases:
                    //
                    //  -   There is a VALID_NOTIFY and there was a change in the composite's
                    //      PowerState, or it went below the Notify.LowCapacity, or it went
                    //      above the Notify.HighCapacity.
                    //
                    //  -   There is no VALID_NOTIFY (SetStatusNotify) and there was a change
                    //      in the composite's PowerState.
                    //

                    if (compBatt->Info.Valid & VALID_NOTIFY) {
                        if ((compBatt->Info.Status.PowerState != compBatt->Wait.PowerState)    ||
                            (compBatt->Info.Status.Capacity < compBatt->Wait.LowCapacity)      ||
                            (compBatt->Info.Status.Capacity > compBatt->Wait.HighCapacity)) {

                            BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: calling StatusNotify\n"));
                            BatteryClassStatusNotify (compBatt->Class);
                        }
                    } else {
                        if (compBatt->Info.Status.PowerState != oldPowerState) {
                            BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: calling StatusNotify\n"));
                            BatteryClassStatusNotify (compBatt->Class);
                        }
                    }

                } else {

                    BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: recycling cancelled status irp\n"));
                }
                break;

            default:
                BattPrint (BATT_ERROR, ("CompBatt: internal error - bad state\n"));
                break;
        }

        //
        // Set irp to issue query
        //

#if DEBUG
        if ((Batt->Wait.LowCapacity > 0xf0000000) && (Batt->Wait.LowCapacity != BATTERY_UNKNOWN_CAPACITY)) {
            BattPrint (BATT_ERROR, ("CompBattMonitorIrpCompleteWorker: LowCapacity < 0, LowCapacity =%x\n",
                       Batt->Wait.LowCapacity));
            ASSERT(FALSE);
        }
#endif

        Batt->State         = CB_ST_GET_STATUS;
        Batt->Wait.Timeout  = (ULONG) -1;
        RtlCopyMemory (&Batt->IrpBuffer.Wait, &Batt->Wait, sizeof (Batt->Wait));

        IrpSp->Parameters.DeviceIoControl.IoControlCode         = IOCTL_BATTERY_QUERY_STATUS;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength     = sizeof(Batt->IrpBuffer.Wait);
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength    = sizeof(Batt->IrpBuffer.Status);

        BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: waiting for status, Irp - %x\n", Irp));
        BattPrint (BATT_NOTE, ("--------  PowerState   = %x\n"
                               "--------  LowCapacity  = %x\n"
                               "--------  HighCapacity = %x\n",
                               Batt->Wait.PowerState,
                               Batt->Wait.LowCapacity,
                               Batt->Wait.HighCapacity)
                               );

    } else if (Irp->IoStatus.Status == STATUS_DEVICE_REMOVED) {

        //
        // If the Battery class driver returned STATUS_DEVICE_REMOVED, then the
        // device has been removed, so we need to quit sending IRPs.
        //

        BattPrint (BATT_NOTE, ("Compbatt: MonitorIrpCompleteWorker detected device removal.\n"));
        CompBattRemoveBattery (&Batt->BattName, compBatt);
        IoFreeIrp (Irp);

        return;

    } else {
        BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: battery disappeared (status:%08x)\n",
                                Irp->IoStatus.Status));

        //
        // Invalidate the battery's tag, and the individual battery's cache, and
        // recalculate the composite's tag
        //

        Batt->Info.Tag          = BATTERY_TAG_INVALID;
        Batt->Info.Valid        = 0;
        compBatt->Info.Valid    = 0;
        compBatt->Info.StatusTimeStamp  = 0;        // Invalidate cache

        BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: calling StatusNotify\n"));
        BatteryClassStatusNotify (compBatt->Class);

        Batt->State = CB_ST_GET_TAG;
        IrpSp->Parameters.DeviceIoControl.IoControlCode         = IOCTL_BATTERY_QUERY_TAG;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength     = sizeof(ULONG);
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength    = sizeof(ULONG);
        Batt->IrpBuffer.Tag = (ULONG) -1;


        BattPrint (BATT_NOTE, ("CompBattMonitorIrpCompleteWorker: getting tag (last error %x)\n",
                Irp->IoStatus.Status));

    }


    IrpSp->MajorFunction            = IRP_MJ_DEVICE_CONTROL;
    Irp->AssociatedIrp.SystemBuffer = &Batt->IrpBuffer;
    Irp->PendingReturned            = FALSE;
    Irp->Cancel                     = FALSE;

    IoSetCompletionRoutine (Irp, CompBattMonitorIrpComplete, NULL, TRUE, TRUE, TRUE);
    status = IoCallDriver (Batt->DeviceObject, Irp);
    BattPrint (BATT_NOTE, ("Compbatt: MonitorIrpCompleteWorker: CallDriver returned 0x%lx.\n", status));

    BattPrint (BATT_TRACE, ("CompBatt: EXITING MonitorIrpCompleteWorker\n"));

    return;
}






VOID
CompBattRecalculateTag (
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    The routine checks to see if there is still a valid battery in the
    composite's list.  If so, the composite tag is bumped.  This also
    invalidates all but the composite's tag.

Arguments:

    CompBatt    - Composite device extension

Return Value:

    none

--*/
{
    PCOMPOSITE_ENTRY            batt;
    PLIST_ENTRY                 entry;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING CompBattRecalculateTag\n"));


    //
    // Run through the list of batteries looking for one that is still good
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);


        if (batt->Info.Valid & VALID_TAG) {
            CompBatt->Info.Valid   |= VALID_TAG;
            CompBatt->Info.Tag      = CompBatt->NextTag++;
            break;
        }

        CompBatt->Info.Tag = BATTERY_TAG_INVALID;
    }
    ExReleaseFastMutex (&CompBatt->ListMutex);

    BattPrint (BATT_TRACE, ("CompBatt: EXITING CompBattRecalculateTag\n"));
}






VOID
CompBattChargeDischarge (
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    The routine calculates which battery should be charging/discharging
    and attempts to make it so.  Policy is summarized below:

    CHARGING POLICY:
        The most charged battery that is also less than 90% of maximum capacity
        is charged first.

    DISCHARGING POLICY:
        The most discharged battery that is also more than 2% of empty is discharged
        first, until it is empty.

Arguments:

    CompBatt    - Composite device extension

Return Value:

    NONE.  Nobody really cares if this works or not, since it won't work on all batteries.

--*/
{
    PCOMPOSITE_ENTRY            batt;
    PLIST_ENTRY                 entry;
    ULONG                       capacity;
    ULONG                       percentCapacity;
    ULONG                       targetCapacity;
    PCOMPOSITE_ENTRY            targetBattery;
    BATTERY_SET_INFORMATION     battSetInfo;
    NTSTATUS                    status;


    BattPrint (BATT_TRACE, ("CompBatt: ENTERING CompBattChargeDischarge\n"));

    targetBattery = NULL;

    //
    // Check if AC is present in the system.
    //

    if (CompBatt->Info.Status.PowerState & BATTERY_POWER_ON_LINE) {

        //
        // AC is present.  Examine all batteries, looking for the most
        // charged one that is less than 90% full.
        //

        targetCapacity = 0;
        battSetInfo.InformationLevel = BatteryCharge;

        ExAcquireFastMutex (&CompBatt->ListMutex);
        for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

            batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

            if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
                continue;
            }

            if (batt->Info.Valid & VALID_TAG) {

                //
                // Get the battery max capacity and current % of capacity
                //

                capacity = batt->Info.Info.FullChargedCapacity;
                if (capacity == 0) {
                    CompbattReleaseDeleteLock(&batt->DeleteLock);
                    break;
                }

                percentCapacity = (batt->Info.Status.Capacity * 100) / capacity;

                //
                // Is this the most charged battery AND < 90% full?
                //

                if ((capacity > targetCapacity) && (percentCapacity < BATTERY_MAX_CHARGE_CAPACITY)) {

                    //
                    // Yes, this one is in the running for the one to charge
                    //

                    targetCapacity = capacity;
                    targetBattery = batt;
                }
            }

            CompbattReleaseDeleteLock(&batt->DeleteLock);

        }
        ExReleaseFastMutex (&CompBatt->ListMutex);

        BattPrint (BATT_NOTE, ("CompBattChargeDischarge: Setting battery %x to CHARGE (AC present)\n",
                                targetBattery));

    } else {

        //
        // We are running on battery power.  Examine all batteries, looking
        // for the one with the least capacity that is greater than some small
        // safety margin (say 2%).
        //

        targetCapacity = -1;
        battSetInfo.InformationLevel = BatteryDischarge;

        ExAcquireFastMutex (&CompBatt->ListMutex);
        for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

            batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

            if (!NT_SUCCESS (CompbattAcquireDeleteLock(&batt->DeleteLock))) {
                continue;
            }

            if (batt->Info.Valid & VALID_TAG) {

                //
                // Get the battery max capacity and current % of capacity
                //

                capacity = batt->Info.Info.FullChargedCapacity;
                if (capacity == 0) {
                    CompbattReleaseDeleteLock(&batt->DeleteLock);
                    break;
                }

                percentCapacity = (batt->Info.Status.Capacity * 100) / capacity;

                //
                // Is this the least charged battery AND has a safety margin?
                //

                if ((capacity < targetCapacity) && (percentCapacity > BATTERY_MIN_SAFE_CAPACITY)) {

                    //
                    // Yes, this one is in the running for the one to discharge
                    //

                    targetCapacity = capacity;
                    targetBattery = batt;
                }
            }

            CompbattReleaseDeleteLock(&batt->DeleteLock);

        }
        ExReleaseFastMutex (&CompBatt->ListMutex);

        BattPrint (BATT_NOTE, ("CompBattChargeDischarge: Setting battery %x to DISCHARGE (no AC)\n",
                                targetBattery));

    }

    //
    // If we have found a suitable battery, complete the setup and send off the Ioctl
    //

    if (targetBattery != NULL) {

        battSetInfo.BatteryTag = targetBattery->Info.Tag;

        //
        // Make the Ioctl to the battery.  This won't always be successful, since some
        // batteries don't support it.  For example, no control-method batteries support
        // software charging decisions.  Some smart batteries do, however.
        //

        status = BatteryIoctl (IOCTL_BATTERY_SET_INFORMATION,
                                batt->DeviceObject,
                                &battSetInfo,
                                sizeof (BATTERY_SET_INFORMATION),
                                NULL,
                                0,
                                FALSE);

    }


    BattPrint (BATT_TRACE, ("CompBatt: EXITING CompBattChargeDischarge\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\compbatt\compmisc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    battmisc.c

Abstract:

    Miscellaneous functions needed by the composite battery to talk to
    the batteries in the system.

Author:

    Scott Brenden

Environment:

Notes:


Revision History:

--*/

#include "compbatt.h"



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BatteryIoctl)
#pragma alloc_text(PAGE, CompBattGetDeviceObjectPointer)
#endif



NTSTATUS
BattIoctlComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT         Event;

    Event = (PKEVENT) Context;
    KeSetEvent (Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}




NTSTATUS
BatteryIoctl(
    IN ULONG            Ioctl,
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    IN PVOID            OutputBuffer,
    IN ULONG            OutputBufferLength,
    IN BOOLEAN          PrivateIoctl
    )
/*++

Routine Description:

    The routine Creates an IRP and does Ioctl to the device object passed in.

Arguments:

    Ioctl               - code for the Ioctl

    DeviceObject        - Device object to send the ioctl to

    InputBuffer         - Input buffer for the ioctl

    InputBufferLength   - length of the input buffer

    OutputBuffer        - Buffer for containing the results of the ioctl

    OutputBufferLength  - Length of the output buffer

    PrivateIoctl        - TRUE if this is to be an IRP_MJ_DEVICE_CONTROL, FALSE
                          if this is to be an IRP_MJ_INTERNAL_DEVICE_CONTROL.

Return Value:

    Status returned by the Ioctl

--*/
{
    NTSTATUS                status;
    IO_STATUS_BLOCK         IOSB;
    PIRP                    irp;
    KEVENT                 event;
    // PUCHAR                  buffer;
    // ULONG                   bufferSize;
    // PIO_STACK_LOCATION      irpSp;


    PAGED_CODE();

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING BatteryIoctl\n"));

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Build synchronous request with no transfer.
    //

    irp = IoBuildDeviceIoControlRequest(
                Ioctl,
                DeviceObject,
                InputBuffer,
                InputBufferLength,
                OutputBuffer,
                OutputBufferLength,
                PrivateIoctl,
                &event,
                &IOSB
                   );

    if (irp == NULL) {
        BattPrint (BATT_ERROR, ("BatteryIoctl: couldn't create Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Pass request to port driver and wait for request to complete.
    //

    status = IoCallDriver(DeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = IOSB.Status;
    }

    if (!NT_SUCCESS(status)) {
        BattPrint (BATT_ERROR, ("BatteryIoctl: Irp failed - %x\n", status));
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING BatteryIoctl\n"));

    return status;
}




BOOLEAN
IsBatteryAlreadyOnList(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    The routine runs through the list of batteries the composite keeps and checks
    to see if the symbolic link name passed in matches one of them.

Arguments:

    SymbolicLinkName    - Name for battery to check if already on list


Return Value:

    TRUE if the SymbolicLinkName belongs to a battery already on the list, FALSE
    otherwise.
--*/
{
    PCOMPOSITE_ENTRY        batt;
    PLIST_ENTRY             entry;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING IsBatteryAlreadyOnList\n"));

    //
    // Run through the list of batteries looking for new batteries
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!RtlCompareUnicodeString(SymbolicLinkName, &batt->BattName, TRUE)) {
            //
            // The battery is already on the list
            //

            ExReleaseFastMutex (&CompBatt->ListMutex);
            return TRUE;
        }
    }

    BattPrint (BATT_TRACE, ("CompBatt: EXITING IsBatteryAlreadyOnList\n"));

    ExReleaseFastMutex (&CompBatt->ListMutex);

    return FALSE;
}

PCOMPOSITE_ENTRY
RemoveBatteryFromList(
    IN PUNICODE_STRING      SymbolicLinkName,
    IN PCOMPOSITE_BATTERY   CompBatt
    )
/*++

Routine Description:

    The routine runs through the list of batteries the composite keeps and checks
    to see if the symbolic link name passed in matches one of them.  If a match is found,
    the entry is removed from the list of batteries

Arguments:

    SymbolicLinkName    - Name for battery to check if already on list


Return Value:

    TRUE if the SymbolicLinkName was found and deleted. FALSE otherwise.
--*/
{
    PCOMPOSITE_ENTRY        batt;
    PLIST_ENTRY             entry;

    BattPrint (BATT_TRACE, ("CompBatt: ENTERING RemoveBatteryFromList\n"));

    //
    // Run through the list of batteries looking for new batteries
    //

    ExAcquireFastMutex (&CompBatt->ListMutex);
    for (entry = CompBatt->Batteries.Flink; entry != &CompBatt->Batteries;  entry = entry->Flink) {

        batt = CONTAINING_RECORD (entry, COMPOSITE_ENTRY, Batteries);

        if (!RtlCompareUnicodeString(SymbolicLinkName, &batt->BattName, TRUE)) {
            //
            // The battery is on the list, remove
            //

            //
            // Wait until no one else is looking at this battery before removing it.
            //

            CompbattAcquireDeleteLock (&batt->DeleteLock);

            ExReleaseFastMutex (&CompBatt->ListMutex);

            CompbattReleaseDeleteLockAndWait (&batt->DeleteLock);


            ExAcquireFastMutex (&CompBatt->ListMutex);
            RemoveEntryList(entry);
            ExReleaseFastMutex (&CompBatt->ListMutex);

            return batt;
        }
    }

    ExReleaseFastMutex (&CompBatt->ListMutex);

    BattPrint (BATT_TRACE, ("CompBatt: EXITING RemoveBatteryFromList\n"));

    return NULL;
}

NTSTATUS
CompBattGetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    This routine is essentially a copy from ntos\io\iosubs.c
    The reason for this is that we need to open the device with shared access
    rather than exclusive access.  In addition  ZwCreateFile was used instead of
    ZwOpenFile becuase that didn't seem to complie right when only wdm.h instead
    of ntddk.h was included.

    This routine returns a pointer to the device object specified by the
    object name.  It also returns a pointer to the referenced file object
    that has been opened to the device that ensures that the device cannot
    go away.

    To close access to the device, the caller should dereference the file
    object pointer.

Arguments:

    ObjectName - Name of the device object for which a pointer is to be
        returned.

    DesiredAccess - Access desired to the target device object.

    FileObject - Supplies the address of a variable to receive a pointer
        to the file object for the device.

    DeviceObject - Supplies the address of a variable to receive a pointer
        to the device object for the specified device.

Return Value:

    The function value is a referenced pointer to the specified device
    object, if the device exists.  Otherwise, NULL is returned.

--*/

{
    PFILE_OBJECT fileObject;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the object attributes to open the device.
    //

    InitializeObjectAttributes( &objectAttributes,
                                ObjectName,
                                0,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwCreateFile (
                    &fileHandle,
                    DesiredAccess,     // desired access
                    &objectAttributes,
                    &ioStatus,
                    (PLARGE_INTEGER) NULL,
                    0L,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
                    FILE_OPEN,
                    0,
                    NULL,
                    0);

    if (NT_SUCCESS( status )) {

        //
        // The open operation was successful.  Dereference the file handle
        // and obtain a pointer to the device object for the handle.
        //

        status = ObReferenceObjectByHandle( fileHandle,
                                            0,
                                            *IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &fileObject,
                                            NULL );
        if (NT_SUCCESS( status )) {

            *FileObject = fileObject;

            //
            // Get a pointer to the device object for this file.
            //
            *DeviceObject = IoGetRelatedDeviceObject( fileObject );
        }

        (VOID) ZwClose( fileHandle );
    }

    return status;
}

//
// Delete Lock routines from io\remlock.c
//

VOID
CompbattInitializeDeleteLock (
        IN PCOMPBATT_DELETE_LOCK Lock
        )
{
    Lock->Deleted = FALSE;
    Lock->RefCount = 1;
    KeInitializeEvent(&Lock->DeleteEvent,
                      SynchronizationEvent,
                      FALSE);

}

NTSTATUS
CompbattAcquireDeleteLock (
        IN PCOMPBATT_DELETE_LOCK Lock
        )
{
    LONG        lockValue;

    lockValue = InterlockedIncrement(&Lock->RefCount);

    if (Lock->Deleted) {
        if (0 == InterlockedDecrement (&Lock->RefCount)) {
            KeSetEvent (&Lock->DeleteEvent, 0, FALSE);
        }

        return STATUS_DELETE_PENDING;
    }

    return STATUS_SUCCESS;

}

VOID
CompbattReleaseDeleteLock (
        IN PCOMPBATT_DELETE_LOCK Lock
        )
{
    if (0 == InterlockedDecrement(&Lock->RefCount)) {

        KeSetEvent(&Lock->DeleteEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }
}

VOID
CompbattReleaseDeleteLockAndWait (
        IN PCOMPBATT_DELETE_LOCK Lock
        )
{
    Lock->Deleted = TRUE;

    InterlockedDecrement (&Lock->RefCount);

    if (0 < InterlockedDecrement (&Lock->RefCount)) {
        KeWaitForSingleObject (&Lock->DeleteEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\acpins.c ===
/*** acpins.c - ACPI Name Space functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/09/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  GetNameSpaceObject - Find a name space object
 *
 *  ENTRY
 *      pszObjPath -> object path string
 *      pnsScope - object scope to start the search (NULL means root)
 *      ppnsObj -> to hold the object found
 *      dwfNS - flags
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL GetNameSpaceObject(PSZ pszObjPath, PNSOBJ pnsScope, PPNSOBJ ppns,
                                  ULONG dwfNS)
{
    TRACENAME("GETNAMESPACEOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PSZ psz;

    ENTER(3, ("GetNameSpaceObject(ObjPath=%s,Scope=%s,ppns=%x,Flags=%x)\n",
              pszObjPath, GetObjectPath(pnsScope), ppns, dwfNS));

    if (pnsScope == NULL)
        pnsScope = gpnsNameSpaceRoot;

    if (*pszObjPath == '\\')
    {
        psz = &pszObjPath[1];
        pnsScope = gpnsNameSpaceRoot;
    }
    else
    {
        psz = pszObjPath;

        while ((*psz == '^') && (pnsScope != NULL))
        {
            psz++;
            pnsScope = pnsScope->pnsParent;
        }
    }

    *ppns = pnsScope;

    if (pnsScope == NULL)
        rc = AMLIERR_OBJ_NOT_FOUND;
    else if (*psz != '\0')
    {
        BOOLEAN fSearchUp;
        PNSOBJ pns;

        fSearchUp = (BOOLEAN)(!(dwfNS & NSF_LOCAL_SCOPE) &&
                              (pszObjPath[0] != '\\') &&
                              (pszObjPath[0] != '^') &&
                              (STRLEN(pszObjPath) <= sizeof(NAMESEG)));
        for (;;)
        {
            do
            {
                if ((pns = pnsScope->pnsFirstChild) == NULL)
                    rc = AMLIERR_OBJ_NOT_FOUND;
                else
                {
                    BOOLEAN fFound;
                    PSZ pszEnd;
                    ULONG dwLen;
                    NAMESEG dwName;

                    if ((pszEnd = STRCHR(psz, '.')) != NULL)
                        dwLen = (ULONG)(pszEnd - psz);
                    else
                        dwLen = STRLEN(psz);

                    if (dwLen > sizeof(NAMESEG))
                    {
                        rc = AMLI_LOGERR(AMLIERR_INVALID_NAME,
                                         ("GetNameSpaceObject: invalid name - %s",
                                          pszObjPath));

                        // Satisfy the compiler...
                        fFound = FALSE;
                    }
                    else
                    {
                        dwName = NAMESEG_BLANK;
                        MEMCPY(&dwName, psz, dwLen);
                        //
                        // Search all siblings for a matching NameSeg.
                        //
                        fFound = FALSE;
                        do
                        {
                            if (pns->dwNameSeg == dwName)
                            {
                                pnsScope = pns;
                                fFound = TRUE;
                                break;
                            }
                            pns = (PNSOBJ)pns->list.plistNext;
                        } while (pns != pns->pnsParent->pnsFirstChild);
                    }

                    if (rc == STATUS_SUCCESS)
                    {
                        if (!fFound)
                            rc = AMLIERR_OBJ_NOT_FOUND;
                        else
                        {
                            psz += dwLen;
                            if (*psz == '.')
                            {
                                psz++;
                            }
                else if (*psz == '\0')
                            {
                                *ppns = pnsScope;
                                break;
                            }
                        }
                    }
                }
            } while (rc == STATUS_SUCCESS);

            if ((rc == AMLIERR_OBJ_NOT_FOUND) && fSearchUp &&
                (pnsScope != NULL) && (pnsScope->pnsParent != NULL))
            {
                pnsScope = pnsScope->pnsParent;
                rc = STATUS_SUCCESS;
            }
            else
            {
                break;
            }
        }
    }

    if ((dwfNS & NSF_WARN_NOTFOUND) && (rc == AMLIERR_OBJ_NOT_FOUND))
    {
        rc = AMLI_LOGERR(rc, ("GetNameSpaceObject: object %s not found",
                              pszObjPath));
    }

    if (rc != STATUS_SUCCESS)
    {
        *ppns = NULL;
    }

    EXIT(3, ("GetNameSpaceObject=%x (pns=%x)\n", rc, *ppns));
    return rc;
}       //GetNameSpaceObject

/***LP  CreateNameSpaceObject - Create a name space object under current scope
 *
 *  ENTRY
 *      pheap -> HEAP
 *      pszName -> name string of the object (NULL if creating noname object)
 *      pnsScope - scope to create object under (NULL means root)
 *      powner -> object owner
 *      ppns -> to hold the pointer to the new object (can be NULL)
 *      dwfNS - flags
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateNameSpaceObject(PHEAP pheap, PSZ pszName, PNSOBJ pnsScope,
                                     POBJOWNER powner, PPNSOBJ ppns,
                                     ULONG dwfNS)
{
    TRACENAME("CREATENAMESPACEOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pns = NULL;

    ENTER(3, ("CreateNameSpaceObject(pheap=%x,Name=%s,pnsScope=%x,powner=%x,ppns=%x,Flags=%x)\n",
              pheap, pszName? pszName: "<null>", pnsScope, powner, ppns, dwfNS));

    if (pnsScope == NULL)
        pnsScope = gpnsNameSpaceRoot;

    if (pszName == NULL)
    {
        if ((pns = NEWNSOBJ(pheap, sizeof(NSOBJ))) == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("CreateNameSpaceObject: fail to allocate name space object"));
        }
        else
        {
            ASSERT(gpnsNameSpaceRoot != NULL);
            MEMZERO(pns, sizeof(NSOBJ));
            pns->pnsParent = pnsScope;
            InsertOwnerObjList(powner, pns);
            ListInsertTail(&pns->list,
                           (PPLIST)&pnsScope->pnsFirstChild);
        }
    }
    else if ((*pszName != '\0') &&
             ((rc = GetNameSpaceObject(pszName, pnsScope, &pns,
                                       NSF_LOCAL_SCOPE)) == STATUS_SUCCESS))
    {
        if (!(dwfNS & NSF_EXIST_OK))
        {
            rc = AMLI_LOGERR(AMLIERR_OBJ_ALREADY_EXIST,
                             ("CreateNameSpaceObject: object already exist - %s",
                              pszName));
        }
    }
    else if ((*pszName == '\0') || (rc == AMLIERR_OBJ_NOT_FOUND))
    {
        rc = STATUS_SUCCESS;
        //
        // Are we creating root?
        //
        if (STRCMP(pszName, "\\") == 0)
        {
            ASSERT(gpnsNameSpaceRoot == NULL);
            ASSERT(powner == NULL);
            if ((pns = NEWNSOBJ(pheap, sizeof(NSOBJ))) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("CreateNameSpaceObject: fail to allocate name space object"));
            }
            else
            {
                MEMZERO(pns, sizeof(NSOBJ));
                pns->dwNameSeg = NAMESEG_ROOT;
                gpnsNameSpaceRoot = pns;
                InsertOwnerObjList(powner, pns);
            }
        }
        else
        {
            PSZ psz;
            PNSOBJ pnsParent;

            if ((psz = STRRCHR(pszName, '.')) != NULL)
            {
                *psz = '\0';
                psz++;
                rc = GetNameSpaceObject(pszName, pnsScope, &pnsParent,
                                        NSF_LOCAL_SCOPE | NSF_WARN_NOTFOUND);
            }
            else if (*pszName == '\\')
            {
                psz = &pszName[1];
                //
                // By this time, we'd better created root already.
                //
                ASSERT(gpnsNameSpaceRoot != NULL);
                pnsParent = gpnsNameSpaceRoot;
            }
            else if (*pszName == '^')
            {
                psz = pszName;
                pnsParent = pnsScope;
                while ((*psz == '^') && (pnsParent != NULL))
                {
                    pnsParent = pnsParent->pnsParent;
                    psz++;
                }
            }
            else
            {
                ASSERT(pnsScope != NULL);
                psz = pszName;
                pnsParent = pnsScope;
            }

            if (rc == STATUS_SUCCESS)
            {
                int iLen = STRLEN(psz);

                if ((*psz != '\0') && (iLen > sizeof(NAMESEG)))
                {
                    rc = AMLI_LOGERR(AMLIERR_INVALID_NAME,
                                     ("CreateNameSpaceObject: invalid name - %s",
                                      psz));
                }
                else if ((pns = NEWNSOBJ(pheap, sizeof(NSOBJ)))
                         == NULL)
                {
                    rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                     ("CreateNameSpaceObject: fail to allocate name space object"));
                }
                else
                {
                    MEMZERO(pns, sizeof(NSOBJ));

                    if (*pszName == '\0')
                        pns->dwNameSeg = NAMESEG_NONE;
                    else
                    {
                        pns->dwNameSeg = NAMESEG_BLANK;
                        MEMCPY(&pns->dwNameSeg, psz, iLen);
                    }

                    pns->pnsParent = pnsParent;
                    InsertOwnerObjList(powner, pns);
                    ListInsertTail(&pns->list,
                                   (PPLIST)&pnsParent->pnsFirstChild);
                }
            }
        }
    }

    if ((rc == STATUS_SUCCESS) && (ppns != NULL))
        *ppns = pns;

    EXIT(3, ("CreateNameSpaceObject=%x (pns=%x)\n", rc, pns));
    return rc;
}       //CreateNameSpaceObject

/***LP  FreeNameSpaceObjects - Free Name Space object and its children
 *
 *  ENTRY
 *      pnsObj -> name space object
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeNameSpaceObjects(PNSOBJ pnsObj)
{
    TRACENAME("FREENAMESPACEOBJECTS")
    PNSOBJ pns, pnsSibling, pnsParent;
  #ifdef DEBUGGER
    POBJSYM pos;
  #endif

    ENTER(3, ("FreeNameSpaceObjects(Obj=%s)\n", GetObjectPath(pnsObj)));

    ASSERT(pnsObj != NULL);

    for (pns = pnsObj; pns != NULL;)
    {
        while (pns->pnsFirstChild != NULL)
        {
            pns = pns->pnsFirstChild;
        }

        pnsSibling = NSGETNEXTSIBLING(pns);
        pnsParent = NSGETPARENT(pns);

        ENTER(4, ("FreeNSObj(Obj=%s)\n", GetObjectPath(pns)));
      #ifdef DEBUGGER
        //
        // If I am in the symbol list, get rid of it before I die.
        //
        for (pos = gDebugger.posSymbolList; pos != NULL; pos = pos->posNext)
        {
            if (pns == pos->pnsObj)
            {
                if (pos->posPrev != NULL)
                    pos->posPrev->posNext = pos->posNext;

                if (pos->posNext != NULL)
                    pos->posNext->posPrev = pos->posPrev;

                if (pos == gDebugger.posSymbolList)
                    gDebugger.posSymbolList = pos->posNext;

                FREESYOBJ(pos);
                break;
            }
        }
      #endif

        //
        // All my children are gone, I must die now.
        //
        ASSERT(pns->pnsFirstChild == NULL);

        if ((pns->ObjData.dwDataType == OBJTYPE_OPREGION) &&
            (((POPREGIONOBJ)pns->ObjData.pbDataBuff)->bRegionSpace ==
             REGSPACE_MEM))
        {
            ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

            if(((POPREGIONOBJ)pns->ObjData.pbDataBuff)->dwLen)
            {
                MmUnmapIoSpace((PVOID)
                               ((POPREGIONOBJ)pns->ObjData.pbDataBuff)->uipOffset,
                               ((POPREGIONOBJ)pns->ObjData.pbDataBuff)->dwLen);
            }
        }

        if (pns->pnsParent == NULL)
        {
            //
            // I am root!
            //
            ASSERT(pns == gpnsNameSpaceRoot);
            gpnsNameSpaceRoot = NULL;
        }
        else
        {
            ListRemoveEntry(&pns->list,
                            (PPLIST)&pns->pnsParent->pnsFirstChild);
        }
        //
        // Free any attached data buffer if any
        //
        FreeDataBuffs(&pns->ObjData, 1);
        //
        // Free myself
        //
        if (pns->dwRefCount == 0)
        {
            FREENSOBJ(pns);
        }
        else
        {
            pns->ObjData.dwfData |= DATAF_NSOBJ_DEFUNC;
            ListInsertTail(&pns->list, &gplistDefuncNSObjs);
        }
        EXIT(4, ("FreeNSObj!\n"));

        if (pns == pnsObj)
        {
            //
            // I was the last one, done!
            //
            pns = NULL;
        }
        else if (pnsSibling != NULL)
        {
            //
            // I have siblings, go kill them.
            //
            pns = pnsSibling;
        }
        else
        {
            ASSERT(pnsParent != NULL);
            pns = pnsParent;
        }
    }

    EXIT(3, ("FreeNameSpaceObjects!\n"));
}       //FreeNameSpaceObjects

/***LP  LoadDDB - Load and parse Differentiated Definition Block
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdsdt -> DSDT block
 *      pnsScope -> current scope
 *      ppowner -> to hold new object owner
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS
LOCAL
LoadDDB(
    PCTXT pctxt,
    PDSDT pdsdt,
    PNSOBJ pnsScope,
    POBJOWNER *ppowner
    )
{
    BOOLEAN freeTable = FALSE;
    NTSTATUS rc = STATUS_SUCCESS;

    if (!ValidateTable(pdsdt)) {

        rc = AMLI_LOGERR(
            AMLIERR_INVALID_TABLE,
            ("LoadDDB: invalid table %s at 0x%08x",
             NameSegString(pdsdt->Header.Signature), pdsdt)
            );
        freeTable = TRUE;

    } else {

        rc = NewObjOwner( gpheapGlobal, ppowner);
        if (rc == STATUS_SUCCESS) {

            if (pctxt->pcall == NULL) {

                rc = PushCall(pctxt, NULL, &pctxt->Result);

            }
            if (rc == STATUS_SUCCESS) {

              #ifdef DEBUGGER
                gDebugger.pbBlkBegin = pdsdt->DiffDefBlock;
                gDebugger.pbBlkEnd = (PUCHAR)pdsdt + pdsdt->Header.Length;
              #endif

                rc = PushScope(
                    pctxt,
                    pdsdt->DiffDefBlock,
                    (PUCHAR)pdsdt + pdsdt->Header.Length, pctxt->pbOp,
                    pnsScope, *ppowner, gpheapGlobal, &pctxt->Result
                    );

            }

        } else {

            freeTable = TRUE;

        }

    }

    if (freeTable) {

        pctxt->powner = NULL;
        FreeContext(pctxt);

    }
    return rc;
}       //LoadDDB

/***LP  LoadMemDDB - Load DDB from physical memory
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pDDB -> beginning of DDB
 *      ppowner -> to hold owner handle
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL LoadMemDDB(PCTXT pctxt, PDSDT pDDB, POBJOWNER *ppowner)
{
    TRACENAME("LOADMEMDDB")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("LoadMemDDB(pctxt=%x,Addr=%x,ppowner=%x)\n",
              pctxt, pDDB, ppowner));

    if ((ghValidateTable.pfnHandler != NULL) &&
        ((rc = ((PFNVT)ghValidateTable.pfnHandler)(pDDB,
                                                   ghValidateTable.uipParam)) !=
         STATUS_SUCCESS))
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_TABLE,
                         ("LoadMemDDB: table validation failed (rc=%x)",
                          rc));
    }
    else
    {
        rc = LoadDDB(pctxt, pDDB, pctxt->pnsScope, ppowner);
    }

    EXIT(3, ("LoadMemDDB=%x (powner=%x)\n", rc, *ppowner));
    return rc;
}       //LoadMemDDB

/***LP  LoadFieldUnitDDB - Load DDB from a FieldUnit object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> FieldUnit object
 *      ppowner -> to hold owner handle
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL LoadFieldUnitDDB(PCTXT pctxt, POBJDATA pdataObj,
                                POBJOWNER *ppowner)
{
    TRACENAME("LOADFIELDUNITDDB")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdataTmp;
    DESCRIPTION_HEADER *pdh;

    ENTER(3, ("LoadFieldUnitDDB(pctxt=%x,pdataObj=%x,ppowner=%x)\n",
              pctxt, pdataObj, ppowner));

    if ((pdataTmp = NEWODOBJ(pctxt->pheapCurrent, sizeof(OBJDATA))) == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                         ("LoadFieldUnitDDB: failed to allocate temp. object data"));
    }
    else if ((pdh = NEWBDOBJ(gpheapGlobal, sizeof(DESCRIPTION_HEADER))) == NULL)
    {
        FREEODOBJ(pdataTmp);
        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                         ("LoadFieldUnitDDB: failed to allocate description header"));
    }
    else
    {
        PUCHAR pbTable;

        MEMZERO(pdataTmp, sizeof(OBJDATA));
        pdataTmp->dwDataType = OBJTYPE_BUFFDATA;
        pdataTmp->dwDataLen = sizeof(DESCRIPTION_HEADER);
        pdataTmp->pbDataBuff = (PUCHAR)pdh;

        if ((rc = ReadObject(pctxt, pdataObj, pdataTmp)) == STATUS_SUCCESS)
        {
            if ((pbTable = NEWBDOBJ(gpheapGlobal, pdh->Length)) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("LoadFieldUnitDDB: failed to allocate buffer"));
            }
            else
            {
                MEMCPY(pbTable, pdh, sizeof(DESCRIPTION_HEADER));
                pdataTmp->dwDataLen = pdh->Length - sizeof(DESCRIPTION_HEADER);
                pdataTmp->pbDataBuff = pbTable + sizeof(DESCRIPTION_HEADER);

                if ((rc = ReadObject(pctxt, pdataObj, pdataTmp)) ==
                    STATUS_SUCCESS)
                {
                    if ((ghValidateTable.pfnHandler != NULL) &&
                        ((rc = ((PFNVT)ghValidateTable.pfnHandler)(
                                   (PDSDT)pbTable, ghValidateTable.uipParam)) !=
                         STATUS_SUCCESS))
                    {
                        rc = AMLI_LOGERR(AMLIERR_INVALID_TABLE,
                                         ("LoadFieldUnitDDB: table validation failed (rc=%x)",
                                          rc));
                    }
                    else
                    {
                        rc = LoadDDB(pctxt, (PDSDT)pbTable, pctxt->pnsScope,
                                     ppowner);
                    }
                }
                else if (rc == AMLISTA_PENDING)
                {
                    rc = AMLI_LOGERR(AMLIERR_FATAL,
                                     ("LoadFieldUnitDDB: definition block loading cannot block"));
                }

                FREEBDOBJ(pbTable);
            }
        }
        else if (rc == AMLISTA_PENDING)
        {
            rc = AMLI_LOGERR(AMLIERR_FATAL,
                             ("LoadFieldUnitDDB: definition block loading cannot block"));
        }

        FREEBDOBJ(pdh);
        FREEODOBJ(pdataTmp);
    }

    EXIT(3, ("LoadFieldUnitDDB=%x (powner=%x)\n", rc, *ppowner));
    return rc;
}       //LoadFieldUnitDDB

/***LP  UnloadDDB - Unload Differentiated Definition Block
 *
 *  ENTRY
 *      powner -> OBJOWNER
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

VOID LOCAL UnloadDDB(POBJOWNER powner)
{
    TRACENAME("UNLOADDDB")

    ENTER(3, ("UnloadDDB(powner=%x)\n", powner));
    //
    // Walk name space and remove all objects belongs to this DDB.
    //
    FreeObjOwner(powner, TRUE);
  #ifdef DEBUG
    {
        KIRQL   oldIrql;

        KeAcquireSpinLock( &gdwGHeapSpinLock, &oldIrql );
        gdwGHeapSnapshot = gdwGlobalHeapSize;
        KeReleaseSpinLock( &gdwGHeapSpinLock, oldIrql );
    }
  #endif

    EXIT(3, ("UnloadDDB!\n"));
}       //UnloadDDB

/***LP  EvalPackageElement - Evaluate a package element
 *
 *  ENTRY
 *      ppkg -> package object
 *      iPkgIndex - package index (0-based)
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL EvalPackageElement(PPACKAGEOBJ ppkg, int iPkgIndex,
                                  POBJDATA pdataResult)
{
    TRACENAME("EVALPACKAGEELEMENT")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("EvalPackageElement(ppkg=%x,Index=%d,pdataResult=%x)\n",
              ppkg, iPkgIndex, pdataResult));

    ASSERT(pdataResult != NULL);
    if (iPkgIndex >= (int)ppkg->dwcElements)
    {
        rc = AMLIERR_INDEX_TOO_BIG;
    }
    else
    {
        rc = DupObjData(gpheapGlobal, pdataResult, &ppkg->adata[iPkgIndex]);
    }

    EXIT(3, ("EvalPackageElement=%x (Type=%s,Value=%x,Len=%d,Buff=%x)\n",
             rc, GetObjectTypeName(pdataResult->dwDataType),
             pdataResult->uipDataValue, pdataResult->dwDataLen,
             pdataResult->pbDataBuff));
    return rc;
}       //EvalPackageElement

#ifdef DEBUGGER
/***LP  DumpNameSpaceObject - Dump name space object
 *
 *  ENTRY
 *      pszPath -> name space path string
 *      fRecursive - TRUE if also dump the subtree recursively
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

LONG LOCAL DumpNameSpaceObject(PSZ pszPath, BOOLEAN fRecursive)
{
    TRACENAME("DUMPNAMESPACEOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pns;
    char szName[sizeof(NAMESEG) + 1];

    ENTER(3, ("DumpNameSpaceObject(Path=%s,fRecursive=%x)\n",
              pszPath, fRecursive));

    if ((rc = GetNameSpaceObject(pszPath, NULL, &pns,
                                 NSF_LOCAL_SCOPE)) == STATUS_SUCCESS)
    {
        PRINTF("\nACPI Name Space: %s (%p)\n", pszPath, pns);
        if (!fRecursive)
        {
            STRCPYN(szName, (PSZ)&pns->dwNameSeg, sizeof(NAMESEG));
            DumpObject(&pns->ObjData, szName, 0);
        }
        else
            DumpNameSpaceTree(pns, 0);
    }
    else if (rc == AMLIERR_OBJ_NOT_FOUND)
    {
        PRINTF(MODNAME "_ERROR: object %s not found\n", pszPath);
    }

    EXIT(3, ("DumpNameSpaceObject=%x\n", rc));
    return rc;
}       //DumpNameSpaceObject

/***LP  DumpNameSpaceTree - Dump all the name space objects in the subtree
 *
 *  ENTRY
 *      pnsObj -> name space subtree root
 *      dwLevel - indent level
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpNameSpaceTree(PNSOBJ pnsObj, ULONG dwLevel)
{
    TRACENAME("DUMPNAMESPACETREE")
    PNSOBJ pns, pnsNext;
    char szName[sizeof(NAMESEG) + 1];

    ENTER(3, ("DumpNameSpaceTree(pns=%x,level=%d)\n", pnsObj, dwLevel));
    //
    // First, dump myself
    //
    STRCPYN(szName, (PSZ)&pnsObj->dwNameSeg, sizeof(NAMESEG));
    DumpObject(&pnsObj->ObjData, szName, dwLevel);
    //
    // Then, recursively dump each of my children
    //
    for (pns = pnsObj->pnsFirstChild; pns != NULL; pns = pnsNext)
    {
        //
        // If this is the last child, we have no more.
        //
        if ((pnsNext = (PNSOBJ)pns->list.plistNext) == pnsObj->pnsFirstChild)
            pnsNext = NULL;
        //
        // Dump a child
        //
        DumpNameSpaceTree(pns, dwLevel + 1);
    }

    EXIT(3, ("DumpNameSpaceTree!\n"));
}       //DumpNameSpaceTree

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\amlihook.h ===
#ifndef _AMLI_HOOK_
#define _AMLI_HOOK_


extern ULONG g_AmliHookEnabled;

#define AMLIHOOK_ENABLED_VALUE       608

//
//  AcpitlTestFlags
//

#define AMLIHOOK_TEST_FLAGS_HOOK_API  1
#define AMLIHOOK_TEST_FLAGS_DBG_ON_ERROR   2
#define AMLIHOOK_TEST_FLAGS_NO_NOTIFY_ON_CALL  4

#define AMLIHOOK_TEST_FLAGS_HOOK_MASK  ((ULONG)(AMLIHOOK_TEST_FLAGS_HOOK_API))

//
//  AMLIHOOK_DATA call back data struct
//


typedef struct _AMLIHOOK_DATA
{
 UCHAR Type;
 UCHAR SubType;
 ULONG State;
 ULONG Id;
 ULONG_PTR Arg1;
 ULONG_PTR Arg2;
 ULONG_PTR Arg3;
 ULONG_PTR Arg4;
 ULONG_PTR Arg5;
 ULONG_PTR Arg6;
 ULONG_PTR Arg7;
 NTSTATUS Ret;
} AMLIHOOK_DATA , *PAMLIHOOK_DATA;

//
//--- state member
//
#define AMLIHOOK_TEST_DATA_STATE_CALL        1
#define AMLIHOOK_TEST_DATA_STATE_RETURN      2
#define AMLIHOOK_TEST_DATA_STATE_ASYNC_CALL  3
#define AMLIHOOK_TEST_DATA_STATE_QUERY       4

#define AMLIHOOK_TEST_DATA_CALL_STATE_MASK (AMLIHOOK_TEST_DATA_STATE_CALL | AMLIHOOK_TEST_DATA_STATE_ASYNC_CALL)


#define AMLIHOOK_CALLBACK_NAME  L"\\Callback\\AMLIHOOK"

#define IsAmliHookEnabled()  g_AmliHookEnabled

ULONG 
AmliHook_GetDbgFlags(
   VOID);

VOID
AmliHook_InitTestData(
   PAMLIHOOK_DATA Data);

PAMLIHOOK_DATA
AmliHook_AllocAndInitTestData(
   VOID);

NTSTATUS
AmliHook_InitTestHookInterface(
   VOID);

VOID
AmliHook_UnInitTestHookInterface(
   VOID);

NTSTATUS
AmliHook_TestNotify(
   PAMLIHOOK_DATA Data);

NTSTATUS
AmliHook_TestNotifyRet(
   PAMLIHOOK_DATA Data,
   NTSTATUS Status);

VOID
AmliHook_ProcessInternalError(
   VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\amlipriv.h ===
/*** amlipriv.h - AML Interpreter Private Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _AMLIPRIV_H
#define _AMLIPRIV_H

/*** Macros
 */

/*XLATOFF*/

#define MODNAME         "AMLI"

#ifndef DEBUG
  #define AMLI_WARN(x)
  #define AMLI_ERROR(x)
  #define CHKGLOBALHEAP()
#else
  #define AMLI_WARN(x)          ConPrintf(MODNAME "_WARN: ");           \
                                ConPrintf x;                            \
                                ConPrintf("\n");
  #define AMLI_ERROR(x)         ConPrintf(MODNAME "_ERROR: ");          \
                                ConPrintf x;                            \
                                ConPrintf("\n");                        \
                                KdBreakPoint();                         \
                                CHKDEBUGGERREQ();
  #define CHKGLOBALHEAP() 

#endif

#ifndef DEBUGGER
  #define PRINTF
  #define AMLI_LOGERR(rc,p)     (rc)
  #define RESETERR()
  #define CHKDEBUGGERREQ()
  #define LOGSCHEDEVENT(ev,d1,d2,d3)
  #define LOGEVENT(ev,d1,d2,d3,d4,d5,d6,d7)
  #define LOGMUTEXEVENT(ev,d1,d2,d3,d4,d5,d6,d7)
#else
  #define PRINTF                ConPrintf
  #define AMLI_LOGERR(rc,p)     (LogError(rc), CatError p, (rc))
  #define RESETERR()            {gDebugger.rcLastError = STATUS_SUCCESS;\
                                 gDebugger.szLastError[0] = '\0';       \
                                }
  #define CHKDEBUGGERREQ()      if (gDebugger.dwfDebugger & DBGF_DEBUGGER_REQ) \
                                {                                              \
                                    ConPrintf("\nProcess AML Debugger Request.\n");\
                                    gDebugger.dwfDebugger &=                   \
                                        ~DBGF_DEBUGGER_REQ;                    \
                                    AMLIDebugger(FALSE);                       \
                                }
  #define LOGEVENT              LogEvent
  #define LOGSCHEDEVENT         LogSchedEvent
  #define LOGMUTEXEVENT(ev,d1,d2,d3,d4,d5,d6,d7)                        \
                                if (gDebugger.dwfDebugger & DBGF_LOGEVENT_MUTEX)\
                                {                                       \
                                    LogEvent(ev,d1,d2,d3,d4,d5,d6,d7);  \
                                }
#endif

#define LOCAL           __cdecl
#define DEREF(x)        ((x) = (x))
#define BYTEOF(d,i)     (((PUCHAR)&d)[i])
#define WORDOF(d,i)     (((PUSHORT)&d)[i])

//
// NTRAID#60804-2000/06/20-splante Remove dependence on static translation
//
#define HalTranslateBusAddress(InterfaceType,BusNumber,BusAddress,AddressSpace,TranslatedAddress) \
                              (*(TranslatedAddress) = (BusAddress), TRUE)

//
// The various tags
//
#define CTOBJ_TAG       'ClmA'
#define HPOBJ_TAG       'HlmA'
#define PRIV_TAG        'IlmA'
#define PHOBJ_TAG       'PlmA'
#define RSOBJ_TAG       'RlmA'
#define SYOBJ_TAG       'SlmA'
#define RTOBJ_TAG       'TlmA'

// Memory management macros
#define ALLOCPOOL               ExAllocatePool
#define ALLOCPOOLWITHTAG        ExAllocatePoolWithTag
#ifdef DEBUG
  #ifndef MAXWINNT_DEBUG
    #define MALLOC_PAGED(n,t)   (++gdwcMemObjs,                         \
                                 ALLOCPOOLWITHTAG(                      \
                                   (gdwfAMLI & AMLIF_LOCKED)?           \
                                   NonPagedPool: PagedPool, n, t))
    #define MALLOC_LOCKED(n,t)  (++gdwcMemObjs,                         \
                                 ALLOCPOOLWITHTAG(                      \
                                   NonPagedPool, n, t))
  #else
    #define MALLOC_PAGED(n,t)   (++gdwcMemObjs,                         \
                                 ExAllocatePoolWithTagPriority(         \
                                   (gdwfAMLI & AMLIF_LOCKED)?           \
                                   NonPagedPool: PagedPool, n, t,       \
                                   HighPoolPrioritySpecialPoolOverrun))
    #define MALLOC_LOCKED(n,t)  (++gdwcMemObjs,                         \
                                 ExAllocatePoolWithTagPriority(         \
                                   NonPagedPool, n, t,                  \
                                   HighPoolPrioritySpecialPoolOverrun))
  #endif

  #define MALLOC                MALLOC_LOCKED

  #define MFREE(p)              FreeMem(p, &gdwcMemObjs)

  #define NEWHPOBJ(n)           (++gdwcHPObjs, MALLOC(n, HPOBJ_TAG))
  #define FREEHPOBJ(p)          {MFREE(p); --gdwcHPObjs;}

  #define NEWSYOBJ(n)           (++gdwcSYObjs, MALLOC_LOCKED(n, SYOBJ_TAG))
  #define FREESYOBJ(p)          {MFREE(p); --gdwcSYObjs;}

  #define NEWRSOBJ(n)           (++gdwcRSObjs, MALLOC_LOCKED(n, RSOBJ_TAG))
  #define FREERSOBJ(p)          {MFREE(p); --gdwcRSObjs;}

  #define NEWPHOBJ(n)           (++gdwcPHObjs, MALLOC_LOCKED(n, PHOBJ_TAG))
  #define FREEPHOBJ(p)          {MFREE(p); --gdwcPHObjs;}

  #define NEWRESTOBJ(n)         (MALLOC_LOCKED(n, RTOBJ_TAG))
  #define FREERESTOBJ(p)        (MFREE(p))

  #define NEWOBJDATA(h,p)       NewObjData(h, p)
  #define FREEOBJDATA(p)        FreeObjData(p)

  #define NEWODOBJ(h,n)         (++gdwcODObjs, HeapAlloc(h, 'TADH', n))
  #define FREEODOBJ(p)          {HeapFree(p); --gdwcODObjs;}

  #define NEWNSOBJ(h,n)         (++gdwcNSObjs, HeapAlloc(h, 'OSNH', n))
  #define FREENSOBJ(p)          {HeapFree(p); --gdwcNSObjs;}

  #define NEWOOOBJ(h,n)         (++gdwcOOObjs, HeapAlloc(h, 'NWOH', n))
  #define FREEOOOBJ(p)          {HeapFree(p); --gdwcOOObjs;}

  #define NEWSDOBJ(h,n)         (++gdwcSDObjs, HeapAlloc(h, 'RTSH', n))
  #define FREESDOBJ(p)          {HeapFree(p); --gdwcSDObjs;}

  #define NEWBDOBJ(h,n)         (++gdwcBDObjs, HeapAlloc(h, 'FUBH', n))
  #define FREEBDOBJ(p)          {HeapFree(p); --gdwcBDObjs;}

  #define NEWPKOBJ(h,n)         (++gdwcPKObjs, HeapAlloc(h, 'GKPH', n))
  #define FREEPKOBJ(p)          {HeapFree(p); --gdwcPKObjs;}

  #define NEWBFOBJ(h,n)         (++gdwcBFObjs, HeapAlloc(h, 'DFBH', n))
  #define FREEBFOBJ(p)          {HeapFree(p); --gdwcBFObjs;}

  #define NEWFUOBJ(h,n)         (++gdwcFUObjs, HeapAlloc(h, 'UDFH', n))
  #define FREEFUOBJ(p)          {HeapFree(p); --gdwcFUObjs;}

  #define NEWKFOBJ(h,n)         (++gdwcKFObjs, HeapAlloc(h, 'FKBH', n))
  #define FREEKFOBJ(p)          {HeapFree(p); --gdwcKFObjs;}

  #define NEWFOBJ(h,n)          (++gdwcFObjs, HeapAlloc(h, 'ODFH', n))
  #define FREEFOBJ(p)           {HeapFree(p); --gdwcFObjs;}

  #define NEWIFOBJ(h,n)         (++gdwcIFObjs, HeapAlloc(h, 'FXIH', n))
  #define FREEIFOBJ(p)          {HeapFree(p); --gdwcIFObjs;}

  #define NEWOROBJ(h,n)         (++gdwcORObjs, HeapAlloc(h, 'GROH', n))
  #define FREEOROBJ(p)          {HeapFree(p); --gdwcORObjs;}

  #define NEWMTOBJ(h,n)         (++gdwcMTObjs, HeapAlloc(h, 'TUMH', n))
  #define FREEMTOBJ(p)          {HeapFree(p); --gdwcMTObjs;}

  #define NEWEVOBJ(h,n)         (++gdwcEVObjs, HeapAlloc(h, 'NVEH', n))
  #define FREEEVOBJ(p)          {HeapFree(p); --gdwcEVObjs;}

  #define NEWMEOBJ(h,n)         (++gdwcMEObjs, HeapAlloc(h, 'TEMH', n))
  #define FREEMEOBJ(p)          {HeapFree(p); --gdwcMEObjs;}

  #define NEWPROBJ(h,n)         (++gdwcPRObjs, HeapAlloc(h, 'SRPH', n))
  #define FREEPROBJ(p)          {HeapFree(p); --gdwcPRObjs;}

  #define NEWPCOBJ(h,n)         (++gdwcPCObjs, HeapAlloc(h, 'ORPH', n))
  #define FREEPCOBJ(p)          {HeapFree(p); --gdwcPCObjs;}

  #define NEWCROBJ(h,n)         (++gdwcCRObjs, HeapAlloc(h, 'RNWO', n))
  #define FREECROBJ(p)          {HeapFree(p); --gdwcCRObjs;}
#else
  #define MALLOC_PAGED(n,t)     ALLOCPOOLWITHTAG(PagedPool, n, t)
  #define MALLOC_LOCKED(n,t)    ALLOCPOOLWITHTAG(NonPagedPool, n, t)
  #define MALLOC                MALLOC_LOCKED
  #define MFREE(p)              ExFreePool(p)

  #define NEWHPOBJ(n)           MALLOC(n, HPOBJ_TAG)
  #define FREEHPOBJ(p)          MFREE(p)

  #define NEWSYOBJ(n)           MALLOC_LOCKED(n, SYOBJ_TAG)
  #define FREESYOBJ(p)          MFREE(p)

  #define NEWRSOBJ(n)           MALLOC_LOCKED(n, RSOBJ_TAG)
  #define FREERSOBJ(p)          MFREE(p)

  #define NEWPHOBJ(n)           MALLOC_LOCKED(n, PHOBJ_TAG)
  #define FREEPHOBJ(p)          MFREE(p)

  #define NEWRESTOBJ(n)         MALLOC_LOCKED(n, RTOBJ_TAG)
  #define FREERESTOBJ(p)        MFREE(p)

  #define NEWOBJDATA(h,p)       NewObjData(h,p)
  #define FREEOBJDATA(p)        FreeObjData(p)

  #define NEWODOBJ(h,n)         HeapAlloc(h, 'TADH', n)
  #define FREEODOBJ(p)          HeapFree(p)

  #define NEWNSOBJ(h,n)         HeapAlloc(h, 'OSNH', n)
  #define FREENSOBJ(p)          HeapFree(p)

  #define NEWOOOBJ(h,n)         HeapAlloc(h, 'NWOH', n)
  #define FREEOOOBJ(p)          HeapFree(p)

  #define NEWSDOBJ(h,n)         HeapAlloc(h, 'RTSH', n)
  #define FREESDOBJ(p)          HeapFree(p)

  #define NEWBDOBJ(h,n)         HeapAlloc(h, 'FUBH', n)
  #define FREEBDOBJ(p)          HeapFree(p)

  #define NEWPKOBJ(h,n)         HeapAlloc(h, 'GKPH', n)
  #define FREEPKOBJ(p)          HeapFree(p)

  #define NEWBFOBJ(h,n)         HeapAlloc(h, 'DFBH', n)
  #define FREEBFOBJ(p)          HeapFree(p)

  #define NEWFUOBJ(h,n)         HeapAlloc(h, 'UDFH', n)
  #define FREEFUOBJ(p)          HeapFree(p)

  #define NEWKFOBJ(h,n)         HeapAlloc(h, 'FKBH', n)
  #define FREEKFOBJ(p)          HeapFree(p)

  #define NEWFOBJ(h,n)          HeapAlloc(h, 'ODFH', n)
  #define FREEFOBJ(p)           HeapFree(p)

  #define NEWIFOBJ(h,n)         HeapAlloc(h, 'FXIH', n)
  #define FREEIFOBJ(p)          HeapFree(p)

  #define NEWOROBJ(h,n)         HeapAlloc(h, 'GROH', n)
  #define FREEOROBJ(p)          HeapFree(p)

  #define NEWMTOBJ(h,n)         HeapAlloc(h, 'TUMH', n)
  #define FREEMTOBJ(p)          HeapFree(p)

  #define NEWEVOBJ(h,n)         HeapAlloc(h, 'NVEH', n)
  #define FREEEVOBJ(p)          HeapFree(p)

  #define NEWMEOBJ(h,n)         HeapAlloc(h, 'TEMH', n)
  #define FREEMEOBJ(p)          HeapFree(p)

  #define NEWPROBJ(h,n)         HeapAlloc(h, 'SRPH', n)
  #define FREEPROBJ(p)          HeapFree(p)

  #define NEWPCOBJ(h,n)         HeapAlloc(h, 'ORPH', n)
  #define FREEPCOBJ(p)          HeapFree(p)

  #define NEWCROBJ(h,n)         HeapAlloc(h, 'RNWO', n)
  #define FREECROBJ(p)          HeapFree(p)
#endif
#define MEMCPY                  RtlCopyMemory
#define MEMZERO                 RtlZeroMemory

#define ISLEADNAMECHAR(c)       (((c) >= 'A') && ((c) <= 'Z') || ((c) == '_'))
#define ISNAMECHAR(c)           (ISLEADNAMECHAR(c) || ((c) >= '0') && ((c) <= '9'))
#define SHIFTLEFT(d,c)          (((c) >= 32)? 0: (d) << (c))
#define SHIFTRIGHT(d,c)         (((c) >= 32)? 0: (d) >> (c))
#define MIN(a,b)                (((a) > (b))? (b): (a))
#define MAX(a,b)                (((a) > (b))? (a): (b))

/*XLATON*/

/*** Constants
 */

// These are internal error codes which aren't really errors
#define AMLISTA_DONE            0x00008000
#define AMLISTA_BREAK           0x00008001
#define AMLISTA_RETURN          0x00008002
#define AMLISTA_CONTINUE        0x00008003
#define AMLISTA_PENDING         0x00008004
#define AMLISTA_TIMEOUT         0x00008005

// Global AMLI flags
#define AMLIF_LOCKED            0x00000001
#define AMLIF_IN_LOCKPHASE      0x00000002
#define AMLIF_LOADING_DDB       0x80000000

// Error Log
#define READ_ERROR_NOTED        0x00000001
#define WRITE_ERROR_NOTED       0x00000002

//
// AMLI Override FLAGS
//
#define AMLI_OVERRIDE_IO_ADDRESS_CHECK  0x00000001

// Global Hack flags
#define HACKF_OLDSLEEP          0x00000001

//
// AMLI Reg Attributes key
//
#define AMLI_ATTRIBUTES "AMLIAttributes"


#define ARGTYPE_NAME            'N'             //name argument
#define ARGTYPE_DATAOBJ         'O'             //data argument
#define ARGTYPE_DWORD           'D'             //numeric dword argument
#define ARGTYPE_WORD            'W'             //numeric word argument
#define ARGTYPE_BYTE            'B'             //numeric byte argument
#define ARGTYPE_SNAME           'S'             //supername argument
#define ARGTYPE_SNAME2          's'             //supername argument
                                                //  object can be non-existing
#define ARGTYPE_OPCODE          'C'             //opcode argument

// Argument object type (used for type validation)
#define ARGOBJ_UNKNOWN          'U'             //OBJTYPE_UNKNOWN - don't care
#define ARGOBJ_INTDATA          'I'             //OBJTYPE_INTDATA
#define ARGOBJ_STRDATA          'Z'             //OBJTYPE_STRDATA
#define ARGOBJ_BUFFDATA         'B'             //OBJTYPE_BUFFDATA
#define ARGOBJ_PKGDATA          'P'             //OBJTYPE_PKGDATA
#define ARGOBJ_FIELDUNIT        'F'             //OBJTYPE_FIELDUNIT
#define ARGOBJ_OBJALIAS         'O'             //OBJTYPE_OBJALIAS
#define ARGOBJ_DATAALIAS        'A'             //OBJTYPE_DATAALIAS
#define ARGOBJ_BASICDATA        'D'             //INTDATA,STRDATA,BUFFDATA
#define ARGOBJ_COMPLEXDATA      'C'             //BUFFDATA,PKGDATA
#define ARGOBJ_REFERENCE        'R'             //OBJALIAS,DATAALIAS,BUFFFIELD

#define MAX_BYTE                0xff
#define MAX_WORD                0xffff
#define MAX_DWORD               0xffffffff
#define MAX_NUM_LOCALS          8
#define MAX_NUM_ARGS            7
#define MAX_NAME_LEN            255

#define DEF_CTXTMAX_SIZE        16              //16 Contexts
#if defined (_WIN64)
#define DEF_CTXTBLK_SIZE        (4096*16)        //64K context block
#define DEF_GLOBALHEAPBLK_SIZE  (4096*16*16)     //1M global heap block
#else
#define DEF_CTXTBLK_SIZE        (4096*2)        //8K context block
#define DEF_GLOBALHEAPBLK_SIZE  (4096*16)       //64K global heap block
#endif
#define DEF_TIMESLICE_LENGTH    100             //100ms
#define DEF_TIMESLICE_INTERVAL  100             //100ms
#if defined(_WIN64)
  #define DEF_HEAP_ALIGNMENT    8               //QWord aligned
#else
  #define DEF_HEAP_ALIGNMENT    4               //DWord aligned
#endif

#define AMLI_REVISION           1
#define NAMESEG_ROOT            0x5f5f5f5c      // "\___"
#define NAMESEG_BLANK           0x5f5f5f5f      // "____"
#define NAMESEG_NONE            0x00000000      // ""
#define NAMESTR_ROOT            "\\"
#define CREATORID_MSFT          "MSFT"
#define MIN_CREATOR_REV         0x01000000

// dwfNS local flags
#define NSF_EXIST_OK            0x00010000      //for CreateNameSpaceObject
#define NSF_WARN_NOTFOUND       0x80000000      //for GetNameSpaceObject

/*** Type and Structure definitions
 */

typedef NTSTATUS (LOCAL *PFNOP)(PFRAME, PPNSOBJ);

typedef struct _amlterm
{
    PSZ   pszTermName;
    ULONG dwOpcode;
    PSZ   pszArgTypes;
    ULONG dwTermClass;
    ULONG dwfOpcode;
    PFNOH pfnCallBack;
    ULONG dwCBData;
    PFNOP pfnOpcode;
} AMLTERM, *PAMLTERM;

// dwfOpcode flags
#define OF_VARIABLE_LIST        0x00000001
#define OF_ARG_OBJECT           0x00000002
#define OF_LOCAL_OBJECT         0x00000004
#define OF_DATA_OBJECT          0x00000008
#define OF_STRING_OBJECT        0x00000010
#define OF_NAME_OBJECT          0x00000020
#define OF_DEBUG_OBJECT         0x00000040
#define OF_REF_OBJECT           0x00000080
#define OF_CALLBACK_EX          0x80000000

// dwTermClass
#define TC_NAMESPACE_MODIFIER   0x00000001
#define TC_NAMED_OBJECT         0x00000002
#define TC_OPCODE_TYPE1         0x00000003
#define TC_OPCODE_TYPE2         0x00000004
#define TC_OTHER                0x00000005

typedef struct _opcodemap
{
    ULONG    dwOpcode;
    PAMLTERM pamlterm;
} OPCODEMAP, *POPCODEMAP;

typedef struct _objowner
{
    LIST   list;
    ULONG  dwSig;
    PNSOBJ pnsObjList;
} OBJOWNER, *POBJOWNER;

#define SIG_OBJOWNER            'RNWO'

typedef struct _evhandle
{
    PFNHND    pfnHandler;
    ULONG_PTR uipParam;
} EVHANDLE, *PEVHANDLE;

typedef struct _rsaccess
{
    struct _rsaccess *prsaNext;
    ULONG     dwRegionSpace;
    PFNCA     pfnCookAccess;
    ULONG_PTR uipCookParam;
    PFNRA     pfnRawAccess;
    ULONG_PTR uipRawParam;
} RSACCESS, *PRSACCESS;

typedef struct _passivehook
{
    struct _ctxt *pctxt;
    ULONG_PTR    uipAddr;
    ULONG        dwLen;
    PULONG_PTR   puipMappedAddr;
    WORK_QUEUE_ITEM WorkItem;
} PASSIVEHOOK, *PPASSIVEHOOK;

typedef struct _mutex
{
    KSPIN_LOCK SpinLock;
    KIRQL      OldIrql;
} MUTEX, *PMUTEX;

typedef struct _badioaddr
{
    ULONG BadAddrBegin;
    ULONG BadAddrSize;
    ULONG OSVersionTrigger;
} BADIOADDR, *PBADIOADDR;

typedef struct _AMLI_Log_WorkItem_Context
{
    BOOLEAN         fRead;
    ULONG           Address;
    ULONG           Index;
    PIO_WORKITEM    pIOWorkItem;
} AMLI_LOG_WORKITEM_CONTEXT, *PAMLI_LOG_WORKITEM_CONTEXT; 

#endif  //ifndef _AMLIPRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\amldebug.c ===
/*** amldebug.c - AML Debugger functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"
#include "unasm.h"
#include <stdio.h>
#include <stdarg.h>

#ifdef DEBUGGER

/*** Local function prototypes
 */

LONG LOCAL DebugHelp(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL DebugExpr(PSZ pszArg, PULONG_PTR puipValue, BOOLEAN *pfPhysical,
                     PPNSOBJ ppns, PULONG pdwOffset);
BOOLEAN LOCAL IsNumber(PSZ pszStr, ULONG dwBase, PULONG_PTR puipValue);
LONG LOCAL DumpData(ULONG_PTR uipAddr, ULONG dwfUnitSize, ULONG dwLen,
                    BOOLEAN fPhysical);
LONG LOCAL DebugDumpData(PCMDARG pArg, PSZ pszArg, ULONG dwfDataSize);
LONG LOCAL DebugD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugDB(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugDW(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugDD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugDA(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
#ifdef DEBUG
LONG LOCAL DebugDC(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
#endif
LONG LOCAL DebugEditMem(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                        ULONG dwNonSWArgs);
LONG LOCAL InPort(ULONG dwPort, ULONG dwSize, PULONG pdwData);
LONG LOCAL DebugInPort(PSZ pszArg, ULONG dwSize);
LONG LOCAL DebugI(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugIW(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugID(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugQuit(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL DebugNotify(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                       ULONG dwNonSWArgs);
LONG LOCAL OutPort(ULONG dwPort, ULONG dwSize, ULONG dwData);
LONG LOCAL DebugOutPort(PSZ pszArg, ULONG dwSize);
LONG LOCAL DebugO(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugOW(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL DebugOD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
VOID LOCAL PrintSymbol(PUCHAR pb);
LONG LOCAL DebugTrace(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL DebugStep(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL DebugSetLogSize(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs);
LONG LOCAL DebugRunMethod(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                          ULONG dwNonSWArgs);
VOID EXPORT RunMethodCallBack(PNSOBJ pns, NTSTATUS rc, POBJDATA pdata,
                              PVOID pvContext);
VOID LOCAL AddObjSymbol(PUCHAR pbOp, PNSOBJ pnsObj);
BOOLEAN LOCAL FindObjSymbol(PUCHAR pbOp, PPNSOBJ ppns, PULONG pdwOffset);
BOOLEAN LOCAL CheckAndEnableDebugSpew(BOOLEAN fEnable);

/*** Exported data
 */

DBGR gDebugger = {0};


/*** Local data
 */

ULONG dwCmdArg = 0;

CMDARG ArgsHelp[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugHelp,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsD[] =
{
    "l", AT_NUM, AF_SEP, &dwCmdArg, 16, DebugD,
    NULL, AT_ACTION, 0, NULL, 0, DebugD,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDB[] =
{
    "l", AT_NUM, AF_SEP, &dwCmdArg, 16, DebugDB,
    NULL, AT_ACTION, 0, NULL, 0, DebugDB,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDW[] =
{
    "l", AT_NUM, AF_SEP, &dwCmdArg, 16, DebugDW,
    NULL, AT_ACTION, 0, NULL, 0, DebugDW,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDD[] =
{
    "l", AT_NUM, AF_SEP, &dwCmdArg, 16, DebugDD,
    NULL, AT_ACTION, 0, NULL, 0, DebugDD,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDA[] =
{
    "l", AT_NUM, AF_SEP, &dwCmdArg, 16, DebugDA,
    NULL, AT_ACTION, 0, NULL, 0, DebugDA,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsEditMem[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugEditMem,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsI[] =
{
    NULL, AT_NUM, 0, &dwCmdArg, 16, DebugI,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsIW[] =
{
    NULL, AT_NUM, 0, &dwCmdArg, 16, DebugIW,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsID[] =
{
    NULL, AT_NUM, 0, &dwCmdArg, 16, DebugID,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsNotify[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugNotify,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsO[] =
{
    NULL, AT_NUM, 0, &dwCmdArg, 16, DebugO,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsOW[] =
{
    NULL, AT_NUM, 0, &dwCmdArg, 16, DebugOW,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsOD[] =
{
    NULL, AT_NUM, 0, &dwCmdArg, 16, DebugOD,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsRunMethod[] =
{
    NULL, AT_ACTION, 0, NULL, 0, DebugRunMethod,
    NULL, AT_END, 0, NULL, 0, NULL
};

#ifdef TRACING
CMDARG ArgsSetTrace[] =
{
    "trigon", AT_ENABLE, 0, &gDebugger.dwfDebugger, DBGF_TRIGGER_MODE, NULL,
    "trigoff", AT_DISABLE, 0, &gDebugger.dwfDebugger, DBGF_TRIGGER_MODE, NULL,
    "level", AT_NUM, AF_SEP, &giTraceLevel, 0, NULL,
    "add", AT_STRING, AF_SEP, &gpszTrigPts, 0, AddTraceTrigPts,
    "zap", AT_STRING, AF_SEP, &gpszTrigPts, 0, ZapTraceTrigPts,
    NULL, AT_END, 0, NULL, 0, NULL
};
#endif

DBGCMD DbgCmds[] =
{
    "?", 0, ArgsHelp, DebugHelp,
    "d", 0, ArgsD, DebugD,
    "db", 0, ArgsDB, DebugDB,
    "dw", 0, ArgsDW, DebugDW,
    "dd", 0, ArgsDD, DebugDD,
    "da", 0, ArgsDA, DebugDA,
  #ifdef DEBUG
    "dc", 0, NULL, DebugDC,
  #endif
    "e", 0, ArgsEditMem, DebugEditMem,
    "g", CMDF_QUIT, NULL, NULL,
    "i", 0, ArgsI, DebugI,
    "iw", 0, ArgsIW, DebugIW,
    "id", 0, ArgsID, DebugID,
    "notify", 0, ArgsNotify, DebugNotify,
    "o", 0, ArgsO, DebugO,
    "ow", 0, ArgsOW, DebugOW,
    "od", 0, ArgsOD, DebugOD,
    "p", 0, NULL, DebugStep,
    "q", 0, NULL, DebugQuit,
    "run", 0, ArgsRunMethod, DebugRunMethod,
    "t", 0, NULL, DebugTrace,
  #ifdef TRACING
    "trace", 0, ArgsSetTrace, SetTrace,
  #endif
    NULL, 0, NULL, NULL
};

/***EP  AMLIDebugger - AMLI Debugger
 *
 *  ENTRY
 *      fCallFromVxD - debugger is invoked by the VxD .. command.
 *
 *  EXIT
 *      None
 */

VOID STDCALL AMLIDebugger(BOOLEAN fCallFromVxD)
{
    if (!(gDebugger.dwfDebugger & DBGF_IN_KDSHELL))
    {
        if (fCallFromVxD)
        {
            gDebugger.dwfDebugger |= DBGF_IN_VXDMODE;
        }
        else
        {
            gDebugger.dwfDebugger &= ~DBGF_IN_VXDMODE;
        }

        gDebugger.dwfDebugger |= DBGF_IN_DEBUGGER;
        Debugger(DbgCmds, "\n" MODNAME "(? for help)-> ");
        gDebugger.dwfDebugger &= ~(DBGF_IN_DEBUGGER | DBGF_IN_VXDMODE);
    }
    else
    {
        PRINTF("\nRe-entering AML debugger is not allowed.\n"
               "Type 'g' to go back to the AML debugger.\n");
    }
}       //AMLIDebugger

/***LP  DebugHelp - help
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugHelp(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwNonSWArgs);
    //
    // User typed ? <cmd>
    //
    if (pszArg != NULL)
    {
        if (STRCMP(pszArg, "?") == 0)
        {
            PRINTF("\nHelp:\n");
            PRINTF("Usage: ? [<Cmd>]\n");
            PRINTF("<Cmd> - command to get help on\n");
        }
        else if (STRCMP(pszArg, "bc") == 0)
        {
            PRINTF("\nClear Breakpoints:\n");
            PRINTF("Usage: bc <bp list> | *\n");
            PRINTF("<bp list> - list of breakpoint numbers\n");
            PRINTF("*         - all breakpoints\n");
        }
        else if (STRCMP(pszArg, "bd") == 0)
        {
            PRINTF("\nDisable Breakpoints:\n");
            PRINTF("Usage: bd <bp list> | *\n");
            PRINTF("<bp list> - list of breakpoint numbers\n");
            PRINTF("*         - all breakpoints\n");
        }
        else if (STRCMP(pszArg, "be") == 0)
        {
            PRINTF("\nEnable Breakpoints:\n");
            PRINTF("Usage: be <bp list> | *\n");
            PRINTF("<bp list> - list of breakpoint numbers\n");
            PRINTF("*         - all breakpoints\n");
        }
        else if (STRCMP(pszArg, "bl") == 0)
        {
            PRINTF("\nList All Breakpoints:\n");
            PRINTF("Usage: bl\n");
        }
        else if (STRCMP(pszArg, "bp") == 0)
        {
            PRINTF("\nSet BreakPoints:\n");
            PRINTF("Usage: bp <MethodName> | <CodeAddr> ...\n");
            PRINTF("<MethodName> - full path of method name to have breakpoint set at\n");
            PRINTF("<CodeAddr>   - address of AML code to have breakpoint set at\n");
        }
        else if (STRCMP(pszArg, "cl") == 0)
        {
            PRINTF("\nClear Event Log:\n");
            PRINTF("Usage: cl\n");
        }
        else if (STRCMP(pszArg, "d") == 0)
        {
            PRINTF("\nDump Data:\n");
            PRINTF("Usage: d [[l=<Len>] <Addr> | <MethodName>]\n");
            PRINTF("<Len>        - length of address range in hex\n");
            PRINTF("<Addr>       - data address (physical address if prefixed by \"%%\")\n");
            PRINTF("<MethodName> - full path of method name\n");
        }
        else if (STRCMP(pszArg, "db") == 0)
        {
            PRINTF("\nDump Data Bytes:\n");
            PRINTF("Usage: db [[l=<Len>] <Addr> | <MethodName>]\n");
            PRINTF("<Len>        - length of address range in hex\n");
            PRINTF("<Addr>       - data address (physical address if prefixed by \"%%\")\n");
            PRINTF("<MethodName> - full path of method name\n");
        }
        else if (STRCMP(pszArg, "dw") == 0)
        {
            PRINTF("\nDump Data Words:\n");
            PRINTF("Usage: dw [[l=<Len>] <Addr> | <MethodName>]\n");
            PRINTF("<Len>        - length of address range in hex\n");
            PRINTF("<Addr>       - data address (physical address if prefixed by \"%%\")\n");
            PRINTF("<MethodName> - full path of method name\n");
        }
        else if (STRCMP(pszArg, "dd") == 0)
        {
            PRINTF("\nDump Data DWords:\n");
            PRINTF("Usage: dd [[l=<Len>] <Addr> | <MethodName>]\n");
            PRINTF("<Len>        - length of address rangein hex\n");
            PRINTF("<Addr>       - data address (physical address if prefixed by \"%%\")\n");
            PRINTF("<MethodName> - full path of method name\n");
        }
        else if (STRCMP(pszArg, "da") == 0)
        {
            PRINTF("\nDump Data String:\n");
            PRINTF("Usage: da [[l=<Len>] <Addr> | <MethodName>]\n");
            PRINTF("<Len>        - length of address range in hex\n");
            PRINTF("<Addr>       - data address (physical address if prefixed by \"%%\")\n");
            PRINTF("<MethodName> - full path of method name\n");
        }
      #ifdef DEBUG
        else if (STRCMP(pszArg, "dc") == 0)
        {
            PRINTF("\nDump Memory Object Count Table:\n");
            PRINTF("Usage: dc\n");
        }
        else if (STRCMP(pszArg, "dh") == 0)
        {
            PRINTF("\nDump Heap:\n");
            PRINTF("Usage: dh [<Addr>]\n");
            PRINTF("<Addr> - address of the heap block, global heap if missing\n");
        }
      #endif
        else if (STRCMP(pszArg, "dl") == 0)
        {
            PRINTF("\nDump Event Log:\n");
            PRINTF("Usage: dl\n");
        }
        else if (STRCMP(pszArg, "ds") == 0)
        {
            PRINTF("\nDump Stack:\n");
          #ifdef DEBUG
            PRINTF("Usage: ds [/v] [<Addr>]\n");
            PRINTF("v - enable versbos mode\n");
          #else
            PRINTF("Usage: ds [<Addr>]\n");
          #endif
            PRINTF("<Addr> - address of the context block, use current context if missing\n");
        }
        else if (STRCMP(pszArg, "dns") == 0)
        {
            PRINTF("\nDump Name Space Object:\n");
            PRINTF("Usage: dns [[/s] [<NameStr> | <Addr>]]\n");
            PRINTF("s         - recursively dump the name space subtree\n");
            PRINTF("<NameStr> - name space path (dump whole name space if absent)\n");
            PRINTF("<Addr>    - specify address of the name space object\n");
        }
        else if (STRCMP(pszArg, "do") == 0)
        {
            PRINTF("\nDump Data Object:\n");
            PRINTF("Usage: do <Addr>\n");
            PRINTF("<Addr> - address of the data object\n");
        }
        else if (STRCMP(pszArg, "e") == 0)
        {
            PRINTF("\nEdit Memory:\n");
            PRINTF("Usage: e [<Addr> [<DataList>]]\n");
            PRINTF("<Addr>     - memory address (physical address if prefixed by \"%%\")\n");
            PRINTF("<DataList> - list of data separated by spaces, "
                   "data can be a byte or a string\n");
        }
        else if (STRCMP(pszArg, "find") == 0)
        {
            PRINTF("\nFind NameSpace Object:\n");
            PRINTF("Usage: find <NameSeg>\n");
            PRINTF("<NameSeg> - Name of the NameSpace object without path\n");
        }
        else if (STRCMP(pszArg, "g") == 0)
        {
            PRINTF("\nQuit debugger, continue normal execution.\n");
        }
        else if (STRCMP(pszArg, "i") == 0)
        {
            PRINTF("\nRead Data From a Byte Port:\n");
            PRINTF("Usage: i <Port>\n");
            PRINTF("<Port> - port address\n");
        }
        else if (STRCMP(pszArg, "iw") == 0)
        {
            PRINTF("\nRead Data From a Word Port:\n");
            PRINTF("Usage: iw <Port>\n");
            PRINTF("<Port> - port address\n");
        }
        else if (STRCMP(pszArg, "id") == 0)
        {
            PRINTF("\nRead Data From a DWord Port:\n");
            PRINTF("Usage: id <Port>\n");
            PRINTF("<Port> - port address\n");
        }
        else if (STRCMP(pszArg, "lc") == 0)
        {
            PRINTF("\nList All Contexts:\n");
            PRINTF("Usage: lc\n");
        }
        else if (STRCMP(pszArg, "ln") == 0)
        {
            PRINTF("\nDisplay Nearest Method Name:\n");
            PRINTF("Usage: ln [<MethodName> | <CodeAddr>]\n");
            PRINTF("<MethodName> - full path of method name\n");
            PRINTF("<CodeAddr>   - address of AML code\n");
        }
        else if (STRCMP(pszArg, "notify") == 0)
        {
            PRINTF("\nNotify a NameSpace Object:\n");
            PRINTF("Usage: notify <Obj> <Value>\n");
            PRINTF("<Obj>   - full NameSpace path of object or its address\n");
            PRINTF("<Value> - notification value\n");
        }
        else if (STRCMP(pszArg, "o") == 0)
        {
            PRINTF("\nWrite Data to a Byte Port:\n");
            PRINTF("Usage: o <Port> <Byte>\n");
            PRINTF("<Port> - port address\n");
            PRINTF("<Byte> - data to be written\n");
        }
        else if (STRCMP(pszArg, "ow") == 0)
        {
            PRINTF("\nWrite Data to a Word Port:\n");
            PRINTF("Usage: ow <Port> <Word>\n");
            PRINTF("<Port> - port address\n");
            PRINTF("<Word> - data to be written\n");
        }
        else if (STRCMP(pszArg, "od") == 0)
        {
            PRINTF("\nWrite Data to a DWord Port:\n");
            PRINTF("Usage: o <Port> <DWord>\n");
            PRINTF("<Port>  - port address\n");
            PRINTF("<DWord> - data to be written\n");
        }
        else if (STRCMP(pszArg, "p") == 0)
        {
            PRINTF("\nStep over AML Code\n");
            PRINTF("Usage: p\n");
        }
        else if (STRCMP(pszArg, "q") == 0)
        {
            PRINTF("\nQuit to kernel debugger:\n");
            PRINTF("Usage: q\n");
        }
        else if (STRCMP(pszArg, "r") == 0)
        {
            PRINTF("\nDisplay Context Information:\n");
            PRINTF("Usage: r\n");
        }
        else if (STRCMP(pszArg, "run") == 0)
        {
            PRINTF("\nRun a Method:\n");
            PRINTF("Usage: run <MethodName> | <CodeAddr> [<ArgList>]\n");
            PRINTF("<MethodName> - full path of method name\n");
            PRINTF("<CodeAddr>   - address of method\n");
            PRINTF("<ArgList>    - list of integer arguments\n");
        }
        else if (STRCMP(pszArg, "set") == 0)
        {
            PRINTF("\nSet Debugger Options:\n");
            PRINTF("Usage: set [traceon | traceoff] [nesttraceon | nesttraceoff] [spewon | spewoff]\n"
                   "           [lbrkon | lbrkoff] [errbrkon | errbrkoff] [verboseon | verboseoff]\n"
                   "           [logon | logoff] [logmuton | logmutoff] [logsize=<MaxNumEvents>]\n");
            PRINTF("traceon      - turn on AML tracing\n");
            PRINTF("traceoff     - turn off AML tracing\n");
            PRINTF("nesttraceon  - turn on nest tracing (only valid with traceon)\n");
            PRINTF("nesttraceoff - turn off nest tracing (only valid with traceon)\n");
            PRINTF("spewon       - turn on debug spew\n");
            PRINTF("spewoff      - turn off debug spew\n");
            PRINTF("lbrkon       - enable load DDB completion break\n");
            PRINTF("lbrkoff      - disable load DDB completion break\n");
            PRINTF("errbrkon     - enable break on error\n");
            PRINTF("errbrkoff    - disable break on error\n");
            PRINTF("verboseon    - enable verbose mode\n");
            PRINTF("verboseoff   - disable verbose mode\n");
            PRINTF("logon        - enable event logging\n");
            PRINTF("logoff       - disable event logging\n");
            PRINTF("logmuton     - enable mutex event logging\n");
            PRINTF("logmutoff    - disable mutex event logging\n");
        }
        else if (STRCMP(pszArg, "t") == 0)
        {
            PRINTF("\nTrace Into AML Code:\n");
            PRINTF("Usage: t\n");
        }
      #ifdef TRACING
        else if (STRCMP(pszArg, "trace") == 0)
        {
            PRINTF("\nInterpreter Trace Mode:\n");
            PRINTF("Usage: trace [trigon] [trigoff] [level=<n>] [add=<TrigPtStr>] [zap=<TrigPtList>]\n");
            PRINTF("trigon       - turn on trace trigger mode\n");
            PRINTF("trigoff      - turn off trace trigger mode\n");
            PRINTF("level        - set trace level to <n>\n");
            PRINTF("add          - add trace trigger points\n");
            PRINTF("<TrigPtStr>  - list of trigger point strings separated by commas\n");
            PRINTF("zap          - zap trace trigger points\n");
            PRINTF("<TrigPtList> - list of trigger point numbers separated by commas\n");
        }
      #endif
        else if (STRCMP(pszArg, "u") == 0)
        {
            PRINTF("\nUnassemble AML code:\n");
            PRINTF("Usage: u [<MethodName> | <CodeAddr>]\n");
            PRINTF("<MethodName> - full path of method name\n");
            PRINTF("<CodeAddr>   - address of AML code\n");
        }
        else
        {
            DBG_ERROR(("invalid help command - %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }
    }
    //
    // User typed just a "?" without any arguments
    //
    else if (dwArgNum == 0)
    {
        PRINTF("\n");
        PRINTF("Help                     - ? [<Cmd>]\n");
        PRINTF("Clear Breakpoints        - bc <bp list> | *\n");
        PRINTF("Disable Breakpoints      - bd <bp list> | *\n");
        PRINTF("Enable Breakpoints       - be <bp list> | *\n");
        PRINTF("List Breakpoints         - bl\n");
        PRINTF("Set Breakpoints          - bp <MethodName> | <CodeAddr> ...\n");
        PRINTF("Clear Event Log          - cl\n");
        PRINTF("Dump Data                - d [[l=<Len>] <Addr>]\n");
        PRINTF("Dump Data Bytes          - db [[l=<Len>] <Addr>]\n");
        PRINTF("Dump Data Words          - dw [[l=<Len>] <Addr>]\n");
        PRINTF("Dump Data DWords         - dd [[l=<Len>] <Addr>]\n");
        PRINTF("Dump Data String         - da [[l=<Len>] <Addr>]\n");
        PRINTF("Dump Event Log           - dl\n");
      #ifdef DEBUG
        PRINTF("Dump Object Count Table  - dc\n");
        PRINTF("Dump Heap                - dh [<Addr>]\n");
        PRINTF("Dump Stack               - ds [/v] [<Addr>]\n");
      #else
        PRINTF("Dump Stack               - ds [<Addr>]\n");
      #endif
        PRINTF("Dump Name Space Object   - dns [[/s] [<NameStr> | <Addr>]]\n");
        PRINTF("Dump Data Object         - do <Addr>\n");
        PRINTF("Edit Memory              - e [<Addr> [<DataList>]]\n");
        PRINTF("Find NameSpace Object    - find <NameSeg>\n");
        PRINTF("Continue Execution       - g\n");
        PRINTF("Read Byte from Port      - i <Port>\n");
        PRINTF("Read Word from Port      - iw <Port>\n");
        PRINTF("Read DWord from Port     - id <Port>\n");
        PRINTF("List All Contexts        - lc\n");
        PRINTF("Display Nearest Method   - ln [<MethodName> | <CodeAddr>]\n");
        PRINTF("Notify NameSpace Object  - notify <Obj> <Value>\n");
        PRINTF("Write Byte to Port       - o <Port> <Byte>\n");
        PRINTF("Write Word to Port       - ow <Port> <Word>\n");
        PRINTF("Write DWord to Port      - od <Port> <DWord>\n");
        PRINTF("Step Over AML Code       - p\n");
        PRINTF("Quit to Kernel Debugger  - q\n");
        PRINTF("Display Context Info.    - r\n");
        PRINTF("Run Method               - run <MethodName> | <CodeAddr> [<ArgList>]\n");
        PRINTF("Set Debugger Options     - set [traceon | traceoff] [nesttraceon | nesttraceoff]\n"
               "                               [spewon | spewoff] [lbrkon | lbrkoff] \n"
               "                               [errbrkon | errbrkoff] [verboseon | verboseoff] \n"
               "                               [logon | logoff] [logmuton | logmutoff] \n");
        PRINTF("Trace Into AML Code      - t\n");
      #ifdef TRACING
        PRINTF("Interpreter Trace Mode   - trace [trigon] [trigoff] [level=<n>]\n"
               "                                 [add=<TrigPtStr] [zap=<TrigPtList>]\n");
      #endif
        PRINTF("Unassemble AML code      - u [<MethodName> | <CodeAddr>]\n");
    }

    return rc;
}       //DebugHelp

/***LP  DebugExpr - Parse debugger expression
 *
 *  ENTRY
 *      pszArg -> expression argument
 *      puipValue -> to hold the result of expression
 *      pfPhysical -> set to TRUE if the expression is a physical address
 *                    (NULL if don't allow physical address)
 *      ppns -> to hold the pointer of the nearest pns object
 *      pdwOffset -> to hold the offset of the address to the nearest pns object
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_CMD_FAILED
 */

LONG LOCAL DebugExpr(PSZ pszArg, PULONG_PTR puipValue, BOOLEAN *pfPhysical,
                     PPNSOBJ ppns, PULONG pdwOffset)
{
    LONG rc = DBGERR_NONE;
    PNSOBJ pns = NULL;
    ULONG dwOffset = 0;

    if (pfPhysical != NULL)
        *pfPhysical = FALSE;

    if ((pfPhysical != NULL) && (pszArg[0] == '%') && (pszArg[1] == '%'))
    {
        if (IsNumber(&pszArg[2], 16, puipValue))
        {
            *pfPhysical = TRUE;
        }
        else
        {
            DBG_ERROR(("invalid physical address - %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else if (!IsNumber(pszArg, 16, puipValue))
    {
        STRUPR(pszArg);
        if ((GetNameSpaceObject(pszArg, NULL, &pns, NSF_LOCAL_SCOPE) ==
             STATUS_SUCCESS) &&
            (pns->ObjData.dwDataType == OBJTYPE_METHOD))
        {
            *puipValue = (ULONG_PTR)
                        (((PMETHODOBJ)pns->ObjData.pbDataBuff)->abCodeBuff);
        }
        else
        {
            DBG_ERROR(("object not found or object is not a method - %s",
                       pszArg));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else if (FindObjSymbol((PUCHAR)*puipValue, &pns, &dwOffset))
    {
        if ((pns->ObjData.dwDataType != OBJTYPE_METHOD) ||
            (dwOffset >= pns->ObjData.dwDataLen -
                         FIELD_OFFSET(METHODOBJ, abCodeBuff)))
        {
            pns = NULL;
            dwOffset = 0;
        }
    }

    if (rc == DBGERR_NONE)
    {
        if (ppns != NULL)
            *ppns = pns;

        if (pdwOffset != NULL)
            *pdwOffset = dwOffset;
    }

    return rc;
}       //DebugExpr

/***LP  IsNumber - Check if string is a number, if so return the number
 *
 *  ENTRY
 *      pszStr -> string
 *      dwBase - base
 *      puipValue -> to hold the number
 *
 *  EXIT-SUCCESS
 *      returns TRUE - the string is a number
 *  EXIT-FAILURE
 *      returns FALSE - the string is not a number
 */

BOOLEAN LOCAL IsNumber(PSZ pszStr, ULONG dwBase, PULONG_PTR puipValue)
{
    BOOLEAN rc;
    PSZ psz;

    *puipValue = (ULONG_PTR)STRTOUL(pszStr, &psz, dwBase);
    if ((psz != pszStr) && (*psz == '\0'))
        rc = TRUE;
    else
        rc = FALSE;

    return rc;
}       //IsNumber


/***LP  DumpData - Dump data
 *
 *  ENTRY
 *      uipAddr - data address
 *      dwfUnitSize - DBGF_DUMPDATA_MASK flags
 *      dwLen - length of data range
 *      fPhysical - TRUE if uipAddr is a physical address
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DumpData(ULONG_PTR uipAddr, ULONG dwfUnitSize, ULONG dwLen,
                    BOOLEAN fPhysical)
{
    LONG rc = DBGERR_NONE;
    PUCHAR pbData = NULL;
    PSZ pszPrefix = "";

    gDebugger.dwfDebugger &= ~(DBGF_DUMPDATA_MASK | DBGF_DUMPDATA_PHYADDR);
    gDebugger.dwfDebugger |= dwfUnitSize;
    if (fPhysical)
    {
        gDebugger.dwfDebugger |= DBGF_DUMPDATA_PHYADDR;
        pszPrefix = "%%";
        if (MapUnmapPhysMem(NULL, uipAddr, dwLen, (PULONG_PTR)&pbData) !=
            STATUS_SUCCESS)
        {
            DBG_ERROR(("Failed to map physical address %x", uipAddr));
            rc = DBGERR_CMD_FAILED;
        }
    }
    else
        pbData = (PUCHAR)uipAddr;

    if (ASSERTRANGE(pbData, dwLen))
    {
        if (dwfUnitSize == DBGF_DUMPDATA_STRING)
        {
            gDebugger.uipDumpDataAddr = uipAddr;
            PRINTF("%s%08x: ", pszPrefix, uipAddr);
            while ((dwLen > 0) && (*pbData != '\0'))
            {
                PRINTF("%c",
                       ((*pbData >= ' ') && (*pbData <= '~'))? *pbData: '.');
                pbData++;
                dwLen--;
            }
            PRINTF("\n");
        }
        else
        {
            PUCHAR pbEnd = pbData + dwLen;
            ULONG dwDataSize = DATASIZE(dwfUnitSize);
            int i;

            for (i = 0; pbData < pbEnd;)
            {
                if (i == 0)
                    PRINTF("%s%08x: ", pszPrefix, uipAddr);
                else if ((i == 8) && (dwDataSize == sizeof(UCHAR)))
                    PRINTF("-");
                else
                    PRINTF(" ");

                switch (dwDataSize)
                {
                    case sizeof(UCHAR):
                        PRINTF("%02x", *pbData);
                        break;

                    case sizeof(USHORT):
                        PRINTF("%04x", *((PUSHORT)pbData));
                        break;

                    case sizeof(ULONG):
                        PRINTF("%08x", *((PULONG)pbData));
                }

                pbData += dwDataSize;
                uipAddr += (ULONG_PTR)dwDataSize;
                i += (int)dwDataSize;
                if (i == 0x10)
                {
                    if (dwDataSize == sizeof(UCHAR))
                    {
                        UCHAR b;

                        PRINTF(" ");
                        for (i = 0x10; i > 0; --i)
                        {
                            b = *(pbData - i);
                            PRINTF("%c", ((b >= ' ') && (b <= '~'))? b: '.');
                        }
                    }
                    i = 0;
                    PRINTF("\n");
                }
            }
            gDebugger.uipDumpDataAddr = uipAddr;
        }
    }
    else
    {
        DBG_ERROR(("invalid address %08x", uipAddr));
        rc = DBGERR_INVALID_CMD;
    }

    if (fPhysical && (pbData != NULL))
    {
        MapUnmapPhysMem(NULL, (ULONG_PTR)pbData, dwLen, NULL);
    }

    return rc;
}       //DumpData

/***LP  DebugDumpData - Dump data to debugger
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwfDataSize - data size flags
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDumpData(PCMDARG pArg, PSZ pszArg, ULONG dwfDataSize)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fProcessed = FALSE;
    #define DEF_LEN 0x80
    static ULONG dwLen = DEF_LEN;

    if (pszArg != NULL)
    {
        if ((pArg != NULL) && (pArg->dwArgType == AT_NUM))
        {
            dwLen = dwCmdArg;
        }
        else
        {
            ULONG_PTR uipAddr;
            BOOLEAN fPhysical;

            if (((rc = DebugExpr(pszArg, &uipAddr, &fPhysical, NULL, NULL)) ==
                 DBGERR_NONE) &&
                ((rc = DumpData(uipAddr, dwfDataSize, dwLen, fPhysical)) ==
                 DBGERR_NONE))
            {
                fProcessed = TRUE;
            }
        }
    }
    else
    {
        if (fProcessed)
            fProcessed = FALSE;
        else
        {
            rc = DumpData(gDebugger.uipDumpDataAddr, dwfDataSize, dwLen,
                          (BOOLEAN)((gDebugger.dwfDebugger &
                                     DBGF_DUMPDATA_PHYADDR) != 0));
        }
        dwLen = DEF_LEN;
    }

    return rc;
}       //DebugDumpData

/***LP  DebugD - Dump data
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugDumpData(pArg, pszArg,
                       gDebugger.dwfDebugger & DBGF_DUMPDATA_MASK);

    return rc;
}       //DebugD

/***LP  DebugDB - Dump data bytes
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDB(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugDumpData(pArg, pszArg, DBGF_DUMPDATA_BYTE);

    return rc;
}       //DebugDB

/***LP  DebugDW - Dump data words
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDW(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugDumpData(pArg, pszArg, DBGF_DUMPDATA_WORD);

    return rc;
}       //DebugDW

/***LP  DebugDD - Dump data dwords
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugDumpData(pArg, pszArg, DBGF_DUMPDATA_DWORD);

    return rc;
}       //DebugDD

/***LP  DebugDA - Dump data string
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDA(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugDumpData(pArg, pszArg, DBGF_DUMPDATA_STRING);

    return rc;
}       //DebugDA

#ifdef DEBUG
/***LP  DebugDC - Dump memory object count table
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugDC(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        DumpMemObjCounts();
        rc = DBGERR_NONE;
    }
    else
    {
        DBG_ERROR(("invalid dump object count command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DebugDC

#endif

/***LP  DebugEditMem - Edit memory
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwfDataSize - data size flags
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugEditMem(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                        ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fProcessed = FALSE;
    static BOOLEAN fPhysical = FALSE;
    static ULONG_PTR uipAddr = 0;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        ULONG_PTR uipData;
        PUCHAR pbMemAddr;

        if (dwArgNum == 1)
        {
            if (pszArg[0] == '%')
            {
                if (IsNumber(&pszArg[2], 16, &uipData))
                {
                    fPhysical = TRUE;
                    uipAddr = uipData;
                }
                else
                {
                    DBG_ERROR(("invalid physical address - %s", pszArg));
                    rc = DBGERR_INVALID_CMD;
                }
            }
            else if (IsNumber(pszArg, 16, &uipData))
            {
                uipAddr = uipData;
            }
            else
            {
                DBG_ERROR(("invalid address - %s", pszArg));
                rc = DBGERR_INVALID_CMD;
            }
        }
        else if (IsNumber(pszArg, 16, &uipData))
        {
            if (uipData <= MAX_BYTE)
            {
                if (fPhysical)
                {
                    if (MapUnmapPhysMem(NULL, uipAddr, 1,
                                        (PULONG_PTR)&pbMemAddr) !=
                        STATUS_SUCCESS)
                    {
                        DBG_ERROR(("Failed to map physical address %p",
                                   uipAddr));
                        rc = DBGERR_CMD_FAILED;
                    }
                }
                else
                    pbMemAddr = (PUCHAR)uipAddr;

                if (ASSERTRANGE(pbMemAddr, 1))
                {
                    *pbMemAddr = (UCHAR)uipData;
                    uipAddr++;
                }
                else
                {
                    DBG_ERROR(("invalid address - %s", uipAddr));
                    rc = DBGERR_INVALID_CMD;
                }

                if (fPhysical)
                {
                    MapUnmapPhysMem(NULL, (ULONG_PTR)pbMemAddr, 1, NULL);
                }
            }
            else
            {
                DBG_ERROR(("data must be a byte value - %s", pszArg));
                rc = DBGERR_INVALID_CMD;
            }
        }
        else if ((pszArg[0] == '"') && (pszArg[STRLEN(pszArg) - 1] == '"'))
        {
            int i, icLen;

            icLen = STRLEN(pszArg);
            if (fPhysical)
            {
                if (MapUnmapPhysMem(NULL, uipAddr, icLen,
                                    (PULONG_PTR)&pbMemAddr) != STATUS_SUCCESS)
                {
                    DBG_ERROR(("Failed to map physical address %p", uipAddr));
                    rc = DBGERR_CMD_FAILED;
                }
            }
            else
                pbMemAddr = (PUCHAR)uipAddr;

            if (ASSERTRANGE(pbMemAddr, icLen))
            {
                for (i = 1; i < icLen - 1; ++i)
                {
                    *pbMemAddr = pszArg[i];
                    pbMemAddr++;
                    uipAddr++;
                }
            }
            else
            {
                DBG_ERROR(("invalid address - %s", uipAddr));
                rc = DBGERR_INVALID_CMD;
            }

            if (fPhysical)
            {
                MapUnmapPhysMem(NULL, (ULONG_PTR)pbMemAddr, icLen, NULL);
            }
        }
        else
        {
            DBG_ERROR(("invalid data - %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }

        if ((rc == DBGERR_NONE) && (dwArgNum > 1))
            fProcessed = TRUE;
    }
    else
    {
        if (fProcessed)
            fProcessed = FALSE;
        else
        {
            DBG_ERROR(("invalid EditMemory command"));
            rc = DBGERR_INVALID_CMD;
        }
        fPhysical = FALSE;
    }

    return rc;
}       //DebugEditMem


/***LP  InPort - Read from an I/O port
 *
 *  dwPort - port address
 *  dwSize - port size
 *  pdwData -> to hold data read
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL InPort(ULONG dwPort, ULONG dwSize, PULONG pdwData)
{
    LONG rc = DBGERR_NONE;
    PHYSICAL_ADDRESS phyaddr = {0, 0}, XlatedAddr;
    ULONG dwAddrSpace;

    phyaddr.LowPart = dwPort;
    dwAddrSpace = 1;
    if (HalTranslateBusAddress(Internal, 0, phyaddr, &dwAddrSpace, &XlatedAddr))
    {
        dwPort = XlatedAddr.LowPart;
        *pdwData = ReadSystemIO(dwPort, dwSize, 0xffffffff);
    }
    else
    {
        DBG_ERROR(("failed to translate port address"));
        rc = DBGERR_CMD_FAILED;
    }

    return rc;
}       //InPort

/***LP  DebugInPort - Port input
 *
 *  ENTRY
 *      pszArg -> argument string
 *      dwSize - port size
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugInPort(PSZ pszArg, ULONG dwSize)
{
    LONG rc = DBGERR_NONE;
    static BOOLEAN fProcessed = FALSE;

    if (pszArg != NULL)
    {
        ULONG_PTR uipPort;

        if (fProcessed || !IsNumber(pszArg, 16, &uipPort))
        {
            DBG_ERROR(("invalid inport command"));
            rc = DBGERR_INVALID_CMD;
        }
        else
        {
            ULONG dwData;

            if ((rc = InPort((ULONG)uipPort, dwSize, &dwData)) == DBGERR_NONE)
            {
                PRINTF("%04x: ", (ULONG)uipPort);
                switch (dwSize)
                {
                    case sizeof(UCHAR):
                        PRINTF("%02x", (UCHAR)dwData);
                        break;

                    case sizeof(USHORT):
                        PRINTF("%04x", (USHORT)dwData);
                        break;

                    case sizeof(ULONG):
                        PRINTF("%08x", dwData);
                }
                PRINTF("\n");
            }
        }

        if (rc == DBGERR_NONE)
            fProcessed = TRUE;
    }
    else
    {
        if (fProcessed)
            fProcessed = FALSE;
        else
        {
            DBG_ERROR(("invalid inport command"));
            rc = DBGERR_INVALID_CMD;
        }
    }

    return rc;
}       //DebugInPort

/***LP  DebugI - Byte port input
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugI(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugInPort(pszArg, sizeof(UCHAR));

    return rc;
}       //DebugI

/***LP  DebugIW - Word port input
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugIW(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugInPort(pszArg, sizeof(USHORT));

    return rc;
}       //DebugIW

/***LP  DebugID - DWord port input
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugID(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugInPort(pszArg, sizeof(ULONG));

    return rc;
}       //DebugID

/***LP  DebugQuit - Quit to kernel debugger
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugQuit(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        if (gDebugger.dwfDebugger & DBGF_IN_VXDMODE)
        {
            rc = DBGERR_QUIT;
        }
        else
        {
            PRINTF("\nShell to Kernel Debugger.\n"
                   "Type 'g' to go back to the AML debugger.\n\n");
            gDebugger.dwfDebugger |= DBGF_IN_KDSHELL;
            KdBreakPoint();
            gDebugger.dwfDebugger &= ~DBGF_IN_KDSHELL;
            rc = DBGERR_NONE;
        }
    }
    else
    {
        DBG_ERROR(("invalid Quit command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DebugQuit


/***LP  DummyCallBack - Callback that does absolutely nothing
 *
 *  ENTRY
 *      pv - not used
 *
 *  EXIT
 *      None
 */

VOID LOCAL DummyCallBack(PVOID pv)
{
    DEREF(pv);
}       //DummyCallBack

/***LP  DebugNotify - Notify object
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugNotify(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                       ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static PNSOBJ pns = NULL;
    static ULONG_PTR uipValue = 0;

    DEREF(pArg);

    if (pszArg != NULL)
    {
        switch (dwArgNum)
        {
            case 1:
                if (!IsNumber(pszArg, 16, (PULONG_PTR)&pns))
                {
                    STRUPR(pszArg);
                    if (GetNameSpaceObject(pszArg, NULL, &pns, NSF_LOCAL_SCOPE)
                        != STATUS_SUCCESS)
                    {
                        DBG_ERROR(("object not found - %s", pszArg));
                        rc = DBGERR_INVALID_CMD;
                    }
                }
                break;

            case 2:
                if (!IsNumber(pszArg, 16, &uipValue))
                {
                    DBG_ERROR(("invalid notification value - %s", pszArg));
                    rc = DBGERR_INVALID_CMD;
                }
                break;

            default:
                DBG_ERROR(("invalid notify command"));
                rc = DBGERR_INVALID_CMD;
        }
    }
    else
    {
        if (dwNonSWArgs != 2)
        {
            DBG_ERROR(("invalid notify command"));
            rc = DBGERR_INVALID_CMD;
        }
        else if (!ASSERTRANGE(pns, sizeof(NSOBJ)))
        {
            DBG_ERROR(("invalid object"));
            rc = DBGERR_INVALID_CMD;
        }
        else
        {
            PRINTF("Queuing: Notify(%s, %x) ...\n",
                   GetObjectPath(pns), uipValue);

            ((PFNNH)ghNotify.pfnHandler)(EVTYPE_NOTIFY, (ULONG)uipValue, pns,
                                         (ULONG)ghNotify.uipParam,
                                         DummyCallBack, NULL);
        }
    }

    return rc;
}       //DebugNotify

/***LP  OutPort - Write to an I/O port
 *
 *  dwPort - port address
 *  dwSize - port size
 *  dwData - data to be written
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL OutPort(ULONG dwPort, ULONG dwSize, ULONG dwData)
{
    LONG rc = DBGERR_NONE;
    PHYSICAL_ADDRESS phyaddr = {0, 0}, XlatedAddr;
    ULONG dwAddrSpace;

    phyaddr.LowPart = dwPort;
    dwAddrSpace = 1;
    if (HalTranslateBusAddress(Internal, 0, phyaddr, &dwAddrSpace, &XlatedAddr))
    {
        dwPort = XlatedAddr.LowPart;
        WriteSystemIO(dwPort, dwSize, dwData);
    }
    else
    {
        DBG_ERROR(("failed to translate port address"));
        rc = DBGERR_CMD_FAILED;
    }

    return rc;
}       //OutPort

/***LP  DebugOutPort - Port output
 *
 *  ENTRY
 *      pszArg -> argument string
 *      dwSize - port size
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugOutPort(PSZ pszArg, ULONG dwSize)
{
    LONG rc = DBGERR_NONE;
    static int icArgs = 0;
    static ULONG dwPort = 0;

    if (pszArg != NULL)
    {
        ULONG_PTR uipData;

        icArgs++;
        if ((icArgs > 2) || !IsNumber(pszArg, 16, &uipData))
        {
            DBG_ERROR(("invalid outport command"));
            rc = DBGERR_INVALID_CMD;
        }
        else if (icArgs == 1)
        {
            dwPort = (ULONG)uipData;
        }
        else
        {
            OutPort(dwPort, dwSize, (ULONG)uipData);
        }

        if (rc != DBGERR_NONE)
            icArgs = 0;
    }
    else
    {
        if (icArgs != 2)
        {
            DBG_ERROR(("invalid outport command"));
            rc = DBGERR_INVALID_CMD;
        }
        icArgs = 0;
    }

    return rc;
}       //DebugOutPort

/***LP  DebugO - Byte port output
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugO(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugOutPort(pszArg, sizeof(UCHAR));

    return rc;
}       //DebugO

/***LP  DebugOW - Word port output
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugOW(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugOutPort(pszArg, sizeof(USHORT));

    return rc;
}       //DebugOW

/***LP  DebugOD - DWord port output
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugOD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    rc = DebugOutPort(pszArg, sizeof(ULONG));

    return rc;
}       //DebugOD


/***LP  DebugStep - Trace and step over an AML instruction
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugStep(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        gDebugger.dwfDebugger |= DBGF_STEP_OVER;
        rc = DBGERR_QUIT;
    }
    else
    {
        DBG_ERROR(("invalid step command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DebugStep


/***LP  DebugSetLogSize - Set EventLog size
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugSetLogSize(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(pszArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (!SetLogSize(dwCmdArg))
    {
        DBG_ERROR(("failed to set EventLog size to %d", dwCmdArg));
        rc = DBGERR_CMD_FAILED;
    }

    return rc;
}       //DebugSetLogSize

/***LP  SetLogSize - Set EventLog size
 *
 *  ENTRY
 *      dwLogSize - EventLog size
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN LOCAL SetLogSize(ULONG dwLogSize)
{
    BOOLEAN rc = FALSE;

    if (gDebugger.pEventLog != NULL)
    {
        MFREE(gDebugger.pEventLog);
        gDebugger.pEventLog = NULL;
        gDebugger.dwLogSize = 0;
        gDebugger.dwLogIndex = 0;
    }

    if ((gDebugger.pEventLog = MALLOC_LOCKED(sizeof(EVENTLOG)*dwLogSize,
                                             'GOLE')) != NULL)
    {
        gDebugger.dwLogSize = dwLogSize;
        gDebugger.dwLogIndex = 0;
        MEMZERO(gDebugger.pEventLog, sizeof(EVENTLOG)*dwLogSize);
        rc = TRUE;
    }

    return rc;
}       //SetLogSize

/***LP  DebugTrace - Single-step an AML instruction
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugTrace(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                      ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        gDebugger.dwfDebugger |= DBGF_SINGLE_STEP;
        rc = DBGERR_QUIT;
    }
    else
    {
        DBG_ERROR(("invalid trace command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DebugTrace


BOOLEAN fRunningMethod = FALSE;

/***LP  DebugRunMethod - Run Method
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DebugRunMethod(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                          ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static int icArgs = -1;
    static PNSOBJ pns = NULL;
    static OBJDATA Args[MAX_NUM_ARGS] = {0};
    static OBJDATA Result;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (fRunningMethod)
    {
        DBG_ERROR(("Cannot run method while previous method is still pending"));
        rc = DBGERR_CMD_FAILED;
    }
    else if (pszArg != NULL)
    {
        if (icArgs == -1)
        {
            PUCHAR pbAddr;

            if ((rc = DebugExpr(pszArg, (PULONG_PTR)&pbAddr, NULL, &pns, NULL))
                == DBGERR_NONE)
            {
                if (pns != NULL)
                {
                    pns = GetBaseObject(pns);
                    icArgs = 0;
                }
                else
                {
                    DBG_ERROR(("invalid method or method not found"));
                    rc = DBGERR_CMD_FAILED;
                }
            }
        }
        else if (icArgs < MAX_NUM_ARGS)
        {
            MEMZERO(&Args[icArgs], sizeof(OBJDATA));
            if (IsNumber(pszArg, 0, &Args[icArgs].uipDataValue))
            {
                Args[icArgs].dwDataType = OBJTYPE_INTDATA;
                icArgs++;
            }
            else
            {
                DBG_ERROR(("invalid argument %s (can only be integer)",
                           pszArg));
                rc = DBGERR_INVALID_CMD;
            }
        }
        else
        {
            DBG_ERROR(("too many arguments"));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else if (icArgs >= 0)
    {
        NTSTATUS rcAMLI;

        MEMZERO(&Result, sizeof(OBJDATA));
        fRunningMethod = TRUE;
        if ((rcAMLI = AsyncEvalObject(pns, &Result, icArgs, Args,
                                      RunMethodCallBack, NULL, TRUE)) !=
            AMLISTA_PENDING)
        {
            RunMethodCallBack(pns, rcAMLI, &Result, NULL);
            if (rcAMLI != STATUS_SUCCESS)
            {
                rc = DBGERR_CMD_FAILED;
            }
        }
        else
        {
            PRINTF("\n%s returned PENDING\n", GetObjectPath(pns));
        }

        icArgs = -1;
    }
    else
    {
        DBG_ERROR(("invalid run command"));
        rc = DBGERR_CMD_FAILED;
    }

    if (rc != DBGERR_NONE)
    {
        icArgs = -1;
    }

    return rc;
}       //DebugRunMethod

/***LP  RunMethodCallBack - RunMethod completion callback
 *
 *  ENTRY
 *      pns -> method object
 *      rc - execution status code
 *      pdata -> result data
 *      pvContext -> context data
 *
 *  EXIT
 *      None
 */

VOID EXPORT RunMethodCallBack(PNSOBJ pns, NTSTATUS rc, POBJDATA pdata,
                              PVOID pvContext)
{
    DEREF(pvContext);

    if (rc == STATUS_SUCCESS)
    {
        PRINTF("\n%s completed successfully with object data:\n",
               GetObjectPath(pns));
        DumpObject(pdata, NULL, 0);
    }
    else
    {
        PSZ pszErr;

        AMLIGetLastError(&pszErr);
        PRINTF("\n%s failed with the following error:\n%s\n",
               GetObjectPath(pns), pszErr);
    }
    fRunningMethod = FALSE;
}       //RunMethodCallBack

/***LP  AddObjSymbol - Add object to symbol table
 *
 *  ENTRY
 *      pbOp -> code address
 *      pnsObj -> object
 *
 *  EXIT
 *      None
 */

VOID LOCAL AddObjSymbol(PUCHAR pbOp, PNSOBJ pnsObj)
{
    POBJSYM pos, p;

    if ((pos = NEWSYOBJ(sizeof(OBJSYM))) == NULL)
    {
        AMLI_ERROR(("AddObjSymbol: failed to allocate symbol buffer"));
    }
    else
    {
        MEMZERO(pos, sizeof(OBJSYM));
        pos->pbOp = pbOp;
        pos->pnsObj = pnsObj;

        if (gDebugger.posSymbolList == NULL)
        {
            gDebugger.posSymbolList = pos;
        }
        else if (pbOp < gDebugger.posSymbolList->pbOp)
        {
            pos->posNext = gDebugger.posSymbolList;
            gDebugger.posSymbolList->posPrev = pos;
            gDebugger.posSymbolList = pos;
        }
        else
        {
            for (p = gDebugger.posSymbolList; p != NULL; p = p->posNext)
            {
                if (pbOp < p->pbOp)
                {
                    pos->posNext = p;
                    pos->posPrev = p->posPrev;
                    p->posPrev->posNext = pos;
                    p->posPrev = pos;
                    break;
                }
                else if (p->posNext == NULL)
                {
                    pos->posPrev = p;
                    p->posNext = pos;
                    break;
                }
            }
        }
    }
}       //AddObjSymbol

/***LP  FreeSymList - Free all object symbols
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeSymList(VOID)
{
    POBJSYM pos, posNext;

    for (pos = gDebugger.posSymbolList; pos != NULL; pos = posNext)
    {
        posNext = pos->posNext;
        FREESYOBJ(pos);
    }
}       //FreeSymList

/***LP  FindObjSymbol - Find nearest object with given address
 *
 *  ENTRY
 *      pbOp - address
 *      ppns -> to hold the nearest object
 *      pdwOffset - to hold offset from the nearest object
 *
 *  EXIT-SUCCESS
 *      returns TRUE - found a nearest object
 *  EXIT-FAILURE
 *      returns FALSE - cannot found nearest object
 */

BOOLEAN LOCAL FindObjSymbol(PUCHAR pbOp, PPNSOBJ ppns, PULONG pdwOffset)
{
    BOOLEAN rc = FALSE;
    POBJSYM pos;

    for (pos = gDebugger.posSymbolList; pos != NULL; pos = pos->posNext)
    {
        if (pbOp <= pos->pbOp)
        {
            if ((pbOp < pos->pbOp) && (pos->posPrev != NULL))
                pos = pos->posPrev;

            if (pbOp >= pos->pbOp)
            {
                *ppns = pos->pnsObj;
                *pdwOffset = (ULONG)(pbOp - pos->pbOp);
                rc = TRUE;
            }
            break;
        }
    }

    return rc;
}       //FindObjSymbol

/***LP  CheckBP - Check given address is in the breakpoint list
 *
 *  ENTRY
 *      pbOp - address
 *
 *  EXIT-SUCCESS
 *      returns breakpoint number
 *  EXIT-FAILURE
 *      returns -1
 */


int LOCAL CheckBP(PUCHAR pbOp)
{
    int i;

    for (i = 0; i < MAX_BRK_PTS; ++i)
    {
        if (pbOp == gDebugger.BrkPts[i].pbBrkPt)
        {
            break;
        }
    }

    if ((i == MAX_BRK_PTS) ||
        !(gDebugger.BrkPts[i].dwfBrkPt & BPF_ENABLED))
    {
        i = -1;
    }

    return i;
}       //CheckBP

/***LP  PrintfBuffData - Print buffer data
 *
 *  ENTRY
 *      pb -> buffer
 *      dwLen - length of buffer
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintBuffData(PUCHAR pb, ULONG dwLen)
{
    TRACENAME("PRINTBUFFDATA")
    int i, j;

    ENTER(4, ("PrintBuffData(pb=%x,Len=%d)\n", pb, dwLen));

    PRINTF("{");
    for (i = j = 0; i < (int)dwLen; ++i)
    {
        if (j == 0)
            PRINTF("\n\t0x%02x", pb[i]);
        else
            PRINTF(",0x%02x", pb[i]);

        j++;
        if (j >= 14)
            j = 0;
    }
    PRINTF("}");

    EXIT(4, ("PrintBuffData!\n"));
}       //PrintBuffData

/***LP  PrintIndent - Print indentation
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintIndent(PCTXT pctxt)
{
    TRACENAME("PRINTINDENT")
    int i;

    ENTER(4, ("PrintIndent(pctxt=%x,pbOp=%x)\n", pctxt, pctxt->pbOp));

    PRINTF("\n%I64x: ", (ULONG64)pctxt->pbOp);
    for (i = 0; i < gDebugger.iPrintLevel; ++i)
    {
        PRINTF("| ");
    }

    EXIT(4, ("PrintIndent!\n"));
}       //PrintIndent

/***LP  PrintObject - Print object content
 *
 *  ENTRY
 *      pdata -> object
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintObject(POBJDATA pdata)
{
    TRACENAME("PRINTOBJECT")
    int i;

    ENTER(4, ("PrintObject(pdata=%x)\n", pdata));

    switch (pdata->dwDataType)
    {
        case OBJTYPE_INTDATA:
            PRINTF("0x%p", pdata->uipDataValue);
            break;

        case OBJTYPE_STRDATA:
            PRINTF("\"%s\"", pdata->pbDataBuff);
            break;

        case OBJTYPE_BUFFDATA:
            PRINTF("Buffer(0x%x)", pdata->dwDataLen);
            PrintBuffData(pdata->pbDataBuff, pdata->dwDataLen);
            break;

        case OBJTYPE_PKGDATA:
            PRINTF("Package(%d){",
                   ((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements);
            for (i = 0;
                 i < (int)((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements;
                 ++i)
            {
                PRINTF("\n\t");
                PrintObject(&((PPACKAGEOBJ)pdata->pbDataBuff)->adata[i]);
                if (i + 1 < (int)((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements)
                    PRINTF(",");
            }
            PRINTF("}");
            break;

        default:
            PRINTF("<Obj=%p,Type=%s,Value=0x%p,Buff=%p,Len=%d>",
                   pdata, GetObjectTypeName(pdata->dwDataType),
                   pdata->uipDataValue, pdata->pbDataBuff, pdata->dwDataLen);
    }

    EXIT(4, ("PrintObject!\n"));
}       //PrintObject

/***LP  LogEvent - Log an event in the log buffer
 *
 *  ENTRY
 *      dwEvent - event type
 *      uipData1 - log data 1
 *      uipData2 - log data 2
 *      uipData3 - log data 3
 *      uipData4 - log data 4
 *      uipData5 - log data 5
 *      uipData6 - log data 6
 *      uipData7 - log data 7
 *
 *  EXIT
 *      None
 */

VOID LOCAL LogEvent(ULONG dwEvent, ULONG_PTR uipData1, ULONG_PTR uipData2,
                    ULONG_PTR uipData3, ULONG_PTR uipData4, ULONG_PTR uipData5,
                    ULONG_PTR uipData6, ULONG_PTR uipData7)
{
    if ((gDebugger.dwfDebugger & DBGF_LOGEVENT_ON) &&
        (gDebugger.pEventLog != NULL))
    {
        ULONG i = gDebugger.dwLogIndex;

        gDebugger.pEventLog[i].ullTime = KeQueryInterruptTime();
        gDebugger.pEventLog[i].dwEvent = dwEvent;
        gDebugger.pEventLog[i].uipData1 = uipData1;
        gDebugger.pEventLog[i].uipData2 = uipData2;
        gDebugger.pEventLog[i].uipData3 = uipData3;
        gDebugger.pEventLog[i].uipData4 = uipData4;
        gDebugger.pEventLog[i].uipData5 = uipData5;
        gDebugger.pEventLog[i].uipData6 = uipData6;
        gDebugger.pEventLog[i].uipData7 = uipData7;
        gDebugger.dwLogIndex++;
        if (gDebugger.dwLogIndex >= gDebugger.dwLogSize)
        {
            gDebugger.dwLogIndex = 0;
        }
    }
}       //LogEvent;

/***LP  LogSchedEvent - Log a scheduler event in the log buffer
 *
 *  ENTRY
 *      dwEvent - event type
 *      uipData1 - log data 1
 *      uipData2 - log data 2
 *      uipData3 - log data 3
 *
 *  EXIT
 *      None
 */

VOID LOCAL LogSchedEvent(ULONG dwEvent, ULONG_PTR uipData1, ULONG_PTR uipData2,
                         ULONG_PTR uipData3)
{
    if ((gDebugger.dwfDebugger & DBGF_LOGEVENT_ON) &&
        (gDebugger.pEventLog != NULL))
    {
        ULONG i = gDebugger.dwLogIndex;

        gDebugger.pEventLog[i].ullTime = KeQueryInterruptTime();
        gDebugger.pEventLog[i].dwEvent = dwEvent;
        gDebugger.pEventLog[i].uipData1 = (ULONG_PTR)KeGetCurrentThread();
        gDebugger.pEventLog[i].uipData2 = (ULONG_PTR)gReadyQueue.pkthCurrent;
        gDebugger.pEventLog[i].uipData3 = (ULONG_PTR)gReadyQueue.pctxtCurrent;
        gDebugger.pEventLog[i].uipData4 = (ULONG_PTR)gReadyQueue.dwfCtxtQ;
        gDebugger.pEventLog[i].uipData5 = uipData1;
        gDebugger.pEventLog[i].uipData6 = uipData2;
        gDebugger.pEventLog[i].uipData7 = uipData3;
        gDebugger.dwLogIndex++;
        if (gDebugger.dwLogIndex >= gDebugger.dwLogSize)
        {
            gDebugger.dwLogIndex = 0;
        }
    }
}       //LogSchedEvent

/***LP  LogError - Log error code and message
 *
 *  ENTRY
 *      rcErr - error code
 *
 *  EXIT
 *      None
 */

VOID LOCAL LogError(NTSTATUS rcErr)
{
    static struct _ErrMsg
    {
        NTSTATUS rcErr;
        PSZ      pszMsg;
    } ErrMsgTable[] =
    {
        AMLIERR_NONE,                   "Success",
        AMLIERR_OUT_OF_MEM,             "Failed to allocate memory",
        AMLIERR_INVALID_OPCODE,         "Invalid AML Opcode",
        AMLIERR_NAME_TOO_LONG,          "Object name is too long",
        AMLIERR_ASSERT_FAILED,          "Assertion failure",
        AMLIERR_INVALID_NAME,           "Invalid object name",
        AMLIERR_OBJ_NOT_FOUND,          "Object not found",
        AMLIERR_OBJ_ALREADY_EXIST,      "Object already exist",
        AMLIERR_INDEX_TOO_BIG,          "Index is too big",
        AMLIERR_ARG_NOT_EXIST,          "Argument does not exist",
        AMLIERR_FATAL,                  "Fatal error",
        AMLIERR_INVALID_SUPERNAME,      "Invalid SuperName",
        AMLIERR_UNEXPECTED_ARGTYPE,     "Unexpected argument type",
        AMLIERR_UNEXPECTED_OBJTYPE,     "Unexpected object type",
        AMLIERR_UNEXPECTED_TARGETTYPE,  "Unexpected target type",
        AMLIERR_INCORRECT_NUMARG,       "Incorrect number of arguments",
        AMLIERR_FAILED_ADDR_XLATE,      "Failed address translation",
        AMLIERR_INVALID_EVENTTYPE,      "Invalid event type",
        AMLIERR_REGHANDLER_FAILED,      "Failed to register event handler",
        AMLIERR_HANDLER_EXIST,          "Event handler already exist",
        AMLIERR_INVALID_DATA,           "Invalid data",
        AMLIERR_INVALID_REGIONSPACE,    "Invalid RegionSpace",
        AMLIERR_INVALID_ACCSIZE,        "Invalid AccessSize",
        AMLIERR_INVALID_TABLE,          "Invalid table",
        AMLIERR_ACQUIREGL_FAILED,       "Failed to acquire global lock",
        AMLIERR_ALREADY_INITIALIZED,    "AML Interpreter is already initialized",
        AMLIERR_NOT_INITIALIZED,        "AML Interpreter is not initialized",
        AMLIERR_MUTEX_INVALID_LEVEL,    "Invalid mutex sync level",
        AMLIERR_MUTEX_NOT_OWNED,        "Mutex object has no owner",
        AMLIERR_MUTEX_NOT_OWNER,        "Mutex object is owned by a different owner",
        AMLIERR_RS_ACCESS,              "RegionSpace handler error",
        AMLIERR_STACK_OVERFLOW,         "AML Stack overflow",
        AMLIERR_INVALID_BUFFSIZE,       "Invalid buffer size",
        AMLIERR_BUFF_TOOSMALL,          "Buffer is too small",
        AMLIERR_NOTIFY_FAILED,          "Notify handler failed",
        0,                              NULL
    };
    int i;

    gDebugger.rcLastError = rcErr;
    for (i = 0; ErrMsgTable[i].pszMsg != NULL; ++i)
    {
        if (rcErr == ErrMsgTable[i].rcErr)
        {
            sprintf(gDebugger.szLastError, MODNAME "_ERROR(%08x): %s",
                    rcErr, ErrMsgTable[i].pszMsg);
            break;
        }
    }

    ASSERT(ErrMsgTable[i].pszMsg != NULL);
}       //LogError

/***LP  CatError - Concat to error buffer
 *
 *  ENTRY
 *      pszFormat -> message format string
 *      ... - variable parameters according to format string
 *
 *  EXIT
 *      None
 */

VOID LOCAL CatError(PSZ pszFormat, ...)
{
    va_list marker;

    STRCAT(gDebugger.szLastError, "\n");
    va_start(marker, pszFormat);

    if(_vsnprintf(&gDebugger.szLastError[STRLEN(gDebugger.szLastError)],
             sizeof(gDebugger.szLastError) - STRLEN(gDebugger.szLastError),
             pszFormat, marker) == -1)
    {
        gDebugger.szLastError[sizeof(gDebugger.szLastError) - 1] = '\0';
    }
    
    va_end(marker);

    ConPrintf(gDebugger.szLastError);
    ConPrintf("\n");

    if (gDebugger.dwfDebugger & DBGF_ERRBREAK_ON)
    {
        AMLIDebugger(FALSE);
    }
}       //CatError

/***LP  ConPrintf - Console printf
 *
 *  ENTRY
 *      pszFormat -> format string
 *      ... - variable parameters according to format string
 *
 *  EXIT
 *      None
 */

VOID LOCAL ConPrintf(PSZ pszFormat, ...)
{
    static char szBuff[1024];
    va_list marker;

    va_start(marker, pszFormat);
    vsprintf(szBuff, pszFormat, marker);
    va_end(marker);
    if (gDebugger.hConMessage.pfnHandler != NULL) {

        ((PFNCM)gDebugger.hConMessage.pfnHandler)(
            szBuff,
            gDebugger.hConMessage.uipParam
            );

    } else {

        _PRINTF(szBuff);

    }
}       //ConPrintf

/***LP  ConPrompt - Console prompted input
 *
 *  ENTRY
 *      pszPrompt -> prompt string
 *      pszBuff -> input buffer
 *      dwcbBuff - buffer size
 */

VOID LOCAL ConPrompt(PSZ pszPrompt, PSZ pszBuff, ULONG dwcbBuff)
{

    if(gDebugger.dwfDebugger & ~DBGF_DEBUG_SPEW_ON)
    {
        CheckAndEnableDebugSpew(TRUE);
    }

    if (gDebugger.hConPrompt.pfnHandler != NULL)
    {
        ((PFNCP)gDebugger.hConPrompt.pfnHandler)(pszPrompt, pszBuff, dwcbBuff,
                                                 gDebugger.hConPrompt.uipParam);
    }
    else
    {
        DbgPrompt(pszPrompt, pszBuff, dwcbBuff);
    }
}       //ConPrompt


/***LP  CheckAndEnableDebugSpew - Enable debug spew if it is not already turned on.
 *
 *  ENTRY
 *      BOOLEAN fEnable - Enable iff TRUE.
 *
 *  EXIT
 *      BOOLEAN - TRUE on success.
 */
BOOLEAN LOCAL CheckAndEnableDebugSpew(BOOLEAN fEnable)
{
    BOOLEAN bRet = FALSE;
    
    if(KeGetCurrentIrql() < DISPATCH_LEVEL)
    {
        if(fEnable)
        {
            gDebugger.dwfDebugger |= DBGF_DEBUG_SPEW_ON;
            DbgSetDebugFilterState( DPFLTR_AMLI_ID, -1, TRUE);
        }
        else
        {
            DbgSetDebugFilterState( DPFLTR_AMLI_ID, -1, FALSE);
            gDebugger.dwfDebugger &= ~DBGF_DEBUG_SPEW_ON;
        }

        bRet = TRUE;
    }
    return bRet;
}

#endif  //ifdef DEBUGGER

#ifdef DEBUG
/***LP  DumpMemObjCounts - display memory object counts
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpMemObjCounts(VOID)
{
    static char szFormat[] = "Number of %s = %d\n";

    PRINTF("CurGlobalHeapSize=%d bytes\n", gdwGlobalHeapSize);
    PRINTF("RefGlobalHeapSize=%d bytes\n", gdwGHeapSnapshot);
    PRINTF("MaxLocalHeapSize =%d bytes\n", gdwLocalHeapMax);
    PRINTF("MaxLocalStackSize=%d bytes\n", gdwLocalStackMax);
    PRINTF(szFormat, "CtxtObj      ", gdwcCTObjs);
    PRINTF(szFormat, "HeapObj      ", gdwcHPObjs);
    PRINTF(szFormat, "SymbolObj    ", gdwcSYObjs);
    PRINTF(szFormat, "RSAccessObj  ", gdwcRSObjs);
    PRINTF(szFormat, "PassHookObj  ", gdwcPHObjs);
    PRINTF(szFormat, "DataObj      ", gdwcODObjs);
    PRINTF(szFormat, "NSObj        ", gdwcNSObjs);
    PRINTF(szFormat, "OwnerObj     ", gdwcOOObjs);
    PRINTF(szFormat, "BuffFieldObj ", gdwcBFObjs);
    PRINTF(szFormat, "StrDataObj   ", gdwcSDObjs);
    PRINTF(szFormat, "BuffDataObj  ", gdwcBDObjs);
    PRINTF(szFormat, "PackageObj   ", gdwcPKObjs);
    PRINTF(szFormat, "FieldUnitObj ", gdwcFUObjs);
    PRINTF(szFormat, "BankFieldObj ", gdwcKFObjs);
    PRINTF(szFormat, "FieldObj     ", gdwcFObjs);
    PRINTF(szFormat, "IndexFieldObj", gdwcIFObjs);
    PRINTF(szFormat, "OpRegion     ", gdwcORObjs);
    PRINTF(szFormat, "MutexObj     ", gdwcMTObjs);
    PRINTF(szFormat, "EventObj     ", gdwcEVObjs);
    PRINTF(szFormat, "MethodObj    ", gdwcMEObjs);
    PRINTF(szFormat, "PowerResObj  ", gdwcPRObjs);
    PRINTF(szFormat, "ProcessorObj ", gdwcPCObjs);
    PRINTF(szFormat, "CtxtResObj   ", gdwcCRObjs);
    PRINTF(szFormat, "MiscObj      ",
           gdwcMemObjs - gdwcCTObjs - gdwcHPObjs - gdwcSYObjs - gdwcRSObjs -
           gdwcPHObjs - gdwcCRObjs);
}       //DumpMemObjCounts
#endif  //ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\amlitest.c ===
/*++
Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    amlitest

Abstract:

    

Environment:

    kernel mode only

Notes:

--*/


/*
#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"  */


#include "pch.h"
//#include "amlihook.h"
//#include "amlitest.h" 

#define AMLIHOOK_DEBUG_ASYNC_AMLI ((ULONG)0x1)

#ifdef DBG


ULONG AmliTestDebugFlags=0x00;


#define AmliTest_DebugPrint(x)   AmliTestDebugPrintFunc x

CHAR AmliTestDebugBuffer[200];

//
//   Internal functions.
//


VOID
AmliTestDebugPrintFunc(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...)
   {
   va_list ap;
   va_start(ap, DebugMessage);


   if(DebugPrintLevel & AmliTestDebugFlags)
      {

       
       
      if(_vsnprintf(AmliTestDebugBuffer,
         200,
         DebugMessage, 
         ap) < 0)
      {
          //
          // _vsnprintf failed, don't print out anything.
          //
          AmliTestDebugBuffer[0] = '\0';
      }
      AmliTestDebugBuffer[199] = '\0';

      DbgPrint(AmliTestDebugBuffer);
      }
   }

#endif

//
//  AMLITest_Post_Generic
//

NTSTATUS 
AMLITest_Post_Generic(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS _Status)
   {

   //
   //--- Notify test driver off call status 
   //

   NTSTATUS  Status = 
      AmliHook_TestNotifyRet(
               *ppData,
               _Status);


   ExFreePool(*ppData);
   *ppData = NULL;
   return(Status);
   }

//
//  Exported functions.
//


//
//  Pre/Post GetNameSpaceObject
// 

NTSTATUS 
AMLITest_Pre_GetNameSpaceObject(
   IN PSZ pszObjPath, 
   IN PNSOBJ pnsScope,
   OUT PPNSOBJ ppns, 
   IN ULONG dwfFlags,
   PAMLIHOOK_DATA  * ppData)
   {
  
   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      {
      AmliHook_ProcessInternalError();
      return(STATUS_INSUFFICIENT_RESOURCES);
      }
   
   //
   //--- Notify test driver off call 
   //
   
   (*ppData)->Type = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_GET_NAME_SPACE_OBJECT;
   (*ppData)->State = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1 = (ULONG_PTR)pszObjPath;
   (*ppData)->Arg2 = (ULONG_PTR)pnsScope;
   (*ppData)->Arg3 = (ULONG_PTR)ppns;
   (*ppData)->Arg4 = (ULONG_PTR)dwfFlags;

   return(AmliHook_TestNotify(*ppData));
   }

NTSTATUS 
AMLITest_Post_GetNameSpaceObject(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {
   return(AMLITest_Post_Generic(ppData,Status));
   }



//
//  Pre/Post GetFieldUnitRegionObj
//


NTSTATUS 
AMLITest_Pre_GetFieldUnitRegionObj(
   IN PFIELDUNITOBJ pfu,
   OUT PPNSOBJ ppns,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Allocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);

   //
   //--- Notify test driver off call 
   //
   
   (*ppData)->Type = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_GET_FIELD_UNIT_REGION_OP;
   (*ppData)->State = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1 = (ULONG_PTR)pfu;
   (*ppData)->Arg2 = (ULONG_PTR)ppns;

   return(AmliHook_TestNotify(*ppData));
   }



NTSTATUS 
AMLITest_Post_GetFieldUnitRegionObj(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS _Status)
   {
   return(AMLITest_Post_Generic(ppData,_Status));
   }



//
//  Pre/Post EvalNameSpaceObject
//



NTSTATUS 
AMLITest_Pre_EvalNameSpaceObject(
   IN PNSOBJ pns,
   OUT POBJDATA pdataResult,
   IN int icArgs,
   IN POBJDATA pdataArgs,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);


   //
   //--- Notify test driver off call 
   //
   
   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_EVAL_NAME_SPACE_OBJECT;
   (*ppData)->State = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1 = (ULONG_PTR)pns;
   (*ppData)->Arg2 = (ULONG_PTR)pdataResult;
   (*ppData)->Arg3 = (ULONG_PTR)icArgs;
   (*ppData)->Arg4 = (ULONG_PTR)pdataArgs;

   return(AmliHook_TestNotify(*ppData));
   }
   
NTSTATUS 
AMLITest_Post_EvalNameSpaceObject(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS _Status)
   {
   return(AMLITest_Post_Generic(Data,_Status));
   }





//
//  CallBack Pre/Post AsyncEvalObject
//


VOID EXPORT
AMLITest_AsyncEvalObjectCallBack(
   IN PNSOBJ pns, 
   IN NTSTATUS status, 
   IN POBJDATA pdataResult, 
   IN PVOID Context)
   {

   PAMLIHOOK_DATA   pData = (PAMLIHOOK_DATA)Context;
   NTSTATUS RetStatus ; 
   PFNACB AcpiAsyncCallBack;
   PVOID AcpiContext;


   AcpiAsyncCallBack = (PFNACB)pData->Arg5;
   AcpiContext = (PVOID)pData->Arg6;


   if( (VOID*)(pData->Arg2) != (VOID*)pdataResult)
      AmliHook_ProcessInternalError();


   //
   //--- Notify test driver off call status 
   //

   RetStatus = AmliHook_TestNotifyRet(
               pData,
               status);


   AmliTest_DebugPrint((
      AMLIHOOK_DEBUG_ASYNC_AMLI,
      "DEBUG:  AMLITest_AsyncEvalObjectCallBack Data=%lx\n",
      pData));


   ExFreePool(pData);

   if(AcpiAsyncCallBack)
      {
   
      AcpiAsyncCallBack(
            pns,
            RetStatus,
            pdataResult,
            AcpiContext);
      }
  
   }



NTSTATUS 
AMLITest_Pre_AsyncEvalObject(
   IN PNSOBJ pns,
   OUT POBJDATA pdataResult,
   IN int icArgs,
   IN POBJDATA pdataArgs,
   IN PFNACB * pfnAsyncCallBack,
   IN PVOID * pvContext,
   PAMLIHOOK_DATA  * Data)
   {


   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *Data = 
      AmliHook_AllocAndInitTestData();
   if(!Data)
      return(STATUS_INSUFFICIENT_RESOURCES);


   //
   //--- Notify test driver off call 
   //
   
   (*Data)->Type = ACPIVER_DATA_TYPE_AMLI;
   (*Data)->SubType = ACPIVER_DATA_SUBTYPE_ASYNC_EVAL_OBJECT;
   (*Data)->State = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*Data)->Arg1 = (ULONG_PTR)pns;
   (*Data)->Arg2 = (ULONG_PTR)pdataResult;
   (*Data)->Arg3 = (ULONG_PTR)icArgs;
   (*Data)->Arg4 = (ULONG_PTR)pdataArgs;
   (*Data)->Arg5 = (ULONG_PTR)*pfnAsyncCallBack;
   (*Data)->Arg6 = (ULONG_PTR)*pvContext;

   //
   //  Hook my callback function , and conext.
   //

   *pfnAsyncCallBack = AMLITest_AsyncEvalObjectCallBack;
   *pvContext = *Data;


   return(AmliHook_TestNotify(*Data));
   }
   
   


NTSTATUS 
AMLITest_Post_AsyncEvalObject(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {


   AmliTest_DebugPrint((
      AMLIHOOK_DEBUG_ASYNC_AMLI,
      "DEBUG:  AMLITest_Post_AsyncEvalObject Data=%lx Pending=%s\n",
      *ppData,
      (Status == STATUS_PENDING)? "TRUE" : "FALSE"));

   
   if(Status == STATUS_PENDING)
      return(Status);

   //
   //--- Call back will not be called.
   //

   return(AMLITest_Post_Generic(ppData,Status));
   }


//
//  Pre/Post NestAsyncEvalObject
// 



NTSTATUS 
AMLITest_Pre_NestAsyncEvalObject(
   PNSOBJ pns,
   POBJDATA pdataResult,
   int icArgs,
   POBJDATA pdataArgs,
   PFNACB * pfnAsyncCallBack,
   PVOID * pvContext,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);


   
   //
   //--- Notify test driver off call 
   //
   
   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_NEST_ASYNC_EVAL_OBJECT;
   (*ppData)->State = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1 = (ULONG_PTR)pns;
   (*ppData)->Arg2 = (ULONG_PTR)pdataResult;
   (*ppData)->Arg3 = (ULONG_PTR)icArgs;
   (*ppData)->Arg4 = (ULONG_PTR)pdataArgs;
   (*ppData)->Arg5 = (ULONG_PTR)pfnAsyncCallBack;
   (*ppData)->Arg6 = (ULONG_PTR)pvContext;

   //
   //  Hook my callback function , and conext.
   //

   *pfnAsyncCallBack = AMLITest_AsyncEvalObjectCallBack;
   *pvContext = *ppData;

   

   return(AmliHook_TestNotify(*ppData));
   }
   

NTSTATUS 
AMLITest_Post_NestAsyncEvalObject(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {

   if(Status == STATUS_PENDING)
      return(Status);

   //
   //--- Work is done.
   //--- AMLITest_AsyncEvalObjectCallBack will not be called.
   //
   
   return(AMLITest_Post_Generic(ppData,Status));
   }

//
// Pre/Post EvalPackageElement
//


NTSTATUS 
AMLITest_Pre_EvalPackageElement(
   PNSOBJ pns,
   int iPkgIndex,
   POBJDATA pdataResult,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);


   //
   //--- Notify test driver off call 
   //

   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_EVAL_PACKAGE_ELEMENT;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1    = (ULONG_PTR)pns;
   (*ppData)->Arg2    = (ULONG_PTR)iPkgIndex;
   (*ppData)->Arg3    = (ULONG_PTR)pdataResult;

   return(AmliHook_TestNotify(*ppData));
   }


NTSTATUS 
AMLITest_Post_EvalPackageElement(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status)
   {
   return(AMLITest_Post_Generic(Data,Status));
   }


//
//  Pre/Post EvalPkgDataElement
//


NTSTATUS 
AMLITest_Pre_EvalPkgDataElement(
   POBJDATA pdataPkg,
   int iPkgIndex,
   POBJDATA pdataResult,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);

   //
   //--- Notify test driver off call 
   //

   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_EVAL_PKG_DATA_ELEMENT;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1    = (ULONG_PTR)pdataPkg;
   (*ppData)->Arg2    = (ULONG_PTR)iPkgIndex;
   (*ppData)->Arg3    = (ULONG_PTR)pdataResult;

   return(AmliHook_TestNotify(*ppData));
   }


NTSTATUS 
AMLITest_Post_EvalPkgDataElement(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {
   return(AMLITest_Post_Generic(ppData,Status));
   }


//
//  Pre/Post FreeDataBuffs
//


NTSTATUS
AMLITest_Pre_FreeDataBuffs(
   POBJDATA pdata, 
   int icData,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);
   //
   //--- Notify test driver off call 
   //

   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_FREE_DATA_BUFFS;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1    = (ULONG_PTR)pdata;
   (*ppData)->Arg2    = (ULONG_PTR)icData;

   return(AmliHook_TestNotify(*ppData));
   }

NTSTATUS 
AMLITest_Post_FreeDataBuffs(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {
   return(AMLITest_Post_Generic(ppData,Status));
   }



//
//  Pre/Post RegEventHandler.
//

NTSTATUS 
AMLIHook_Pre_RegEventHandler(
   ULONG dwEventType, 
   ULONG_PTR uipEventData,
   PFNHND * pfnHandler, 
   ULONG_PTR * uipParam,
   PAMLIHOOK_DATA  * ppData)
   {
   NTSTATUS Status;
   PFNHND EventHandler;
   ULONG_PTR EventParam;


   //
   //  Alocate and init AMLIHOOK_DATA
   //

   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);



   //
   //--- Querry the test driver for Event handler to
   //--- register.
   //

   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_REG_EVENT_HANDLER;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_QUERY;
   (*ppData)->Arg1    = (ULONG_PTR)dwEventType;
   (*ppData)->Arg2    = (ULONG_PTR)uipEventData;
   (*ppData)->Arg3    = (ULONG_PTR)*pfnHandler;
   (*ppData)->Arg4    = (ULONG_PTR)*uipParam;


   AmliHook_TestNotify(*ppData);


   if((*ppData)->Ret != STATUS_SUCCESS)
      DbgBreakPoint();

   EventHandler = (PFNHND)(*ppData)->Arg3;
   EventParam = (ULONG_PTR)(*ppData)->Arg4;


   if(EventHandler != *pfnHandler)
      {
      //
      // Test driver will hook this call
      // I will need values for both
      // params.
      //

      if(!EventHandler)
         AmliHook_ProcessInternalError();

      if(!EventParam)
         AmliHook_ProcessInternalError();

      *pfnHandler = EventHandler;
      *uipParam = EventParam;



      }

   //
   //--- Notify test driver off call 
   //

   AmliHook_InitTestData(*ppData);


   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_REG_EVENT_HANDLER;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1    = (ULONG_PTR)dwEventType;
   (*ppData)->Arg2    = (ULONG_PTR)uipEventData;

   return(AmliHook_TestNotify(*ppData));
   }

 

NTSTATUS 
AMLIHook_Post_RegEventHandler(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {
   return(AMLITest_Post_Generic(ppData,Status));
   }



//
//  CallBack , Pre/Post PauseInterpreter
//

VOID EXPORT
AMLITest_PauseInterpreterCallBack(
   PVOID Context)
   {
   NTSTATUS Status;
   PFNAA AcpiCallBack=NULL;
   PVOID AcpiContext=NULL;
   PAMLIHOOK_DATA  Data = (PAMLIHOOK_DATA)Context;

   //
   //--- Notify test driver off call status 
   //

   Status = AmliHook_TestNotifyRet(
               Data,
               STATUS_SUCCESS);

   AcpiCallBack = (PFNAA)Data->Arg1;
   AcpiContext  = (PVOID)Data->Arg2;


   ExFreePool(Data);


   if(AcpiCallBack)
      {
      AcpiCallBack(AcpiContext);
      }

   }


NTSTATUS 
AMLITest_Pre_PauseInterpreter(
   PFNAA * pfnCallBack, 
   PVOID * Context,
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //
 
   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);


   //
   //--- Notify test driver off call 
   //

   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_PAUSE_INTERPRETER;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_CALL;
   (*ppData)->Arg1    = (ULONG_PTR)*pfnCallBack;
   (*ppData)->Arg2    = (ULONG_PTR)*Context;


   //
   //  Hook my Callback context
   //

   *pfnCallBack = AMLITest_PauseInterpreterCallBack;
   *Context = *ppData;


   return(AmliHook_TestNotify(*ppData));
   }


NTSTATUS 
AMLITest_Post_PauseInterpreter(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {

   if(Status == STATUS_PENDING)
      return(Status);

   //
   //--- Call back will not be called.
   //
   
   Status = AmliHook_TestNotifyRet(
      *ppData,
      Status);

   ExFreePool(*ppData);
   *ppData = NULL;

   return(Status);
   }



//
//  Pre/Post ResumeInterpreter
//

NTSTATUS 
AMLITest_Pre_ResumeInterpreter(
   PAMLIHOOK_DATA  * ppData)
   {

   //
   //  Alocate and init AMLIHOOK_DATA
   //
 
   *ppData = 
      AmliHook_AllocAndInitTestData();
   if(!(*ppData))
      return(STATUS_INSUFFICIENT_RESOURCES);

   //
   //--- Notify test driver off call 
   //

   (*ppData)->Type    = ACPIVER_DATA_TYPE_AMLI;
   (*ppData)->SubType = ACPIVER_DATA_SUBTYPE_RESUME_INTERPRETER;
   (*ppData)->State   = AMLIHOOK_TEST_DATA_STATE_CALL;

   return(AmliHook_TestNotify(*ppData));
   }

NTSTATUS 
AMLITest_Post_ResumeInterpreter(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS Status)
   {
   return(AMLITest_Post_Generic(ppData,Status));
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\amldebug.h ===
/*** amldebug.h - AML Debugger Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/24/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _AMLDEBUG_H
#define _AMLDEBUG_H

#ifdef DEBUGGER

/*** Constants
 */

// DNS flags
#define DNSF_RECURSE            0x00000001

// DS flags
#define DSF_VERBOSE             0x00000001

// dwfDebug flags
#define DBGF_IN_DEBUGGER    0x00000001
#define DBGF_IN_VXDMODE         0x00000002
#define DBGF_IN_KDSHELL         0x00000004
#define DBGF_VERBOSE_ON         0x00000008
#define DBGF_AMLTRACE_ON        0x00000010
#define DBGF_TRIGGER_MODE       0x00000020
#define DBGF_SINGLE_STEP        0x00000040
#define DBGF_STEP_OVER          0x00000080
#define DBGF_STEP_MODES         (DBGF_SINGLE_STEP | DBGF_STEP_OVER)
#define DBGF_TRACE_NONEST       0x00000100
#define DBGF_DUMPDATA_PHYADDR   0x00000200
//
// Important! Don't move the DBGF_DUMPDATA_* bits unless you update the
// following DATASIZE() macro.
//
#define DBGF_DUMPDATA_MASK      0x00000c00
#define DBGF_DUMPDATA_BYTE      0x00000000
#define DBGF_DUMPDATA_WORD      0x00000400
#define DBGF_DUMPDATA_DWORD     0x00000800
#define DBGF_DUMPDATA_STRING    0x00000c00
#define DATASIZE(f)             (((f) == DBGF_DUMPDATA_STRING)? 0:      \
                                 (1L << ((f) >> 10)))

#define DBGF_DEBUGGER_REQ       0x00001000
#define DBGF_CHECKING_TRACE     0x00002000
#define DBGF_ERRBREAK_ON        0x00004000
#define DBGF_LOGEVENT_ON        0x00008000
#define DBGF_LOGEVENT_MUTEX     0x00010000
#define DBGF_DEBUG_SPEW_ON      0x00020000

#define MAX_TRIG_PTS            10
#define MAX_TRIGPT_LEN          31
#endif
#define MAX_ERRBUFF_LEN         255
#define MAX_BRK_PTS             10

#ifdef DEBUGGER
#define MAX_UNASM_CODES         0x10

#define DEF_MAXLOG_ENTRIES      204     //8K buffer

/*** Macros
 */

#define ASSERTRANGE(p,n)      (TRUE)

#endif
/*** Type definitions
 */

#define BPF_ENABLED             0x00000001

typedef struct _brkpt
{
    ULONG  dwfBrkPt;
    PUCHAR pbBrkPt;
} BRKPT, *PBRKPT;

typedef struct _objsym
{
    struct _objsym *posPrev;
    struct _objsym *posNext;
    PUCHAR pbOp;
    PNSOBJ pnsObj;
} OBJSYM, *POBJSYM;

typedef struct _eventlog
{
    ULONG         dwEvent;
    ULONGLONG     ullTime;
    ULONG_PTR     uipData1;
    ULONG_PTR     uipData2;
    ULONG_PTR     uipData3;
    ULONG_PTR     uipData4;
    ULONG_PTR     uipData5;
    ULONG_PTR     uipData6;
    ULONG_PTR     uipData7;
} EVENTLOG, *PEVENTLOG;


typedef struct _dbgr
{
    ULONG     dwfDebugger;
    int       iPrintLevel;
    ULONG_PTR uipDumpDataAddr;
    PUCHAR    pbUnAsm;
    PUCHAR    pbUnAsmEnd;
    PUCHAR    pbBlkBegin;
    PUCHAR    pbBlkEnd;
    POBJSYM   posSymbolList;
    BRKPT     BrkPts[MAX_BRK_PTS];
    ULONG     dwLogSize;
    ULONG     dwLogIndex;
    PEVENTLOG pEventLog;
    EVHANDLE  hConMessage;
    EVHANDLE  hConPrompt;
    NTSTATUS  rcLastError;
    char      szLastError[MAX_ERRBUFF_LEN + 1];
} DBGR, *PDBGR;

/*** Exported Data
 */

extern DBGR gDebugger;
#ifdef DEBUGGER
/*** Exported function prototypes
 */

VOID LOCAL AddObjSymbol(PUCHAR pbOp, PNSOBJ pnsObj);
VOID LOCAL FreeSymList(VOID);
int LOCAL CheckBP(PUCHAR pbOp);
VOID LOCAL PrintBuffData(PUCHAR pb, ULONG dwLen);
VOID LOCAL PrintIndent(PCTXT pctxt);
VOID LOCAL PrintObject(POBJDATA pdata);
VOID LOCAL LogEvent(ULONG dwEvent, ULONG_PTR uipData1, ULONG_PTR uipData2,
                    ULONG_PTR uipData3, ULONG_PTR uipData4, ULONG_PTR uipData5,
                    ULONG_PTR uipData6, ULONG_PTR uipData7);
VOID LOCAL LogSchedEvent(ULONG dwEvent, ULONG_PTR uipData1, ULONG_PTR uipData2,
                         ULONG_PTR uipData3);
BOOLEAN LOCAL SetLogSize(ULONG dwLogSize);
VOID LOCAL LogError(NTSTATUS rcErr);
VOID LOCAL CatError(PSZ pszFormat, ...);
VOID LOCAL ConPrintf(PSZ pszFormat, ...);
VOID LOCAL ConPrompt(PSZ pszPrompt, PSZ pszBuff, ULONG dwcbBuff);


#endif  //ifdef DEBUGGER

#ifdef DEBUG
VOID LOCAL DumpMemObjCounts(VOID);
#endif  //ifdef DEBUG

#endif  //ifndef _AMLDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\amlihook.c ===
/*++
Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    acpitl.c

Abstract:

    

Environment:

    kernel mode only

Notes:

  
    Things acpi.sys needs to do.

   1) Call  AmliHook_InitTestHookInterface() in its DriverEntry() very early.  

   This functyion will hook the amli functions if acpiver.sys is installed.

   2) Call AmliHook_UnInitTestHookInterface() on driver unload.
      This is not inteded to be called to disable Amli Hooking at runtime.


  

--*/


/*
#include "wdm.h"
#include "ntdddisk.h"
#include "stdarg.h"
#include "stdio.h"   */
//#include "wdm.h"

#include "pch.h"

//#include "amlihook.h" 

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'ihVA')
#endif

//
//  Globals
//

PCALLBACK_OBJECT g_AmliHookCallbackObject = NULL;
ULONG g_AmliHookTestFlags=0;
ULONG g_AmliHookIdCounter=0;
ULONG g_AmliHookEnabled = 0;


//
// -- Get dbg flags
//

extern NTSTATUS OSGetRegistryValue( 
    IN  HANDLE                          ParentHandle,
    IN  PWSTR                           ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  *Information);

extern NTSTATUS OSOpenUnicodeHandle(
    PUNICODE_STRING UnicodeKey,
    HANDLE          ParentHandle,
    PHANDLE         ChildHandle);

extern NTSTATUS
OSCloseHandle(
    HANDLE  Key);

//
//  Internal function defines.
//
ULONG
AmliHook_GetUniqueId(
   VOID);

//
//  Functions
//


ULONG 
AmliHook_GetDbgFlags(
   VOID)
   {

   UNICODE_STRING DriverKey;
   HANDLE DriverKeyHandle;
   NTSTATUS        status;
   PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  RegValue=NULL;
   ULONG DebugFlags;


   RtlInitUnicodeString( &DriverKey, 
      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\acpiver");


   status = OSOpenUnicodeHandle( 
     &DriverKey,
     NULL,
     &DriverKeyHandle);
   
   if (!NT_SUCCESS(status)) 
      {
      return(0);
      }


   status = OSGetRegistryValue(
      DriverKeyHandle,
      L"AcpiCtrl",
      &RegValue);

   if (!NT_SUCCESS(status)) 
      {
      OSCloseHandle(DriverKeyHandle);
      return(0);
      }

   if(RegValue->DataLength == 0  ||
      RegValue->Type != REG_DWORD) 
      {
      ExFreePool(RegValue);
      return(0);
      }

   DebugFlags = 
      *((ULONG*)( ((PUCHAR)RegValue->Data)));

   ExFreePool(RegValue);

   return(DebugFlags); 
   }

ULONG
AmliHook_GetUniqueId(
   VOID)
   {

   //  BUGBUG For some reason acpi.sys 
   //  will not link with this.
   //  Acpiver doesn't use the ID yet.
   //
   //return(InterlockedIncrement(
   //    &g_AmliHookIdCounter));

   g_AmliHookIdCounter++;
   return(g_AmliHookIdCounter);
   }

VOID
AmliHook_InitTestData(
   PAMLIHOOK_DATA Data)
   {
   RtlZeroMemory(Data,sizeof(AMLIHOOK_DATA));

   Data->Id = AmliHook_GetUniqueId();
   }

PAMLIHOOK_DATA
AmliHook_AllocAndInitTestData(
   VOID)
   {

   PAMLIHOOK_DATA Data = ExAllocatePool(NonPagedPool,sizeof(AMLIHOOK_DATA));
   if(!Data)
      {
      AmliHook_ProcessInternalError();
      return(NULL);
      }
   AmliHook_InitTestData(Data);
   return(Data);
   }

//
//  AmliHook_UnInitTestHookInterface
//

VOID
AmliHook_UnInitTestHookInterface(
   VOID)
   {

   if(g_AmliHookCallbackObject) 
      ObDereferenceObject(g_AmliHookCallbackObject);

   

   }

//
//  AmliHook_InitTestHookInterface
//

NTSTATUS
AmliHook_InitTestHookInterface(
   VOID)
   {
   NTSTATUS  status = STATUS_SUCCESS;
   
   g_AmliHookCallbackObject = NULL;
   g_AmliHookIdCounter = 0;
   g_AmliHookEnabled = 0;

   g_AmliHookTestFlags = AmliHook_GetDbgFlags();
 
   if(g_AmliHookTestFlags & AMLIHOOK_TEST_FLAGS_HOOK_MASK)
      {

      //
      //--- We want to hook the AMLI.api interface.
      //--- So create the notify interface.
      //

      OBJECT_ATTRIBUTES   objectAttributes;
      UNICODE_STRING CallBackName;
    
      RtlInitUnicodeString(&CallBackName,AMLIHOOK_CALLBACK_NAME);

      InitializeObjectAttributes (
          &objectAttributes,
         &CallBackName,
         OBJ_CASE_INSENSITIVE | OBJ_PERMANENT ,
         NULL,       
         NULL);
    
      status = ExCreateCallback(
          &g_AmliHookCallbackObject,
         &objectAttributes,
         TRUE, 
         TRUE);

      if(!NT_SUCCESS(status)) 
         {
         //
         //--- Failed 
         //
         AmliHook_ProcessInternalError();

         g_AmliHookCallbackObject = NULL;

         return(status);
         }
      else
         {

         //
         //--- Functions are hooked.
         //

         g_AmliHookEnabled = AMLIHOOK_ENABLED_VALUE;

         }
      }

   return(status);
   }


//
//  AmliHook_TestNotify
//

NTSTATUS
AmliHook_TestNotify(
   PAMLIHOOK_DATA Data)
   {

   if(g_AmliHookTestFlags & AMLIHOOK_TEST_FLAGS_NO_NOTIFY_ON_CALL)
      {
      //
      //--- do not notify on call, 
      //
      if(Data->State & AMLIHOOK_TEST_DATA_CALL_STATE_MASK)
         return(STATUS_SUCCESS);
      }

   if(!g_AmliHookCallbackObject)
      {
      AmliHook_ProcessInternalError();
      return(STATUS_UNSUCCESSFUL);
      }

    ExNotifyCallback(
      g_AmliHookCallbackObject,
      Data,
      NULL);

   return(STATUS_SUCCESS);
   }

NTSTATUS
AmliHook_TestNotifyRet(
   PAMLIHOOK_DATA Data,
   NTSTATUS Status)
   {

     
   if(!g_AmliHookCallbackObject)
      {
      AmliHook_ProcessInternalError();
      return(STATUS_UNSUCCESSFUL);
      }

   Data->State = AMLIHOOK_TEST_DATA_STATE_RETURN;
   Data->Ret = Status;

   ExNotifyCallback(
      g_AmliHookCallbackObject,
      Data,
      NULL);

   return(Data->Ret);
   }



VOID
AmliHook_ProcessInternalError(
   VOID)
   {

   if(g_AmliHookTestFlags & AMLIHOOK_TEST_FLAGS_DBG_ON_ERROR)
      DbgBreakPoint();

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\amliapi.c ===
/*** amliapi.c - AMLI APIs
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/13/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"
//#include "amlihook.h"
//#include "amlitest.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/*++
OSIAML contains the AML for the _OSI Method. This AML is generated from the following ASL:

Method(_OSI, 0x1, NotSerialized)
{
    Return(OSI(Arg0))
}
--*/

UCHAR OSIAML[] = {
                    0xa4, 0xca, 0x68
                  };


/***EP  AMLIInitialize - Initialize AML interpreter
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIInitialize | AML Interpreter initialization.
 *
 *          This function must be called before any AML interpreter functions
 *          can be called.  This function will typically allocate and
 *          initialize global resources, create the ACPI name space etc.
 *          It is typically called in the initialization of the ACPI core
 *          driver.
 *
 *  @PARM   ULONG | dwCtxtBlkSize | Specifies the size of Context blocks.  If
 *          zero, use default context block size.
 *
 *  @PARM   ULONG | dwGlobalHeapBlkSize | Specifies the size of Global heap.
 *          If zero, use default global heap size.
 *
 *  @PARM   ULONG | dwfAMLIInit | AMLI initialization flags.
 *
 *  @FLAG   AMLIIF_INIT_BREAK | Break into the debugger at initialization
 *          completion.
 *
 *  @FLAG   AMLIIF_LOADDDB_BREAK | Break into the debugger at load definition
 *          block completion.
 *
 *  @PARM   ULONG | dwmsTimeSliceLength | Time slice length in msec.
 *
 *  @PARM   ULONG | dwmsTimeSliceInterval | Time slice interval in msec.
 *
 *  @PARM   ULONG | dwmsMaxCTObjs | Number of context to allocate
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 */

NTSTATUS AMLIAPI AMLIInitialize(ULONG dwCtxtBlkSize, ULONG dwGlobalHeapBlkSize,
                                ULONG dwfAMLIInit, ULONG dwmsTimeSliceLength,
                                ULONG dwmsTimeSliceInterval, ULONG dwmsMaxCTObjs)
{
    TRACENAME("AMLIINITIALIZE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(1, ("AMLIInitialize(InitFlags=%x,CtxtBlkSize=%d,GlobalHeapBlkSize=%d,TimeSliceLen=%d,TimeSliceInterval=%d)\n",
              dwfAMLIInit, dwCtxtBlkSize, dwGlobalHeapBlkSize,
              dwmsTimeSliceLength, dwmsTimeSliceInterval));

  #ifndef DEBUGGER
    DEREF(dwfAMLIInit);
  #endif

    RESETERR();
    if (gpnsNameSpaceRoot != NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_ALREADY_INITIALIZED,
                         ("AMLIInitialize: interpreter already initialized"));
    }
    else
    {
        gdwCtxtBlkSize = dwCtxtBlkSize ? dwCtxtBlkSize: DEF_CTXTBLK_SIZE;
        gdwGlobalHeapBlkSize = dwGlobalHeapBlkSize? dwGlobalHeapBlkSize:
                                                    DEF_GLOBALHEAPBLK_SIZE;
        gdwfAMLIInit = dwfAMLIInit;
        gdwfHacks = GetHackFlags(NULL);

        //
        // Sanity Check
        //
        if (dwmsMaxCTObjs > 1024) {

            dwmsMaxCTObjs = 1024;

        }
        gdwcCTObjsMax = (dwmsMaxCTObjs > DEF_CTXTMAX_SIZE) ? dwmsMaxCTObjs :
                                                             DEF_CTXTMAX_SIZE;

      #ifdef DEBUGGER
        //   gDebugger.dwfDebugger |= (DBGF_LOGEVENT_ON | DBGF_ERRBREAK_ON);
        gDebugger.dwfDebugger |= DBGF_LOGEVENT_ON;
        SetLogSize(DEF_MAXLOG_ENTRIES);
        KeInitializeSpinLock( &gdwGHeapSpinLock );
      #endif
        KeInitializeSpinLock( &gdwGContextSpinLock );

        //
        // Initialize the LookAside lists.
        //
        ExInitializeNPagedLookasideList(
            &AMLIContextLookAsideList,
            NULL,
            NULL,
            0,
            gdwCtxtBlkSize,
            CTOBJ_TAG,
            (USHORT) gdwcCTObjsMax
            );

        if ((rc = NewHeap(gdwGlobalHeapBlkSize, &gpheapGlobal)) ==
            STATUS_SUCCESS)
        {
            int i;
            PNSOBJ pns;
            static PSZ apszDefinedRootObjs[] =
            {
                "_GPE", "_PR", "_SB", "_SI", "_TZ"
            };
            #define NUM_DEFINED_ROOT_OBJS (sizeof(apszDefinedRootObjs)/sizeof(PSZ))

            gpheapGlobal->pheapHead = gpheapGlobal;
            if ((rc = CreateNameSpaceObject(gpheapGlobal, NAMESTR_ROOT, NULL,
                                            NULL, NULL, 0)) == STATUS_SUCCESS)
            {
                for (i = 0; i < NUM_DEFINED_ROOT_OBJS; ++i)
                {
                    if ((rc = CreateNameSpaceObject(gpheapGlobal,
                                                    apszDefinedRootObjs[i],
                                                    NULL, NULL, NULL, 0)) !=
                        STATUS_SUCCESS)
                    {
                        break;
                    }
                }
            }

            if ((rc == STATUS_SUCCESS) &&
                ((rc = CreateNameSpaceObject(gpheapGlobal, "_REV", NULL, NULL,
                                             &pns, 0)) == STATUS_SUCCESS))
            {
                pns->ObjData.dwDataType = OBJTYPE_INTDATA;
                pns->ObjData.uipDataValue = AMLI_REVISION;
            }

            if ((rc == STATUS_SUCCESS) &&
                ((rc = CreateNameSpaceObject(gpheapGlobal, "_OS", NULL, NULL,
                                             &pns, 0)) == STATUS_SUCCESS))
            {
                pns->ObjData.dwDataType = OBJTYPE_STRDATA;
                pns->ObjData.dwDataLen = STRLEN(gpszOSName) + 1;
                if ((pns->ObjData.pbDataBuff = NEWSDOBJ(gpheapGlobal,
                                                        pns->ObjData.dwDataLen))
                    == NULL)
                {
                    rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                     ("AMLIInitialize: failed to allocate \\_OS name object"));
                }
                else
                {
                    MEMCPY(pns->ObjData.pbDataBuff, gpszOSName,
                           pns->ObjData.dwDataLen);
                }
            }

            if ((rc == STATUS_SUCCESS) &&
                ((rc = CreateNameSpaceObject(gpheapGlobal,"_OSI", NULL, NULL,
                                              &pns, 0)) == STATUS_SUCCESS))
            {

                pns->ObjData.dwDataType = OBJTYPE_METHOD;
                pns->ObjData.dwDataLen = sizeof(METHODOBJ) + sizeof(OSIAML) - sizeof(UCHAR);
                if ((pns->ObjData.pbDataBuff = NEWSDOBJ(gpheapGlobal,
                                                        pns->ObjData.dwDataLen))
                    == NULL)
                {
                    rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                     ("AMLIInitiaize: failed to allocate \\_OSI name object"));
                }
                else
                {
                    MEMZERO(pns->ObjData.pbDataBuff, pns->ObjData.dwDataLen);
                    //This method has one argument
                    ((PMETHODOBJ)(pns->ObjData.pbDataBuff))->bMethodFlags |=  0x1; 
                    
                    MEMCPY(((PMETHODOBJ)(pns->ObjData.pbDataBuff))->abCodeBuff, (PUCHAR)OSIAML,
                           sizeof(OSIAML));
                }
            }

            if ((rc == STATUS_SUCCESS) &&
                ((rc = CreateNameSpaceObject(gpheapGlobal, "_GL", NULL, NULL,
                                             &pns, 0)) == STATUS_SUCCESS))
            {
                pns->ObjData.dwfData = DATAF_GLOBAL_LOCK;
                rc = InitMutex(gpheapGlobal, pns, 0);
            }

            if (rc == STATUS_SUCCESS)
            {
                gReadyQueue.dwmsTimeSliceLength = dwmsTimeSliceLength?
                                                    dwmsTimeSliceLength:
                                                    DEF_TIMESLICE_LENGTH;
                gReadyQueue.dwmsTimeSliceInterval = dwmsTimeSliceInterval?
                                                      dwmsTimeSliceInterval:
                                                      DEF_TIMESLICE_INTERVAL;
                KeInitializeTimer(&gReadyQueue.Timer);
                InitializeMutex(&gReadyQueue.mutCtxtQ);
                ExInitializeWorkItem(&gReadyQueue.WorkItem,
                                     StartTimeSlicePassive, &gReadyQueue);
                InitializeMutex(&gmutCtxtList);
                InitializeMutex(&gmutOwnerList);
                InitializeMutex(&gmutHeap);
                InitializeMutex(&gmutSleep);
                KeInitializeDpc(&gReadyQueue.DpcStartTimeSlice,
                                StartTimeSlice,
                                &gReadyQueue);
                KeInitializeDpc(&gReadyQueue.DpcExpireTimeSlice,
                                ExpireTimeSlice,
                                &gReadyQueue);
                KeInitializeDpc(&SleepDpc, SleepQueueDpc, NULL);
                KeInitializeTimer(&SleepTimer);
                InitializeListHead(&SleepQueue);
                InitializeRegOverrideFlags();
                InitIllegalIOAddressListFromHAL();
            }
        }
    }

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

  #ifdef DEBUGGER
    if (gdwfAMLIInit & AMLIIF_INIT_BREAK)
    {
        PRINTF("\n" MODNAME ": Break at AMLI Initialization Completion.\n");
        AMLIDebugger(FALSE);
    }
  #endif

    EXIT(1, ("AMLIInitialize=%x\n", rc));
    return rc;
}       //AMLIInitialize

/***EP  AMLITerminate - Terminate AML interpreter
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLITerminate | AML Interpreter termination.
 *
 *          This function is called to clean up all the global resources used
 *          by the AML interpreter.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 */

NTSTATUS AMLIAPI AMLITerminate(VOID)
{
    TRACENAME("AMLITERMINATE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(1, ("AMLITerminate()\n"));

    RESETERR();
    if (gpnsNameSpaceRoot == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_NOT_INITIALIZED,
                         ("AMLITerminate: interpreter not initialized"));
    }
    else
    {
        PLIST plist;
        PHEAP pheap;

      #ifdef DEBUGGER
        FreeSymList();
        if (gDebugger.pEventLog != NULL)
        {
            MFREE(gDebugger.pEventLog);
        }
        MEMZERO(&gDebugger, sizeof(DBGR));
      #endif

        ASSERT(gReadyQueue.pkthCurrent == NULL);
        ASSERT(gReadyQueue.pctxtCurrent == NULL);
        FreeNameSpaceObjects(gpnsNameSpaceRoot);
        gpnsNameSpaceRoot = NULL;
        MEMZERO(&gReadyQueue, sizeof(CTXTQ));

        while ((plist = ListRemoveTail(&gplistCtxtHead)) != NULL)
        {
            FreeContext(CONTAINING_RECORD(plist, CTXT, listCtxt));
        }

        while ((plist = ListRemoveTail(&gplistObjOwners)) != NULL)
        {
            FreeObjOwner((POBJOWNER)plist, FALSE);
        }

        while ((plist = ListRemoveTail(&gplistDefuncNSObjs)) != NULL)
        {
            FREENSOBJ(CONTAINING_RECORD(plist, NSOBJ, list));
        }

        FreeRSAccessList(gpRSAccessHead);
        gpRSAccessHead = NULL;
        MEMZERO(&ghNotify, sizeof(EVHANDLE));
        MEMZERO(&ghValidateTable, sizeof(EVHANDLE));
        MEMZERO(&ghFatal, sizeof(EVHANDLE));
        MEMZERO(&ghGlobalLock, sizeof(EVHANDLE));
        MEMZERO(&ghCreate, sizeof(EVHANDLE));
        MEMZERO(&ghDestroyObj,sizeof(EVHANDLE));
        for (pheap = gpheapGlobal; pheap != NULL; pheap = gpheapGlobal)
        {
            gpheapGlobal = pheap->pheapNext;
            FreeHeap(pheap);
        }

        FreellegalIOAddressList();

        gdwfAMLI = 0;

      #ifdef DEBUG
        if (gdwcMemObjs != 0)
        {
            DumpMemObjCounts();
            ASSERT(gdwcMemObjs == 0);
        }
      #endif
    }

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

    EXIT(1, ("AMLITerminate=%x\n", rc));
    return rc;
}       //AMLITerminate

/***EP  AMLILoadDDB - Load and parse Differentiated Definition Block
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLILoadDDB | Load Differentiated Definition Block.
 *
 *          This function loads and parses the given Differentiated System
 *          Description Table as well as any dynamic Differentiated Definition
 *          Block.  It will parse the DDB and populate the ACPI name space
 *          accordingly.
 *
 *  @PARM   PDSDT | pDSDT | Pointer to a DSDT block.
 *
 *  @PARM   HANDLE * | phDDB | Pointer to the variable that will receive
 *          the DDB handle (can be NULL).
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code if encountering parse error.
 *
 *  @DEVNOTE If an error occurs in the middle of loading a DDB, the loading
 *          will be aborted but the objects created prior to the error remain
 *          in the name space.  Therefore, it is the responsibility of the
 *          caller to call AMLIUnLoadDDB to destroy the created objects if
 *          desired and the return handle is not NULL.
 */

NTSTATUS AMLIAPI AMLILoadDDB(PDSDT pDSDT, HANDLE *phDDB)
{
    TRACENAME("AMLILOADDDB")
    NTSTATUS rc = STATUS_SUCCESS;
    PCTXT pctxt = NULL;
    POBJOWNER powner = NULL;

    ENTER(1, ("AMLILoadDDB(pDSDT=%x,phDDB=%x)\n", pDSDT, phDDB));

    ASSERT(pDSDT != NULL);
    RESETERR();
    CHKDEBUGGERREQ();

    gInitTime = TRUE;
    
  #ifdef DEBUGGER
    if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
    {
        PRINTF(MODNAME ": %p: Loading Definition Block %s at 0x%p.\n",
               KeGetCurrentThread(), NameSegString(pDSDT->Header.Signature),
               pDSDT);
    }
  #endif

    gdwfHacks |= GetHackFlags(pDSDT);

    if ((rc = NewContext(&pctxt)) == STATUS_SUCCESS)
    {
        ASSERT(gpheapGlobal != NULL);
        pctxt->pheapCurrent = gpheapGlobal;

      #ifdef DEBUG
        gdwfAMLI |= AMLIF_LOADING_DDB;
      #endif

        if (atLoad.pfnCallBack != NULL && atLoad.dwfOpcode & OF_CALLBACK_EX) {

            ((PFNOPEX)atLoad.pfnCallBack)(
                EVTYPE_OPCODE_EX,
                OPEXF_NOTIFY_PRE,
                atLoad.dwOpcode,
                NULL,
                atLoad.dwCBData
                );

        }

        rc = LoadDDB(pctxt,pDSDT, gpnsNameSpaceRoot, &powner);
        if (rc == STATUS_SUCCESS)
        {
            rc = SyncLoadDDB(pctxt);
        }

      #ifdef DEBUG
        {
            KIRQL   oldIrql;

            gdwfAMLI &= ~AMLIF_LOADING_DDB;
            KeAcquireSpinLock( &gdwGHeapSpinLock, &oldIrql );
            gdwGHeapSnapshot = gdwGlobalHeapSize;
            KeReleaseSpinLock( &gdwGHeapSpinLock, oldIrql );
        }
      #endif
    }

    if (phDDB != NULL)
    {
        *phDDB = (HANDLE)powner;
    }

    if ((powner != NULL) && (atLoad.pfnCallBack != NULL))
    {
        if (atLoad.dwfOpcode & OF_CALLBACK_EX) {

            ((PFNOPEX)atLoad.pfnCallBack)(
                EVTYPE_OPCODE_EX,
                OPEXF_NOTIFY_POST,
                atLoad.dwOpcode,
                NULL,
                atLoad.dwCBData
                );

        } else {

            atLoad.pfnCallBack(
                EVTYPE_OPCODE,
                atLoad.dwOpcode,
                NULL,
                atLoad.dwCBData
                );

        }
    }

  #ifdef DEBUGGER
    if (gdwfAMLIInit & AMLIIF_LOADDDB_BREAK)
    {
        PRINTF("\n" MODNAME ": Break at Load Definition Block Completion.\n");
        AMLIDebugger(FALSE);
    }
  #endif

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

    gInitTime = FALSE;
    
    EXIT(1, ("AMLILoadDDB=%x (powner=%x)\n", rc, powner));
    return rc;
}       //AMLILoadDDB

/***EP  AMLIUnloadDDB - Unload Differentiated Definition Block
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   VOID | AMLIUnloadDDB | Unload the Differentiated Definition Block.
 *
 *          This function is called to unload the given dynamic DDB object and
 *          clean it out of the name space.  Note that this function does not
 *          differentiate between a DSDT from a dynamic DDB, so it is the
 *          caller's responsibility to not freeing the DSDT accidentally.
 *
 *  @PARM   HANDLE | hDDB | handle to the definition block context to be
 *          unloaded.
 *
 *  @RDESC  None.
 */

VOID AMLIAPI AMLIUnloadDDB(HANDLE hDDB)
{
    TRACENAME("AMLIUNLOADDDB")

    ENTER(1, ("AMLIUnloadDDB(hDDB=%x)\n", hDDB));

    RESETERR();
    if (hDDB != NULL)
    {
        ASSERT(((POBJOWNER)hDDB)->dwSig == SIG_OBJOWNER);
        UnloadDDB((POBJOWNER)hDDB);
    }

    EXIT(1, ("AMLIUnloadDDB!\n"));
}       //AMLIUnloadDDB

/***EP  AMLIGetNameSpaceObject - Find a name space object
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIGetNameSpaceObject | Find an object in the ACPI
 *          name space.
 *
 *          This function accepts an absolute object path as well as a
 *          relative object path in the form of an ASCIIZ string.
 *          It will search through the name space in the appropriate
 *          scope for the given object path and returns the object
 *          pointer when it is found.
 *
 *  @PARM   PSZ | pszObjPath | Pointer to an ASCIIZ string specifying the
 *          object path.
 *
 *  @PARM   PNSOBJ | pnsScope | If not NULL, this points to the object scope
 *          where the search starts.  If pszObjPath is specifying an absolute
 *          path, this parameter is ignored.
 *
 *  @PARM   PPNSOBJ | ppns | Pointer to a variable to hold the object
 *          point.
 *
 *  @PARM   ULONG | dwfFlags | Option flags.
 *
 *  @FLAG   NSF_LOCAL_SCOPE | Search local scope only.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 */

NTSTATUS AMLIAPI AMLIGetNameSpaceObject(PSZ pszObjPath, PNSOBJ pnsScope,
                                        PPNSOBJ ppns, ULONG dwfFlags)
{
    TRACENAME("AMLIGETNAMESPACEOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA  pHData = NULL;

    ENTER(1, ("AMLIGetNameSpaceObject(ObjPath=%s,Scope=%s,ppns=%p,Flags=%x)\n",
              pszObjPath, GetObjectPath(pnsScope), ppns, dwfFlags));

    ASSERT(pszObjPath != NULL);
    ASSERT(*pszObjPath != '\0');
    ASSERT(ppns != NULL);
    RESETERR();
    CHKDEBUGGERREQ();


    if(IsAmliHookEnabled())
      {

       rc = AMLITest_Pre_GetNameSpaceObject(
         pszObjPath,pnsScope,ppns,dwfFlags,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);

      }

    if ((pnsScope != NULL) && (pnsScope->ObjData.dwfData & DATAF_NSOBJ_DEFUNC))
    {
        AMLI_WARN(("AMLIGetNameSpaceObject: pnsScope is no longer valid"));
        rc = STATUS_NO_SUCH_DEVICE;
    }
    else
    {
        ASSERT((pnsScope == NULL) || !(pnsScope->ObjData.dwfData & DATAF_NSOBJ_DEFUNC));
        rc = GetNameSpaceObject(pszObjPath, pnsScope, ppns, dwfFlags);
    }

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

    if(IsAmliHookEnabled())
      {
      rc = AMLITest_Post_GetNameSpaceObject(
         &pHData,rc);
      }


    EXIT(1, ("AMLIGetNameSpaceObject=%x (pns=%p)\n", rc, *ppns));
    return rc;
}       //AMLIGetNameSpaceObject

/***EP  AMLIGetFieldUnitRegionObj - Get OpRegion associated with FieldUnit
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIGetFieldUnitRegionObj | Get the OperationRegion
 *          object associated with the FieldUnit object.
 *
 *  @PARM   PFIELDUNITOBJ | pfu | Pointer to a FieldUnit object.
 *
 *  @PARM   PPNSOBJ | ppns | Pointer to a variable to hold the OperationRegion
 *          object.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 */

NTSTATUS AMLIAPI AMLIGetFieldUnitRegionObj(PFIELDUNITOBJ pfu, PPNSOBJ ppns)
{
    TRACENAME("AMLIGETFIELDUNITREGIONOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA  pHData = NULL;


    ENTER(1, ("AMLIGetFieldUnitRegionObj(pfu=%x,ppns=%x)\n", pfu, ppns));

    ASSERT(pfu != NULL);
    ASSERT(ppns != NULL);
    RESETERR();

    if(IsAmliHookEnabled())
      {

       rc = AMLITest_Pre_GetFieldUnitRegionObj(
         pfu,ppns,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);

      }

    rc = GetFieldUnitRegionObj(pfu, ppns);

    if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

    if(IsAmliHookEnabled())
      {

       rc = AMLITest_Post_GetFieldUnitRegionObj(
          &pHData,rc);
      }

    EXIT(1, ("AMLIGetFieldUnitRegionObj=%x (pns=%x)\n", rc, *ppns));
    return rc;
}       //AMLIGetFieldUnitRegionObj

/***EP  AMLIEvalNameSpaceObject - Evaluate a name space object
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIEvalNameSpaceObject | Evaluate a name space object.
 *
 *          This function evaluate a given object.  If the given object is a
 *          control method, it will execute it.  If the given object is a data
 *          object, the data value is returned in a given buffer.
 *
 *  @PARM   PNSOBJ | pns | Pointer to the object to be evaluated.
 *
 *  @PARM   POBJDATA | pdataResult | Pointer to the OBJDATA structure which will
 *          hold the result of the evaluation (can be NULL if don't care about
 *          result).
 *
 *  @PARM   int | icArgs | Specify the number of arguments pass to the method
 *          object for evaluation (only valid if pns points to a method object).
 *
 *  @PARM   POBJDATA | pdataArgs | Pointer to an array of argument data object
 *          (only valid if pns points to a method object).
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 *
 *  @DEVNOTE The returned object may contain buffer pointer to the actual
 *          data in the ACPI name space.  Therefore, the caller must be very
 *          careful not to overwrite any data in the buffer.  Also, the caller
 *          is responsible for calling AMLIFreeDataBuffs on the result object
 *          after the result object data is no longer needed.
 */

NTSTATUS AMLIAPI AMLIEvalNameSpaceObject(PNSOBJ pns, POBJDATA pdataResult,
                                         int icArgs, POBJDATA pdataArgs)
{
    TRACENAME("AMLIEVALNAMESPACEOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA  pHData = NULL;

    ENTER(1, ("AMLIEvalNameSpaceObject(Obj=%s,pdataResult=%x,icArgs=%d,pdataArgs=%x)\n",
              GetObjectPath(pns), pdataResult, icArgs, pdataArgs));

    ASSERT(pns != NULL);
    ASSERT((icArgs == 0) || (pdataArgs != NULL));
    RESETERR();
    CHKGLOBALHEAP();
    CHKDEBUGGERREQ();

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Pre_EvalNameSpaceObject(
         pns,pdataResult,icArgs,pdataArgs,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);
      }


    if (pns->ObjData.dwfData & DATAF_NSOBJ_DEFUNC)
    {
        AMLI_WARN(("AMLIEvalNameSpaceObject: pnsObj is no longer valid"));
        rc = STATUS_NO_SUCH_DEVICE;
    }
    else
    {
        if (pdataResult != NULL)
            MEMZERO(pdataResult, sizeof(OBJDATA));

        pns = GetBaseObject(pns);

      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
        {
            PRINTF(MODNAME ": %p: EvalNameSpaceObject(%s)\n",
                   KeGetCurrentThread(), GetObjectPath(pns));
        }
      #endif

        rc = SyncEvalObject(pns, pdataResult, icArgs, pdataArgs);

        if (rc == AMLISTA_PENDING)
            rc = STATUS_PENDING;
        else if (rc != STATUS_SUCCESS)
            rc = NTERR(rc);
    }

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Post_EvalNameSpaceObject(
          &pHData,rc);
      }


    EXIT(1, ("AMLIEvalNameSpaceObject=%x\n", rc));
    return rc;
}       //AMLIEvalNameSpaceObject

/***EP  AMLIAsyncEvalObject - Evaluate an object asynchronously
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIAsyncEvalObject | Evaluate an object asynchronously.
 *
 *  @PARM   PNSOBJ | pns | Pointer to the object to be evaluated.
 *
 *  @PARM   POBJDATA | pdataResult | Pointer to the OBJDATA structure which will
 *          hold the result of the evaluation (can be NULL if don't care about
 *          result).
 *
 *  @PARM   int | icArgs | Specify the number of arguments pass to the method
 *          object for evaluation (only valid if pns points to a method object).
 *
 *  @PARM   POBJDATA | pdataArgs | Pointer to an array of argument data object
 *          (only valid if pns points to a method object).
 *
 *  @PARM   PFNACB | pfnAsyncCallBack | Pointer to the asynchronous callback
 *          function in case the control method is blocked and has to be
 *          completed asynchronously (can be NULL if no Callback required).
 *
 *  @PARM   PVOID | pvContext | Pointer to some context data that the
 *          interpreter will pass to the Async callback handler.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 *
 *  @DEVNOTE The returned object may contain buffer pointer to the actual
 *          data in the ACPI name space.  Therefore, the caller must be very
 *          careful not to overwrite any data in the buffer.  Also, the caller
 *          is responsible for calling AMLIFreeDataBuffs on the result object
 *          after the result object data is no longer needed.
 */

NTSTATUS AMLIAPI AMLIAsyncEvalObject(PNSOBJ pns, POBJDATA pdataResult,
                                     int icArgs, POBJDATA pdataArgs,
                                     PFNACB pfnAsyncCallBack, PVOID pvContext)
{
    TRACENAME("AMLIASYNCEVALOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA  pHData = NULL;

    ENTER(1, ("AMLIAsyncEvalObject(Obj=%s,pdataResult=%x,icArgs=%d,pdataArgs=%x,pfnAysnc=%x)\n",
              GetObjectPath(pns), pdataResult, icArgs, pdataArgs,
              pfnAsyncCallBack));

    ASSERT(pns != NULL);
    ASSERT((icArgs == 0) || (pdataArgs != NULL));
    RESETERR();
    CHKGLOBALHEAP();
    CHKDEBUGGERREQ();

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Pre_AsyncEvalObject(
         pns,pdataResult,icArgs,pdataArgs,
         &pfnAsyncCallBack,&pvContext,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);

      }



    if (pns->ObjData.dwfData & DATAF_NSOBJ_DEFUNC)
    {
        AMLI_WARN(("AMLIAsyncEvalObject: pnsObj is no longer valid"));
        rc = STATUS_NO_SUCH_DEVICE;
    }
    else
    {
        if (pdataResult != NULL)
            MEMZERO(pdataResult, sizeof(OBJDATA));

        pns = GetBaseObject(pns);

      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
        {
            PRINTF(MODNAME ": %p: AsyncEvalObject(%s)\n",
                   KeGetCurrentThread(), GetObjectPath(pns));
        }
      #endif

        rc = AsyncEvalObject(pns, pdataResult, icArgs, pdataArgs,
                             pfnAsyncCallBack, pvContext, TRUE);

        if (rc == AMLISTA_PENDING)
            rc = STATUS_PENDING;
        else if (rc != STATUS_SUCCESS)
            rc = NTERR(rc);
    }

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Post_AsyncEvalObject(
          &pHData,rc);
      }


    EXIT(1, ("AMLIAsyncEvalObject=%x\n", rc));
    return rc;
}       //AMLIAsyncEvalObject

/***EP  AMLINestAsyncEvalObject - Evaluate an object asynchronously from within
 *                                the current context
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLINestAsyncEvalObject | Evaluate an object
 *          asynchronously from within the current context.
 *
 *  @PARM   PNSOBJ | pns | Pointer to the object to be evaluated.
 *
 *  @PARM   POBJDATA | pdataResult | Pointer to the OBJDATA structure which will
 *          hold the result of the evaluation (can be NULL if don't care about
 *          result).
 *
 *  @PARM   int | icArgs | Specify the number of arguments pass to the method
 *          object for evaluation (only valid if pns points to a method object).
 *
 *  @PARM   POBJDATA | pdataArgs | Pointer to an array of argument data object
 *          (only valid if pns points to a method object).
 *
 *  @PARM   PFNACB | pfnAsyncCallBack | Pointer to the asynchronous callback
 *          function in case the control method is blocked and has to be
 *          completed asynchronously (can be NULL if no Callback required).
 *
 *  @PARM   PVOID | pvContext | Pointer to some context data that the
 *          interpreter will pass to the Async callback handler.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 *
 *  @DEVNOTE The returned object may contain buffer pointer to the actual
 *          data in the ACPI name space.  Therefore, the caller must be very
 *          careful not to overwrite any data in the buffer.  Also, the caller
 *          is responsible for calling AMLIFreeDataBuffs on the result object
 *          after the result object data is no longer needed.
 */

NTSTATUS AMLIAPI AMLINestAsyncEvalObject(PNSOBJ pns, POBJDATA pdataResult,
                                         int icArgs, POBJDATA pdataArgs,
                                         PFNACB pfnAsyncCallBack,
                                         PVOID pvContext)
{
    TRACENAME("AMLINESTASYNCEVALOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA  pHData = NULL;


    ENTER(1, ("AMLINestAsyncEvalObject(Obj=%s,pdataResult=%x,icArgs=%d,pdataArgs=%x,pfnAysnc=%x)\n",
              GetObjectPath(pns), pdataResult, icArgs, pdataArgs,
              pfnAsyncCallBack));

    ASSERT(pns != NULL);
    ASSERT((icArgs == 0) || (pdataArgs != NULL));
    RESETERR();
    CHKGLOBALHEAP();
    CHKDEBUGGERREQ();

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Pre_NestAsyncEvalObject(
         pns,pdataResult,icArgs,pdataArgs,
         &pfnAsyncCallBack,&pvContext,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);


      }


    if (pns->ObjData.dwfData & DATAF_NSOBJ_DEFUNC)
    {
        AMLI_WARN(("AMLINestAsyncEvalObject: pnsObj is no longer valid"));
        rc = STATUS_NO_SUCH_DEVICE;
    }
    else
    {
        if (pdataResult != NULL)
            MEMZERO(pdataResult, sizeof(OBJDATA));

        pns = GetBaseObject(pns);

      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
        {
            PRINTF(MODNAME ": %p: AsyncNestEvalObject(%s)\n",
                   KeGetCurrentThread(), GetObjectPath(pns));
        }
      #endif

        rc = NestAsyncEvalObject(pns, pdataResult, icArgs, pdataArgs,
                                 pfnAsyncCallBack, pvContext, TRUE);

        if (rc == AMLISTA_PENDING)
            rc = STATUS_PENDING;
        else if (rc != STATUS_SUCCESS)
            rc = NTERR(rc);
    }

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Post_NestAsyncEvalObject(
          &pHData,rc);
      }

    EXIT(1, ("AMLINestAsyncEvalObject=%x\n", rc));
    return rc;
}       //AMLINestAsyncEvalObject

/***EP  AMLIEvalPackageElement - Evaluate a package element
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIEvalPackageElement | Evaluate a package element.
 *
 *          This function evaluate an element of a given package object.
 *          A package is essentially an array of objects.  This API provides
 *          a way to evaluate individual element object inside a package.
 *
 *  @PARM   PNSOBJ | pns | Pointer to the package object to be evaluated.  If
 *          the object is a method, then the method is evaluated first before
 *          the resulting package object is evaluated.  It is an error if the
 *          resulting object is not of package type.
 *
 *  @PARM   int | iPkgIndex | Package index (0-based).
 *
 *  @PARM   POBJDATA | pdataResult | Pointer to the OBJDATA structure which will
 *          hold the result of the evaluation (can be NULL if don't care about
 *          result).
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 *
 *  @DEVNOTE The returned object may contain buffer pointer to the actual
 *          data in the ACPI name space.  Therefore, the caller must be very
 *          careful not to overwrite any data in the buffer.  Also, the caller
 *          is responsible for calling AMLIFreeDataBuffs on the result object
 *          after the result object data is no longer needed.
 */

NTSTATUS AMLIAPI AMLIEvalPackageElement(PNSOBJ pns, int iPkgIndex,
                                        POBJDATA pdataResult)
{
    TRACENAME("AMLIEVALPACKAGEELEMENT")
    NTSTATUS rc = STATUS_SUCCESS;
    OBJDATA data;
    POBJDATA pdata = NULL;
    PAMLIHOOK_DATA pHData = NULL;

    ENTER(1, ("AMLIEvalPackageElement(Obj=%s,Index=%d,pdataResult=%x)\n",
              GetObjectPath(pns), iPkgIndex, pdataResult));

    ASSERT(pns != NULL);
    ASSERT(pdataResult != NULL);
    RESETERR();
    CHKGLOBALHEAP();
    CHKDEBUGGERREQ();


    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Pre_EvalPackageElement(
         pns,iPkgIndex,pdataResult,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);
      }



    if (pns->ObjData.dwfData & DATAF_NSOBJ_DEFUNC)
    {
        AMLI_WARN(("AMLIEvalPackageElement: pnsObj is no longer valid"));
        rc = STATUS_NO_SUCH_DEVICE;
    }
    else
    {
        MEMZERO(pdataResult, sizeof(OBJDATA));
        MEMZERO(&data, sizeof(data));
        pns = GetBaseObject(pns);

      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
        {
            PRINTF(MODNAME ": %p: EvalPackageElement(%s,%d)\n",
                   KeGetCurrentThread(), GetObjectPath(pns), iPkgIndex);
        }
      #endif

        if (pns->ObjData.dwDataType == OBJTYPE_METHOD)
        {
            if ((rc = SyncEvalObject(pns, &data, 0, NULL)) == STATUS_SUCCESS)
            {
                if (data.dwDataType == OBJTYPE_PKGDATA)
                    pdata = &data;
                else
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("AMLIEvalPackageElement: result object of the method is not package (ObjType=%s)",
                                      GetObjectTypeName(data.dwDataType)));
                }
            }
        }
        else if (pns->ObjData.dwDataType == OBJTYPE_PKGDATA)
        {
            pdata = &pns->ObjData;
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("AMLIEvalPackageElement: object is not a method or package (ObjType=%s)",
                              GetObjectTypeName(pns->ObjData.dwDataType)));
        }

        if (rc == STATUS_SUCCESS)
        {
            rc = EvalPackageElement((PPACKAGEOBJ)pdata->pbDataBuff, iPkgIndex,
                                    pdataResult);
        }
        FreeDataBuffs(&data, 1);

        if (rc == AMLISTA_PENDING)
            rc = STATUS_PENDING;
        else if (rc != STATUS_SUCCESS)
            rc = NTERR(rc);
        else
        {
            ASSERT((pdataResult->pbDataBuff == NULL) ||
                   !(pdataResult->dwfData & DATAF_BUFF_ALIAS));
        }
    }

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Post_EvalPackageElement(
          &pHData,rc);
      }




    EXIT(1, ("AMLIEvalPackageElement=%x\n", rc));
    return rc;
}       //AMLIEvalPackageElement

/***EP  AMLIEvalPkgDataElement - Evaluate an element of a package data
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIEvalPkgDataElement | Evaluate a package data element.
 *
 *          This function evaluate an element of a given package data object.
 *          A package is essentially an array of objects.  This API provides
 *          a way to evaluate individual element object inside a package.
 *
 *  @PARM   POBJDATA | pdataPkg | Pointer to the package data object to be
 *          evaluated.  It is an error if the data object is not of package
 *          type.
 *
 *  @PARM   int | iPkgIndex | Package index (0-based).
 *
 *  @PARM   POBJDATA | pdataResult | Pointer to the OBJDATA structure which will
 *          hold the result of the evaluation (can be NULL if don't care about
 *          result).
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 *
 *  @DEVNOTE The returned object may contain buffer pointer to the actual
 *          data in the ACPI name space.  Therefore, the caller must be very
 *          careful not to overwrite any data in the buffer.  Also, the caller
 *          is responsible for calling AMLIFreeDataBuffs on the result object
 *          after the result object data is no longer needed.
 */

NTSTATUS AMLIAPI AMLIEvalPkgDataElement(POBJDATA pdataPkg, int iPkgIndex,
                                        POBJDATA pdataResult)
{
    TRACENAME("AMLIEVALPKGDATAELEMENT")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA pHData = NULL;

    ENTER(1, ("AMLIEvalPkgDataElement(pdataPkg=%x,Index=%d,pdataResult=%x)\n",
              pdataPkg, iPkgIndex, pdataResult));

    ASSERT(pdataResult != NULL);
    RESETERR();
    CHKGLOBALHEAP();
    CHKDEBUGGERREQ();

    MEMZERO(pdataResult, sizeof(OBJDATA));


    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Pre_EvalPkgDataElement(
         pdataPkg,iPkgIndex,pdataResult,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);
      }


  #ifdef DEBUGGER
    if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
    {
        PRINTF(MODNAME ": %p: EvalPkgDataElement(%x,%d)\n",
               KeGetCurrentThread(), pdataPkg, iPkgIndex);
    }
  #endif

    if (pdataPkg->dwDataType != OBJTYPE_PKGDATA)
    {
        rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                         ("AMLIEvalPkgDataElement: object is not a package (ObjType=%s)",
                          GetObjectTypeName(pdataPkg->dwDataType)));
    }
    else
    {
        rc = EvalPackageElement((PPACKAGEOBJ)pdataPkg->pbDataBuff, iPkgIndex,
                                pdataResult);
    }

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);
    else
    {
        ASSERT((pdataResult->pbDataBuff == NULL) ||
               !(pdataResult->dwfData & DATAF_BUFF_ALIAS));
    }

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Post_EvalPkgDataElement(
          &pHData,rc);
      }


    EXIT(1, ("AMLIEvalPkgDataElement=%x\n", rc));
    return rc;
}       //AMLIEvalPkgDataElement

/***EP  AMLIFreeDataBuffs - Free data buffers of an object array
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   VOID | AMLIFreeDataBuffs | Free data buffers of a data object
 *          array.
 *
 *          This function is typically called after evaluating an object to
 *          free the result object buffers.
 *
 *  @PARM   POBJDATA | pdata | Pointer to the object array.
 *
 *  @PARM   int | icData | Specifies the number of objects in the array.
 *
 *  @RDESC  None.
 */

VOID AMLIAPI AMLIFreeDataBuffs(POBJDATA pdata, int icData)
{
    TRACENAME("AMLIFREEDATABUFFS")
    PAMLIHOOK_DATA pHData = NULL;

    ENTER(1, ("AMLIFreeDataBuffs(pdata=%x,icData=%d)\n", pdata, icData));

    ASSERT(pdata != NULL);
    ASSERT(icData > 0);
    RESETERR();

    if(IsAmliHookEnabled())
      {

      AMLITest_Pre_FreeDataBuffs(
         pdata,icData,&pHData);

      }

    FreeDataBuffs(pdata, icData);

    if(IsAmliHookEnabled())
      {

      AMLITest_Post_FreeDataBuffs(
          &pHData,STATUS_SUCCESS);
      }

    EXIT(1, ("AMLIFreeDataBuffs!\n"));
}       //AMLIFreeDataBuffs

/***EP  AMLIRegEventHandler - Register an event handler
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIRegEventHandler | Register an event handler.
 *          handler.
 *
 *          This function allows the caller to hook a callback handler for some
 *          AMLI events.
 *
 *  @PARM   ULONG | dwEventType | Event type the handler will handle.
 *
 *  @PARM   ULONG_PTR | uipEventData | Event specific data the handler will
 *          handle.
 *
 *  @PARM   PFNHND | pfnHandler | Callback handler entry point (can be NULL
 *          if deregistering previous handler).
 *
 *  @PARM   ULONG_PTR | uipParam | Parameter Data (will be passed to the
 *          callback handler).
 *
 *  @RDESC  None.
 */

NTSTATUS AMLIAPI AMLIRegEventHandler(ULONG dwEventType, ULONG_PTR uipEventData,
                                     PFNHND pfnHandler, ULONG_PTR uipParam)
{
    TRACENAME("AMLIREGEVENTHANDLER")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA pHData = NULL;

    ENTER(1, ("AMLIRegEventHandler(EventType=%x,EventData=%x,pfnHandler=%x,Param=%x)\n",
              dwEventType, uipEventData, pfnHandler, uipParam));
    RESETERR();

   if(IsAmliHookEnabled())
      {

      rc = AMLIHook_Pre_RegEventHandler(
         dwEventType,uipEventData,&pfnHandler,&uipParam,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);


      }

    switch (dwEventType)
    {
        case EVTYPE_OPCODE:
            rc = RegOpcodeHandler((ULONG)uipEventData, (PFNOH)pfnHandler,
                                  uipParam, 0);
            break;

        case EVTYPE_OPCODE_EX:
            rc = RegOpcodeHandler((ULONG)uipEventData, (PFNOH)pfnHandler,
                                  uipParam, OF_CALLBACK_EX);
            break;

        case EVTYPE_NOTIFY:
            rc = RegEventHandler(&ghNotify, pfnHandler, uipParam);
            break;

        case EVTYPE_FATAL:
            rc = RegEventHandler(&ghFatal, pfnHandler, uipParam);
            break;

        case EVTYPE_VALIDATE_TABLE:
            rc = RegEventHandler(&ghValidateTable, pfnHandler, uipParam);
            break;

        case EVTYPE_ACQREL_GLOBALLOCK:
            rc = RegEventHandler(&ghGlobalLock, pfnHandler, uipParam);
            break;

        case EVTYPE_RS_COOKACCESS:
            rc = RegRSAccess((ULONG)uipEventData, pfnHandler, uipParam, FALSE);
            break;

        case EVTYPE_RS_RAWACCESS:
            rc = RegRSAccess((ULONG)uipEventData, pfnHandler, uipParam, TRUE);
            break;

        case EVTYPE_CREATE:
            rc = RegEventHandler(&ghCreate, pfnHandler, uipParam);
            break;

        case EVTYPE_DESTROYOBJ:
            rc =RegEventHandler(&ghDestroyObj, pfnHandler, uipParam);
            break;

      #ifdef DEBUGGER
        case EVTYPE_CON_MESSAGE:
            rc = RegEventHandler(&gDebugger.hConMessage, pfnHandler, uipParam);
            break;

        case EVTYPE_CON_PROMPT:
            rc = RegEventHandler(&gDebugger.hConPrompt, pfnHandler, uipParam);
            break;
      #endif

        default:
            rc = AMLI_LOGERR(AMLIERR_INVALID_EVENTTYPE,
                             ("AMLIRegEventHandler: invalid event type %x",
                              dwEventType));
    }

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

    if(IsAmliHookEnabled())
      {

      rc = AMLIHook_Post_RegEventHandler(
          &pHData,rc);
      }


    EXIT(1, ("AMLIRegEventHandler=%x\n", rc));
    return rc;
}       //AMLIRegEventHandler

/***EP  AMLIPauseInterpreter
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIPauseInterpreter | Flush the interpreter queue
 *          and pause the interpreter so that all subsequent new method
 *          execution requests will be queued.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 */

NTSTATUS AMLIAPI AMLIPauseInterpreter(PFNAA pfnCallback, PVOID Context)
{
    TRACENAME("AMLIPAUSEINTERPRETER")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLIHOOK_DATA pHData = NULL;


    ENTER(1, ("AMLIPauseInterpreter(Callback=%p,Context=%p)\n",
              pfnCallback, Context));
    RESETERR();

   if(IsAmliHookEnabled())
      {

      rc = AMLITest_Pre_PauseInterpreter(
         &pfnCallback,&Context,&pHData);

      if(rc != STATUS_SUCCESS)
         return(rc);
      }



    AcquireMutex(&gReadyQueue.mutCtxtQ);
    if (!(gReadyQueue.dwfCtxtQ & (CQF_PAUSED | CQF_FLUSHING)))
    {
        if (gplistCtxtHead == NULL)
        {
            //
            // There is no pending ctxt.
            //
            gReadyQueue.dwfCtxtQ |= CQF_PAUSED;
        }
        else
        {
            //
            // There are pending ctxts, so we go into flushing mode.
            //
            gReadyQueue.dwfCtxtQ |= CQF_FLUSHING;
            gReadyQueue.pfnPauseCallback = pfnCallback;
            gReadyQueue.PauseCBContext = Context;
            rc = AMLISTA_PENDING;
        }
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("AMLIPauseInterpreter: interpreter already entered paused state"));
    }
    ReleaseMutex(&gReadyQueue.mutCtxtQ);

    LOGSCHEDEVENT('PAUS', (ULONG_PTR)rc, 0, 0);

    if (rc == AMLISTA_PENDING)
        rc = STATUS_PENDING;
    else if (rc != STATUS_SUCCESS)
        rc = NTERR(rc);

    if(IsAmliHookEnabled())
      {

      rc = AMLITest_Post_PauseInterpreter(
          &pHData,rc);
      }

    EXIT(1, ("AMLIPauseInterpreter=%x\n", rc));
    return rc;
}       //AMLIPauseInterpreter

/***EP  AMLIResumeInterpreter
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   VOID | AMLIResumeInterpreter | Resume the interpreter from
 *          paused state.
 *
 *  @RDESC  None.
 */

VOID AMLIAPI AMLIResumeInterpreter(VOID)
{

    PAMLIHOOK_DATA pHData = NULL;

    TRACENAME("AMLIRESUMEINTERPRETER")

    ENTER(1, ("AMLIResumeInterpreter()\n"));
    RESETERR();

   if(IsAmliHookEnabled())
      {

      AMLITest_Pre_ResumeInterpreter(
         &pHData);
      }

    AcquireMutex(&gReadyQueue.mutCtxtQ);
    if (gReadyQueue.dwfCtxtQ & (CQF_PAUSED | CQF_FLUSHING))
    {
        gReadyQueue.dwfCtxtQ &= ~(CQF_PAUSED | CQF_FLUSHING);
        gReadyQueue.pfnPauseCallback = NULL;
        gReadyQueue.PauseCBContext = NULL;
        LOGSCHEDEVENT('RSUM', 0, 0, 0);
        if ((gReadyQueue.plistCtxtQ != NULL) &&
            !(gReadyQueue.dwfCtxtQ & CQF_WORKITEM_SCHEDULED))
        {
            OSQueueWorkItem(&gReadyQueue.WorkItem);
            gReadyQueue.dwfCtxtQ |= CQF_WORKITEM_SCHEDULED;
            LOGSCHEDEVENT('RSTQ', 0, 0, 0);
        }
    }
    else
    {
        AMLI_WARN(("AMLIResumeInterpreter: not in paused state"));
    }
    ReleaseMutex(&gReadyQueue.mutCtxtQ);

    if(IsAmliHookEnabled())
      {

      AMLITest_Post_ResumeInterpreter(
          &pHData,STATUS_SUCCESS);
      }



    EXIT(1, ("AMLIResumeInterpreter!\n"));
}       //AMLIResumeInterpreter

/***EP  AMLIReferenceObject - Bump up the reference count of the object
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   VOID | AMLIReferenceObject | Bump up the reference count of the
 *          name space object.
 *
 *  @PARM   PNSOBJ | pnsObj | Points to the name space object.
 *
 *  @RDESC  None.
 */

VOID AMLIAPI AMLIReferenceObject(PNSOBJ pnsObj)
{
    TRACENAME("AMLIREFERENCEOBJECT")

    ENTER(1, ("AMLIReferenceObject(pnsObj=%x)\n", pnsObj));

    RESETERR();

    ASSERT(pnsObj != NULL);
    pnsObj->dwRefCount++;
    EXIT(1, ("AMLIReferenceObj!\n"));
}       //AMLIReferenceObject

/***EP  AMLIDereferenceObject - Bump down the reference count of the object
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   VOID | AMLIDereferenceObject | Bump down the reference count of the
 *          name space object.  If it reaches zero and it is in defunc state,
 *          deallocate the object.
 *
 *  @PARM   PNSOBJ | pnsObj | Points to the name space object.
 *
 *  @RDESC  None.
 */

VOID AMLIAPI AMLIDereferenceObject(PNSOBJ pnsObj)
{
    TRACENAME("AMLIDEREFERENCEOBJECT")

    ENTER(1, ("AMLIDereferenceObject(pnsObj=%x)\n", pnsObj));

    RESETERR();

    ASSERT(pnsObj != NULL);
    ASSERT(pnsObj->dwRefCount > 0);

    if (pnsObj->dwRefCount > 0)
    {
        pnsObj->dwRefCount--;
        if ((pnsObj->dwRefCount == 0) && (pnsObj->ObjData.dwfData & DATAF_NSOBJ_DEFUNC))
        {
            ListRemoveEntry(&pnsObj->list, &gplistDefuncNSObjs);
            FREENSOBJ(pnsObj);
        }
    }

    EXIT(1, ("AMLIDereferenceObj!\n"));
}       //AMLIDereferenceObject

/***EP  AMLIDestroyFreedObjs - Destroy freed objects during an unload
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIDestroyFreedObjs | Destroy freed objects from a
 *          previous unload.
 *
 *  @PARM   PNSOBJ | pnsObj | The object in the freed list to be destroyed.
 *
 *  @RDESC  SUCCESS - Returns STATUS_SUCCESS.
 *
 *  @RDESC  FAILURE - Returns NT status code.
 */

NTSTATUS AMLIAPI AMLIDestroyFreedObjs(PNSOBJ pnsObj)
{
    TRACENAME("AMLIDESTROYFREEDOBJS")

    ENTER(1, ("AMLIDestroyFreedObjs(pnsObj=%x)\n",pnsObj));

    RESETERR();

    ASSERT(pnsObj != NULL);

    //
    // Destroy the namespace object
    //
    FreeNameSpaceObjects(pnsObj);

    EXIT(1, ("AMLIDestroyFreedObjs=%x \n",STATUS_SUCCESS));
    return STATUS_SUCCESS;
}       //AMLIDestroyFreedObjs

#ifdef DEBUGGER
/***EP  AMLIGetLastError - Get last error code and message
 *
 *  @DOC    EXTERNAL
 *
 *  @FUNC   NTSTATUS | AMLIGetLastError | Get last error code and associated
 *          error message.
 *
 *  @PARM   PSZ * | ppszErrMsg | Point to a variable to hold the error message
 *          buffer pointer.  If there is no error, the variable is set to NULL.
 *
 *  @RDESC  Returns the last error code.
 */

NTSTATUS AMLIAPI AMLIGetLastError(PSZ *ppszErrMsg)
{
    TRACENAME("AMLIGETLASTERROR")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(1, ("AMLIGetLastError(ppszErrMsg=%x)\n", ppszErrMsg));

    ASSERT(ppszErrMsg != NULL);

    if ((rc = gDebugger.rcLastError) != STATUS_SUCCESS)
        *ppszErrMsg = gDebugger.szLastError;
    else
        *ppszErrMsg = NULL;

    EXIT(1, ("AMLIGetLastError=%x (Msg=%s)\n",
             rc, *ppszErrMsg? *ppszErrMsg: "<null>"));
    return rc;
}       //AMLIGetLastError
#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\data.h ===
/*** data.h - Global Data Definitions
 *
 *  This module contains global data definitions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _DATA_H
#define _DATA_H

#ifdef DEBUG
extern ULONG gdwcMemObjs;
extern ULONG gdwcHPObjs;
extern ULONG gdwcODObjs;
extern ULONG gdwcNSObjs;
extern ULONG gdwcOOObjs;
extern ULONG gdwcBFObjs;
extern ULONG gdwcSDObjs;
extern ULONG gdwcBDObjs;
extern ULONG gdwcPKObjs;
extern ULONG gdwcFUObjs;
extern ULONG gdwcKFObjs;
extern ULONG gdwcFObjs;
extern ULONG gdwcIFObjs;
extern ULONG gdwcORObjs;
extern ULONG gdwcMTObjs;
extern ULONG gdwcEVObjs;
extern ULONG gdwcMEObjs;
extern ULONG gdwcPRObjs;
extern ULONG gdwcPCObjs;
extern ULONG gdwcRSObjs;
extern ULONG gdwcSYObjs;
extern ULONG gdwcPHObjs;
extern ULONG gdwcCRObjs;
extern ULONG gdwGlobalHeapSize;
extern ULONG gdwLocalHeapMax;
extern ULONG gdwLocalStackMax;
extern ULONG gdwGHeapSnapshot;
extern KSPIN_LOCK gdwGHeapSpinLock;
#endif
extern LONG             gdwcCTObjs;
extern ULONG            gdwcCTObjsMax;
extern KSPIN_LOCK       gdwGContextSpinLock;
extern NPAGED_LOOKASIDE_LIST   AMLIContextLookAsideList;
#ifdef TRACING
extern PSZ gpszTrigPts;
#endif
extern ULONG gdwfAMLI;
extern ULONG gdwfAMLIInit;
extern ULONG gdwfHacks;
extern ULONG gdwCtxtBlkSize;
extern ULONG gdwGlobalHeapBlkSize;
extern PNSOBJ gpnsNameSpaceRoot;
extern PHEAP gpheapGlobal;
extern PLIST gplistCtxtHead;
extern PLIST gplistObjOwners;
extern PLIST gplistDefuncNSObjs;
extern PRSACCESS gpRSAccessHead;
extern EVHANDLE ghNotify;
extern EVHANDLE ghValidateTable;
extern EVHANDLE ghFatal;
extern EVHANDLE ghGlobalLock;
extern EVHANDLE ghCreate;
extern EVHANDLE ghDestroyObj;
extern CTXTQ gReadyQueue;
extern MUTEX gmutCtxtList;
extern MUTEX gmutOwnerList;
extern MUTEX gmutHeap;
extern ULONG gdwHighestOSVerQueried;
extern PHAL_AMLI_BAD_IO_ADDRESS_LIST gpBadIOAddressList;
extern PULONG gpBadIOErrorLogDoneList;
extern ULONG gOverrideFlags;
extern BOOLEAN gInitTime;

//
// Sleep specific data structures
//
extern MUTEX      gmutSleep;
extern KDPC       SleepDpc;
extern KTIMER     SleepTimer;
extern LIST_ENTRY SleepQueue;

extern PAMLTERM OpcodeTable[256];
extern OPCODEMAP ExOpcodeTable[];
extern AMLTERM atIf, atWhile;
extern AMLTERM atLoad;

/*** Import data
 */

extern PCHAR gpszOSName;

#endif  //ifndef _DATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\data.c ===
/*** data.c - Global Data
 *
 *  This module contains global data declaration.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

#ifdef DEBUG
ULONG gdwcMemObjs = 0;
ULONG gdwcHPObjs = 0;
ULONG gdwcODObjs = 0;
ULONG gdwcNSObjs = 0;
ULONG gdwcOOObjs = 0;
ULONG gdwcBFObjs = 0;
ULONG gdwcSDObjs = 0;
ULONG gdwcBDObjs = 0;
ULONG gdwcPKObjs = 0;
ULONG gdwcFUObjs = 0;
ULONG gdwcKFObjs = 0;
ULONG gdwcFObjs = 0;
ULONG gdwcIFObjs = 0;
ULONG gdwcORObjs = 0;
ULONG gdwcMTObjs = 0;
ULONG gdwcEVObjs = 0;
ULONG gdwcMEObjs = 0;
ULONG gdwcPRObjs = 0;
ULONG gdwcPCObjs = 0;
ULONG gdwcRSObjs = 0;
ULONG gdwcSYObjs = 0;
ULONG gdwcPHObjs = 0;
ULONG gdwcCRObjs = 0;
ULONG gdwGlobalHeapSize = 0;
ULONG gdwLocalHeapMax = 0;
ULONG gdwLocalStackMax = 0;
ULONG gdwGHeapSnapshot = 0;
KSPIN_LOCK gdwGHeapSpinLock;
#endif
LONG  gdwcCTObjs = 0;
ULONG gdwcCTObjsMax = 0;
KSPIN_LOCK gdwGContextSpinLock;
NPAGED_LOOKASIDE_LIST   AMLIContextLookAsideList;
#ifdef TRACING
PSZ gpszTrigPts = NULL;
#endif
ULONG gdwfAMLI = 0;
ULONG gdwfAMLIInit = 0;
ULONG gdwfHacks = 0;
ULONG gdwCtxtBlkSize = DEF_CTXTBLK_SIZE;
ULONG gdwGlobalHeapBlkSize = DEF_GLOBALHEAPBLK_SIZE;
PNSOBJ gpnsNameSpaceRoot = NULL;
PHEAP gpheapGlobal = NULL;
PLIST gplistCtxtHead = NULL;
PLIST gplistObjOwners = NULL;
PLIST gplistDefuncNSObjs = NULL;
PRSACCESS gpRSAccessHead = NULL;
EVHANDLE ghNotify = {0};
EVHANDLE ghValidateTable = {0};
EVHANDLE ghFatal = {0};
EVHANDLE ghGlobalLock = {0};
EVHANDLE ghCreate = {0};
EVHANDLE ghDestroyObj = {0};
CTXTQ gReadyQueue = {0};
MUTEX gmutCtxtList = {0};
MUTEX gmutOwnerList = {0};
MUTEX gmutHeap = {0};
ULONG gdwHighestOSVerQueried = 0;
PHAL_AMLI_BAD_IO_ADDRESS_LIST gpBadIOAddressList = NULL;
PULONG gpBadIOErrorLogDoneList = NULL;
ULONG gOverrideFlags = 0;
BOOLEAN gInitTime = FALSE;
//
// Sleep specific data structures
//
MUTEX      gmutSleep = {0};
KDPC       SleepDpc = {0};
KTIMER     SleepTimer = {0};
LIST_ENTRY SleepQueue = {0};

#define VL      OF_VARIABLE_LIST
#define AO      OF_ARG_OBJECT
#define LO      OF_LOCAL_OBJECT
#define DO      OF_DATA_OBJECT
#define SO      OF_STRING_OBJECT
#define BO      OF_DEBUG_OBJECT
#define NO      OF_NAME_OBJECT
#define RO      OF_REF_OBJECT

#define NS      TC_NAMESPACE_MODIFIER
#define OB      TC_NAMED_OBJECT
#define C1      TC_OPCODE_TYPE1
#define C2      TC_OPCODE_TYPE2
#define OT      TC_OTHER

AMLTERM
    //
    // Name Space Modifiers
    //
    atAlias         = {"Alias", OP_ALIAS, "NN", NS, 0,  NULL, 0, Alias},
    atName          = {"Name",  OP_NAME,  "NO", NS, 0,  NULL, 0, Name},
    atScope         = {"Scope", OP_SCOPE, "N",  NS, VL, NULL, 0, Scope},
    //
    // Named Object Creators
    //
    atBankField     = {"BankField",       OP_BANKFIELD,   "NNCB", OB, VL, NULL, 0, BankField},
    atBitField      = {"CreateBitField",  OP_BITFIELD,    "CCN",  OB, 0,  NULL, 0, CreateBitField},
    atByteField     = {"CreateByteField", OP_BYTEFIELD,   "CCN",  OB, 0,  NULL, 0, CreateByteField},
    atDWordField    = {"CreateDWordField",OP_DWORDFIELD,  "CCN",  OB, 0,  NULL, 0, CreateDWordField},
    atCreateField   = {"CreateField",     OP_CREATEFIELD, "CCCN", OB, 0,  NULL, 0, CreateField},
    atWordField     = {"CreateWordField", OP_WORDFIELD,   "CCN",  OB, 0,  NULL, 0, CreateWordField},
    atDevice        = {"Device",          OP_DEVICE,      "N",    OB, VL, NULL, 0, Device},
    atEvent         = {"Event",           OP_EVENT,       "N",    OB, 0,  NULL, 0, Event},
    atField         = {"Field",           OP_FIELD,       "NB",   OB, VL, NULL, 0, Field},
    atIndexField    = {"IndexField",      OP_IDXFIELD,    "NNB",  OB, VL, NULL, 0, IndexField},
    atMethod        = {"Method",          OP_METHOD,      "NB",   OB, VL, NULL, 0, Method},
    atMutex         = {"Mutex",           OP_MUTEX,       "NB",   OB, 0,  NULL, 0, Mutex},
    atOpRegion      = {"OperationRegion", OP_OPREGION,    "NBCC", OB, 0,  NULL, 0, OpRegion},
    atPowerRes      = {"PowerResource",   OP_POWERRES,    "NBW",  OB, VL, NULL, 0, PowerRes},
    atProcessor     = {"Processor",       OP_PROCESSOR,   "NBDB", OB, VL, NULL, 0, Processor},
    atThermalZone   = {"ThermalZone",     OP_THERMALZONE, "N",    OB, VL, NULL, 0, ThermalZone},
    //
    // Type 1 Opcodes
    //
    atBreak         = {"Break",            OP_BREAK,       NULL,   C1, 0,  NULL, 0, Break},
    atBreakPoint    = {"BreakPoint",       OP_BREAKPOINT,  NULL,   C1, 0,  NULL, 0, BreakPoint},
    atElse          = {"Else",             OP_ELSE,        NULL,   C1, VL, NULL, 0, IfElse},
    atFatal         = {"Fatal",            OP_FATAL,       "BDC",  C1, 0,  NULL, 0, Fatal},
    atIf            = {"If",               OP_IF,          "C",    C1, VL, NULL, 0, IfElse},
    atLoad          = {"Load",             OP_LOAD,        "NS",   C1, 0,  NULL, 0, Load},
    atNOP           = {"NoOp",             OP_NOP,         NULL,   C1, 0,  NULL, 0, NULL},
    atNotify        = {"Notify",           OP_NOTIFY,      "SC",   C1, 0,  NULL, 0, Notify},
    atRelease       = {"Release",          OP_RELEASE,     "S",    C1, 0,  NULL, 0, ReleaseResetSignalUnload},
    atReset         = {"Reset",            OP_RESET,       "S",    C1, 0,  NULL, 0, ReleaseResetSignalUnload},
    atReturn        = {"Return",           OP_RETURN,      "C",    C1, 0,  NULL, 0, Return},
    atSignal        = {"Signal",           OP_SIGNAL,      "S",    C1, 0,  NULL, 0, ReleaseResetSignalUnload},
    atSleep         = {"Sleep",            OP_SLEEP,       "C",    C1, 0,  NULL, 0, SleepStall},
    atStall         = {"Stall",            OP_STALL,       "C",    C1, 0,  NULL, 0, SleepStall},
    atUnload        = {"Unload",           OP_UNLOAD,      "S",    C1, 0,  NULL, 0, ReleaseResetSignalUnload},
    atWhile         = {"While",            OP_WHILE,       "C",    C1, VL, NULL, 0, While},
    //
    // Type 2 Opcodes
    //
    atAcquire       = {"Acquire",         OP_ACQUIRE,     "SW",    C2, 0,  NULL, 0, Acquire},
    atAdd           = {"Add",             OP_ADD,         "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atAnd           = {"And",             OP_AND,         "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atBuffer        = {"Buffer",          OP_BUFFER,      "C",     C2, VL, NULL, 0, Buffer},
    atConcat        = {"Concatenate",     OP_CONCAT,      "CCS",   C2, 0,  NULL, 0, Concat},
    atCondRefOf     = {"CondRefOf",       OP_CONDREFOF,   "sS",    C1, 0,  NULL, 0, CondRefOf},
    atDecrement     = {"Decrement",       OP_DECREMENT,   "S",     C2, 0,  NULL, 0, IncDec},
    atDerefOf       = {"DerefOf",         OP_DEREFOF,     "C",     C2, 0,  NULL, 0, DerefOf},
    atDivide        = {"Divide",          OP_DIVIDE,      "CCSS",  C2, 0,  NULL, 0, Divide},
    atFindSetLBit   = {"FindSetLeftBit",  OP_FINDSETLBIT, "CS",    C2, 0,  NULL, 0, ExprOp1},
    atFindSetRBit   = {"FindSetRightBit", OP_FINDSETRBIT, "CS",    C2, 0,  NULL, 0, ExprOp1},
    atFromBCD       = {"FromBCD",         OP_FROMBCD,     "CS",    C2, 0,  NULL, 0, ExprOp1},
    atIncrement     = {"Increment",       OP_INCREMENT,   "S",     C2, 0,  NULL, 0, IncDec},
    atIndex         = {"Index",           OP_INDEX,       "CCS",   C2, RO, NULL, 0, Index},
    atLAnd          = {"LAnd",            OP_LAND,        "CC",    C2, 0,  NULL, 0, LogOp2},
    atLEq           = {"LEqual",          OP_LEQ,         "CC",    C2, 0,  NULL, 0, LogOp2},
    atLG            = {"LGreater",        OP_LG,          "CC",    C2, 0,  NULL, 0, LogOp2},
    atLL            = {"LLess",           OP_LL,          "CC",    C2, 0,  NULL, 0, LogOp2},
    atLNot          = {"LNot",            OP_LNOT,        "C",     C2, 0,  NULL, 0, LNot},
    atLOr           = {"LOr",             OP_LOR,         "CC",    C2, 0,  NULL, 0, LogOp2},
    atMatch         = {"Match",           OP_MATCH,       "CBCBCC",C2, 0,  NULL, 0, Match},
    atMultiply      = {"Multiply",        OP_MULTIPLY,    "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atNAnd          = {"NAnd",            OP_NAND,        "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atNOr           = {"NOr",             OP_NOR,         "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atNot           = {"Not",             OP_NOT,         "CS",    C2, 0,  NULL, 0, ExprOp1},
    atObjType       = {"ObjectType",      OP_OBJTYPE,     "S",     C2, 0,  NULL, 0, ObjTypeSizeOf},
    atOr            = {"Or",              OP_OR,          "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atOSI           = {"OSI",             OP_OSI,         "S",     C2, 0,  NULL, 0, OSInterface},
    atPackage       = {"Package",         OP_PACKAGE,     "B",     C2, VL, NULL, 0, Package},
    atRefOf         = {"RefOf",           OP_REFOF,       "S",     C2, 0,  NULL, 0, RefOf},
    atShiftLeft     = {"ShiftLeft",       OP_SHIFTL,      "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atShiftRight    = {"ShiftRight",      OP_SHIFTR,      "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atSizeOf        = {"SizeOf",          OP_SIZEOF,      "S",     C2, 0,  NULL, 0, ObjTypeSizeOf},
    atStore         = {"Store",           OP_STORE,       "CS",    C2, 0,  NULL, 0, Store},
    atSubtract      = {"Subtract",        OP_SUBTRACT,    "CCS",   C2, 0,  NULL, 0, ExprOp2},
    atToBCD         = {"ToBCD",           OP_TOBCD,       "CS",    C2, 0,  NULL, 0, ExprOp1},
    atWait          = {"Wait",            OP_WAIT,        "SC",    C2, 0,  NULL, 0, Wait},
    atXOr           = {"XOr",             OP_XOR,         "CCS",   C2, 0,  NULL, 0, ExprOp2},
    //
    // Misc. Opcodes
    //
    atNameObj       = {NULL,              OP_NONE,         NULL,   OT, NO, NULL, 0, NULL},
    atDataObj       = {NULL,              OP_NONE,         NULL,   OT, DO, NULL, 0, NULL},
    atString        = {NULL,              OP_STRING,       NULL,   OT, SO, NULL, 0, NULL},
    atArgObj        = {NULL,              OP_NONE,         NULL,   OT, AO, NULL, 0, NULL},
    atLocalObj      = {NULL,              OP_NONE,         NULL,   OT, LO, NULL, 0, NULL},
    atDebugObj      = {"Debug",           OP_DEBUG,        NULL,   OT, BO, NULL, 0, NULL};

PAMLTERM OpcodeTable[256] =
{ //0x00                   0x01                  0x02                  0x03
    &atDataObj,         &atDataObj,         NULL,               NULL,
  //0x04                0x05                0x06                0x07
    NULL,               NULL,               &atAlias,           NULL,
  //0x08                0x09                0x0a                0x0b
    &atName,            NULL,               &atDataObj,         &atDataObj,
  //0x0c                0x0d                0x0e                0x0f
    &atDataObj,         &atString,          NULL,               NULL,
  //0x10                0x11                0x12                0x13
    &atScope,           &atBuffer,          &atPackage,         NULL,
  //0x14                0x15                0x16                0x17
    &atMethod,          NULL,               NULL,               NULL,
  //0x18                0x19                0x1a                0x1b
    NULL,               NULL,               NULL,               NULL,
  //0x1c                0x1d                0x1e                0x1f
    NULL,               NULL,               NULL,               NULL,
  //0x20                0x21                0x22                0x23
    NULL,               NULL,               NULL,               NULL,
  //0x24                0x25                0x26                0x27
    NULL,               NULL,               NULL,               NULL,
  //0x28                0x29                0x2a                0x2b
    NULL,               NULL,               NULL,               NULL,
  //0x2c                0x2d                0x2e                0x2f
    NULL,               NULL,               &atNameObj,         &atNameObj,
  //0x30                0x31                0x32                0x33
    NULL,               NULL,               NULL,               NULL,
  //0x34                0x35                0x36                0x37
    NULL,               NULL,               NULL,               NULL,
  //0x38                0x39                0x3a                0x3b
    NULL,               NULL,               NULL,               NULL,
  //0x3c                0x3d                0x3e                0x3f
    NULL,               NULL,               NULL,               NULL,
  //0x40                0x41                0x42                0x43
    NULL,               &atNameObj,         &atNameObj,         &atNameObj,
  //0x44                0x45                0x46                0x47
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x48                0x49                0x4a                0x4b
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x4c                0x4d                0x4e                0x4f
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x50                0x51                0x52                0x53
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x54                0x55                0x56                0x57
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x58                0x59                0x5a                0x5b
    &atNameObj,         &atNameObj,         &atNameObj,         NULL,
  //0x5c                0x5d                0x5e                0x5f
    &atNameObj,         NULL,               &atNameObj,         &atNameObj,
  //0x60                0x61                0x62                0x63
    &atLocalObj,        &atLocalObj,        &atLocalObj,        &atLocalObj,
  //0x64                0x65                0x66                0x67
    &atLocalObj,        &atLocalObj,        &atLocalObj,        &atLocalObj,
  //0x68                0x69                0x6a                0x6b
    &atArgObj,          &atArgObj,          &atArgObj,          &atArgObj,
  //0x6c                0x6d                0x6e                0x6f
    &atArgObj,          &atArgObj,          &atArgObj,          NULL,
  //0x70                0x71                0x72                0x73
    &atStore,           &atRefOf,           &atAdd,             &atConcat,
  //0x74                0x75                0x76                0x77
    &atSubtract,        &atIncrement,       &atDecrement,       &atMultiply,
  //0x78                0x79                0x7a                0x7b
    &atDivide,          &atShiftLeft,       &atShiftRight,      &atAnd,
  //0x7c                0x7d                0x7e                0x7f
    &atNAnd,            &atOr,              &atNOr,             &atXOr,
  //0x80                0x81                0x82                0x83
    &atNot,             &atFindSetLBit,     &atFindSetRBit,     &atDerefOf,
  //0x84                0x85                0x86                0x87
    NULL,               NULL,               &atNotify,          &atSizeOf,
  //0x88                0x89                0x8a                0x8b
    &atIndex,           &atMatch,           &atDWordField,      &atWordField,
  //0x8c                0x8d                0x8e                0x8f
    &atByteField,       &atBitField,        &atObjType,         NULL,
  //0x90                0x91                0x92                0x93
    &atLAnd,            &atLOr,             &atLNot,            &atLEq,
  //0x94                0x95                0x96                0x97
    &atLG,              &atLL,              NULL,               NULL,
  //0x98                0x99                0x9a                0x9b
    NULL,               NULL,               NULL,               NULL,
  //0x9c                0x9d                0x9e                0x9f
    NULL,               NULL,               NULL,               NULL,
  //0xa0                0xa1                0xa2                0xa3
    &atIf,              &atElse,            &atWhile,           &atNOP,
  //0xa4                0xa5                0xa6                0xa7
    &atReturn,          &atBreak,           NULL,               NULL,
  //0xa8                0xa9                0xaa                0xab
    NULL,               NULL,               NULL,               NULL,
  //0xac                0xad                0xae                0xaf
    NULL,               NULL,               NULL,               NULL,
  //0xb0                0xb1                0xb2                0xb3
    NULL,               NULL,               NULL,               NULL,
  //0xb4                0xb5                0xb6                0xb7
    NULL,               NULL,               NULL,               NULL,
  //0xb8                0xb9                0xba                0xbb
    NULL,               NULL,               NULL,               NULL,
  //0xbc                0xbd                0xbe                0xbf
    NULL,               NULL,               NULL,               NULL,
  //0xc0                0xc1                0xc2                0xc3
    NULL,               NULL,               NULL,               NULL,
  //0xc4                0xc5                0xc6                0xc7
    NULL,               NULL,               NULL,               NULL,
  //0xc8                0xc9                0xca                0xcb
    NULL,               NULL,               &atOSI,             NULL,
  //0xcc                0xcd                0xce                0xcf
    &atBreakPoint,      NULL,               NULL,               NULL,
  //0xd0                0xd1                0xd2                0xd3
    NULL,               NULL,               NULL,               NULL,
  //0xd4                0xd5                0xd6                0xd7
    NULL,               NULL,               NULL,               NULL,
  //0xd8                0xd9                0xda                0xdb
    NULL,               NULL,               NULL,               NULL,
  //0xdc                0xdd                0xde                0xdf
    NULL,               NULL,               NULL,               NULL,
  //0xe0                0xe1                0xe2                0xe3
    NULL,               NULL,               NULL,               NULL,
  //0xe4                0xe5                0xe6                0xe7
    NULL,               NULL,               NULL,               NULL,
  //0xe8                0xe9                0xea                0xeb
    NULL,               NULL,               NULL,               NULL,
  //0xec                0xed                0xee                0xef
    NULL,               NULL,               NULL,               NULL,
  //0xf0                0xf1                0xf2                0xf3
    NULL,               NULL,               NULL,               NULL,
  //0xf4                0xf5                0xf6                0xf7
    NULL,               NULL,               NULL,               NULL,
  //0xf8                0xf9                0xfa                0xfb
    NULL,               NULL,               NULL,               NULL,
  //0xfc                0xfd                0xfe                0xff
    NULL,               NULL,               NULL,               &atDataObj
};

OPCODEMAP ExOpcodeTable[] =
{
    EXOP_MUTEX,         &atMutex,
    EXOP_EVENT,         &atEvent,
    EXOP_CONDREFOF,     &atCondRefOf,
    EXOP_CREATEFIELD,   &atCreateField,
    EXOP_LOAD,          &atLoad,
    EXOP_STALL,         &atStall,
    EXOP_SLEEP,         &atSleep,
    EXOP_ACQUIRE,       &atAcquire,
    EXOP_SIGNAL,        &atSignal,
    EXOP_WAIT,          &atWait,
    EXOP_RESET,         &atReset,
    EXOP_RELEASE,       &atRelease,
    EXOP_FROMBCD,       &atFromBCD,
    EXOP_TOBCD,         &atToBCD,
    EXOP_UNLOAD,        &atUnload,
    EXOP_REVISION,      &atDataObj,
    EXOP_DEBUG,         &atDebugObj,
    EXOP_FATAL,         &atFatal,
    EXOP_OPREGION,      &atOpRegion,
    EXOP_FIELD,         &atField,
    EXOP_DEVICE,        &atDevice,
    EXOP_PROCESSOR,     &atProcessor,
    EXOP_POWERRES,      &atPowerRes,
    EXOP_THERMALZONE,   &atThermalZone,
    EXOP_IDXFIELD,      &atIndexField,
    EXOP_BANKFIELD,     &atBankField,
    0,                  NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\ctxt.h ===
/*** ctxt.h - AML context structures and definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     06/13/97
 *
 *  MODIFICATION HISTORY
 */

#ifndef _CTXT_H
#define _CTXT_H

/*** Type and Structure definitions
 */
typedef struct _ctxt CTXT, *PCTXT, **PPCTXT;
typedef struct _heap HEAP, *PHEAP;
typedef NTSTATUS (LOCAL *PFNPARSE)(PCTXT, PVOID, NTSTATUS);
typedef NTSTATUS (LOCAL *PFN)();

typedef struct _framehdr
{
    ULONG    dwSig;                     //frame object signature
    ULONG    dwLen;                     //frame object length
    ULONG    dwfFrame;                  //frame flags
    PFNPARSE pfnParse;                  //frame object parse function
} FRAMEHDR, *PFRAMEHDR;

#define FRAMEF_STAGE_MASK       0x0000000f
#define FRAMEF_CONTEXT_MASK     0xffff0000

typedef struct _post
{
    FRAMEHDR  FrameHdr;                 //frame header
    ULONG_PTR uipData1;                 //data1
    ULONG_PTR uipData2;                 //data2
    POBJDATA pdataResult;               //points to result object
} POST, *PPOST;

#define SIG_POST                'TSOP'

typedef struct _scope
{
    FRAMEHDR  FrameHdr;                 //frame header
    PUCHAR    pbOpEnd;                  //points to the end of scope
    PUCHAR    pbOpRet;                  //points to return address of scope
    PNSOBJ    pnsPrevScope;             //points to previous scope
    POBJOWNER pownerPrev;               //points to previous object owner
    PHEAP     pheapPrev;                //points to previous heap
    POBJDATA  pdataResult;              //points to result object
} SCOPE, *PSCOPE;

#define SIG_SCOPE               'POCS'
#define SCOPEF_FIRST_TERM       0x00010000

typedef struct _call
{
    FRAMEHDR  FrameHdr;                 //frame header
    struct _call *pcallPrev;            //points to previous call frame
    POBJOWNER pownerPrev;               //points to previous object owner
    PNSOBJ    pnsMethod;                //points to method object
    int       iArg;                     //next argument to be parsed
    int       icArgs;                   //number of arguments
    POBJDATA  pdataArgs;                //points to the argument array
    OBJDATA   Locals[MAX_NUM_LOCALS];   //arrays of locals
    POBJDATA  pdataResult;              //points to result object
} CALL, *PCALL;

#define SIG_CALL                'LLAC'
#define CALLF_NEED_MUTEX        0x00010000
#define CALLF_ACQ_MUTEX         0x00020000
#define CALLF_INVOKE_CALL       0x00040000

typedef struct _nestedctxt
{
    FRAMEHDR    FrameHdr;               //frame header
    PNSOBJ      pnsObj;                 //points to current object of evaluation
    PNSOBJ      pnsScope;               //points to current scope
    OBJDATA     Result;                 //to hold result data
    PFNACB      pfnAsyncCallBack;       //async completion callback function
    POBJDATA    pdataCallBack;          //points to return data of eval.
    PVOID       pvContext;              //context data for async callback
    ULONG       dwfPrevCtxt;            //save previous context flags
    struct _nestedctxt *pnctxtPrev;     //save previous nested context frame
} NESTEDCTXT, *PNESTEDCTXT;

#define SIG_NESTEDCTXT          'XTCN'

typedef struct _term
{
    FRAMEHDR FrameHdr;                  //frame header
    PUCHAR   pbOpTerm;                  //points to opcode of this term
    PUCHAR   pbOpEnd;                   //points to the end of the term
    PUCHAR   pbScopeEnd;                //points to the end of the scope
    PAMLTERM pamlterm;                  //points to AMLTERM for this term
    PNSOBJ   pnsObj;                    //to store object created by this term
    int      iArg;                      //next argument to be parsed
    int      icArgs;                    //number of arguments
    POBJDATA pdataArgs;                 //points to the argument array
    POBJDATA pdataResult;               //points to result object
} TERM, *PTERM;

#define SIG_TERM                'MRET'

typedef struct _package
{
    FRAMEHDR    FrameHdr;               //frame header
    PPACKAGEOBJ ppkgobj;                //points to the package object
    int         iElement;               //next element to parse
    PUCHAR      pbOpEnd;                //points to package end
} PACKAGE, *PPACKAGE;

#define SIG_PACKAGE             'FGKP'

typedef struct _acquire
{
    FRAMEHDR  FrameHdr;                 //frame header
    PMUTEXOBJ pmutex;                   //points to the mutex object data
    USHORT    wTimeout;                 //timeout value
    POBJDATA  pdataResult;              //points to result object
} ACQUIRE, *PACQUIRE;

#define SIG_ACQUIRE             'FQCA'
#define ACQF_NEED_GLOBALLOCK    0x00010000
#define ACQF_HAVE_GLOBALLOCK    0x00020000
#define ACQF_SET_RESULT         0x00040000

typedef struct _accfieldunit
{
    FRAMEHDR FrameHdr;                  //frame header
    POBJDATA pdataObj;                  //points to field unit object data
    POBJDATA pdata;                     //points to source/result object
} ACCFIELDUNIT, *PACCFIELDUNIT;

#define SIG_ACCFIELDUNIT        'UFCA'
#define AFUF_READFIELDUNIT      0x00010000
#define AFUF_HAVE_GLOBALLOCK    0x00020000

typedef struct _wrfieldloop
{
    FRAMEHDR   FrameHdr;                //frame header
    POBJDATA   pdataObj;                //points to object to be written
    PFIELDDESC pfd;                     //points to FieldDesc
    PUCHAR     pbBuff;                  //points to source buffer
    ULONG      dwBuffSize;              //source buffer size
    ULONG      dwDataInc;               //data write increment
} WRFIELDLOOP, *PWRFIELDLOOP;

#define SIG_WRFIELDLOOP         'LFRW'

typedef struct _accfieldobj
{
    FRAMEHDR  FrameHdr;                 //frame header
    POBJDATA  pdataObj;                 //object to be read
    PUCHAR    pbBuff;                   //points to target buffer
    PUCHAR    pbBuffEnd;                //points to target buffer end
    ULONG     dwAccSize;                //access size
    ULONG     dwcAccesses;              //number of accesses
    ULONG     dwDataMask;               //data mask
    int       iLBits;                   //number of left bits
    int       iRBits;                   //number of right bits
    int       iAccess;                  //index to number of accesses
    ULONG     dwData;                   //temp. data
    FIELDDESC fd;
} ACCFIELDOBJ, *PACCFIELDOBJ;

#define SIG_ACCFIELDOBJ         'OFCA'

typedef struct _preservewrobj
{
    FRAMEHDR FrameHdr;                  //frame header
    POBJDATA pdataObj;                  //object to be read
    ULONG    dwWriteData;               //data to be written
    ULONG    dwPreserveMask;            //preserve bit mask
    ULONG    dwReadData;                //temp data read
} PRESERVEWROBJ, *PPRESERVEWROBJ;

#define SIG_PRESERVEWROBJ       'ORWP'

typedef struct _wrcookacc
{
    FRAMEHDR  FrameHdr;                 //frame header
    PNSOBJ    pnsBase;                  //points to opregion object
    PRSACCESS prsa;                     //points to RSACCESS
    ULONG     dwAddr;                   //region space address
    ULONG     dwSize;                   //size of access
    ULONG     dwData;                   //data to be written
    ULONG     dwDataMask;               //data mask
    ULONG     dwDataTmp;                //temp. data
    BOOLEAN   fPreserve;                //TRUE if need preserve bits
} WRCOOKACC, *PWRCOOKACC;

#define SIG_WRCOOKACC           'ACRW'

typedef struct _sleep
{
    FRAMEHDR      FrameHdr;             //frame header
    LIST_ENTRY    ListEntry;            //to link the sleep requests together
    LARGE_INTEGER SleepTime;            //wake up time
    PCTXT         Context;              //points to current context
} SLEEP, *PSLEEP;

#define SIG_SLEEP               'PELS'

typedef struct _resource
{
    ULONG         dwResType;
    struct _ctxt  *pctxtOwner;
    PVOID         pvResObj;
    LIST          list;
} RESOURCE, *PRESOURCE;

#define RESTYPE_MUTEX           1

typedef struct _heapobjhdr
{
    ULONG   dwSig;                      //heap object signature
    ULONG   dwLen;                      //heap object length;
    PHEAP   pheap;                      //points to beginning of heap
    LIST    list;                       //links all free heap blocks
} HEAPOBJHDR, *PHEAPOBJHDR;

struct _heap
{
    ULONG       dwSig;                  //heap signature
    PUCHAR      pbHeapEnd;              //points to end of heap block
    PHEAP       pheapHead;              //points to head of heap chain
    PHEAP       pheapNext;              //points to next heap block
    PUCHAR      pbHeapTop;              //points to the last free heap block
    PLIST       plistFreeHeap;          //points to the free heap block list
    HEAPOBJHDR  Heap;                   //beginning of heap memory
};

#define SIG_HEAP                'PAEH'

struct _ctxt
{
    ULONG       dwSig;                  //signature "CTXT"
    PUCHAR      pbCtxtEnd;              //points to end of context block
    LIST        listCtxt;               //links all allocated context
    LIST        listQueue;              //links for queuing context
    PPLIST      pplistCtxtQueue;        //points to queue head pointer
    PLIST       plistResources;         //links all owned resources
    ULONG       dwfCtxt;                //context flags
    PNSOBJ      pnsObj;                 //points to current object of evaluation
    PNSOBJ      pnsScope;               //points to current scope
    POBJOWNER   powner;                 //points to current object owner
    PCALL       pcall;                  //points to current call frame
    PNESTEDCTXT pnctxt;                 //points to current nest ctxt frame
    ULONG       dwSyncLevel;            //current sync level for mutexs
    PUCHAR      pbOp;                   //AML code pointer
    OBJDATA     Result;                 //to hold result data
    PFNACB      pfnAsyncCallBack;       //async completion callback function
    POBJDATA    pdataCallBack;          //points to return data of eval.
    PVOID       pvContext;              //context data for async callback
//  #ifdef DEBUGGER
//    LARGE_INTEGER Timestamp;
//  #endif
    KTIMER      Timer;                  //timeout timer if context is blocked
    KDPC        Dpc;                    //DPC hook for the context
    PHEAP       pheapCurrent;           //current heap
    CTXTDATA    CtxtData;               //context data
    HEAP        LocalHeap;              //Local heap
};

#define SIG_CTXT                'TXTC'
#define CTXTF_TIMER_PENDING     0x00000001
#define CTXTF_TIMER_DISPATCH    0x00000002
#define CTXTF_TIMEOUT           0x00000004
#define CTXTF_READY             0x00000008
#define CTXTF_RUNNING           0x00000010
#define CTXTF_NEED_CALLBACK     0x00000020
#define CTXTF_IN_READYQ         0x00000040
#define CTXTF_NEST_EVAL         0x00000080
#define CTXTF_ASYNC_EVAL        0x00000100

typedef struct _ctxtq
{
    ULONG    dwfCtxtQ;
    PKTHREAD pkthCurrent;
    PCTXT    pctxtCurrent;
    PLIST    plistCtxtQ;
    ULONG    dwmsTimeSliceLength;
    ULONG    dwmsTimeSliceInterval;
    PFNAA    pfnPauseCallback;
    PVOID    PauseCBContext;
    MUTEX    mutCtxtQ;
    KTIMER   Timer;
    KDPC     DpcStartTimeSlice;
    KDPC     DpcExpireTimeSlice;
    WORK_QUEUE_ITEM WorkItem;
} CTXTQ, *PCTXTQ;

#define CQF_TIMESLICE_EXPIRED   0x00000001
#define CQF_WORKITEM_SCHEDULED  0x00000002
#define CQF_FLUSHING            0x00000004
#define CQF_PAUSED              0x00000008

typedef struct _syncevent
{
    NTSTATUS rcCompleted;
    PCTXT    pctxt;
    KEVENT   Event;
} SYNCEVENT, *PSYNCEVENT;

typedef struct _restart
{
    PCTXT pctxt;
    WORK_QUEUE_ITEM WorkItem;
} RESTART, *PRESTART;

#endif  //ifndef _CTXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\cmdarg.h ===
/*** cmdarg.h - Command argument parsing Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/18/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _CMDARG_H
#define _CMDARG_H

#ifdef DEBUGGER

/*** Macros
 */

#define ARG_ERROR(x)            ConPrintf(MODNAME "_ARGERR: ");         \
                                ConPrintf x;                            \
                                ConPrintf("\n");

/*** Constants
 */

// Error codes
#define ARGERR_NONE             0
#define ARGERR_SEP_NOT_FOUND    -1
#define ARGERR_INVALID_NUMBER   -2
#define ARGERR_INVALID_ARG      -3
#define ARGERR_ASSERT_FAILED    -4

// Command argument flags
#define AF_NOI                  0x00000001      //NoIgnoreCase
#define AF_SEP                  0x00000002      //require separator

// Command argument types
#define AT_END                  0               //end marker of arg table
#define AT_STRING               1
#define AT_NUM                  2
#define AT_ENABLE               3
#define AT_DISABLE              4
#define AT_ACTION               5

/*** Type definitions
 */

typedef struct _cmdarg CMDARG;
typedef CMDARG *PCMDARG;
typedef LONG (LOCAL *PFNARG)(PCMDARG, PSZ, ULONG, ULONG);

struct _cmdarg
{
    PSZ    pszArgID;            //argument ID string
    ULONG  dwArgType;           //AT_*
    ULONG  dwfArg;              //AF_*
    PVOID  pvArgData;           //AT_END: none
                                //AT_STRING: PPSZ - ptr. to string ptr.
                                //AT_NUM: PLONG - ptr. to number
                                //AT_ENABLE: PULONG - ptr. to flags
                                //AT_DISABLE: PULONG - ptr. to flags
                                //AT_ACTION: none
    ULONG  dwArgParam;          //AT_END: none
                                //AT_STRING: none
                                //AT_NUM: base
                                //AT_ENABLE: flag bit mask
                                //AT_DISABLE: flag bit mask
                                //AT_ACTION: none
    PFNARG pfnArg;              //ptr. to argument verification function or
                                //  action function if AT_ACTION
};

/*** Exported function prototypes
 */

LONG LOCAL DbgParseArgs(PCMDARG ArgTable, PULONG pdwNumArgs,
                        PULONG pdwNonSWArgs, PSZ pszTokenSeps);

#endif  //ifdef DEBUGGER
#endif  //ifndef _CMDARG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\cmdarg.c ===
/*** cmdarg.c - Command argument parsing functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/18/96
 *
 *  MODIFICATION HISTORY
 */


#include "pch.h"

#ifdef DEBUGGER

/*** Local function prototypes
 */

LONG LOCAL DbgParseOneArg(PCMDARG ArgTable, PSZ psz, ULONG dwArgNum,
                          PULONG pdwNonSWArgs);
PCMDARG LOCAL DbgMatchArg(PCMDARG ArgTable, PSZ *ppsz, PULONG pdwNonSWArgs);

/*** Local data
 */

PSZ pszSwitchChars = "-/";
PSZ pszOptionSeps = "=:";

/***EP  DbgParseArgs - parse command arguments
 *
 *  ENTRY
 *      pArgs -> command argument table
 *      pdwNumArgs -> to hold the number of arguments parsed
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *      pszTokenSeps -> token separator characters string
 *
 *  EXIT-SUCCESS
 *      returns ARGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DbgParseArgs(PCMDARG ArgTable, PULONG pdwNumArgs,
                        PULONG pdwNonSWArgs, PSZ pszTokenSeps)
{
    LONG rc = ARGERR_NONE;
    PSZ psz;

    *pdwNumArgs = 0;
    *pdwNonSWArgs = 0;
    while ((psz = STRTOK(NULL, pszTokenSeps)) != NULL)
    {
        (*pdwNumArgs)++;
        if ((rc = DbgParseOneArg(ArgTable, psz, *pdwNumArgs, pdwNonSWArgs)) !=
            ARGERR_NONE)
        {
            break;
        }
    }

    return rc;
}       //DbgParseArgs

/***LP  DbgParseOneArg - parse one command argument
 *
 *  ENTRY
 *      pArgs -> command argument table
 *      psz -> argument string
 *      dwArgNum - argument number
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *
 *  EXIT-SUCCESS
 *      returns ARGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DbgParseOneArg(PCMDARG ArgTable, PSZ psz, ULONG dwArgNum,
                          PULONG pdwNonSWArgs)
{
    LONG rc = ARGERR_NONE;
    PCMDARG pArg;
    PSZ pszEnd;

    if ((pArg = DbgMatchArg(ArgTable, &psz, pdwNonSWArgs)) != NULL)
    {
        switch (pArg->dwArgType)
        {
            case AT_STRING:
            case AT_NUM:
                if (pArg->dwfArg & AF_SEP)
                {
                    if ((*psz != '\0') &&
                        (STRCHR(pszOptionSeps, *psz) != NULL))
                    {
                        psz++;
                    }
                    else
                    {
                        ARG_ERROR(("argument missing option separator - %s",
                                   psz));
                        rc = ARGERR_SEP_NOT_FOUND;
                        break;
                    }
                }

                if (pArg->dwArgType == AT_STRING)
                {
                    *((PSZ *)pArg->pvArgData) = psz;
                }
                else
                {
                    *((PLONG)pArg->pvArgData) =
                        STRTOL(psz, &pszEnd, pArg->dwArgParam);
                    if (psz == pszEnd)
                    {
                        ARG_ERROR(("invalid numeric argument - %s", psz));
                        rc = ARGERR_INVALID_NUMBER;
                        break;
                    }
                }

                if (pArg->pfnArg != NULL)
                {
                    rc = pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs);
                }
                break;

            case AT_ENABLE:
            case AT_DISABLE:
                if (pArg->dwArgType == AT_ENABLE)
                    *((PULONG)pArg->pvArgData) |= pArg->dwArgParam;
                else
                    *((PULONG)pArg->pvArgData) &= ~pArg->dwArgParam;

                if ((pArg->pfnArg != NULL) &&
                    (pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs) !=
                     ARGERR_NONE))
                {
                    break;
                }

                if (*psz != '\0')
                {
                    rc = DbgParseOneArg(ArgTable, psz, dwArgNum, pdwNonSWArgs);
                }
                break;

            case AT_ACTION:
                ASSERT(pArg->pfnArg != NULL);
                rc = pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs);
                break;

            default:
                ARG_ERROR(("invalid argument table"));
                rc = ARGERR_ASSERT_FAILED;
        }
    }
    else
    {
        ARG_ERROR(("invalid command argument - %s", psz));
        rc = ARGERR_INVALID_ARG;
    }

    return rc;
}       //DbgParseOneArg

/***LP  DbgMatchArg - match argument type from argument table
 *
 *  ENTRY
 *      ArgTable -> argument table
 *      ppsz -> argument string pointer
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *
 *  EXIT-SUCCESS
 *      returns pointer to argument entry matched
 *  EXIT-FAILURE
 *      returns NULL
 */

PCMDARG LOCAL DbgMatchArg(PCMDARG ArgTable, PSZ *ppsz, PULONG pdwNonSWArgs)
{
    PCMDARG pArg;

    for (pArg = ArgTable; pArg->dwArgType != AT_END; pArg++)
    {
        if (pArg->pszArgID == NULL)     //NULL means match anything.
        {
            (*pdwNonSWArgs)++;
            break;
        }
        else
        {
            ULONG dwLen;

            if (STRCHR(pszSwitchChars, **ppsz) != NULL)
                (*ppsz)++;

            dwLen = STRLEN(pArg->pszArgID);
            if (StrCmp(pArg->pszArgID, *ppsz, dwLen,
                       (BOOLEAN)((pArg->dwfArg & AF_NOI) != 0)) == 0)
            {
                (*ppsz) += dwLen;
                break;
            }
        }
    }

    if (pArg->dwArgType == AT_END)
        pArg = NULL;

    return pArg;
}       //DbgMatchArg

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\amlitest.h ===
/*#include "acpitabl.h"
#include "amli.h"*/


#define ACPIVER_DATA_TYPE_AMLI                            ((UCHAR)1)
#define ACPIVER_DATA_TYPE_END                             2

#define ACPIVER_DATA_SUBTYPE_GET_NAME_SPACE_OBJECT        ((UCHAR)1)
#define ACPIVER_DATA_SUBTYPE_GET_FIELD_UNIT_REGION_OP     ((UCHAR)2)
#define ACPIVER_DATA_SUBTYPE_EVAL_NAME_SPACE_OBJECT       ((UCHAR)3)
#define ACPIVER_DATA_SUBTYPE_ASYNC_EVAL_OBJECT            ((UCHAR)4)
#define ACPIVER_DATA_SUBTYPE_NEST_ASYNC_EVAL_OBJECT       ((UCHAR)5)
#define ACPIVER_DATA_SUBTYPE_REG_EVENT_HANDLER            ((UCHAR)6)
#define ACPIVER_DATA_SUBTYPE_EVAL_PACKAGE_ELEMENT         ((UCHAR)7)
#define ACPIVER_DATA_SUBTYPE_EVAL_PKG_DATA_ELEMENT        ((UCHAR)8)
#define ACPIVER_DATA_SUBTYPE_FREE_DATA_BUFFS              ((UCHAR)9)
#define ACPIVER_DATA_SUBTYPE_PAUSE_INTERPRETER            ((UCHAR)10)
#define ACPIVER_DATA_SUBTYPE_RESUME_INTERPRETER           ((UCHAR)11)
#define ACPIVER_DATA_SUBTYPE_END                          ((UCHAR)12)

//
//  Pre/Post GetNameSpaceObject
// 
NTSTATUS 
AMLITest_Pre_GetNameSpaceObject(
   IN PSZ pszObjPath,   
   IN PNSOBJ pnsScope,
   OUT PPNSOBJ ppns, 
   IN ULONG dwfFlags,
   IN PAMLIHOOK_DATA  * ppData);



NTSTATUS 
AMLITest_Post_GetNameSpaceObject(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS _Status);


//
//  Pre/Post GetFieldUnitRegionObj
//

NTSTATUS 
AMLITest_Pre_GetFieldUnitRegionObj(
   IN PFIELDUNITOBJ pfu,
   OUT PPNSOBJ ppns,
   PAMLIHOOK_DATA  * ppData);




NTSTATUS 
AMLITest_Post_GetFieldUnitRegionObj(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS _Status);

//
//  Pre/Post EvalNameSpaceObject
//

NTSTATUS 
AMLITest_Pre_EvalNameSpaceObject(
   IN PNSOBJ pns,
   OUT POBJDATA pdataResult,
   IN int icArgs,
   IN POBJDATA pdataArgs,
   IN PAMLIHOOK_DATA  * ppData);

NTSTATUS 
AMLITest_Post_EvalNameSpaceObject(
   PAMLIHOOK_DATA  * ppData,
   NTSTATUS _Status);

//
//  CallBack Pre/Post AsyncEvalObject
//


VOID EXPORT
AMLITest_AsyncEvalObjectCallBack(
   IN PNSOBJ pns, 
   IN NTSTATUS status, 
   IN POBJDATA pdataResult, 
   IN PVOID Context);



NTSTATUS 
AMLITest_Pre_AsyncEvalObject(
   IN PNSOBJ pns,
   OUT POBJDATA pdataResult,
   IN int icArgs,
   IN POBJDATA pdataArgs,
   IN PFNACB * nAsyncCallBack,
   IN PVOID * Context,
   PAMLIHOOK_DATA  * Data);

NTSTATUS 
AMLITest_Post_AsyncEvalObject(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);




//
//  Pre/Post NestAsyncEvalObject
//

NTSTATUS 
AMLITest_Pre_NestAsyncEvalObject(
   PNSOBJ pns,
   POBJDATA pdataResult,
   int icArgs,
   POBJDATA pdataArgs,
   PFNACB * pfnAsyncCallBack,
   PVOID * pvContext,
   PAMLIHOOK_DATA  * Data);


NTSTATUS 
AMLITest_Post_NestAsyncEvalObject(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);

//
//  Pre/Post EvalPackageElement
//

NTSTATUS 
AMLITest_Pre_EvalPackageElement(
   PNSOBJ pns,
   int iPkgIndex,
   POBJDATA pdataResult,
   PAMLIHOOK_DATA  * Data);

NTSTATUS 
AMLITest_Post_EvalPackageElement(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);

//
//  Pre/Post EvalPkgDataElement
//

NTSTATUS 
AMLITest_Pre_EvalPkgDataElement(
   POBJDATA pdataPkg,
   int iPkgIndex,
   POBJDATA pdataResult,
   PAMLIHOOK_DATA  * Data);

NTSTATUS 
AMLITest_Post_EvalPkgDataElement(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);


//
//  Pre/Post FreeDataBuffs
//

NTSTATUS
AMLITest_Pre_FreeDataBuffs(
   POBJDATA pdata, 
   int icData,
   PAMLIHOOK_DATA  * Data);

NTSTATUS 
AMLITest_Post_FreeDataBuffs(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);



//
//  Pre/Post RegEventHandler
//


NTSTATUS 
AMLIHook_Pre_RegEventHandler(
   ULONG dwEventType, 
   ULONG_PTR uipEventData,
   PFNHND * pfnHandler, 
   ULONG_PTR * uipParam,
   PAMLIHOOK_DATA  * Data);


NTSTATUS 
AMLIHook_Post_RegEventHandler(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);





//
//  CallBack , Pre/Post PauseInterpreter
//

VOID EXPORT
AMLITest_PauseInterpreterCallBack(
   PVOID Context);

NTSTATUS 
AMLITest_Pre_PauseInterpreter(
   PFNAA * pfnCallBack, 
   PVOID * Context,
   PAMLIHOOK_DATA  * Data);

NTSTATUS 
AMLITest_Post_PauseInterpreter(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);

//
//  Pre/Post ResumeInterpreter
//

NTSTATUS 
AMLITest_Pre_ResumeInterpreter(
   PAMLIHOOK_DATA  * Data);

NTSTATUS 
AMLITest_Post_ResumeInterpreter(
   PAMLIHOOK_DATA  * Data,
   NTSTATUS Status);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\ctxt.c ===
/*** ctxt.c - Context Block handling functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     06/13/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

NTSTATUS
LOCAL
NewContext(
    PPCTXT ppctxt
    )
/*++

Routine Description:

    Allocate a new context structure from tne NonPaged Lookaside
    List. Also keep track of the high water marks so that the OS
    can intelligently decide what the "appropriate" number of
    contexts that it should allocate.

    Note that this code raises the possibility that if we detect
    an out-of-memory error, we might be able to save a registry
    key that includes a new larger number (to prevent this problem
    in the first place). Adaptive recovery?

Arguments:

    ppctxt  - address of to hold the newly created context

Return Value:

    NTSTATUS

--*/
{
    TRACENAME("NEWCONTEXT")
    KIRQL       oldIrql;
    NTSTATUS    rc = STATUS_SUCCESS;

    ENTER(2, ("NewContext(ppctxt=%x)\n", ppctxt));

    *ppctxt = ExAllocateFromNPagedLookasideList(
        &AMLIContextLookAsideList
        );
    if (*ppctxt == NULL) {

        AMLI_WARN(("NewContext: Could not Allocate New Context"));
        rc = AMLIERR_OUT_OF_MEM;

    } else {

        //
        // Bookkeeping for memory resources to determine the high
        // water mark
        //
        KeAcquireSpinLock(&gdwGContextSpinLock, &oldIrql );
        gdwcCTObjs++;
        if (gdwcCTObjs > 0 &&
            (ULONG) gdwcCTObjs > gdwcCTObjsMax) {

            gdwcCTObjsMax = gdwcCTObjs;

        }
        KeReleaseSpinLock(&gdwGContextSpinLock, oldIrql );

        //
        // Context Initialization
        //
        InitContext(*ppctxt, gdwCtxtBlkSize);
        AcquireMutex(&gmutCtxtList);
        ListInsertTail(&(*ppctxt)->listCtxt, &gplistCtxtHead);
        ReleaseMutex(&gmutCtxtList);

    }

    EXIT(2, ("NewContext=%x (pctxt=%x)\n", rc, *ppctxt));
    return rc;
}  //NewContext

VOID
LOCAL
FreeContext(
    PCTXT pctxt
    )
/*++

Routine Description:

    This is routine is called when a context is no longer required
    and should be returned to the system's LookAside list

Arguments:

    pctxt   - Address of the context to be freed

Return Value:

    None

--*/
{
    TRACENAME("FREECONTEXT")
    KIRQL   oldIrql;
    
    ENTER(2, ("FreeContext(pctxt=%x)\n", pctxt));
    ASSERT(pctxt->powner == NULL);

    //
    // Need to hold the proper mutex to touch the global ctxt list
    //
    AcquireMutex(&gmutCtxtList);
    ListRemoveEntry(&pctxt->listCtxt, &gplistCtxtHead);

    if (pctxt->pplistCtxtQueue != NULL) {

        ListRemoveEntry(&pctxt->listQueue, pctxt->pplistCtxtQueue);

    }

    //
    // Done with the global mutex
    //
    ReleaseMutex(&gmutCtxtList);

    //
    // Release any allocated storage that might not have been cleaned up
    //
    FreeDataBuffs(&pctxt->Result, 1);

    //
    // Bookkeeping for memory resources to determine the high
    // water mark
    //
    KeAcquireSpinLock(&gdwGContextSpinLock, &oldIrql );
    gdwcCTObjs--;
    ASSERT(gdwcCTObjs >= 0);
    KeReleaseSpinLock(&gdwGContextSpinLock, oldIrql );

    
    //
    // Log the end of a method
    //
    ACPIWMILOGEVENT((1,
                EVENT_TRACE_TYPE_END,
                GUID_List[AMLI_LOG_GUID],
                "Object = %s",
                GetObjectPath(pctxt->pnsObj)
               ));

    //
    // Return the context to the nonpaged lookaside list
    //
    ExFreeToNPagedLookasideList(&AMLIContextLookAsideList, pctxt);
    EXIT(2, ("FreeContext!\n"));
} //FreeContext

/***LP  InitContext - initialize a given context block
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      dwLen - length of context block
 *
 *  EXIT
 *      None
 */

VOID LOCAL InitContext(PCTXT pctxt, ULONG dwLen)
{
    TRACENAME("INITCONTEXT")

    ENTER(2, ("InitContext(pctxt=%x,Len=%d)\n", pctxt, dwLen));

    MEMZERO(pctxt, sizeof(CTXT) - sizeof(HEAP));
    pctxt->dwSig = SIG_CTXT;
    pctxt->pbCtxtEnd = (PUCHAR)pctxt + dwLen;
    pctxt->pheapCurrent = &pctxt->LocalHeap;
//  #ifdef DEBUGGER
//    KeQuerySystemTime(&pctxt->Timestamp);
//  #endif
    KeInitializeDpc(&pctxt->Dpc, TimeoutCallback, pctxt);
    KeInitializeTimer(&pctxt->Timer);
    InitHeap(&pctxt->LocalHeap,
             (ULONG)(pctxt->pbCtxtEnd - (PUCHAR)&pctxt->LocalHeap));
    pctxt->LocalHeap.pheapHead = &pctxt->LocalHeap;

    EXIT(2, ("InitContext!\n"));
}       //InitContext

/***LP  IsStackEmpty - determine if the stack is empty
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT-SUCCESS
 *      returns TRUE - stack is empty
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN LOCAL IsStackEmpty(PCTXT pctxt)
{
    TRACENAME("ISSTACKEMPTY")
    BOOLEAN rc;

    ENTER(2, ("IsStackEmpty(pctxt=%p)\n", pctxt));

    rc = (BOOLEAN)(pctxt->LocalHeap.pbHeapEnd == pctxt->pbCtxtEnd);

    EXIT(2, ("IsStackEmpty=%x\n", rc));
    return rc;
}       //IsStackEmpty

/***LP  PushFrame - Push a new frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      dwSig - frame object signature
 *      dwLen - size of the frame object
 *      pfnParse -> frame object parse function
 *      ppvFrame -> to hold pointer to the newly pushed frame (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushFrame(PCTXT pctxt, ULONG dwSig, ULONG dwLen,
                         PFNPARSE pfnParse, PVOID *ppvFrame)
{
    TRACENAME("PUSHFRAME")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("PushFrame(pctxt=%p,Sig=%s,Len=%d,pfnParse=%p,ppvFrame=%p)\n",
              pctxt, NameSegString(dwSig), dwLen, pfnParse, ppvFrame));
    //
    // Check to see if we have enough space, make sure it doesn't run into the
    // heap.
    //
    if (pctxt->LocalHeap.pbHeapEnd - dwLen >= pctxt->LocalHeap.pbHeapTop)
    {
        PFRAMEHDR pfh;

        pctxt->LocalHeap.pbHeapEnd -= dwLen;
        pfh = (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd;
        MEMZERO(pfh, dwLen);
        pfh->dwSig = dwSig;
        pfh->dwLen = dwLen;
        pfh->pfnParse = pfnParse;

        if (ppvFrame != NULL)
        {
            *ppvFrame = pfh;
        }

      #ifdef DEBUG
        if ((ULONG)(pctxt->pbCtxtEnd - pctxt->LocalHeap.pbHeapEnd) >
            gdwLocalStackMax)
        {
            gdwLocalStackMax = (ULONG)(pctxt->pbCtxtEnd -
                                       pctxt->LocalHeap.pbHeapEnd);
        }
      #endif
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_STACK_OVERFLOW,
                         ("PushFrame: stack ran out of space"));
    }

    EXIT(2, ("PushFrame=%x (StackTop=%x)\n", rc, pctxt->LocalHeap.pbHeapEnd));
    return rc;
}       //PushFrame

/***LP  PopFrame - Pop a frame off the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT
 *      None
 */

VOID LOCAL PopFrame(PCTXT pctxt)
{
    TRACENAME("POPFRAME")

    ENTER(2, ("PopFrame(pctxt=%p)\n", pctxt));

    ASSERT(!IsStackEmpty(pctxt));
    ASSERT(((PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd)->dwSig != 0);
    pctxt->LocalHeap.pbHeapEnd +=
        ((PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd)->dwLen;

    EXIT(2, ("PopFrame! (StackTop=%p)\n", pctxt->LocalHeap.pbHeapEnd));
}       //PopFrame

/***LP  PushPost - Push a Post frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pfnPost -> post processing function
 *      uipData1 - data1
 *      uipData2 - data2
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushPost(PCTXT pctxt, PFNPARSE pfnPost, ULONG_PTR uipData1,
                        ULONG_PTR uipData2, POBJDATA pdataResult)
{
    TRACENAME("PUSHPOST")
    NTSTATUS rc = STATUS_SUCCESS;
    PPOST ppost;

    ENTER(2, ("PushPost(pctxt=%x,pfnPost=%x,Data1=%x,Data2=%x,pdataResult=%x)\n",
              pctxt, pfnPost, uipData1, uipData2, pdataResult));

    if ((rc = PushFrame(pctxt, SIG_POST, sizeof(POST), pfnPost, &ppost)) ==
        STATUS_SUCCESS)
    {
        ppost->uipData1 = uipData1;
        ppost->uipData2 = uipData2;
        ppost->pdataResult = pdataResult;
    }

    EXIT(2, ("PushPost=%x (ppost=%x)\n", rc, ppost));
    return rc;
}       //PushPost

/***LP  PushScope - Push a ParseScope frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pbOpBegin -> beginning of scope
 *      pbOpEnd -> end of scope
 *      pbOpRet -> return address after end of scope (NULL if continue on)
 *      pnsScope -> new scope
 *      powner -> new owner
 *      pheap -> new heap
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushScope(PCTXT pctxt, PUCHAR pbOpBegin, PUCHAR pbOpEnd,
                         PUCHAR pbOpRet, PNSOBJ pnsScope, POBJOWNER powner,
                         PHEAP pheap, POBJDATA pdataResult)
{
    TRACENAME("PUSHSCOPE")
    NTSTATUS rc = STATUS_SUCCESS;
    PSCOPE pscope;

    ENTER(2, ("PushScope(pctxt=%x,pbOpBegin=%x,pbOpEnd=%x,pbOpRet=%x,pnsScope=%x,pheap=%x,pdataResult=%x)\n",
              pctxt, pbOpBegin, pbOpEnd, pbOpRet, pnsScope, pheap,
              pdataResult));

    if ((rc = PushFrame(pctxt, SIG_SCOPE, sizeof(SCOPE), ParseScope, &pscope))
        == STATUS_SUCCESS)
    {
        pctxt->pbOp = pbOpBegin;
        pscope->pbOpEnd = pbOpEnd;
        pscope->pbOpRet = pbOpRet;
        pscope->pnsPrevScope = pctxt->pnsScope;
        pctxt->pnsScope = pnsScope;
        pscope->pownerPrev = pctxt->powner;
        pctxt->powner = powner;
        pscope->pheapPrev = pctxt->pheapCurrent;
        pctxt->pheapCurrent = pheap;
        pscope->pdataResult = pdataResult;
    }

    EXIT(2, ("PushScope=%x (pscope=%x)\n", rc, pscope));
    return rc;
}       //PushScope

/***LP  PushCall - Push a Call frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pnsMethod -> method object
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushCall(PCTXT pctxt, PNSOBJ pnsMethod, POBJDATA pdataResult)
{
    TRACENAME("PUSHCALL")
    NTSTATUS rc = STATUS_SUCCESS;
    PCALL pcall;

    ENTER(2, ("PushCall(pctxt=%x,pnsMethod=%s,pdataResult=%x)\n",
              pctxt, GetObjectPath(pnsMethod), pdataResult));

    ASSERT((pnsMethod == NULL) ||
           (pnsMethod->ObjData.dwDataType == OBJTYPE_METHOD));

    if ((rc = PushFrame(pctxt, SIG_CALL, sizeof(CALL), ParseCall, &pcall))
        == STATUS_SUCCESS)
    {
        if (pnsMethod != NULL)
        {
            PMETHODOBJ pm = (PMETHODOBJ)pnsMethod->ObjData.pbDataBuff;

            pcall->pnsMethod = pnsMethod;
            if (pm->bMethodFlags & METHOD_SERIALIZED)
            {
                pcall->FrameHdr.dwfFrame |= CALLF_NEED_MUTEX;
            }
            pcall->icArgs = (int)(pm->bMethodFlags & METHOD_NUMARG_MASK);
            if (pcall->icArgs > 0)
            {
                if ((pcall->pdataArgs = NEWODOBJ(pctxt->pheapCurrent,
                                                 sizeof(OBJDATA)*pcall->icArgs))
                    == NULL)
                {
                    rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                     ("PushCall: failed to allocate argument objects"));
                }
                else
                {
                    MEMZERO(pcall->pdataArgs, sizeof(OBJDATA)*pcall->icArgs);
                }
            }
        }
        else
        {
            //
            // This is a dummy call frame for AMLILoadDDB.  We just need it
            // for its Locals array in case there is ASL referencing them.
            // But we don't really want to parse a call frame, so let's set
            // it to final clean up stage.
            //
            ASSERT(pctxt->pcall == NULL);
            pctxt->pcall = pcall;
            pcall->FrameHdr.dwfFrame = 4;
        }

        pcall->pdataResult = pdataResult;
    }

    EXIT(2, ("PushCall=%x (pcall=%x)\n", rc, pcall));
    return rc;
}       //PushCall

/***LP  PushTerm - Push a Term frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pbOpTerm -> term opcode
 *      pbScopeEnd -> end of current scope
 *      pamlterm -> AMLTERM
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushTerm(PCTXT pctxt, PUCHAR pbOpTerm, PUCHAR pbScopeEnd,
                        PAMLTERM pamlterm, POBJDATA pdataResult)
{
    TRACENAME("PUSHTERM")
    NTSTATUS rc = STATUS_SUCCESS;
    PTERM pterm;

    ENTER(2, ("PushTerm(pctxt=%x,pbOpTerm=%x,pbScopeEnd=%x,pamlterm=%x,pdataResult=%x)\n",
              pctxt, pbOpTerm, pbScopeEnd, pamlterm, pdataResult));

    if ((rc = PushFrame(pctxt, SIG_TERM, sizeof(TERM), ParseTerm, &pterm)) ==
        STATUS_SUCCESS)
    {
        pterm->pbOpTerm = pbOpTerm;
        pterm->pbScopeEnd = pbScopeEnd;
        pterm->pamlterm = pamlterm;
        pterm->pdataResult = pdataResult;
        pterm->icArgs = pamlterm->pszArgTypes? STRLEN(pamlterm->pszArgTypes): 0;
        if (pterm->icArgs > 0)
        {
            if ((pterm->pdataArgs = NEWODOBJ(pctxt->pheapCurrent,
                                             sizeof(OBJDATA)*pterm->icArgs)) ==
                NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("PushTerm: failed to allocate argument objects"));
            }
            else
            {
                MEMZERO(pterm->pdataArgs, sizeof(OBJDATA)*pterm->icArgs);
            }
        }
    }

    EXIT(2, ("PushTerm=%x (pterm=%x)\n", rc, pterm));
    return rc;
}       //PushTerm

/***LP  RunContext - Run a context
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 *
 *  NOTE
 *      Caller must own the scheduler lock such that the context flags can
 *      be updated properly.  The lock is dropped and re-obtain around
 *      execution of the target context.
 */

NTSTATUS LOCAL RunContext(PCTXT pctxt)
{
    TRACENAME("RUNCONTEXT")
    NTSTATUS rc;
    PFRAMEHDR pfh;
    PKTHREAD pkthSave = gReadyQueue.pkthCurrent;
    PCTXT pctxtSave = gReadyQueue.pctxtCurrent;

    ENTER(2, ("RunContext(pctxt=%x)\n", pctxt));

    //
    // Better be a Ready Context structure.
    //
    ASSERT(pctxt->dwSig == SIG_CTXT);
    ASSERT(pctxt->dwfCtxt & CTXTF_READY);

    //
    // Remember previous context and thread.
    //
    gReadyQueue.pctxtCurrent = pctxt;
    gReadyQueue.pkthCurrent = KeGetCurrentThread();

    LOGSCHEDEVENT('RUNC', (ULONG_PTR)pctxt, (ULONG_PTR)
                  (pctxt->pnctxt? pctxt->pnctxt->pnsObj: pctxt->pnsObj),
                  (ULONG_PTR)pctxt->dwfCtxt);

    //
    // As long as the context is ready, execute it.
    //
    for (;;)
    {
        //
        // Transistion context from Ready to Running.
        //
        rc = STATUS_SUCCESS;
        pctxt->dwfCtxt &= ~CTXTF_READY;
        pctxt->dwfCtxt |= CTXTF_RUNNING;

        //
        // Drop scheduler lock and execute context.
        //
        ReleaseMutex(&gReadyQueue.mutCtxtQ);

        //
        // Go for as long as there's work to perform.
        //
        while (!IsStackEmpty(pctxt))
        {
            CHKDEBUGGERREQ();
            pfh = (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd;
            ASSERT(pfh->pfnParse != NULL);

            rc = pfh->pfnParse(pctxt, pfh, rc);
            if ((rc == AMLISTA_PENDING) || (rc == AMLISTA_DONE))
            {
                break;
            }
        }

        //
        // Get the scheduler lock, and clear the running flag.
        //
        AcquireMutex(&gReadyQueue.mutCtxtQ);

        //
        // If we are in nested eval and the nested context is done,
        // we must not clear the running flag because the parent thread
        // is still running.
        //
        if (!(pctxt->dwfCtxt & CTXTF_NEST_EVAL) || (rc != AMLISTA_DONE))
        {
            pctxt->dwfCtxt &= ~CTXTF_RUNNING;
        }

        //
        // If the context is no longer ready, we're done.
        //
        if (!(pctxt->dwfCtxt & CTXTF_READY))
        {
            break;
        }

        //
        // Context became Ready during a pending operation, keep
        // dispatching.
        //
        ASSERT (rc == AMLISTA_PENDING);
    }

    if (rc == AMLISTA_PENDING)
    {
        pctxt->dwfCtxt |= CTXTF_NEED_CALLBACK;
    }
    else if (rc == AMLISTA_DONE)
    {
        if (pctxt->pnctxt == NULL)
        {
            pctxt->dwfCtxt &= ~CTXTF_NEST_EVAL;
        }
        rc = STATUS_SUCCESS;
    }
    else
    {
        ReleaseMutex(&gReadyQueue.mutCtxtQ);
        if ((rc == STATUS_SUCCESS) && (pctxt->pdataCallBack != NULL))
        {
            rc = DupObjData(gpheapGlobal, pctxt->pdataCallBack, &pctxt->Result);
        }

        if (pctxt->dwfCtxt & CTXTF_NEED_CALLBACK)
        {
            AsyncCallBack(pctxt, rc);

            if(pctxt->dwfCtxt & CTXTF_ASYNC_EVAL)
            {    
                rc = AMLISTA_PENDING;
            }
        }

        //
        // Free any owned resources the context may not have freed.
        //
        while (pctxt->plistResources != NULL)
        {
            PRESOURCE pres;

            pres = CONTAINING_RECORD(pctxt->plistResources, RESOURCE, list);
            ASSERT (pres->pctxtOwner == pctxt);

            //
            // Note that it is the responsibility of the corresponding
            // resource release functions (e.g. ReleaseASLMutex) to dequeue
            // the resource from the list and free it.
            //
            switch (pres->dwResType)
            {
                case RESTYPE_MUTEX:
                    ReleaseASLMutex(pctxt, pres->pvResObj);
                    break;

                default:
                    //
                    // We should never come here.  In case we do, we need to
                    // dequeue the unknown resource object and free it.
                    //
                    pres = CONTAINING_RECORD(
                               ListRemoveHead(&pctxt->plistResources),
                               RESOURCE, list);
                    ASSERT(pres == NULL);
                    FREECROBJ(pres);
            }
        }

        FreeContext(pctxt);

        AcquireMutex(&gReadyQueue.mutCtxtQ);
    }

    //
    // Restore previous context and thread.
    //
    gReadyQueue.pkthCurrent = pkthSave;
    gReadyQueue.pctxtCurrent = pctxtSave;

    if ((gReadyQueue.dwfCtxtQ & CQF_FLUSHING) && (gplistCtxtHead == NULL))
    {
        //
        // We just flushed the last pending ctxt, let's go into paused state.
        //
        gReadyQueue.dwfCtxtQ &= ~CQF_FLUSHING;
        gReadyQueue.dwfCtxtQ |= CQF_PAUSED;
        if (gReadyQueue.pfnPauseCallback != NULL)
        {
            //
            // We are in paused state and all pending contexts are flushed,
            // tell core driver that we are done flushing.
            //
            gReadyQueue.pfnPauseCallback(gReadyQueue.PauseCBContext);
            LOGSCHEDEVENT('PACB', (ULONG_PTR)pctxt, (ULONG_PTR)rc, 0);
        }
    }

    LOGSCHEDEVENT('RUN!', (ULONG_PTR)pctxt, (ULONG_PTR)rc, 0);

    EXIT(2, ("RunContext=%x\n", rc));
    return rc;
}       //RunContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\debugger.c ===
/*** debugger.c - Debugger functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/18/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef DEBUGGER

/*** Miscellaneous Constants
 */

#define MAX_CMDLINE_LEN         255

/*** Local function prototypes
 */

LONG LOCAL DbgExecuteCmd(PDBGCMD pDbgCmds, PSZ pszCmd);
BOOLEAN LOCAL IsCommandInAMLIExtension(PSZ pszCmd);

/*** Local data
 */

PSZ pszTokenSeps = " \t\n";

/***LP  Debugger - generic debugger entry point
 *
 *  ENTRY
 *      pDbgCmds -> debugger command table
 *      pszPrompt -> prompt string
 *
 *  EXIT
 *      None
 */

VOID LOCAL Debugger(PDBGCMD pDbgCmds, PSZ pszPrompt)
{
    char szCmdLine[MAX_CMDLINE_LEN + 1];
    char Buffer[MAX_CMDLINE_LEN + 1];
    PSZ psz;

    for (;;)
    {
        ConPrompt(pszPrompt, szCmdLine, sizeof(szCmdLine));

        STRCPY(Buffer, szCmdLine);

        if((psz = STRTOK(szCmdLine, pszTokenSeps)) != NULL)
        {
            if(IsCommandInAMLIExtension(psz))
            {
                char Command[MAX_CMDLINE_LEN + (10 * sizeof(char))] = {0};
                char Name[] = "ACPI";
                
                STRCPY(Command, "!AMLI ");
                STRCAT(Command, Buffer);
                STRCAT(Command, " ; g");
                DbgCommandString(Name, Command);
            }
            else if (DbgExecuteCmd(pDbgCmds, psz) == DBGERR_QUIT)
                break;
        }
    }

}       //Debugger

/***LP  DbgExecuteCmd - execute a debugger command
 *
 *  ENTRY
 *      pDbgCmds -> debugger command table
 *      pszCmd -> command string
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE or DBGERR_QUIT
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DbgExecuteCmd(PDBGCMD pDbgCmds, PSZ pszCmd)
{
    LONG rc = DBGERR_NONE;
    int i;
    ULONG dwNumArgs = 0, dwNonSWArgs = 0;

    for (i = 0; pDbgCmds[i].pszCmd != NULL; i++)
    {
        if (STRCMP(pszCmd, pDbgCmds[i].pszCmd) == 0)
        {
            if (pDbgCmds[i].dwfCmd & CMDF_QUIT)
            {
                rc = DBGERR_QUIT;
            }
            else if ((pDbgCmds[i].pArgTable == NULL) ||
                     ((rc = DbgParseArgs(pDbgCmds[i].pArgTable, &dwNumArgs,
                                         &dwNonSWArgs, pszTokenSeps)) ==
                      ARGERR_NONE))
            {
                if (pDbgCmds[i].pfnCmd != NULL)
                    rc = pDbgCmds[i].pfnCmd(NULL, NULL, dwNumArgs, dwNonSWArgs);
            }
            else
                rc = DBGERR_PARSE_ARGS;

            break;
        }
    }

    if (pDbgCmds[i].pszCmd == NULL)
    {
        DBG_ERROR(("invalid command - %s", pszCmd));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DbgExecuteCmd


BOOLEAN LOCAL IsCommandInAMLIExtension(PSZ pszCmd)
{
    BOOLEAN     bRet = FALSE;
    ULONG       i = 0;
    static PSZ  CommandsInAMLIExtension[] = { "bc",
                                                 "bd",
                                                 "be",
                                                 "bl",
                                                 "bp",
                                                 "cl",
                                                 "dh",
                                                 "dl",
                                                 "dns",
                                                 "do",
                                                 "ds",
                                                 "find",
                                                 "lc",
                                                 "ln",
                                                 "r",
                                                 "set",
                                                 "u"
                                               };
    ULONG       NumCommands = (sizeof(CommandsInAMLIExtension)/sizeof(PSZ));
    
    for(i = 0; i < NumCommands; i++)
    {
        if(STRCMPI(CommandsInAMLIExtension[i], pszCmd) == 0)
        {
            bRet = TRUE;
            break;
        }
    }

    return bRet;
}

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\misc.c ===
/*** misc.c - Miscellaneous functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/18/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  InitializeMutex - initialize mutex
 *
 *  ENTRY
 *      pmut -> MUTEX
 *
 *  EXIT
 *      None
 */

VOID LOCAL InitializeMutex(PMUTEX pmut)
{
    TRACENAME("INITIALIZEMUTEX")

    ENTER(3, ("InitializeMutex(pmut=%x)\n", pmut));

    KeInitializeSpinLock(&pmut->SpinLock);
    pmut->OldIrql = PASSIVE_LEVEL;

    EXIT(3, ("InitializeMutex!\n"));
}       //InitializeMutex

/***LP  AcquireMutex - acquire mutex
 *
 *  ENTRY
 *      pmut -> MUTEX
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 *
 *  NOTE
 *      AcquireMutex can be called at DISPATCH_LEVEL as long as the mutex
 *      is unowned or owned by the same thread.  If the mutex is owned by
 *      some other thread, this thread cannot block if we are at
 *      DISPATCH_LEVEL and therefore would fail to acquire the mutex.
 */

BOOLEAN LOCAL AcquireMutex(PMUTEX pmut)
{
    TRACENAME("ACQUIREMUTEX")
    BOOLEAN rc = TRUE;

    ENTER(3, ("AcquireMutex(pmut=%x)\n", pmut));

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    KeAcquireSpinLock(&pmut->SpinLock, &pmut->OldIrql);

    EXIT(3, ("AcquireMutex=%x\n", rc));
    return rc;
}       //AcquireMutex

/***LP  ReleaseMutex - release mutex
 *
 *  ENTRY
 *      pmut -> MUTEX
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN LOCAL ReleaseMutex(PMUTEX pmut)
{
    TRACENAME("RELEASEMUTEX")
    BOOLEAN rc = TRUE;

    ENTER(3, ("ReleaseMutex(pmut=%x)\n", pmut));

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    KeReleaseSpinLock(&pmut->SpinLock, pmut->OldIrql);

    EXIT(3, ("ReleaseMutex!\n"));
    return rc;
}       //ReleaseMutex

/***LP  FindOpcodeTerm - find the AMLTERM for the given opcode
 *
 *  ENTRY
 *      dwOp - opcode
 *      pOpTable -> opcode table
 *
 *  EXIT-SUCCESS
 *      returns pointer to the opcode's AMLTERM
 *  EXIT-FAILURE
 *      returns NULL
 */

PAMLTERM LOCAL FindOpcodeTerm(ULONG dwOp, POPCODEMAP pOpTable)
{
    TRACENAME("FINDOPCODETERM")
    PAMLTERM pamlterm = NULL;

    ENTER(3, ("FindOpcodeTerm(Op=%x,pOpTable=%x)\n", dwOp, pOpTable));

    while (pOpTable->pamlterm != NULL)
    {
        if (dwOp == pOpTable->dwOpcode)
        {
            pamlterm = pOpTable->pamlterm;
            break;
        }
        else
            pOpTable++;
    }

    EXIT(3, ("FindOpcodeTerm=%x\n", pamlterm));
    return pamlterm;
}       //FindOpcodeTerm

/***LP  GetHackFlags - Get the hack flags from the registry
 *
 *  ENTRY
 *      pdsdt -> AML table
 *
 *  EXIT-SUCCESS
 *      returns the hack flags read
 *  EXIT-FAILURE
 *      returns zero
 */

ULONG LOCAL GetHackFlags(PDSDT pdsdt)
{
    TRACENAME("GETHACKFLAGS")
    ULONG dwfHacks = 0, dwcb;
    static PSZ pszHackFlags = "AMLIHackFlags";

    ENTER(3, ("GetHackFlags(pdsdt=%x)\n", pdsdt));

    if (pdsdt == NULL)
    {
        dwcb = sizeof(dwfHacks);
        OSReadRegValue(pszHackFlags, (HANDLE)NULL, &dwfHacks, &dwcb);
    }
    else
    {
        ULONG dwLen, i;
        PSZ pszRegPath;
        HANDLE hRegKey;
        NTSTATUS status;

        dwLen = STRLEN(ACPI_PARAMETERS_REGISTRY_KEY) +
                ACPI_MAX_TABLE_STRINGS +
                8 + 5;

        if ((pszRegPath = ExAllocatePoolWithTag(PagedPool, dwLen, PRIV_TAG)) != NULL)
        {
            STRCPY(pszRegPath, ACPI_PARAMETERS_REGISTRY_KEY);
            STRCAT(pszRegPath, "\\");
            STRCATN(pszRegPath, (PSZ)&pdsdt->Header.Signature,
                    ACPI_MAX_SIGNATURE);
            STRCAT(pszRegPath, "\\");
            STRCATN(pszRegPath, (PSZ)pdsdt->Header.OEMID, ACPI_MAX_OEM_ID);
            STRCAT(pszRegPath, "\\");
            STRCATN(pszRegPath, (PSZ)pdsdt->Header.OEMTableID, ACPI_MAX_TABLE_ID);
            STRCAT(pszRegPath, "\\");
            ULTOA(pdsdt->Header.OEMRevision, &pszRegPath[STRLEN(pszRegPath)],
                  16);
            dwLen = STRLEN(pszRegPath);
            for (i = 0; i < dwLen; i++)
            {
                if (pszRegPath[i] == ' ')
                {
                    pszRegPath[i] = '_';
                }
            }

            status = OSOpenHandle(pszRegPath, NULL, &hRegKey);
            if (NT_SUCCESS(status))
            {
                dwcb = sizeof(dwfHacks);
                OSReadRegValue(pszHackFlags, hRegKey, &dwfHacks, &dwcb);
            }
            ExFreePool(pszRegPath);
        }
    }

    EXIT(3, ("GetHackFlags=%x\n", dwfHacks));
    return dwfHacks;
}       //GetHackFlags

/***LP  GetBaseObject - If object type is OBJALIAS, follow the chain to the base
 *
 *  ENTRY
 *      pnsObj -> object
 *
 *  EXIT
 *      returns the base object
 */

PNSOBJ LOCAL GetBaseObject(PNSOBJ pnsObj)
{
    TRACENAME("GETBASEOBJECT")

    ENTER(3, ("GetBaseObject(pnsObj=%s)\n", GetObjectPath(pnsObj)));

    while (pnsObj->ObjData.dwDataType == OBJTYPE_OBJALIAS)
    {
        pnsObj = pnsObj->ObjData.pnsAlias;
    }

    EXIT(3, ("GetBaseObject=%s\n", GetObjectPath(pnsObj)));
    return pnsObj;
}       //GetBaseObject

/***LP  GetBaseData - If object type is DATAALIAS, follow the chain to the base
 *
 *  ENTRY
 *      pdataObj -> object
 *
 *  EXIT
 *      returns the base object
 */

POBJDATA LOCAL GetBaseData(POBJDATA pdataObj)
{
    TRACENAME("GETBASEDATA")

    ENTER(3, ("GetBaseData(pdataObj=%x)\n", pdataObj));

    ASSERT(pdataObj != NULL);
    for (;;)
    {
        if (pdataObj->dwDataType == OBJTYPE_OBJALIAS)
        {
            pdataObj = &pdataObj->pnsAlias->ObjData;
        }
        else if (pdataObj->dwDataType == OBJTYPE_DATAALIAS)
        {
            pdataObj = pdataObj->pdataAlias;
        }
        else
        {
            break;
        }
    }

    EXIT(3, ("GetBaseData=%x\n", pdataObj));
    return pdataObj;
}       //GetBaseData

/***LP  NewObjOwner - create a new object owner
 *
 *  ENTRY
 *      pheap -> HEAP
 *      ppowner -> to hold new owner pointer
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL NewObjOwner(PHEAP pheap, POBJOWNER *ppowner)
{
    TRACENAME("NEWOBJOWNER")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("NewObjOwner(pheap=%x,ppowner=%x)\n", pheap, ppowner));

    if ((*ppowner = NEWOOOBJ(pheap, sizeof(OBJOWNER))) == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                         ("NewObjOwner: failed to allocate object owner"));
    }
    else
    {

        MEMZERO(*ppowner, sizeof(OBJOWNER));
        (*ppowner)->dwSig = SIG_OBJOWNER;

        AcquireMutex(&gmutOwnerList);
        ListInsertTail(&(*ppowner)->list, &gplistObjOwners);
        ReleaseMutex(&gmutOwnerList);

    }

    EXIT(3, ("NewObjOwner=%x (powern=%x)\n", rc, *ppowner));
    return rc;
}       //NewObjOwner

/***LP  FreeObjOwner - free object owner
 *
 *  ENTRY
 *      powner -> OBJOWNER
 *      fUnload - if TRUE, the caller is unloading a DDB
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeObjOwner(POBJOWNER powner, BOOLEAN fUnload)
{
    TRACENAME("FREEOBJOWNER")
    KIRQL   oldIrql;
    PNSOBJ  pns;
    PNSOBJ  pnsNext       = NULL;
    PNSOBJ  pnsPrev       = NULL;
    PNSOBJ  pnsDeviceList = NULL;
    PNSOBJ  pnsChild      = NULL;

    ENTER(3, ("FreeObjOwner(powner=%x,fUnload=%x)\n", powner,fUnload));

    ASSERT(powner != NULL);

    AcquireMutex(&gmutOwnerList);
    ListRemoveEntry(&powner->list, &gplistObjOwners);
    ReleaseMutex(&gmutOwnerList);

    if (fUnload && (ghDestroyObj.pfnHandler != NULL))
    {

        //
        // First we have to tell the driver that we are about to
        // do walk the owner list so that we can seek and destroy
        // the objects
        //
        ((PFNDOBJ)ghDestroyObj.pfnHandler)(DESTROYOBJ_START, &oldIrql, 0);

        //
        // First pass, mark the objects defunc'd.
        //
        for (pns = powner->pnsObjList; pns != NULL; pns = pns->pnsOwnedNext) {

            pns->ObjData.dwfData |= DATAF_NSOBJ_DEFUNC;

        }

        //
        // Second pass, find the device in the list to be removed
        //
        for (pns = powner->pnsObjList; pns != NULL; pns = pnsNext) {

            pnsNext = pns->pnsOwnedNext;
            if (pns->ObjData.dwDataType == OBJTYPE_DEVICE ||
                pns->ObjData.dwDataType == OBJTYPE_POWERRES ||
                pns->ObjData.dwDataType == OBJTYPE_THERMALZONE ||
                pns->ObjData.dwDataType == OBJTYPE_PROCESSOR) {

                if (pnsPrev) {

                    pnsPrev->pnsOwnedNext = pns->pnsOwnedNext;

                } else {

                    powner->pnsObjList = pns->pnsOwnedNext;

                }
                pns->pnsOwnedNext = pnsDeviceList;
                pnsDeviceList = pns;

                //
                // Detach the device from its parent
                //
                if (pns->pnsParent != NULL) {

                    ListRemoveEntry(
                        &pns->list,
                        (PPLIST)&pns->pnsParent->pnsFirstChild
                        );
                    pns->pnsParent = NULL;

                }

                //
                // Make sure that all of the device's children have been
                // marked as being unloaded
                //
                if (pns->pnsFirstChild) {

                    pnsChild = pns->pnsFirstChild;
                    do {

                        if (!(pnsChild->ObjData.dwfData & DATAF_NSOBJ_DEFUNC) ) {

                            ((PFNDOBJ)ghDestroyObj.pfnHandler)(
                                DESTROYOBJ_CHILD_NOT_FREED,
                                pnsChild,
                                0
                                );

                        }
                        pnsChild = (PNSOBJ) pnsChild->list.plistNext;

                    } while (pnsChild != pns->pnsFirstChild);

                }
                //
                // Not that if we don't put this continue in here, then
                // it becomes possible for pnsPrev to point to a device,
                // which would corrupt the list
                continue;

            } else if (pns->pnsParent == NULL ||
                !(pns->pnsParent->ObjData.dwfData & DATAF_NSOBJ_DEFUNC)) {

                ((PFNDOBJ)ghDestroyObj.pfnHandler)(
                    DESTROYOBJ_BOGUS_PARENT,
                    pns,
                    0
                    );

            }
            pnsPrev = pns;

        }

        //
        // Chain the two lists back together
        //
        if (powner->pnsObjList == NULL) {

            powner->pnsObjList = pnsDeviceList;

        } else {

            //
            // Find a pointer to the last element in the list
            //
            pns = powner->pnsObjList;

            while ( pns->pnsOwnedNext != NULL )
            {

                //
                // Next element in the list
                //
                pns = pns->pnsOwnedNext;

            } 

            pns->pnsOwnedNext = pnsDeviceList;
        }

        //        //
        // Third pass pass, do callback for each device that is going away
        //
        for (pns = pnsDeviceList; pns != NULL; pns = pnsNext) {

            //
            // Remember what the next point is because we might nuke
            // the current object in the callback (if there is no
            // device extension associated with it
            //
            pnsNext = pns->pnsOwnedNext;

            //
            // Issue the callback. This might nuke the pnsObject
            //
            ((PFNDOBJ)ghDestroyObj.pfnHandler)(
                DESTROYOBJ_REMOVE_OBJECT,
                pns,
                pns->ObjData.dwDataType
                );

        }

        //
        // We end by tell the ACPI driver that we have finished looking
        // at the list
        //
        ((PFNDOBJ)ghDestroyObj.pfnHandler)(DESTROYOBJ_END, &oldIrql, 0 );

    }
    else
    {
        for (pns = powner->pnsObjList; pns != NULL; pns = pnsNext)
        {
            pnsNext = pns->pnsOwnedNext;
            FreeNameSpaceObjects(pns);
        }
    }
    powner->pnsObjList = NULL;
    FREEOOOBJ(powner);

    EXIT(3, ("FreeObjOwner!\n"));
}       //FreeObjOwner

/***LP  InsertOwnerObjList - Insert the new object into the owner's object list
 *
 *  ENTRY
 *      powner -> owner
 *      pnsObj -> new object
 *
 *  EXIT
 *      None
 */

VOID LOCAL InsertOwnerObjList(POBJOWNER powner, PNSOBJ pnsObj)
{
    TRACENAME("INSERTOWNEROBJLIST")

    ENTER(3, ("InsertOwnerObjList(powner=%x,pnsObj=%x)\n",
              powner, pnsObj));

    pnsObj->hOwner = (HANDLE)powner;
    if (powner != NULL)
    {
        pnsObj->pnsOwnedNext = powner->pnsObjList;
        powner->pnsObjList = pnsObj;
    }

    EXIT(3, ("InsertOwnerObjList!\n"));
}       //InsertOwnerObjList

/***LP  FreeDataBuffs - Free any buffers attached to OBJDATA array
 *
 *  ENTRY
 *      adata -> OBJDATA array
 *      icData - number of data object in array
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeDataBuffs(POBJDATA adata, int icData)
{
    TRACENAME("FREEDATABUFFS")
    int i;

    ENTER(3, ("FreeDataBuffs(adata=%x,icData=%d)\n", adata, icData));

    for (i = 0; i < icData; ++i)
    {
        if (adata[i].pbDataBuff != NULL)
        {
            if (adata[i].dwfData & DATAF_BUFF_ALIAS)
            {
                //
                // decrement the base object's reference count.
                //
                adata[i].pdataBase->dwRefCount--;
            }
            else
            {
                //
                // We cannot free a base object buffer that has aliases on it.
                //
                ASSERT(adata[i].dwRefCount == 0);
                if (adata[i].dwDataType == OBJTYPE_PKGDATA)
                {
                    PPACKAGEOBJ ppkg = (PPACKAGEOBJ)adata[i].pbDataBuff;

                    FreeDataBuffs(ppkg->adata, ppkg->dwcElements);
                }
                ENTER(4, ("FreeData(i=%d,Buff=%x,Flags=%x)\n",
                          i, adata[i].pbDataBuff, adata[i].dwfData));
                FREEOBJDATA(&adata[i]);
                EXIT(4, ("FreeData!\n"));
            }
        }

        MEMZERO(&adata[i], sizeof(OBJDATA));
    }

    EXIT(3, ("FreeDataBuff!\n"));
}       //FreeDataBuffs

/***LP  PutIntObjData - put integer data into data object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> data object
 *      dwData -> data to be written
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PutIntObjData(PCTXT pctxt, POBJDATA pdataObj, ULONG dwData)
{
    TRACENAME("PUTINTOBJDATA")
    NTSTATUS rc = STATUS_SUCCESS;
    OBJDATA data;

    ENTER(3, ("PutIntObjData(pctxt=%x,pdataObj=%x,dwData=%x)\n",
              pctxt, pdataObj, dwData));

    MEMZERO(&data, sizeof(OBJDATA));
    data.dwDataType = OBJTYPE_INTDATA;
    data.uipDataValue = (ULONG_PTR)dwData;

    rc = WriteObject(pctxt, pdataObj, &data);

    EXIT(3, ("PutIntObjData=%x\n", rc));
    return rc;
}       //PutIntObjData

/***LP  GetFieldUnitRegionObj - Get the OperationRegion object of FieldUnit
 *
 *  ENTRY
 *      pfu -> FIELDUNITOBJ
 *      ppns -> to hold OperationRegion object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL GetFieldUnitRegionObj(PFIELDUNITOBJ pfu, PPNSOBJ ppns)
{
    TRACENAME("GETFIELDUNITREGIONOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pns;

    ENTER(3, ("GetFieldUnitRegionObj(pfu=%x,ppns=%x)\n", pfu, ppns));

    pns = pfu->pnsFieldParent;
    switch (pns->ObjData.dwDataType)
    {
        case OBJTYPE_BANKFIELD:
            *ppns = ((PBANKFIELDOBJ)pns->ObjData.pbDataBuff)->pnsBase;
            break;

        case OBJTYPE_FIELD:
            *ppns = ((PFIELDOBJ)pns->ObjData.pbDataBuff)->pnsBase;
            break;

        case OBJTYPE_INDEXFIELD:
            pns = ((PINDEXFIELDOBJ)pns->ObjData.pbDataBuff)->pnsData;
            ASSERT(pns->ObjData.dwDataType == OBJTYPE_FIELDUNIT);
            rc = GetFieldUnitRegionObj((PFIELDUNITOBJ)pns->ObjData.pbDataBuff,
                                       ppns);
            break;

        default:
            rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                             ("GetFieldUnitRegionObj: unknown field unit parent object type - %x",
                              (*ppns)->ObjData.dwDataType));
    }

    if ((*ppns != NULL) && ((*ppns)->ObjData.dwDataType != OBJTYPE_OPREGION))
    {
        rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                         ("GetFieldUnitRegionObj: base object of field unit is not OperationRegion (BaseObj=%s,Type=%x)",
                          GetObjectPath(*ppns), (*ppns)->ObjData.dwDataType));
    }

    EXIT(3, ("GetFieldUnitRegionObj=%x (RegionObj=%x:%s)\n",
             rc, *ppns, GetObjectPath(*ppns)));
    return rc;
}       //GetFieldUnitRegionObj

/***LP  CopyObjData - Copy object data
 *
 *  ENTRY
 *      pdataDst -> target object
 *      pdataSrc -> source object
 *
 *  EXIT
 *      None
 */

VOID LOCAL CopyObjData(POBJDATA pdataDst, POBJDATA pdataSrc)
{
    TRACENAME("COPYOBJDATA")

    ENTER(3, ("CopyObjData(Dest=%x,Src=%x)\n", pdataDst, pdataSrc));

    ASSERT(pdataDst != NULL);
    ASSERT(pdataSrc != NULL);
    if (pdataDst != pdataSrc)
    {
        MEMCPY(pdataDst, pdataSrc, sizeof(OBJDATA));
        if (pdataSrc->dwfData & DATAF_BUFF_ALIAS)
        {
            //
            // Source is an alias, so we need to increment the base object
            // reference count.
            //
            ASSERT(pdataSrc->pdataBase != NULL);
            pdataSrc->pdataBase->dwRefCount++;
        }
        else if (pdataSrc->pbDataBuff != NULL)
        {
            //
            // Source is a base object with buffer, increment its reference
            // count.
            //
            pdataSrc->dwRefCount++;
            pdataDst->dwfData |= DATAF_BUFF_ALIAS;
            pdataDst->pdataBase = pdataSrc;
        }
    }

    EXIT(3, ("CopyObjData!\n"));
}       //CopyObjData

/***LP  MoveObjData - Move object data
 *
 *  ENTRY
 *      pdataDst -> target object
 *      pdataSrc -> source object
 *
 *  EXIT
 *      None
 */

VOID LOCAL MoveObjData(POBJDATA pdataDst, POBJDATA pdataSrc)
{
    TRACENAME("MOVEOBJDATA")

    ENTER(3, ("MoveObjData(Dest=%x,Src=%x)\n", pdataDst, pdataSrc));

    ASSERT(pdataDst != NULL);
    ASSERT(pdataSrc != NULL);
    if (pdataDst != pdataSrc)
    {
        //
        // We can only move an alias object or a base object with zero
        // reference count or a base object with no data buffer.
        //
        ASSERT((pdataSrc->dwfData & DATAF_BUFF_ALIAS) ||
               (pdataSrc->pbDataBuff == NULL) ||
               (pdataSrc->dwRefCount == 0));

        MEMCPY(pdataDst, pdataSrc, sizeof(OBJDATA));
        MEMZERO(pdataSrc, sizeof(OBJDATA));
    }

    EXIT(3, ("MoveObjData!\n"));
}       //MoveObjData

/***LP  DupObjData - Duplicate object data
 *
 *  ENTRY
 *      pheap -> HEAP
 *      pdataDst -> target object
 *      pdataSrc -> source object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL DupObjData(PHEAP pheap, POBJDATA pdataDst, POBJDATA pdataSrc)
{
    TRACENAME("DUPOBJDATA")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("DupObjData(pheap=%x,Dest=%x,Src=%x)\n",
              pheap, pdataDst, pdataSrc));

    ASSERT(pdataDst != NULL);
    ASSERT(pdataSrc != NULL);
    if (pdataDst != pdataSrc)
    {
        MEMCPY(pdataDst, pdataSrc, sizeof(OBJDATA));
        if (pdataSrc->pbDataBuff != NULL)
        {
            if ((pdataDst->pbDataBuff = NEWOBJDATA(pheap, pdataSrc)) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("DupObjData: failed to allocate destination buffer"));
            }
            else if (pdataSrc->dwDataType == OBJTYPE_PKGDATA)
            {
                PPACKAGEOBJ ppkgSrc = (PPACKAGEOBJ)pdataSrc->pbDataBuff,
                            ppkgDst = (PPACKAGEOBJ)pdataDst->pbDataBuff;
                int i;

                ppkgDst->dwcElements = ppkgSrc->dwcElements;
                for (i = 0; i < (int)ppkgSrc->dwcElements; ++i)
                {
                    if ((rc = DupObjData(pheap, &ppkgDst->adata[i],
                                         &ppkgSrc->adata[i])) != STATUS_SUCCESS)
                    {
                        break;
                    }
                }
            }
            else
            {
                MEMCPY(pdataDst->pbDataBuff, pdataSrc->pbDataBuff,
                       pdataSrc->dwDataLen);
            }
            pdataDst->dwfData &= ~DATAF_BUFF_ALIAS;
            pdataDst->dwRefCount = 0;
        }
    }

    EXIT(3, ("DupObjData=%x\n", rc));
    return rc;
}       //DupObjData

/***LP  CopyObjBuffer - Copy object data to a buffer
 *
 *  ENTRY
 *      pbBuff -> buffer
 *      dwLen - buffer size
 *      pdata -> object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CopyObjBuffer(PUCHAR pbBuff, ULONG dwLen, POBJDATA pdata)
{
    TRACENAME("COPYOBJBUFFER")
    NTSTATUS rc = STATUS_SUCCESS;
    PUCHAR pb = NULL;
    ULONG dwcb = 0;

    ENTER(3, ("CopyObjBuffer(pbBuff=%x,Len=%d,pdata=%x)\n",
              pbBuff, dwLen, pdata));

    switch (pdata->dwDataType)
    {
        case OBJTYPE_INTDATA:
            pb = (PUCHAR)&pdata->uipDataValue;
            dwcb = sizeof(ULONG);
            break;

        case OBJTYPE_STRDATA:
            pb = pdata->pbDataBuff;
            dwcb = pdata->dwDataLen - 1;
            break;

        case OBJTYPE_BUFFDATA:
            pb = pdata->pbDataBuff;
            dwcb = pdata->dwDataLen;
            break;

        default:
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("CopyObjBuffer: invalid source object type (type=%s)",
                              GetObjectTypeName(pdata->dwDataType)));
    }

    if ((rc == STATUS_SUCCESS) && (pbBuff != pb))
    {
        MEMZERO(pbBuff, dwLen);
        dwcb = MIN(dwLen, dwcb);
        MEMCPY(pbBuff, pb, dwcb);
    }

    EXIT(3, ("CopyObjBuffer=%x (CopyLen=%d)\n", rc, dwcb));
    return rc;
}       //CopyObjBuffer

/***LP  AcquireGL - acquire global lock
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL AcquireGL(PCTXT pctxt)
{
    TRACENAME("ACQUIREGL")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("AcquireGL(pctxt=%x)\n", pctxt));

    if (ghGlobalLock.pfnHandler != NULL)
    {
        ASSERT(!(pctxt->dwfCtxt & CTXTF_READY));
        rc = ((PFNGL)ghGlobalLock.pfnHandler)(EVTYPE_ACQREL_GLOBALLOCK,
                                              GLOBALLOCK_ACQUIRE,
                                              ghGlobalLock.uipParam,
                                              RestartCtxtCallback,
                                              &pctxt->CtxtData);
        if (rc == STATUS_PENDING)
        {
            rc = AMLISTA_PENDING;
        }
        else if (rc != STATUS_SUCCESS)
        {
            rc = AMLI_LOGERR(AMLIERR_ACQUIREGL_FAILED,
                             ("AcquireGL: failed to acquire global lock"));
        }
    }

    EXIT(3, ("AcquireGL=%x\n", rc));
    return rc;
}       //AcquireGL

/***LP  ReleaseGL - release global lock if acquired
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReleaseGL(PCTXT pctxt)
{
    TRACENAME("RELEASEGL")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("ReleaseGL(pctxt=%x)\n", pctxt));

    if (ghGlobalLock.pfnHandler != NULL)
    {
        rc = ((PFNGL)ghGlobalLock.pfnHandler)(EVTYPE_ACQREL_GLOBALLOCK,
                                              GLOBALLOCK_RELEASE,
                                              ghGlobalLock.uipParam, NULL,
                                              &pctxt->CtxtData);
    }

    EXIT(3, ("ReleaseGL=%x\n", rc));
    return rc;
}       //ReleaseGL

/***LP  MapUnmapPhysMem - Map/Unmap physical memory
 *
 *  ENTRY
 *      pctxt -> CTXT (can be NULL if cannot handle STATUS_PENDING)
 *      uipAddr - physical address
 *      dwLen - length of memory range
 *      puipMappedAddr -> to hold memory address mapped (NULL if unmap)
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL MapUnmapPhysMem(PCTXT pctxt, ULONG_PTR uipAddr, ULONG dwLen,
                               PULONG_PTR puipMappedAddr)
{
    TRACENAME("MAPUNMAPPHYSMEM")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("MapUnmapPhysMem(pctxt=%x,Addr=%x,Len=%d,pMappedAddr=%x)\n",
              pctxt, uipAddr, dwLen, puipMappedAddr));

    if(dwLen)
    {
        if (KeGetCurrentIrql() == PASSIVE_LEVEL)
        {
            if (puipMappedAddr != NULL)
            {
                *puipMappedAddr = MapPhysMem(uipAddr, dwLen);
            }
            else
            {
                MmUnmapIoSpace((PVOID)uipAddr, dwLen);
            }
        }
        else if (pctxt != NULL)
        {
            PPASSIVEHOOK pph;

            if ((pph = NEWPHOBJ(sizeof(PASSIVEHOOK))) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("MapUnmapPhysMem: failed to allocate passive hook"));
            }
            else
            {
                pph->pctxt = pctxt;
                pph->uipAddr = uipAddr;
                pph->dwLen = dwLen;
                pph->puipMappedAddr = puipMappedAddr;
                ExInitializeWorkItem(&pph->WorkItem, MapUnmapCallBack, pph);
                OSQueueWorkItem(&pph->WorkItem);

                rc = AMLISTA_PENDING;
            }
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_FATAL,
                             ("MapUnmapPhysMem: IRQL is not at PASSIVE (IRQL=%x)",
                              KeGetCurrentIrql()));
        }
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_DATA,
                 ("MapUnmapPhysMem: Trying to create 0 length memory opregion"));

    }

    EXIT(3, ("MapUnmapPhysMem=%x (MappedAddr=%x)\n",
             rc, puipMappedAddr? *puipMappedAddr: 0));
    return rc;
}       //MapUnmapPhysMem

/***LP  MapPhysMem - Map physical memory
 *
 *  ENTRY
 *      uipAddr - physical memory address
 *      dwLen - length of memory block
 *
 *  EXIT
 *      returns mapped address
 */

ULONG_PTR LOCAL MapPhysMem(ULONG_PTR uipAddr, ULONG dwLen)
{
    TRACENAME("MAPPHYSMEM")
    ULONG_PTR uipMappedAddr = 0;
    PHYSICAL_ADDRESS phyaddr = {0, 0}, XlatedAddr;
    ULONG dwAddrSpace;

    ENTER(3, ("MapPhysMem(Addr=%x,Len=%d)\n", uipAddr, dwLen));

    phyaddr.HighPart = 0;
    phyaddr.QuadPart = uipAddr;
    dwAddrSpace = 0;
    if (HalTranslateBusAddress(Internal, 0, phyaddr, &dwAddrSpace, &XlatedAddr))
    {
        uipMappedAddr = (ULONG_PTR)MmMapIoSpace(XlatedAddr, dwLen, MmNonCached);
    }

    EXIT(3, ("MapPhysMem=%x", uipMappedAddr));
    return uipMappedAddr;
}       //MapPhysMem

/***LP  MapUnmapCallBack - Map/Unmap physical memory callback
 *
 *  ENTRY
 *      pph -> PASSIVEHOOK
 *
 *  EXIT
 *      None
 */

VOID MapUnmapCallBack(PPASSIVEHOOK pph)
{
    TRACENAME("MAPUNMAPCALLBACK")

    ENTER(3, ("MapUnmapCallBack(pph=%x,pctxt=%x,Addr=%x,Len=%d,pdwMappedAddr=%x)\n",
              pph, pph->pctxt, pph->uipAddr, pph->dwLen, pph->puipMappedAddr));

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    if (pph->puipMappedAddr != NULL)
    {
        *pph->puipMappedAddr = MapPhysMem(pph->uipAddr, pph->dwLen);
    }
    else
    {
        MmUnmapIoSpace((PVOID)pph->uipAddr, pph->dwLen);
    }

    RestartContext(pph->pctxt,
                   (BOOLEAN)((pph->pctxt->dwfCtxt & CTXTF_ASYNC_EVAL) == 0));

    FREEPHOBJ(pph);

    EXIT(3, ("MapUnmapCallBack!\n"));
}       //MapUnmapCallBack

/***LP  MatchObjType - match object type
 *
 *  ENTRY
 *      dwObjType - object type
 *      dwExpected - expected type
 *
 *  EXIT-SUCCESS
 *      returns TRUE - type matched
 *  EXIT-FAILURE
 *      returns FALSE - type mismatch
 */

BOOLEAN LOCAL MatchObjType(ULONG dwObjType, ULONG dwExpectedType)
{
    TRACENAME("MATCHOBJTYPE")
    BOOLEAN rc = FALSE;

    ENTER(3, ("MatchObjType(ObjType=%s,Expected=%s)\n",
              GetObjectTypeName(dwObjType), GetObjectTypeName(dwExpectedType)));
    //
    // OBJTYPE_BUFFFIELD is essentially OBJTYPE_INTDATA, so we'll let
    // it pass the check.
    //
    if ((dwObjType == OBJTYPE_BUFFFIELD) &&
        (dwExpectedType == OBJTYPE_INTDATA))
    {
        rc = TRUE;
    }
    else if ((dwExpectedType == OBJTYPE_UNKNOWN) ||
             (dwObjType == OBJTYPE_UNKNOWN) ||
             (dwObjType == dwExpectedType))
    {
        rc = TRUE;
    }
    else
    {
        if ((dwObjType == OBJTYPE_INTDATA) ||
            (dwObjType == OBJTYPE_STRDATA) ||
            (dwObjType == OBJTYPE_BUFFDATA) ||
            (dwObjType == OBJTYPE_PKGDATA))
        {
            dwObjType = OBJTYPE_DATA;
        }
        else if ((dwObjType == OBJTYPE_FIELDUNIT) ||
                 (dwObjType == OBJTYPE_BUFFFIELD))
        {
            dwObjType = OBJTYPE_DATAFIELD;
        }

        if ((dwObjType == dwExpectedType) ||
            (dwExpectedType == OBJTYPE_DATAOBJ) &&
            ((dwObjType == OBJTYPE_DATA) || (dwObjType == OBJTYPE_DATAFIELD)))
        {
            rc = TRUE;
        }
    }

    EXIT(3, ("MatchObjType=%x\n", rc));
    return rc;
}       //MatchObjType

/***LP  ValidateTarget - Validate target object type
 *
 *  ENTRY
 *      pdataTarget -> target object data
 *      dwExpectedType - expected target object type
 *      ppdata -> to hold base target object data pointer
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ValidateTarget(POBJDATA pdataTarget, ULONG dwExpectedType,
                              POBJDATA *ppdata)
{
    TRACENAME("VALIDATETARGET")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("ValidateTarget(pdataTarget=%x,ExpectedType=%s,ppdata=%x)\n",
              pdataTarget, GetObjectTypeName(dwExpectedType), ppdata));

    ASSERT(pdataTarget != NULL);
    if (pdataTarget->dwDataType == OBJTYPE_OBJALIAS)
    {
        *ppdata = &pdataTarget->pnsAlias->ObjData;
    }
    else if (pdataTarget->dwDataType == OBJTYPE_DATAALIAS)
    {
        *ppdata = pdataTarget->pdataAlias;
    }
    else if ((pdataTarget->dwDataType == OBJTYPE_UNKNOWN) ||
             (pdataTarget->dwDataType == OBJTYPE_BUFFFIELD) ||
             (pdataTarget->dwDataType == OBJTYPE_DEBUG))
    {
        *ppdata = pdataTarget;
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_TARGETTYPE,
                         ("ValidateTarget: target is not a supername (Type=%s)",
                          GetObjectTypeName(pdataTarget->dwDataType)));
    }

    if ((rc == STATUS_SUCCESS) &&
        (pdataTarget->dwDataType == OBJTYPE_OBJALIAS) &&
        !MatchObjType((*ppdata)->dwDataType, dwExpectedType))
    {
        rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_TARGETTYPE,
                         ("ValidateTarget: unexpected target type (Type=%s,Expected=%s)",
                          GetObjectTypeName((*ppdata)->dwDataType),
                          GetObjectTypeName(dwExpectedType)));
    }

    if ((rc == STATUS_SUCCESS) &&
        (pdataTarget->dwDataType != OBJTYPE_OBJALIAS) &&
        MatchObjType((*ppdata)->dwDataType, OBJTYPE_DATA))
    {
        FreeDataBuffs(*ppdata, 1);
    }

    EXIT(3, ("ValidateTarget=%x (pdataTarget=%x)\n", rc, *ppdata));
    return rc;
}       //ValidateTarget

/***LP  ValidateArgTypes - Validate argument types
 *
 *  ENTRY
 *      pArgs -> argument array
 *      pszExpectedTypes -> expected argument types string
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ValidateArgTypes(POBJDATA pArgs, PSZ pszExpectedTypes)
{
    TRACENAME("VALIDATEARGTYPES")
    NTSTATUS rc = STATUS_SUCCESS;
    int icArgs, i;

    ENTER(3, ("ValidateArgTypes(pArgs=%x,ExpectedTypes=%s)\n",
              pArgs, pszExpectedTypes));

    ASSERT(pszExpectedTypes != NULL);

    icArgs = STRLEN(pszExpectedTypes);
    for (i = 0; (rc == STATUS_SUCCESS) && (i < icArgs); ++i)
    {
        switch (pszExpectedTypes[i])
        {
            case ARGOBJ_UNKNOWN:
                break;

            case ARGOBJ_INTDATA:
                if (pArgs[i].dwDataType != OBJTYPE_INTDATA)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type Integer (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_STRDATA:
                if (pArgs[i].dwDataType != OBJTYPE_STRDATA)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type String (Type-%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_BUFFDATA:
                if (pArgs[i].dwDataType != OBJTYPE_BUFFDATA)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type Buffer (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_PKGDATA:
                if (pArgs[i].dwDataType != OBJTYPE_PKGDATA)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type Package (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_FIELDUNIT:
                if (pArgs[i].dwDataType != OBJTYPE_FIELDUNIT)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type FieldUnit (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_OBJALIAS:
                if (pArgs[i].dwDataType != OBJTYPE_OBJALIAS)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type ObjAlias (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_DATAALIAS:
                if (pArgs[i].dwDataType != OBJTYPE_DATAALIAS)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type DataAlias (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_BASICDATA:
                if ((pArgs[i].dwDataType != OBJTYPE_INTDATA) &&
                    (pArgs[i].dwDataType != OBJTYPE_STRDATA) &&
                    (pArgs[i].dwDataType != OBJTYPE_BUFFDATA))
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type int/str/buff (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_COMPLEXDATA:
                if ((pArgs[i].dwDataType != OBJTYPE_BUFFDATA) &&
                    (pArgs[i].dwDataType != OBJTYPE_PKGDATA))
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type buff/pkg (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            case ARGOBJ_REFERENCE:
                if ((pArgs[i].dwDataType != OBJTYPE_OBJALIAS) &&
                    (pArgs[i].dwDataType != OBJTYPE_DATAALIAS) &&
                    (pArgs[i].dwDataType != OBJTYPE_BUFFFIELD))
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                     ("ValidateArgTypes: expected Arg%d to be type reference (Type=%s)",
                                      i,
                                      GetObjectTypeName(pArgs[i].dwDataType)));
                }
                break;

            default:
                rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                                 ("ValidateArgTypes: internal error (invalid type - %c)",
                                  pszExpectedTypes[i]));
        }
    }

    EXIT(3, ("ValidateArgTypes=%x\n", rc));
    return rc;
}       //ValidateArgTypes

/***LP  RegEventHandler - register event handler
 *
 *  ENTRY
 *      peh -> EVHANDLE
 *      pfnHandler -> handler entry point
 *      uipParam - parameter pass to handler
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL RegEventHandler(PEVHANDLE peh, PFNHND pfnHandler,
                               ULONG_PTR uipParam)
{
    TRACENAME("REGEVENTHANDLER")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("RegEventHandler(peh=%x,pfnHandler=%x,Param=%x)\n",
              peh, pfnHandler, uipParam));

    if ((peh->pfnHandler != NULL) && (pfnHandler != NULL))
    {
        rc = AMLI_LOGERR(AMLIERR_HANDLER_EXIST,
                         ("RegEventHandler: event handler already exist"));
    }
    else
    {
        peh->pfnHandler = pfnHandler;
        peh->uipParam = uipParam;
    }

    EXIT(3, ("RegEventHandler=%x\n", rc));
    return rc;
}       //RegEventHandler

/***LP  RegOpcodeHandler - register an opcode callback handler
 *
 *  The callback handler will be called after the opcode finishes its
 *  execution.  If an opcode has a variable list, the opcode handler
 *  will be called at the point of processing the closing brace.
 *
 *  ENTRY
 *      dwOpcode - opcode event to hook
 *      pfnHandler -> handler entry point
 *      uipParam - parameter pass to handler
 *      dwfOpcode - opcode flags
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL RegOpcodeHandler(ULONG dwOpcode, PFNOH pfnHandler,
                                ULONG_PTR uipParam, ULONG dwfOpcode)
{
    TRACENAME("REGOPCODEHANDLER")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLTERM pamlterm;

    ENTER(3, ("RegOpcodeHandler(Opcode=%x,pfnHandler=%x,Param=%x,dwfOpcode=%x)\n",
              dwOpcode, pfnHandler, uipParam, dwfOpcode));

    if ((dwOpcode & 0xff) == OP_EXT_PREFIX)
        pamlterm = FindOpcodeTerm(dwOpcode >> 8, ExOpcodeTable);
    else
        pamlterm = OpcodeTable[dwOpcode];

    if (pamlterm == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_REGHANDLER_FAILED,
                         ("RegOpcodeHandler: either invalid opcode or "
                          "opcode does not allow callback"));
    }
    else if ((pamlterm->pfnCallBack != NULL) && (pfnHandler != NULL))
    {
        rc = AMLI_LOGERR(AMLIERR_HANDLER_EXIST,
                         ("RegOpcodeHandler: opcode or opcode class already "
                          "has a handler"));
    }
    else
    {
        pamlterm->pfnCallBack = pfnHandler;
        pamlterm->dwCBData = (ULONG)uipParam;
        pamlterm->dwfOpcode |= dwfOpcode;
    }

    EXIT(3, ("RegOpcodeHandler=%x\n", rc));
    return rc;
}       //RegOpcodeHandler

/***LP  RegRSAccess - register region space cook/raw access handler
 *
 *  ENTRY
 *      dwRegionSpace - specifying the region space to handle
 *      pfnHandler -> handler entry point
 *      uipParam - parameter pass to handler
 *      fRaw - TRUE if registering raw access handler
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL RegRSAccess(ULONG dwRegionSpace, PFNHND pfnHandler,
                           ULONG_PTR uipParam, BOOLEAN fRaw)
{
    TRACENAME("REGRSACCESS")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("RegRSAccess(RegionSpace=%x,pfnHandler=%x,Param=%x,fRaw=%x)\n",
              dwRegionSpace, pfnHandler, uipParam, fRaw));

    if ((dwRegionSpace != REGSPACE_MEM) && (dwRegionSpace != REGSPACE_IO))
    {
        PRSACCESS prsa;

        if ((prsa = FindRSAccess(dwRegionSpace)) == NULL)
        {
            if ((prsa = NEWRSOBJ(sizeof(RSACCESS))) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("RegRSAccess: failed to allocate handler structure"));
            }
            else
            {
                MEMZERO(prsa, sizeof(RSACCESS));
                prsa->dwRegionSpace = dwRegionSpace;
                prsa->prsaNext = gpRSAccessHead;
                gpRSAccessHead = prsa;
            }
        }

        if (rc == STATUS_SUCCESS)
        {
            if (fRaw)
            {
                if ((prsa->pfnRawAccess != NULL) && (pfnHandler != NULL))
                {
                    rc = AMLI_LOGERR(AMLIERR_HANDLER_EXIST,
                                     ("RegRSAccess: RawAccess for RegionSpace %x "
                                      "already have a handler", dwRegionSpace));
                }
                else
                {
                    prsa->pfnRawAccess = (PFNRA)pfnHandler;
                    prsa->uipRawParam = uipParam;
                }
            }
            else
            {
                if ((prsa->pfnCookAccess != NULL) && (pfnHandler != NULL))
                {
                    rc = AMLI_LOGERR(AMLIERR_HANDLER_EXIST,
                                     ("RegRSAccess: CookAccess for RegionSpace %x "
                                      "already have a handler", dwRegionSpace));
                }
                else
                {
                    prsa->pfnCookAccess = (PFNCA)pfnHandler;
                    prsa->uipCookParam = uipParam;
                }
            }
        }
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_REGIONSPACE,
                         ("RegRSAccess: illegal region space - %x",
                          dwRegionSpace));
    }

    EXIT(3, ("RegRSAccess=%x\n", rc));
    return rc;
}       //RegRSAccess

/***LP  FindRSAccess - Find RSACCESS structure with a given RegionSpace
 *
 *  ENTRY
 *      dwRegionSpace - region space
 *
 *  EXIT-SUCCESS
 *      returns the pointer to the structure found
 *  EXIT-FAILURE
 *      returns NULL
 */

PRSACCESS LOCAL FindRSAccess(ULONG dwRegionSpace)
{
    TRACENAME("FINDRSACCESS")
    PRSACCESS prsa;

    ENTER(3, ("FindRSAccess(RegionSpace=%x)\n", dwRegionSpace));

    for (prsa = gpRSAccessHead; prsa != NULL; prsa = prsa->prsaNext)
    {
        if (prsa->dwRegionSpace == dwRegionSpace)
            break;
    }

    EXIT(3, ("FindRSAccess=%x\n", prsa));
    return prsa;
}       //FindRSAccess

/***LP  FreeRSAccessList - free the RSACCESS structure list
 *
 *  ENTRY
 *      prsa -> RSACCESS list
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeRSAccessList(PRSACCESS prsa)
{
    TRACENAME("FREERSACCESSLIST")
    PRSACCESS prsaNext;

    ENTER(3, ("FreeRSAccessList(prsa=%x)\n", prsa));

    while (prsa != NULL)
    {
        prsaNext = prsa->prsaNext;
        FREERSOBJ(prsa);
        prsa = prsaNext;
    }

    EXIT(3, ("FreeRSAccessList!\n"));
}       //FreeRSAccessList

/***LP  GetObjectPath - get object namespace path
 *
 *  ENTRY
 *      pns -> object
 *
 *  EXIT
 *      returns name space path
 */

PSZ LOCAL GetObjectPath(PNSOBJ pns)
{
    TRACENAME("GETOBJECTPATH")
    static char szPath[MAX_NAME_LEN + 1] = {0};
    int i;

    ENTER(4, ("GetObjectPath(pns=%x)\n", pns));

    if (pns != NULL)
    {
        if (pns->pnsParent == NULL)
            STRCPY(szPath, "\\");
        else
        {
            GetObjectPath(pns->pnsParent);
            if (pns->pnsParent->pnsParent != NULL)
                STRCAT(szPath, ".");
            STRCATN(szPath, (PSZ)&pns->dwNameSeg, sizeof(NAMESEG));
        }


        for (i = STRLEN(szPath) - 1; i >= 0; --i)
        {
            if (szPath[i] == '_')
                szPath[i] = '\0';
            else
                break;
        }
    }
    else
    {
        szPath[0] = '\0';
    }

    EXIT(4, ("GetObjectPath=%s\n", szPath));
    return szPath;
}       //GetObjectPath

#ifdef DEBUGGER

/***LP  NameSegString - convert a NameSeg to an ASCIIZ string
 *
 *  ENTRY
 *      dwNameSeg - NameSeg
 *
 *  EXIT
 *      returns string
 */

PSZ LOCAL NameSegString(ULONG dwNameSeg)
{
    TRACENAME("NAMESEGSTRING")
    static char szNameSeg[sizeof(NAMESEG) + 1] = {0};

    ENTER(5, ("NameSegString(dwNameSeg=%x)\n", dwNameSeg));

    STRCPYN(szNameSeg, (PSZ)&dwNameSeg, sizeof(NAMESEG));

    EXIT(5, ("NameSegString=%s\n", szNameSeg));
    return szNameSeg;
}       //NameSegString


/***LP  GetObjectTypeName - get object type name
 *
 *  ENTRY
 *      dwObjType - object type
 *
 *  EXIT
 *      return object type name
 */

PSZ LOCAL GetObjectTypeName(ULONG dwObjType)
{
    TRACENAME("GETOBJECTTYPENAME")
    PSZ psz = NULL;
    int i;
    static struct
    {
        ULONG dwObjType;
        PSZ   pszObjTypeName;
    } ObjTypeTable[] =
        {
            OBJTYPE_UNKNOWN,    "Unknown",
            OBJTYPE_INTDATA,    "Integer",
            OBJTYPE_STRDATA,    "String",
            OBJTYPE_BUFFDATA,   "Buffer",
            OBJTYPE_PKGDATA,    "Package",
            OBJTYPE_FIELDUNIT,  "FieldUnit",
            OBJTYPE_DEVICE,     "Device",
            OBJTYPE_EVENT,      "Event",
            OBJTYPE_METHOD,     "Method",
            OBJTYPE_MUTEX,      "Mutex",
            OBJTYPE_OPREGION,   "OpRegion",
            OBJTYPE_POWERRES,   "PowerResource",
            OBJTYPE_PROCESSOR,  "Processor",
            OBJTYPE_THERMALZONE,"ThermalZone",
            OBJTYPE_BUFFFIELD,  "BuffField",
            OBJTYPE_DDBHANDLE,  "DDBHandle",
            OBJTYPE_DEBUG,      "Debug",
            OBJTYPE_OBJALIAS,   "ObjAlias",
            OBJTYPE_DATAALIAS,  "DataAlias",
            OBJTYPE_BANKFIELD,  "BankField",
            OBJTYPE_FIELD,      "Field",
            OBJTYPE_INDEXFIELD, "IndexField",
            OBJTYPE_DATA,       "Data",
            OBJTYPE_DATAFIELD,  "DataField",
            OBJTYPE_DATAOBJ,    "DataObject",
            0,                  NULL
        };

    ENTER(4, ("GetObjectTypeName(Type=%x)\n", dwObjType));

    for (i = 0; ObjTypeTable[i].pszObjTypeName != NULL; ++i)
    {
        if (dwObjType == ObjTypeTable[i].dwObjType)
        {
            psz = ObjTypeTable[i].pszObjTypeName;
            break;
        }
    }

    EXIT(4, ("GetObjectTypeName=%s\n", psz? psz: "NULL"));
    return psz;
}       //GetObjectTypeName

/***LP  GetRegionSpaceName - get region space name
 *
 *  ENTRY
 *      bRegionSpace - region space
 *
 *  EXIT
 *      return object type name
 */

PSZ LOCAL GetRegionSpaceName(UCHAR bRegionSpace)
{
    TRACENAME("GETREGIONSPACENAME")
    PSZ psz = NULL;
    int i;
    static PSZ pszVendorDefined = "VendorDefined";
    static struct
    {
        UCHAR bRegionSpace;
        PSZ   pszRegionSpaceName;
    } RegionNameTable[] =
        {
            REGSPACE_MEM,       "SystemMemory",
            REGSPACE_IO,        "SystemIO",
            REGSPACE_PCICFG,    "PCIConfigSpace",
            REGSPACE_EC,        "EmbeddedController",
            REGSPACE_SMB,       "SMBus",
            0,                  NULL
        };

    ENTER(4, ("GetRegionSpaceName(RegionSpace=%x)\n", bRegionSpace));

    for (i = 0; RegionNameTable[i].pszRegionSpaceName != NULL; ++i)
    {
        if (bRegionSpace == RegionNameTable[i].bRegionSpace)
        {
            psz = RegionNameTable[i].pszRegionSpaceName;
            break;
        }
    }

    if (psz == NULL)
    {
        psz = pszVendorDefined;
    }

    EXIT(4, ("GetRegionSpaceName=%s\n", psz? psz: "NULL"));
    return psz;
}       //GetRegionSpaceName
#endif  //ifdef DEBUGGER

/***LP  ValidateTable - Validate the table creator and revision
 *
 *  ENTRY
 *      pdsdt -> DSDT
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN LOCAL ValidateTable(PDSDT pdsdt)
{
    TRACENAME("VALIDATETABLE")
    BOOLEAN rc = TRUE;

    ENTER(3, ("ValidateTable(pdsdt=%x)\n", pdsdt));

    if (!(gdwfAMLIInit & AMLIIF_NOCHK_TABLEVER) &&
        (STRCMPN((PSZ)pdsdt->Header.CreatorID, CREATORID_MSFT,
                 sizeof(pdsdt->Header.CreatorID)) == 0))
    {
        if (pdsdt->Header.CreatorRev < MIN_CREATOR_REV)
        {
            rc = FALSE;
        }
    }

    EXIT(3, ("ValidateTable=%x\n", rc));
    return rc;
}       //ValidateTable

/***LP  NewObjData - allocate new object data identical to a given old object
 *
 *  ENTRY
 *      pheap -> HEAP
 *      pdata -> old object
 *
 *  EXIT-SUCCESS
 *      returns pointer to the new data
 *  EXIT-FAILURE
 *      returns NULL
 */

PVOID LOCAL NewObjData(PHEAP pheap, POBJDATA pdata)
{
    PVOID pv = NULL;

    switch (pdata->dwDataType)
    {
        case OBJTYPE_STRDATA:
            pv = NEWSDOBJ(gpheapGlobal, pdata->dwDataLen);
            break;

        case OBJTYPE_BUFFDATA:
            pv = NEWBDOBJ(gpheapGlobal, pdata->dwDataLen);
            break;

        case OBJTYPE_PKGDATA:
            pv = NEWPKOBJ(gpheapGlobal, pdata->dwDataLen);
            break;

        case OBJTYPE_FIELDUNIT:
            pv = NEWFUOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_EVENT:
            pv = NEWEVOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_METHOD:
            pv = NEWMEOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_MUTEX:
            pv = NEWMTOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_OPREGION:
            pv = NEWOROBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_POWERRES:
            pv = NEWPROBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_PROCESSOR:
            pv = NEWPCOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_BUFFFIELD:
            pv = NEWBFOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_BANKFIELD:
            pv = NEWKFOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_FIELD:
            pv = NEWFOBJ(pheap, pdata->dwDataLen);
            break;

        case OBJTYPE_INDEXFIELD:
            pv = NEWIFOBJ(pheap, pdata->dwDataLen);
            break;

        default:
            AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                        ("NewObjData: invalid object type %s",
                         GetObjectTypeName(pdata->dwDataType)));
    }

    return pv;
}       //NewObjData

/***LP  FreeObjData - Free object data
 *
 *  ENTRY
 *      pdata -> object which its data is to be freed
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeObjData(POBJDATA pdata)
{
    switch (pdata->dwDataType)
    {
        case OBJTYPE_STRDATA:
            FREESDOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_BUFFDATA:
            FREEBDOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_PKGDATA:
            FREEPKOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_FIELDUNIT:
            FREEFUOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_EVENT:
            FREEEVOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_METHOD:
            FREEMEOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_MUTEX:
            FREEMTOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_OPREGION:
            FREEOROBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_POWERRES:
            FREEPROBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_PROCESSOR:
            FREEPCOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_BUFFFIELD:
            FREEBFOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_BANKFIELD:
            FREEKFOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_FIELD:
            FREEFOBJ(pdata->pbDataBuff);
            break;

        case OBJTYPE_INDEXFIELD:
            FREEIFOBJ(pdata->pbDataBuff);
            break;

        default:
            AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                        ("FreeObjData: invalid object type %s",
                         GetObjectTypeName(pdata->dwDataType)));
    }
}       //FreeObjData

/*** LP InitializeRegOverrideFlags - Get override flags from
 *                                   the registry.
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */
VOID LOCAL InitializeRegOverrideFlags(VOID)
{
    TRACENAME("InitializeRegOverrideFlags")
    HANDLE hRegKey=NULL;
    NTSTATUS status;
    ULONG argSize;

    ENTER(3, ("InitializeRegOverrideFlags\n"));
        
    status = OSOpenHandle(ACPI_PARAMETERS_REGISTRY_KEY, NULL, &hRegKey);
    if (NT_SUCCESS(status))
    {
        argSize = sizeof(gOverrideFlags);
        OSReadRegValue(AMLI_ATTRIBUTES, hRegKey, &gOverrideFlags, &argSize);
    }
    else
    {
        gOverrideFlags = 0;
    }
    
    EXIT(3, ("InitializeRegOverrideFlags\n"));
    return;
}


/*** LP ValidateMemoryOpregionRange - Validate the memory range that is
 *                                    required for the memory opregion.
 *
 *  ENTRY
 *      uipAddr - physical memory address
 *      dwLen - length of memory block
 *
 *  EXIT
 *      returns TRUE iff the memory is in the legal range.
 */
BOOLEAN LOCAL ValidateMemoryOpregionRange(ULONG_PTR uipAddr, ULONG dwLen)
{
    BOOLEAN                                 Ret = FALSE;
    NTSTATUS                                status;
    PACPI_BIOS_MULTI_NODE                   e820Info;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR         cmPartialDesc;
    PCM_PARTIAL_RESOURCE_LIST               cmPartialList;
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  keyInfo;
    ULONGLONG                               i;
    ULONGLONG                               absMin;
    ULONGLONG                               absMax;
    
    
    //
    // Read the key for the AcpiConfigurationData
    //
    status = OSReadAcpiConfigurationData( &keyInfo );

    if (!NT_SUCCESS(status)) 
    {
        PRINTF("ValidateMemoryOpregionRange: Cannot get E820 Information %08lx\n",
                status
              );
        Ret = TRUE;
    }
    else
    {
        //
        // Crack the structure to get the E820Table entry
        //
        cmPartialList = (PCM_PARTIAL_RESOURCE_LIST) (keyInfo->Data);
        cmPartialDesc = &(cmPartialList->PartialDescriptors[0]);
        e820Info = (PACPI_BIOS_MULTI_NODE) ( (PUCHAR) cmPartialDesc + sizeof(CM_PARTIAL_RESOURCE_LIST) );

        //
        // Calculate absmin and absmax for the incoming address
        //
        absMin = (ULONGLONG)uipAddr;
        absMax = absMin + dwLen;
        
        //
        // walk the E820 list
        //
        for(i = 0; i < e820Info->Count; i++) 
        {
            if (e820Info->E820Entry[i].Type == AcpiAddressRangeMemory) 
            {
                if(absMax < (ULONGLONG)PAGE_SIZE)
                {
                    Ret = TRUE;
                    PRINTF("ValidateMemoryOpregionRange: Memory OpRegion (Base = 0x%I64x, Length = 0x%x) is in first physical page, skipping check.\n",
                           absMin,
                           dwLen
                           );
                }
                else
                {
                    if((absMax < (ULONGLONG) e820Info->E820Entry[i].Base.QuadPart)
                      ||(absMin >= (ULONGLONG) (e820Info->E820Entry[i].Base.QuadPart + e820Info->E820Entry[i].Length.QuadPart)))
                    {
                        Ret = TRUE;
                        PRINTF("ValidateMemoryOpregionRange: Memory OpRegion (Base = 0x%I64x, Length = 0x%x) is not in AcpiAddressRangeMemory (Base = 0x%I64x, Length = 0x%I64x)\n",
                               absMin,
                               dwLen,
                               e820Info->E820Entry[i].Base.QuadPart,
                               e820Info->E820Entry[i].Length.QuadPart
                               );
                    }
                    else
                    {
                        //
                        // This opregion is mapping memory that belongs to the OS.
                        // Log a error in the event log.
                        //

                        PWCHAR illegalMemoryAddress[5];
                        WCHAR AMLIName[6];
                        WCHAR addressBuffer[64];
                        WCHAR addressLengthBuffer[64];
                        WCHAR OSaddressBufferRangeMin[64];
                        WCHAR OSaddressBufferRangeMax[64];
                                           
                        //
                        // Turn the address into a string
                        //
                        swprintf( AMLIName, L"AMLI");
                        swprintf( addressBuffer, L"0x%I64x", absMin );
                        swprintf( addressLengthBuffer, L"0x%lx", dwLen );
                        swprintf( OSaddressBufferRangeMin, L"0x%I64x", e820Info->E820Entry[i].Base.QuadPart );
                        swprintf( OSaddressBufferRangeMax, L"0x%I64x", e820Info->E820Entry[i].Base.QuadPart +  e820Info->E820Entry[i].Length.QuadPart);

                        
                        //
                        // Build the list of arguments to pass to the function that will write the
                        // error log to the registry
                        //
                        illegalMemoryAddress[0] = AMLIName;
                        illegalMemoryAddress[1] = addressBuffer;
                        illegalMemoryAddress[2] = addressLengthBuffer;
                        illegalMemoryAddress[3] = OSaddressBufferRangeMin;
                        illegalMemoryAddress[4] = OSaddressBufferRangeMax;

                        //
                        // Log error to event log
                        //
                        ACPIWriteEventLogEntry(ACPI_ERR_AMLI_ILLEGAL_MEMORY_OPREGION_FATAL,
                                           illegalMemoryAddress,
                                           5,
                                           NULL,
                                           0);        


                        PRINTF("ValidateMemoryOpregionRange: Memory OpRegion (Base = 0x%I64x, Length = 0x%x) is in AcpiAddressRangeMemory (Base = 0x%I64x, Length = 0x%I64x)\n",
                               absMin,
                               dwLen,
                               e820Info->E820Entry[i].Base.QuadPart,
                               e820Info->E820Entry[i].Length.QuadPart
                               );
                        Ret = FALSE;
                        break;
                    }
                }
            }
        }
        //
        // Free the E820 info
        //
        ExFreePool( keyInfo );
    }
  
    return Ret;
}

#ifdef DEBUG
/*** LP FreeMem - Free memory object
 *
 *  ENTRY
 *      pv -> memory object to be freed
 *      pdwcObjs -> object counter to be decremented
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeMem(PVOID pv, PULONG pdwcObjs)
{
    if (*pdwcObjs != 0)
    {
        ExFreePool(pv);
        (*pdwcObjs)--;
    }
    else
    {
        AMLI_ERROR(("FreeMem: Unbalanced MemFree"));
    }
}       //FreeMem

/*** LP CheckGlobalHeap - Make sure that the global heap has not become
 *                        corrupted
 *
 *  ENTRY
 *      None
 *
 *  Exit
 *      None
 */
VOID LOCAL CheckGlobalHeap()
{
    KIRQL oldIrql;

    //
    // We don't care about this is we are loading a DDB
    //
    if (gdwfAMLI & AMLIF_LOADING_DDB) {

        return;

    }

    //
    // Must have spinlock protection...
    //
    KeAcquireSpinLock( &gdwGHeapSpinLock, &oldIrql );

    //
    // We only care if they don't match...
    //
    if (gdwGlobalHeapSize == gdwGHeapSnapshot) {

        goto CheckGlobalHeapExit;

    }

    //
    // If the new heap size is smaller than the current size, then
    // we shrunk the heap and that is good...
    //
    if (gdwGlobalHeapSize < gdwGHeapSnapshot) {

        //
        // Remember the new "snapshot size"
        //
        gdwGHeapSnapshot = gdwGlobalHeapSize;
        goto CheckGlobalHeapExit;

    }

    if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON) {

        AMLI_WARN(("CheckGlobalHeap: "
                   "potential memory leak "
                   "detected (CurrentHeapSize=%d,"
                   "ReferenceSize=%d)",
                   gdwGlobalHeapSize,
                   gdwGHeapSnapshot));

    }
    if (gdwGlobalHeapSize - gdwGHeapSnapshot > 8192) {

        AMLI_WARN(("CheckGlobalHeap: detected memory leak"));
        KdBreakPoint();

    }

CheckGlobalHeapExit:

    //
    // Release the lock and we are done
    //
    KeReleaseSpinLock( &gdwGHeapSpinLock, oldIrql );
}
#endif  //ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\namedobj.c ===
/*** namedobj.c - Parse named object instructions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/10/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  BankField - Parse and execute the BankField instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL BankField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("BANKFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pnsBase, pnsBank;

    ENTER(2, ("BankField(pctxt=%x,pterm=%x,pbOp=%x)\n",
              pctxt, pterm, pctxt->pbOp));

    if (((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[0].pbDataBuff,
                                  pctxt->pnsScope, &pnsBase, NSF_WARN_NOTFOUND))
         == STATUS_SUCCESS) &&
        ((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[1].pbDataBuff,
                                  pctxt->pnsScope, &pnsBank, NSF_WARN_NOTFOUND))
         == STATUS_SUCCESS))
    {
        if (pnsBase->ObjData.dwDataType != OBJTYPE_OPREGION)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("BankField: %s is not an operation region",
                              pterm->pdataArgs[0].pbDataBuff));
        }
        else if (pnsBank->ObjData.dwDataType != OBJTYPE_FIELDUNIT)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("BankField: %s is not a field unit",
                              pterm->pdataArgs[1].pbDataBuff));
        }
        else if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent, NULL,
                                             pctxt->pnsScope, pctxt->powner,
                                             &pterm->pnsObj, 0)) ==
                 STATUS_SUCCESS)
        {
            pterm->pnsObj->ObjData.dwDataType = OBJTYPE_BANKFIELD;
            pterm->pnsObj->ObjData.dwDataLen = sizeof(BANKFIELDOBJ);

            if ((pterm->pnsObj->ObjData.pbDataBuff =
                 NEWKFOBJ(pctxt->pheapCurrent,
                          pterm->pnsObj->ObjData.dwDataLen)) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("BankField: failed to allocate BankField object"));
            }
            else
            {
                PBANKFIELDOBJ pbf;

                MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                        pterm->pnsObj->ObjData.dwDataLen);
                pbf = (PBANKFIELDOBJ)pterm->pnsObj->ObjData.pbDataBuff;
                pbf->pnsBase = pnsBase;
                pbf->pnsBank = pnsBank;
                pbf->dwBankValue = (ULONG)pterm->pdataArgs[2].uipDataValue