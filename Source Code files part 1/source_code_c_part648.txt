OCK 
{
    READ_WRITE_LOCK     rwlLock;
    union
    {
        ULONG           ulCount;    // number of waiting threads
        LIST_ENTRY      leLink;     // link in list of free locks
    };
} DYNAMIC_READWRITE_LOCK, *PDYNAMIC_READWRITE_LOCK;

//
// STRUCTURE: DYNAMIC_LOCKS_STORE
// store of free dynamic locks that can be allocated as required.
//

typedef struct _DYNAMIC_LOCKS_STORE 
{
    CHAR                szName[4];
    
    HANDLE              hHeap;
    
    LOCKED_LIST         llFreeLocksList;

    ULONG               ulCountAllocated;
    ULONG               ulCountFree;
} DYNAMIC_LOCKS_STORE, *PDYNAMIC_LOCKS_STORE;



// if more than DYNAMIC_LOCKS_HIGH_THRESHOLD locks are
// allocated then any locks that are freed are destroyed
#define DYNAMIC_LOCKS_HIGH_THRESHOLD 7

#define DYNAMIC_LOCKS_STORE_INITIALIZED(pStore)                     \
    (LOCKED_LIST_INITIALIZED(&(pStore)->llFreeLocksList))

typedef enum { READ_MODE, WRITE_MODE } LOCK_MODE;

DWORD
InitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pStore,
    HANDLE                  hHeap,
    PCHAR                   szName
    );

DWORD
DeInitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pStore
    );

DWORD
AcquireDynamicReadwriteLock (
    PDYNAMIC_READWRITE_LOCK *ppLock,
    LOCK_MODE               lmMode,
    PDYNAMIC_LOCKS_STORE    pStore
    );

VOID
ReleaseDynamicReadwriteLock (
    PDYNAMIC_READWRITE_LOCK *ppLock,
    LOCK_MODE               lmMode,
    PDYNAMIC_LOCKS_STORE    pStore
    );

#endif // _EAPOL_SYNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\eapol\service\pcheapol.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This module contains the header files that needed to included across 
    various source files


Revision History:

    sachins, Apr 23 2000, Created
   
Notes:

    Maintain the order of the include files, at the top being vanilla
    definitions files, bottom being dependent definitions

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <rtutils.h>
#include <locale.h>
#include <lmcons.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <winsvc.h>
#include <winuser.h>
#include <wmistr.h>
#include <wmium.h>
#include <wchar.h>
#include <zwapi.h>
#include <dbt.h>
#include <rpc.h>
#include <raseapif.h>
#include <raserror.h>
#include <ntddndis.h>
#include <ndisguid.h>
#include <ndispnp.h>
#include <dhcpcapi.h>
#include <winsock2.h>
#include <mswsock.h>
#include <ws2spi.h>
#include <md5.h>
#include <rc4.h>
#include <objbase.h>
#include <security.h>
#include <secext.h>
#include <nuiouser.h>
#include <nlasvc.h>
#include <netconp.h>
#include <winsta.h>
#include <wtsapi32.h>
#include <syslib.h>
#include <shlwapi.h>
#include <wincrypt.h>
#include <userenv.h>
#include <esent.h>
#include <wzcsapi.h>
#include <ntddip6.h>

#include "wifipol.h"
#include "intfhdl.h"
#include "notify.h"
#include "wzccrypt.h"

#include "eldefs.h"
#include "elsync.h"
#include "eapol.h"
#include "elport.h"
#include "eleap.h"
#include "eldeviceio.h"
#include "elprotocol.h"
#include "eluser.h"
#include "eapollog.h"
#include "eapoldlgrc.h"
#include "mprerror.h"       // Extended errors provided by mpr
#include "eldialog.h"
#include "eloptimize.h"
#include "elip6.h"
#include "tracing.h"
#include "database.h"
#include "zcdblog.h"
#include "wzc_s.h"
#include "eapolutil.h"
#include "eltrace.h"
#include "elpolicy.h"
#include "elkey.h"
#include "elglobals.h"
#include "rpcsrv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\inc\eapolext.h ===
#pragma once

extern 
VOID 
EAPOLServiceMain (
        IN DWORD    argc,
        IN LPWSTR   *lpwsServiceArgs
        );

extern
VOID
EAPOLCleanUp (
        IN DWORD    dwError
        );

extern
DWORD
ElDeviceNotificationHandler (
        IN  VOID    *lpEventData,
        IN  DWORD   dwEventType
        );

extern
DWORD
ElSessionChangeHandler (
        IN  VOID        *lpEventData,
        IN  DWORD       dwEventType
        );

extern
DWORD
RpcEapolGetCustomAuthData (
    STRING_HANDLE   pSrvAddr,
    PWCHAR          pwszGuid,
    DWORD           dwEapTypeId,
    RAW_DATA        pwszSSID,
    PRAW_DATA       rdConnInfo
    );

extern
DWORD
RpcEapolSetCustomAuthData (
    STRING_HANDLE   pSrvAddr,
    PWCHAR          pwszGuid,
    DWORD           dwEapTypeId,
    RAW_DATA        pwszSSID,
    PRAW_DATA       rdConnInfo
    );

extern
DWORD
RpcEapolGetInterfaceParams (
    STRING_HANDLE   pSrvAddr,
    PWCHAR          pwszGuid,
    PEAPOL_INTF_PARAMS  pIntfParams
    );

extern
DWORD
RpcEapolSetInterfaceParams (
    STRING_HANDLE   pSrvAddr,
    PWCHAR          pwszGuid,
    PEAPOL_INTF_PARAMS  pIntfParams
    );

extern
DWORD
RpcEapolReAuthenticateInterface (
    STRING_HANDLE   pSrvAddr,
    PWCHAR          pwszGuid
    );

extern
DWORD
RpcEapolQueryInterfaceState (
    STRING_HANDLE   pSrvAddr,
    PWCHAR          pwszGuid,
    PEAPOL_INTF_STATE   pIntfState
    );

extern
HRESULT
EAPOLQueryGUIDNCSState (
    IN      GUID            * pGuidConn,
    OUT     NETCON_STATUS   * pncs
    );

extern
VOID
EAPOLTrayIconReady (
    IN  const   WCHAR       * pwszUserName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\eapol\service\eluser.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    
    eluser.h

Abstract:

    The module deals with declarations related to user interaction, user logon


Revision History:

    sachins, Apr 23 2000, Created

--*/

#ifndef _EAPOL_USER_H_
#define _EAPOL_USER_H_

//
// Dialer dialogs argument block.  
//
typedef struct
_USERDLGARGS
{
    EAPOL_PCB       *pPCB;
} USERDLGARGS;

//
// Dialer dialogs context block. 
//
typedef struct
USERDLGINFO
{
    // Common dial context information including the RAS API arguments.
    //
    USERDLGARGS* pArgs;

    // Handle of the dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndEbUser;
    HWND hwndEbPw;
    HWND hwndEbDomain;
    HWND hwndCbSavePw;
    HWND hwndClbNumbers;
    HWND hwndStLocations;
    HWND hwndLbLocations;
    HWND hwndPbRules;
    HWND hwndPbProperties;

    // Window handles and original window procedure of the subclassed
    // 'hwndClbNumbers' control's edit-box and list-box child windows.
    //
    HWND hwndClbNumbersEb;
    HWND hwndClbNumbersLb;
    WNDPROC wndprocClbNumbersEb;
    WNDPROC wndprocClbNumbersLb;

    // Set if COM has been initialized (necessary for calls to netshell).
    //
    BOOL fComInitialized;
} USERDLGINFO;

VOID        
ElSessionChangeHandler (
        IN  PVOID   pEventData,
        IN  DWORD   dwEventType
        );

DWORD
WINAPI
ElUserLogonCallback (
        IN  PVOID           pvContext
        );

DWORD
WINAPI
ElUserLogoffCallback (
        IN  PVOID           pvContext
        );

DWORD
ElGetUserIdentity (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
ElProcessUserIdentityResponse (
        IN  EAPOL_EAP_UI_CONTEXT    EapolUIContext,
        IN  EAPOLUI_RESP            EapolUIResp
        );

DWORD
ElGetUserNamePassword (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
ElProcessUserNamePasswordResponse (
        IN  EAPOL_EAP_UI_CONTEXT    EapolUIContext,
        IN  EAPOLUI_RESP            EapolUIResp
        );

DWORD
ElInvokeInteractiveUI (
        IN  EAPOL_PCB               *pPCB,
        IN  ELEAP_INVOKE_EAP_UI     *pInvokeEapUIIn
        );

DWORD
ElProcessInvokeInteractiveUIResponse (
        IN  EAPOL_EAP_UI_CONTEXT    EapolUIContext,
        IN  EAPOLUI_RESP            EapolUIResp
        );

VOID
ElUserDlgSave (
        IN  USERDLGINFO      *pInfo
        );
BOOL
ElUserDlgCommand (
        IN  USERDLGINFO      *pInfo,
        IN  WORD        wNotification,
        IN  WORD        wId,
        IN  HWND        hwndCtrl
        );
DWORD
ElUserDlg (
        IN  HWND        hwndOwner,
        IN  EAPOL_PCB   *pPCB
        );

BOOL
ElUserDlgInit (
        IN  HWND    hwndDlg,
        IN  USERDLGARGS  *pArgs
        );

VOID
ElUserDlgTerm (
        IN  HWND    hwndDlg,
        IN  USERDLGINFO      *pInfo
        );

INT_PTR
ElUserDlgProc (
        IN  HWND    hwnd,
        IN  UINT    unMsg,
        IN  WPARAM  wparam,
        IN  LPARAM  lparam );

DWORD
ElCreateAndSendIdentityResponse (
        IN  EAPOL_PCB               *pPCB,
        IN  EAPOL_EAP_UI_CONTEXT    *pEAPUIContext
        );

DWORD
ElSendGuestIdentityResponse (
        IN  EAPOL_EAP_UI_CONTEXT    *pEAPUIContext
        );

DWORD
ElStartUserLogon (
        );

DWORD
ElValidateInteractiveRPCClient (
        );

#endif // _EAPOL_USER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\eapol\service\eluser.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    
    eluser.c


Abstract:

    The module deals with functions related to user interaction, user logon


Revision History:

    sachins, Apr 23 2000, Created

--*/


#include "pcheapol.h"
#pragma hdrstop

#define cszEapKeyRas   TEXT("Software\\Microsoft\\RAS EAP\\UserEapInfo")

#define cszEapValue TEXT("EapInfo")

#ifndef EAPOL_SERVICE
#define cszModuleName TEXT("wzcsvc.dll")
#else
#define cszModuleName TEXT("eapol.exe")
#endif


//
// ElSessionChangeHandler
//
// Description:
//
//  Function called to handle user session login/logoff/user-switching
//
// Arguments:
//  pEventData - SCM event data
//  dwEventType - SCM event type
//

VOID
ElSessionChangeHandler (
        PVOID       pEventData,
        DWORD       dwEventType
        )
{
    DWORD                   dwEventStatus = 0;
    BOOLEAN                 fDecrWorkerThreadCount = FALSE;
    LPTHREAD_START_ROUTINE  pUserRoutine = NULL;
    PVOID                   pvBuffer = NULL;
    EAPOL_ZC_INTF   ZCData;
    DWORD                   dwRetCode = NO_ERROR;

    do
    {
        if (g_hEventTerminateEAPOL == NULL)
        {
            dwRetCode = NO_ERROR;
            break;
        }
        if (( dwEventStatus = WaitForSingleObject (
                                    g_hEventTerminateEAPOL,
                                    0)) == WAIT_FAILED)
        {
            dwRetCode = GetLastError ();
            break;
        }
        if (dwEventStatus == WAIT_OBJECT_0)
        {
            dwRetCode = NO_ERROR;
            break;
        }
        if (!(g_dwModulesStarted & LOGON_MODULE_STARTED))
        {
            break;
        }

        InterlockedIncrement (&g_lWorkerThreads);

        fDecrWorkerThreadCount = TRUE;

        if (pEventData)
        {
            WTSSESSION_NOTIFICATION* pswtsi = (WTSSESSION_NOTIFICATION*)pEventData;
            DWORD dwSessionId = pswtsi->dwSessionId;
    
            switch (dwEventType)
            {
                case WTS_CONSOLE_CONNECT:
                case WTS_REMOTE_CONNECT:    
                    {
                        TRACE1 (USER,"ElSessionChangeHandler: CONNECT for session = (%ld)\n", 
                                dwSessionId);
                        pUserRoutine = ElUserLogonCallback;
                        break;
                    }							
			             
                case WTS_CONSOLE_DISCONNECT:
                case WTS_REMOTE_DISCONNECT:	
                    {
                        TRACE1 (USER,"ElSessionChangeHandler: DISCONNECT for session = (%ld)\n", 
                                dwSessionId);
                        pUserRoutine = ElUserLogoffCallback;
                        break;
                    }				        
    
                case WTS_SESSION_LOGON:
                    {											
                        TRACE1 (USER,"ElSessionChangeHandler: LOGON for session = (%ld)", 
                                dwSessionId);
                        pUserRoutine = ElUserLogonCallback;
                        break;
                    }						
					    	
                case WTS_SESSION_LOGOFF:
                    {
                        TRACE1 (USER,"ElSessionChangeHandler: LOGOFF for session=(%ld)", 
                                dwSessionId);
							    	
                        pUserRoutine = ElUserLogoffCallback;
                        break;
                    }
					    	
                default:	
                    break;
            }

            if (pUserRoutine == NULL)
            {
                break;
            }

            if ((pvBuffer = MALLOC (sizeof(DWORD))) == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            *((DWORD *)pvBuffer) = dwSessionId;

            if (!QueueUserWorkItem (
                (LPTHREAD_START_ROUTINE)pUserRoutine,
                pvBuffer,
                WT_EXECUTELONGFUNCTION))
            {
                dwRetCode = GetLastError();
                TRACE1 (DEVICE, "ElSessionChangeHandler: QueueUserWorkItem failed with error %ld",
                        dwRetCode);
	            break;
            }
            else
            {
                fDecrWorkerThreadCount = FALSE;
            }

        }
    }
    while (FALSE);

    if (fDecrWorkerThreadCount)
    {
        InterlockedDecrement (&g_lWorkerThreads);
    }

    if (dwRetCode != NO_ERROR)
    {
        if (pvBuffer != NULL)
        {
            FREE (pvBuffer);
        }
    }
}


//
// ElUserLogonCallback
//
// Description:
//
// Callback function invoked whenever a user logs in
// Will initiate authentication process on all ports of LAN class
// Credentials for the user in case of EAP-TLS can be obtained by 
// acquiring user token
// For EAP-CHAP, WinLogon cerdentials will need to be supplied
//
// Arguments:
//  None. 
//

DWORD
WINAPI
ElUserLogonCallback (
        IN  PVOID       pvContext
        )
{

    DWORD       dwIndex = 0;
    EAPOL_PCB   *pPCB = NULL;
    BOOL        fSetCONNECTINGState = FALSE;
    EAPOL_ZC_INTF   ZCData;
    DWORD       dwRetCode = NO_ERROR;           

    TRACE1 (USER, "ElUserLogonCallback: UserloggedOn = %ld",
            g_fUserLoggedOn);

    do 
    {
        if (g_fUserLoggedOn)
        {
            TRACE0 (USER, "ElUserLogonCallback: User logon already detected, returning without processing");
            break;
        }

        if (pvContext == NULL)
        {
            break;
        }

        if (*((DWORD *)pvContext) != USER_SHARED_DATA->ActiveConsoleId)
        {
            TRACE1 (USER, "ElUserLogonCallback: Not active console id (%ld)",
                    *((DWORD *)pvContext));
            break;
        }

        // Check if UserModule is ready for notifications

        if (!g_fTrayIconReady)
        {
            if ((dwRetCode = ElCheckUserModuleReady ()) != NO_ERROR)
            {
                TRACE1 (USER, "ElUserLogonCallback: ElCheckUserModuleReady failed with error %ld",
                        dwRetCode);
                if (dwRetCode == ERROR_BAD_IMPERSONATION_LEVEL)
                {
                    break;
                }
            }
        }

        // Set global flag to indicate the user logged on
        g_fUserLoggedOn = TRUE;
        g_dwCurrentSessionId = *((DWORD *)pvContext);


        ACQUIRE_WRITE_LOCK (&(g_PCBLock));

        for (dwIndex = 0; dwIndex < PORT_TABLE_BUCKETS; dwIndex++)
        {
            for (pPCB = g_PCBTable.pPCBBuckets[dwIndex].pPorts;
                    pPCB != NULL;
                    pPCB = pPCB->pNext)
            {
                fSetCONNECTINGState = FALSE;
                ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

                switch (pPCB->dwEAPOLAuthMode)
                {
                    case EAPOL_AUTH_MODE_0:

                        if (pPCB->State == EAPOLSTATE_AUTHENTICATED)
                        {
                            if (pPCB->PreviousAuthenticationType ==
                                    EAPOL_UNAUTHENTICATED_ACCESS)
                            {
                                fSetCONNECTINGState = TRUE;
                            }
                        }
                        else
                        {
                            (VOID) ElEapEnd (pPCB);
                            fSetCONNECTINGState = TRUE;
                        }

                        break;

                    case EAPOL_AUTH_MODE_1:

                        (VOID) ElEapEnd (pPCB);
                        fSetCONNECTINGState = TRUE;

                        break;

                    case EAPOL_AUTH_MODE_2:

                        // Do nothing 

                        break;
                }

                if (!EAPOL_PORT_ACTIVE(pPCB))
                {
                    TRACE1 (USER, "ElUserLogonCallback: Port %ws not active",
                                            pPCB->pwszDeviceGUID);
                    fSetCONNECTINGState = FALSE;
                }

                // Set port to EAPOLSTATE_CONNECTING
            
                if (fSetCONNECTINGState)
                {
                    DbLogPCBEvent (DBLOG_CATEG_INFO, pPCB, EAPOL_USER_LOGON, pPCB->pwszFriendlyName);

                    // First send out EAPOL_Logoff message
                    if ((dwRetCode = FSMLogoff (pPCB, NULL)) 
                            != NO_ERROR)
                    {
                        TRACE1 (USER, "ElUserLogonCallback: Error in FSMLogoff = %ld",
                                dwRetCode);
                        dwRetCode = NO_ERROR;
                    }

                    pPCB->dwAuthFailCount = 0;

                    // With unauthenticated access flag set, port will always
                    // reauthenticate for logged on user

                    pPCB->PreviousAuthenticationType = 
                                EAPOL_UNAUTHENTICATED_ACCESS;

                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));

                    // Restart authentication on the port
                    if ((dwRetCode = ElReStartPort (pPCB, 0, NULL)) != NO_ERROR)
                    {
                        TRACE1 (USER, "ElUserLogonCallback: MachineAuth: Error in ElReStartPort = %ld",
                                dwRetCode);
                        continue;
                    }
                }
                else
                {
                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                    continue;
                }
            }
        }
    
        RELEASE_WRITE_LOCK (&(g_PCBLock));
    
        if (dwRetCode != NO_ERROR)
        {
            break;
        }
    
    } while (FALSE);

    TRACE1 (USER, "ElUserLogonCallback: completed with error %ld", dwRetCode);
        
    if (pvContext != NULL)
    {
        FREE (pvContext);
    }

    InterlockedDecrement (&g_lWorkerThreads);

    return 0;
}


//
// ElUserLogoffCallback
//
// Description:
//
// Callback function invoked whenever a user logs off 
// Will logoff from all ports which have authentication enabled
//
// Arguments:
//  None. 
//

DWORD
WINAPI
ElUserLogoffCallback (
        IN  PVOID       pvContext
        )
{
    DWORD           dwIndex = 0;
    EAPOL_PCB       *pPCB = NULL; 
    BOOL            fSetCONNECTINGState = FALSE;
    EAPOL_ZC_INTF   ZCData;
    DWORD           dwRetCode = NO_ERROR;

    do
    {
        if (!g_fUserLoggedOn)
        {
            TRACE0 (USER, "ElUserLogoffCallback: User logoff already called, returning without processing");
            break;
        }

        if (pvContext == NULL)
        {
            break;
        }

        if (g_dwCurrentSessionId != *((DWORD *)pvContext))
        {
            TRACE1 (USER, "ElUserLogoffCallback: Not active console id (%ld)",
                    *((DWORD *)pvContext));
            break;
        }

        // Reset global flag to indicate the user logged off
    
        g_fUserLoggedOn = FALSE;
        g_dwCurrentSessionId = 0xffffffff;

        // Reset User Module ready flag
        g_fTrayIconReady = FALSE;
    
        TRACE1 (USER, "ElUserLogoffCallback: UserloggedOff = %ld",
                g_fUserLoggedOn);

        ACQUIRE_WRITE_LOCK (&(g_PCBLock));

        for (dwIndex = 0; dwIndex < PORT_TABLE_BUCKETS; dwIndex++)
        {
            for (pPCB = g_PCBTable.pPCBBuckets[dwIndex].pPorts;
                    pPCB != NULL;
                    pPCB = pPCB->pNext)
            {
                fSetCONNECTINGState = FALSE;
                ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

                switch (pPCB->dwEAPOLAuthMode)
                {
                    case EAPOL_AUTH_MODE_0:

                        if (pPCB->State == EAPOLSTATE_AUTHENTICATED)
                        {
                            if (pPCB->PreviousAuthenticationType !=
                                    EAPOL_MACHINE_AUTHENTICATION)
                            {
                                fSetCONNECTINGState = TRUE;
                            }
                        }
                        else
                        {
                            (VOID) ElEapEnd (pPCB);
                            fSetCONNECTINGState = TRUE;
                        }

                        break;

                    case EAPOL_AUTH_MODE_1:

                        (VOID) ElEapEnd (pPCB);
                        fSetCONNECTINGState = TRUE;

                        break;

                    case EAPOL_AUTH_MODE_2:

                        // Do nothing 

                        break;
                }

                if (!EAPOL_PORT_ACTIVE(pPCB))
                {
                    TRACE1 (USER, "ElUserLogoffCallback: Port %ws not active",
                                            pPCB->pwszDeviceGUID);
                    fSetCONNECTINGState = FALSE;
                }

                // Set port to EAPOLSTATE_CONNECTING
                if (fSetCONNECTINGState)
                {
                    DbLogPCBEvent (DBLOG_CATEG_INFO, pPCB, 
                            EAPOL_USER_LOGOFF, pPCB->pwszFriendlyName);

                    // First send out EAPOL_Logoff message
                    if ((dwRetCode = FSMLogoff (pPCB, NULL)) 
                            != NO_ERROR)
                    {
                        TRACE1 (USER, "ElUserLogoffCallback: Error in FSMLogoff = %ld",
                                dwRetCode);
                        dwRetCode = NO_ERROR;
                    }

                    pPCB->dwAuthFailCount = 0;

                    // With Unauthenticated_access, port will always
                    // reauthenticate 
                    pPCB->PreviousAuthenticationType = 
                                EAPOL_UNAUTHENTICATED_ACCESS;

                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));

                    // Restart authentication on the port
                    if ((dwRetCode = ElReStartPort (pPCB, 0, NULL)) 
                            != NO_ERROR)
                    {
                        TRACE1 (USER, "ElUserLogoffCallback: Error in ElReStartPort = %ld",
                                dwRetCode);
                        continue;
                    }
                }
                else
                {
                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                    continue;
                }
            }
        }
        RELEASE_WRITE_LOCK (&(g_PCBLock));
    }
    while (FALSE);
    
    TRACE0 (USER, "ElUserLogoffCallback: completed");

    if (pvContext != NULL)
    {
        FREE (pvContext);
    }

    InterlockedDecrement (&g_lWorkerThreads);
    
    return 0;
}


//
// ElGetUserIdentity
//
// Description:
//
// Function called to initiate and get user identity on a particular 
// interface. The RasEapGetIdentity in the appropriate DLL is called
// with the necessary arguments.
// 
// Arguments:
//  pPCB - Pointer to PCB for the specific port/interface
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElGetUserIdentity (
        IN  EAPOL_PCB       *pPCB
        )
{
    HANDLE              hLib = NULL;
    RASEAPFREE          pFreeFunc = NULL;
    RASEAPGETIDENTITY pIdenFunc = NULL;
    DWORD               dwIndex = -1;
    DWORD               cbData = 0;
    PBYTE               pbAuthData = NULL;
    PBYTE               pbUserIn = NULL;
    DWORD               dwInSize = 0;
    BYTE                *pUserDataOut;
    DWORD               dwSizeOfUserDataOut;
    LPWSTR              lpwszIdentity = NULL;
    CHAR                *pszIdentity = NULL;
    HWND                hwndOwner = NULL;
    DWORD               dwFlags = 0;
    BYTE                *pbSSID = NULL;
    DWORD               dwSizeOfSSID = 0;
    EAPOL_STATE         TmpEAPOLState;
    EAPOL_EAP_UI_CONTEXT *pEAPUIContext = NULL;
    DWORD               dwRetCode = NO_ERROR;

    do 
    {
        TRACE0 (USER, "ElGetUserIdentity entered");

        if (!EAPOL_PORT_ACTIVE(pPCB))
        {
            TRACE1 (PORT, "ElGetUserIdentity: Port %ws not active",
                    pPCB->pwszDeviceGUID);
            // Port is not active, cannot do further processing on this port
            break;
        }

        if (pPCB->PreviousAuthenticationType != EAPOL_MACHINE_AUTHENTICATION)
        {
            // Get Access Token for user logged on interactively

            if (pPCB->hUserToken != NULL)
            {
                if (!CloseHandle (pPCB->hUserToken))
                {
                    dwRetCode = GetLastError ();
                    TRACE1 (USER, "ElGetUserIdentity: CloseHandle failed with error %ld",
                            dwRetCode);
                    break;
                }
            }
            pPCB->hUserToken = NULL;

            if ((dwRetCode = ElGetWinStationUserToken (g_dwCurrentSessionId, &pPCB->hUserToken)) != NO_ERROR)
            {
                TRACE1 (USER, "ElGetUserIdentity: ElGetWinStationUserToken failed with error (%ld)",
                    dwRetCode);
                dwRetCode = ERROR_NO_TOKEN;
                break;
            }

            //
            // Try to fetch user identity without sending request to 
            // user module. If not possible, send request to user module
            //

            if ((dwRetCode = ElGetUserIdentityOptimized (pPCB))
                        != ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION)
            {
                TRACE0 (USER, "ElGetUserIdentity: ElGetUserIdentityOptimized got identity without user module intervention");
                break;
            }

            if (!g_fTrayIconReady)
            {
                if ((dwRetCode = ElCheckUserModuleReady ()) != NO_ERROR)
                {
                    TRACE1 (USER, "ElGetUserIdentity: ElCheckUserModuleReady failed with error %ld",
                            dwRetCode);
                    break;
                }
            }

            if (!g_fTrayIconReady)
            {
                DbLogPCBEvent (DBLOG_CATEG_WARN, pPCB, EAPOL_WAITING_FOR_DESKTOP_LOAD);
                dwRetCode = ERROR_IO_PENDING;
                TRACE0 (USER, "ElGetUserIdentity: TrayIcon NOT ready");
                break;
            }

            // 
            // Call GetUserIdentityDlgWorker
            //

            pEAPUIContext = MALLOC (sizeof(EAPOL_EAP_UI_CONTEXT));
            if (pEAPUIContext == NULL)
            {
                TRACE0 (USER, "ElGetUserIdentity: MALLOC failed for pEAPUIContext");
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            pEAPUIContext->dwEAPOLUIMsgType = EAPOLUI_GET_USERIDENTITY;
            wcscpy (pEAPUIContext->wszGUID, pPCB->pwszDeviceGUID);
            pPCB->dwUIInvocationId              =
                    InterlockedIncrement(&(g_dwEAPUIInvocationId));
            pEAPUIContext->dwSessionId = g_dwCurrentSessionId;
            pEAPUIContext->dwContextId = pPCB->dwUIInvocationId;
            pEAPUIContext->dwEapId = pPCB->bCurrentEAPId;
            pEAPUIContext->dwEapTypeId = pPCB->dwEapTypeToBeUsed;
            pEAPUIContext->dwEapFlags = pPCB->dwEapFlags;
            if (pPCB->pwszSSID)
            {
                wcscpy (pEAPUIContext->wszSSID, pPCB->pwszSSID);
            }
            if (pPCB->pSSID)
            {
                pEAPUIContext->dwSizeOfSSID = pPCB->pSSID->SsidLength;
                memcpy ((BYTE *)pEAPUIContext->bSSID, (BYTE *)pPCB->pSSID->Ssid,
                        NDIS_802_11_SSID_LEN-sizeof(ULONG));
            }

            // Have to notify state change before we post balloon
            TmpEAPOLState = pPCB->State;
            pPCB->State = EAPOLSTATE_ACQUIRED;
            ElNetmanNotify (pPCB, EAPOL_NCS_CRED_REQUIRED, NULL);
            // State is changed only in FSMAcquired
            // Revert to original
            pPCB->State = TmpEAPOLState;

            // Post the message to netman

            if ((dwRetCode = ElPostShowBalloonMessage (
                            pPCB,
                            sizeof(EAPOL_EAP_UI_CONTEXT),
                            (BYTE *)pEAPUIContext,
                            0,
                            NULL
                            )) != NO_ERROR)
            {
                TRACE1 (USER, "ElGetUserIdentity: ElPostShowBalloonMessage failed with error %ld",
                        dwRetCode);
                break;
            }

            // Restart PCB timer since UI may take longer time than required

            RESTART_TIMER (pPCB->hTimer,
                    INFINITE_SECONDS, 
                    "PCB",
                    &dwRetCode);
            if (dwRetCode != NO_ERROR)
            {
                break;
            }

            pPCB->EapUIState = EAPUISTATE_WAITING_FOR_IDENTITY;
            DbLogPCBEvent (DBLOG_CATEG_INFO, pPCB, EAPOL_WAITING_FOR_DESKTOP_IDENTITY);

            // Return error code as pending, since credentials have still not
            // been acquired
            dwRetCode = ERROR_IO_PENDING;

        }
        else // MACHINE_AUTHENTICATION
        {

        pPCB->hUserToken = NULL;

        // The EAP dll will have already been loaded by the state machine
        // Retrieve the handle to the dll from the global EAP table

        if ((dwIndex = ElGetEapTypeIndex (pPCB->dwEapTypeToBeUsed)) == -1)
        {
            TRACE1 (USER, "ElGetUserIdentity: ElGetEapTypeIndex finds no dll for EAP index %ld",
                    pPCB->dwEapTypeToBeUsed);
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        hLib = g_pEapTable[dwIndex].hInstance;

        pIdenFunc = (RASEAPGETIDENTITY)GetProcAddress(hLib, 
                                                    "RasEapGetIdentity");
        pFreeFunc = (RASEAPFREE)GetProcAddress(hLib, "RasEapFreeMemory");

        if ((pFreeFunc == NULL) || (pIdenFunc == NULL))
        {
            TRACE0 (USER, "ElGetUserIdentity: pIdenFunc or pFreeFunc does not exist in the EAP implementation");
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        if (pPCB->pSSID)
        {
            pbSSID = pPCB->pSSID->Ssid;
            dwSizeOfSSID = pPCB->pSSID->SsidLength;
        }

        // Get the size of the EAP blob
        if ((dwRetCode = ElGetCustomAuthData (
                        pPCB->pwszDeviceGUID,
                        pPCB->dwEapTypeToBeUsed,
                        dwSizeOfSSID,
                        pbSSID,
                        NULL,
                        &cbData
                        )) != NO_ERROR)
        {
            if (dwRetCode == ERROR_BUFFER_TOO_SMALL)
            {
                if (cbData <= 0)
                {
                    // No EAP blob stored in the registry
                    TRACE0 (USER, "ElGetUserIdentity: NULL sized EAP blob: continue");
                    pbAuthData = NULL;
                    // Every port should have connection data !!!
                    dwRetCode = NO_ERROR;
                }
                else
                {
                    // Allocate memory to hold the blob
                    pbAuthData = MALLOC (cbData);
                    if (pbAuthData == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (USER, "ElGetUserIdentity: Error in memory allocation for EAP blob");
                        break;
                    }
                    if ((dwRetCode = ElGetCustomAuthData (
                                pPCB->pwszDeviceGUID,
                                pPCB->dwEapTypeToBeUsed,
                                dwSizeOfSSID,
                                pbSSID,
                                pbAuthData,
                                &cbData
                                )) != NO_ERROR)
                    {
                        TRACE1 (USER, "ElGetUserIdentity: ElGetCustomAuthData failed with %ld",
                                dwRetCode);
                        break;
                    }
                }
            }
            else
            {
                // CustomAuthData for "Default" is always created for an
                // interface when EAPOL starts up
                TRACE1 (USER, "ElGetUserIdentity: ElGetCustomAuthData size estimation failed with error %ld",
                        dwRetCode);
                break;
            }
        }

        if (pIdenFunc)
        if ((dwRetCode = (*(pIdenFunc))(
                        pPCB->dwEapTypeToBeUsed,
                        hwndOwner, // hwndOwner
                        RAS_EAP_FLAG_MACHINE_AUTH, // dwFlags
                        NULL, // lpszPhonebook
                        pPCB->pwszFriendlyName, // lpszEntry
                        pbAuthData, // Connection data
                        cbData, // Count of pbAuthData
                        pbUserIn, // User data for port
                        dwInSize, // Size of user data
                        &pUserDataOut,
                        &dwSizeOfUserDataOut,
                        &lpwszIdentity
                        )) != NO_ERROR)
        {
            if (dwRetCode == ERROR_NO_EAPTLS_CERTIFICATE)
            {
                DbLogPCBEvent (DBLOG_CATEG_ERR, pPCB, EAPOL_NO_CERTIFICATE_MACHINE);
            }
            else
            {
                DbLogPCBEvent (DBLOG_CATEG_ERR, pPCB, EAPOL_ERROR_GET_IDENTITY, EAPOLAuthTypes[EAPOL_MACHINE_AUTHENTICATION], dwRetCode);
            }
            TRACE1 (USER, "ElGetUserIdentity: Error in calling GetIdentity = %ld",
                    dwRetCode);
            break;
        }

        // Fill in the returned information into the PCB fields for 
        // later authentication

        if (pPCB->pCustomAuthUserData != NULL)
        {
            FREE (pPCB->pCustomAuthUserData);
            pPCB->pCustomAuthUserData = NULL;
        }

        pPCB->pCustomAuthUserData = MALLOC (dwSizeOfUserDataOut + sizeof (DWORD));
        if (pPCB->pCustomAuthUserData == NULL)
        {
            TRACE1 (USER, "ElGetUserIdentity: Error in allocating memory for UserInfo = %ld",
                    dwRetCode);
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pPCB->pCustomAuthUserData->dwSizeOfCustomAuthData = dwSizeOfUserDataOut;

        if ((dwSizeOfUserDataOut != 0) && (pUserDataOut != NULL))
        {
            memcpy ((BYTE *)pPCB->pCustomAuthUserData->pbCustomAuthData, 
                (BYTE *)pUserDataOut, 
                dwSizeOfUserDataOut);
        }

        if (lpwszIdentity != NULL)
        {
            pszIdentity = MALLOC (wcslen(lpwszIdentity)*sizeof(CHAR) + sizeof(CHAR));
            if (pszIdentity == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (USER, "ElGetUserIdentity: MALLOC failed for pszIdentity");
                break;
            }

            if (0 == WideCharToMultiByte (
                        CP_ACP,
                        0,
                        lpwszIdentity,
                        -1,
                        pszIdentity,
                        wcslen(lpwszIdentity)*sizeof(CHAR)+sizeof(CHAR),
                        NULL, 
                        NULL ))
            {
                dwRetCode = GetLastError();
                TRACE2 (USER, "ElGetUserIdentity: WideCharToMultiByte (%ws) failed: %ld",
                        lpwszIdentity, dwRetCode);
                break;
            }

            TRACE1 (USER, "ElGetUserIdentity: Got identity = %s",
                    pszIdentity);

            if (pPCB->pszIdentity != NULL)
            {
                FREE (pPCB->pszIdentity);
                pPCB->pszIdentity = NULL;
            }
            pPCB->pszIdentity = MALLOC (strlen(pszIdentity) + sizeof(CHAR));
            if (pPCB->pszIdentity == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (USER, "ElGetUserIdentity: MALLOC failed for pPCB->pszIdentity");
                break;
            }
            memcpy (pPCB->pszIdentity, pszIdentity, strlen (pszIdentity));
            pPCB->pszIdentity[strlen(pszIdentity)] = '\0';
        }

        if (pPCB->pCustomAuthConnData != NULL)
        {
            FREE (pPCB->pCustomAuthConnData);
            pPCB->pCustomAuthConnData = NULL;
        }

        pPCB->pCustomAuthConnData = MALLOC (cbData + sizeof (DWORD));
        if (pPCB->pCustomAuthConnData == NULL)
        {
            TRACE1 (USER, "ElGetUserIdentity: Error in allocating memory for AuthInfo = %ld",
                    dwRetCode);
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pPCB->pCustomAuthConnData->dwSizeOfCustomAuthData = cbData;

        if ((cbData != 0) && (pbAuthData != NULL))
        {
            memcpy ((BYTE *)pPCB->pCustomAuthConnData->pbCustomAuthData, 
                (BYTE *)pbAuthData, 
                cbData);
        }

        // Mark the identity has been obtained for this PCB
        pPCB->fGotUserIdentity = TRUE;

        }

    } while (FALSE);

    // Cleanup
    if ((dwRetCode != NO_ERROR) && (dwRetCode != ERROR_IO_PENDING))
    {
        if (pPCB->pCustomAuthUserData != NULL)
        {
            FREE (pPCB->pCustomAuthUserData);
            pPCB->pCustomAuthUserData = NULL;
        }

        if (pPCB->pszIdentity != NULL)
        {
            FREE (pPCB->pszIdentity);
            pPCB->pszIdentity = NULL;
        }
    }

    if (pEAPUIContext != NULL)
    {
        FREE (pEAPUIContext);
    }

    if (pbUserIn != NULL)
    {
        FREE (pbUserIn);
    }

    if (pbAuthData != NULL)
    {
        FREE (pbAuthData);
    }

    if (pFreeFunc != NULL)
    {
        if (lpwszIdentity != NULL)
        {
            if (( dwRetCode = (*(pFreeFunc)) ((BYTE *)lpwszIdentity)) != NO_ERROR)
            {
                TRACE1 (USER, "ElGetUserIdentity: Error in pFreeFunc = %ld",
                        dwRetCode);
            }
        }
        if (pUserDataOut != NULL)
        {
            if (( dwRetCode = (*(pFreeFunc)) ((BYTE *)pUserDataOut)) != NO_ERROR)
            {
                TRACE1 (USER, "ElGetUserIdentity: Error in pFreeFunc = %ld",
                        dwRetCode);
            }
        }
    }

    TRACE1 (USER, "ElGetUserIdentity completed with error %ld", dwRetCode);

    return dwRetCode;

}


//
// ElProcessUserIdentityResponse
//
// Description:
//
// Function to handle UI response for ElGetUserIdentityResponse
// 
// Arguments:
//
// Return values:
//
//

DWORD
ElProcessUserIdentityResponse (
        IN  EAPOL_EAP_UI_CONTEXT    EapolUIContext,
        IN  EAPOLUI_RESP            EapolUIResp
        )
{
    DWORD                   dwSizeOfIdentity = 0;
    BYTE                    *pbIdentity = NULL;
    DWORD                   dwSizeOfUserData = 0;
    BYTE                    *pbUserData = NULL;
    DWORD                   dwSizeofConnData = 0;
    BYTE                    *pbConnData = NULL;
    EAPOL_PCB               *pPCB = NULL;
    EAPOL_EAP_UI_CONTEXT    *pEAPUIContext = NULL;
    BOOLEAN                 fPortReferenced = FALSE;
    BOOLEAN                 fPCBLocked = FALSE;
    BOOLEAN                 fBlobCopyIncomplete = FALSE;
    DWORD                   dwRetCode = NO_ERROR;

    do
    {
        pEAPUIContext = (EAPOL_EAP_UI_CONTEXT *)&EapolUIContext;

        ACQUIRE_WRITE_LOCK (&g_PCBLock);

        if ((pPCB = ElGetPCBPointerFromPortGUID (pEAPUIContext->wszGUID)) != NULL)
        {
            if (EAPOL_REFERENCE_PORT (pPCB))
            {
                fPortReferenced = TRUE;
            }
            else
            {
                pPCB = NULL;
            }
        }

        RELEASE_WRITE_LOCK (&g_PCBLock);

        if (pPCB == NULL)
        {
            break;
        }

        ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

        fPCBLocked = TRUE;

        if (!EAPOL_PORT_ACTIVE(pPCB))
        {
            TRACE1 (USER, "ElProcessUserIdentityResponse: Port %ws not active",
                    pPCB->pwszDeviceGUID);

            // Port is not active, cannot do further processing on this port
            
            break;
        }

        if (pEAPUIContext->dwRetCode != NO_ERROR)
        {
            DbLogPCBEvent (DBLOG_CATEG_ERR, pPCB,
                    EAPOL_ERROR_DESKTOP_IDENTITY, dwRetCode);
            TRACE1 (USER, "ElProcessUserIdentityResponse: Error in Dialog function (%ld)",
            pEAPUIContext->dwRetCode);
            break;
        }

        if (pPCB->EapUIState != EAPUISTATE_WAITING_FOR_IDENTITY)
        {
            TRACE2 (USER, "ElProcessUserIdentityResponse: PCB EapUIState has changed to (%ld), expected = (%ld)",
                    pPCB->EapUIState, EAPUISTATE_WAITING_FOR_IDENTITY);
            break;
        }

        if (pPCB->dwUIInvocationId != pEAPUIContext->dwContextId)
        {
            TRACE2 (USER, "ElProcessUserIdentityResponse: PCB UI Id has changed to (%ld), expected = (%ld)",
                    pPCB->dwUIInvocationId, pEAPUIContext->dwContextId);
            // break;
        }

        if (pPCB->bCurrentEAPId != pEAPUIContext->dwEapId)
        {
            TRACE2 (USER, "ElProcessUserIdentityResponse: PCB EAP Id has changed to (%ld), expected = (%ld)",
                    pPCB->bCurrentEAPId, pEAPUIContext->dwEapId);
            // break;
        }

        // Since the PCB context is right, restart PCB timer to timeout
        // in authPeriod seconds
        RESTART_TIMER (pPCB->hTimer,
                pPCB->EapolConfig.dwauthPeriod,
                "PCB",
                &dwRetCode);
        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (USER, "ElProcessUserIdentityResponse: Error in RESTART_TIMER %ld",
                    dwRetCode);
            break;
        }

        DbLogPCBEvent (DBLOG_CATEG_INFO, pPCB, EAPOL_PROCESSING_DESKTOP_RESPONSE);

        if ((EapolUIResp.rdData0.dwDataLen != 0) && (EapolUIResp.rdData0.pData != NULL))
        {
            dwSizeOfIdentity = EapolUIResp.rdData0.dwDataLen;
            pbIdentity = EapolUIResp.rdData0.pData;
        }

        if ((EapolUIResp.rdData1.dwDataLen != 0) && (EapolUIResp.rdData1.pData != NULL))
        {
            dwSizeOfUserData = EapolUIResp.rdData1.dwDataLen;
            pbUserData = EapolUIResp.rdData1.pData;
        }

        if ((EapolUIResp.rdData2.dwDataLen != 0) && (EapolUIResp.rdData2.pData != NULL))
        {
            dwSizeofConnData = EapolUIResp.rdData2.dwDataLen;
            pbConnData = EapolUIResp.rdData2.pData;
        }

        fBlobCopyIncomplete = TRUE;

        if (pPCB->pszIdentity != NULL)
        {
            FREE (pPCB->pszIdentity);
            pPCB->pszIdentity = NULL;
        }
        if (pbIdentity != NULL)
        {
            pPCB->pszIdentity = MALLOC (dwSizeOfIdentity + sizeof(CHAR));
            if (pPCB->pszIdentity == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (USER, "ElProcessUserIdentityResponse: MALLOC failed for pPCB->pszIdentity");
                break;
            }
            memcpy (pPCB->pszIdentity, pbIdentity, dwSizeOfIdentity);
            pPCB->pszIdentity[dwSizeOfIdentity] = '\0';
            TRACE1 (USER, "ElProcessUserIdentityResponse: Got username = %s",
                    pPCB->pszIdentity);
        }

        if (pPCB->pCustomAuthUserData != NULL)
        {
            FREE (pPCB->pCustomAuthUserData);
            pPCB->pCustomAuthUserData = NULL;
        }
        pPCB->pCustomAuthUserData = MALLOC (dwSizeOfUserData + sizeof (DWORD));
        if (pPCB->pCustomAuthUserData == NULL)
        {
            TRACE1 (USER, "ElProcessUserIdentityResponse: Error in allocating memory for UserInfo = %ld",
                    dwRetCode);
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        pPCB->pCustomAuthUserData->dwSizeOfCustomAuthData = dwSizeOfUserData;
        if ((dwSizeOfUserData != 0) && (pbUserData != NULL))
        {
            memcpy ((BYTE *)pPCB->pCustomAuthUserData->pbCustomAuthData, 
                (BYTE *)pbUserData, 
                dwSizeOfUserData);
        }

        if (pPCB->pCustomAuthConnData != NULL)
        {
            FREE (pPCB->pCustomAuthConnData);
            pPCB->pCustomAuthConnData = NULL;
        }
        pPCB->pCustomAuthConnData = MALLOC (dwSizeofConnData + sizeof (DWORD));
        if (pPCB->pCustomAuthConnData == NULL)
        {
            TRACE1 (USER, "ElProcessUserIdentityResponse: Error in allocating memory for AuthInfo = %ld",
                    dwRetCode);
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        pPCB->pCustomAuthConnData->dwSizeOfCustomAuthData = dwSizeofConnData;
        if ((dwSizeofConnData != 0) && (pbConnData != NULL))
        {
            memcpy ((BYTE *)pPCB->pCustomAuthConnData->pbCustomAuthData, 
                (BYTE *)pbConnData, 
                dwSizeofConnData);
        }

        fBlobCopyIncomplete = FALSE;

        if ((dwRetCode = ElCreateAndSendIdentityResponse (
                            pPCB, pEAPUIContext)) != NO_ERROR)
        {
            TRACE1 (USER, "ElProcessUserIdentityResponse: ElCreateAndSendIdentityResponse failed with error %ld",
                    dwRetCode);
            break;
        }

        // Mark the identity has been obtained for this PCB
        pPCB->fGotUserIdentity = TRUE;

        // Reset the state if identity was obtained, else port will 
        // recover by itself
        pPCB->EapUIState &= ~EAPUISTATE_WAITING_FOR_IDENTITY;

    }
    while (FALSE);

    // Cleanup
    if (dwRetCode != NO_ERROR)
    {
        if (fPCBLocked && fBlobCopyIncomplete)
        {
            if (pPCB->pCustomAuthUserData != NULL)
            {
                FREE (pPCB->pCustomAuthUserData);
                pPCB->pCustomAuthUserData = NULL;
            }

            if (pPCB->pszIdentity != NULL)
            {
                FREE (pPCB->pszIdentity);
                pPCB->pszIdentity = NULL;
            }
        }
    }

    if (fPCBLocked)
    {
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));
    }

    if (fPortReferenced)
    {
        EAPOL_DEREFERENCE_PORT (pPCB);
    }

    return dwRetCode;
}

    
//
// ElGetUserNamePassword
//
// Description:
//
// Function called to get username, domain (if any) and password using
// an interactive dialog. Called if EAP-type is MD5
//
// Arguments:
//      pPCB - Pointer to PCB for the port/interface on which credentials 
//      are to be obtained
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElGetUserNamePassword (
        IN  EAPOL_PCB       *pPCB
        )
{
    EAPOL_EAP_UI_CONTEXT    *pEAPUIContext = NULL;
    DWORD                   dwRetCode = NO_ERROR;

    do 
    {
        TRACE0 (USER, "ElGetUserNamePassword entered");

        if (!EAPOL_PORT_ACTIVE(pPCB))
        {
            TRACE1 (PORT, "ElGetUserNamePassword: Port %ws not active",
                    pPCB->pwszDeviceGUID);
            // Port is not active, cannot do further processing on this port
            break;
        }

        // Get Access Token for user logged on interactively
       
        if (pPCB->hUserToken != NULL)
        {
            if (!CloseHandle (pPCB->hUserToken))
            {
                dwRetCode = GetLastError ();
                TRACE1 (USER, "ElGetUserNamePassword: CloseHandle failed with error %ld",
                        dwRetCode);
                break;
            }
        }
        pPCB->hUserToken = NULL;

        if ((dwRetCode = ElGetWinStationUserToken (g_dwCurrentSessionId, &pPCB->hUserToken)) != NO_ERROR)
        {
            TRACE1 (USER, "ElGetUserNamePassword: ElGetWinStationUserToken failed with error (%ld)",
                dwRetCode);
            dwRetCode = ERROR_NO_TOKEN;
            break;
        }

        if (!g_fTrayIconReady)
        {
            if ((dwRetCode = ElCheckUserModuleReady ()) != NO_ERROR)
            {
                TRACE1 (USER, "ElGetUserNamePassword: ElCheckUserModuleReady failed with error %ld",
                        dwRetCode);
                break;
            }
        }

        if (!g_fTrayIconReady)
        {
            DbLogPCBEvent (DBLOG_CATEG_WARN, pPCB, EAPOL_WAITING_FOR_DESKTOP_LOAD);
            dwRetCode = ERROR_IO_PENDING;
            TRACE0 (USER, "ElGetUserNamePassword: TrayIcon NOT ready");
            break;
        }

        // 
        // Call ElGetUserNamePasswordDlgWorker
        //

        pEAPUIContext = MALLOC (sizeof(EAPOL_EAP_UI_CONTEXT));
        if (pEAPUIContext == NULL)
        {
            TRACE0 (USER, "ElGetUserNamePassword: MALLOC failed for pEAPUIContext");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pEAPUIContext->dwEAPOLUIMsgType = EAPOLUI_GET_USERNAMEPASSWORD;
        wcscpy (pEAPUIContext->wszGUID, pPCB->pwszDeviceGUID);
        pPCB->dwUIInvocationId              =
                InterlockedIncrement(&(g_dwEAPUIInvocationId));
        pEAPUIContext->dwSessionId = g_dwCurrentSessionId;
        pEAPUIContext->dwContextId = pPCB->dwUIInvocationId;
        pEAPUIContext->dwEapId = pPCB->bCurrentEAPId;
        pEAPUIContext->dwEapTypeId = pPCB->dwEapTypeToBeUsed;
        pEAPUIContext->dwEapFlags = pPCB->dwEapFlags;
        if (pPCB->pSSID)
        {
            memcpy ((BYTE *)pEAPUIContext->bSSID, (BYTE *)pPCB->pSSID->Ssid,
                    NDIS_802_11_SSID_LEN-sizeof(ULONG));
            pEAPUIContext->dwSizeOfSSID = pPCB->pSSID->SsidLength;
        }
        if (pPCB->pwszSSID)
        {
            wcscpy (pEAPUIContext->wszSSID, pPCB->pwszSSID);
        }

        // Post the message to netman

        if ((dwRetCode = ElPostShowBalloonMessage (
                        pPCB,
                        sizeof(EAPOL_EAP_UI_CONTEXT),
                        (BYTE *)pEAPUIContext,
                        0,
                        NULL
                        )) != NO_ERROR)
        {
            TRACE1 (USER, "ElGetUserNamePassword: ElPostShowBalloonMessage failed with error %ld",
                    dwRetCode);
            break;
        }

        // Restart PCB timer since UI may take longer time than required

        RESTART_TIMER (pPCB->hTimer,
                INFINITE_SECONDS, 
                "PCB",
                &dwRetCode);
        if (dwRetCode != NO_ERROR)
        {
            break;
        }

        pPCB->EapUIState = EAPUISTATE_WAITING_FOR_IDENTITY;
        DbLogPCBEvent (DBLOG_CATEG_INFO, pPCB, EAPOL_WAITING_FOR_DESKTOP_IDENTITY);

        // Return error code as pending, since credentials have still not
        // been acquired
        dwRetCode = ERROR_IO_PENDING;

    } while (FALSE);

    if ((dwRetCode != NO_ERROR) && (dwRetCode != ERROR_IO_PENDING))
    {
    }

    if (pEAPUIContext)
    {
        FREE (pEAPUIContext);
    }

    TRACE1 (USER, "ElGetUserNamePassword completed with error %ld", dwRetCode);

    return dwRetCode;
}


//
// ElProcessUserNamePasswordResponse
//
// Description:
//
// UI Response handler function for ElGetUserNamePassword
//
// Arguments:
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElProcessUserNamePasswordResponse (
        IN  EAPOL_EAP_UI_CONTEXT    EapolUIContext,
        IN  EAPOLUI_RESP            EapolUIResp
        )
{
    DWORD                   dwSizeOfIdentity = 0;
    BYTE                    *pbIdentity = NULL;
    DWORD                   dwSizeOfPassword = 0;
    BYTE                    *pbPassword = NULL;
    HWND                    hwndOwner = NULL;
    BOOLEAN                 fPCBLocked = FALSE;
    BOOLEAN                 fPortReferenced = FALSE;
    BOOLEAN                 fBlobCopyIncomplete = FALSE;
    EAPOL_PCB               *pPCB = NULL;
    EAPOL_EAP_UI_CONTEXT    *pEAPUIContext = NULL;
    DWORD                   dwRetCode = NO_ERROR;

    do 
    {
        TRACE0 (USER, "ElProcessUserNamePasswordResponse entered");

        pEAPUIContext = (EAPOL_EAP_UI_CONTEXT *)&EapolUIContext;

        ACQUIRE_WRITE_LOCK (&g_PCBLock);

        if ((pPCB = ElGetPCBPointerFromPortGUID (pEAPUIContext->wszGUID)) != NULL)
        {
            if (EAPOL_REFERENCE_PORT (pPCB))
            {
                fPortReferenced = TRUE;
            }
            else
            {
                pPCB = NULL;
            }
        }

        RELEASE_WRITE_LOCK (&g_PCBLock);

        if (pPCB == NULL)
        {
            break;
        }

        ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

        fPCBLocked = TRUE;

        if (!EAPOL_PORT_ACTIVE(pPCB))
        {
            TRACE1 (PORT, "ElProcessUserNamePasswordResponse: Port %ws not active",
                    pPCB->pwszDeviceGUID);
            // Port is not active, cannot do further processing on this port
            break;
        }
        
        if (pEAPUIContext->dwRetCode != NO_ERROR)
        {
            DbLogPCBEvent (DBLOG_CATEG_ERR, pPCB,
                    EAPOL_ERROR_DESKTOP_IDENTITY, dwRetCode);
            TRACE1 (USER, "ElProcessUserNamePasswordResponse: Error in Dialog function (%ld)",
            pEAPUIContext->dwRetCode);
            break;
        }

        if (pPCB->EapUIState != EAPUISTATE_WAITING_FOR_IDENTITY)
        {
            TRACE2 (USER, "ElProcessUserNamePasswordResponse: PCB EapUIState has changed to (%ld), expected = (%ld)",
                    pPCB->EapUIState, EAPUISTATE_WAITING_FOR_IDENTITY);
            break;
        }

        if (pPCB->dwUIInvocationId != pEAPUIContext->dwContextId)
        {
            TRACE2 (USER, "ElProcessUserNamePasswordResponse: PCB UI Id has changed to (%ld), expected = (%ld)",
                    pPCB->dwUIInvocationId, pEAPUIContext->dwContextId);
            // break;
        }

        if (pPCB->bCurrentEAPId != pEAPUIContext->dwEapId)
        {
            TRACE2 (USER, "ElProcessUserNamePasswordResponse: PCB EAP Id has changed to (%ld), expected = (%ld)",
                    pPCB->bCurrentEAPId, pEAPUIContext->dwEapId);
            // break;
        }

        // Since the PCB context is right, restart PCB timer to timeout
        // in authPeriod seconds
        RESTART_TIMER (pPCB->hTimer,
                pPCB->EapolConfig.dwauthPeriod,
                "PCB",
                &dwRetCode);
        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (USER, "ElProcessUserNamePasswordResponse: Error in RESTART_TIMER %ld",
                    dwRetCode);
            break;
        }

        DbLogPCBEvent (DBLOG_CATEG_INFO, pPCB, EAPOL_PROCESSING_DESKTOP_RESPONSE);

        if ((EapolUIResp.rdData0.dwDataLen != 0) && (EapolUIResp.rdData0.pData != NULL))
        {
            dwSizeOfIdentity = EapolUIResp.rdData0.dwDataLen;
            pbIdentity = EapolUIResp.rdData0.pData;
        }

        if ((EapolUIResp.rdData1.dwDataLen != 0) && (EapolUIResp.rdData1.pData != NULL))
        {
            dwSizeOfPassword = EapolUIResp.rdData1.dwDataLen;
            pbPassword = EapolUIResp.rdData1.pData;
        }

        fBlobCopyIncomplete = TRUE;

        if (pPCB->pszIdentity != NULL)
        {
            FREE (pPCB->pszIdentity);
            pPCB->pszIdentity = NULL;
        }

        if  (pPCB->PasswordBlob.pbData != NULL)
        {
            FREE (pPCB->PasswordBlob.pbData);
            pPCB->PasswordBlob.pbData = NULL;
            pPCB->PasswordBlob.cbData = 0;
        }

        if (pbIdentity != NULL)
        {
            pPCB->pszIdentity = MALLOC (dwSizeOfIdentity + sizeof(CHAR));
            if (pPCB->pszIdentity == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (USER, "ElProcessUserNamePasswordResponse: MALLOC failed for pPCB->pszIdentity");
                break;
            }
            memcpy (pPCB->pszIdentity, pbIdentity, dwSizeOfIdentity);
            pPCB->pszIdentity[dwSizeOfIdentity] = '\0';
            TRACE1 (USER, "ElProcessUserNamePasswordResponse: Got username = %s",
                    pPCB->pszIdentity);
        }

        if (pbPassword != 0)
        {
            if ((pPCB->PasswordBlob.pbData = 
                        MALLOC (dwSizeOfPassword)) == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            memcpy (pPCB->PasswordBlob.pbData, pbPassword, dwSizeOfPassword);
            pPCB->PasswordBlob.cbData = dwSizeOfPassword;
        }

        fBlobCopyIncomplete = FALSE;

        if ((dwRetCode = ElCreateAndSendIdentityResponse (
                            pPCB, pEAPUIContext)) != NO_ERROR)
        {
            TRACE1 (USER, "ElProcessUserNamePasswordResponse: ElCreateAndSendIdentityResponse failed with error %ld",
                    dwRetCode);
            break;
        }

        // Mark the identity has been obtained for this PCB
        pPCB->fGotUserIdentity = TRUE;

        // Reset the state if identity was obtained, else the port will recover
        // by itself
        pPCB->EapUIState &= ~EAPUISTATE_WAITING_FOR_IDENTITY;
       
    } while (FALSE);

    if (dwRetCode != NO_ERROR)
    {
        if (fPCBLocked && fBlobCopyIncomplete)
        {
            if (pPCB->pszIdentity)
            {
                FREE (pPCB->pszIdentity);
                pPCB->pszIdentity = NULL;
            }
            if (pPCB->PasswordBlob.pbData)
            {
                FREE (pPCB->PasswordBlob.pbData);
                pPCB->PasswordBlob.pbData = NULL;
                pPCB->PasswordBlob.cbData = 0;
            }
        }
    }

    if (fPCBLocked)
    {
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));
    }

    if (fPortReferenced)
    {
        EAPOL_DEREFERENCE_PORT (pPCB);
    }

    TRACE1 (USER, "ElProcessUserNamePasswordResponse completed with error %ld", dwRetCode);

    return dwRetCode;
}


//
// ElInvokeInteractiveUI
//
// Description:
//
// Function called to invoke RasEapInvokeInteractiveUI for an EAP on a 
// particular interface
// 
// Arguments:
//  pPCB - Pointer to PCB for the specific interface
//  pInvokeEapUIIn - Data to be supplied to the InvokeInteractiveUI entrypoint
//      provided by the EAP dll through PPP_EAP_OUTPUT structure
//

DWORD
ElInvokeInteractiveUI (
        IN  EAPOL_PCB               *pPCB,
        IN  ELEAP_INVOKE_EAP_UI     *pInvokeEapUIIn
        )
{
    EAPOL_EAP_UI_CONTEXT    *pEAPUIContext = NULL;
    DWORD                   dwRetCode = NO_ERROR;

    do 
    {
        if (pInvokeEapUIIn == NULL)
        {
            dwRetCode = ERROR_INVALID_PARAMETER;
            return dwRetCode;
        }

        if (pPCB->PreviousAuthenticationType == EAPOL_MACHINE_AUTHENTICATION)
        {
            TRACE0 (USER, "ElInvokeInteractiveUI: Cannot popup UI during machine authentication");
            DbLogPCBEvent (DBLOG_CATEG_ERR, pPCB, EAPOL_CANNOT_DESKTOP_MACHINE_AUTH);
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }
            
        if (!g_fTrayIconReady)
        {
            if ((dwRetCode = ElCheckUserModuleReady ()) != NO_ERROR)
            {
                TRACE1 (USER, "ElInvokeInteractiveUI: ElCheckUserModuleReady failed with error %ld",
                        dwRetCode);
                break;
            }
        }

        if (!g_fTrayIconReady)
        {
            DbLogPCBEvent (DBLOG_CATEG_WARN, pPCB, EAPOL_WAITING_FOR_DESKTOP_LOAD);
            dwRetCode = ERROR_IO_PENDING;
            TRACE0 (USER, "ElInvokeInteractiveUI: TrayIcon NOT ready");
            break;
        }

        TRACE0 (USER, "ElInvokeInteractiveUI entered");

        // 
        // Call ElInvokeInteractiveUIDlgWorker
        //

        pEAPUIContext = MALLOC (sizeof(EAPOL_EAP_UI_CONTEXT) +
                                    pInvokeEapUIIn->dwSizeOfUIContextData);
        if (pEAPUIContext == NULL)
        {
            TRACE0 (USER, "ElInvokeInteractiveUI: MALLOC failed for pEAPUIContext");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pEAPUIContext->dwEAPOLUIMsgType = EAPOLUI_INVOKEINTERACTIVEUI;
        wcscpy (pEAPUIContext->wszGUID, pPCB->pwszDeviceGUID);
        pPCB->dwUIInvocationId              =
                InterlockedIncrement(&(g_dwEAPUIInvocationId));
        pEAPUIContext->dwSessionId = g_dwCurrentSessionId;
        pEAPUIContext->dwContextId = pPCB->dwUIInvocationId;
        pEAPUIContext->dwEapId = pPCB->bCurrentEAPId;
        pEAPUIContext->dwEapTypeId = pPCB->dwEapTypeToBeUsed;
        pEAPUIContext->dwEapFlags = pPCB->dwEapFlags;
        if (pPCB->pSSID)
        {
            pEAPUIContext->dwSizeOfSSID = pPCB->pSSID->SsidLength;
            memcpy ((BYTE *)pEAPUIContext->bSSID, (BYTE *)pPCB->pSSID->Ssid,
                    NDIS_802_11_SSID_LEN-sizeof(ULONG));
        }
        if (pPCB->pwszSSID)
        {
            wcscpy (pEAPUIContext->wszSSID, pPCB->pwszSSID);
        }
        pEAPUIContext->dwSizeOfEapUIData = 
            pInvokeEapUIIn->dwSizeOfUIContextData;
        memcpy (pEAPUIContext->bEapUIData, pInvokeEapUIIn->pbUIContextData,
                pInvokeEapUIIn->dwSizeOfUIContextData);

        // Post the message to netman

        if ((dwRetCode = ElPostShowBalloonMessage (
                        pPCB,
                        sizeof(EAPOL_EAP_UI_CONTEXT)+pInvokeEapUIIn->dwSizeOfUIContextData,
                        (BYTE *)pEAPUIContext,
                        0,
                        NULL
                        )) != NO_ERROR)
        {
            TRACE1 (USER, "ElInvokeInteractiveUI: ElPostShowBalloonMessage failed with error %ld",
                    dwRetCode);
            break;
        }

        // Restart PCB timer since UI may take longer time than required

        RESTART_TIMER (pPCB->hTimer,
                INFINITE_SECONDS, 
                "PCB",
                &dwRetCode);
        if (dwRetCode != NO_ERROR)
        {
            break;
        }

        pPCB->EapUIState = EAPUISTATE_WAITING_FOR_UI_RESPONSE;
        DbLogPCBEvent (DBLOG_CATEG_INFO, pPCB, EAPOL_WAITING_FOR_DESKTOP_LOGON);

        TRACE0 (USER, "ElInvokeInteractiveUI: ElEapWork completed successfully");

    } while (FALSE);

    if (pInvokeEapUIIn->pbUIContextData != NULL)
    {
        FREE (pInvokeEapUIIn->pbUIContextData);
        pInvokeEapUIIn->pbUIContextData = NULL;
        pInvokeEapUIIn->dwSizeOfUIContextData = 0;
    }

    if (pEAPUIContext != NULL)
    {
        FREE (pEAPUIContext);
    }

    TRACE1 (USER, "ElInvokeInteractiveUI completed with error %ld", dwRetCode);

    return dwRetCode;
}


//
// ElProcessInvokeInteractiveUIResponse
//
// Description:
//
// Worker function for ElInvokeInteractiveUI
// 
// Arguments:
//

DWORD
ElProcessInvokeInteractiveUIResponse (
        IN  EAPOL_EAP_UI_CONTEXT    EapolUIContext,
        IN  EAPOLUI_RESP            EapolUIResp
        )
{
    BYTE                    *pbUIData = NULL;
    DWORD                   dwSizeOfUIData = 0;
    EAPOL_PCB               *pPCB = NULL;
    EAPOL_EAP_UI_CONTEXT    *pEAPUIContext = NULL;
    BOOLEAN                 fPortReferenced = FALSE;
    BOOLEAN                 fPCBLocked = FALSE;
    DWORD                   dwRetCode = NO_ERROR;

    do 
    {
        TRACE0 (USER, "ElProcessInvokeInteractiveUIResponse entered");

        pEAPUIContext = (EAPOL_EAP_UI_CONTEXT *)&EapolUIContext;

        ACQUIRE_WRITE_LOCK (&g_PCBLock);

        if ((pPCB = ElGetPCBPointerFromPortGUID (pEAPUIContext->wszGUID)) != NULL)
        {
            if (EAPOL_REFERENCE_PORT (pPCB))
            {
                fPortReferenced = TRUE;
            }
            else
            {
                pPCB = NULL;
            }
        }

        RELEASE_WRITE_LOCK (&g_PCBLock);

        if (pPCB == NULL)
        {
            break;
        }

        ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

        fPCBLocked = TRUE;

        if (!EAPOL_PORT_ACTIVE(pPCB))
        {
            TRACE1 (PORT, "ElProcessInvokeInteractiveUIResponse: Port %ws not active",
                    pPCB->pwszDeviceGUID);
            break;
        }

        if (pEAPUIContext->dwRetCode != NO_ERROR)
        {
            DbLogPCBEvent (DBLOG_CATEG_ERR, pPCB, EAPOL_ERROR_DESKTOP_LOGON, dwRetCode);
            TRACE1 (USER, "ElProcessInvokeInteractiveUIResponse: Error in Dialog function (%ld)",
                pEAPUIContext->dwRetCode);
            break;
        }

        if (pPCB->EapUIState != EAPUISTATE_WAITING_FOR_UI_RESPONSE)
        {
            TRACE2 (USER, "ElProcessInvokeInteractiveUIResponse: PCB EapUIState has changed to (%ld), expected = (%ld)",
                    pPCB->EapUIState, EAPUISTATE_WAITING_FOR_UI_RESPONSE);
            break;
        }

        if (pPCB->dwUIInvocationId != pEAPUIContext->dwContextId)
        {
            TRACE2 (USER, "ElProcessInvokeInteractiveUIResponse: PCB UI Id has changed to (%ld), expected = (%ld)",
                    pPCB->dwUIInvocationId, pEAPUIContext->dwContextId);
            // break;
        }

        if (pPCB->bCurrentEAPId != pEAPUIContext->dwEapId)
        {
            TRACE2 (USER, "ElProcessInvokeInteractiveUIResponse: PCB EAP Id has changed to (%ld), expected = (%ld)",
                    pPCB->bCurrentEAPId, pEAPUIContext->dwEapId);
            // break;
        }

        // Since the PCB context is right, restart PCB timer to timeout
        // in authPeriod seconds
        RESTART_TIMER (pPCB->hTimer,
                pPCB->EapolConfig.dwauthPeriod,
                "PCB",
                &dwRetCode);
        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (USER, "ElProcessInvokeInteractiveUIResponse: Error in RESTART_TIMER %ld",
                    dwRetCode);
            break;
        }

        DbLogPCBEvent (DBLOG_CATEG_INFO, pPCB, EAPOL_PROCESSING_DESKTOP_RESPONSE);

        if ((EapolUIResp.rdData0.dwDataLen != 0) && (EapolUIResp.rdData0.pData != NULL))
        {
            dwSizeOfUIData = EapolUIResp.rdData0.dwDataLen;
            pbUIData = EapolUIResp.rdData0.pData;
        }

        if (pPCB->EapUIData.pEapUIData != NULL)
        {
            FREE (pPCB->EapUIData.pEapUIData);
            pPCB->EapUIData.pEapUIData = NULL;
            pPCB->EapUIData.dwSizeOfEapUIData = 0;
        }
        pPCB->EapUIData.pEapUIData = MALLOC (dwSizeOfUIData);
        if (pPCB->EapUIData.pEapUIData == NULL)
        {
            TRACE1 (USER, "ElProcessInvokeInteractiveUIResponse: Error in allocating memory for UIData = %ld",
                    dwRetCode);
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pPCB->EapUIData.dwSizeOfEapUIData = dwSizeOfUIData;
        if ((dwSizeOfUIData != 0) && (pbUIData != NULL))
        {
            memcpy ((BYTE *)pPCB->EapUIData.pEapUIData,
                (BYTE *)pbUIData, 
                dwSizeOfUIData);
        }

        pPCB->EapUIData.dwContextId = pPCB->dwUIInvocationId;

        pPCB->fEapUIDataReceived = TRUE;

        TRACE0 (USER, "ElProcessInvokeInteractiveUIResponse: Calling ElEapWork");

        // Provide UI data to EAP Dll for processing
        // EAP will send out response if required

        if ((dwRetCode = ElEapWork (
                                pPCB,
                                NULL)) != NO_ERROR)
        {
            TRACE1 (USER, "ElProcessInvokeInteractiveUIResponse: ElEapWork failed with error = %ld",
                    dwRetCode);
            break;
        }
                
        // Reset the state 
        pPCB->EapUIState &= ~EAPUISTATE_WAITING_FOR_UI_RESPONSE;

        TRACE0 (USER, "ElProcessInvokeInteractiveUIResponse: ElEapWork completed successfully");

    } while (FALSE);

    // Cleanup
    if (dwRetCode != NO_ERROR)
    {
        if (pPCB->EapUIData.pEapUIData != NULL)
        {
            FREE (pPCB->EapUIData.pEapUIData);
            pPCB->EapUIData.pEapUIData = NULL;
            pPCB->EapUIData.dwSizeOfEapUIData = 0;
        }
    }

    if (fPCBLocked)
    {
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));
    }

    if (fPortReferenced)
    {
        EAPOL_DEREFERENCE_PORT (pPCB);
    }

    TRACE1 (USER, "ElProcessInvokeInteractiveUIResponse completed with error %ld", 
            dwRetCode);

    return dwRetCode;
}


//
// ElCreateAndSendIdentityResponse
//
// Description:
//
// Function called send out Identity Response packet
// 
// Arguments:
//  pPCB - Port Control Block for appropriate interface
//  pEAPUIContext - UI context blob
//
// Return values:
//  NO_ERROR -  success
//  !NO_ERROR - error
//
//

DWORD
ElCreateAndSendIdentityResponse (
        IN      EAPOL_PCB               *pPCB,
        IN      EAPOL_EAP_UI_CONTEXT    *pEAPUIContext
        )
{
    PPP_EAP_PACKET      *pSendBuf = NULL;
    EAPOL_PACKET        *pEapolPkt = NULL;
    WORD                wSizeOfEapPkt = 0;
    DWORD               dwIdentityLength = 0;
    DWORD               dwRetCode = NO_ERROR;

    do
    {
        // Create buffer for EAPOL + EAP and pass pointer to EAP header

        pEapolPkt = (EAPOL_PACKET *) MALLOC (MAX_EAPOL_BUFFER_SIZE); 

        TRACE1 (EAPOL, "ElCreateAndSendIdResp: EapolPkt created at %p", pEapolPkt);

        if (pEapolPkt == NULL)
        {
            TRACE0 (EAPOL, "ElCreateAndSendIdResp: Error allocating EAP buffer");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Point to EAP header
        pSendBuf = (PPP_EAP_PACKET *)((PBYTE)pEapolPkt + sizeof (EAPOL_PACKET) - 1);

        pSendBuf->Code  = EAPCODE_Response;
        pSendBuf->Id    = (BYTE)pPCB->bCurrentEAPId;

        if (pPCB->pszIdentity != NULL)
        {
            dwIdentityLength = strlen (pPCB->pszIdentity);
        }
        else
        {
            dwIdentityLength = 0;
        }

        HostToWireFormat16 (
            (WORD)(PPP_EAP_PACKET_HDR_LEN+1+dwIdentityLength),
            pSendBuf->Length );

        strncpy ((CHAR *)pSendBuf->Data+1, (CHAR *)pPCB->pszIdentity, 
                dwIdentityLength);

        TRACE1 (EAPOL, "ElCreateAndSendIdResp: Identity sent out = %s", 
                pPCB->pszIdentity);

        pSendBuf->Data[0] = EAPTYPE_Identity;

        // Indicate to EAPOL what is length of the EAP packet
        wSizeOfEapPkt = (WORD)(PPP_EAP_PACKET_HDR_LEN+
                                    1+dwIdentityLength);

        // Send out EAPOL packet

        memcpy ((BYTE *)pEapolPkt->EthernetType, 
                (BYTE *)pPCB->bEtherType, 
                SIZE_ETHERNET_TYPE);
        pEapolPkt->ProtocolVersion = pPCB->bProtocolVersion;
        pEapolPkt->PacketType = EAP_Packet;

        HostToWireFormat16 ((WORD) wSizeOfEapPkt,
                (BYTE *)pEapolPkt->PacketBodyLength);

        // Make a copy of the EAPOL packet in the PCB
        // Will be used during retransmission

        if (pPCB->pbPreviousEAPOLPkt != NULL)
        {
            FREE (pPCB->pbPreviousEAPOLPkt);
        }
        pPCB->pbPreviousEAPOLPkt = 
            MALLOC (sizeof (EAPOL_PACKET)+wSizeOfEapPkt-1);

        if (pPCB->pbPreviousEAPOLPkt == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        memcpy (pPCB->pbPreviousEAPOLPkt, pEapolPkt, 
                sizeof (EAPOL_PACKET)+wSizeOfEapPkt-1);

        pPCB->dwSizeOfPreviousEAPOLPkt = 
            sizeof (EAPOL_PACKET)+wSizeOfEapPkt-1;

        pPCB->dwPreviousId = pPCB->bCurrentEAPId;

        // Send packet out on the port
        dwRetCode = ElWriteToPort (pPCB,
                        (CHAR *)pEapolPkt,
                        sizeof (EAPOL_PACKET)+wSizeOfEapPkt-1);
        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAPOL, "ElCreateAndSendIdResp: Error in writing EAP_Packet to port %ld",
                    dwRetCode);
            break;
        }

    }
    while (FALSE);

    if (pEapolPkt != NULL)
    {
        FREE (pEapolPkt);
    }

    return dwRetCode;
}


//
// ElSendGuestIdentityResponse
//
// Description:
//
// Function called send out Guest Identity Response packet
// 
// Arguments:
//  pEAPUIContext - UI context blob
//
// Return values:
//  NO_ERROR    - success
//  !NO_ERROR   - failure
//

DWORD
ElSendGuestIdentityResponse (
        IN      EAPOL_EAP_UI_CONTEXT    *pEAPUIContext
        )
{
    EAPOL_PCB   *pPCB = NULL;
    BOOLEAN     fPortReferenced = FALSE;
    BOOLEAN     fPCBLocked = FALSE;
    DWORD       dwRetCode = NO_ERROR;

    do
    {
        ACQUIRE_WRITE_LOCK (&g_PCBLock);

        if ((pPCB = ElGetPCBPointerFromPortGUID (pEAPUIContext->wszGUID)) != NULL)
        {
            if (EAPOL_REFERENCE_PORT (pPCB))
            {
                fPortReferenced = TRUE;
            }
            else
            {
                pPCB = NULL;
            }
        }

        RELEASE_WRITE_LOCK (&g_PCBLock);

        if (pPCB == NULL)
        {
            break;
        }

        ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

        fPCBLocked = TRUE;

        // Send the identity out as a EAP-Response packet

        if (pPCB->EapUIState != EAPUISTATE_WAITING_FOR_IDENTITY)
        {
            TRACE2 (USER, "ElSendGuestIdentityResponse: PCB EapUIState has changed to (%ld), expected = (%ld)",
                    pPCB->EapUIState, EAPUISTATE_WAITING_FOR_IDENTITY);
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        if (pPCB->dwUIInvocationId != pEAPUIContext->dwContextId)
        {
            TRACE2 (USER, "ElSendGuestIdentityResponse: PCB UI Id has changed to (%ld), expected = (%ld)",
                    pPCB->dwUIInvocationId, pEAPUIContext->dwContextId);
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        if (pPCB->bCurrentEAPId != pEAPUIContext->dwEapId)
        {
            TRACE2 (USER, "ElSendGuestIdentityResponse: PCB EAP Id has changed to (%ld), expected = (%ld)",
                    pPCB->bCurrentEAPId, pEAPUIContext->dwEapId);
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        if (pPCB->pszIdentity != NULL)
        {
            FREE (pPCB->pszIdentity);
            pPCB->pszIdentity = NULL;
        }

        // Do not flag that identity was received
        // Reset the UI state though for state machine to proceed
        pPCB->EapUIState &= ~EAPUISTATE_WAITING_FOR_IDENTITY;
        pPCB->PreviousAuthenticationType = EAPOL_UNAUTHENTICATED_ACCESS;

        if ((dwRetCode = ElCreateAndSendIdentityResponse (
                            pPCB, pEAPUIContext)) != NO_ERROR)
        {
            TRACE1 (USER, "ElSendGuestIdentityResponse: ElCreateAndSendIdentityResponse failed with error %ld",
                    dwRetCode);
            break;
        }
    }
    while (FALSE);

    if (fPCBLocked)
    {
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));
    }

    if (fPortReferenced)
    {
        EAPOL_DEREFERENCE_PORT (pPCB);
    }

    return dwRetCode;
}


//
// ElValidateInteractiveRPCClient
//
// Description:
//
// Function called to validate if RPC call is from interactive client
// 
// Arguments:
//
// Return values:
//  NO_ERROR    - success
//  !NO_ERROR   - failure
//

DWORD
ElValidateInteractiveRPCClient (
        )
{
    HANDLE  hUserToken = INVALID_HANDLE_VALUE;
    TOKEN_USER          *pUserTokenData = NULL;
    BOOLEAN fRevertToSelf = FALSE;
    RPC_STATUS  RpcStatus = RPC_S_OK;
    DWORD   dwSizeNeeded = 0;
    DWORD   dwRetCode = NO_ERROR, dwRetCode1 = NO_ERROR;
    
    do
    {
        if ((RpcStatus = RpcImpersonateClient(0)) != RPC_S_OK)
        {
            dwRetCode = ERROR_ACCESS_DENIED;
            break;
        }
        fRevertToSelf = TRUE;

        // Get an impersonation token with the client's security context.
        if (!OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, 
                    TRUE, &hUserToken ))
        {
            dwRetCode = GetLastError ();
            break;
        }

        if (hUserToken != NULL)
        {
            dwSizeNeeded = 0;
            if (!GetTokenInformation(hUserToken, TokenSessionId, 0, 0, &dwSizeNeeded))
            {
                if ((dwRetCode = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
                {
                    pUserTokenData = (TOKEN_USER *) MALLOC (dwSizeNeeded);
                    if (pUserTokenData == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (ANY,"ElValidateInteractiveRPCClient: Allocation for UserTokenData failed");
                        break;
                    }
                    // Reset error code since we are continuing processing
                    // This was a valid scenario
                    dwRetCode = NO_ERROR;
                }
                else
                {
                    TRACE1 (ANY,"ElValidateInteractiveRPCClient: Error in GetTokenInformation = %ld",
                            dwRetCode);
                    break;
                }

                if (!GetTokenInformation (hUserToken,
                                            TokenSessionId,
                                            pUserTokenData,
                                            dwSizeNeeded,
                                            &dwSizeNeeded))
                {
                    dwRetCode = GetLastError ();
                    
                    TRACE1 (ANY,"ElValidateInteractiveRPCClient: GetTokenInformation failed with error %ld",
                            dwRetCode);
                    break;
                }
            }
            else
            {
                TRACE0 (ANY,"ElValidateInteractiveRPCClient: *No* error in GetTokenInformation, when error expected");
                dwRetCode = ERROR_ACCESS_DENIED;
                break;
            }

            if (g_dwCurrentSessionId != *((DWORD *)pUserTokenData))
            {
                TRACE2 (ANY, "ElValidateInteractiveRPCClient: RPC call from invalid user (%ld), valid = (%ld)",
                        *((DWORD *)pUserTokenData), g_dwCurrentSessionId);
                dwRetCode = ERROR_ACCESS_DENIED;
            }
        }
        else
        {
            dwRetCode = ERROR_ACCESS_DENIED;
            break;
        }
    }
    while (FALSE);

    if (hUserToken != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hUserToken);
    }
    if (fRevertToSelf)
    {
        dwRetCode1 = RpcRevertToSelf();
        if (dwRetCode1 != NO_ERROR)
        {
            dwRetCode = dwRetCode1;
        }
    }
    if (pUserTokenData != NULL)
    {
        FREE (pUserTokenData);
    }

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\eapol\service\svcmain.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    svcmain.c

Abstract:

    This module contains code for starting off, shutting down and 
    handling device addition/removal request for the EAPOL module. 


Revision History:

    sachins, Apr 25 2000, Created

Notes:
    EAPOL_SERVICE if defined, on compilation, a .exe version is created.
    If not defined, on compilation, a .lib is created, with entry 
    points defined, which netman calls into.

--*/

#include "pcheapol.h"
#pragma hdrstop

extern
VOID
EAPOLServiceMain (
    IN DWORD        argc,
    IN LPWSTR       *lpwsServiceArgs
    );

DWORD
WINAPI
EAPOLServiceMainWorker (
        IN  PVOID       pvContext
        );

#ifdef EAPOL_SERVICE

//
// main
//
// Description: Will simply register the entry point of the EAPOL 
//		service with the service controller. The service controller
//		will capture this thread. It will be freed only when
//		the service is shutdown. At that point we will simply exit
//		the process.
//
// Return values:	none
//

void
_cdecl
main ( int argc, unsigned char * argv[] )
{
    SERVICE_TABLE_ENTRY	EapolServiceDispatchTable[2];

    UNREFERENCED_PARAMETER( argc );
    UNREFERENCED_PARAMETER( argv );

    EapolServiceDispatchTable[0].lpServiceName = EAPOL_SERVICE_NAME;
    EapolServiceDispatchTable[0].lpServiceProc = EAPOLServiceMain;
    EapolServiceDispatchTable[1].lpServiceName = NULL;
    EapolServiceDispatchTable[1].lpServiceProc = NULL;

    if ( !StartServiceCtrlDispatcher( EapolServiceDispatchTable ) )
    {
    }

    ExitProcess(0);
}

//
// EAPOLAnnounceServiceStatus
//
// Description: Will simly call SetServiceStatus to inform the service
//      control manager of this service's current status.
//
// Return values: none
//

VOID
EAPOLAnnounceServiceStatus (
    VOID
    )
{
    BOOL dwRetCode;

    //
    // Increment the checkpoint in a pending state:
    //

    switch( g_ServiceStatus.dwCurrentState )
    {
    case SERVICE_START_PENDING:
    case SERVICE_STOP_PENDING:

        g_ServiceStatus.dwCheckPoint++;

        break;

    default:
        break;
    }

    dwRetCode = SetServiceStatus( g_hServiceStatus,
                                  &g_ServiceStatus );

    if ( dwRetCode == FALSE )
    {
	TRACE1 (INIT, "Error: SetServiceStatus returned %d\n", 
		GetLastError() );
    }
}

#endif


//
// EAPOLCleanUp
//
// Description: Will free any allocated memory, deinitialize RPC, deinitialize
//              the kernel-mode server and unload it if it was loaded.
//              This could have been called due to an error on SERVICE_START
//              or normal termination.
//
// Return values: none
//

VOID
EAPOLCleanUp (
    IN DWORD    dwError
    )
{
    DWORD   dwEventStatus = 0;
    SERVICE_STATUS  ServiceStatus;
    DWORD   dwRetCode = NO_ERROR;

    if (g_hEventTerminateEAPOL == NULL)
    {
        return;
    }

    // 
    // Check if have already gone through EAPOLCleanUp before
    // Return if so
    //

    if (( dwEventStatus = WaitForSingleObject (
                g_hEventTerminateEAPOL,
                0)) == WAIT_FAILED)
    {
        dwRetCode = GetLastError ();
        if ( g_dwTraceId != INVALID_TRACEID )
	{
            TRACE1 (INIT, "EAPOLCleanUp: WaitForSingleObject failed with error %ld, Terminating cleanup",
                dwRetCode);
	}

        // log

        return;
    }

    if (dwEventStatus == WAIT_OBJECT_0)
    {
        if ( g_dwTraceId != INVALID_TRACEID )
	{
            TRACE0 (INIT, "EAPOLCleanUp: g_hEventTerminateEAPOL already signaled, returning");
	}
        return;
    }

#ifdef EAPOL_SERVICE

    //
    // Announce that we are stopping
    //

    g_ServiceStatus.dwCurrentState     = SERVICE_STOP_PENDING;
    g_ServiceStatus.dwControlsAccepted = 0;
    g_ServiceStatus.dwCheckPoint       = 1;
    g_ServiceStatus.dwWaitHint         = 200000;

    EAPOLAnnounceServiceStatus();

#endif

    //
    // Tear down and free everything
    //

    //
    // Set event to indicate to waiting threads to terminate
    //

    if ( !SetEvent (g_hEventTerminateEAPOL) )
    {
        dwRetCode = GetLastError();
        if ( g_dwTraceId != INVALID_TRACEID )
	{
            TRACE1 (INIT, "EAPOLCleanUp: SetEvent for g_hEventTerminateEAPOL failed with error %ld",
                dwRetCode);
	}

        // log
    }

    //
    // Shutdown device related stuff
    // Close handles to NDISUIO
    // Shutdown EAPOL State machine
    //
    if ( ( dwRetCode = ElMediaDeInit()) != NO_ERROR )
    {
        if ( g_dwTraceId != INVALID_TRACEID )
        {
            TRACE1 (INIT, "Media DeInit failed with dwRetCode = %ld\n", 
                    dwRetCode );
        }

        dwRetCode = NO_ERROR;
    }
	else
	{
            if ( g_dwTraceId != INVALID_TRACEID )
	    {
        	TRACE1 (INIT, "Media DeInit succeeded with dwRetCode = %ld\n", 
                   dwRetCode );
	    }
	}

    if (READ_WRITE_LOCK_CREATED(&(g_PolicyLock)))
    {
        ACQUIRE_WRITE_LOCK (&g_PolicyLock);
        if (g_pEAPOLPolicyList != NULL)
        {
            ElFreePolicyList (g_pEAPOLPolicyList);
            g_pEAPOLPolicyList = NULL;
        }
        RELEASE_WRITE_LOCK (&g_PolicyLock);
    }

    if (READ_WRITE_LOCK_CREATED(&(g_PolicyLock)))
    {
        DELETE_READ_WRITE_LOCK(&(g_PolicyLock));
    }

#ifdef EAPOL_SERVICE

    if ( dwError == NO_ERROR )
    {
        g_ServiceStatus.dwWin32ExitCode = NO_ERROR;
    }
    else
    {
        g_ServiceStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
    }

    g_ServiceStatus.dwCurrentState       = SERVICE_STOPPED;
    g_ServiceStatus.dwControlsAccepted   = 0;
    g_ServiceStatus.dwCheckPoint         = 0;
    g_ServiceStatus.dwWaitHint           = 0;
    g_ServiceStatus.dwServiceSpecificExitCode = dwError;

    EAPOLAnnounceServiceStatus();

    if (!CloseHandle(g_hStopService))
    {
        if ( g_dwTraceId != INVALID_TRACEID )
        {
            TRACE1 (INIT, "EAPOLCleanup: CloseHandle failed with error %ld",
                GetLastError());
        }
    }

#endif

    if ( g_dwTraceId != INVALID_TRACEID )
    {
        TRACE1 (INIT, "EAPOLCleanup completed with error %d\n", dwError );
        TraceDeregisterA( g_dwTraceId );
        g_dwTraceId = INVALID_TRACEID;
    }

    EapolLogInformation (EAPOL_LOG_SERVICE_RUNNING, 0, NULL);

    if ( g_hLogEvents != NULL)
    {
        EapolLogInformation (EAPOL_LOG_SERVICE_STOPPED, 0, NULL);
        RouterLogDeregisterW( g_hLogEvents );
        g_hLogEvents = NULL;
    }

    if (g_hEventTerminateEAPOL != NULL)
    {
        CloseHandle (g_hEventTerminateEAPOL);
        g_hEventTerminateEAPOL = NULL;
    }

    return;
}


#ifdef EAPOL_SERVICE

//
// ServiceHandlerEx
//
// Description: Will respond to control requests from the service controller.
//
// Return values:     none
//
//

DWORD
ServiceHandlerEx (
    IN DWORD        dwControlCode,
    IN DWORD        dwEventType,
    IN LPVOID       lpEventData,
    IN LPVOID       lpContext
    )
{
    DWORD dwRetCode = NO_ERROR;

    switch( dwControlCode )
    {
    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        if ( ( g_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
            ||
            ( g_ServiceStatus.dwCurrentState == SERVICE_STOPPED ))
        {
            break;
        }

        TRACE0 (INIT, "ServiceHandlerEx: SERVICE_CONTROL_ STOP or SHUTDOWN event called");

        //
        // Announce that we are stopping
        //

        g_ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        g_ServiceStatus.dwControlsAccepted = 0;
        g_ServiceStatus.dwCheckPoint       = 1;
        g_ServiceStatus.dwWaitHint         = 200000;

        EAPOLAnnounceServiceStatus();

        SetEvent( g_hStopService );

        return( NO_ERROR );

        break;

    case SERVICE_CONTROL_DEVICEEVENT:
        if ( ( g_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
            ||
            ( g_ServiceStatus.dwCurrentState == SERVICE_STOPPED ))
        {
            break;
        }

        TRACE0 (INIT, "ServiceHandlerEx: SERVICE_CONTROL_DEVICEEVENT event called");
        // Received notification that some LAN interface was added or deleted

        if (lpEventData != NULL)
        {
            // Call device notification handler

            if ((dwRetCode = ElDeviceNotificationHandler (
                            lpEventData, dwEventType)) != NO_ERROR)
            {
        
                TRACE1 (INIT, "ServiceHandlerEx: ElDeviceNotificationHandler faield with error %ld",
                        dwRetCode);
                break;
            }
        }

    default:

        return( ERROR_CALL_NOT_IMPLEMENTED );

        break;
    }

    return( dwRetCode );
}

#endif


//
// EAPOLServiceMain
//
// Description: This is the main procedure for the EAPOL Server Service. It
//              will be called when the service is supposed to start itself.
//              It will do all service wide initialization.
//
// Return values:     none
//

VOID
WINAPI
EAPOLServiceMain (
    IN DWORD    argc,   // Command line arguments. Will be ignored.
    IN LPWSTR * lpwsServiceArgs
    )
{
    DWORD   dwRetCode = NO_ERROR;

    UNREFERENCED_PARAMETER( argc );
    UNREFERENCED_PARAMETER( lpwsServiceArgs );

    //
    // Initialize globals
    //

    g_hEventTerminateEAPOL = NULL;
    g_lWorkerThreads = 0;
    g_lPCBContextsAlive = 0;
    g_hLogEvents  = NULL;
    g_dwTraceId = INVALID_TRACEID;
    g_hStopService = NULL;
    g_dwModulesStarted = 0;
    g_hNLA_LPC_Port = NULL;
    g_fUserLoggedOn = FALSE;
    g_hTimerQueue = NULL;
    g_hDeviceNotification = NULL;
    g_fTrayIconReady = FALSE;
    g_dwmaxStart = EAPOL_MAX_START;
    g_dwstartPeriod = EAPOL_START_PERIOD;
    g_dwauthPeriod = EAPOL_AUTH_PERIOD;
    g_dwheldPeriod = EAPOL_HELD_PERIOD;
    g_dwSupplicantMode = EAPOL_DEFAULT_SUPPLICANT_MODE;
    g_dwEAPOLAuthMode = EAPOL_DEFAULT_AUTH_MODE;
    g_pEAPOLPolicyList = NULL;
    g_dwCurrentSessionId = 0xffffffff;

#ifdef EAPOL_SERVICE

    g_hServiceStatus = RegisterServiceCtrlHandlerEx(
                                            TEXT("EAPOL"),
                                            ServiceHandlerEx,
                                            NULL );

    if ( !g_hServiceStatus )
    {
        break;
    }

    g_ServiceStatus.dwServiceType  = SERVICE_WIN32_SHARE_PROCESS;
    g_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;

    EAPOLAnnounceServiceStatus();

#endif

    //
    // Create event that will be used to indicate EAPOL shutdown 
    //

    g_hEventTerminateEAPOL = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( g_hEventTerminateEAPOL == (HANDLE)NULL )
    {
	    dwRetCode = GetLastError ();
        EAPOLCleanUp ( dwRetCode );
        return;
    }

    //
    // Register for debug tracing via rtutils.dll
    //

    g_dwTraceId = TraceRegister (L"EAPOL");

    if ( g_dwTraceId == INVALID_TRACEID )
    {
	    dwRetCode = GetLastError ();
        EAPOLCleanUp ( dwRetCode );
        return;
    }

    //
    // Register for event logging via rtutils.dll
    //

    g_hLogEvents = RouterLogRegisterW(L"EAPOL");

    if ( g_hLogEvents == NULL )
    {
	    dwRetCode = GetLastError ();
        TRACE1 (INIT, "EAPOLServiceMainWorker: RouterLogRegisterW failed with error %ld",
               dwRetCode); 
        EAPOLCleanUp ( dwRetCode );
        return;
    }

    if (dwRetCode = CREATE_READ_WRITE_LOCK(&(g_PolicyLock), "PCY") != NO_ERROR)
    {
        TRACE1(INIT, "EAPOLServiceMainWorker: Error %d creating g_PolicyLock read-write-lock", dwRetCode);
        EAPOLCleanUp ( dwRetCode );
        return;
    }
    
    // Queue a worker item to do the heavy-duty work during initialization
    // This will not hold up the main service thread

    InterlockedIncrement (&g_lWorkerThreads);

    if (!QueueUserWorkItem(
        (LPTHREAD_START_ROUTINE)EAPOLServiceMainWorker,
        NULL,
        WT_EXECUTELONGFUNCTION))
    {
        dwRetCode = GetLastError();
        InterlockedDecrement (&g_lWorkerThreads);
        return;
    }
}


DWORD
WINAPI
EAPOLServiceMainWorker (
        IN  PVOID       pvContext
        )
{

    DWORD       dwRetCode = NO_ERROR;

    do
    {

#ifdef EAPOL_SERVICE

    //
    // Announce that we have successfully started.
    //

    g_ServiceStatus.dwCurrentState      = SERVICE_RUNNING;
    g_ServiceStatus.dwCheckPoint        = 0;
    g_ServiceStatus.dwWaitHint          = 0;
    g_ServiceStatus.dwControlsAccepted  = SERVICE_ACCEPT_STOP;

    EAPOLAnnounceServiceStatus();

    //
    // Create event that will be used to shutdown the EAPOL service
    //

    g_hStopService = CreateEvent ( NULL, TRUE, FALSE, NULL );

    if ( g_hStopService == (HANDLE)NULL )
    {
	    dwRetCode = GetLastError ();
        TRACE1 (INIT, "EAPOLServiceMainWorker: CreateEvent failed with error %ld",
                dwRetCode);
        break;
    }

#endif

    if ((dwRetCode = ElUpdateRegistry ()) != NO_ERROR)
    {
        TRACE1 (INIT, "ElUpdateRegistry failed with error (%ld)",
                dwRetCode);
        // Ignore registry update errors
        dwRetCode = NO_ERROR;
    }

    //
    // Initialize media related stuff
    // Interfaces will be enumerated, handles to NDISUIO driver will be opened,
    // EAPOL will be initialized
    //

    if ( ( dwRetCode = ElMediaInit ()) != NO_ERROR )
    {
        TRACE1 (INIT, "Media Init failed with dwRetCode = %d\n", 
                   dwRetCode );
        break;
    }
	else
	{
        TRACE1 (INIT, "Media Init succeeded with dwRetCode = %d\n", 
                   dwRetCode );
	}

    TRACE0 (INIT, "EAPOL started successfully\n" );

    // EapolLogInformation (EAPOL_LOG_SERVICE_STARTED, 0, NULL);

#ifdef EAPOL_SERVICE

    //
    // Just wait here for EAPOL service to terminate.
    //

    dwRetCode = WaitForSingleObject( g_hStopService, INFINITE );

    if ( dwRetCode == WAIT_FAILED )
    {
        dwRetCode = GetLastError();
    }
    else
    {
        dwRetCode = NO_ERROR;
    }

    TRACE0 (INIT, "Stopping EAPOL gracefully\n" );

    EAPOLCleanUp ( dwRetCode );

#endif

    }
    while (FALSE);

    InterlockedDecrement (&g_lWorkerThreads);

    if (dwRetCode != NO_ERROR)
    {
        EAPOLCleanUp ( dwRetCode );
    }

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\inc\intfhdl.h ===
#pragma once

extern HINSTANCE g_hInstance;

typedef struct _HSH_HANDLE
{
    INT         nRefCount;
    HANDLE      hdlInterf;
} HSH_HANDLE, *PHSH_HANDLE;

DWORD 
OpenIntfHandle(
    LPWSTR wszGuid,
    PHANDLE pIntfHdl);

DWORD
CloseIntfHandle(
    LPWSTR wszGuid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\inc\policycf.h ===
#ifndef _POLICYCF_H
#define _POLICYCF_H

#define CFSTR_WIFIPOLICYOBJECT   L"WIFI_POLICYOBJECT"
#define POByteOffset(base, offset) (((LPBYTE)base)+offset)

typedef struct
{
	DWORD m_dwInterfaceFlags;
	long  m_lMMCUpdateHandle;

	DWORD m_dwOffsetObjClass;
	DWORD m_dwOffsetObjPath;
	DWORD m_dwOffsetRemoteMachineName;
} POLICYOBJECTSTRUCT;

class POLICYOBJECT
{
public:
	// Policy Object flags
	#define POFLAG_INVALID  0x00000000
	#define POFLAG_NEW		0x00000002
	#define POFLAG_EDIT		0x00000004
	#define POFLAG_APPLY	0x00000008
	#define POFLAG_CANCEL	0x00000010
	#define POFLAG_LOCAL	0x00000020
	#define POFLAG_GLOBAL   0x00000040
	#define POFLAG_REMOTE	0x00000080


	POLICYOBJECT ()	
	{
		dwInterfaceFlags (POFLAG_INVALID);
		lMMCUpdateHandle (0);
	};
	~POLICYOBJECT () {};

	// memory allocation helpers
	int DataGlobalAllocLen ()
	{
		return (sizeof (POLICYOBJECTSTRUCT) + 
			m_sObjClass.GetLength()*sizeof(wchar_t)+sizeof(wchar_t) + 
			m_sObjPath.GetLength()*sizeof(wchar_t)+sizeof(wchar_t) +
			m_sRemoteMachineName.GetLength()*sizeof(wchar_t)+sizeof(wchar_t));
	}

	HRESULT FromObjMedium (STGMEDIUM* pObjMedium)
	{
		HRESULT hr = E_UNEXPECTED;
	    POLICYOBJECTSTRUCT* pPolicyStruct = (POLICYOBJECTSTRUCT*) pObjMedium->hGlobal;	
		if (pPolicyStruct)
		{
			m_dwInterfaceFlags = pPolicyStruct->m_dwInterfaceFlags;
			m_lMMCUpdateHandle = pPolicyStruct->m_lMMCUpdateHandle;

			m_sObjPath		 = (LPWSTR)POByteOffset(pPolicyStruct, pPolicyStruct->m_dwOffsetObjPath);
			m_sObjClass		 = (LPWSTR)POByteOffset(pPolicyStruct, pPolicyStruct->m_dwOffsetObjClass);
			m_sRemoteMachineName = (LPWSTR)POByteOffset(pPolicyStruct, pPolicyStruct->m_dwOffsetRemoteMachineName);

			hr = S_OK;
		}
		return hr;
	}

	HRESULT ToPolicyStruct (POLICYOBJECTSTRUCT* pPolicyStruct)
	{
		HRESULT hr = E_UNEXPECTED;
		if (pPolicyStruct)
		{
			pPolicyStruct->m_dwInterfaceFlags = m_dwInterfaceFlags;
			pPolicyStruct->m_lMMCUpdateHandle = m_lMMCUpdateHandle;

			// store ObjPath
			int istrlenObjPath =  m_sObjPath.GetLength()*sizeof(wchar_t)+sizeof(wchar_t);
			int iStructLen = sizeof (POLICYOBJECTSTRUCT);
			LONG_PTR addr = ((LONG_PTR)(pPolicyStruct)) + iStructLen;
			memcpy((void*)addr,m_sObjPath,istrlenObjPath);
			pPolicyStruct->m_dwOffsetObjPath=iStructLen;

			// store ObjClass
			// using the current istrlen (length of ObjPath) determine new address and offset for the class
			addr = addr + istrlenObjPath;
			pPolicyStruct->m_dwOffsetObjClass=iStructLen+istrlenObjPath;
			// get new strlen and copy the class in
			int istrlenObjClass = m_sObjClass.GetLength()*sizeof(wchar_t)+sizeof(wchar_t);
			memcpy((void*)addr,m_sObjClass,istrlenObjClass);

			// store RemoteMachineName
			// using istrlenObjClass (length of ObjClass) determine new address and offset for the class
			addr = addr + istrlenObjClass;
			pPolicyStruct->m_dwOffsetRemoteMachineName=iStructLen+istrlenObjPath+istrlenObjClass;
			// get new strlen and copy the class in
			int istrlenRemoteMachineName = m_sRemoteMachineName.GetLength()*sizeof(wchar_t)+sizeof(wchar_t);
			memcpy((void*)addr,m_sRemoteMachineName,istrlenRemoteMachineName);

			hr = S_OK;
		}
		return hr;
	}

	// member access methods
	DWORD dwInterfaceFlags() {return m_dwInterfaceFlags;}
	void dwInterfaceFlags (DWORD dw) {m_dwInterfaceFlags = dw;}

	long lMMCUpdateHandle() {return m_lMMCUpdateHandle;}
	void lMMCUpdateHandle (long l) {m_lMMCUpdateHandle = l;}

	CString ObjClass() {return m_sObjClass;}
	void ObjClass (CString s) {m_sObjClass = s;}

	CString ObjPath() {return m_sObjPath;}
	void ObjPath (CString s) {m_sObjPath = s;}

	CString RemoteMachineName() {return m_sRemoteMachineName;}
	void RemoteMachineName (CString s) {m_sRemoteMachineName = s;}

private:
	DWORD m_dwInterfaceFlags;
	long  m_lMMCUpdateHandle;

	CString m_sObjClass;
	CString m_sObjPath;
	CString m_sRemoteMachineName;
};

#endif // _POLICYCF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\inc\notify.h ===
#pragma once

// Service Control Manager notifications
#define WZCNOTIF_UNKNOWN            0
#define WZCNOTIF_DEVICE_ARRIVAL     1
#define WZCNOTIF_DEVICE_REMOVAL     2
// WMI notifications
#define WZCNOTIF_ADAPTER_BIND       3
#define WZCNOTIF_ADAPTER_UNBIND     4
#define WZCNOTIF_MEDIA_CONNECT      5
#define WZCNOTIF_MEDIA_DISCONNECT   6
#define WZCNOTIF_WZC_CONNECT        7

// datatype describing the WZC specific notifcation sent to the upper levels
// whenver a WZC Configuration has been successfully plumbed down.
typedef struct _WZC_CONFIG_NOTIF
{
    DWORD               dwSessionHdl;
    NDIS_802_11_SSID    ndSSID;
    RAW_DATA            rdEventData;
    WCHAR               wszGuid[1];
} WZC_CONFIG_NOTIF, *PWZC_CONFIG_NOTIF;

// the datatype below is used to bring all different types of notifications
// to one common point within the Wireless Zero Configuration Service. Each
// type of notification should have a WZCNOTIF* constant defined and should
// enlist its specific data structure (with variable lenght probably) in the
// union from within the WZC_DEVICE_NOTIF structure
typedef struct _WZC_DEVICE_NOTIF
{
    DWORD       dwEventType;    // one of WZCNOTIF* values
    union
    {
        DEV_BROADCAST_DEVICEINTERFACE   dbDeviceIntf;   // filled in for SCM notifications
        WNODE_HEADER                    wmiNodeHdr;     // filled in for WMI notifications
        WZC_CONFIG_NOTIF                wzcConfig;      // null terminated guid name
    };
} WZC_DEVICE_NOTIF, *PWZC_DEVICE_NOTIF;

// Upper level app commands (might move to wzcsapi.h later)
#define WZCCMD_HARD_RESET           0
#define WZCCMD_SOFT_RESET           1
#define WZCCMD_CFG_NEXT             2   // cmd to switch to the next cfg in the list
#define WZCCMD_CFG_DELETE           3   // cmd to delete the currently plumbed cfg
#define WZCCMD_CFG_NOOP             4   // cmd no operation can be done on the crt config
#define WZCCMD_CFG_SETDATA          5   // cmd to set the BLOB associated with the crt config
#define WZCCMD_SKEY_QUERY           6   // cmd to retrieve the dynamic session keys
#define WZCCMD_SKEY_SET             7   // cmd to set the dynamic session keys

// (Upper level app -> WZC) interraction. Upper level app can partially control
// the functioning of WZC by providing certain stimulus to the state machine.
// Parameters:
//     dwCtrlCode:
//         [in] one of WZCCMD_* constants
//     wszIntfGuid:
//         [in] the guid of the interface to which the command is addressed
DWORD
RpcCmdInterface(
    IN DWORD        dwHandle,       // handle to check the validity of the command against the WZC state
    IN DWORD        dwCmdCode,      // one of the WZCCMD_* constants
    IN LPWSTR       wszIntfGuid,    // interface GUID to which the command is addressed
    IN PRAW_DATA    prdUserData);   // raw user data

// (Upper level app <- WZC) notification. Upper level app gets notifications
// from WZC through this call.
DWORD
ElMediaEventsHandler(
    IN PWZC_DEVICE_NOTIF  pwzcDeviceNotif);  // notification blob

// (Upper level app <- WZC) notification. Upper level app gets notified
// from WZC whenever the user is altering the list of preferred networks
DWORD
ElWZCCfgChangeHandler(
    IN LPWSTR   wszIntfGuid,
    PWZC_802_11_CONFIG_LIST pwzcCfgList);

DWORD
WZCSvcCheckRPCAccess(DWORD dwAccess);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\inc\wlstore2.h ===
#ifdef __cplusplus
extern "C" {
#endif

enum STORAGE_LOCATION {
        LOCATION_LOCAL=0,
        LOCATION_REMOTE,
        LOCATION_GLOBAL,
        LOCATION_CACHE,
        LOCATION_FILE,
        LOCATION_WMI,
    };





#include <wbemidl.h>
#include <wlrsop.h>
#include <wldefs.h>
#include <wlstructs.h>



DWORD
WirelessEnumPolicyData(
    HANDLE hPolicyStore,
    PWIRELESS_POLICY_DATA ** pppWirelessPolicyData,
    PDWORD pdwNumPolicyObjects
    );


DWORD
WirelessSetPolicyData(
    HANDLE hPolicyStore,
    PWIRELESS_POLICY_DATA pWirelessPolicyData
    );


DWORD
WirelessCreatePolicyData(
    HANDLE hPolicyStore,
    PWIRELESS_POLICY_DATA pWirelessPolicyData
    );


DWORD
WirelessDeletePolicyData(
    HANDLE hPolicyStore,
    PWIRELESS_POLICY_DATA pWirelessPolicyData
    );

DWORD
WirelessOpenPolicyStore(
    LPWSTR pszMachineName,
    DWORD dwTypeOfStore,
    LPWSTR pszFileName,
    HANDLE * phPolicyStore
    );

DWORD
WirelessGPOOpenPolicyStore(
    LPWSTR pszMachineName,
    DWORD dwTypeOfStore,
    LPWSTR pszDSGPOName,
    LPWSTR pszFileName,
    HANDLE * phPolicyStore
    );

DWORD
WMIOpenPolicyStore(
    LPWSTR pszMachineName,
    HANDLE * phPolicyStore
    );



DWORD
DirOpenPolicyStore(
    LPWSTR pszMachineName,
    HANDLE * phPolicyStore
    );

DWORD
DirGPOOpenPolicyStore(
    LPWSTR pszMachineName,
    LPWSTR pszGPOName,
    HANDLE * phPolicyStore
    );

DWORD
WirelessClosePolicyStore(
    HANDLE hPolicyStore
    );





DWORD
ComputeGPODirLocationName(
                       LPWSTR pszDirDomainName,
                       LPWSTR * ppszDirFQPathName
                       );




DWORD
WirelessRemovePSFromPolicy(
    PWIRELESS_POLICY_DATA pWirelessPolicyData,
    LPCWSTR pszSSID
    );

DWORD
WirelessRemovePSFromPolicyId(
    PWIRELESS_POLICY_DATA pWirelessPolicyData,
    DWORD dwId
    );

DWORD
WirelessAddPSToPolicy(
    PWIRELESS_POLICY_DATA pWirelessPolicyData,
    PWIRELESS_PS_DATA pWirelessPSData
    );

DWORD
WirelessSetPSDataInPolicy(
    PWIRELESS_POLICY_DATA pWirelessPolicyData,
    PWIRELESS_PS_DATA pWirelessPSData
    );


void
WirelessPolicyPSId(
    PWIRELESS_POLICY_DATA pWirelessPolicyData,
    LPCWSTR pszSSID,
    DWORD *dwId
    );

void
UpdateWirelessPSData(
    PWIRELESS_PS_DATA pWirelessPSData
    );

DWORD
WirelessSetPSDataInPolicyId(
    PWIRELESS_POLICY_DATA pWirelessPolicyData,
    PWIRELESS_PS_DATA pWirelessPSData
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\inc\wldefs.h ===
#include <wzcsapi.h>

#define WIRELESS_ACCESS_NETWORK_ANY 1
#define WIRELESS_ACCESS_NETWORK_AP 2
#define WIRELESS_ACCESS_NETWORK_ADHOC 3

#define WIRELESS_NETWORK_TYPE_ADHOC 1
#define WIRELESS_NETWORK_TYPE_AP 2

#define WIRELESS_8021X_MODE_DISABLE SUPPLICANT_MODE_0
#define WIRELESS_8021X_MODE_NO_TRANSMIT_EAPOLSTART_WIRED SUPPLICANT_MODE_1
#define WIRELESS_8021X_MODE_NAS_TRANSMIT_EAPOLSTART_WIRED SUPPLICANT_MODE_2
#define WIRELESS_8021X_MODE_TRANSMIT_EAPOLSTART_WIRED SUPPLICANT_MODE_3

#define WIRELESS_EAP_TYPE_TLS EAP_TYPE_TLS
#define WIRELESS_EAP_TYPE_MD5 EAP_TYPE_MD5

#define WIRELESS_CERT_TYPE_SMARTCARD EAPOL_CERT_TYPE_SMARTCARD
#define WIRELESS_CERT_TYPE_MC_CERT EAPOL_CERT_TYPE_MC_CERT

#define WIRELESS_MC_AUTH_TYPE_MC_NO_USER EAPOL_AUTH_MODE_0
#define WIRELESS_MC_AUTH_TYPE_USER_DONTCARE_MC EAPOL_AUTH_MODE_1
#define WIRELESS_MC_AUTH_TYPE_MC_ONLY EAPOL_AUTH_MODE_2

#define WIRELESS_MAX_START_DEFAULT 3
#define WIRELESS_START_PERIOD_DEFAULT 60
#define WIRELESS_AUTH_PERIOD_DEFAULT 60
#define WIRELESS_HELD_PERIOD_DEFAULT 60

#define ERROR_PS_NOT_PRESENT 10

#define WL_BLOB_MAJOR_VERSION 1
#define WL_BLOB_MINOR_VERSION 0



typedef struct _WIRELESS_PREFERRED_SETTING_DATA {
    DWORD dwPSLen;
    WCHAR pszWirelessSSID[32];
    DWORD dwWirelessSSIDLen;
    DWORD dwId;    
    DWORD dwWepEnabled;
    DWORD dwNetworkAuthentication;
    DWORD dwAutomaticKeyProvision;
    DWORD dwNetworkType;
    DWORD dwEnable8021x;
    DWORD dw8021xMode;
    DWORD dwEapType;
    LPBYTE  pbEAPData;
    DWORD dwEAPDataLen;
    DWORD dwMachineAuthentication;
    DWORD dwMachineAuthenticationType;
    DWORD dwGuestAuthentication;

    DWORD dwIEEE8021xMaxStart;
    DWORD dwIEEE8021xStartPeriod;
    DWORD dwIEEE8021xAuthPeriod;
    DWORD dwIEEE8021xHeldPeriod;

    DWORD dwWhenChanged;
    DWORD dwDescriptionLen;
    LPWSTR pszDescription;
                   
} WIRELESS_PS_DATA, *PWIRELESS_PS_DATA;

typedef struct _WIRELESS_POLICY_DATA {
    WORD wMajorVersion;
    WORD wMinorVersion;
    GUID  PolicyIdentifier;
    DWORD dwPollingInterval;
    DWORD dwDisableZeroConf;
    DWORD dwNetworkToAccess;
    DWORD dwConnectToNonPreferredNtwks;

    DWORD dwNumPreferredSettings;
    PWIRELESS_PS_DATA *ppWirelessPSData;

    DWORD dwWhenChanged;
    DWORD dwNumAPNetworks;
    LPWSTR pszWirelessName;
    LPWSTR pszOldWirelessName;
    LPWSTR pszDescription;
    PRSOP_INFO pRsopInfo;
    DWORD dwFlags;
} WIRELESS_POLICY_DATA, *PWIRELESS_POLICY_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\inc\wifipol.h ===
HANDLE hPolicyEngineThread;
DWORD dwPolicyEngineParam;



DWORD
InitPolicyEngine(
    DWORD dwParam, 
    HANDLE * hThread
    );

DWORD
TerminatePolicyEngine(
    HANDLE hThread
    );

 DWORD
 ReApplyPolicy8021x(
     );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\inc\wlstructs.h ===
#define WIRELESS_REGISTRY_PROVIDER     0
#define WIRELESS_DIRECTORY_PROVIDER    1
#define WIRELESS_FILE_PROVIDER         2
#define WIRELESS_WMI_PROVIDER          3

#define WLSTORE_READWRITE 0x00000000 
#define WLSTORE_READONLY  0x00000001



LPVOID
AllocPolMem(
    DWORD cb
    );

BOOL
FreePolMem(
    LPVOID pMem
    );

LPWSTR
AllocPolStr(
    LPCWSTR pStr
    );

BOOL
FreePolStr(
    LPWSTR pStr
    );

DWORD
ReallocatePolMem(
    LPVOID * ppOldMem,
    DWORD cbOld,
    DWORD cbNew
    );

BOOL
ReallocPolStr(
    LPWSTR *ppStr,
    LPWSTR pStr
    );



void
FreeMulWirelessPolicyData(
    PWIRELESS_POLICY_DATA * ppWirelessPolicyData,
    DWORD dwNumPolicyObjects
    );



DWORD
CopyWirelessPolicyData(
    PWIRELESS_POLICY_DATA pWirelessPolicyData,
    PWIRELESS_POLICY_DATA * ppWirelessPolicyData
    );


DWORD
UpdateWirelessPolicyData(
    PWIRELESS_POLICY_DATA pNewWirelessPolicyData,
    PWIRELESS_POLICY_DATA pWirelessPolicyData
    );

DWORD
UpdateWirelessPolicyDataWithPreferredSettings( 
    PWIRELESS_POLICY_DATA pNewWirelessPolicyData, 
    PWIRELESS_POLICY_DATA pWirelessPolicyData
    );


DWORD
CopyWirelessPSData(
    PWIRELESS_PS_DATA pWirelessPSData,
    PWIRELESS_PS_DATA * ppWirelessPSData
    );

DWORD
ModifyWirelessPSData(
    PWIRELESS_PS_DATA pNewWirelessPSData,
    PWIRELESS_PS_DATA pWirelessPSData
    );


void
FreeWirelessPolicyData(
    PWIRELESS_POLICY_DATA pWirelessPolicyData
    );

void
FreeWirelessPSData(
    PWIRELESS_PS_DATA pWirelessPSData
    );

DWORD
WirelessPSMoveUp(
    PWIRELESS_POLICY_DATA pWirelessPSData,
    DWORD dwIndex
    );

DWORD
WirelessPSMoveDown(
    PWIRELESS_POLICY_DATA pWirelessPSData,
    DWORD dwIndex
    );

void
FreeRsopInfo(
    PRSOP_INFO pRsopInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\monitor\database\externs.h ===
extern TABLE_INFO gLogRecordTable[];

extern DWORD RECORD_TABLE_NUM_COLS;

extern PSESSION_CONTAINER gpSessionCont;

extern DWORD gdwCurrentHeader;
extern DWORD gdwCurrentTableSize;
extern DWORD gdwCurrentMaxRecordID;

extern JET_INSTANCE gJetInstance;

extern WZC_RW_LOCK gWZCDbSessionRWLock;

extern PWZC_RW_LOCK gpWZCDbSessionRWLock;

extern DWORD gdwWZCDbSessionCount;

extern SESSION_CONTAINER gAppendSessionCont;

extern PSESSION_CONTAINER gpAppendSessionCont;

extern BOOL gbDBOpened;

extern BOOL gbEnableDbLogging;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\inc\wzccrypt.h ===
#include <wincrypt.h>

#ifndef _WZCCRYPT_H_
#define _WZCCRYPT_H_

#define MASTER_SESSION_KEY_LENGTH   32
#define MASTER_SESSION_IV_LENGTH    32

typedef struct  _MASTER_SESSION_KEYS {
    BYTE    bPeerEncryptionKey[MASTER_SESSION_KEY_LENGTH];
    BYTE    bAuthenticatorEncryptionKey[MASTER_SESSION_KEY_LENGTH];
    BYTE    bPeerAuthenticationKey[MASTER_SESSION_KEY_LENGTH];
    BYTE    bAuthenticatorAuthenticationKey[MASTER_SESSION_KEY_LENGTH];
    BYTE    bPeerIV[MASTER_SESSION_IV_LENGTH];
    BYTE    bAuthenticatorIV[MASTER_SESSION_IV_LENGTH];
} MASTER_SESSION_KEYS, *PMASTER_SESSION_KEYS;

DWORD
GenerateMasterSessionKeys (
    PBYTE   pbSecret,
    DWORD   cbSecret,
    PBYTE   pbRandom,
    DWORD   cbRandom,
    PMASTER_SESSION_KEYS    pMasterSessionKeys
    );

#define MAX_SESSION_KEY_LENGTH  32

#define csz_CLIENT_EAP_ENCRYPTION   "client EAP encryption"

typedef struct  _SESSION_KEYS {
    DWORD   dwKeyLength;
    BYTE    bSendKey[MAX_SESSION_KEY_LENGTH];
    BYTE    bReceiveKey[MAX_SESSION_KEY_LENGTH];
} SESSION_KEYS, *PSESSION_KEYS;

// secured session keys
typedef struct _SEC_SESSION_KEYS {
    DATA_BLOB   dblobSendKey;
    DATA_BLOB   dblobReceiveKey;
} SEC_SESSION_KEYS, *PSEC_SESSION_KEYS;


DWORD
DeriveSessionKeys (
    PBYTE       pbMasterSendKey,
    PBYTE       pbMasterReceiveKey,
    DWORD       dwSessionKeyLength,
    PSESSION_KEYS   pSessionKeys
    );

DWORD
GenerateDynamicKeys (
    PBYTE   pbMasterSecret,
    DWORD   dwMasterSecretLength,
    PBYTE   pbRandom,
    DWORD   dwRandomLength,
    DWORD   dwDynamicKeyLength,
    SESSION_KEYS *pSessionKeys
    );

#endif // _WZCCRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\monitor\database\mrswlock.h ===
DWORD
InitializeRWLock(
    PWZC_RW_LOCK pWZCRWLock
    );

VOID
DestroyRWLock(
    PWZC_RW_LOCK pWZCRWLock
    );

VOID
AcquireSharedLock(
    PWZC_RW_LOCK pWZCRWLock
    );

VOID
AcquireExclusiveLock(
    PWZC_RW_LOCK pWZCRWLock
    );

VOID
ReleaseSharedLock(
    PWZC_RW_LOCK pWZCRWLock
    );

VOID
ReleaseExclusiveLock(
    PWZC_RW_LOCK pWZCRWLock
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\monitor\database\database.c ===
#include "precomp.h"


DWORD
InitWZCDbGlobals(
    BOOL    bLoggingEnabled
    )
{
    DWORD dwError = 0;


    gpSessionCont = NULL;

    gdwCurrentHeader = 1;
    gdwCurrentTableSize = 0;
    gdwCurrentMaxRecordID = 0;

    gJetInstance = 0;

    gpWZCDbSessionRWLock = &gWZCDbSessionRWLock;

    gpAppendSessionCont = &gAppendSessionCont;

    memset(gpAppendSessionCont, 0, sizeof(SESSION_CONTAINER));

    gdwWZCDbSessionCount = 0;

    gbDBOpened = FALSE;
    
    gbEnableDbLogging = bLoggingEnabled;

    dwError = InitializeRWLock(gpWZCDbSessionRWLock);
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Open log database.
    //
    if (gbEnableDbLogging) {
        dwError = WZCOpenAppendSession(gpAppendSessionCont);
        BAIL_ON_WIN32_ERROR(dwError);
        gbDBOpened = TRUE;
    }

error:

    return (dwError);
}


VOID
DeInitWZCDbGlobals(
    )
{
    if (gpSessionCont) {

        DestroySessionContList(gpSessionCont);
        gpSessionCont = NULL;
        gdwWZCDbSessionCount = 0;

    }

    //
    // If database has been opened for appending then close it.
    //

    if (gbDBOpened) {
        (VOID) WZCCloseAppendSession(gpAppendSessionCont);
        gbDBOpened = FALSE;
    }

    if (gpWZCDbSessionRWLock) {
        DestroyRWLock(gpWZCDbSessionRWLock);
        gpWZCDbSessionRWLock = NULL;
    }

    return;
}

DWORD
WZCSetLoggingState(
    BOOL    bLoggingEnabled
)
{   
    DWORD Error = 0;

    AcquireExclusiveLock(gpWZCDbSessionRWLock);
    
    gbEnableDbLogging = bLoggingEnabled;

    if (!bLoggingEnabled) {
        if (gdwWZCDbSessionCount == 0) {
            if (gbDBOpened) {
                (VOID) WZCCloseAppendSession(gpAppendSessionCont);
                gbDBOpened = FALSE;
            }
        }
    }
    else {
        if (!gbDBOpened) {
            Error = WZCOpenAppendSession(gpAppendSessionCont);
            BAIL_ON_LOCK_ERROR(Error);
            gbDBOpened = TRUE;
        }
    }

lock:

    ReleaseExclusiveLock(gpWZCDbSessionRWLock);

    return Error;

}

DWORD
WZCMapJetError(
    JET_ERR JetError,
    LPSTR CallerInfo OPTIONAL
    )
/*++

Routine Description:

    This function maps the Jet database errors to Windows errors.

Arguments:

    JetError - An error from a JET function call.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = 0;

    if (JetError == JET_errSuccess) {
        return (ERROR_SUCCESS);
    }

    if (JetError < 0) {

        Error = JetError;

        switch (JetError) {

        case JET_errNoCurrentRecord:
            Error = ERROR_NO_MORE_ITEMS;
            break;

        case JET_errRecordNotFound:
            break;

        case JET_errKeyDuplicate:
            break;

        default:
            break;

        }

        return (Error);

    }

    return (ERROR_SUCCESS);
}


DWORD
WZCCreateDatabase(
    JET_SESID JetServerSession,
    CHAR * Connect,
    JET_DBID * pJetDatabaseHandle,
    JET_GRBIT JetBits
    )
/*++

Routine Description:

    This routine creates wzc database and initializes it.

Arguments:

    JetServerSession - Server session id.

    Connect - Database type. NULL specifies the default engine (blue).

    pJetDatabaseHandle - Pointer to database handle returned.

    JetBits - Create flags.

Return Value:

    JET errors.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;
    char DBFilePath[MAX_PATH];
    char * pc = NULL;


    memset(DBFilePath, 0, sizeof(CHAR)*MAX_PATH);

    //
    // Create database file name.
    //

    pc = getenv(DBFILENAMEPREFIX);

    if (pc != NULL) {
        if (lstrlenA(pc) > 
               MAX_PATH - lstrlenA(DBFILENAMESUFFIX) - lstrlenA(DBFILENAME) -1)
        {
            Error = ERROR_FILENAME_EXCED_RANGE;
            BAIL_ON_WIN32_ERROR(Error);
        }
    	strcpy(DBFilePath, pc);
    	strcat(DBFilePath, DBFILENAMESUFFIX);
    }
    else {
        if (0 > MAX_PATH - lstrlenA(DBFILENAMESUFFIX) - lstrlenA(DBFILENAME) -1)
        {
            Error = ERROR_FILENAME_EXCED_RANGE;
            BAIL_ON_WIN32_ERROR(Error);
        }
    	strcpy(DBFilePath, DBFILENAMESUFFIX);
    }

    strcat(DBFilePath, DBFILENAME);

    //
    // Convert name to ANSI.
    //

    OemToCharBuffA(DBFilePath, DBFilePath, MAX_PATH); 

    //
    // Create database.
    //

    JetError = JetCreateDatabase(
                   JetServerSession,
                   DBFilePath,
                   Connect,
                   pJetDatabaseHandle,
                   JetBits
                   );
    Error = WZCMapJetError(JetError, "JetCreateDatabase");
    BAIL_ON_WIN32_ERROR(Error);

error:

    return (Error);
}


DWORD
WZCOpenDatabase(
    JET_SESID JetServerSession,
    CHAR * Connect,
    JET_DBID * pJetDatabaseHandle,
    JET_GRBIT JetBits
    )
/*++

Routine Description:

    This routine attaches to wzc database and opens it.

Arguments:

    JetServerSession - Server session id.

    Connect - Database type. NULL specifies the default engine (blue).

    pJetDatabaseHandle - Pointer to database handle returned.

    JetBits - Create flags.

Return Value:

    JET errors.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;
    char DBFilePath[MAX_PATH];
    char * pc = NULL;


    memset(DBFilePath, 0, sizeof(CHAR)*MAX_PATH);

    //
    // Create database file name.
    //

    pc = getenv(DBFILENAMEPREFIX);

    if (pc != NULL) {
        if (lstrlenA(pc) >
               MAX_PATH - lstrlenA(DBFILENAMESUFFIX) - lstrlenA(DBFILENAME) -1)
        {
            Error = ERROR_FILENAME_EXCED_RANGE;
            BAIL_ON_WIN32_ERROR(Error);
        }
    	strcpy(DBFilePath, pc);
    	strcat(DBFilePath, DBFILENAMESUFFIX);
    }
    else {
        if (0 > MAX_PATH - lstrlenA(DBFILENAMESUFFIX) - lstrlenA(DBFILENAME) -1)
        {
            Error = ERROR_FILENAME_EXCED_RANGE;
            BAIL_ON_WIN32_ERROR(Error);
        }
    	strcpy(DBFilePath, DBFILENAMESUFFIX);
    }

    strcat(DBFilePath, DBFILENAME);

    //
    // Convert name to ANSI.
    //

    OemToCharBuffA(DBFilePath, DBFilePath, MAX_PATH);

    //
    // Attach to database.
    //

    JetError = JetAttachDatabase(
                   JetServerSession,
                   DBFilePath,
                   JetBits
                   );
    Error = WZCMapJetError(JetError, "JetAttachDatabase");
    BAIL_ON_WIN32_ERROR(Error);

    JetError = JetOpenDatabase(
                   JetServerSession,
                   DBFilePath,
                   Connect,
                   pJetDatabaseHandle,
                   JetBits
                   );
    Error = WZCMapJetError(JetError, "JetOpenDatabase");
    BAIL_ON_WIN32_ERROR(Error);

error:

    return (Error);
}


DWORD
WZCInitializeDatabase(
    JET_SESID * pJetServerSession
    )
/*++

Routine Description:

    This function initializes the wzc logging database.

Arguments:

    pJetServerSession - Pointer to server session id.

Return Value:

    Windows Error.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;
    char DBFilePath[MAX_PATH];
    char * pc = NULL;
    BOOL bInitJetInstance = FALSE;


    memset(DBFilePath, 0, sizeof(CHAR)*MAX_PATH);

    *pJetServerSession = 0;
    gJetInstance = 0;

    //
    // Create database file name.
    //

    pc = getenv(DBFILENAMEPREFIX);

    if (pc != NULL) {
        if (lstrlenA(pc) >
               MAX_PATH - lstrlenA(DBFILENAMESUFFIX) - lstrlenA(DBFILENAME) -1)
        {
            Error = ERROR_FILENAME_EXCED_RANGE;
            BAIL_ON_WIN32_ERROR(Error);
        }
    	strcpy(DBFilePath, pc);
    	strcat(DBFilePath, DBFILENAMESUFFIX);
    }
    else {
        if (0 > MAX_PATH - lstrlenA(DBFILENAMESUFFIX) - lstrlenA(DBFILENAME) -1)
        {
            Error = ERROR_FILENAME_EXCED_RANGE;
            BAIL_ON_WIN32_ERROR(Error);
        }
    	strcpy(DBFilePath, DBFILENAMESUFFIX);
    }

    //
    // Convert name to ANSI.
    //

    OemToCharBuffA(DBFilePath, DBFilePath, MAX_PATH);

    //
    // create a Jet instance.
    //

    JetError = JetCreateInstance(
                   &gJetInstance,
                   cszWLANMonInstanceName
                   );
    Error = WZCMapJetError(JetError, "JetCreateInstance");
    BAIL_ON_WIN32_ERROR(Error);
    bInitJetInstance = TRUE;

    //
    // Set parameters to circularly use DB logging files.
    //

    JetError = JetSetSystemParameter(
                   &gJetInstance,
                   (JET_SESID)0,
                   JET_paramCircularLog,
                   TRUE,
                   NULL
                   );
    Error = WZCMapJetError(JetError, "JetSetSystemParameter");
    BAIL_ON_WIN32_ERROR(Error);

    //
    // Set max size of log file for DB as MAX_CHECK_POINT_DEPTH.
    //

    JetError = JetSetSystemParameter(
                   &gJetInstance,
                   (JET_SESID)0,
                   JET_paramCheckpointDepthMax,
                   MAX_CHECK_POINT_DEPTH,
                   NULL
                   );
    Error = WZCMapJetError(JetError, "JetSetSystemParameter");
    BAIL_ON_WIN32_ERROR(Error);

    //
    // Set system, temperary and log file path to where the .mdb file is.
    //

    JetError = JetSetSystemParameter(
                   &gJetInstance,
                   (JET_SESID)0,
                   JET_paramSystemPath,
                   TRUE,
                   DBFilePath
                   );
    Error = WZCMapJetError(JetError, "JetSetSystemParameter");
    BAIL_ON_WIN32_ERROR(Error);

    JetError = JetSetSystemParameter(
                   &gJetInstance,
                   (JET_SESID)0,
                   JET_paramLogFilePath,
                   TRUE,
                   DBFilePath
                   );
    Error = WZCMapJetError(JetError, "JetSetSystemParameter");
    BAIL_ON_WIN32_ERROR(Error);

    JetError = JetSetSystemParameter(
                   &gJetInstance,
                   (JET_SESID)0,
                   JET_paramTempPath,
                   TRUE,
                   DBFilePath
                   );
    Error = WZCMapJetError(JetError, "JetSetSystemParameter");
    BAIL_ON_WIN32_ERROR(Error);

    //
    // Create path if it does not exist.
    //

    JetError = JetSetSystemParameter(
                   &gJetInstance,
                   (JET_SESID)0,
                   JET_paramCreatePathIfNotExist,
                   TRUE,
                   NULL
                   );
    Error = WZCMapJetError(JetError, "JetSetSystemParameter");
    BAIL_ON_WIN32_ERROR(Error);

    JetError = JetInit(&gJetInstance);
    Error = WZCMapJetError(JetError, "JetInit");
    BAIL_ON_WIN32_ERROR(Error);

    JetError = JetBeginSession(
                   gJetInstance,
                   pJetServerSession,
                   "admin",
                   ""
                   );
    Error = WZCMapJetError(JetError, "JetBeginSession");
    BAIL_ON_WIN32_ERROR(Error);

    return (Error);

error:

    if (*pJetServerSession != 0) {
        JetError = JetEndSession(*pJetServerSession, 0);
        WZCMapJetError(JetError, "JetEndSession");
        *pJetServerSession = 0;
    }

    if (bInitJetInstance) {
        JetError = JetTerm2(gJetInstance, JET_bitTermComplete);
        gJetInstance = 0;
        WZCMapJetError(JetError, "JetTerm/JetTerm2");
    }

    return (Error);
}


VOID
WZCTerminateJet(
    JET_SESID * pJetServerSession
    )
/*++

Routine Description:

    This routine ends the jet session and terminates the jet engine.

Arguments:

    pJetServerSession - Pointer to the server session id.

Return Value:

    None.

--*/
{
    JET_ERR JetError = JET_errSuccess;


    if (*pJetServerSession != 0) {
        JetError = JetEndSession(*pJetServerSession, 0);
        WZCMapJetError(JetError, "JetEndSession");
        *pJetServerSession = 0;
    }

    JetError = JetTerm2(gJetInstance, JET_bitTermComplete);
    gJetInstance = 0;
    WZCMapJetError(JetError, "JetTerm/JetTerm2");

    return;
}


DWORD
WZCJetBeginTransaction(
    JET_SESID JetServerSession
    )
/*++

Routine Description:

    This functions starts an wzc database transaction.

Arguments:

    JetServerSession - Server session id.

Return Value:

    The status of the operation.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;

    JetError = JetBeginTransaction(JetServerSession);

    Error = WZCMapJetError(JetError, "WZCJetBeginTransaction");

    return (Error);
}


DWORD
WZCJetRollBack(
    JET_SESID JetServerSession
    )
/*++

Routine Description:

    This functions rolls back an wzc database transaction.

Arguments:

    JetServerSession - Server session id.

Return Value:

      The status of the operation.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;

    //
    // Rollback the last transaction.
    //

    JetError = JetRollback(JetServerSession, 0);

    Error = WZCMapJetError(JetError, "WZCJetRollBack");

    return(Error);
}


DWORD
WZCJetCommitTransaction(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle
    )
/*++

Routine Description:

    This functions commits an wzc database transaction.

Arguments:

    JetServerSession - Server session id.

    JetTableHandle - Table handle.

Return Value:

    The status of the operation.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;


    JetError = JetCommitTransaction(
                   JetServerSession,
                   JET_bitCommitLazyFlush
                   );

    Error = WZCMapJetError(JetError, "WZCJetCommitTransaction");
    return (Error);
}


DWORD
WZCJetPrepareUpdate(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle,
    char * ColumnName,
    PVOID Key,
    DWORD KeySize,
    BOOL NewRecord
    )
/*++

Routine Description:

    This function prepares the database for the creation of a new record,
    or updating an existing record.

Arguments:

    JetServerSession - Server session id.

    JetTableHandle - Table handle.

    ColumnName - The column name of an index column.

    Key - The key to update/create.

    KeySize - The size of the specified key, in bytes.

    NewRecord - TRUE to create the key, FALSE to update an existing key.

Return Value:

    The status of the operation.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;


    if (!NewRecord) {

        JetError = JetSetCurrentIndex(
                       JetServerSession,
                       JetTableHandle,
                       ColumnName
                       );
        Error = WZCMapJetError(JetError, "JetPrepareUpdate: JetSetCurrentIndex");
        if (Error != ERROR_SUCCESS) {
            WZCMapJetError(JetError, ColumnName);
            return (Error);
        }

        JetError = JetMakeKey(
                       JetServerSession,
                       JetTableHandle,
                       Key,
                       KeySize,
                       JET_bitNewKey
                       );
        Error = WZCMapJetError(JetError, "JetPrepareUpdate: JetMakeKey");
        if (Error != ERROR_SUCCESS) {
            WZCMapJetError(JetError, ColumnName);
            return (Error);
        }

        JetError = JetSeek(
                       JetServerSession,
                       JetTableHandle,
                       JET_bitSeekEQ
                       );
        Error = WZCMapJetError(JetError, "JetPrepareUpdate: JetSeek");
        if (Error != ERROR_SUCCESS) {
            WZCMapJetError(JetError, ColumnName);
            return (Error);
        }

    }

    JetError = JetPrepareUpdate(
                   JetServerSession,
                   JetTableHandle,
                   NewRecord ? JET_prepInsert : JET_prepReplace
                   );
    Error = WZCMapJetError(JetError, "JetPrepareUpdate: JetPrepareUpdate");
    return (Error);
}


DWORD
WZCJetCommitUpdate(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle
    )
/*++

Routine Description:

    This function commits an update to the database. The record specified
    by the last call to WZCJetPrepareUpdate() is committed.

Arguments:

    JetServerSession - Server session id.

    JetTableHandle - Table handle.

Return Value:

    The status of the operation.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;


    JetError = JetUpdate(
                   JetServerSession,
                   JetTableHandle,
                   NULL,
                   0,
                   NULL
                   );

    Error = WZCMapJetError(JetError, "WZCJetCommitUpdate");
    return (Error);
}


DWORD
WZCJetSetValue(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle,
    JET_COLUMNID KeyColumnId,
    PVOID Data,
    DWORD DataSize
    )
/*++

Routine Description:

    This function updates the value of an entry in the current record.

Arguments:

    JetServerSession - Server session id.

    JetTableHandle - Table handle.

    KeyColumnId - The Id of the column (value) to update.

    Data - A pointer to the new value for the column.

    DataSize - The size of the data, in bytes.

Return Value:

    Winerror code.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;


    JetError = JetSetColumn(
                   JetServerSession,
                   JetTableHandle,
                   KeyColumnId,
                   Data,
                   DataSize,
                   0,
                   NULL
                   );

    Error = WZCMapJetError(JetError, "JetSetValue: JetSetcolumn");
    return (Error);
}


DWORD
WZCJetPrepareSearch(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle,
    char * ColumnName,
    BOOL SearchFromStart,
    PVOID Key,
    DWORD KeySize
    )
/*++

Routine Description:

    This function prepares for a search of the client database.

Arguments:

    JetServerSession - Server session id.

    JetTableHandle - Table handle.

    ColumnName - The column name to use as the index column.

    SearchFromStart - If TRUE, search from the first record in the
                      database.  If FALSE, search from the specified key.

    Key - The key to start the search.

    KeySize - The size, in bytes, of key.

Return Value:

    Winerror code.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;


    JetError = JetSetCurrentIndex(
                   JetServerSession,
                   JetTableHandle,
                   ColumnName
                   );
    Error = WZCMapJetError(JetError, "JetPrepareSearch: JetSetCurrentIndex");
    if (Error != ERROR_SUCCESS) {
        WZCMapJetError(JetError, ColumnName);
        return (Error);
    }

    if (SearchFromStart) {
        JetError = JetMove(
                       JetServerSession,
                       JetTableHandle,
                       JET_MoveFirst,
                       0
                       );
    }
    else {
        JetError = JetMakeKey(
                       JetServerSession,
                       JetTableHandle,
                       Key,
                       KeySize,
                       JET_bitNewKey
                       );
        Error = WZCMapJetError(JetError, "JetPrepareSearch: JetMakeKey");
        if (Error != ERROR_SUCCESS) {
            WZCMapJetError(JetError, ColumnName);
            return (Error);
        }

        JetError = JetSeek(
                       JetServerSession,
                       JetTableHandle,
                       JET_bitSeekGT
                       );

    }

    Error = WZCMapJetError(JetError, "JetPrepareSearch: JetMove / JetSeek");
    return (Error);
}


DWORD
WZCJetNextRecord(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle
    )
/*++

Routine Description:

    This function advances to the next record in a search.

Arguments:

    JetServerSession - Server session id.

    JetTableHandle - Table handle.

Return Value:

    The status of the operation.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;


    JetError = JetMove(
                   JetServerSession,
                   JetTableHandle,
                   JET_MoveNext,
                   0
                   );

    Error = WZCMapJetError(JetError, "JetNextRecord");
    return (Error);
}


DWORD
WZCCreateTableData(
    JET_SESID JetServerSession,
    JET_DBID JetDatabaseHandle,
    JET_TABLEID * pJetTableHandle
    )
/*++

Routine Description:

    This function creates a table in the database.

Arguments:

    JetServerSession - Server session id.

    JetDatabaseHandle - Database handle.

    pJetTableHandle - Pointer to return table handle.

Return Value:

    The status of the operation.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;
    JET_COLUMNDEF ColumnDef;
    CHAR * IndexKey = NULL;
    DWORD i = 0;


    memset(&ColumnDef, 0, sizeof(JET_COLUMNDEF));

    //
    // Create table.
    //

    JetError = JetCreateTable(
                   JetServerSession,
                   JetDatabaseHandle,
                   LOG_RECORD_TABLE,
                   DB_TABLE_SIZE,
                   DB_TABLE_DENSITY,
                   pJetTableHandle
                   );
    Error = WZCMapJetError(JetError, "JetCreateTable");
    BAIL_ON_WIN32_ERROR(Error);

    //
    // Create columns.
    // Init fields of columndef that do not change between addition of
    // columns.
    //

    ColumnDef.cbStruct  = sizeof(ColumnDef);
    ColumnDef.columnid  = 0;
    ColumnDef.wCountry  = 1;
    ColumnDef.langid    = DB_LANGID;
    ColumnDef.cp        = DB_CP;
    ColumnDef.wCollate  = 0;
    ColumnDef.cbMax     = 0;
    ColumnDef.grbit     = 0;

    for (i = 0; i < RECORD_TABLE_NUM_COLS; i++) {

        ColumnDef.coltyp = gLogRecordTable[i].ColType;
        ColumnDef.grbit = gLogRecordTable[i].dwJetBit;

        JetError = JetAddColumn(
                       JetServerSession,
                       *pJetTableHandle,
                       gLogRecordTable[i].ColName,
                       &ColumnDef,
                       NULL,
                       0,
                       &gLogRecordTable[i].ColHandle
                       );
        Error = WZCMapJetError(JetError, "JetAddColumn");
        BAIL_ON_WIN32_ERROR(Error);

    }

    //
    // Finally create index.
    //

    IndexKey = "+" RECORD_IDX_STR "\0";
    JetError = JetCreateIndex(
                   JetServerSession,
                   *pJetTableHandle,
                   gLogRecordTable[RECORD_IDX_IDX].ColName,
                   0,
                   IndexKey,
                   strlen(IndexKey) + 2, // for two termination chars.
                   50
                   );
    Error = WZCMapJetError(JetError, "JetCreateIndex");
    BAIL_ON_WIN32_ERROR(Error);

    IndexKey = "+" RECORD_ID_STR "\0";
    JetError = JetCreateIndex(
                   JetServerSession,
                   *pJetTableHandle,
                   gLogRecordTable[RECORD_ID_IDX].ColName,
                   0,
                   IndexKey,
                   strlen(IndexKey) + 2, // for two termination chars.
                   50
                   );
    Error = WZCMapJetError(JetError, "JetCreateIndex");
    BAIL_ON_WIN32_ERROR(Error);

    IndexKey = "+" TIMESTAMP_STR "\0";
    JetError = JetCreateIndex(
                   JetServerSession,
                   *pJetTableHandle,
                   gLogRecordTable[TIMESTAMP_IDX].ColName,
                   0,
                   IndexKey,
                   strlen(IndexKey) + 2, // for two termination chars.
                   50
                   );
    Error = WZCMapJetError(JetError, "JetCreateIndex");
    BAIL_ON_WIN32_ERROR(Error);

    IndexKey = "+" INTERFACE_MAC_STR "\0";
    JetError = JetCreateIndex(
                   JetServerSession,
                   *pJetTableHandle,
                   gLogRecordTable[INTERFACE_MAC_IDX].ColName,
                   0,
                   IndexKey,
                   strlen(IndexKey) + 2, // for two termination chars.
                   50
                   );
    Error = WZCMapJetError(JetError, "JetCreateIndex");
    BAIL_ON_WIN32_ERROR(Error);

    IndexKey = "+" DEST_MAC_STR "\0";
    JetError = JetCreateIndex(
                   JetServerSession,
                   *pJetTableHandle,
                   gLogRecordTable[DEST_MAC_IDX].ColName,
                   0,
                   IndexKey,
                   strlen(IndexKey) + 2, // for two termination chars.
                   50
                   );
    Error = WZCMapJetError(JetError, "JetCreateIndex");
    BAIL_ON_WIN32_ERROR(Error);

    IndexKey = "+" SSID_STR "\0";
    JetError = JetCreateIndex(
                   JetServerSession,
                   *pJetTableHandle,
                   gLogRecordTable[SSID_IDX].ColName,
                   0,
                   IndexKey,
                   strlen(IndexKey) + 2, // for two termination chars.
                   50
                   );
    Error = WZCMapJetError(JetError, "JetCreateIndex");
    BAIL_ON_WIN32_ERROR(Error);

error:

    return (Error);
}


DWORD
WZCOpenTableData(
    JET_SESID JetServerSession,
    JET_DBID JetDatabaseHandle,
    JET_TABLEID * pJetTableHandle
    )
/*++

Routine Description:

    This function opens a table in the database.

Arguments:

    JetServerSession - Server session id.

    JetDatabaseHandle - Database handle.

    pJetTableHandle - Pointer to return table handle.

Return Value:

    The status of the operation.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;
    JET_COLUMNDEF ColumnDef;
    CHAR * IndexKey = NULL;
    DWORD i = 0;


    memset(&ColumnDef, 0, sizeof(JET_COLUMNDEF));

    //
    // Open table.
    //

    JetError = JetOpenTable(
                   JetServerSession,
                   JetDatabaseHandle,
                   LOG_RECORD_TABLE,
                   NULL,
                   0,
                   0,
                   pJetTableHandle
                   );
    Error = WZCMapJetError(JetError, "JetOpenTable");
    BAIL_ON_WIN32_ERROR(Error);

    for (i = 0; i < RECORD_TABLE_NUM_COLS; i++) {

        ColumnDef.coltyp   = gLogRecordTable[i].ColType;

        JetError = JetGetTableColumnInfo(
                       JetServerSession,
                       *pJetTableHandle,
                       gLogRecordTable[i].ColName,
                       &ColumnDef,
                       sizeof(ColumnDef),
                       0
                       );
        Error = WZCMapJetError(JetError, "JetGetTableColumnInfo");
        BAIL_ON_WIN32_ERROR(Error);

        gLogRecordTable[i].ColHandle = ColumnDef.columnid;

    }

error:

    return (Error);
}


DWORD
WZCJetGetValue(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle,
    JET_COLUMNID ColumnId,
    PVOID pvData,
    DWORD dwSize,
    PDWORD pdwRequiredSize
    )
/*++

Routine Description:

    This function reads the value of an entry in the current record.

Arguments:

    JetServerSession - Server session id.

    JetDatabaseHandle - Database handle.

    ColumnId - The Id of the column (value) to read.

    Data - Pointer to a location where the data that is read from the
           database returned,  or pointer to a location where data is.

    DataSize - If the pointed value is non-zero then the Data points to
               a buffer otherwise this function allocates buffer for 
               return data and returns buffer pointer in Data.

    pdwRequiredSize - Pointer to hold the required size.

Return Value:

    The status of the operation.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;


    JetError = JetRetrieveColumn(
                   JetServerSession,
                   JetTableHandle,
                   ColumnId,
                   pvData,
                   dwSize,
                   pdwRequiredSize,
                   0,
                   NULL
                   );
    Error = WZCMapJetError(JetError, "JetGetValue: JetRetrieveColumn");
    BAIL_ON_WIN32_ERROR(Error);

error:

    return (Error);
}


BOOL
IsDBOpened(
    )
{
    return (gbDBOpened);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\monitor\database\mrswlock.c ===
/*++

Copyright (c) 2001 Microsoft Corporation


Module Name:

    mrswlock.c

Abstract:

    This module contains multiple readers / single writer implementation.

Author:

    abhisheV    18-October-2001

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
InitializeRWLock(
    PWZC_RW_LOCK pWZCRWLock
    )
{
    DWORD dwError = 0;
    SECURITY_ATTRIBUTES SecurityAttributes;


    memset(pWZCRWLock, 0, sizeof(WZC_RW_LOCK));

    __try {
        InitializeCriticalSection(&(pWZCRWLock->csExclusive));
        pWZCRWLock->bInitExclusive = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwError = GetExceptionCode();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    __try {
        InitializeCriticalSection(&(pWZCRWLock->csShared));
        pWZCRWLock->bInitShared = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
         dwError = GetExceptionCode();
         BAIL_ON_WIN32_ERROR(dwError);
    }

    memset(&SecurityAttributes, 0, sizeof(SECURITY_ATTRIBUTES));

    SecurityAttributes.nLength = sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor = NULL;
    SecurityAttributes.bInheritHandle = TRUE;

    pWZCRWLock->hReadDone = CreateEvent(
                                  &SecurityAttributes,
                                  TRUE,
                                  FALSE,
                                  NULL
                                  );
    if (!pWZCRWLock->hReadDone) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    SetEvent(pWZCRWLock->hReadDone);

    return (dwError);

error:

    DestroyRWLock(pWZCRWLock);

    return (dwError);
}


VOID
DestroyRWLock(
    PWZC_RW_LOCK pWZCRWLock
    )
{
    if (pWZCRWLock->hReadDone) {
        CloseHandle(pWZCRWLock->hReadDone);
    }

    if (pWZCRWLock->bInitShared == TRUE) {
        DeleteCriticalSection(&(pWZCRWLock->csShared));
        pWZCRWLock->bInitShared = FALSE;
    }

    if (pWZCRWLock->bInitExclusive == TRUE) {
        DeleteCriticalSection(&(pWZCRWLock->csExclusive));
        pWZCRWLock->bInitExclusive = FALSE;
    }

    memset(pWZCRWLock, 0, sizeof(WZC_RW_LOCK));

    return;
}


VOID
AcquireSharedLock(
    PWZC_RW_LOCK pWZCRWLock
    )
{
    //
    // Claim the exclusive critical section. This call blocks if there's
    // an active writer or if there's a writer waiting for active readers
    // to complete.
    //

    EnterCriticalSection(&(pWZCRWLock->csExclusive));

    //
    // Claim access to the reader count. If this blocks, it's only for a
    // brief moment while other reader threads go through to increment or
    // decrement the reader count.
    //

    EnterCriticalSection(&(pWZCRWLock->csShared));

    //
    // Increment the reader count. If this is the first reader then reset
    // the read done event so that the next writer blocks.
    //

    if ((pWZCRWLock->lReaders)++ == 0) {
        ResetEvent(pWZCRWLock->hReadDone);
    }

    //
    // Release access to the reader count.
    //

    LeaveCriticalSection(&(pWZCRWLock->csShared));

    //
    // Release access to the exclusive critical section. This enables
    // other readers  to come through and the next write to wait for
    // active readers to complete which in turn prevents new readers
    // from entering.
    //

    LeaveCriticalSection(&(pWZCRWLock->csExclusive));

    return;
}


VOID
AcquireExclusiveLock(
    PWZC_RW_LOCK pWZCRWLock
    )
{
    DWORD dwStatus = 0;


    //
    // Claim the exclusive critical section. This not only prevents other
    // threads from claiming the write lock, but also prevents any new
    // threads from claiming the read lock.
    //

    EnterCriticalSection(&(pWZCRWLock->csExclusive));

    pWZCRWLock->dwCurExclusiveOwnerThreadId = GetCurrentThreadId();

    //
    // Wait for the active readers to release their read locks.
    //

    dwStatus = WaitForSingleObject(pWZCRWLock->hReadDone, INFINITE);

    ASSERT(dwStatus == WAIT_OBJECT_0);

    return;
}


VOID
ReleaseSharedLock(
    PWZC_RW_LOCK pWZCRWLock
    )
{
    //
    // Claim access to the reader count. If this blocks, it's only for a
    // brief moment while other reader threads go through to increment or
    // decrement the reader count.
    //

    EnterCriticalSection(&(pWZCRWLock->csShared));

    //
    // Decrement the reader count. If this is the last reader, set read
    // done event, which allows the first waiting writer to proceed.
    //

    if (--(pWZCRWLock->lReaders) == 0) {
        SetEvent(pWZCRWLock->hReadDone);
    }

    //
    // Release access to the reader count.
    //

    LeaveCriticalSection(&(pWZCRWLock->csShared));

    return;
}


VOID
ReleaseExclusiveLock(
    PWZC_RW_LOCK pWZCRWLock
    )
{
    //
    // Make the exclusive critical section available to one other writer
    // or to the first reader.
    //

    pWZCRWLock->dwCurExclusiveOwnerThreadId = 0;

    LeaveCriticalSection(&(pWZCRWLock->csExclusive));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\monitor\database\globals.c ===
#include "precomp.h"

TABLE_INFO gLogRecordTable[] = {
	{RECORD_IDX_STR,  	0, JET_coltypLong, 		JET_bitColumnAutoincrement},
	{RECORD_ID_STR,		0, JET_coltypLong,		0},
    	{COMPONENT_ID_STR,  	0, JET_coltypLong, 		0},
    	{CATEGORY_STR, 		0, JET_coltypLong, 		0},
    	{TIMESTAMP_STR, 	0, JET_coltypDateTime,		0},
    	{MESSAGE_STR, 		0, JET_coltypLongText,		0},
	{INTERFACE_MAC_STR,	0, JET_coltypText,		0},
	{DEST_MAC_STR,		0, JET_coltypText,		0},
	{SSID_STR,		0, JET_coltypText,		0},
	{CONTEXT_STR,		0, JET_coltypLongText,		0}
};

DWORD RECORD_TABLE_NUM_COLS = (sizeof(gLogRecordTable) / sizeof(TABLE_INFO));

PSESSION_CONTAINER gpSessionCont;

DWORD gdwCurrentHeader;
DWORD gdwCurrentTableSize;
DWORD gdwCurrentMaxRecordID;

JET_INSTANCE gJetInstance;

WZC_RW_LOCK gWZCDbSessionRWLock;

PWZC_RW_LOCK gpWZCDbSessionRWLock = NULL;

DWORD gdwWZCDbSessionCount;

SESSION_CONTAINER gAppendSessionCont;

PSESSION_CONTAINER gpAppendSessionCont;

BOOL gbDBOpened;

BOOL gbEnableDbLogging;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\monitor\database\precomp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    precomp.h

Abstract:

    Precompiled header for appmon.dll.

Author:

    HuiS    June 2001

Environment:

    User Level: Win32

Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <rpc.h>
#include <windows.h>
#include <tchar.h>
#include <userenv.h>
#include <esent.h>

#include "wzcsapi.h"
#include "database.h"
#include "mrswlock.h"
#include "externs.h"
#include "tracing.h"

#ifdef BAIL_ON_WIN32_ERROR
#undef BAIL_ON_WIN32_ERROR
#endif

#define BAIL_ON_WIN32_ERROR(dwError)    \
    if (dwError) {                      \
        goto error;                     \
    }

#define BAIL_ON_LOCK_ERROR(dwError)     \
    if (dwError) {                      \
        goto lock;                      \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\monitor\database\wzclog.c ===
/*++

Copyright (c) 2001 Microsoft Corporation


Module Name:

    wzclog.c

Abstract:

    This module contains all of the code to service the
    API calls made to the SPD logging server.

Author:

    abhisheV    18-October-2001

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
OpenWZCDbLogSession(
    LPWSTR pServerName,
    DWORD dwVersion,
    PHANDLE phSession
    )
/*++

Routine Description:

    This function opens a new session for a client.

Arguments:

    pServerName - Pointer to the server name.

    phSession - Pointer to hold the handle for the opened session.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = 0;
    PSESSION_CONTAINER pSessionCont = NULL;


    Error = CreateSessionCont(
                &pSessionCont
                );
    BAIL_ON_WIN32_ERROR(Error);

    AcquireExclusiveLock(gpWZCDbSessionRWLock);
    
    if (gdwWZCDbSessionCount >= MAX_SESSION_NUM){
        Error = ERROR_REMOTE_SESSION_LIMIT_EXCEEDED;
        BAIL_ON_LOCK_ERROR(Error);
    }

    if (!gbDBOpened) {
        Error = WZCOpenAppendSession(gpAppendSessionCont);
        BAIL_ON_LOCK_ERROR(Error);
        gbDBOpened = TRUE;
    }

    Error = IniOpenWZCDbLogSession(pSessionCont);
    BAIL_ON_LOCK_ERROR(Error);

    pSessionCont->pNext = gpSessionCont;
    gpSessionCont = pSessionCont;

    *phSession = (HANDLE)pSessionCont;
    
    gdwWZCDbSessionCount ++;

    ReleaseExclusiveLock(gpWZCDbSessionRWLock);

    return (Error);

lock:

    ReleaseExclusiveLock(gpWZCDbSessionRWLock);

error:

    if (pSessionCont) {
        FreeSessionCont(pSessionCont);
    }

    *phSession = NULL;

    return (Error);
}


DWORD
CreateSessionCont(
    PSESSION_CONTAINER * ppSessionCont
    )
{
    DWORD dwError = 0;
    PSESSION_CONTAINER pSessionCont = NULL;


    pSessionCont = LocalAlloc(LMEM_ZEROINIT, sizeof(SESSION_CONTAINER));
    if (!pSessionCont) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memset(pSessionCont, 0, sizeof(SESSION_CONTAINER));

    *ppSessionCont = pSessionCont;
    return (dwError);

error:

    *ppSessionCont = NULL;
    return (dwError);
}


DWORD
IniOpenWZCDbLogSession(
    PSESSION_CONTAINER pSessionCont
    )
/*++

Routine Description:

    This function opens a new session for a client.

Arguments:

    pSessionCont - Pointer to hold the opened session data.

Return Value:

    Windows Error.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;
    char DBFilePath[MAX_PATH];
    char * pc = NULL;
    JET_SESID * pMyJetServerSession = NULL;
    JET_DBID * pMyJetDatabaseHandle = NULL;
    JET_TABLEID * pMyClientTableHandle = NULL;


    memset(DBFilePath, 0, sizeof(CHAR)*MAX_PATH);

    pMyJetServerSession = (JET_SESID *) &(pSessionCont->SessionID);
    pMyJetDatabaseHandle = (JET_DBID *) &(pSessionCont->DbID);
    pMyClientTableHandle = (JET_TABLEID *) &(pSessionCont->TableID);

    //
    // Create database file name.
    //

    pc = getenv(DBFILENAMEPREFIX);

    if (pc != NULL) {
        if (lstrlenA(pc) >
               MAX_PATH - lstrlenA(DBFILENAMESUFFIX) - lstrlenA(DBFILENAME) -1)
        {
            Error = ERROR_FILENAME_EXCED_RANGE;
            BAIL_ON_WIN32_ERROR(Error);
        }
        strcpy(DBFilePath, pc);
        strcat(DBFilePath, DBFILENAMESUFFIX);
    }
    else {
        if (0 > MAX_PATH - lstrlenA(DBFILENAMESUFFIX) - lstrlenA(DBFILENAME) -1)
        {
            Error = ERROR_FILENAME_EXCED_RANGE;
            BAIL_ON_WIN32_ERROR(Error);
        }
        strcpy(DBFilePath, DBFILENAMESUFFIX);
    }

    strcat(DBFilePath, DBFILENAME);

    //
    // Convert name to ANSI.
    //

    OemToCharBuffA(DBFilePath, DBFilePath, MAX_PATH);

    JetError = JetBeginSession(
                   gJetInstance,
                   pMyJetServerSession,
                   "admin",
                   ""
                   );
    Error = WZCMapJetError(JetError, "JetBeginSession");
    BAIL_ON_WIN32_ERROR(Error);

    JetError = JetOpenDatabase(
                   *pMyJetServerSession,
                   DBFilePath,
                   0,
                   pMyJetDatabaseHandle,
                   0
                   );
    Error = WZCMapJetError(JetError, "JetOpenDatabase");
    BAIL_ON_WIN32_ERROR(Error);

    JetError = JetOpenTable(
                   *pMyJetServerSession,
                   *pMyJetDatabaseHandle,
                   LOG_RECORD_TABLE,
                   NULL,
                   0,
                   0,
                   pMyClientTableHandle
                   );
    Error = WZCMapJetError(JetError, "JetOpenTable");
    BAIL_ON_WIN32_ERROR(Error);

    return (Error);

error:

    if (pMyJetServerSession && *pMyJetServerSession) {
        JetError = JetEndSession(*pMyJetServerSession, 0);
        WZCMapJetError(JetError, "JetEndSession");
        *pMyJetServerSession = 0;
    }

    return (Error);
}


VOID
FreeSessionCont(
    PSESSION_CONTAINER pSessionCont
    )
{
    if (pSessionCont) {
        LocalFree(pSessionCont);
    }
    return;
}


DWORD
CloseWZCDbLogSession(
    HANDLE hSession
    )
/*++

Routine Description:

    This function ends a session for a client.

Arguments:

    hSession - Handle for the session to end.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = 0;
    PSESSION_CONTAINER pSessionCont = NULL;


    AcquireExclusiveLock(gpWZCDbSessionRWLock);

    Error = GetSessionContainer(hSession, &pSessionCont);
    BAIL_ON_LOCK_ERROR(Error);

    Error = IniCloseWZCDbLogSession(pSessionCont);
    BAIL_ON_LOCK_ERROR(Error);

    RemoveSessionCont(
        pSessionCont
        );

    FreeSessionCont(pSessionCont);
    
    gdwWZCDbSessionCount --;
    
    if (!gbEnableDbLogging) {
        if (gdwWZCDbSessionCount == 0) {
            ASSERT(gbDBOpened == TRUE);
            (VOID) WZCCloseAppendSession(gpAppendSessionCont);
            gbDBOpened = FALSE;
        }
    }

    ReleaseExclusiveLock(gpWZCDbSessionRWLock);

    return (Error);

lock:

    ReleaseExclusiveLock(gpWZCDbSessionRWLock);

    return (Error);
}


DWORD
GetSessionContainer(
    HANDLE hSession,
    PSESSION_CONTAINER * ppSessionCont
    )
{
    DWORD Error = ERROR_INVALID_HANDLE;
    PSESSION_CONTAINER * ppTemp = NULL;
    PSESSION_CONTAINER pSessionCont = (PSESSION_CONTAINER) hSession;

    *ppSessionCont = NULL;

    ppTemp = &gpSessionCont;

    while (*ppTemp) {

        if (*ppTemp == pSessionCont) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppSessionCont = *ppTemp;
        Error = ERROR_SUCCESS;
    }

    return (Error);
}


DWORD
IniCloseWZCDbLogSession(
    PSESSION_CONTAINER pSessionCont
    )
/*++

Routine Description:

    This function ends a session for a client.

Arguments:

    pSessionCont - Pointer to the session data for the session to end.

Return Value:

    Windows Error.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;
    JET_SESID * pMyJetServerSession = NULL;


    pMyJetServerSession = (JET_SESID *) &(pSessionCont->SessionID);

    if (*pMyJetServerSession) {
        JetError = JetEndSession(*pMyJetServerSession, 0);
        Error = WZCMapJetError(JetError, "JetEndSession");
        BAIL_ON_WIN32_ERROR(Error);
        *pMyJetServerSession = 0;
    }

error:

    return (Error);
}


VOID
RemoveSessionCont(
    PSESSION_CONTAINER pSessionCont
    )
{
    PSESSION_CONTAINER * ppTemp = NULL;


    ppTemp = &gpSessionCont;

    while (*ppTemp) {

        if (*ppTemp == pSessionCont) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pSessionCont->pNext;
    }

    return;
}


VOID
DestroySessionContList(
    PSESSION_CONTAINER pSessionContList
    )
{
    PSESSION_CONTAINER pSessionCont = NULL;
    PSESSION_CONTAINER pTemp = NULL;

    pSessionCont = pSessionContList;

    while (pSessionCont) {

        pTemp = pSessionCont;
        pSessionCont = pSessionCont->pNext;

        (VOID) IniCloseWZCDbLogSession(pTemp);
        FreeSessionCont(pTemp);

    }
}


DWORD
WZCOpenAppendSession(
    PSESSION_CONTAINER pSessionCont
    )
/*++

Routine Description:

    This function tries to open a database in DBFILENAME and its table.
    If the database does not exist, it creates the database and creates
    the table as well.
    If just the table does not exist, it creates the table and opens it.

Arguments:

    pSessionCont - Pointer to the session container.

Return Value:

    Windows Error.

--*/
{
    DWORD dwError = 0;
    DWORD dwTempIdx = 0;
    DWORD dwReqSize = 0;
    BOOL bInitializedDb = FALSE;
    JET_SESID * pMyJetServerSession = NULL;
    JET_DBID * pMyJetDatabaseHandle = NULL;
    JET_TABLEID * pMyClientTableHandle = NULL;
    JET_ERR JetError = JET_errSuccess;


    pMyJetServerSession = (JET_SESID *) &(pSessionCont->SessionID);
    pMyJetDatabaseHandle = (JET_DBID *) &(pSessionCont->DbID);
    pMyClientTableHandle = (JET_TABLEID *) &(pSessionCont->TableID);

    gdwCurrentHeader = 1;
    gdwCurrentTableSize = 0;
    gdwCurrentMaxRecordID = 0;

    dwError = WZCInitializeDatabase(
                  pMyJetServerSession
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    bInitializedDb = TRUE;

    dwError = WZCCreateDatabase(
                  *pMyJetServerSession,
                  0,
                  pMyJetDatabaseHandle,
                  0
                  );

    if (!dwError) {
        dwError = WZCGetTableDataHandle(
                      pMyJetServerSession,
                      pMyJetDatabaseHandle,
                      pMyClientTableHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        return (ERROR_SUCCESS);
    }

    //
    // Database already exists.
    //
    dwError = WZCOpenDatabase(
                  *pMyJetServerSession,
                  0,
                  pMyJetDatabaseHandle,
                  0
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = WZCGetTableDataHandle(
                  pMyJetServerSession,
                  pMyJetDatabaseHandle,
                  pMyClientTableHandle
                  );
    //
    // If the table does not have correct columns, delete it and create a
    // new table.
    //
    if (dwError != JET_errColumnNotFound) {
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {

        JetError = JetCloseTable(
                       *pMyJetServerSession,
                       *pMyClientTableHandle
                       );
        dwError = WZCMapJetError(JetError, "JetCloseTable");
        BAIL_ON_WIN32_ERROR(dwError);
        *pMyClientTableHandle = 0;

        JetError = JetDeleteTable(
                       *pMyJetServerSession,
                       *pMyJetDatabaseHandle,
                       LOG_RECORD_TABLE
                       );
        dwError = WZCMapJetError(JetError, "JetDeleteTable");
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = WZCGetTableDataHandle(
                      pMyJetServerSession,
                      pMyJetDatabaseHandle,
                      pMyClientTableHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    //
    // Initialize current table size and current header.
    // Find out total number of records in table.
    //
    JetError = JetSetCurrentIndex(
                   *pMyJetServerSession,
                   *pMyClientTableHandle,
                   gLogRecordTable[RECORD_IDX_IDX].ColName
                   );
    dwError = WZCMapJetError(JetError, "JetSetCurrentIndex");
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Jump to the last record.
    //
    JetError = JetMove(
                   *pMyJetServerSession,
                   *pMyClientTableHandle,
                   JET_MoveLast,
                   0
                   );
    dwError = WZCMapJetError(JetError, "JetMove");
    if (dwError != ERROR_SUCCESS) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    //
    // Check if the logical end of table has been hit.
    //
    dwError = WZCJetGetValue(
                  *pMyJetServerSession,
                  *pMyClientTableHandle,
                  gLogRecordTable[RECORD_IDX_IDX].ColHandle,
                  &dwTempIdx,
                  sizeof(dwTempIdx),
                  &dwReqSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    gdwCurrentTableSize = dwTempIdx;

    //
    // Find out the current header.
    //
    JetError = JetSetCurrentIndex(
                   *pMyJetServerSession,
                   *pMyClientTableHandle,
                   gLogRecordTable[TIMESTAMP_IDX].ColName
                   );
    dwError = WZCMapJetError(JetError, "JetSetCurrentIndex");
    BAIL_ON_WIN32_ERROR(dwError);

    JetError = JetMove(
                   *pMyJetServerSession,
                   *pMyClientTableHandle,
                   JET_MoveFirst,
                   0
                   );
    dwError = WZCMapJetError(JetError, "JetMove");
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = WZCJetGetValue(
                  *pMyJetServerSession,
                  *pMyClientTableHandle,
                  gLogRecordTable[RECORD_IDX_IDX].ColHandle,
                  &dwTempIdx,
                  sizeof(dwTempIdx),
                  &dwReqSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    gdwCurrentHeader = dwTempIdx;

    return (dwError);

error:

    if (bInitializedDb) {
        WZCCloseAppendSession(pSessionCont);
    }

    return (dwError);
}


DWORD
WZCCloseAppendSession(
    PSESSION_CONTAINER pSessionCont
    )
/*++

Routine Description:

    This function tries to close the database and the append session.

Arguments:

    pSessionCont - Pointer to the session container.

Return Value:

    Windows Error.

--*/
{
    DWORD dwError = 0;
    JET_ERR JetError = JET_errSuccess;
    JET_SESID * pMyJetServerSession = NULL;


    pMyJetServerSession = (JET_SESID *) &(pSessionCont->SessionID);

    if (*pMyJetServerSession != 0) {
        JetError = JetEndSession(*pMyJetServerSession, 0);
        dwError = WZCMapJetError(JetError, "JetEndSession");
        *pMyJetServerSession = 0;
    }

    JetError = JetTerm2(gJetInstance, JET_bitTermComplete);
    gJetInstance = 0;
    dwError = WZCMapJetError(JetError, "JetTerm/JetTerm2");

    return (dwError);
}


DWORD
AddWZCDbLogRecord(
    LPWSTR pServerName,
    DWORD dwVersion,
    PWZC_DB_RECORD pWZCRecord,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function appends a new record into the table.

Arguments:

    pServerName - Pointer to the server name.

    pWZCRecord - Pointer to the record to be appended.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = 0;
    BOOL bStartedTransaction = FALSE;
    JET_ERR JetError = JET_errSuccess;
    SYSTEMTIME stLocalTime;
    BOOL bNewRecord = TRUE;
    DWORD dwTempKey = 0;
    JET_SESID * pMyJetServerSession = NULL;
    JET_DBID * pMyJetDatabaseHandle = NULL;
    JET_TABLEID * pMyClientTableHandle = NULL;
    DWORD LocalError = 0;


    //
    // Get current time as time stamp for the record.
    //
    GetLocalTime(&stLocalTime);
    SystemTimeToFileTime(&stLocalTime, &(pWZCRecord->timestamp));

    AcquireExclusiveLock(gpWZCDbSessionRWLock);

    if (!gbDBOpened) {
        Error = ERROR_INVALID_STATE;
        BAIL_ON_LOCK_ERROR(Error);
    }

    if (!gbEnableDbLogging) {
        Error = ERROR_INVALID_STATE;
        BAIL_ON_LOCK_ERROR(Error);
    }

    pMyJetServerSession = (JET_SESID *) &(gpAppendSessionCont->SessionID);
    pMyJetDatabaseHandle = (JET_DBID *) &(gpAppendSessionCont->DbID);
    pMyClientTableHandle = (JET_TABLEID *) &(gpAppendSessionCont->TableID);

    if (!(*pMyClientTableHandle)) {
        Error = WZCGetTableDataHandle(
                    pMyJetServerSession,
                    pMyJetDatabaseHandle,
                    pMyClientTableHandle
                    );
        BAIL_ON_LOCK_ERROR(Error);
    }

    //
    // Insert a new record or replace a old one.
    //
    if (gdwCurrentTableSize < MAX_RECORD_NUM) {
        bNewRecord = TRUE;
    }
    else {
        bNewRecord = FALSE;
        dwTempKey = gdwCurrentHeader;
    }

    Error = WZCJetBeginTransaction(*pMyJetServerSession);
    BAIL_ON_LOCK_ERROR(Error);
    bStartedTransaction = TRUE;

    //
    // Prepare for insertion/replacement.
    //
    Error = WZCJetPrepareUpdate(
                *pMyJetServerSession,
                *pMyClientTableHandle,
                gLogRecordTable[RECORD_IDX_IDX].ColName,
                &dwTempKey,
                sizeof(dwTempKey),
                bNewRecord
                );
    BAIL_ON_LOCK_ERROR(Error);

    Error = WZCJetSetValue(
                *pMyJetServerSession,
                *pMyClientTableHandle,
                gLogRecordTable[RECORD_ID_IDX].ColHandle,
                &(gdwCurrentMaxRecordID),
                sizeof(gdwCurrentMaxRecordID)
                );
    BAIL_ON_LOCK_ERROR(Error);

    Error = WZCJetSetValue(
                *pMyJetServerSession,
                *pMyClientTableHandle,
                gLogRecordTable[COMPONENT_ID_IDX].ColHandle,
                &(pWZCRecord->componentid),
                sizeof(pWZCRecord->componentid)
                );
    BAIL_ON_LOCK_ERROR(Error);

    Error = WZCJetSetValue(
                *pMyJetServerSession,
                *pMyClientTableHandle,
                gLogRecordTable[CATEGORY_IDX].ColHandle,
                &(pWZCRecord->category),
                sizeof(pWZCRecord->category)
                );
    BAIL_ON_LOCK_ERROR(Error);

    Error = WZCJetSetValue(
                *pMyJetServerSession,
                *pMyClientTableHandle,
                gLogRecordTable[TIMESTAMP_IDX].ColHandle,
                &(pWZCRecord->timestamp),
                sizeof(pWZCRecord->timestamp)
                );
    BAIL_ON_LOCK_ERROR(Error);

    Error = WZCJetSetValue(
                *pMyJetServerSession,
                *pMyClientTableHandle,
                 gLogRecordTable[MESSAGE_IDX].ColHandle,
                (pWZCRecord->message).pData,
                (pWZCRecord->message).dwDataLen
                );
    BAIL_ON_LOCK_ERROR(Error);

    Error = WZCJetSetValue(
                *pMyJetServerSession,
                *pMyClientTableHandle,
                gLogRecordTable[INTERFACE_MAC_IDX].ColHandle,
                (pWZCRecord->localmac).pData,
                (pWZCRecord->localmac).dwDataLen
                );
    BAIL_ON_LOCK_ERROR(Error);

    Error = WZCJetSetValue(
                *pMyJetServerSession,
                *pMyClientTableHandle,
                gLogRecordTable[DEST_MAC_IDX].ColHandle,
                (pWZCRecord->remotemac).pData,
                (pWZCRecord->remotemac).dwDataLen
                );
    BAIL_ON_LOCK_ERROR(Error);

    Error = WZCJetSetValue(
                *pMyJetServerSession,
                *pMyClientTableHandle,
                gLogRecordTable[SSID_IDX].ColHandle,
                (pWZCRecord->ssid).pData,
                (pWZCRecord->ssid).dwDataLen
                );
    BAIL_ON_LOCK_ERROR(Error);

    Error = WZCJetSetValue(
                *pMyJetServerSession,
                *pMyClientTableHandle,
                gLogRecordTable[CONTEXT_IDX].ColHandle,
                (pWZCRecord->context).pData,
                (pWZCRecord->context).dwDataLen
                );
    BAIL_ON_LOCK_ERROR(Error);

    JetError = JetUpdate(
                   *pMyJetServerSession,
                   *pMyClientTableHandle,
                   NULL,
                   0,
                   NULL
                   );
    Error = WZCMapJetError(JetError, "AddWZCDbLogRecord: JetUpdate");
    BAIL_ON_LOCK_ERROR(Error);

    //
    // Commit changes.
    //
    Error = WZCJetCommitTransaction(
                *pMyJetServerSession,
                *pMyClientTableHandle
                );
    BAIL_ON_LOCK_ERROR(Error);

    if (gdwCurrentTableSize < MAX_RECORD_NUM) {
        gdwCurrentTableSize++;
    }
    else {
        gdwCurrentHeader = (gdwCurrentHeader + 1) > MAX_RECORD_NUM ?
                           1 : (gdwCurrentHeader + 1);
    }

    ReleaseExclusiveLock(gpWZCDbSessionRWLock);
    return (Error);

lock:

    //
    // If the transaction has been started, then roll back to the
    // start point, so that the database does not become inconsistent.
    //

    if (bStartedTransaction == TRUE) {
        LocalError = WZCJetRollBack(*pMyJetServerSession);
    }

    ReleaseExclusiveLock(gpWZCDbSessionRWLock);

    return (Error);
}


DWORD
EnumWZCDbLogRecords(
    HANDLE hSession,
    PWZC_DB_RECORD pTemplateRecord,
    PBOOL pbEnumFromStart,
    DWORD dwPreferredNumEntries,
    PWZC_DB_RECORD * ppWZCRecords,
    LPDWORD pdwNumRecords,
    LPVOID pvReserved
    )
{
    DWORD Error = 0;
    PSESSION_CONTAINER pSessionCont = NULL;


    AcquireSharedLock(gpWZCDbSessionRWLock);

    Error = GetSessionContainer(hSession, &pSessionCont);
    BAIL_ON_LOCK_ERROR(Error);

    if (pTemplateRecord) {
        Error = ERROR_NOT_SUPPORTED;
    }
    else {
        Error = IniEnumWZCDbLogRecords(
                    pSessionCont,
                    pbEnumFromStart,
                    dwPreferredNumEntries,
                    ppWZCRecords,
                    pdwNumRecords
                    );
    }
    BAIL_ON_LOCK_ERROR(Error);

    ReleaseSharedLock(gpWZCDbSessionRWLock);

    return (Error);

lock:

    ReleaseSharedLock(gpWZCDbSessionRWLock);

    return (Error);
}


DWORD
IniEnumWZCDbLogRecords(
    PSESSION_CONTAINER pSessionCont,
    PBOOL pbEnumFromStart,
    DWORD dwPreferredNumEntries,
    PWZC_DB_RECORD * ppWZCRecords,
    LPDWORD pdwNumRecords
    )
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    PWZC_DB_RECORD pWZCRecords = NULL;

    JET_SESID * pMyJetServerSession = NULL;
    JET_DBID * pMyJetDatabaseHandle = NULL;
    JET_TABLEID * pMyClientTableHandle = NULL;

    DWORD i = 0;
    PWZC_DB_RECORD pCurWZCRecord = NULL;
    JET_ERR JetError = JET_errSuccess;
    DWORD dwReqSize = 0;
    char cTempBuf[MAX_RAW_DATA_SIZE];
    DWORD dwCurIndex = 0;
    BOOL bEnumFromStart = FALSE;


    if (!dwPreferredNumEntries ||
        (dwPreferredNumEntries > MAX_RECORD_ENUM_COUNT)) {
        dwNumToEnum = MAX_RECORD_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    pWZCRecords = RpcCAlloc(sizeof(WZC_DB_RECORD)*dwNumToEnum);
    if (!pWZCRecords) {
         dwError = ERROR_OUTOFMEMORY;
         BAIL_ON_WIN32_ERROR(dwError);
    }

    memset(pWZCRecords, 0, sizeof(WZC_DB_RECORD)*dwNumToEnum);

    pMyJetServerSession = (JET_SESID *) &(pSessionCont->SessionID);
    pMyJetDatabaseHandle = (JET_DBID *) &(pSessionCont->DbID);
    pMyClientTableHandle = (JET_TABLEID *) &(pSessionCont->TableID);

    if (!(*pMyClientTableHandle)) {
        JetError = JetOpenTable(
                       *pMyJetServerSession,
                       *pMyJetDatabaseHandle,
                       LOG_RECORD_TABLE,
                       NULL,
                       0,
                       0,
                       pMyClientTableHandle
                       );
        dwError = WZCMapJetError(JetError, "JetOpenTable");
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bEnumFromStart = *pbEnumFromStart;

    if (bEnumFromStart) {
        dwError = WZCJetPrepareSearch(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[TIMESTAMP_IDX].ColName,
                      bEnumFromStart,
                      NULL,
                      0
                      );
    	BAIL_ON_WIN32_ERROR(dwError);
        bEnumFromStart = FALSE;
    }

    for (i = 0; i < dwNumToEnum; i++) {

        pCurWZCRecord = (pWZCRecords + i);

        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[RECORD_ID_IDX].ColHandle,
                      &(pCurWZCRecord->recordid),
                      sizeof(pCurWZCRecord->recordid),
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);

        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[COMPONENT_ID_IDX].ColHandle,
                      &(pCurWZCRecord->componentid),
                      sizeof(pCurWZCRecord->componentid),
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);

        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[CATEGORY_IDX].ColHandle,
                      &(pCurWZCRecord->category),
                      sizeof(pCurWZCRecord->category),
                      &dwReqSize
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[TIMESTAMP_IDX].ColHandle,
                      &(pCurWZCRecord->timestamp),
                      sizeof(pCurWZCRecord->timestamp),
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);

        dwReqSize = 0;
        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[MESSAGE_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);
        if (dwReqSize > 0) {
             (pCurWZCRecord->message).pData = RpcCAlloc(dwReqSize);
             if (!((pCurWZCRecord->message).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->message).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->message).dwDataLen = dwReqSize;
        }

        dwReqSize = 0;
        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[INTERFACE_MAC_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);
        if (dwReqSize > 0) {
             (pCurWZCRecord->localmac).pData = RpcCAlloc(dwReqSize);
             if (!((pCurWZCRecord->localmac).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->localmac).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->localmac).dwDataLen = dwReqSize;
        }

        dwReqSize = 0;
        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[DEST_MAC_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);
        if (dwReqSize > 0) {
             (pCurWZCRecord->remotemac).pData = RpcCAlloc(dwReqSize);
             if (!((pCurWZCRecord->remotemac).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->remotemac).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->remotemac).dwDataLen = dwReqSize;
        }

        dwReqSize = 0;
        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[SSID_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);
        if (dwReqSize > 0) {
             (pCurWZCRecord->ssid).pData = RpcCAlloc(dwReqSize);
             if (!((pCurWZCRecord->ssid).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->ssid).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->ssid).dwDataLen = dwReqSize;
        }

        dwReqSize = 0;
        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[CONTEXT_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);
        if (dwReqSize > 0) {
             (pCurWZCRecord->context).pData = RpcCAlloc(dwReqSize);
             if (!((pCurWZCRecord->context).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->context).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->context).dwDataLen = dwReqSize;
        }

        JetError = JetMove(
                       *pMyJetServerSession,
                       *pMyClientTableHandle,
                       JET_MoveNext,
                       0
                       );
        //
        // Don't bail from here as the end of the table (logical or physical)
        // is caught in the next call.
        //

        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[RECORD_IDX_IDX].ColHandle,
                      &dwCurIndex,
                      sizeof(dwCurIndex),
                      &dwReqSize
                      );
        if (dwCurIndex == gdwCurrentHeader || dwError != ERROR_SUCCESS) {
            dwError = ERROR_NO_MORE_ITEMS;
            i++;
            break;
        }

    }

    *pbEnumFromStart = bEnumFromStart;
    *ppWZCRecords = pWZCRecords;
    *pdwNumRecords = i;

    return (dwError);

error:

    if (pWZCRecords) {
        FreeWZCRecords(pWZCRecords, dwNumToEnum);
    }

    *ppWZCRecords = NULL;
    *pdwNumRecords = 0;

    return (dwError);
}


VOID
FreeWZCRecords(
    PWZC_DB_RECORD pWZCRecords,
    DWORD dwNumRecords
    )
{
    DWORD i = 0;

    if (pWZCRecords) {

        for (i = 0; i < dwNumRecords; i++) {

            if (pWZCRecords[i].message.pData) {
                RpcFree(pWZCRecords[i].message.pData);
            }
            if (pWZCRecords[i].localmac.pData) {
                RpcFree(pWZCRecords[i].localmac.pData);
            }
            if (pWZCRecords[i].remotemac.pData) {
                RpcFree(pWZCRecords[i].remotemac.pData);
            }
            if (pWZCRecords[i].ssid.pData) {
                RpcFree(pWZCRecords[i].ssid.pData);
            }
            if (pWZCRecords[i].context.pData) {
                RpcFree(pWZCRecords[i].context.pData);
            }


        }

        RpcFree(pWZCRecords);

    }

    return;
}


DWORD
FlushWZCDbLog(
    HANDLE hSession
    )
{
    DWORD Error = 0;
    PSESSION_CONTAINER pSessionCont = NULL;


    AcquireExclusiveLock(gpWZCDbSessionRWLock);

    Error = GetSessionContainer(hSession, &pSessionCont);
    BAIL_ON_LOCK_ERROR(Error);

    Error = IniFlushWZCDbLog();
    BAIL_ON_LOCK_ERROR(Error);

    ReleaseExclusiveLock(gpWZCDbSessionRWLock);

    return (Error);

lock:

    ReleaseExclusiveLock(gpWZCDbSessionRWLock);

    return (Error);
}


DWORD
IniFlushWZCDbLog(
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD JetError = JET_errSuccess;
    JET_SESID * pMyJetServerSession = NULL;
    JET_DBID * pMyJetDatabaseHandle = NULL;
    JET_TABLEID * pMyClientTableHandle = NULL;


    pMyJetServerSession = (JET_SESID *) &(gpAppendSessionCont->SessionID);
    pMyJetDatabaseHandle = (JET_DBID *) &(gpAppendSessionCont->DbID);
    pMyClientTableHandle = (JET_TABLEID *) &(gpAppendSessionCont->TableID);

    dwError = CloseAllTableSessions(gpSessionCont);
    BAIL_ON_WIN32_ERROR(dwError);

    JetError = JetCloseTable(
                   *pMyJetServerSession,
                   *pMyClientTableHandle
                   );
    dwError = WZCMapJetError(JetError, "JetCloseTable");
    BAIL_ON_WIN32_ERROR(dwError);
    *pMyClientTableHandle = 0;

    JetError = JetDeleteTable(
                   *pMyJetServerSession,
                   *pMyJetDatabaseHandle,
                   LOG_RECORD_TABLE
                   );
    dwError = WZCMapJetError(JetError, "JetDeleteTable");
    BAIL_ON_WIN32_ERROR(dwError);

    gdwCurrentHeader = 1;
    gdwCurrentTableSize = 0;
    gdwCurrentMaxRecordID = 0;

    dwError = WZCGetTableDataHandle(
                  pMyJetServerSession,
                  pMyJetDatabaseHandle,
                  pMyClientTableHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = OpenAllTableSessions(gpSessionCont);
    BAIL_ON_WIN32_ERROR(dwError);

    return (dwError);

error:

    return (dwError);
}


DWORD
CloseAllTableSessions(
    PSESSION_CONTAINER pSessionContList
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD JetError = JET_errSuccess;
    PSESSION_CONTAINER pSessionCont = NULL;


    pSessionCont = pSessionContList;

    while (pSessionCont) {

        JetError = JetCloseTable(
                       pSessionCont->SessionID,
                       pSessionCont->TableID
                       );
        dwError = WZCMapJetError(JetError, "JetCloseTable");
        BAIL_ON_WIN32_ERROR(dwError);
        pSessionCont->TableID = 0;

        pSessionCont = pSessionCont->pNext;

    }

error:

    return (dwError);
}


DWORD
OpenAllTableSessions(
    PSESSION_CONTAINER pSessionContList
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD JetError = JET_errSuccess;
    PSESSION_CONTAINER pSessionCont = NULL;


    pSessionCont = pSessionContList;

    while (pSessionCont) {

        if (pSessionCont->TableID == 0) {
            JetError = JetOpenTable(
                           pSessionCont->SessionID,
                           (JET_DBID)(pSessionCont->DbID),
                           LOG_RECORD_TABLE,
                           NULL,
                           0,
                           0,
                           &pSessionCont->TableID
                           );
            dwError = WZCMapJetError(JetError, "JetOpenTable");
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pSessionCont = pSessionCont->pNext;

    }

error:

    return (dwError);
}


DWORD
WZCGetTableDataHandle(
    JET_SESID * pMyJetServerSession,
    JET_DBID * pMyJetDatabaseHandle,
    JET_TABLEID * pMyClientTableHandle
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD JetError = JET_errSuccess;


    //
    // Create a new table. It will be opened in exclusive mode by
    // Jet Engine.
    //
    dwError = WZCCreateTableData(
                  *pMyJetServerSession,
                  *pMyJetDatabaseHandle,
                  pMyClientTableHandle
                  );
    if (dwError != JET_errTableDuplicate) {

        BAIL_ON_WIN32_ERROR(dwError);

        //
        // Close the table since it is exclusively locked now.
        //

        JetError = JetCloseTable(
                       *pMyJetServerSession,
                       *pMyClientTableHandle
                       );
        dwError = WZCMapJetError(JetError, "JetCloseTable");
        if (dwError != ERROR_SUCCESS) {
            ASSERT(FALSE);
        }
        BAIL_ON_WIN32_ERROR(dwError);
        *pMyClientTableHandle = 0;

    }
    *pMyClientTableHandle = 0;

    //
    // Reopen the table in non-exclusive mode.
    //
    dwError = WZCOpenTableData(
                  *pMyJetServerSession,
                  *pMyJetDatabaseHandle,
                  pMyClientTableHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}

DWORD
IniEnumWZCDbLogRecordsSummary(
    PSESSION_CONTAINER pSessionCont,
    PBOOL pbEnumFromStart,
    DWORD dwPreferredNumEntries,
    PWZC_DB_RECORD * ppWZCRecords,
    LPDWORD pdwNumRecords
    )
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    PWZC_DB_RECORD pWZCRecords = NULL;

    JET_SESID * pMyJetServerSession = NULL;
    JET_DBID * pMyJetDatabaseHandle = NULL;
    JET_TABLEID * pMyClientTableHandle = NULL;

    DWORD i = 0;
    PWZC_DB_RECORD pCurWZCRecord = NULL;
    JET_ERR JetError = JET_errSuccess;
    DWORD dwReqSize = 0;
    char cTempBuf[MAX_RAW_DATA_SIZE];
    DWORD dwCurIndex = 0;
    BOOL bEnumFromStart = FALSE;


    if (!dwPreferredNumEntries ||
        (dwPreferredNumEntries > MAX_RECORD_ENUM_COUNT)) {
        dwNumToEnum = MAX_RECORD_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    pWZCRecords = RpcCAlloc(sizeof(WZC_DB_RECORD)*dwNumToEnum);
    if (!pWZCRecords) {
         dwError = ERROR_OUTOFMEMORY;
         BAIL_ON_WIN32_ERROR(dwError);
    }

    memset(pWZCRecords, 0, sizeof(WZC_DB_RECORD)*dwNumToEnum);

    pMyJetServerSession = (JET_SESID *) &(pSessionCont->SessionID);
    pMyJetDatabaseHandle = (JET_DBID *) &(pSessionCont->DbID);
    pMyClientTableHandle = (JET_TABLEID *) &(pSessionCont->TableID);

    if (!(*pMyClientTableHandle)) {
        JetError = JetOpenTable(
                       *pMyJetServerSession,
                       *pMyJetDatabaseHandle,
                       LOG_RECORD_TABLE,
                       NULL,
                       0,
                       0,
                       pMyClientTableHandle
                       );
        dwError = WZCMapJetError(JetError, "JetOpenTable");
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bEnumFromStart = *pbEnumFromStart;

    if (bEnumFromStart) {
        dwError = WZCJetPrepareSearch(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[TIMESTAMP_IDX].ColName,
                      bEnumFromStart,
                      NULL,
                      0
                      );
    	BAIL_ON_WIN32_ERROR(dwError);
        bEnumFromStart = FALSE;
    }

    for (i = 0; i < dwNumToEnum; i++) {

        pCurWZCRecord = (pWZCRecords + i);

        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[RECORD_IDX_IDX].ColHandle,
                      &(pCurWZCRecord->recordid),
                      sizeof(pCurWZCRecord->recordid),
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);

        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[COMPONENT_ID_IDX].ColHandle,
                      &(pCurWZCRecord->componentid),
                      sizeof(pCurWZCRecord->componentid),
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);

        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[CATEGORY_IDX].ColHandle,
                      &(pCurWZCRecord->category),
                      sizeof(pCurWZCRecord->category),
                      &dwReqSize
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[TIMESTAMP_IDX].ColHandle,
                      &(pCurWZCRecord->timestamp),
                      sizeof(pCurWZCRecord->timestamp),
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);

        dwReqSize = 0;
        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[INTERFACE_MAC_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);
        if (dwReqSize > 0) {
             (pCurWZCRecord->localmac).pData = RpcCAlloc(dwReqSize);
             if (!((pCurWZCRecord->localmac).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->localmac).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->localmac).dwDataLen = dwReqSize;
        }

        dwReqSize = 0;
        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[DEST_MAC_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);
        if (dwReqSize > 0) {
             (pCurWZCRecord->remotemac).pData = RpcCAlloc(dwReqSize);
             if (!((pCurWZCRecord->remotemac).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->remotemac).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->remotemac).dwDataLen = dwReqSize;
        }

        dwReqSize = 0;
        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[SSID_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);
        if (dwReqSize > 0) {
             (pCurWZCRecord->ssid).pData = RpcCAlloc(dwReqSize);
             if (!((pCurWZCRecord->ssid).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->ssid).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->ssid).dwDataLen = dwReqSize;
        }

        dwReqSize = 0;
        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[MESSAGE_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    	BAIL_ON_WIN32_ERROR(dwError);
        if (dwReqSize > 0) {
        	//
        	// only get (up to) MAX_SUMMARY_MESSAGE_SIZE message data
        	//
		dwReqSize = dwReqSize <= MAX_SUMMARY_MESSAGE_SIZE ?
					dwReqSize : MAX_SUMMARY_MESSAGE_SIZE;
             (pCurWZCRecord->message).pData = RpcCAlloc(dwReqSize + 2);
             ZeroMemory((pCurWZCRecord->message).pData, dwReqSize + 2);
             if (!((pCurWZCRecord->message).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->message).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->message).dwDataLen = dwReqSize + 2;
        }

	//
	// do not get context at all
	//
	(pCurWZCRecord->context).pData = NULL;
       (pCurWZCRecord->context).dwDataLen = 0;

        JetError = JetMove(
                       *pMyJetServerSession,
                       *pMyClientTableHandle,
                       JET_MoveNext,
                       0
                       );
        //
        // Don't bail from here as the end of the table (logical or physical)
        // is caught in the next call.
        //

        dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[RECORD_IDX_IDX].ColHandle,
                      &dwCurIndex,
                      sizeof(dwCurIndex),
                      &dwReqSize
                      );
        if (dwCurIndex == gdwCurrentHeader || dwError != ERROR_SUCCESS) {
	    JetError = JetMove(
	                 *pMyJetServerSession,
	                 *pMyClientTableHandle,
	                 JET_MoveLast,
                	 0
	                 );
	    dwError = WZCMapJetError(JetError, "JetMove");
	    if (dwError == ERROR_SUCCESS)
	            dwError = ERROR_NO_MORE_ITEMS;
            i++;
            break;
        }

    }

    *pbEnumFromStart = bEnumFromStart;
    *ppWZCRecords = pWZCRecords;
    *pdwNumRecords = i;

    return (dwError);

error:

    if (pWZCRecords) {
        FreeWZCRecords(pWZCRecords, dwNumToEnum);
    }

    *ppWZCRecords = NULL;
    *pdwNumRecords = 0;

    return (dwError);
}

DWORD
EnumWZCDbLogRecordsSummary(
    HANDLE hSession,
    PWZC_DB_RECORD pTemplateRecord,
    PBOOL pbEnumFromStart,
    DWORD dwPreferredNumEntries,
    PWZC_DB_RECORD * ppWZCRecords,
    LPDWORD pdwNumRecords,
    LPVOID pvReserved
    )
{
    DWORD Error = 0;
    PSESSION_CONTAINER pSessionCont = NULL;


    AcquireSharedLock(gpWZCDbSessionRWLock);

    Error = GetSessionContainer(hSession, &pSessionCont);
    BAIL_ON_LOCK_ERROR(Error);

    if (pTemplateRecord) {
        Error = ERROR_NOT_SUPPORTED;
    }
    else {
        Error = IniEnumWZCDbLogRecordsSummary(
                    pSessionCont,
                    pbEnumFromStart,
                    dwPreferredNumEntries,
                    ppWZCRecords,
                    pdwNumRecords
                    );
    }
    BAIL_ON_LOCK_ERROR(Error);

    ReleaseSharedLock(gpWZCDbSessionRWLock);

    return (Error);

lock:

    ReleaseSharedLock(gpWZCDbSessionRWLock);

    return (Error);
}

DWORD
GetWZCDbLogRecord(
    HANDLE hSession,
    PWZC_DB_RECORD pTemplateRecord,
    PWZC_DB_RECORD * ppWZCRecords,
    LPVOID pvReserved
    )
{
    DWORD Error = 0;
    PSESSION_CONTAINER pSessionCont = NULL;
    SESSION_CONTAINER mySessionCont;

    AcquireSharedLock(gpWZCDbSessionRWLock);

    Error = GetSessionContainer(hSession, &pSessionCont);
    BAIL_ON_LOCK_ERROR(Error);

    ZeroMemory(&mySessionCont, sizeof(SESSION_CONTAINER));

    Error = IniOpenWZCDbLogSession(&mySessionCont);
    BAIL_ON_LOCK_ERROR(Error);

    if (!pTemplateRecord) {
        Error = ERROR_INVALID_HANDLE;
    }
    else {
        Error = IniGetWZCDbLogRecord(
                    &mySessionCont,
                    pTemplateRecord,
                    ppWZCRecords
                    );
    }
    BAIL_ON_LOCK_ERROR(Error);

    Error = IniCloseWZCDbLogSession(&mySessionCont);
    BAIL_ON_LOCK_ERROR(Error);

    ReleaseSharedLock(gpWZCDbSessionRWLock);
    
    return (Error);

lock:

    ReleaseSharedLock(gpWZCDbSessionRWLock);

    return (Error);

};

DWORD
IniGetWZCDbLogRecord(
    PSESSION_CONTAINER pSessionCont,
    PWZC_DB_RECORD pTemplateRecord,
    PWZC_DB_RECORD * ppWZCRecords
    )
{
    DWORD dwError = 0;
    PWZC_DB_RECORD pWZCRecords = NULL;

    JET_SESID * pMyJetServerSession = NULL;
    JET_DBID * pMyJetDatabaseHandle = NULL;
    JET_TABLEID * pMyClientTableHandle = NULL;

    PWZC_DB_RECORD pCurWZCRecord = NULL;
    JET_ERR JetError = JET_errSuccess;
    DWORD dwReqSize = 0;
    char cTempBuf[MAX_RAW_DATA_SIZE];

  
    pWZCRecords = RpcCAlloc(sizeof(WZC_DB_RECORD));
    if (!pWZCRecords) {
         dwError = ERROR_OUTOFMEMORY;
         BAIL_ON_WIN32_ERROR(dwError);
    }

    memset(pWZCRecords, 0, sizeof(WZC_DB_RECORD));

    pMyJetServerSession = (JET_SESID *) &(pSessionCont->SessionID);
    pMyJetDatabaseHandle = (JET_DBID *) &(pSessionCont->DbID);
    pMyClientTableHandle = (JET_TABLEID *) &(pSessionCont->TableID);

    if (!(*pMyClientTableHandle)) {
        JetError = JetOpenTable(
                       *pMyJetServerSession,
                       *pMyJetDatabaseHandle,
                       LOG_RECORD_TABLE,
                       NULL,
                       0,
                       0,
                       pMyClientTableHandle
                       );
        dwError = WZCMapJetError(JetError, "JetOpenTable");
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // seek to the perticular position
    //
    dwError = WZCSeekRecordOnIndexTime(
                     *pMyJetServerSession,
                     *pMyClientTableHandle,
			pTemplateRecord->recordid,
			pTemplateRecord->timestamp
                     );
    if (dwError != ERROR_SUCCESS)
    		dwError = ERROR_NO_MORE_ITEMS;
    BAIL_ON_WIN32_ERROR(dwError);


    pCurWZCRecord = pWZCRecords;

    dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[RECORD_IDX_IDX].ColHandle,
                      &(pCurWZCRecord->recordid),
                      sizeof(pCurWZCRecord->recordid),
                      &dwReqSize
                      );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[COMPONENT_ID_IDX].ColHandle,
                      &(pCurWZCRecord->componentid),
                      sizeof(pCurWZCRecord->componentid),
                      &dwReqSize
                      );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[CATEGORY_IDX].ColHandle,
                      &(pCurWZCRecord->category),
                      sizeof(pCurWZCRecord->category),
                      &dwReqSize
                      );
     BAIL_ON_WIN32_ERROR(dwError);

     dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[TIMESTAMP_IDX].ColHandle,
                      &(pCurWZCRecord->timestamp),
                      sizeof(pCurWZCRecord->timestamp),
                      &dwReqSize
                      );
    BAIL_ON_WIN32_ERROR(dwError);

     dwReqSize = 0;
     dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[INTERFACE_MAC_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    BAIL_ON_WIN32_ERROR(dwError);
    if (dwReqSize > 0) {
             (pCurWZCRecord->localmac).pData = RpcCAlloc(dwReqSize);
             if (!((pCurWZCRecord->localmac).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->localmac).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->localmac).dwDataLen = dwReqSize;
        }

    dwReqSize = 0;
    dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[DEST_MAC_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    BAIL_ON_WIN32_ERROR(dwError);
    if (dwReqSize > 0) {
             (pCurWZCRecord->remotemac).pData = RpcCAlloc(dwReqSize);
             if (!((pCurWZCRecord->remotemac).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->remotemac).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->remotemac).dwDataLen = dwReqSize;
        }

    dwReqSize = 0;
    dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[SSID_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    BAIL_ON_WIN32_ERROR(dwError);
    if (dwReqSize > 0) {
             (pCurWZCRecord->ssid).pData = RpcCAlloc(dwReqSize);
             if (!((pCurWZCRecord->ssid).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->ssid).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->ssid).dwDataLen = dwReqSize;
        }

    dwReqSize = 0;
    dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[MESSAGE_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    BAIL_ON_WIN32_ERROR(dwError);
    if (dwReqSize > 0) {
             (pCurWZCRecord->message).pData = RpcCAlloc(dwReqSize);
             ZeroMemory((pCurWZCRecord->message).pData, dwReqSize);
             if (!((pCurWZCRecord->message).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->message).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->message).dwDataLen = dwReqSize;
        }

    dwReqSize = 0;
    dwError = WZCJetGetValue(
                      *pMyJetServerSession,
                      *pMyClientTableHandle,
                      gLogRecordTable[CONTEXT_IDX].ColHandle,
                      cTempBuf,
                      MAX_RAW_DATA_SIZE,
                      &dwReqSize
                      );
    BAIL_ON_WIN32_ERROR(dwError);
    if (dwReqSize > 0) {
             (pCurWZCRecord->context).pData = RpcCAlloc(dwReqSize);
             if (!((pCurWZCRecord->context).pData)) {
                 dwError = ERROR_OUTOFMEMORY;
                 BAIL_ON_WIN32_ERROR(dwError);
             }
             memcpy((pCurWZCRecord->context).pData, cTempBuf, dwReqSize);
             (pCurWZCRecord->context).dwDataLen = dwReqSize;
        }

    *ppWZCRecords = pWZCRecords;

    return (dwError);

error:

    if (pWZCRecords) {
        FreeWZCRecords(pWZCRecords, 1);
    }

    *ppWZCRecords = NULL;

    return (dwError);

}


DWORD
WZCSeekRecordOnIndexTime(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle,
    DWORD	dwIndex,
    FILETIME	ftTimeStamp
    )
/*++

Routine Description:

    This function seeks a record based on index and timestamp

Arguments:

    JetServerSession - Server session id.
    JetTableHandle - Table handle.
    dwIndex	- record index
    ftTimeStamp - record timestamp

Return Value:

    Winerror code.

--*/
{
    JET_ERR JetError = JET_errSuccess;
    DWORD Error = 0;
    LONG	lErr = 0;
    DWORD dwKeySize = sizeof (dwIndex);

    DWORD  dwReqSize = 0;
    FILETIME ftMyTimeStamp;

    JetError = JetSetCurrentIndex(
                   JetServerSession,
                   JetTableHandle,
                   gLogRecordTable[RECORD_IDX_IDX].ColName
                   );
    Error = WZCMapJetError(JetError, "JetPrepareSearch: JetSetCurrentIndex");
    if (Error != ERROR_SUCCESS) {
        WZCMapJetError(JetError, gLogRecordTable[RECORD_IDX_IDX].ColName);
        return (Error);
    }

    	
    JetError = JetMove(
                       JetServerSession,
                       JetTableHandle,
                       JET_MoveFirst,
                       0
                       );
     Error = WZCMapJetError(JetError, "JetPrepareSearch: JetMove");
     if (Error != ERROR_SUCCESS) {
            WZCMapJetError(JetError, gLogRecordTable[RECORD_IDX_IDX].ColName);
            return (Error);
        }

    JetError = JetMakeKey(
                       JetServerSession,
                       JetTableHandle,
                       &dwIndex,
                       dwKeySize,
                       JET_bitNewKey
                       );
     Error = WZCMapJetError(JetError, "JetPrepareSearch: JetMakeKey");
     if (Error != ERROR_SUCCESS) {
            WZCMapJetError(JetError, gLogRecordTable[RECORD_IDX_IDX].ColName);
            return (Error);
        }

    JetError = JetSeek(
                       JetServerSession,
                       JetTableHandle,
                       JET_bitSeekEQ
                       );
    Error = WZCMapJetError(JetError, "JetPrepareSearch: JetMove / JetSeek");

    if (Error == ERROR_SUCCESS) {
		dwReqSize = 0;
		Error = WZCJetGetValue(
              	        JetServerSession,
                     	 JetTableHandle,
	                      gLogRecordTable[TIMESTAMP_IDX].ColHandle,
       	               &ftMyTimeStamp,
              	        sizeof(ftMyTimeStamp),
                     	 &dwReqSize
	                      );
		if (Error == ERROR_SUCCESS) {
			lErr = CompareFileTime(
				&ftMyTimeStamp,
				&ftTimeStamp
				);
			if (lErr != 0) 
				Error = ERROR_NO_MORE_ITEMS;	
			}
     	}
     
    return (Error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\dsstore.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       dsstore.h
//
//  Contents:  Policy management for directory
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

DWORD
OpenDirectoryServerHandle(
                          LPWSTR pszDomainName,
                          DWORD dwPortNumber,
                          HLDAP * phLdapBindHandle
                          );


DWORD
CloseDirectoryServerHandle(
                           HLDAP hLdapBindHandle
                           );

DWORD
ReadPolicyObjectFromDirectory(
                              HLDAP hLdapBindHandle,
                              LPWSTR pszPolicyDN,
                              PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
                              );


DWORD
AppendCommonNameToQuery(
                        LPWSTR szQueryBuffer,
                        LPWSTR szCommonName
                        );

DWORD
ComputePrelimCN(
                LPWSTR szDN,
                LPWSTR szCommonName
                );

DWORD
UnMarshallPolicyObject(
                       HLDAP hLdapBindHandle,
                       LPWSTR pszPolicyDN,
                       PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject,
                       LDAPMessage *res
                       );



typedef struct _ldapobject
{
    union {
        WCHAR *strVals;
        struct berval *bVals;
    } val;
} LDAPOBJECT, *PLDAPOBJECT;

#define LDAPOBJECT_STRING(pldapobject)      ((pldapobject)->val.strVals)
#define LDAPOBJECT_BERVAL(pldapobject)      ((pldapobject)->val.bVals)
#define LDAPOBJECT_BERVAL_VAL(pldapobject)  ((pldapobject)->val.bVals->bv_val)
#define LDAPOBJECT_BERVAL_LEN(pldapobject)  ((pldapobject)->val.bVals->bv_len)


void
FreeWirelessPolicyObject(
                      PWIRELESS_POLICY_OBJECT pWirelessPolicyObject
                      );


DWORD
ComputePolicyContainerDN(
                         LPWSTR pszPolicyDN,
                         LPWSTR * ppszPolicyContainerDN
                         );

DWORD
ComputeDefaultDirectory(
                        LPWSTR * ppszDefaultDirectory
                        );


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\ldaputil.h ===
typedef LDAP * PLDAP;

typedef PLDAP HLDAP;

DWORD
LdapOpen(
         WCHAR *domainName,
         int portno,
         HLDAP * phLdapHandle
         );


DWORD
LdapBind(
         HLDAP hLdapHandle
         );

DWORD
LdapSearchHelper(
                 HLDAP hLdapHandle,
                 WCHAR *base,
                 int   scope,
                 WCHAR *filter,
                 WCHAR *attrs[],
                 int   attrsonly,
                 struct l_timeval *timeout,
                 LDAPMessage **res
                 );

DWORD
LdapSearchS(
            HLDAP hLdapHandle,
            WCHAR *base,
            int   scope,
            WCHAR *filter,
            WCHAR *attrs[],
            int   attrsonly,
            LDAPMessage **res
            );

DWORD
LdapSearchST(
             HLDAP hLdapHandle,
             WCHAR *base,
             int   scope,
             WCHAR *filter,
             WCHAR *attrs[],
             int   attrsonly,
             struct l_timeval *timeout,
             LDAPMessage **res
             );

DWORD
CheckAndSetExtendedError(
                         HLDAP hLdapHandle,
                         int ldaperr
                         );


DWORD
LdapFirstEntry(
               HLDAP hLdapHandle,
               LDAPMessage *res,
               LDAPMessage **pfirst
               );

DWORD
LdapGetValues(
              HLDAP hLdapHandle,
              LDAPMessage *entry,
              WCHAR *attr,
              WCHAR ***pvalues,
              int   *pcount
              );

DWORD
LdapGetValuesLen(
                 HLDAP hLdapHandle,
                 LDAPMessage *entry,
                 WCHAR *attr,
                 struct berval ***pvalues,
                 int   *pcount
                 );

DWORD
LdapNextEntry(
              HLDAP hLdapHandle,
              LDAPMessage *entry,
              LDAPMessage **pnext
              );

int
LdapCountEntries(
                 HLDAP hLdapHandle,
                 LDAPMessage *res
                 );

void
LdapMsgFree(
            LDAPMessage *res
            );

void LdapValueFree(
                   WCHAR **vals
                   );

void LdapValueFreeLen(
                      struct berval **vals
                      );

DWORD
LdapAddS(
         HLDAP hLdapHandle,
         WCHAR *dn,
         LDAPModW *attrs[]
         );

DWORD
LdapModifyS(
            HLDAP hLdapHandle,
            WCHAR *dn,
            LDAPModW *mods[]
            );

DWORD
LdapDeleteS(
            HLDAP hLdapHandle,
            WCHAR *dn
            );

DWORD
LdapRename(
    HLDAP hLdapHandle, 
    WCHAR * oldDn,
    WCHAR * newDn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\monitor\inc\database.h ===
/*Copyright (c) 1994  Microsoft Corporation

Module Name:

    database.h

Abstract:



Author:



Revision History:



--*/

#ifndef _DATABASE_
#define _DATABASE_


#define cszWLANMonInstanceName     "WLANMON"

//
//  database constants.
//
#define DB_TABLE_SIZE       10      // table size in 4K pages.
#define DB_TABLE_DENSITY    80      // page density
#define DB_LANGID           0x0409  // language id
#define DB_CP               1252    // code page


/***************** New Added **********************/

#include  "wzcmon.h"


#define DBFILENAMEPREFIX	"windir"
#define DBFILENAMESUFFIX	"\\tracing\\wzcmon\\"
#define DBFILENAME 		    "amlog.mdb"


#define LOG_RECORD_TABLE    "LogTable"

#define RECORD_IDX_STR      "RecordIndex"
#define RECORD_ID_STR	    "RecordID"
#define COMPONENT_ID_STR    "ComponentID"
#define CATEGORY_STR        "Category"
#define TIMESTAMP_STR       "TimeStamp"
#define MESSAGE_STR         "Message"
#define INTERFACE_MAC_STR   "InterfaceMAC"
#define DEST_MAC_STR	    "DestMac"
#define SSID_STR	    "SSID"
#define CONTEXT_STR	    "Context"


#define RECORD_IDX_IDX      0
#define RECORD_ID_IDX	    1
#define COMPONENT_ID_IDX    2
#define CATEGORY_IDX        3
#define TIMESTAMP_IDX       4
#define MESSAGE_IDX         5
#define INTERFACE_MAC_IDX   6
#define DEST_MAC_IDX        7
#define SSID_IDX	    8
#define CONTEXT_IDX	    9


#define MAX_CHECK_POINT_DEPTH   (20*1024*1024)

#define MAX_RECORD_NUM          5000

#define MAX_SUMMARY_MESSAGE_SIZE		80

#define MAX_SESSION_NUM         5


/*************************************************/

typedef struct _TABLE_INFO {
    CHAR * ColName;
    JET_COLUMNID ColHandle;
    JET_COLTYP ColType;
    DWORD dwJetBit;
} TABLE_INFO, * PTABLE_INFO;

typedef struct _SESSION_CONTAINER {
    DWORD_PTR SessionID;
    DWORD_PTR DbID;
    DWORD_PTR TableID;
    struct _SESSION_CONTAINER * pNext;
} SESSION_CONTAINER, * PSESSION_CONTAINER;

/********************* New added functions **************/


typedef struct _WZC_RW_LOCK {
    CRITICAL_SECTION csExclusive;
    BOOL bInitExclusive;
    CRITICAL_SECTION csShared;
    BOOL bInitShared;
    LONG lReaders;
    HANDLE hReadDone;
    DWORD dwCurExclusiveOwnerThreadId;
} WZC_RW_LOCK, * PWZC_RW_LOCK;


DWORD
InitWZCDbGlobals(   
    BOOL bLoggingEnabled
    );

VOID
DeInitWZCDbGlobals(
    );

DWORD
WZCSetLoggingState(
    BOOL    bLoggingEnabled
);

DWORD
WZCMapJetError(
    JET_ERR JetError,
    LPSTR CallerInfo OPTIONAL
    );

DWORD
WZCCreateDatabase(
    JET_SESID JetServerSession,
    CHAR * Connect,
    JET_DBID * pJetDatabaseHandle,
    JET_GRBIT JetBits
    );

DWORD
WZCOpenDatabase(
    JET_SESID JetServerSession,
    CHAR * Connect,
    JET_DBID * pJetDatabaseHandle,
    JET_GRBIT JetBits
    );

DWORD
WZCInitializeDatabase(
    JET_SESID * pJetServerSession
    );

VOID
WZCTerminateJet(
    JET_SESID * pJetServerSession
    );

DWORD
WZCJetBeginTransaction(
    JET_SESID JetServerSession
    );

DWORD
WZCJetRollBack(
    JET_SESID JetServerSession
    );

DWORD
WZCJetCommitTransaction(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle
    );

DWORD
WZCJetPrepareUpdate(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle,
    char * ColumnName,
    PVOID Key,
    DWORD KeySize,
    BOOL NewRecord
    );

DWORD
WZCJetCommitUpdate(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle
    );

DWORD
WZCJetSetValue(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle,
    JET_COLUMNID KeyColumnId,
    PVOID Data,
    DWORD DataSize
    );

DWORD
WZCJetPrepareSearch(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle,
    char * ColumnName,
    BOOL SearchFromStart,
    PVOID Key,
    DWORD KeySize
    );

DWORD
WZCJetNextRecord(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle
    );

DWORD
WZCCreateTableData(
    JET_SESID JetServerSession,
    JET_DBID JetDatabaseHandle,
    JET_TABLEID * pJetTableHandle
    );

DWORD
WZCOpenTableData(
    JET_SESID JetServerSession,
    JET_DBID JetDatabaseHandle,
    JET_TABLEID * pJetTableHandle
    );

DWORD
WZCJetGetValue(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle,
    JET_COLUMNID ColumnId,
    PVOID pvData,
    DWORD dwSize,
    PDWORD pdwRequiredSize
    );

DWORD
CreateSessionCont(
    PSESSION_CONTAINER * ppSessionCont
    );

DWORD
IniOpenWZCDbLogSession(
    PSESSION_CONTAINER pSessionCont
    );

VOID
FreeSessionCont(
    PSESSION_CONTAINER pSessionCont
    );

DWORD
GetSessionContainer(
    HANDLE hSession,
    PSESSION_CONTAINER * ppSessionCont
    );

DWORD
IniCloseWZCDbLogSession(
    PSESSION_CONTAINER pSessionCont
    );

VOID
RemoveSessionCont(
    PSESSION_CONTAINER pSessionCont
    );

VOID
DestroySessionContList(
    PSESSION_CONTAINER pSessionContList
    );

DWORD
WZCOpenAppendSession(
    PSESSION_CONTAINER pSessionCont
    );

DWORD
WZCCloseAppendSession(
    PSESSION_CONTAINER pSessionCont
    );

DWORD
IniEnumWZCDbLogRecords(
    PSESSION_CONTAINER pSessionCont,
    PBOOL pbEnumFromStart,
    DWORD dwPreferredNumEntries,
    PWZC_DB_RECORD * ppWZCRecords,
    LPDWORD pdwNumRecords
    );

VOID
FreeWZCRecords(
    PWZC_DB_RECORD pWZCRecords,
    DWORD dwNumRecords
    );

DWORD
IniFlushWZCDbLog(
    );

DWORD
CloseAllTableSessions(
    PSESSION_CONTAINER pSessionContList
    );

DWORD
OpenAllTableSessions(
    PSESSION_CONTAINER pSessionContList
    );

DWORD
WZCGetTableDataHandle(
    JET_SESID * pMyJetServerSession,
    JET_DBID * pMyJetDatabaseHandle,
    JET_TABLEID * pMyClientTableHandle
    );

BOOL
IsDBOpened(
    );

DWORD
IniEnumWZCDbLogRecordsSummary(
    PSESSION_CONTAINER pSessionCont,
    PBOOL pbEnumFromStart,
    DWORD dwPreferredNumEntries,
    PWZC_DB_RECORD * ppWZCRecords,
    LPDWORD pdwNumRecords
    );

DWORD
EnumWZCDbLogRecordsSummary(
    HANDLE hSession,
    PWZC_DB_RECORD pTemplateRecord,
    PBOOL pbEnumFromStart,
    DWORD dwPreferredNumEntries,
    PWZC_DB_RECORD * ppWZCRecords,
    LPDWORD pdwNumRecords,
    LPVOID pvReserved
    );

DWORD
GetWZCDbLogRecord(
    HANDLE hSession,
    PWZC_DB_RECORD pTemplateRecord,
    PWZC_DB_RECORD * ppWZCRecords,
    LPVOID pvReserved
    );
    
DWORD
IniGetWZCDbLogRecord(
    PSESSION_CONTAINER pSessionCont,
    PWZC_DB_RECORD pTemplateRecord,
    PWZC_DB_RECORD * ppWZCRecords
    );

DWORD
WZCSeekRecordOnIndexTime(
    JET_SESID JetServerSession,
    JET_TABLEID JetTableHandle,
    DWORD	dwIndex,
    FILETIME	ftTimeStamp
    );

/*******************************************************/
#endif // _DATABASE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\dsstore.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       dsstore.c
//
//  Contents:  Policy management for directory
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "precomp.h"

LPWSTR PolicyDNAttributes[] = {
    L"msieee80211-ID",
        L"description",
        L"msieee80211-DataType",
        L"msieee80211-Data",
        L"cn",
        L"distinguishedName",
        L"whenChanged",
        NULL
};


DWORD
OpenDirectoryServerHandle(
                          LPWSTR pszDomainName,
                          DWORD dwPortNumber,
                          HLDAP * phLdapBindHandle
                          )
{
    DWORD dwError = 0;
    
    
    *phLdapBindHandle = NULL;
    
    dwError = LdapOpen(
        pszDomainName,
        dwPortNumber,
        phLdapBindHandle
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = LdapBind(
        *phLdapBindHandle
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    return(dwError);
    
error:
    
    if (*phLdapBindHandle) {
        CloseDirectoryServerHandle(
            *phLdapBindHandle
            );
        *phLdapBindHandle = NULL;
    }
    
    return(dwError);
}

DWORD
CloseDirectoryServerHandle(
    HLDAP hLdapBindHandle
    )
{
    
    int ldaperr = 0;
    
    if (hLdapBindHandle) {
        
        ldaperr = ldap_unbind(hLdapBindHandle);
        
    }
    
    return(0);
}


DWORD
ReadPolicyObjectFromDirectory(
                              HLDAP hLdapBindHandle,
                              LPWSTR pszPolicyDN,
                              PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
                              )
{
    
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    LPWSTR szFilterString = L"(objectClass=*)";
    DWORD dwError = 0;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    
    
    dwError = LdapSearchST(
        hLdapBindHandle,
        pszPolicyDN,
        LDAP_SCOPE_BASE,
        szFilterString,
        PolicyDNAttributes,
        0,
        NULL,
        &res
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = UnMarshallPolicyObject(
        hLdapBindHandle,
        pszPolicyDN,
        &pWirelessPolicyObject,
        res
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    
    
    *ppWirelessPolicyObject = pWirelessPolicyObject;
    
cleanup:
    
    if (res) {
        LdapMsgFree(res);
    }
    
    return(dwError);
    
error:
    
    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(
            pWirelessPolicyObject
            );
    }
    
    *ppWirelessPolicyObject = NULL;
    
    goto cleanup;
    
}



DWORD
UnMarshallPolicyObject(
                       HLDAP hLdapBindHandle,
                       LPWSTR pszPolicyDN,
                       PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject,
                       LDAPMessage *res
                       )
{
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    LDAPMessage *e = NULL;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszTemp = NULL;
    
    
    pWirelessPolicyObject = (PWIRELESS_POLICY_OBJECT)AllocPolMem(
        sizeof(WIRELESS_POLICY_OBJECT)
        );
    if (!pWirelessPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    
    dwError = LdapFirstEntry(
        hLdapBindHandle,
        res,
        &e
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    /*
    strvalues = NULL;
    dwError = LdapGetValues(
    hLdapBindHandle,
    e,
    L"distinguishedName",
    (WCHAR ***)&strvalues,
    (int *)&dwCount
    );
    BAIL_ON_WIN32_ERROR(dwError);
    */
    
    pWirelessPolicyObject->pszWirelessOwnersReference = AllocPolStr(
        pszPolicyDN
        );
    if (!pWirelessPolicyObject->pszWirelessOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    strvalues = NULL;
    dwError = LdapGetValues(
        hLdapBindHandle,
        e,
        L"cn",
        (WCHAR ***)&strvalues,
        (int *)&dwCount
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pWirelessPolicyObject->pszWirelessName = AllocPolStr(
        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
        );
    if (!pWirelessPolicyObject->pszWirelessName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);
    
    
    strvalues = NULL;
    dwError = LdapGetValues(
        hLdapBindHandle,
        e,
        L"description",
        (WCHAR ***)&strvalues,
        (int *)&dwCount
        );
    // BAIL_ON_WIN32_ERROR(dwError);
    
    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {
        
        pWirelessPolicyObject->pszDescription = AllocPolStr(
            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
            );
        if (!pWirelessPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);
        
    } else {
        pWirelessPolicyObject->pszDescription = NULL;
    }
    
    
    strvalues = NULL;
    dwError = LdapGetValues(
        hLdapBindHandle,
        e,
        L"msieee80211-ID",
        (WCHAR ***)&strvalues,
        (int *)&dwCount
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    pWirelessPolicyObject->pszWirelessID = AllocPolStr(
        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
        );
    if (!pWirelessPolicyObject->pszWirelessID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);
    
    
    strvalues = NULL;
    dwError = LdapGetValues(
        hLdapBindHandle,
        e,
        L"msieee80211-DataType",
        (WCHAR ***)&strvalues,
        (int *)&dwCount
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pWirelessPolicyObject->dwWirelessDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);
    
    strvalues = NULL;
    dwError = LdapGetValues(
        hLdapBindHandle,
        e,
        L"whenChanged",
        (WCHAR ***)&strvalues,
        (int *)&dwCount
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pWirelessPolicyObject->dwWhenChanged = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);
    
    
    
    //
    // unmarshall the msieee80211-Data blob
    //
    
    dwError = LdapGetValuesLen(
        hLdapBindHandle,
        e,
        L"msieee80211-Data",
        (struct berval ***)&bvalues,
        (int *)&dwCount
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pWirelessPolicyObject->pWirelessData = pBuffer;
    pWirelessPolicyObject->dwWirelessDataLen = dwLen;
    LdapValueFreeLen(bvalues);
    
    
    *ppWirelessPolicyObject = pWirelessPolicyObject;
    
    return(dwError);
    
error:
    
    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyObject);
    }
    
    *ppWirelessPolicyObject = NULL;
    
    return(dwError);
}



DWORD
ComputePrelimCN(
                LPWSTR szDN,
                LPWSTR szCommonName
                )
{
    LPWSTR pszComma = NULL;
    
    pszComma = wcschr(szDN, L',');
    
    if (!pszComma) {
        return (ERROR_INVALID_DATA);
    }
    
    *pszComma = L'\0';
    
    wcscpy(szCommonName, szDN);
    
    *pszComma = L',';
    
    return(0);
}

DWORD
ComputePolicyContainerDN(
                         LPWSTR pszPolicyDN,
                         LPWSTR * ppszPolicyContainerDN
                         )
{
    LPWSTR pszComma = NULL;
    LPWSTR pszPolicyContainer = NULL;
    DWORD dwError = 0;
    
    *ppszPolicyContainerDN = NULL;
    pszComma = wcschr(pszPolicyDN, L',');
    
    pszPolicyContainer = AllocPolStr(
        pszComma + 1
        );
    if (!pszPolicyContainer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszPolicyContainerDN = pszPolicyContainer;
    
error:
    
    return(dwError);
}


DWORD
ComputeDefaultDirectory(
                        LPWSTR * ppszDefaultDirectory
                        )
{
    
    PDOMAIN_CONTROLLER_INFOW pDomainControllerInfo = NULL;
    DWORD dwError = 0;
    DWORD Flags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME;
    LPWSTR pszDefaultDirectory = NULL;
    
    
    *ppszDefaultDirectory = NULL;
    
    dwError = DsGetDcNameW(
        NULL,
        NULL,
        NULL,
        NULL,
        Flags,
        &pDomainControllerInfo
        ) ;
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    pszDefaultDirectory = AllocPolStr(
        pDomainControllerInfo->DomainName
        );
    if (!pszDefaultDirectory) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszDefaultDirectory = pszDefaultDirectory;
    
error:
    
    if (pDomainControllerInfo) {
        
        (void) NetApiBufferFree(pDomainControllerInfo) ;
    }
    
    
    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\ldaputil.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       drt.cxx
//
//  Contents:   Main for OleDs DRT
//
//
//  History:    28-Oct-94  KrishnaG, created OleDs DRT
//              28-Oct-94  ChuckC, rewritten.
//
//----------------------------------------------------------------------------


#include "precomp.h"


DWORD
LdapOpen(
         WCHAR *domainName,
         int portno,
         HLDAP * phLdapHandle
         )
{
    int ldaperr = 0;
    void *ldapOption;
    HLDAP hLdapHandle = NULL;
    DWORD dwError = 0;
    
    hLdapHandle = ldap_init(domainName, portno );
    
    if (hLdapHandle == NULL ) {
        
        dwError = ERROR_BAD_NETPATH;
        goto error;
    }
    
    //
    // Now process versioning
    //
    
    ldapOption = (void *) LDAP_VERSION3;
    
    ldaperr = ldap_set_option(
        hLdapHandle,
        LDAP_OPT_VERSION,
        &(ldapOption)
        );

    if (ldaperr) {
        
        dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);
        
        goto error;
    }

    ldaperr = ldap_set_option(
        hLdapHandle,
        LDAP_OPT_DNSDOMAIN_NAME ,
        &(domainName)
        );

    if (ldaperr) {
        
        dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);
        
        goto error;
    }
    
    ldapOption = LDAP_OPT_ON;
    
    ldaperr = ldap_set_option(
        hLdapHandle,
        LDAP_OPT_ENCRYPT ,
        &(ldapOption)
        );

    if (ldaperr) {
        
        dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);
        
        goto error;
    }

    

    ldaperr = ldap_set_option(
        hLdapHandle,
        LDAP_OPT_SIGN ,
        &(ldapOption)
        );

    if (ldaperr) {
        
        dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);
        
        goto error;
    }
    
    ldaperr = ldap_connect(hLdapHandle, NULL);
    
    if (ldaperr) {
        
        dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);
        
        goto error;
    }
    
    //
    // Disabled Callback function support and chasing external referrals
    // KrishnaG - do I need to support this.
    
    *phLdapHandle = hLdapHandle;
    
    return(dwError);
    
error:
    
    if (hLdapHandle != NULL) {
        
        ldaperr = ldap_unbind( hLdapHandle );
        
    }
    
    return (dwError);
}

DWORD
LdapBind(
         HLDAP hLdapHandle
         )
{
    int ldaperr = 0;
    
    ldaperr = ldap_bind_s(hLdapHandle, NULL, NULL, LDAP_AUTH_SSPI);
    
    return (ldaperr);
}


DWORD
LdapSearchHelper(
                 HLDAP hLdapHandle,
                 WCHAR *base,
                 int   scope,
                 WCHAR *filter,
                 WCHAR *attrs[],
                 int   attrsonly,
                 struct l_timeval *timeout,
                 LDAPMessage **res
                 )
{
    int nCount = 0;
    int j = 0;
    int ldaperr = 0;
    DWORD dwError = 0;
    
    if ( timeout == NULL )
    {
        ldaperr = ldap_search_s(
            hLdapHandle,
            base,
            scope,
            filter,
            attrs,
            attrsonly,
            res
            );
        dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);
        
    }
    else
    {
        ldaperr = ldap_search_st(
            hLdapHandle,
            base,
            scope,
            filter,
            attrs,
            attrsonly,
            timeout,
            res
            );
        dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);
        
    }
    
    //
    // Is there an error with checking the no of results
    //
    
    return (dwError);
}


DWORD
LdapSearchS(
            HLDAP hLdapHandle,
            WCHAR *base,
            int   scope,
            WCHAR *filter,
            WCHAR *attrs[],
            int   attrsonly,
            LDAPMessage **res
            )
{
    
    DWORD dwError = 0;
    
    dwError = LdapSearchHelper(
        hLdapHandle,
        base,
        scope,
        filter,
        attrs,
        attrsonly,
        NULL,
        res
        );
    //
    // Is there a check needed for connection errors
    //
    
    return(dwError);
    
}

DWORD
LdapSearchST(
             HLDAP hLdapHandle,
             WCHAR *base,
             int   scope,
             WCHAR *filter,
             WCHAR *attrs[],
             int   attrsonly,
             struct l_timeval *timeout,
             LDAPMessage **res
             )
{
    DWORD dwError = 0;
    
    dwError = LdapSearchHelper(
        hLdapHandle,
        base,
        scope,
        filter,
        attrs,
        attrsonly,
        timeout,
        res
        );
    
    return(dwError);
}




















//
// Completely new functionality - block ported from YihsinS code in ADSI
//


DWORD
LdapAbandon(
            HLDAP hLdapHandle,
            int   msgid
            )
{
    
    // No error code, 0 if success, -1 otherwise
    return ldap_abandon( hLdapHandle, msgid );
}

DWORD
LdapResult(
           HLDAP hLdapHandle,
           int    msgid,
           int    all,
           struct l_timeval *timeout,
           LDAPMessage **res,
           int    *restype
           )
{
    DWORD dwError = 0;
    int ldaperr = 0;
    
    
    *restype = ldap_result( hLdapHandle, msgid, all, timeout, res );
    
    if ( *restype == -1 )  // error
        ldaperr = LdapGetLastError();
    
    if (ldaperr) {
        
        if (!ldap_count_entries( hLdapHandle, *res )) {
            
            dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
        }
    }else {
        
        dwError = 0;
    }
    
    return(dwError);
    
}

void
LdapMsgFree(
            LDAPMessage *res
            )
{
    ldap_msgfree( res );  // Returns the type of message freed which
    // is not interesting
}

int
LdapResult2Error(
                 HLDAP hLdapHandle,
                 LDAPMessage *res,
                 int freeit
                 )
{
    
    return ldap_result2error( hLdapHandle, res, freeit );
}

DWORD
LdapFirstEntry(
               HLDAP hLdapHandle,
               LDAPMessage *res,
               LDAPMessage **pfirst
               )
{
    DWORD dwError = 0;
    int ldaperr = 0;
    
    
    *pfirst = ldap_first_entry( hLdapHandle, res );
    
    if ( *pfirst == NULL )
    {
        ldaperr = LdapGetLastError();
        
        dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
    }
    
    return(dwError);
}

DWORD
LdapNextEntry(
              HLDAP hLdapHandle,
              LDAPMessage *entry,
              LDAPMessage **pnext
              )
{
    DWORD dwError = 0;
    int ldaperr = 0;
    
    
    *pnext = ldap_next_entry( hLdapHandle, entry );
    
    if ( *pnext == NULL )
    {
        ldaperr = LdapGetLastError();
        
        dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
    }
    
    return(dwError);
}

int
LdapCountEntries(
                 HLDAP hLdapHandle,
                 LDAPMessage *res
                 )
{
    
    return ldap_count_entries( hLdapHandle, res );
}

DWORD
LdapFirstAttribute(
                   HLDAP hLdapHandle,
                   LDAPMessage *entry,
                   void  **ptr,
                   WCHAR **pattr
                   )
{
    
    // NOTE: The return value from ldap_first_attribute is static and
    //       should not be freed
    
    *pattr = ldap_first_attribute( hLdapHandle, entry,
        (struct berelement **) ptr );  // static data
    
    if ( *pattr == NULL )
    {
        DWORD dwError = 0;
        int ldaperr = 0;
        
        // Error occurred or end of attributes
        
        ldaperr = LdapGetLastError();
        
        CheckAndSetExtendedError( hLdapHandle, ldaperr);
        
        return(dwError);
    }
    
    return NO_ERROR;
    
}

DWORD
LdapNextAttribute(
                  HLDAP hLdapHandle,
                  LDAPMessage *entry,
                  void  *ptr,
                  WCHAR **pattr
                  )
{
    
    // NOTE: The return value from ldap_next_attribute is static and
    //       should not be freed
    *pattr = ldap_next_attribute( hLdapHandle, entry,
        (struct berelement *) ptr );  // static data
    
#if 0   // Ignore the error code here since at the end of the enumeration,
    // we will probably get an error code here ( both Andy and umich's
    // dll will return errors sometimes. No error returned from NTDS,
    // but errors are returned from Exchange server  )
    
    if ( *pattr == NULL )
    {
        DWORD hr = NO_ERROR;
        int ldaperr = 0;
        
        // Error occurred or end of attributes
        ldaperr = LdapGetLastError();
        dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
        return(dwError);
    }
#endif
    
    return S_OK;
}


//
// NOTE: LdapGetValues return S_OK if attribute [attr] has no values
//       (*[pvalues] =NULL, *[pcount]=0) but all else ok.
//

DWORD
LdapGetValues(
              HLDAP hLdapHandle,
              LDAPMessage *entry,
              WCHAR *attr,
              WCHAR ***pvalues,
              int   *pcount
              )
{
    DWORD dwError = 0;
    int ldaperr = 0;
    
    
    *pvalues = ldap_get_values( hLdapHandle, entry, attr );
    
    if ( *pvalues == NULL ) {
        
        *pcount=0;
        
        //
        // ldap_get_values succeeds if attribute has no values
        // but all else ok.  (confiremed with anoopa)
        //
        
        ldaperr = LdapGetLastError();
        
        if (ldaperr) {
            
            dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
        }
        
        //
        // KrishnaG if  *pvalues is NULL which means I don't get back a
        // value - return an ERROR
        //
        
        return(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
    }
    
    *pcount = ldap_count_values( *pvalues );
    
    return S_OK;
}


//
// NOTE: LdapGetValuesLen return S_OK if attribute [attr] has no values
//       (*[pvalues] =NULL, *[pcount]=0) but all else ok.
//

DWORD
LdapGetValuesLen(
                 HLDAP hLdapHandle,
                 LDAPMessage *entry,
                 WCHAR *attr,
                 struct berval ***pvalues,
                 int   *pcount
                 )
{
    //
    // NOTE: this can contain binary data as well as strings,
    //       strings are ascii, no conversion is done here
    //
    
    char *pszAttrA = NULL;
    DWORD dwError = 0;
    int ldaperr = 0;
    
    
    *pvalues = ldap_get_values_len( hLdapHandle, entry, attr );
    
    if ( *pvalues == NULL ){
        
        *pcount=0;
        
        //
        // ldap_get_values succeeds if attribute has no values
        // but all else ok.  (confiremed with anoopa)
        //
        
        ldaperr = LdapGetLastError();
        
        if (ldaperr) {
            
            dwError = CheckAndSetExtendedError( hLdapHandle,ldaperr);
        }
        
        return(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
    }
    
    *pcount = ldap_count_values_len( *pvalues );
    
    return S_OK;
}


void
LdapValueFree(
              WCHAR **vals
              )
{
    ldap_value_free( vals );
}

void
LdapValueFreeLen(
                 struct berval **vals
                 )
{
    ldap_value_free_len( vals );
}

void
LdapMemFree(
            WCHAR *pszString
            )
{
    ldap_memfree( pszString );
}

void
LdapAttributeFree(
                  WCHAR *pszString
                  )
{
    // String from ldap_first/next_attribute should not be freed,
    // so do nothing here
}

DWORD
LdapGetDn(
          HLDAP hLdapHandle,
          LDAPMessage *entry,
          WCHAR **pdn
          )
{
    int ldaperr = 0;
    DWORD dwError = 0;
    
    *pdn = ldap_get_dn( hLdapHandle, entry );
    if ( *pdn == NULL )
    {
        // Error occurred
        ldaperr = LdapGetLastError();
        
        dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
        return(dwError);
    }
    
    return(dwError);
}



DWORD
CheckAndSetExtendedError(
                         HLDAP hLdapHandle,
                         int     ldaperr
                         )
{
    
    DWORD dwErr = NO_ERROR;
    
    switch (ldaperr) {
        
    case LDAP_SUCCESS :
        dwErr = NO_ERROR;
        break;
        
    case LDAP_OPERATIONS_ERROR :
        dwErr =  ERROR_DS_OPERATIONS_ERROR;
        break;
        
    case LDAP_PROTOCOL_ERROR :
        dwErr =  ERROR_DS_PROTOCOL_ERROR;
        break;
        
    case LDAP_TIMELIMIT_EXCEEDED :
        dwErr = ERROR_DS_TIMELIMIT_EXCEEDED;
        break;
        
    case LDAP_SIZELIMIT_EXCEEDED :
        dwErr = ERROR_DS_SIZELIMIT_EXCEEDED;
        break;
        
    case LDAP_COMPARE_FALSE :
        dwErr = ERROR_DS_COMPARE_FALSE;
        break;
        
    case LDAP_COMPARE_TRUE :
        dwErr = ERROR_DS_COMPARE_TRUE;
        break;
        
    case LDAP_AUTH_METHOD_NOT_SUPPORTED :
        dwErr = ERROR_DS_AUTH_METHOD_NOT_SUPPORTED;
        break;
        
    case LDAP_STRONG_AUTH_REQUIRED :
        dwErr =  ERROR_DS_STRONG_AUTH_REQUIRED;
        break;
        
    case LDAP_PARTIAL_RESULTS :
        
        //
        // Make sure we handle
        // partial results.
        //
        dwErr = ERROR_MORE_DATA;
        break;
        
        
    case LDAP_REFERRAL :
        dwErr =  ERROR_DS_REFERRAL;
        break;
        
    case LDAP_ADMIN_LIMIT_EXCEEDED :
        dwErr   = ERROR_DS_ADMIN_LIMIT_EXCEEDED;
        break;
        
    case LDAP_UNAVAILABLE_CRIT_EXTENSION :
        dwErr = ERROR_DS_UNAVAILABLE_CRIT_EXTENSION;
        break;
        
    case LDAP_CONFIDENTIALITY_REQUIRED :
        dwErr = ERROR_DS_CONFIDENTIALITY_REQUIRED;
        break;
        
    case LDAP_NO_SUCH_ATTRIBUTE :
        dwErr = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        break;
        
    case LDAP_UNDEFINED_TYPE :
        dwErr = ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED;
        break;
        
    case LDAP_INAPPROPRIATE_MATCHING :
        dwErr = ERROR_DS_INAPPROPRIATE_MATCHING;
        break;
        
    case LDAP_CONSTRAINT_VIOLATION :
        dwErr = ERROR_DS_CONSTRAINT_VIOLATION;
        break;
        
    case LDAP_ATTRIBUTE_OR_VALUE_EXISTS :
        dwErr = ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS;
        break;
        
    case LDAP_INVALID_SYNTAX :
        dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
        break;
        
    case LDAP_NO_SUCH_OBJECT :
        dwErr = ERROR_DS_NO_SUCH_OBJECT;
        break;
        
    case LDAP_ALIAS_PROBLEM :
        dwErr = ERROR_DS_ALIAS_PROBLEM;
        break;
        
    case LDAP_INVALID_DN_SYNTAX :
        dwErr = ERROR_DS_INVALID_DN_SYNTAX;
        break;
        
    case LDAP_IS_LEAF :
        dwErr = ERROR_DS_IS_LEAF;
        break;
        
    case LDAP_ALIAS_DEREF_PROBLEM :
        dwErr = ERROR_DS_ALIAS_DEREF_PROBLEM;
        break;
        
    case LDAP_INAPPROPRIATE_AUTH :
        dwErr = ERROR_DS_INAPPROPRIATE_AUTH;
        break;
        
    case LDAP_INVALID_CREDENTIALS :
        dwErr = ERROR_LOGON_FAILURE;
        break;
        
    case LDAP_INSUFFICIENT_RIGHTS :
        dwErr = ERROR_ACCESS_DENIED;
        break;
        
    case LDAP_BUSY :
        dwErr = ERROR_DS_BUSY;
        break;
        
    case LDAP_UNAVAILABLE :
        dwErr = ERROR_DS_UNAVAILABLE;
        break;
        
    case LDAP_UNWILLING_TO_PERFORM :
        dwErr = ERROR_DS_UNWILLING_TO_PERFORM;
        break;
        
    case LDAP_LOOP_DETECT :
        dwErr = ERROR_DS_LOOP_DETECT;
        break;
        
    case LDAP_NAMING_VIOLATION :
        dwErr = ERROR_DS_NAMING_VIOLATION;
        break;
        
    case LDAP_OBJECT_CLASS_VIOLATION :
        dwErr = ERROR_DS_OBJ_CLASS_VIOLATION;
        break;
        
    case LDAP_NOT_ALLOWED_ON_NONLEAF :
        dwErr = ERROR_DS_CANT_ON_NON_LEAF;
        break;
        
    case LDAP_NOT_ALLOWED_ON_RDN :
        dwErr = ERROR_DS_CANT_ON_RDN;
        break;
        
    case LDAP_ALREADY_EXISTS :
        dwErr = ERROR_OBJECT_ALREADY_EXISTS;
        break;
        
    case LDAP_NO_OBJECT_CLASS_MODS :
        dwErr = ERROR_DS_CANT_MOD_OBJ_CLASS;
        break;
        
    case LDAP_RESULTS_TOO_LARGE :
        dwErr = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        break;
        
    case LDAP_AFFECTS_MULTIPLE_DSAS :
        dwErr = ERROR_DS_AFFECTS_MULTIPLE_DSAS;
        break;
        
    case LDAP_OTHER :
        dwErr = ERROR_GEN_FAILURE;
        break;
        
    case LDAP_SERVER_DOWN :
        dwErr = ERROR_DS_SERVER_DOWN;
        break;
        
    case LDAP_LOCAL_ERROR :
        dwErr = ERROR_DS_LOCAL_ERROR;
        break;
        
    case LDAP_ENCODING_ERROR :
        dwErr = ERROR_DS_ENCODING_ERROR;
        break;
        
    case LDAP_DECODING_ERROR :
        dwErr = ERROR_DS_DECODING_ERROR;
        break;
        
    case LDAP_TIMEOUT :
        dwErr = ERROR_TIMEOUT;
        break;
        
    case LDAP_AUTH_UNKNOWN :
        dwErr = ERROR_DS_AUTH_UNKNOWN;
        break;
        
    case LDAP_FILTER_ERROR :
        dwErr = ERROR_DS_FILTER_UNKNOWN;
        break;
        
    case LDAP_USER_CANCELLED :
        dwErr = ERROR_CANCELLED;
        break;
        
    case LDAP_PARAM_ERROR :
        dwErr = ERROR_DS_PARAM_ERROR;
        break;
        
    case LDAP_NO_MEMORY :
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        break;
        
    case LDAP_CONNECT_ERROR :
        dwErr = ERROR_CONNECTION_REFUSED;
        break;
        
    case LDAP_NOT_SUPPORTED :
        dwErr = ERROR_DS_NOT_SUPPORTED;
        break;
        
    case LDAP_NO_RESULTS_RETURNED :
        dwErr = ERROR_DS_NO_RESULTS_RETURNED;
        break;
        
    case LDAP_CONTROL_NOT_FOUND :
        dwErr = ERROR_DS_CONTROL_NOT_FOUND;
        break;
        
    case LDAP_MORE_RESULTS_TO_RETURN :
        dwErr = ERROR_MORE_DATA;
        break;
        
    case LDAP_CLIENT_LOOP :
        dwErr = ERROR_DS_CLIENT_LOOP;
        break;
        
    case LDAP_REFERRAL_LIMIT_EXCEEDED :
        dwErr = ERROR_DS_REFERRAL_LIMIT_EXCEEDED;
        break;
        
    default:
        dwErr = ERROR_DS_BUSY;
        
    }
    
    return(dwErr);
}




DWORD
LdapAddS(
         HLDAP hLdapHandle,
         WCHAR *dn,
         LDAPModW *attrs[]
         )
{
    DWORD dwError = 0;
    int ldaperr = 0;
    
    
    ldaperr = ldap_add_s( hLdapHandle, dn, attrs );
    
    dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);
    
    return(dwError);
}


DWORD
LdapModifyS(
            HLDAP hLdapHandle,
            WCHAR *dn,
            LDAPModW *mods[]
            )
{
    DWORD dwError = 0;
    int ldaperr = 0;
    
    ldaperr = ldap_modify_s( hLdapHandle, dn, mods);
    
    dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);
    
    return(dwError);
}


DWORD
LdapDeleteS(
            HLDAP hLdapHandle,
            WCHAR *dn
            )
{
    DWORD dwError = 0;
    int ldaperr = 0;
    
    ldaperr = ldap_delete_s( hLdapHandle, dn );
    
    dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);
    
    return(dwError);
}

DWORD
LdapRename(
    HLDAP hLdapHandle,
    WCHAR *oldDn,
    WCHAR *newDn
    )
{

    DWORD dwError = 0;

    dwError = ldap_modrdn_s (hLdapHandle, oldDn, newDn);
   // dwError = ldap_rename_ext_s(hLdapHandle, dn, newName, parentNode, TRUE, NULL, NULL);
    return(dwError);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif
    
    
    LPVOID
        ReallocPolMem(
        LPVOID pOldMem,
        DWORD cbOld,
        DWORD cbNew
        );
    
    DWORD
        AllocatePolString(
        LPWSTR pszString,
        LPWSTR * ppszNewString
        );
    
    void
        FreePolString(
        LPWSTR pszString
        );
    
    
#if DBG
    
    extern LIST_ENTRY ADsMemList ;
    
    extern CRITICAL_SECTION ADsMemCritSect ;
    
    VOID InitPolMem(
        VOID
        ) ;
    
    VOID AssertPolMemLeaks(
        VOID
        ) ;
    
    
    VOID
        DumpMemoryTracker();
    
    
#else
    
#define InitPolMem()
#define AssertPolMemLeaks()
    
#define DumpMemoryTracker()
    
    
    
#endif
    
    
#ifdef __cplusplus
}
#endif

/*
inline void * _CRTAPI1
operator new(size_t size)
{
return AllocPolMem(size);
}

  inline void  _CRTAPI1
  operator delete(void * pv)
  {
  FreePolMem(pv);
}*/


#endif // _MEMORY_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\memory.c ===
/*++

  
    Copyright (c) 1990  Microsoft Corporation
    
    Module Name:
      
    memory.c
        
    Abstract:
          
    This module provides all the memory management functions for all spooler
            components
            
    Author:
              
    Krishna Ganugapati (KrishnaG) 03-Feb-1994
                
    Revision History:
                  
--*/

#include "precomp.h"

#define ADsAssert(x)    NULL

#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((DWORD)addr &= ~1))

#define DWORD_ALIGN_UP(size) ((size+3)&~3)


#if DBG


DWORD dwMemLog = 0;

#define MAXDEPTH 10

typedef struct _ADSMEMTAG {
    DWORD Tag ;
    DWORD Size ;
    PVOID pvBackTrace[MAXDEPTH+1];
    LPSTR pszSymbol[MAXDEPTH+1];
    DWORD uDepth;
    LIST_ENTRY List ;
} ADSMEMTAG, *PADSMEMTAG ;

LIST_ENTRY       ADsMemList ;
DWORD            ADsMemCount ;
CRITICAL_SECTION ADsMemCritSect ;

/*++

  Routine Description:
  
    This function initializes the ADs mem tracking code. Must be call
    during DLL load an ONLY during DLL load.
    
      Arguments:
      
        None
        
          Return Value:
          
            None.
            
--*/
VOID InitPolMem(
                VOID
                )
{
    InitializeCriticalSection(&ADsMemCritSect) ;
    InitializeListHead(&ADsMemList) ;
    ADsMemCount = 0 ;
}

/*++

  Routine Description:
  
    This function asserts that the mem list is empty on exit.
    
      Arguments:
      
        None
        
          Return Value:
          
            None.
            
--*/
VOID AssertPolMemLeaks(
                       VOID
                       )
{
    ADsAssert(IsListEmpty(&ADsMemList)) ;
}

#endif

LPVOID
AllocPolMem(
            DWORD cb
            )
            /*++
            
              Routine Description:
              
                This function will allocate local memory. It will possibly allocate extra
                memory and fill this with debugging information for the debugging version.
                
                  Arguments:
                  
                    cb - The amount of memory to allocate
                    
                      Return Value:
                      
                        NON-NULL - A pointer to the allocated memory
                        
                          FALSE/NULL - The operation failed. Extended error status is available
                          using GetLastError.
                          
                            --*/
{
    return(LocalAlloc(LPTR, cb));
    
}

BOOL
FreePolMem(
           LPVOID pMem
           )
{
    return(LocalFree(pMem) == NULL);
}

LPVOID
ReallocPolMem(
              LPVOID pOldMem,
              DWORD cbOld,
              DWORD cbNew
              )
{
    LPVOID pNewMem;
    
    pNewMem=AllocPolMem(cbNew);
    
    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        FreePolMem(pOldMem);
    }
    
    return pNewMem;
}

LPWSTR
AllocPolStr(
            LPCWSTR pStr
            )
            /*++
            
              Routine Description:
              
                This function will allocate enough local memory to store the specified
                string, and copy that string to the allocated memory
                
                  Arguments:
                  
                    pStr - Pointer to the string that needs to be allocated and stored
                    
                      Return Value:
                      
                        NON-NULL - A pointer to the allocated memory containing the string
                        
                          FALSE/NULL - The operation failed. Extended error status is available
                          using GetLastError.
                          
                            --*/
{
    LPWSTR pMem;
    
    if (!pStr)
        return 0;
    
    if (pMem = (LPWSTR)AllocPolMem( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) ))
        wcscpy(pMem, pStr);
    
    return pMem;
}

BOOL
FreePolStr(
           LPWSTR pStr
           )
{
    return pStr ? FreePolMem(pStr)
        : FALSE;
}

BOOL
ReallocPolStr(
              LPWSTR *ppStr,
              LPWSTR pStr
              )
{
    FreePolStr(*ppStr);
    *ppStr=AllocPolStr(pStr);
    
    return TRUE;
}

DWORD
AllocatePolString(
                  LPWSTR pszString,
                  LPWSTR * ppszNewString
                  )
{
    LPWSTR pszNewString = NULL;
    DWORD dwError = 0;
    
    pszNewString = AllocPolStr(pszString);
    
    if (!pszNewString) {
        dwError = GetLastError();
    }
    
    *ppszNewString = pszNewString;
    
    return(dwError);
}

void
FreePolString(
              LPWSTR pszString
              )
{
    if (pszString) {
        FreePolStr(pszString);
    }
    
    return;
}


DWORD
ReallocatePolMem(
                 LPVOID * ppOldMem,
                 DWORD cbOld,
                 DWORD cbNew
                 )
{
    DWORD dwError = 0;
    LPVOID pOldMem = NULL;
    LPVOID pNewMem = NULL;
    
    pOldMem = *ppOldMem;
    pNewMem = AllocPolMem(cbNew);
    
    if (!pNewMem) {
        dwError = ERROR_OUTOFMEMORY;
        return (dwError);
    }
    
    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        FreePolMem(pOldMem);
    }

    *ppOldMem = pNewMem;
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\freeobj.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Freeobj.c
//
//  Contents:  Policy management for directory
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "precomp.h"


void
FreeWirelessPolicyObject(
                      PWIRELESS_POLICY_OBJECT pWirelessPolicyObject
                      )
{
    if (pWirelessPolicyObject->pszDescription) {
        FreePolStr(pWirelessPolicyObject->pszDescription);
    }
    
    if (pWirelessPolicyObject->pszWirelessOwnersReference) {
        FreePolStr(pWirelessPolicyObject->pszWirelessOwnersReference);
    }
    
    if (pWirelessPolicyObject->pszWirelessName) {
        FreePolStr(pWirelessPolicyObject->pszWirelessName);
    }
    
    if (pWirelessPolicyObject->pszWirelessID) {
        FreePolStr(pWirelessPolicyObject->pszWirelessID);
    }
    
    if (pWirelessPolicyObject->pWirelessData) {
        FreePolMem(pWirelessPolicyObject->pWirelessData);
    }
    
    FreePolMem(pWirelessPolicyObject);
    
    return;
}




void
FreeWirelessPolicyObjects(
                       PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObjects,
                       DWORD dwNumPolicyObjects
                       )
{
    DWORD i = 0;
    
    for (i = 0; i < dwNumPolicyObjects; i++) {
        
        if (*(ppWirelessPolicyObjects + i)) {
            
            FreeWirelessPolicyObject(*(ppWirelessPolicyObjects + i));
            
        }
        
    }
    
    FreePolMem(ppWirelessPolicyObjects);
    
    return;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\persist-w.h ===
HRESULT
PersistWMIObject(
                 IWbemServices *pWbemServices,
                 PWIRELESS_POLICY_OBJECT pWirelessRegPolicyObject,
                 PGPO_INFO pGPOInfo
                 );


HRESULT
PersistPolicyObjectEx(
                      IWbemServices *pWbemServices,
                      IWbemClassObject *pWbemClassObj,
                      PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                      PGPO_INFO pGPOInfo
                      );


HRESULT
PersistComnRSOPPolicySettings(
                              IWbemClassObject * pInstWIRELESSObj,
                              PGPO_INFO pGPOInfo
                              );

HRESULT
CloneDirectoryPolicyObjectEx(
                             PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                             PWIRELESS_POLICY_OBJECT * ppWirelessWMIPolicyObject
                             );


DWORD
CopyPolicyDSToFQWMIString(
                          LPWSTR pszPolicyDN,
                          LPWSTR * ppszPolicyName
                          );


HRESULT
WMIWriteMultiValuedString(
                          IWbemClassObject *pInstWbemClassObject,
                          LPWSTR pszValueName,
                          LPWSTR * ppszStringReferences,
                          DWORD dwNumStringReferences
                          );


DWORD
CopyPolicyDSToWMIString(
                        LPWSTR pszPolicyDN,
                        LPWSTR * ppszPolicyName
                        );

HRESULT
LogBlobPropertyEx(
                  IWbemClassObject *pInstance,
                  BSTR bstrPropName,
                  BYTE *pbBlob,
                  DWORD dwLen
                  );

HRESULT
DeleteWMIClassObject(
                     IWbemServices *pWbemServices,
                     LPWSTR pszWirelessWMIObject
                     );

LPWSTR
AllocPolBstrStr(
                LPCWSTR pStr
                );

HRESULT
PolSysAllocString(
                  BSTR * pbsStr,
                  const OLECHAR * sz
                  );

#define SKIPL(pstr) (pstr+2)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\persist.h ===
DWORD
CacheDirectorytoRegistry(
                         PWIRELESS_POLICY_OBJECT pWirelessPolicyObject
                         );

DWORD
PersistRegistryObject(
                      PWIRELESS_POLICY_OBJECT pWirelessRegPolicyObject
                      );


DWORD
PersistPolicyObject(
                    HKEY hRegistryKey,
                    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject
                    );




DWORD
CloneDirectoryPolicyObject(
                           PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                           PWIRELESS_POLICY_OBJECT * ppWirelessRegPolicyObject
                           );


DWORD
DeleteRegistryCache();

DWORD
CopyBinaryValue(
                LPBYTE pMem,
                DWORD dwMemSize,
                LPBYTE * ppNewMem
                );


DWORD
CopyPolicyDSToRegString(
                        LPWSTR pszPolicyDN,
                        LPWSTR * ppszPolicyName
                        );



DWORD
ComputeGUIDName(
                LPWSTR szCommonName,
                LPWSTR * ppszGuidName
                );



DWORD
CopyPolicyDSToFQRegString(
                          LPWSTR pszPolicyDN,
                          LPWSTR * ppszPolicyName
                          );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <wchar.h>
#include <dsgetdc.h>
#include <lm.h>

#define UNICODE
#define COBJMACROS

#include <winldap.h>

#include <wbemidl.h>
#include <oleauto.h>

#include "ldaputil.h"

#include "memory.h"
#include <wlstore2.h>
#include "structs.h"
#include "dsstore.h"
#include "regstore.h"
#include "wmistore.h"
#include "persist.h"
#include "persist-w.h"
#include "procrule.h"
#include "utils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\persist-w.c ===
#include "precomp.h"

LPWSTR gpszWirelessWMIObject = L"RSOP_IEEE80211PolicySetting";

HRESULT
PolSysAllocString( 
                  BSTR * pbsStr,
                  const OLECHAR * sz  
                  )
{
    *pbsStr = SysAllocString(sz);
    if (!pbsStr) {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT
PersistWMIObject(
                 IWbemServices *pWbemServices,
                 PWIRELESS_POLICY_OBJECT pWirelessWMIPolicyObject,
                 PGPO_INFO pGPOInfo
                 )
{
    HRESULT hr;
    IWbemClassObject *pWbemWIRELESSObj = NULL;
    BSTR bstrWirelessWMIObject = NULL;
    
    // If this first GPO we are writing after a policy
    // update, clear the WMI store.
    if (pGPOInfo->uiPrecedence == pGPOInfo->uiTotalGPOs) {
        hr = DeleteWMIClassObject(
            pWbemServices,
            gpszWirelessWMIObject
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    bstrWirelessWMIObject = SysAllocString(gpszWirelessWMIObject);
    if(!bstrWirelessWMIObject) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    hr = IWbemServices_GetObject(pWbemServices,
        bstrWirelessWMIObject,
        WBEM_FLAG_RETURN_WBEM_COMPLETE,
        0,
        &pWbemWIRELESSObj,
        0);
    SysFreeString(bstrWirelessWMIObject);
    BAIL_ON_HRESULT_ERROR(hr);
    
    
    hr = PersistPolicyObjectEx(
        pWbemServices,
        pWbemWIRELESSObj,
        pWirelessWMIPolicyObject,
        pGPOInfo
        );
    
error:
    
    //close WMI?
    if(pWbemWIRELESSObj)
        IWbemClassObject_Release(pWbemWIRELESSObj);
    
    return (hr);
    
}




HRESULT
PersistPolicyObjectEx(
                      IWbemServices *pWbemServices,
                      IWbemClassObject *pWbemClassObj,
                      PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                      PGPO_INFO pGPOInfo
                      )
{
    HRESULT hr = 0;
    IWbemClassObject *pInstWIRELESSObj = NULL;
    VARIANT var;
    
    VariantInit(&var);
    
    //start
    hr = IWbemClassObject_SpawnInstance(
        pWbemClassObj,
        0,
        &pInstWIRELESSObj
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    var.vt = VT_BSTR;
    var.bstrVal = SKIPL(pWirelessPolicyObject->pszWirelessOwnersReference);
    hr = IWbemClassObject_Put(
        pInstWIRELESSObj,
        L"id",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    hr = PersistComnRSOPPolicySettings(
        pInstWIRELESSObj, 
        pGPOInfo
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    var.vt = VT_BSTR;
    hr = PolSysAllocString(&var.bstrVal, L"msieee80211-Policy");
    BAIL_ON_HRESULT_ERROR(hr);
    hr = IWbemClassObject_Put(
        pInstWIRELESSObj,
        L"ClassName",
        0,
        &var,
        0
        );
    VariantClear(&var);
    BAIL_ON_HRESULT_ERROR(hr);
    
    if (pWirelessPolicyObject->pszDescription) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pWirelessPolicyObject->pszDescription);
        hr = IWbemClassObject_Put(
            pInstWIRELESSObj,
            L"description",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    } else {
        //delete description?
        var.vt = VT_BSTR;
        hr = PolSysAllocString(&var.bstrVal, L"");
        BAIL_ON_HRESULT_ERROR(hr);
        hr = IWbemClassObject_Put(
            pInstWIRELESSObj,
            L"description",
            0,
            &var,
            0
            );
        VariantClear(&var);            
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    if (pWirelessPolicyObject->pszWirelessOwnersReference) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pWirelessPolicyObject->pszWirelessOwnersReference);
        hr = IWbemClassObject_Put(
            pInstWIRELESSObj,
            L"name",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    if (pWirelessPolicyObject->pszWirelessName) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pWirelessPolicyObject->pszWirelessName);
        hr = IWbemClassObject_Put(
            pInstWIRELESSObj,
            L"msieee80211Name",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    if (pWirelessPolicyObject->pszWirelessID) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pWirelessPolicyObject->pszWirelessID);
        hr = IWbemClassObject_Put(
            pInstWIRELESSObj,
            L"msieee80211ID",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    var.vt = VT_I4;
    var.lVal = pWirelessPolicyObject->dwWirelessDataType;
    hr = IWbemClassObject_Put(
        pInstWIRELESSObj,
        L"msieee80211DataType",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    if (pWirelessPolicyObject->pWirelessData) {
        hr = LogBlobPropertyEx(
            pInstWIRELESSObj,
            L"msieee80211Data",
            pWirelessPolicyObject->pWirelessData,
            pWirelessPolicyObject->dwWirelessDataLen
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    var.vt = VT_I4;
    var.lVal = pWirelessPolicyObject->dwWhenChanged;
    hr = IWbemClassObject_Put(
        pInstWIRELESSObj,
        L"whenChanged",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    hr = IWbemServices_PutInstance(
        pWbemServices,
        pInstWIRELESSObj,
        WBEM_FLAG_CREATE_OR_UPDATE,
        0,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
error:
    if (pInstWIRELESSObj) {
        IWbemClassObject_Release(pInstWIRELESSObj);
    }
    
    return(hr);
}


HRESULT
PersistComnRSOPPolicySettings(
                              IWbemClassObject * pInstWIRELESSObj,
                              PGPO_INFO pGPOInfo
                              )
{
    HRESULT hr = S_OK;
    VARIANT var;
    
    VariantInit(&var);
    
    var.vt = VT_BSTR;
    var.bstrVal = pGPOInfo->bsCreationtime;
    hr = IWbemClassObject_Put(
        pInstWIRELESSObj,
        L"creationTime",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    
    var.vt = VT_BSTR;
    var.bstrVal = pGPOInfo->bsGPOID;
    hr = IWbemClassObject_Put(
        pInstWIRELESSObj,
        L"GPOID",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    var.vt = VT_I4;
    var.lVal = pGPOInfo->uiPrecedence;
    hr = IWbemClassObject_Put(
        pInstWIRELESSObj,
        L"precedence",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    var.vt = VT_BSTR;
    var.bstrVal = pGPOInfo->bsSOMID;
    hr = IWbemClassObject_Put(
        pInstWIRELESSObj,
        L"SOMID",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
error:
    var.vt = VT_EMPTY;
    return hr;
}

HRESULT
CloneDirectoryPolicyObjectEx(
                             PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                             PWIRELESS_POLICY_OBJECT * ppWirelessWMIPolicyObject
                             )
{
    DWORD dwError = 0;
    PWIRELESS_POLICY_OBJECT pWirelessWMIPolicyObject = NULL;
    LPWSTR pszUniquePolicyName = NULL;
    WCHAR szUniquePolicyName[MAX_PATH];
    
    //malloc policy object
    pWirelessWMIPolicyObject = (PWIRELESS_POLICY_OBJECT)AllocPolMem(
        sizeof(WIRELESS_POLICY_OBJECT)
        );
    if (!pWirelessWMIPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    
    //
    // Now copy the rest of the data in the object
    //
    
    //copy owners ref
    if (pWirelessPolicyObject->pszWirelessID) {
    	/*
        dwError = CopyPolicyDSToWMIString(
            pWirelessPolicyObject->pszWirelessOwnersReference,
            &pWirelessWMIPolicyObject->pszWirelessOwnersReference
            );
            */
       wcscpy(szUniquePolicyName, L"\0");
       wcscpy(szUniquePolicyName, L"msieee80211-Policy");
    	wcscat(szUniquePolicyName, pWirelessPolicyObject->pszWirelessID);
       pszUniquePolicyName = AllocPolBstrStr(szUniquePolicyName);
       if (!pszUniquePolicyName) {
           dwError = ERROR_OUTOFMEMORY;
           BAIL_ON_WIN32_ERROR(dwError);
       }
       pWirelessWMIPolicyObject->pszWirelessOwnersReference = pszUniquePolicyName;
    }
    
    //copy name
    if (pWirelessPolicyObject->pszWirelessName) {
        pWirelessWMIPolicyObject->pszWirelessName = AllocPolBstrStr(
            pWirelessPolicyObject->pszWirelessName
            );
        if (!pWirelessWMIPolicyObject->pszWirelessName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    //copy wirelessid
    if (pWirelessPolicyObject->pszWirelessID) {
        pWirelessWMIPolicyObject->pszWirelessID = AllocPolBstrStr(
            pWirelessPolicyObject->pszWirelessID
            );
        if (!pWirelessWMIPolicyObject->pszWirelessID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    
    //copy datatype
    pWirelessWMIPolicyObject->dwWirelessDataType = pWirelessPolicyObject->dwWirelessDataType;
    
    //copy wirelessdata
    if (pWirelessPolicyObject->pWirelessData) {
        dwError = CopyBinaryValue(
            pWirelessPolicyObject->pWirelessData,
            pWirelessPolicyObject->dwWirelessDataLen,
            &pWirelessWMIPolicyObject->pWirelessData
            );
        BAIL_ON_WIN32_ERROR(dwError);
        pWirelessWMIPolicyObject->dwWirelessDataLen = pWirelessPolicyObject->dwWirelessDataLen;
    }
    
    
    //copy description
    if (pWirelessPolicyObject->pszDescription) {
        pWirelessWMIPolicyObject->pszDescription = AllocPolBstrStr(
            pWirelessPolicyObject->pszDescription
            );
        if (!pWirelessWMIPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    //copy whenchanged
    pWirelessWMIPolicyObject->dwWhenChanged = pWirelessPolicyObject->dwWhenChanged;
    
    //commit & return
    *ppWirelessWMIPolicyObject = pWirelessWMIPolicyObject;
    
    return(dwError);
    
error:
    
    if (pWirelessWMIPolicyObject) {
        FreeWirelessPolicyObject(
            pWirelessWMIPolicyObject
            );
    }
    
    *ppWirelessWMIPolicyObject = NULL;
    
    return(HRESULT_FROM_WIN32(dwError));
    
}
                             
                             
                             

DWORD
CopyPolicyDSToFQWMIString(
                          LPWSTR pszPolicyDN,
                          LPWSTR * ppszPolicyName
                          )
{
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszPolicyName = NULL;
    DWORD dwStringSize = 0;
    
    dwError = ComputePrelimCN(
        pszPolicyDN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwStringSize = wcslen(pszGuidName);
    dwStringSize += 1;
    
    pszPolicyName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszPolicyName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    wcscpy(pszPolicyName, pszGuidName);
    
    *ppszPolicyName = pszPolicyName;
    
    return(dwError);
    
error:
    
    *ppszPolicyName = NULL;
    
    return(dwError);
    
}



HRESULT
WMIWriteMultiValuedString(
                          IWbemClassObject *pInstWbemClassObject,
                          LPWSTR pszValueName,
                          LPWSTR * ppszStringReferences,
                          DWORD dwNumStringReferences
                          )
{
    HRESULT hr = S_OK;
    SAFEARRAYBOUND arrayBound[1];
    SAFEARRAY *pSafeArray = NULL;
    VARIANT var;
    DWORD i = 0;
    BSTR Bstr = NULL;
    
    VariantInit(&var);
    
    if (!ppszStringReferences) {
        hr = E_INVALIDARG;
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    arrayBound[0].lLbound = 0;
    arrayBound[0].cElements = dwNumStringReferences;
    
    pSafeArray = SafeArrayCreate(VT_BSTR, 1, arrayBound);
    if (!pSafeArray)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    for (i = 0; i < dwNumStringReferences; i++)
    {
        Bstr = SysAllocString(*(ppszStringReferences + i));
        if(!Bstr) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_HRESULT_ERROR(hr);
        }
        
        hr = SafeArrayPutElement(pSafeArray, (long *)&i, Bstr);
        SysFreeString(Bstr);
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    var.vt = VT_ARRAY|VT_BSTR;
    var.parray = pSafeArray;
    hr = IWbemClassObject_Put(
        pInstWbemClassObject,
        pszValueName,
        0,
        &var,
        0
        );
    VariantClear(&var);
    BAIL_ON_HRESULT_ERROR(hr);
    
    
error:
    
    return(hr);
    
}


DWORD
CopyFilterDSToWMIString(
                        LPWSTR pszFilterDN,
                        LPWSTR * ppszFilterName
                        )
{
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszFilterName = NULL;
    
    dwError = ComputePrelimCN(
        pszFilterDN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pszFilterName = AllocPolBstrStr(pszGuidName);
    if (!pszFilterName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszFilterName = pszFilterName;
    
    return(dwError);
    
error:
    
    *ppszFilterName = NULL;
    
    return(dwError);
    
}


DWORD
CopyPolicyDSToWMIString(
                        LPWSTR pszPolicyDN,
                        LPWSTR * ppszPolicyName
                        )
{
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszPolicyName = NULL;
    
    dwError = ComputePrelimCN(
        pszPolicyDN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pszPolicyName = AllocPolBstrStr(pszGuidName);
    if (!pszPolicyName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszPolicyName = pszPolicyName;
    
    return(dwError);
    
error:
    
    *ppszPolicyName = NULL;
    
    return(dwError);
    
}


HRESULT
LogBlobPropertyEx(
                  IWbemClassObject *pInstance,
                  BSTR bstrPropName,
                  BYTE *pbBlob,
                  DWORD dwLen
                  )
{
    HRESULT hr = S_OK;
    SAFEARRAYBOUND arrayBound[1];
    SAFEARRAY *pSafeArray = NULL;
    VARIANT var;
    DWORD i = 0;
    
    VariantInit(&var);
    
    arrayBound[0].lLbound = 0;
    arrayBound[0].cElements = dwLen;
    
    pSafeArray = SafeArrayCreate(VT_UI1, 1, arrayBound);
    if (!pSafeArray)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    for (i = 0; i < dwLen; i++)
    {
        hr = SafeArrayPutElement(pSafeArray, (long *)&i, &pbBlob[i]);
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    var.vt = VT_ARRAY|VT_UI1;
    var.parray = pSafeArray;
    hr = IWbemClassObject_Put(
        pInstance,
        bstrPropName,
        0,
        &var,
        0
        );
    VariantClear(&var);        
    BAIL_ON_HRESULT_ERROR(hr);
    
error:
    
    return(hr);
    
}


HRESULT
DeleteWMIClassObject(
                     IWbemServices *pWbemServices,
                     LPWSTR pszWirelessWMIObject
                     )
{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pEnum = NULL;
    IWbemClassObject *pObj = NULL;
    ULONG uReturned = 0;
    VARIANT var;
    BSTR bstrWirelessWMIObject = NULL;
    
    
    VariantInit(&var);
    
    bstrWirelessWMIObject = SysAllocString(pszWirelessWMIObject);
    if(!bstrWirelessWMIObject) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    hr = IWbemServices_CreateInstanceEnum(
        pWbemServices,
        bstrWirelessWMIObject,
        WBEM_FLAG_FORWARD_ONLY,
        0,
        &pEnum
        );
    SysFreeString(bstrWirelessWMIObject);
    BAIL_ON_HRESULT_ERROR(hr);
    
    while(1) 
    {
        hr = IEnumWbemClassObject_Next(
            pEnum, 
            WBEM_INFINITE, 
            1, 
            &pObj, 
            &uReturned
            );
        if (hr == WBEM_S_NO_ERROR) {
            hr = IWbemClassObject_Get(
                pObj,
                L"__RELPATH",
                0,
                &var,
                0,
                0
                );
            BAIL_ON_HRESULT_ERROR(hr);
            
            hr = IWbemServices_DeleteInstance(
                pWbemServices,
                var.bstrVal,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                NULL
                );
            BAIL_ON_HRESULT_ERROR(hr);
            
            //free
            if(pObj) {
                IWbemClassObject_Release(pObj);
                pObj = NULL;
            	}
              VariantClear(&var);    

        } else {
            if(hr == WBEM_S_FALSE) {
                break;
            } else {
                BAIL_ON_HRESULT_ERROR(hr);
            }
        }
    }
    
    hr = S_OK;
    
cleanup:
    
    if(pEnum)
        IEnumWbemClassObject_Release(pEnum);
    
    return(hr);
    
error:

    if (pObj) {
        IWbemClassObject_Release(pObj);
        pObj = NULL;
     }
     VariantClear(&var);

    
    goto cleanup;
    
}

LPWSTR
AllocPolBstrStr(
                LPCWSTR pStr
                )
{
    LPWSTR pMem=NULL;
    DWORD StrLen;
    
    if (!pStr)
        return 0;
    
    StrLen = wcslen(pStr);
    if (pMem = (LPWSTR)AllocPolMem( StrLen*sizeof(WCHAR) + sizeof(WCHAR)
        + sizeof(DWORD)))
        wcscpy(pMem+2, pStr);  // Leaving 4 bytes for length
    
    *(DWORD *)pMem = StrLen*sizeof(WCHAR);  
    
    return pMem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\persist.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Mngrfldr.cpp
//
//  Contents:  Wireless Policy Snapin - Policy Main Page Manager.
//
//
//  History:    TaroonM
//              10/30/01
//                  Abhishev
//       
//
//----------------------------------------------------------------------------

#include "precomp.h"

LPWSTR  gpszWirelessCacheKey = L"SOFTWARE\\Policies\\Microsoft\\Windows\\Wireless\\Policy\\Cache";


DWORD
CacheDirectorytoRegistry(
                         PWIRELESS_POLICY_OBJECT pWirelessPolicyObject
                         )
{
    
    DWORD dwError = 0;
    PWIRELESS_POLICY_OBJECT pWirelessRegPolicyObject = NULL;
    
    //
    // Delete the existing cache.
    //
    
    DeleteRegistryCache();
    
    
    //
    // Create a copy of the directory policy in registry terms
    //
    
    
    dwError = CloneDirectoryPolicyObject(
        pWirelessPolicyObject,
        &pWirelessRegPolicyObject
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    
    //
    // Write the registry policy
    //
    
    
    dwError = PersistRegistryObject(
        pWirelessRegPolicyObject
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
cleanup:
    
    if (pWirelessRegPolicyObject) {
        
        FreeWirelessPolicyObject(
            pWirelessRegPolicyObject
            );
        
    }
    
    return(dwError);
    
error:
    
    DeleteRegistryCache();
    
    goto cleanup;
}


DWORD
PersistRegistryObject(
                      PWIRELESS_POLICY_OBJECT pWirelessRegPolicyObject
                      )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    DWORD dwDisposition = 0;
    
    dwError = RegCreateKeyExW(
        HKEY_LOCAL_MACHINE,
        gpszWirelessCacheKey,
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hRegistryKey,
        &dwDisposition
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    
    dwError = PersistPolicyObject(
        hRegistryKey,
        pWirelessRegPolicyObject
        );
    
error:
    
    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }
    
    
    return(dwError);
}

DWORD
PersistPolicyObject(
                    HKEY hRegistryKey,
                    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject
                    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    DWORD dwDisposition = 0;
    
    
    dwError = RegCreateKeyExW(
        hRegistryKey,
        pWirelessPolicyObject->pszWirelessOwnersReference,
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hRegKey,
        &dwDisposition
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = RegSetValueExW(
        hRegKey,
        L"ClassName",
        0,
        REG_SZ,
        (LPBYTE) L"msieee80211-Policy",
        (wcslen(L"msieee80211-Policy") + 1)*sizeof(WCHAR)
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    if (pWirelessPolicyObject->pszDescription) {
        
        dwError = RegSetValueExW(
            hRegKey,
            L"description",
            0,
            REG_SZ,
            (LPBYTE)pWirelessPolicyObject->pszDescription,
            (wcslen(pWirelessPolicyObject->pszDescription) + 1)*sizeof(WCHAR)
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
    }
    else {
        (VOID) RegDeleteValueW(
            hRegKey,
            L"description"
            );
    }
    
    if (pWirelessPolicyObject->pszWirelessOwnersReference) {
        
        dwError = RegSetValueExW(
            hRegKey,
            L"name",
            0,
            REG_SZ,
            (LPBYTE)pWirelessPolicyObject->pszWirelessOwnersReference,
            (wcslen(pWirelessPolicyObject->pszWirelessOwnersReference) + 1)*sizeof(WCHAR)
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (pWirelessPolicyObject->pszWirelessName) {
        
        dwError = RegSetValueExW(
            hRegKey,
            L"WirelessName",
            0,
            REG_SZ,
            (LPBYTE)pWirelessPolicyObject->pszWirelessName,
            (wcslen(pWirelessPolicyObject->pszWirelessName) + 1)*sizeof(WCHAR)
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (pWirelessPolicyObject->pszWirelessID) {
        
        dwError = RegSetValueExW(
            hRegKey,
            L"WirelessID",
            0,
            REG_SZ,
            (LPBYTE)pWirelessPolicyObject->pszWirelessID,
            (wcslen(pWirelessPolicyObject->pszWirelessID) + 1)*sizeof(WCHAR)
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    
    dwError = RegSetValueExW(
        hRegKey,
        L"WirelessDataType",
        0,
        REG_DWORD,
        (LPBYTE)&pWirelessPolicyObject->dwWirelessDataType,
        sizeof(DWORD)
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    if (pWirelessPolicyObject->pWirelessData) {
        
        dwError = RegSetValueExW(
            hRegKey,
            L"WirelessData",
            0,
            REG_BINARY,
            pWirelessPolicyObject->pWirelessData,
            pWirelessPolicyObject->dwWirelessDataLen
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    dwError = RegSetValueExW(
        hRegKey,
        L"whenChanged",
        0,
        REG_DWORD,
        (LPBYTE)&pWirelessPolicyObject->dwWhenChanged,
        sizeof(DWORD)
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
error:
    
    if (hRegKey) {
        RegCloseKey(hRegKey);
    }
    
    return(dwError);
}





DWORD
CloneDirectoryPolicyObject(
                           PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                           PWIRELESS_POLICY_OBJECT * ppWirelessRegPolicyObject
                           )
{
    DWORD dwError = 0;
    PWIRELESS_POLICY_OBJECT pWirelessRegPolicyObject = NULL;
    
    pWirelessRegPolicyObject = (PWIRELESS_POLICY_OBJECT)AllocPolMem(
        sizeof(WIRELESS_POLICY_OBJECT)
        );
    if (!pWirelessRegPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Now copy the rest of the data in the object
    //
    
    if (pWirelessPolicyObject->pszWirelessOwnersReference) {
        
        dwError = CopyPolicyDSToRegString(
            pWirelessPolicyObject->pszWirelessOwnersReference,
            &pWirelessRegPolicyObject->pszWirelessOwnersReference
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (pWirelessPolicyObject->pszWirelessName) {
        
        pWirelessRegPolicyObject->pszWirelessName = AllocPolStr(
            pWirelessPolicyObject->pszWirelessName
            );
        if (!pWirelessRegPolicyObject->pszWirelessName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    if (pWirelessPolicyObject->pszWirelessID) {
        
        pWirelessRegPolicyObject->pszWirelessID = AllocPolStr(
            pWirelessPolicyObject->pszWirelessID
            );
        if (!pWirelessRegPolicyObject->pszWirelessID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    pWirelessRegPolicyObject->dwWirelessDataType = 
        pWirelessPolicyObject->dwWirelessDataType;
    
    if (pWirelessPolicyObject->pWirelessData) {
        
        dwError = CopyBinaryValue(
            pWirelessPolicyObject->pWirelessData,
            pWirelessPolicyObject->dwWirelessDataLen,
            &pWirelessRegPolicyObject->pWirelessData
            );
        BAIL_ON_WIN32_ERROR(dwError);
        pWirelessRegPolicyObject->dwWirelessDataLen = 
            pWirelessPolicyObject->dwWirelessDataLen;
    }
    
    
    
    if (pWirelessPolicyObject->pszDescription) {
        
        pWirelessRegPolicyObject->pszDescription = AllocPolStr(
            pWirelessPolicyObject->pszDescription
            );
        if (!pWirelessRegPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    pWirelessRegPolicyObject->dwWhenChanged = 
        pWirelessPolicyObject->dwWhenChanged;
    
    *ppWirelessRegPolicyObject = pWirelessRegPolicyObject;
    
    return(dwError);
    
error:
    
    if (pWirelessRegPolicyObject) {
        FreeWirelessPolicyObject(
            pWirelessRegPolicyObject
            );
        
    }
    
    *ppWirelessRegPolicyObject = NULL;
    
    return(dwError);
                         
}


DWORD
CopyBinaryValue(
                LPBYTE pMem,
                DWORD dwMemSize,
                LPBYTE * ppNewMem
                )
{
    LPBYTE pNewMem = NULL;
    DWORD dwError = 0;
    
    
    pNewMem = (LPBYTE)AllocPolMem(dwMemSize);
    if (!pNewMem) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    memcpy(pNewMem, pMem, dwMemSize);
    
    
    *ppNewMem = pNewMem;
    
    return(dwError);
    
error:
    
    if (pNewMem) {
        
        FreePolMem(pNewMem);
    }
    
    *ppNewMem = NULL;
    
    return(dwError);
}
                           
                           
DWORD
CopyPolicyDSToFQRegString(
                          LPWSTR pszPolicyDN,
                          LPWSTR * ppszPolicyName
                          )
{
    
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszPolicyName = NULL;
    DWORD dwStringSize = 0;
    
    dwError = ComputePrelimCN(
        pszPolicyDN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwStringSize = wcslen(gpszWirelessCacheKey);
    dwStringSize += 1;
    dwStringSize += wcslen(pszGuidName);
    dwStringSize += 1;
    
    pszPolicyName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszPolicyName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    wcscpy(pszPolicyName, gpszWirelessCacheKey);
    wcscat(pszPolicyName, L"\\");
    wcscat(pszPolicyName, pszGuidName);
    
    *ppszPolicyName = pszPolicyName;
    
    return(dwError);
    
error:
    
    *ppszPolicyName = NULL;
    return(dwError);
    
}


DWORD
ComputeGUIDName(
                LPWSTR szCommonName,
                LPWSTR * ppszGuidName
                )
{
    LPWSTR pszGuidName = NULL;
    DWORD dwError = 0;
    
    pszGuidName = wcschr(szCommonName, L'=');
    if (!pszGuidName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszGuidName = (pszGuidName + 1);
    
    return(dwError);
    
error:
    
    *ppszGuidName = NULL;
    
    return(dwError);
}


DWORD
DeleteRegistryCache(
                    )
{
    DWORD dwError = 0;
    HKEY hParentKey = NULL;
    WCHAR lpszName[MAX_PATH];
    DWORD dwSize = 0;
    
    dwError = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        gpszWirelessCacheKey,
        0,
        KEY_ALL_ACCESS,
        &hParentKey
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
    dwSize =  MAX_PATH;
    
    while((RegEnumKeyExW(hParentKey, 0, lpszName,
        &dwSize, NULL,
        NULL, NULL,NULL)) == ERROR_SUCCESS) {
        
        dwError = RegDeleteKeyW(
            hParentKey,
            lpszName
            );
        if (dwError != ERROR_SUCCESS) {
            break;
        }
        
        
        memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
        dwSize =  MAX_PATH;
    }
    
error:
    
    if (hParentKey) {
        RegCloseKey(hParentKey);
    }
    
    return(dwError);
}


DWORD
CopyPolicyDSToRegString(
                        LPWSTR pszPolicyDN,
                        LPWSTR * ppszPolicyName
                        )
{
    
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszPolicyName = NULL;
    
    dwError = ComputePrelimCN(
        pszPolicyDN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    pszPolicyName = AllocPolStr(pszGuidName);
    if (!pszPolicyName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszPolicyName = pszPolicyName;
    
    return(dwError);
    
error:
    
    *ppszPolicyName = NULL;
    return(dwError);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\procrule.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       procrule.h
//
//  Contents:  Wireless Network Policy Management - Marshall/Unmarshall/etc.
//
//
//  History:    TaroonM
//              10/30/01
//                  Abhishev(2000)
//----------------------------------------------------------------------------
#include "precomp.h"

DWORD
DeepCpyRsopInfo(
    PRSOP_INFO pDestRsop,
    PRSOP_INFO pSrcRsop
    )
{
    DWORD dwError = ERROR_SUCCESS;

    if (pSrcRsop->pszCreationtime && *pSrcRsop->pszCreationtime) {
        pDestRsop->pszCreationtime = AllocPolStr(
                                         pSrcRsop->pszCreationtime
                                         );
        if (!pDestRsop->pszCreationtime) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    if (pSrcRsop->pszID && *pSrcRsop->pszID) {
        pDestRsop->pszID = AllocPolStr(
                             pSrcRsop->pszID
                             );
        if (!pDestRsop->pszID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    if (pSrcRsop->pszName && *pSrcRsop->pszName) {
        pDestRsop->pszName = AllocPolStr(
                             pSrcRsop->pszName
                             );
    }
    pDestRsop->uiPrecedence = pSrcRsop->uiPrecedence;
    if (pSrcRsop->pszGPOID && *pSrcRsop->pszGPOID) {
        pDestRsop->pszGPOID= AllocPolStr(
                             pSrcRsop->pszGPOID
                             );
        if (!pDestRsop->pszGPOID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    if (pSrcRsop->pszSOMID && *pSrcRsop->pszSOMID) {
        pDestRsop->pszSOMID = AllocPolStr(
                             pSrcRsop->pszSOMID
                             );
        if (!pDestRsop->pszSOMID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:
    return dwError;
}


DWORD
UnmarshallWirelessPSObject(
                           LPBYTE pMem,
                           PWIRELESS_PS_DATA *ppWirelessPSData,
                           LPBYTE *ppMem,
                           LPBYTE pMemDelimitter
                           )
{
    
    DWORD dwError = 0;
    DWORD dwPSLen = 0; 
    PWIRELESS_PS_DATA pWirelessPSData = NULL;
    WCHAR pszWirelessSSID[32];
    DWORD dwWirelessSSIDLen = 0;
    DWORD dwWepEnabled = 0;
    DWORD dwId = 0;
    DWORD dwNetworkAuthentication = 0;
    DWORD dwAutomaticKeyProvision = 0;
    DWORD dwNetworkType = 0;
    DWORD dwEnable8021x = 0;
    DWORD dw8021xMode = 0;
    DWORD dwEapType = 0;
    DWORD dwCertificateType = 0;
    DWORD dwValidateServerCertificate = 0;
    DWORD dwMachineAuthentication = 0;
    DWORD dwMachineAuthenticationType = 0;
    DWORD dwGuestAuthentication = 0;
    DWORD dwIEEE8021xMaxStart = 0;
    DWORD dwIEEE8021xStartPeriod = 0;
    DWORD dwIEEE802xAuthPeriod = 0;
    DWORD dwIEEE802xHeldPeriod = 0;
    DWORD dwDescriptionLen = 0;
    DWORD dwEAPDataLen = 0;
    LPBYTE pbEAPData = NULL;
    LPWSTR pszDescription = NULL;
    LPBYTE pTempMem = NULL;

    pTempMem = pMem;
    
    pWirelessPSData = (PWIRELESS_PS_DATA)AllocPolMem(
        sizeof(WIRELESS_PS_DATA)
        );
    
    if (!pWirelessPSData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
        }

    if (pMem + sizeof(DWORD) > pMemDelimitter) {
    	dwError = ERROR_INVALID_PARAMETER;
    	}
    BAIL_ON_WIN32_ERROR(dwError);
    
    memcpy((LPBYTE)&dwPSLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwPSLen = dwPSLen;

    if (pMem + dwPSLen -sizeof(DWORD) > pMemDelimitter) {
    	dwError = ERROR_INVALID_PARAMETER;
    	}
    BAIL_ON_WIN32_ERROR(dwError);

    // Now that we know the length of this PS, and it is in bounds
    // delimit further ; given by PSLen

    pMemDelimitter = pTempMem + dwPSLen;
    
    memcpy(pszWirelessSSID, pMem, 32*sizeof(WCHAR));
    pMem += 32*(sizeof(WCHAR));
    memcpy(pWirelessPSData->pszWirelessSSID, pszWirelessSSID, 32*sizeof(WCHAR));
    
    memcpy((LPBYTE)&dwWirelessSSIDLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwWirelessSSIDLen = dwWirelessSSIDLen;
    
    memcpy((LPBYTE)&dwWepEnabled, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwWepEnabled = dwWepEnabled;
    
    memcpy((LPBYTE)&dwId, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwId = dwId;
    
    memcpy((LPBYTE)&dwNetworkAuthentication,pMem,sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwNetworkAuthentication = dwNetworkAuthentication;
    
    memcpy((LPBYTE)&dwAutomaticKeyProvision, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwAutomaticKeyProvision = dwAutomaticKeyProvision;
    
    memcpy((LPBYTE)&dwNetworkType, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwNetworkType = dwNetworkType;
    
    memcpy((LPBYTE)&dwEnable8021x, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwEnable8021x = dwEnable8021x;
    
    memcpy((LPBYTE)&dw8021xMode, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dw8021xMode = dw8021xMode;
    
    memcpy((LPBYTE)&dwEapType, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwEapType = dwEapType;
    
    memcpy((LPBYTE)&dwEAPDataLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwEAPDataLen = dwEAPDataLen;

    if (dwEAPDataLen) {
        pbEAPData = (LPBYTE)AllocPolMem((dwEAPDataLen));
    
        if (!pbEAPData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    
        memcpy(pbEAPData, pMem, dwEAPDataLen);
    }
    
    pWirelessPSData->pbEAPData = pbEAPData;
    pMem += dwEAPDataLen;
    
    memcpy((LPBYTE)&dwMachineAuthentication, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwMachineAuthentication = dwMachineAuthentication;
    
    memcpy((LPBYTE)&dwMachineAuthenticationType, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwMachineAuthenticationType = dwMachineAuthenticationType;
    
    memcpy((LPBYTE)&dwGuestAuthentication, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwGuestAuthentication = dwGuestAuthentication;
    
    memcpy((LPBYTE)&dwIEEE8021xMaxStart, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwIEEE8021xMaxStart = dwIEEE8021xMaxStart;
    
    memcpy((LPBYTE)&dwIEEE8021xStartPeriod, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwIEEE8021xStartPeriod = dwIEEE8021xStartPeriod;
    
    memcpy((LPBYTE)&dwIEEE802xAuthPeriod, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwIEEE8021xAuthPeriod = dwIEEE802xAuthPeriod;       
    
    memcpy((LPBYTE)&dwIEEE802xHeldPeriod, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwIEEE8021xHeldPeriod = dwIEEE802xHeldPeriod;
    
    memcpy((LPBYTE)&dwDescriptionLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    pWirelessPSData->dwDescriptionLen = dwDescriptionLen;

    if (dwDescriptionLen) {
        pszDescription = (LPWSTR)AllocPolMem((dwDescriptionLen+1)*sizeof(WCHAR));
    
        if (!pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    
        memcpy(pszDescription, pMem, dwDescriptionLen*sizeof(WCHAR));
    }
    
    pWirelessPSData->pszDescription = pszDescription;
    pMem += dwDescriptionLen*sizeof(WCHAR);

    // validate here that we didnt cross the delimitter

    if (pMem > pMemDelimitter) {
    	dwError = ERROR_INVALID_PARAMETER;
    	}
    BAIL_ON_WIN32_ERROR(dwError);
    
    *ppWirelessPSData = pWirelessPSData;
    *ppMem = pTempMem + dwPSLen;
    
    return(dwError);
    
error:
    
    if (pWirelessPSData) {
        FreeWirelessPSData(pWirelessPSData);
        }
    
    *ppWirelessPSData = NULL;
    return(dwError);
    
}


DWORD
UnmarshallWirelessPolicyObject(
                               PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                               DWORD dwStoreType,
                               PWIRELESS_POLICY_DATA * ppWirelessPolicyData
                               )
                               
{
    LPBYTE pMem = NULL;
    LPBYTE pNMem = NULL; 
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    PWIRELESS_PS_DATA *ppWirelessPSDatas = NULL;
    PWIRELESS_PS_DATA  pWirelessPSData = NULL;
    DWORD dwPollingInterval = 0;
    DWORD dwError = 0;
    DWORD dwSkipSize = 0;
    DWORD dwDisableZeroConf = 0;
    DWORD dwNetworkToAccess = 0;
    DWORD dwConnectToNonPreferredNetworks = 0;
    DWORD dwNumPreferredSettings = 0;
    DWORD dwNumAPNetworks = 0;
    DWORD dwFirstAdhoc = 1;
    DWORD i = 0;
    WORD wMajorVersion = 0;
    WORD wMinorVersion = 0;
    DWORD dwFound = 0;
    DWORD dwWirelessDataLen = 0;
    DWORD dwAdvance = 0;
    DWORD dwWlBlobLen = 0;
    DWORD dwFlags = 0;
    DWORD dwBlobAdvance = 0;
    LPBYTE pMemDelimitter = NULL;

    
    pWirelessPolicyData = (PWIRELESS_POLICY_DATA)AllocPolMem(
        sizeof(WIRELESS_POLICY_DATA)
        );
    if (!pWirelessPolicyData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    
    if (pWirelessPolicyObject->pszWirelessName && *(pWirelessPolicyObject->pszWirelessName)) {
        
        pWirelessPolicyData->pszWirelessName = AllocPolStr(
            pWirelessPolicyObject->pszWirelessName
            );
        if (!pWirelessPolicyData->pszWirelessName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
            }
        }

    pWirelessPolicyData->pszOldWirelessName = NULL;
    
    if (pWirelessPolicyObject->pszDescription && 
        *(pWirelessPolicyObject->pszDescription)){
        
        pWirelessPolicyData->pszDescription = AllocPolStr(
            pWirelessPolicyObject->pszDescription
            );
        if (!pWirelessPolicyData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
            }
        }
    
    wGUIDFromString(pWirelessPolicyObject->pszWirelessID,
        &pWirelessPolicyData->PolicyIdentifier
        );
    
    
    
    pMem = pWirelessPolicyObject->pWirelessData;

    dwWirelessDataLen = pWirelessPolicyObject->dwWirelessDataLen;
    
    //
    // Find the start point of our version.
    //

    pMemDelimitter = pMem + dwWirelessDataLen;
    
    dwAdvance = 0;
    while(dwAdvance < dwWirelessDataLen) {
    	
        memcpy((LPBYTE)&wMajorVersion, pMem+dwAdvance, sizeof(WORD));
        dwAdvance += sizeof(WORD);

        memcpy((LPBYTE)&wMinorVersion, pMem+dwAdvance, sizeof(WORD));
        dwAdvance += sizeof(WORD);

        if ((wMajorVersion == WL_BLOB_MAJOR_VERSION) 
        	&& (wMinorVersion == WL_BLOB_MINOR_VERSION))
        {
            dwFound = 1;
            dwBlobAdvance = dwAdvance;
        }
        else 
        {
               if (
               	(wMajorVersion > WL_BLOB_MAJOR_VERSION) 
               	||((wMajorVersion == WL_BLOB_MAJOR_VERSION) 
               	    && (wMinorVersion > WL_BLOB_MINOR_VERSION))
               	)
               {
                    dwFlags = WLSTORE_READONLY;
               }
    	 }
        memcpy((LPBYTE)&dwWlBlobLen, pMem+dwAdvance, sizeof(DWORD));
        dwAdvance += sizeof(DWORD);
        dwAdvance += dwWlBlobLen;
    }

    if (!dwFound) {
        dwError = ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    pMem += dwBlobAdvance;

    // read the length

    if (pMem + sizeof(DWORD)  > pMemDelimitter) {
    	dwError = ERROR_INVALID_PARAMETER;
    	}
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy((LPBYTE)&dwWlBlobLen, pMem, sizeof(DWORD));

    pMem += sizeof(DWORD);

    if ((pMem + dwWlBlobLen) > pMemDelimitter ) {
    	dwError = ERROR_INVALID_PARAMETER;
    	}
    BAIL_ON_WIN32_ERROR(dwError);

    // Now that we the know a better bound on the delimitter

    pMemDelimitter = pMem + dwWlBlobLen;

    memcpy((LPBYTE)&dwPollingInterval, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    
    memcpy((LPBYTE)&dwDisableZeroConf, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    
    memcpy((LPBYTE)&dwNetworkToAccess, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    
    memcpy((LPBYTE)&dwConnectToNonPreferredNetworks, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    
    memcpy((LPBYTE)&dwNumPreferredSettings, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    
    pWirelessPolicyData->dwWhenChanged = pWirelessPolicyObject->dwWhenChanged;
    
    pWirelessPolicyData->dwPollingInterval = dwPollingInterval;
    
    pWirelessPolicyData->dwDisableZeroConf = dwDisableZeroConf;
    
    pWirelessPolicyData->dwNetworkToAccess = dwNetworkToAccess;
    
    pWirelessPolicyData->dwConnectToNonPreferredNtwks = 
        dwConnectToNonPreferredNetworks;

    pWirelessPolicyData->dwFlags = dwFlags;
    
    if (pMem > pMemDelimitter) {
    	dwError = ERROR_INVALID_PARAMETER;
    	}
    BAIL_ON_WIN32_ERROR(dwError);
    
    if(dwNumPreferredSettings) {
        ppWirelessPSDatas = 
            (PWIRELESS_PS_DATA *) 
            AllocPolMem(dwNumPreferredSettings*sizeof(PWIRELESS_PS_DATA));
        
        if(!ppWirelessPSDatas) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
            }
        
        // Read the WirelessPSData now
        for(i=0;i<dwNumPreferredSettings;++i) {

            
            dwError = UnmarshallWirelessPSObject(
                pMem, 
                &pWirelessPSData,
                &pNMem,
                pMemDelimitter
                );
            BAIL_ON_WIN32_ERROR(dwError);
            
            *(ppWirelessPSDatas+i) = pWirelessPSData;
            pMem = pNMem;
            
            if(dwFirstAdhoc) {
                if (pWirelessPSData->dwNetworkType == 
                    WIRELESS_NETWORK_TYPE_ADHOC)
                {
                    dwNumAPNetworks = i;
                    dwFirstAdhoc = 0;
                    }
                }
            }
        }
    
    pWirelessPolicyData->ppWirelessPSData = ppWirelessPSDatas;
    pWirelessPolicyData->dwNumPreferredSettings = 
        dwNumPreferredSettings;
    
    if(dwFirstAdhoc) {
        dwNumAPNetworks = dwNumPreferredSettings;
        }
    
    pWirelessPolicyData->dwNumAPNetworks = 
        dwNumAPNetworks;

    /* WMI RElated */
    switch(dwStoreType) {

    case WIRELESS_WMI_PROVIDER:
        pWirelessPolicyData->pRsopInfo = (PRSOP_INFO)AllocPolMem(
                                sizeof(RSOP_INFO)
                                );
        if (!pWirelessPolicyData->pRsopInfo) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }    
        dwError = DeepCpyRsopInfo(
                      pWirelessPolicyData->pRsopInfo,
                      pWirelessPolicyObject->pRsopInfo
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        // no "break"; do everything we'd do for WIRELESS_REGISTRY_PROVIDER as well.
    case WIRELESS_REGISTRY_PROVIDER:
        break;
        
    case WIRELESS_DIRECTORY_PROVIDER:
        break;

    default:
         dwError = ERROR_INVALID_PARAMETER;
         BAIL_ON_WIN32_ERROR(dwError);

    }
    
    *ppWirelessPolicyData = pWirelessPolicyData;
    
    return(0);
    
error:
    
    if (pWirelessPolicyData) {
        FreeWirelessPolicyData(pWirelessPolicyData);
        }
    
    *ppWirelessPolicyData = NULL;
    return(dwError);
}


DWORD
UpdateWirelessPolicyDataWithPreferredSettings(
                         PWIRELESS_POLICY_DATA pNewWirelessPolicyData,
                         PWIRELESS_POLICY_DATA pWirelessPolicyData
                         )
{
    DWORD dwError = 0;
    
    DWORD i = 0;
    DWORD j=0;
    DWORD dwNumPreferredSettings = 0;
    DWORD dwNumAPNetworks = 0;
    PWIRELESS_PS_DATA pWirelessPSData;
    PWIRELESS_PS_DATA pNewWirelessPSData;
    PWIRELESS_PS_DATA *ppNewWirelessPSData;
    PWIRELESS_PS_DATA *ppWirelessPSData;
    DWORD dwNumToFreePreferredSettings = 0;
    PWIRELESS_PS_DATA *ppToFreeWirelessPSData = NULL;
    
    
    dwNumPreferredSettings = 
        pWirelessPolicyData->dwNumPreferredSettings;
    
    dwNumAPNetworks = 
        pWirelessPolicyData->dwNumAPNetworks;
    
    dwNumToFreePreferredSettings = 
        pNewWirelessPolicyData->dwNumPreferredSettings;
    

    
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    ppToFreeWirelessPSData = pNewWirelessPolicyData->ppWirelessPSData;
    
    ppNewWirelessPSData = (PWIRELESS_PS_DATA *) AllocPolMem(
        dwNumPreferredSettings*sizeof(PWIRELESS_PS_DATA));
    
    if(!ppNewWirelessPSData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    for(i=0; i<dwNumPreferredSettings; ++i) {
        
        pNewWirelessPSData = NULL;
        dwError = CopyWirelessPSData(
            *(ppWirelessPSData+i),
            &pNewWirelessPSData
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        *(ppNewWirelessPSData+i) = pNewWirelessPSData;
    }
    
    pNewWirelessPolicyData->ppWirelessPSData = 
        ppNewWirelessPSData;

    pNewWirelessPolicyData->dwNumPreferredSettings = 
        dwNumPreferredSettings;
    
    pNewWirelessPolicyData->dwNumAPNetworks = 
        dwNumAPNetworks;
    
    // Free the Old PS Array now
    for(i=0; i < dwNumToFreePreferredSettings; ++i) {
        FreeWirelessPSData(ppToFreeWirelessPSData[i]);
        }
    FreePolMem(ppToFreeWirelessPSData);
    
    return (dwError);
    
error:
    
    if (ppNewWirelessPSData) {

        // Need to free up any of the WirelessPSData that may have been
        // Allocated.
        for(j=0; j<i ; ++j) {
            FreeWirelessPSData(
                ppNewWirelessPSData[j]
                );
        }

        // Free up the last one if there.

        if(pNewWirelessPSData) {
            FreeWirelessPSData(
                pNewWirelessPSData
                );
        }
        
        FreePolMem(ppNewWirelessPSData);
    }
    
    return (dwError);
    
}







DWORD
UpdateWirelessPolicyData(
                         PWIRELESS_POLICY_DATA pNewWirelessPolicyData,
                         PWIRELESS_POLICY_DATA pWirelessPolicyData
                         )
{
    DWORD dwError = 0;
    
    DWORD i = 0;
    DWORD dwNumPreferredSettings = 0;
    DWORD dwNumAPNetworks = 0;
    PWIRELESS_PS_DATA pWirelessPSData;
    PWIRELESS_PS_DATA pNewWirelessPSData;
    PWIRELESS_PS_DATA *ppNewWirelessPSData;
    PWIRELESS_PS_DATA *ppWirelessPSData;
    DWORD dwNumToFreePreferredSettings = 0;
    PWIRELESS_PS_DATA *ppToFreeWirelessPSData = NULL;
    
    
    pNewWirelessPolicyData->dwPollingInterval = 
        pWirelessPolicyData->dwPollingInterval;
    
    pNewWirelessPolicyData->dwWhenChanged = 
        pWirelessPolicyData->dwWhenChanged;

    pNewWirelessPolicyData->dwFlags = pWirelessPolicyData->dwFlags;
    
    memcpy(
        &(pNewWirelessPolicyData->PolicyIdentifier),
        &(pWirelessPolicyData->PolicyIdentifier),
        sizeof(GUID)
        );
    
    if (pWirelessPolicyData->pszWirelessName &&
        *pWirelessPolicyData->pszWirelessName) {

        if (pNewWirelessPolicyData->pszWirelessName) {
        	FreePolStr(pNewWirelessPolicyData->pszWirelessName);
        	}
        
        pNewWirelessPolicyData->pszWirelessName = AllocPolStr(
            pWirelessPolicyData->pszWirelessName
            );
        if (!pNewWirelessPolicyData->pszWirelessName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
            }
        }
    
    if (pWirelessPolicyData->pszDescription &&
        *pWirelessPolicyData->pszDescription) {

        if (pNewWirelessPolicyData->pszDescription) {
        	FreePolStr(pNewWirelessPolicyData->pszDescription);
        	}
        pNewWirelessPolicyData->pszDescription = AllocPolStr(
            pWirelessPolicyData->pszDescription
            );
        if (!pNewWirelessPolicyData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
            }
        }
    
    pNewWirelessPolicyData->dwDisableZeroConf = 
        pWirelessPolicyData->dwDisableZeroConf;
    
    pNewWirelessPolicyData->dwNetworkToAccess = 
        pWirelessPolicyData->dwNetworkToAccess;
    
    pNewWirelessPolicyData->dwConnectToNonPreferredNtwks = 
        pWirelessPolicyData->dwConnectToNonPreferredNtwks;
    
    dwNumPreferredSettings = 
        pWirelessPolicyData->dwNumPreferredSettings;
    
    dwNumAPNetworks = 
        pWirelessPolicyData->dwNumAPNetworks;
    
    dwNumToFreePreferredSettings = 
        pNewWirelessPolicyData->dwNumPreferredSettings;
    
    pNewWirelessPolicyData->dwNumPreferredSettings = 
        dwNumPreferredSettings;
    
    pNewWirelessPolicyData->dwNumAPNetworks = 
        dwNumAPNetworks;
    
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    ppToFreeWirelessPSData = pNewWirelessPolicyData->ppWirelessPSData;
    
    ppNewWirelessPSData = (PWIRELESS_PS_DATA *) AllocPolMem(
        dwNumPreferredSettings*sizeof(PWIRELESS_PS_DATA));
    
    if(!ppNewWirelessPSData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    for(i=0; i<dwNumPreferredSettings; ++i) {
        
        pNewWirelessPSData = NULL;
        dwError = CopyWirelessPSData(
            *(ppWirelessPSData+i),
            &pNewWirelessPSData
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        *(ppNewWirelessPSData+i) = pNewWirelessPSData;
        }
    
    pNewWirelessPolicyData->ppWirelessPSData = 
        ppNewWirelessPSData;
    
    // Free the Old PS Array now
    for(i=0; i < dwNumToFreePreferredSettings; ++i) {
        FreeWirelessPSData(ppToFreeWirelessPSData[i]);
        }
    FreePolMem(ppToFreeWirelessPSData);
    
    return (dwError);
    
error:
    
    if (ppNewWirelessPSData) {
        FreePolMem(ppNewWirelessPSData);
        }
    
    return (dwError);
    
}

DWORD 
ModifyWirelessPSData(
                     PWIRELESS_PS_DATA pNewWirelessPSData,
                     PWIRELESS_PS_DATA pWirelessPSData
                     )
{
    
    DWORD dwError = 0;
    DWORD dwPSLen = 0;
    WCHAR SSID[32];
    DWORD dwSize = 0;
    DWORD dwWepEnabled=0;
    DWORD dwId = 0;
    DWORD dwWirelessSSIDLen = 0;
    DWORD dwNetworkAuthentication = 0;
    DWORD dwAutomaticKeyProvision = 0;
    DWORD dwNetworkType = 0;
    DWORD dwEnable8021x = 0;
    DWORD dw8021xMode = 0;
    DWORD dwEapType = 0;
    DWORD dwCertificateType = 0;
    DWORD dwValidateServerCertificate = 0;
    DWORD dwEAPDataLen = 0;
    LPBYTE pbEAPData = NULL;
    DWORD dwMachineAuthentication = 0;
    DWORD dwMachineAuthenticationType = 0;
    DWORD dwGuestAuthentication = 0;
    DWORD dwIEEE8021xMaxStart = 0;
    DWORD dwIEEE8021xStartPeriod = 0;
    DWORD dwIEEE8021xAuthPeriod = 0;
    DWORD dwIEEE8021xHeldPeriod = 0;
    DWORD dwDescriptionLen = 0;
    LPWSTR pszDescription = NULL;
    
    
    if (!pNewWirelessPSData || !pWirelessPSData) {
        dwError = -1 ;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    dwPSLen = pWirelessPSData->dwPSLen;
    pNewWirelessPSData->dwPSLen = dwPSLen;
    
    memcpy(SSID,pWirelessPSData->pszWirelessSSID,32*2);
    memcpy(pNewWirelessPSData->pszWirelessSSID,SSID,32*2);
    
    dwWirelessSSIDLen = pWirelessPSData->dwWirelessSSIDLen;
    pNewWirelessPSData->dwWirelessSSIDLen = dwWirelessSSIDLen;
    
    dwWepEnabled = pWirelessPSData->dwWepEnabled;
    pNewWirelessPSData->dwWepEnabled = dwWepEnabled;
    
    dwId = pWirelessPSData->dwId;
    pNewWirelessPSData->dwId = dwId;
    
    dwNetworkAuthentication = pWirelessPSData->dwNetworkAuthentication;
    pNewWirelessPSData->dwNetworkAuthentication = dwNetworkAuthentication;
    
    dwAutomaticKeyProvision = pWirelessPSData->dwAutomaticKeyProvision;
    pNewWirelessPSData->dwAutomaticKeyProvision = dwAutomaticKeyProvision;
    
    dwNetworkType = pWirelessPSData->dwNetworkType;
    pNewWirelessPSData->dwNetworkType = dwNetworkType;
    
    dwEnable8021x = pWirelessPSData->dwEnable8021x;
    pNewWirelessPSData->dwEnable8021x = dwEnable8021x;
    
    dw8021xMode = pWirelessPSData->dw8021xMode;
    pNewWirelessPSData->dw8021xMode = dw8021xMode;
    
    dwEapType = pWirelessPSData->dwEapType;
    pNewWirelessPSData->dwEapType = dwEapType;
    
    dwEAPDataLen = pWirelessPSData->dwEAPDataLen;
    pNewWirelessPSData->dwEAPDataLen = dwEAPDataLen;
    
    pbEAPData = AllocPolMem(dwEAPDataLen);
    if (!pbEAPData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    memcpy(pbEAPData, pWirelessPSData->pbEAPData, dwEAPDataLen);
    
    FreePolMem(pNewWirelessPSData->pbEAPData);
    
    
    pNewWirelessPSData->pbEAPData = pbEAPData;
    
    dwMachineAuthentication = pWirelessPSData->dwMachineAuthentication;
    pNewWirelessPSData->dwMachineAuthentication = dwMachineAuthentication;
    
    
    dwMachineAuthenticationType = pWirelessPSData->dwMachineAuthenticationType;
    pNewWirelessPSData->dwMachineAuthenticationType = 
        dwMachineAuthenticationType;
    
    dwGuestAuthentication = pWirelessPSData->dwGuestAuthentication;
    pNewWirelessPSData->dwGuestAuthentication = dwGuestAuthentication;
    
    dwIEEE8021xMaxStart = pWirelessPSData->dwIEEE8021xMaxStart;
    pNewWirelessPSData->dwIEEE8021xMaxStart = dwIEEE8021xMaxStart;
    
    dwIEEE8021xStartPeriod = pWirelessPSData->dwIEEE8021xStartPeriod;
    pNewWirelessPSData->dwIEEE8021xStartPeriod = dwIEEE8021xStartPeriod;
    
    dwIEEE8021xAuthPeriod = pWirelessPSData->dwIEEE8021xAuthPeriod;
    pNewWirelessPSData->dwIEEE8021xAuthPeriod = dwIEEE8021xAuthPeriod;
    
    dwIEEE8021xHeldPeriod = pWirelessPSData->dwIEEE8021xHeldPeriod;
    pNewWirelessPSData->dwIEEE8021xHeldPeriod = dwIEEE8021xHeldPeriod;
    
    dwDescriptionLen = pWirelessPSData->dwDescriptionLen;
    pNewWirelessPSData->dwDescriptionLen = dwDescriptionLen;
    
    pszDescription = AllocPolStr(pWirelessPSData->pszDescription);
    if (!pszDescription) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    FreePolMem(pNewWirelessPSData->pszDescription);
    
    
    pNewWirelessPSData->pszDescription = pszDescription;
    
    return(dwError);
    
error:
    return(dwError);
    
}

DWORD 
WirelessPSMoveUp(
                 PWIRELESS_POLICY_DATA pWirelessPolicyData,
                 DWORD dwIndex
                 )
{
    
    PWIRELESS_PS_DATA *ppWirelessPSData = NULL;
    PWIRELESS_PS_DATA pUpperWirelessPSData = NULL;
    PWIRELESS_PS_DATA pLowerWirelessPSData = NULL;
    DWORD dwError = 0;
    DWORD dwNumPreferredSettings;
    
    
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    if (!ppWirelessPSData) {
        dwError = ERROR_PS_NOT_PRESENT;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    dwNumPreferredSettings = pWirelessPolicyData->dwNumPreferredSettings;
    if(dwNumPreferredSettings <= dwIndex) {
        dwError = ERROR_PS_NOT_PRESENT;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    
    pUpperWirelessPSData = ppWirelessPSData[dwIndex];
    pLowerWirelessPSData = ppWirelessPSData[dwIndex-1];
    
    if(!(pUpperWirelessPSData && pLowerWirelessPSData)) {
        dwError = ERROR_PS_NOT_PRESENT;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    
    pUpperWirelessPSData->dwId = dwIndex-1;
    pLowerWirelessPSData->dwId = dwIndex;
    
    ppWirelessPSData[dwIndex] = pLowerWirelessPSData;
    ppWirelessPSData[dwIndex-1] = pUpperWirelessPSData;
    
    return(dwError);
error:
    
    return(dwError);
    
    }

DWORD 
WirelessPSMoveDown(
                   PWIRELESS_POLICY_DATA pWirelessPolicyData,
                   DWORD dwIndex
                   )
{
    
    PWIRELESS_PS_DATA *ppWirelessPSData = NULL;
    PWIRELESS_PS_DATA pUpperWirelessPSData = NULL;
    PWIRELESS_PS_DATA pLowerWirelessPSData = NULL;
    DWORD dwError = 0;
    DWORD dwNumPreferredSettings;
    
    
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    if (!ppWirelessPSData) {
        dwError = ERROR_PS_NOT_PRESENT;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    dwNumPreferredSettings = pWirelessPolicyData->dwNumPreferredSettings;
    if(dwNumPreferredSettings <= dwIndex) {
        dwError = ERROR_PS_NOT_PRESENT;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    
    pUpperWirelessPSData = ppWirelessPSData[dwIndex+1];
    pLowerWirelessPSData = ppWirelessPSData[dwIndex];
    
    if(!(pUpperWirelessPSData && pLowerWirelessPSData)) {
        dwError = ERROR_PS_NOT_PRESENT;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    
    pUpperWirelessPSData->dwId = dwIndex;
    pLowerWirelessPSData->dwId = dwIndex+1;
    
    ppWirelessPSData[dwIndex] = pUpperWirelessPSData;
    ppWirelessPSData[dwIndex+1] = pLowerWirelessPSData;
    
    return(dwError);
error:
    
    return(dwError);
    
    }


DWORD 
WirelessSetPSDataInPolicyId(
                            PWIRELESS_POLICY_DATA pWirelessPolicyData,
                            PWIRELESS_PS_DATA pWirelessPSData
                            )
{
    DWORD dwError = 0;
    DWORD dwPSId;
    DWORD dwNumPreferredSettings = 0;
    PWIRELESS_PS_DATA pCurrentWirelessPSData = NULL;
    PWIRELESS_PS_DATA *ppWirelessPSData = NULL;
    PWIRELESS_PS_DATA *ppNewWirelessPSData = NULL;
    DWORD dwNumAPNetworks;
    DWORD dwNewNumAPNetworks = 0;
    DWORD dwNewId = 0;
    DWORD i = 0;
    
    if (!(pWirelessPolicyData && pWirelessPSData)) {
        dwError = ERROR_PS_NOT_PRESENT;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    dwPSId = pWirelessPSData->dwId;
    dwNumPreferredSettings = pWirelessPolicyData->dwNumPreferredSettings;
    dwNumAPNetworks = pWirelessPolicyData->dwNumAPNetworks;
    
    
    if (dwPSId >= dwNumPreferredSettings) {
        dwError = ERROR_PS_NOT_PRESENT;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    
    pCurrentWirelessPSData = ppWirelessPSData[dwPSId];
    
    if (pCurrentWirelessPSData->dwNetworkType != pWirelessPSData->dwNetworkType) {
        
        ppNewWirelessPSData = 
            (PWIRELESS_PS_DATA *) 
            AllocPolMem(sizeof(PWIRELESS_PS_DATA)*dwNumPreferredSettings);
        
        if(ppNewWirelessPSData == NULL) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        if (pCurrentWirelessPSData->dwNetworkType == WIRELESS_NETWORK_TYPE_AP) {
            //AP to Adhoc
            for(i=0; i < dwPSId; ++i) {
                ppNewWirelessPSData[i] = ppWirelessPSData[i];
            }
            for(i = dwPSId+1;i<dwNumAPNetworks;++i) {
                ppNewWirelessPSData[i-1] = ppWirelessPSData[i];
            }
            ppNewWirelessPSData[dwNumAPNetworks-1] = ppWirelessPSData[dwPSId];
            dwNewId = dwNumAPNetworks-1 ;
            dwNewNumAPNetworks = pWirelessPolicyData->dwNumAPNetworks-1;
            
            for(i = dwNumAPNetworks;i<dwNumPreferredSettings;++i) {
                ppNewWirelessPSData[i] = ppWirelessPSData[i];
            }
        } else 
        {
            // Adhoc to AP 
            
            for(i=0; i < dwNumAPNetworks; ++i) {
                ppNewWirelessPSData[i] = ppWirelessPSData[i];
            }
            
            ppNewWirelessPSData[dwNumAPNetworks] = ppWirelessPSData[dwPSId];
            dwNewId = dwNumAPNetworks;
            dwNewNumAPNetworks = pWirelessPolicyData->dwNumAPNetworks+1;
            
            for(i=dwNumAPNetworks; i < dwPSId; ++i) {
                ppNewWirelessPSData[i+1] = ppWirelessPSData[i];
            }
            for(i=dwPSId+1; i < dwNumPreferredSettings; ++i) {
                ppNewWirelessPSData[i] = ppWirelessPSData[i];
            }
        }
        
        dwError = ModifyWirelessPSData(
            ppNewWirelessPSData[dwNewId],
            pWirelessPSData
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        for(i=0;i<dwNumPreferredSettings;++i)
        {
            ppNewWirelessPSData[i]->dwId = i;
        }
        
        pWirelessPolicyData->ppWirelessPSData = ppNewWirelessPSData;
        pWirelessPolicyData->dwNumAPNetworks = dwNewNumAPNetworks;
        pWirelessPSData->dwId = dwNewId;
        FreePolMem(ppWirelessPSData);
    } else {
        
        dwError = ModifyWirelessPSData(
            pWirelessPolicyData->ppWirelessPSData[dwPSId],
            pWirelessPSData
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        
        
    }
    
    dwError = ERROR_SUCCESS;
    return(dwError);
    
error:
    if (ppNewWirelessPSData) {
        FreePolMem(ppNewWirelessPSData);
    }
    
    return(dwError);
}



DWORD
CopyWirelessPolicyData(
                       PWIRELESS_POLICY_DATA pWirelessPolicyData,
                       PWIRELESS_POLICY_DATA * ppWirelessPolicyData
                       )
{
    DWORD dwError = 0;
    PWIRELESS_POLICY_DATA pNewWirelessPolicyData = NULL;
    
    DWORD i = 0;
    DWORD dwNumPreferredSettings = 0;
    DWORD dwNumAPNetworks = 0;
    PWIRELESS_PS_DATA pWirelessPSData;
    PWIRELESS_PS_DATA pNewWirelessPSData;
    PWIRELESS_PS_DATA *ppNewWirelessPSData;
    PWIRELESS_PS_DATA *ppWirelessPSData;
    
    
    *ppWirelessPolicyData = NULL;
    
    pNewWirelessPolicyData = (PWIRELESS_POLICY_DATA) AllocPolMem(
        sizeof(WIRELESS_POLICY_DATA)
        );
    if (!pNewWirelessPolicyData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    pNewWirelessPolicyData->dwPollingInterval = 
        pWirelessPolicyData->dwPollingInterval;
    
    pNewWirelessPolicyData->dwWhenChanged = 
        pWirelessPolicyData->dwWhenChanged;

    pNewWirelessPolicyData->dwFlags = pWirelessPolicyData->dwFlags;
    
    memcpy(
        &(pNewWirelessPolicyData->PolicyIdentifier),
        &(pWirelessPolicyData->PolicyIdentifier),
        sizeof(GUID)
        );
    
    if (pWirelessPolicyData->pszWirelessName &&
        *pWirelessPolicyData->pszWirelessName) {
        pNewWirelessPolicyData->pszWirelessName = 
            AllocPolStr(
                pWirelessPolicyData->pszWirelessName
                );

        if (!pNewWirelessPolicyData->pszWirelessName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
            }
        }

        if (pWirelessPolicyData->pszOldWirelessName &&
        *pWirelessPolicyData->pszOldWirelessName) {
        pNewWirelessPolicyData->pszOldWirelessName = 
            AllocPolStr(
                pWirelessPolicyData->pszOldWirelessName
                );

        if (!pNewWirelessPolicyData->pszOldWirelessName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
            }
        }
    
    if (pWirelessPolicyData->pszDescription &&
        *pWirelessPolicyData->pszDescription) {
        pNewWirelessPolicyData->pszDescription = AllocPolStr(
            pWirelessPolicyData->pszDescription
            );
        if (!pNewWirelessPolicyData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
            }
        }
    
    pNewWirelessPolicyData->dwDisableZeroConf = 
        pWirelessPolicyData->dwDisableZeroConf;

    pNewWirelessPolicyData->wMajorVersion = 
    	pWirelessPolicyData->wMajorVersion;
    
    pNewWirelessPolicyData->wMinorVersion = 
    	pWirelessPolicyData->wMinorVersion;
    

    
    pNewWirelessPolicyData->dwNetworkToAccess = 
        pWirelessPolicyData->dwNetworkToAccess;
    
    pNewWirelessPolicyData->dwConnectToNonPreferredNtwks = 
        pWirelessPolicyData->dwConnectToNonPreferredNtwks;
    
    dwNumPreferredSettings = 
        pWirelessPolicyData->dwNumPreferredSettings;
    
    dwNumAPNetworks = 
        pWirelessPolicyData->dwNumAPNetworks;
    
    pNewWirelessPolicyData->dwNumPreferredSettings = 
        dwNumPreferredSettings;
    
    pNewWirelessPolicyData->dwNumAPNetworks = 
        dwNumAPNetworks;
    
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    
    ppNewWirelessPSData = (PWIRELESS_PS_DATA *) AllocPolMem(
        dwNumPreferredSettings*sizeof(PWIRELESS_PS_DATA));
    
    if(!ppNewWirelessPSData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    for(i=0; i<dwNumPreferredSettings; ++i) {
        
        pNewWirelessPSData = NULL;
        dwError = CopyWirelessPSData(
            *(ppWirelessPSData+i),
            &pNewWirelessPSData
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        *(ppNewWirelessPSData+i) = pNewWirelessPSData;
        }
    
    pNewWirelessPolicyData->ppWirelessPSData = 
        ppNewWirelessPSData;

    if (pWirelessPolicyData->pRsopInfo) {
        pNewWirelessPolicyData->pRsopInfo = (PRSOP_INFO)AllocPolMem(
                                sizeof(RSOP_INFO)
                                );
        
        if (!pNewWirelessPolicyData->pRsopInfo) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }    
    
        dwError = DeepCpyRsopInfo(
                     pNewWirelessPolicyData->pRsopInfo,
                     pWirelessPolicyData->pRsopInfo
                     );
        BAIL_ON_WIN32_ERROR(dwError);
    }
        
    *ppWirelessPolicyData = pNewWirelessPolicyData;
    
    return (dwError);
    
error:
    
    if (pNewWirelessPolicyData) {
        FreeWirelessPolicyData(pNewWirelessPolicyData);
        }
    
    *ppWirelessPolicyData = NULL;
    
    return (dwError);
    
}



DWORD 
CopyWirelessPSData(
                   PWIRELESS_PS_DATA pWirelessPSData,
                   PWIRELESS_PS_DATA *ppWirelessPSData
                   )
{
    
    PWIRELESS_PS_DATA pNewWirelessPSData = NULL;
    DWORD dwError = 0;
    DWORD dwPSLen = 0;
    WCHAR SSID[32];
    DWORD dwSize = 0;
    DWORD dwWepEnabled=0;
    DWORD dwId = 0;
    DWORD dwWirelessSSIDLen = 0;
    DWORD dwNetworkAuthentication = 0;
    DWORD dwAutomaticKeyProvision = 0;
    DWORD dwNetworkType = 0;
    DWORD dwEnable8021x = 0;
    DWORD dw8021xMode = 0;
    DWORD dwEapType = 0;
    DWORD dwCertificateType = 0;
    DWORD dwValidateServerCertificate = 0;
    DWORD dwEAPDataLen = 0;
    LPBYTE pbEAPData = NULL;
    DWORD dwMachineAuthentication = 0;
    DWORD dwMachineAuthenticationType = 0;
    DWORD dwGuestAuthentication = 0;
    DWORD dwIEEE8021xMaxStart = 0;
    DWORD dwIEEE8021xStartPeriod = 0;
    DWORD dwIEEE8021xAuthPeriod = 0;
    DWORD dwIEEE8021xHeldPeriod = 0;
    DWORD dwDescriptionLen = 0;
    LPWSTR pszDescription = NULL;
    
    
    pNewWirelessPSData = (PWIRELESS_PS_DATA) AllocPolMem(
        sizeof(WIRELESS_PS_DATA)
        );
    if (!pNewWirelessPSData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    
    dwPSLen = pWirelessPSData->dwPSLen;
    pNewWirelessPSData->dwPSLen = dwPSLen;
    
    memcpy(SSID,pWirelessPSData->pszWirelessSSID,32*2);
    memcpy(pNewWirelessPSData->pszWirelessSSID,SSID,32*2);
    
    dwWirelessSSIDLen = pWirelessPSData->dwWirelessSSIDLen;
    pNewWirelessPSData->dwWirelessSSIDLen = dwWirelessSSIDLen;
    
    dwWepEnabled = pWirelessPSData->dwWepEnabled;
    pNewWirelessPSData->dwWepEnabled = dwWepEnabled;
    
    dwId = pWirelessPSData->dwId;
    pNewWirelessPSData->dwId = dwId;
    
    dwNetworkAuthentication = pWirelessPSData->dwNetworkAuthentication;
    pNewWirelessPSData->dwNetworkAuthentication = dwNetworkAuthentication;
    
    dwAutomaticKeyProvision = pWirelessPSData->dwAutomaticKeyProvision;
    pNewWirelessPSData->dwAutomaticKeyProvision = dwAutomaticKeyProvision;
    
    dwNetworkType = pWirelessPSData->dwNetworkType;
    pNewWirelessPSData->dwNetworkType = dwNetworkType;
    
    dwEnable8021x = pWirelessPSData->dwEnable8021x;
    pNewWirelessPSData->dwEnable8021x = dwEnable8021x;
    
    dw8021xMode = pWirelessPSData->dw8021xMode;
    pNewWirelessPSData->dw8021xMode = dw8021xMode;
    
    dwEapType = pWirelessPSData->dwEapType;
    pNewWirelessPSData->dwEapType = dwEapType;
    
    dwEAPDataLen = pWirelessPSData->dwEAPDataLen;
    pNewWirelessPSData->dwEAPDataLen = dwEAPDataLen;

    if (dwEAPDataLen && (pWirelessPSData->pbEAPData)) {
        pbEAPData = AllocPolMem(dwEAPDataLen);
        if (!pbEAPData) {
            dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
        }
        memcpy(pbEAPData, pWirelessPSData->pbEAPData, dwEAPDataLen);
    }
    
    pNewWirelessPSData->pbEAPData = pbEAPData;
    

    dwMachineAuthentication = pWirelessPSData->dwMachineAuthentication;
    pNewWirelessPSData->dwMachineAuthentication = dwMachineAuthentication;
    
    
    dwMachineAuthenticationType = 
        pWirelessPSData->dwMachineAuthenticationType;
    pNewWirelessPSData->dwMachineAuthenticationType = 
        dwMachineAuthenticationType;
    
    dwGuestAuthentication = pWirelessPSData->dwGuestAuthentication;
    pNewWirelessPSData->dwGuestAuthentication = dwGuestAuthentication;
    
    dwIEEE8021xMaxStart = pWirelessPSData->dwIEEE8021xMaxStart;
    pNewWirelessPSData->dwIEEE8021xMaxStart = dwIEEE8021xMaxStart;
    
    dwIEEE8021xStartPeriod = pWirelessPSData->dwIEEE8021xStartPeriod;
    pNewWirelessPSData->dwIEEE8021xStartPeriod = dwIEEE8021xStartPeriod;
    
    dwIEEE8021xAuthPeriod = pWirelessPSData->dwIEEE8021xAuthPeriod;
    pNewWirelessPSData->dwIEEE8021xAuthPeriod = dwIEEE8021xAuthPeriod;
    
    dwIEEE8021xHeldPeriod = pWirelessPSData->dwIEEE8021xHeldPeriod;
    pNewWirelessPSData->dwIEEE8021xHeldPeriod = dwIEEE8021xHeldPeriod;
    
    dwDescriptionLen = pWirelessPSData->dwDescriptionLen;
    pNewWirelessPSData->dwDescriptionLen = dwDescriptionLen;

    if ((pWirelessPSData->pszDescription) && *(pWirelessPSData->pszDescription)) {
        pszDescription = AllocPolStr(pWirelessPSData->pszDescription);
        if (!pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    pNewWirelessPSData->pszDescription = pszDescription;
    
    *ppWirelessPSData = pNewWirelessPSData;
    return(dwError);
    
error:
    FreeWirelessPSData(pNewWirelessPSData);
    return(dwError);
    
}

void
FreeMulWirelessPolicyData(
                          PWIRELESS_POLICY_DATA * ppWirelessPolicyData,
                          DWORD dwNumPolicyObjects
                          )
{
    DWORD i = 0;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    
    
    if (!ppWirelessPolicyData) {
        return;
        }
    
    for (i = 0; i < dwNumPolicyObjects; i++) {
        
        pWirelessPolicyData = *(ppWirelessPolicyData + i);
        
        if (pWirelessPolicyData) {
            FreeWirelessPolicyData(pWirelessPolicyData);
            }
        }
    
    FreePolMem(ppWirelessPolicyData);
    
    return;
    }

void
FreeWirelessPSData(
                   PWIRELESS_PS_DATA pWirelessPSData
                   )
{
    
    if (!pWirelessPSData)
        return;

    if (pWirelessPSData->pbEAPData) {
    	FreePolMem(pWirelessPSData->pbEAPData);
    }
    
    if (pWirelessPSData->pszDescription) {
        FreePolStr(pWirelessPSData->pszDescription);
        }
    
    FreePolMem(pWirelessPSData);
    return;
    }



void
FreeWirelessPolicyData(
                       PWIRELESS_POLICY_DATA pWirelessPolicyData
                       )
{
    DWORD i = 0;
    DWORD dwNumPSCount = 0;
    PWIRELESS_PS_DATA *ppWirelessPSDatas = NULL;
    PWIRELESS_PS_DATA pWirelessPSData = NULL;
    
    if (!pWirelessPolicyData)
        return;
    
    if (pWirelessPolicyData->pszWirelessName) {
        FreePolStr(pWirelessPolicyData->pszWirelessName);
        }

      if (pWirelessPolicyData->pszOldWirelessName) {
        FreePolStr(pWirelessPolicyData->pszOldWirelessName);
        }
    
    if (pWirelessPolicyData->pszDescription) {
        FreePolStr(pWirelessPolicyData->pszDescription);
        }
    
    ppWirelessPSDatas = pWirelessPolicyData->ppWirelessPSData;
    
    if (ppWirelessPSDatas) {
        dwNumPSCount = pWirelessPolicyData->dwNumPreferredSettings;
        
        for(i = 0; i < dwNumPSCount ; ++i) {
            
            pWirelessPSData = *(ppWirelessPSDatas+i);
            FreeWirelessPSData(pWirelessPSData);
            
            }
        
        FreePolMem(ppWirelessPSDatas);
        }

     if (pWirelessPolicyData->pRsopInfo) {
     FreeRsopInfo(
         pWirelessPolicyData->pRsopInfo
         );
    }
    
    FreePolMem(pWirelessPolicyData);
    return;
    
    }



void
FreeRsopInfo(
    PRSOP_INFO pRsopInfo
    )
{
    if (pRsopInfo)  {
        FreePolStr(pRsopInfo->pszCreationtime);
        FreePolStr(pRsopInfo->pszID);
        FreePolStr(pRsopInfo->pszName);
        FreePolStr(pRsopInfo->pszGPOID);
        FreePolStr(pRsopInfo->pszSOMID);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\utils.h ===
BOOL
HexStringToDword(
                 LPCWSTR lpsz,
                 DWORD * RetValue,
                 int cDigits,
                 WCHAR chDelim
                 );

BOOL
wUUIDFromString(
                LPCWSTR lpsz,
                LPGUID pguid
                );

BOOL
wGUIDFromString(
                LPCWSTR lpsz,
                LPGUID pguid
                );

DWORD
EnablePrivilege(
                LPCTSTR pszPrivilege
                );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\regstore.h ===
DWORD
OpenRegistryWIRELESSRootKey(
                         LPWSTR pszServerName,
                         LPWSTR pszWirelessRegRootContainer,
                         HKEY * phRegistryKey
                         );


DWORD
ReadPolicyObjectFromRegistry(
                             HKEY hRegistryKey,
                             LPWSTR pszPolicyDN,
                             LPWSTR pszWirelessRegRootContainer,
                             PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
                             );


DWORD
UnMarshallRegistryPolicyObject(
                               HKEY hRegistryKey,
                               LPWSTR pszWirelessRegRootContainer,
                               LPWSTR pszWirelessPolicyDN,
                               DWORD  dwNameType,
                               PWIRELESS_POLICY_OBJECT  * ppWirelessPolicyObject
                               );


void
FreeWirelessPolicyObject(
                      PWIRELESS_POLICY_OBJECT pWirelessPolicyObject
                      );


void
FreeWirelessPolicyObjects(
                       PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObjects,
                       DWORD dwNumPolicyObjects
                       );

DWORD
RegstoreQueryValue(
                   HKEY hRegKey,
                   LPWSTR pszValueName,
                   DWORD dwType,
                   LPBYTE * ppValueData,
                   LPDWORD pdwSize
                   );

#define  REG_RELATIVE_NAME          0
#define  REG_FULLY_QUALIFIED_NAME   1

VOID
FlushRegSaveKey(
                HKEY hRegistryKey
                );


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\procrule.h ===
typedef struct _spec_buffer{
    DWORD dwSize;
    LPBYTE pMem;
} SPEC_BUFFER, *PSPEC_BUFFER;


DWORD
UnmarshallWirelessPolicyObject(
                               PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                               DWORD dwStoreType,
                               PWIRELESS_POLICY_DATA * ppWirelessPolicyData
                               );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\structs.h ===
#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) {\
    goto error; \
    }

#define BAIL_ON_HRESULT_ERROR(hr) \
    if (FAILED(hr)) {\
    goto error; \
    }

#define BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError) \
{ \
    dwError = Win32FromWmiHresult(hr); \
    if (dwError) {  \
    goto error; \
    } \
}


typedef struct _WIRELESS_POLICY_OBJECT{
    LPWSTR pszWirelessOwnersReference;
    LPWSTR pszOldWirelessOwnersReferenceName;
    LPWSTR pszWirelessName;
    LPWSTR pszWirelessID;
    DWORD  dwWirelessDataType;
    LPBYTE pWirelessData;
    DWORD  dwWirelessDataLen;
    DWORD dwWhenChanged;
    LPWSTR pszDescription;
    PRSOP_INFO pRsopInfo;
}WIRELESS_POLICY_OBJECT, *PWIRELESS_POLICY_OBJECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\wmistore.h ===
DWORD
UnMarshallWMIPolicyObject(
                          IWbemClassObject *pWbemClassObject,
                          PWIRELESS_POLICY_OBJECT  * ppWirelessPolicyObject
                          );

DWORD
WMIstoreQueryValue(
                   IWbemClassObject *pWbemClassObject,
                   LPWSTR pszValueName,
                   DWORD dwType,
                   LPBYTE *ppValueData,
                   LPDWORD pdwSize
                   );

HRESULT
ReadPolicyObjectFromDirectoryEx(
                                LPWSTR pszMachineName,
                                LPWSTR pszPolicyDN,
                                BOOL   bDeepRead,
                                PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
                                );

HRESULT
WritePolicyObjectDirectoryToWMI(
                                IWbemServices *pWbemServices,
                                PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                                PGPO_INFO pGPOInfo
                                );

DWORD
CreateIWbemServices(
                    LPWSTR pszWirelessWMINamespace,
                    IWbemServices **ppWbemServices
                    );

DWORD
Win32FromWmiHresult(
                    HRESULT hr
                    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\regstore.c ===
#include "precomp.h"


DWORD
OpenRegistryWIRELESSRootKey(
                         LPWSTR pszServerName,
                         LPWSTR pszWirelessRegRootContainer,
                         HKEY * phRegistryKey
                         )
{
    DWORD dwError = 0;
    
    dwError = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        (LPCWSTR) pszWirelessRegRootContainer,
        0,
        KEY_ALL_ACCESS,
        phRegistryKey
        );
    
    BAIL_ON_WIN32_ERROR(dwError);
    
error:
    
    return(dwError);
}


DWORD
ReadPolicyObjectFromRegistry(
                             HKEY hRegistryKey,
                             LPWSTR pszPolicyDN,
                             LPWSTR pszWirelessRegRootContainer,
                             PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
                             )
{
    
    DWORD dwError = 0;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    
    
    dwError = UnMarshallRegistryPolicyObject(
        hRegistryKey,
        pszWirelessRegRootContainer,
        pszPolicyDN,
        REG_FULLY_QUALIFIED_NAME,
        &pWirelessPolicyObject
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    *ppWirelessPolicyObject = pWirelessPolicyObject;
    
cleanup:
    
    
    return(dwError);
    
error:
    
    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(
            pWirelessPolicyObject
            );
    }
    
    *ppWirelessPolicyObject = NULL;
    
    
    goto cleanup;
    
}

DWORD
UnMarshallRegistryPolicyObject(
                               HKEY hRegistryKey,
                               LPWSTR pszWirelessRegRootContainer,
                               LPWSTR pszWirelessPolicyDN,
                               DWORD  dwNameType,
                               PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
                               )
{
    
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwWirelessDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;
    
    DWORD i = 0;
    DWORD dwCount = 0;
    DWORD dwError = 0;
    LPWSTR pszTemp = NULL;
    LPWSTR pszString = NULL;
    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;
    
    
    if (!pszWirelessPolicyDN || !*pszWirelessPolicyDN) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (dwNameType == REG_FULLY_QUALIFIED_NAME) {
        dwRootPathLen =  wcslen(pszWirelessRegRootContainer);
        if (wcslen(pszWirelessPolicyDN) <= (dwRootPathLen+1)) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pszRelativeName = pszWirelessPolicyDN + dwRootPathLen + 1;
    }else {
        pszRelativeName = pszWirelessPolicyDN;
    }
    
    dwError = RegOpenKeyExW(
        hRegistryKey,
        pszRelativeName,
        0,
        KEY_ALL_ACCESS,
        &hRegKey
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pWirelessPolicyObject = (PWIRELESS_POLICY_OBJECT)AllocPolMem(
        sizeof(WIRELESS_POLICY_OBJECT)
        );
    if (!pWirelessPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    
    
    pWirelessPolicyObject->pszWirelessOwnersReference = AllocPolStr(
        pszWirelessPolicyDN
        );
    if (!pWirelessPolicyObject->pszWirelessOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    
    
    dwError = RegstoreQueryValue(
        hRegKey,
        L"WirelessName",
        REG_SZ,
        (LPBYTE *)&pWirelessPolicyObject->pszWirelessName,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    dwError = RegstoreQueryValue(
        hRegKey,
        L"description",
        REG_SZ,
        (LPBYTE *)&pWirelessPolicyObject->pszDescription,
        &dwSize
        );
    // BAIL_ON_WIN32_ERROR(dwError);
    
    
    dwError = RegstoreQueryValue(
        hRegKey,
        L"WirelessID",
        REG_SZ,
        (LPBYTE *)&pWirelessPolicyObject->pszWirelessID,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
        hRegKey,
        L"WirelessDataType",
        NULL,
        &dwType,
        (LPBYTE)&dwWirelessDataType,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pWirelessPolicyObject->dwWirelessDataType = dwWirelessDataType;
    
    
    dwError = RegstoreQueryValue(
        hRegKey,
        L"WirelessData",
        REG_BINARY,
        &pWirelessPolicyObject->pWirelessData,
        &pWirelessPolicyObject->dwWirelessDataLen
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    
    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
        hRegKey,
        L"whenChanged",
        NULL,
        &dwType,
        (LPBYTE)&dwWhenChanged,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pWirelessPolicyObject->dwWhenChanged = dwWhenChanged;
    
    *ppWirelessPolicyObject = pWirelessPolicyObject;
    
    
    if (hRegKey) {
        RegCloseKey(hRegKey);
    }
    
    
    
    return(dwError);
    
error:
    
    *ppWirelessPolicyObject = NULL;
    
    
    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyObject);
    }
    
    
    if (hRegKey) {
        RegCloseKey(hRegKey);
    }
    
    
    
    return(dwError);
}





DWORD
RegstoreQueryValue(
                   HKEY hRegKey,
                   LPWSTR pszValueName,
                   DWORD dwType,
                   LPBYTE * ppValueData,
                   LPDWORD pdwSize
                   )
{
    DWORD dwSize = 0;
    LPWSTR pszValueData = NULL;
    DWORD dwError = 0;
    LPBYTE pBuffer = NULL;
    LPWSTR pszBuf = NULL;
    
    
    dwError = RegQueryValueExW(
        hRegKey,
        pszValueName,
        NULL,
        &dwType,
        NULL,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    if (dwSize == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pBuffer = (LPBYTE)AllocPolMem(dwSize);
    if (!pBuffer) {
        
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    dwError = RegQueryValueExW(
        hRegKey,
        pszValueName,
        NULL,
        &dwType,
        pBuffer,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    
    
    switch (dwType) {
    case REG_SZ:
        pszBuf = (LPWSTR) pBuffer;
        if (!pszBuf || !*pszBuf) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;
        
    default:
        break;
    }
    
    *ppValueData = pBuffer;
    *pdwSize = dwSize;
    return(dwError);
    
error:
    
    if (pBuffer) {
        FreePolMem(pBuffer);
    }
    
    *ppValueData = NULL;
    *pdwSize = 0;
    return(dwError);
}


VOID
FlushRegSaveKey(
                HKEY hRegistryKey
                )
{
    DWORD dwError = 0;
    WCHAR lpszName[MAX_PATH];
    DWORD dwSize = 0;
    
    
    memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
    dwSize = MAX_PATH;
    
    while((RegEnumKeyExW(
        hRegistryKey,
        0,
        lpszName,
        &dwSize,
        NULL,
        NULL,
        NULL,
        NULL)) == ERROR_SUCCESS) {
        
        dwError = RegDeleteKeyW(
            hRegistryKey,
            lpszName
            );
        if (dwError != ERROR_SUCCESS) {
            break;
        }
        
        memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
        dwSize = MAX_PATH;
        
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\utils.c ===
#include "precomp.h"


//
// Taken from windows\wmi\mofcheck\mofcheck.c
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOL HexStringToDword(LPCWSTR lpsz, DWORD * RetValue,
                      int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;
    
    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }
    
    *RetValue = Value;
    
    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
    DWORD dw;
    
    if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
        return FALSE;
    lpsz += sizeof(DWORD)*2 + 1;
    
    if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
        return FALSE;
    lpsz += sizeof(WORD)*2 + 1;
    
    pguid->Data2 = (WORD)dw;
    
    if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
        return FALSE;
    lpsz += sizeof(WORD)*2 + 1;
    
    pguid->Data3 = (WORD)dw;
    
    if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;
    lpsz += sizeof(BYTE)*2;
    
    pguid->Data4[0] = (BYTE)dw;
    if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
        return FALSE;
    lpsz += sizeof(BYTE)*2+1;
    
    pguid->Data4[1] = (BYTE)dw;
    
    if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;
    lpsz += sizeof(BYTE)*2;
    
    pguid->Data4[2] = (BYTE)dw;
    
    if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;
    lpsz += sizeof(BYTE)*2;
    
    pguid->Data4[3] = (BYTE)dw;
    
    if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;
    lpsz += sizeof(BYTE)*2;
    
    pguid->Data4[4] = (BYTE)dw;
    
    if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;
    lpsz += sizeof(BYTE)*2;
    
    pguid->Data4[5] = (BYTE)dw;
    
    if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;
    lpsz += sizeof(BYTE)*2;
    
    pguid->Data4[6] = (BYTE)dw;
    if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;
    lpsz += sizeof(BYTE)*2;
    
    pguid->Data4[7] = (BYTE)dw;
    
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
    DWORD dw;
    
    if (*lpsz == '{' )
        lpsz++;
    
    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;
    
    lpsz +=36;
    
    if (*lpsz == '}' )
        lpsz++;
    
    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
        return FALSE;
    }
    
    return TRUE;
}


DWORD
EnablePrivilege(
                LPCTSTR pszPrivilege
                )
{
    DWORD dwError = 0;
    BOOL bStatus = FALSE;
    HANDLE hTokenHandle = NULL;
    TOKEN_PRIVILEGES NewState;
    TOKEN_PRIVILEGES PreviousState;
    DWORD dwReturnLength = 0;
    
    
    bStatus = OpenThreadToken(
        GetCurrentThread(),
        TOKEN_ALL_ACCESS,
        TRUE,
        &hTokenHandle
        );
    if (!bStatus) {
        bStatus = OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_ALL_ACCESS,
            &hTokenHandle
            );
        if (!bStatus) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    NewState.PrivilegeCount = 1;
    NewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    
    bStatus = LookupPrivilegeValue(
        NULL,
        pszPrivilege,
        &NewState.Privileges[0].Luid
        );
    if (!bStatus) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    bStatus = AdjustTokenPrivileges(
        hTokenHandle,
        FALSE,
        &NewState,
        sizeof(PreviousState),
        &PreviousState,
        &dwReturnLength
        );
    if (!bStatus) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
error:
    
    if (hTokenHandle) {
        CloseHandle(hTokenHandle);
    }
    
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wastore\wmistore.c ===
#include "precomp.h"

LPWSTR gpszWirelessWMINamespace = L"root\\rsop\\computer";

DWORD
Win32FromWmiHresult(
                    HRESULT hr
                    )
{
    if (FAILED(hr)) {
        switch (hr) {
        case WBEM_E_ACCESS_DENIED:
            return ERROR_ACCESS_DENIED;
            
        case REGDB_E_CLASSNOTREG:
        case CLASS_E_NOAGGREGATION:
        case E_NOINTERFACE:
        case WBEM_E_INVALID_NAMESPACE:
        case WBEM_E_INVALID_PARAMETER:
        case WBEM_E_NOT_FOUND:
        case WBEM_E_INVALID_CLASS:
        case WBEM_E_INVALID_OBJECT_PATH:
            return ERROR_INVALID_PARAMETER;
            
        case WBEM_E_OUT_OF_MEMORY:
            return ERROR_OUTOFMEMORY;
            
        case WBEM_E_TRANSPORT_FAILURE:
            return RPC_S_CALL_FAILED;
            
        case WBEM_E_FAILED:
        default:
            return ERROR_WMI_TRY_AGAIN;
        }
    } else {
        return ERROR_SUCCESS;
    }
}

DWORD
UnMarshallWMIPolicyObject(
                          IWbemClassObject *pWbemClassObject,
                          PWIRELESS_POLICY_OBJECT  * ppWirelessPolicyObject
                          )
{
    
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwWirelessDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;
    
    DWORD i = 0;
    DWORD dwCount = 0;
    DWORD dwError = 0;
    HRESULT hr = S_OK;
    LPWSTR pszString = NULL;
    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;
    
    
    ////start
    VARIANT var; //contains pszWirelessPolicyDN
    
    VariantInit(&var);
    
    hr = IWbemClassObject_Get(pWbemClassObject,
        L"id",
        0,
        &var,
        0,
        0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    
    pWirelessPolicyObject = (PWIRELESS_POLICY_OBJECT)AllocPolMem(sizeof(WIRELESS_POLICY_OBJECT));
    if (!pWirelessPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pWirelessPolicyObject->pszWirelessOwnersReference = AllocPolStr((LPWSTR)var.bstrVal);
    VariantClear(&var);
    if (!pWirelessPolicyObject->pszWirelessOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pWirelessPolicyObject->pRsopInfo = (PRSOP_INFO)AllocPolMem(sizeof(RSOP_INFO));
    if (!pWirelessPolicyObject->pRsopInfo) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    dwError = WMIstoreQueryValue(pWbemClassObject,
        L"creationtime",
        VT_BSTR,
        (LPBYTE *)&pWirelessPolicyObject->pRsopInfo->pszCreationtime,
        &dwSize);
    //BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = WMIstoreQueryValue(pWbemClassObject,
        L"GPOID",
        VT_BSTR,
        (LPBYTE *)&pWirelessPolicyObject->pRsopInfo->pszGPOID,
        &dwSize);
    //BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = WMIstoreQueryValue(pWbemClassObject,
        L"id",
        VT_BSTR,
        (LPBYTE *)&pWirelessPolicyObject->pRsopInfo->pszID,
        &dwSize);
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = WMIstoreQueryValue(pWbemClassObject,
        L"name",
        VT_BSTR,
        (LPBYTE *)&pWirelessPolicyObject->pRsopInfo->pszName,
        &dwSize);
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = WMIstoreQueryValue(pWbemClassObject,
        L"SOMID",
        VT_BSTR,
        (LPBYTE *)&pWirelessPolicyObject->pRsopInfo->pszSOMID,
        &dwSize);
    //BAIL_ON_WIN32_ERROR(dwError);
    
    hr = IWbemClassObject_Get(pWbemClassObject,
        L"precedence",
        0,
        &var,
        0,
        0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    pWirelessPolicyObject->pRsopInfo->uiPrecedence = var.lVal;
    
    dwError = WMIstoreQueryValue(pWbemClassObject,
        L"msieee80211Name",
        VT_BSTR,
        (LPBYTE *)&pWirelessPolicyObject->pszWirelessName,
        &dwSize);
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = WMIstoreQueryValue(pWbemClassObject,
        L"description",
        VT_BSTR,
        (LPBYTE *)&pWirelessPolicyObject->pszDescription,
        &dwSize);
    // BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = WMIstoreQueryValue(pWbemClassObject,
        L"msieee80211ID",
        VT_BSTR,
        (LPBYTE *)&pWirelessPolicyObject->pszWirelessID,
        &dwSize);
    BAIL_ON_WIN32_ERROR(dwError);
    
    hr = IWbemClassObject_Get(pWbemClassObject,
        L"msieee80211DataType",
        0,
        &var,
        0,
        0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    dwWirelessDataType = var.lVal;
    
    pWirelessPolicyObject->dwWirelessDataType = dwWirelessDataType;
    
    dwError = WMIstoreQueryValue(pWbemClassObject,
        L"msieee80211Data",
        VT_ARRAY|VT_UI1,
        &pWirelessPolicyObject->pWirelessData,
        &pWirelessPolicyObject->dwWirelessDataLen);
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    
    hr = IWbemClassObject_Get(pWbemClassObject,
        L"whenChanged",
        0,
        &var,
        0,
        0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    dwWhenChanged = var.lVal;
    
    pWirelessPolicyObject->dwWhenChanged = dwWhenChanged;
    
    *ppWirelessPolicyObject = pWirelessPolicyObject;
    
cleanup:
    
    return(dwError);
    
error:
    
    
    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyObject);
    }
    
    *ppWirelessPolicyObject = NULL;
    
    goto cleanup;
    
}


DWORD
WMIstoreQueryValue(
                   IWbemClassObject *pWbemClassObject,
                   LPWSTR pszValueName,
                   DWORD dwType,
                   LPBYTE *ppValueData,
                   LPDWORD pdwSize
                   )
{
    DWORD dwSize = 0;
    LPWSTR pszValueData = NULL;
    DWORD dwError = 0;
    HRESULT hr = S_OK;
    LPBYTE pBuffer = NULL;
    LPWSTR pszBuf = NULL;
    
    SAFEARRAY *pSafeArray = NULL;
    VARIANT var;
    DWORD i = 0;
    DWORD dw = 0;
    LPWSTR pszTmp = NULL;
    LPWSTR pszString = NULL;
    LPWSTR pMem = NULL;
    LPWSTR *ppszTmp = NULL;
    long lUbound = 0;
    DWORD dwCount = 0;
    LPBYTE pdw = NULL;
    BSTR HUGEP *pbstrTmp = NULL;
    BYTE HUGEP *pbyteTmp = NULL;
    
    
    VariantInit(&var);
    
    if(!pWbemClassObject) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    hr = IWbemClassObject_Get(pWbemClassObject,
        pszValueName,
        0,
        &var,
        0,
        0);
    if(hr == WBEM_E_NOT_FOUND) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    ////sanity check
    if(dwType != var.vt) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    switch(dwType) {
    case VT_BSTR:
        pszTmp = var.bstrVal;
        dwSize = wcslen(pszTmp)*sizeof(WCHAR);
        pBuffer = (LPBYTE)AllocPolStr(pszTmp);
        if (!pBuffer) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;
    case (VT_ARRAY|VT_UI1):
        pSafeArray = var.parray;
        if(!pSafeArray) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        hr = SafeArrayGetUBound(
            pSafeArray,
            1,
            &lUbound
            );
       BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

        
        dwSize = lUbound+1;
        if (dwSize == 0) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        pBuffer = (LPBYTE)AllocPolMem(dwSize);
        if (!pBuffer) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        for(i = 0; i < dwSize; i++) {
            hr = SafeArrayGetElement(pSafeArray, (long *)&i, &pBuffer[i]);
            BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
        }
        break;
    case (VT_ARRAY|VT_BSTR):
        pSafeArray = var.parray;
        if(!pSafeArray) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        hr = SafeArrayGetUBound(
            pSafeArray,
            1,
            &lUbound
            );
        BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
        
        dwCount = lUbound+1;
        if (dwCount == 0) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        ppszTmp = (LPWSTR *)AllocPolMem(
            sizeof(LPWSTR)*dwCount
            );
        if (!ppszTmp) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        hr = SafeArrayAccessData(
            pSafeArray,
            (void HUGEP**)&pbstrTmp
            );
       BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
        
        for(i = 0; i < dwCount; i++) {
            pszTmp = pbstrTmp[i];
            ppszTmp[i] = AllocPolStr(pszTmp);
            if (!ppszTmp[i]) {
                dwError = ERROR_OUTOFMEMORY;
                BAIL_ON_WIN32_ERROR(dwError);
            }
        }
        SafeArrayUnaccessData(pSafeArray);
        
        //ppszTmp => string array
        
        for(i = 0; i < dwCount; i++) {
            dwSize += wcslen(ppszTmp[i])+1;
        }
        dwSize++;
        
        pMem = (LPWSTR)AllocPolMem(sizeof(WCHAR)*dwSize);
        if (!pMem) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        //adjust dwSize to byte size
        dwSize *= sizeof(WCHAR);
        
        pszString = pMem;
        
        for(i = 0; i < dwCount; i++) {
            memcpy(pszString, ppszTmp[i], wcslen(ppszTmp[i])*sizeof(WCHAR));
            pszString += wcslen(pszString)+1;
        }
        pBuffer = (LPBYTE)pMem;
        break;
    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;
    }
    
    switch(dwType) {
    case VT_BSTR:
        pszBuf = (LPWSTR)pBuffer;
        if (!pszBuf || !*pszBuf) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;
    default:
        break;
    }
    
    *ppValueData = pBuffer;
    *pdwSize = dwSize;
    
    VariantClear(&var);
    
cleanup:
    
    if(ppszTmp) {
        FreePolMem(ppszTmp);
    }
    
    return(dwError);
    
error:
    
    if (pBuffer) {
        FreePolMem(pBuffer);
    }
    
    *ppValueData = NULL;
    *pdwSize = 0;
    
    goto cleanup;
}


HRESULT
ReadPolicyObjectFromDirectoryEx(
                                LPWSTR pszMachineName,
                                LPWSTR pszPolicyDN,
                                BOOL   bDeepRead,
                                PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
                                )
{
    DWORD dwError = 0;
    HLDAP hLdapBindHandle = NULL;
    LPWSTR pszDefaultDirectory = NULL;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    
    
    if (!pszMachineName || !*pszMachineName) {
        dwError = ComputeDefaultDirectory(
            &pszDefaultDirectory
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = OpenDirectoryServerHandle(
            pszDefaultDirectory,
            389,
            &hLdapBindHandle
            );
        BAIL_ON_WIN32_ERROR(dwError);
    } else {
        dwError = OpenDirectoryServerHandle(
            pszMachineName,
            389,
            &hLdapBindHandle
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    dwError = ReadPolicyObjectFromDirectory(
        hLdapBindHandle,
        pszPolicyDN,
        &pWirelessPolicyObject
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    *ppWirelessPolicyObject = pWirelessPolicyObject;
    
cleanup:
    
    if (pszDefaultDirectory) {
        FreePolStr(pszDefaultDirectory);
    }
    
    if (hLdapBindHandle) {
        CloseDirectoryServerHandle(hLdapBindHandle);
    }
    
    return (HRESULT_FROM_WIN32(dwError));
    
error:
    
    *ppWirelessPolicyObject = NULL;
    
    goto cleanup;
    
}


HRESULT
WritePolicyObjectDirectoryToWMI(
                                IWbemServices *pWbemServices,
                                PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                                PGPO_INFO pGPOInfo
                                )
{
    HRESULT hr = S_OK;
    PWIRELESS_POLICY_OBJECT pWirelessWMIPolicyObject = NULL;
    
    //
    // Create a copy of the directory policy in WMI terms
    //
    hr = CloneDirectoryPolicyObjectEx(
        pWirelessPolicyObject,
        &pWirelessWMIPolicyObject
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    //
    // Write the WMI policy
    //
    
    hr = PersistWMIObject(
        pWbemServices,
        pWirelessWMIPolicyObject,
        pGPOInfo
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
cleanup:
    
    if (pWirelessWMIPolicyObject) {
        FreeWirelessPolicyObject(
            pWirelessWMIPolicyObject
            );
    }
    
    return(hr);
    
error:
    
    goto cleanup;
    
}


DWORD
CreateIWbemServices(
                    LPWSTR pszWirelessWMINamespace,
                    IWbemServices **ppWbemServices
                    )
{
    DWORD dwError = 0;
    HRESULT hr = S_OK;
    IWbemLocator *pWbemLocator = NULL;
    LPWSTR pszWirelessWMIPath = NULL;
    BSTR bstrWirelessWMIPath = NULL;
    
    
    
    if(!pszWirelessWMINamespace || !*pszWirelessWMINamespace) {
        pszWirelessWMIPath = gpszWirelessWMINamespace;
    } else {
        pszWirelessWMIPath = pszWirelessWMINamespace;
    }
    
    hr = CoCreateInstance(
        &CLSID_WbemLocator,
        NULL,
        CLSCTX_INPROC_SERVER,
        &IID_IWbemLocator,
        &pWbemLocator
        );
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    bstrWirelessWMIPath = SysAllocString(pszWirelessWMIPath);
    if(!bstrWirelessWMIPath) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    hr = IWbemLocator_ConnectServer(
        pWbemLocator,
        bstrWirelessWMIPath,
        NULL,
        NULL,
        NULL,
        0,
        NULL,
        NULL,
        ppWbemServices
        );
    SysFreeString(bstrWirelessWMIPath);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    if(pWbemLocator)
        IWbemLocator_Release(pWbemLocator);
    
error:
    
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\eapolpol.h ===
DWORD
ConvertWirelessPolicyDataToEAPOLList(
    IN WIRELESS_POLICY_DATA * pWirelessData, 
    OUT PEAPOL_POLICY_LIST *ppEAPOLList
    );

DWORD
ConvertWirelessPSDataToEAPOLData(
    IN WIRELESS_PS_DATA * pWirelessData, 
    IN OUT EAPOL_POLICY_DATA * pEAPOLData
    );

VOID
FreeEAPOLList (
    IN   	PEAPOL_POLICY_LIST      pEAPOLList
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\init.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    init.h

Abstract:

    This module contains all of the code prototypes
    to initialize the variables for the wifiPOL Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#define WIRELESS_NEW_DS_POLICY_EVENT L"WIRELESS_POLICY_CHANGE_EVENT"

#define DEFAULT_DS_CONNECTIVITY_CHECK 60 // (minutes).


#ifdef __cplusplus
extern "C" {
#endif


DWORD
InitSPDThruRegistry(
    );


DWORD
InitSPDGlobals(
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\eapolpol.c ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:
    
    eapolpol.c


Abstract:

    The module deals with functions related to communication group policy
    settings to EAPOL module


Revision History:

    November 19 2001, Created

--*/

#include    "precomp.h"

DWORD
ConvertWirelessPSDataToEAPOLData (
        IN      WIRELESS_PS_DATA        *pWirelessData,
        IN OUT  EAPOL_POLICY_DATA       *pEAPOLData
        )
{
    DWORD   dwRetCode = NO_ERROR;
    DWORD   dwSSIDSize = 0;
    WCHAR    pszTempSSID[33];
    BYTE  pszOutSSID[33];

    
    do
    {
        if (pWirelessData->dwWirelessSSIDLen != 0)
        {

            wcsncpy(pszTempSSID, pWirelessData->pszWirelessSSID, 32);
     	     pszTempSSID[32] = L'\0';

            dwSSIDSize = WideCharToMultiByte (
                        CP_ACP,
                        0,
                        pszTempSSID,    //pWirelessData->pszWirelessSSID,
                        -1,                    // pWirelessData->dwWirelessSSIDLen+1,
                        pszOutSSID, 
                        MAX_SSID_LEN +1 ,
                        NULL,
                        NULL);

            if (dwSSIDSize == 0) 
            {
                dwRetCode = GetLastError();
                break;
            }
            
            memcpy(pEAPOLData->pbWirelessSSID,  pszOutSSID, 32);
            
        }

        pEAPOLData->dwWirelessSSIDLen = dwSSIDSize-1; 
        pEAPOLData->dwEnable8021x = pWirelessData->dwEnable8021x;
        pEAPOLData->dw8021xMode = pWirelessData->dw8021xMode;
        pEAPOLData->dwEAPType = pWirelessData->dwEapType;
        if (pWirelessData->dwEAPDataLen != 0)
        {
            pEAPOLData->pbEAPData = AllocSPDMem(pWirelessData->dwEAPDataLen);
            if (!pEAPOLData->pbEAPData) {
                dwRetCode = GetLastError();
                break;
            }
        }
        memcpy (pEAPOLData->pbEAPData, pWirelessData->pbEAPData, pWirelessData->dwEAPDataLen);
        pEAPOLData->dwEAPDataLen = pWirelessData->dwEAPDataLen;
        pEAPOLData->dwMachineAuthentication = pWirelessData->dwMachineAuthentication;
        pEAPOLData->dwMachineAuthenticationType = pWirelessData->dwMachineAuthenticationType;
        pEAPOLData->dwGuestAuthentication = pWirelessData->dwGuestAuthentication;
        pEAPOLData->dwIEEE8021xMaxStart = pWirelessData->dwIEEE8021xMaxStart;
        pEAPOLData->dwIEEE8021xStartPeriod = pWirelessData->dwIEEE8021xStartPeriod;
        pEAPOLData->dwIEEE8021xAuthPeriod = pWirelessData->dwIEEE8021xAuthPeriod;
        pEAPOLData->dwIEEE8021xHeldPeriod = pWirelessData->dwIEEE8021xHeldPeriod;
    }
    
    while (FALSE);
    return dwRetCode;
}


//
// If Policy Engine is calling into EAPOL, pEAPOLList will be LocalFree by
// PolicyEngine, after it returns from calling into EAPOL.
// If Policy Engine is called by EAPOL, pEAPOLList will be LocalFree by
// EAPOL
//

DWORD
ConvertWirelessPolicyDataToEAPOLList (
        IN      WIRELESS_POLICY_DATA    *pWirelessData,
        OUT   	PEAPOL_POLICY_LIST      *ppEAPOLList
        )
{
    DWORD   dwIndex = 0;
    EAPOL_POLICY_DATA   *pEAPOLData = NULL;
    EAPOL_POLICY_LIST	*pEAPOLList = NULL;
    DWORD   dwRetCode = NO_ERROR;
    do
    {


       if (!pWirelessData) {
            pEAPOLList = AllocSPDMem(sizeof(EAPOL_POLICY_LIST));

            if (!pEAPOLList) {
                dwRetCode = GetLastError();
                break;
            }
            break;
       }

        pEAPOLList = AllocSPDMem(sizeof(EAPOL_POLICY_LIST)+ 
            pWirelessData->dwNumPreferredSettings*sizeof(EAPOL_POLICY_DATA));

        if (!pEAPOLList) {
            dwRetCode = GetLastError();
            break;
        }

        pEAPOLList->dwNumberOfItems = pWirelessData->dwNumPreferredSettings;
        for (dwIndex=0; dwIndex< pWirelessData->dwNumPreferredSettings; dwIndex++)
        {
            pEAPOLData = &(pEAPOLList->EAPOLPolicy[dwIndex]);
            dwRetCode = ConvertWirelessPSDataToEAPOLData (
                            pWirelessData->ppWirelessPSData[dwIndex],
                            pEAPOLData
                            );
            if (dwRetCode != NO_ERROR)
            {
                break;
            }
        }

    }
    while (FALSE);

    if (dwRetCode) {
    	if (pEAPOLList) {
            for (dwIndex = 0; dwIndex < pWirelessData->dwNumPreferredSettings; dwIndex++)
            {
                pEAPOLData = &(pEAPOLList->EAPOLPolicy[dwIndex]);
                if (pEAPOLData->pbEAPData)
                {
                    FreeSPDMem(pEAPOLData->pbEAPData);
                }
            }
    	    FreeSPDMem(pEAPOLList);
            pEAPOLList = NULL;
    	}
    }

    *ppEAPOLList = pEAPOLList;

    return dwRetCode;

}


VOID
FreeEAPOLList (
        IN   	PEAPOL_POLICY_LIST      pEAPOLList
        )
{
    DWORD   dwIndex = 0;
    PEAPOL_POLICY_DATA   pEAPOLData = NULL;

    if (pEAPOLList) {
        for (dwIndex = 0; dwIndex < pEAPOLList->dwNumberOfItems; dwIndex++)
        {
            pEAPOLData = &(pEAPOLList->EAPOLPolicy[dwIndex]);
            if (pEAPOLData->pbEAPData)
            {
                FreeSPDMem(pEAPOLData->pbEAPData);
            }
        }
        FreeSPDMem(pEAPOLList);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\externs.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    externs.h

Abstract:

    Holds externs for global variables.

Author:

    abhisheV    30-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif



//
// Policy Agent Store specific globals.
//

extern WIRELESS_POLICY_STATE gWirelessPolicyState;

extern PWIRELESS_POLICY_STATE gpWirelessPolicyState;

extern DWORD gCurrentPollingInterval;

extern DWORD gDefaultPollingInterval;

extern LPWSTR gpszWirelessDSPolicyKey;

extern LPWSTR gpszWirelessCachePolicyKey;

extern LPWSTR gpszLocPolicyAgent;

extern DWORD gdwDSConnectivityCheck;

extern HANDLE ghNewDSPolicyEvent;

extern HANDLE ghForcedPolicyReloadEvent;

extern HANDLE ghPolicyChangeNotifyEvent;

extern HANDLE ghPolicyEngineStopEvent;

extern HANDLE ghReApplyPolicy8021x;

extern DWORD gdwPolicyLoopStarted;

extern DWORD gdwWirelessPolicyEngineInited;






#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\memory.c ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions for all spooler
    components

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
//#include "oledsdbg.h"

#define SPDAssert(x)    NULL

#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((DWORD)addr &= ~1))

#define DWORD_ALIGN_UP(size) ((size+3)&~3)


#if DBG


DWORD dwMemoryLog = 0;

#define MAXDEPTH 10

typedef struct _SPDMEMTAG {
    DWORD Tag ;
    DWORD Size ;
    PVOID pvBackTrace[MAXDEPTH+1];
    LPSTR pszSymbol[MAXDEPTH+1];
    DWORD uDepth;
    LIST_ENTRY List ;
} SPDMEMTAG, *PSPDMEMTAG ;

LIST_ENTRY       SPDMemList ;
DWORD            SPDMemCount ;
CRITICAL_SECTION SPDMemCritSect ;

/*++

Routine Description:

    This function initializes the SPD mem tracking code. Must be call
    during DLL load an ONLY during DLL load.

Arguments:

    None

Return Value:

    None.

--*/
VOID InitSPDMem(
    VOID
)
{
    InitializeCriticalSection(&SPDMemCritSect) ;
    InitializeListHead(&SPDMemList) ;
    SPDMemCount = 0 ;
}

/*++

Routine Description:

    This function asserts that the mem list is empty on exit.

Arguments:

    None

Return Value:

    None.

--*/
VOID AssertSPDMemLeaks(
    VOID
)
{
    SPDAssert(IsListEmpty(&SPDMemList)) ;
}

#endif

LPVOID
AllocSPDMem(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
    LPVOID pMem = NULL;

    pMem = LocalAlloc(LPTR, cb);

    if (pMem) {
        memset((LPBYTE) pMem, 0, cb);
    }
    return (pMem);
}

BOOL
FreeSPDMem(
   LPVOID pMem
)
{
    return(LocalFree(pMem) == NULL);
}

LPVOID
ReallocSPDMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=AllocSPDMem(cbNew);

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        FreeSPDMem(pOldMem);
    }

    return pNewMem;
}

LPWSTR
AllocSPDStr(
    LPWSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   LPWSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = (LPWSTR)AllocSPDMem( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) ))
      wcscpy(pMem, pStr);

   return pMem;
}

BOOL
FreeSPDStr(
   LPWSTR pStr
)
{
   return pStr ? FreeSPDMem(pStr)
               : FALSE;
}

BOOL
ReallocSPDStr(
   LPWSTR *ppStr,
   LPWSTR pStr
)
{
   FreeSPDStr(*ppStr);
   *ppStr=AllocSPDStr(pStr);

   return TRUE;
}

DWORD
AllocateSPDMemory(
    DWORD cb,
    LPVOID * ppMem
    )
{
    DWORD dwError = 0;

    LPBYTE pMem = NULL;

    pMem = AllocSPDMem(cb);

    if (!pMem) {
        dwError = GetLastError();
    }

    *ppMem = pMem;

    return(dwError);
}

void
FreeSPDMemory(
    LPVOID pMem
    )
{
    if (pMem) {
        FreeSPDMem(pMem);
    }

    return;
}


DWORD
AllocateSPDString(
    LPWSTR pszString,
    LPWSTR * ppszNewString
    )
{
    LPWSTR pszNewString = NULL;
    DWORD dwError = 0;

    pszNewString = AllocSPDStr(pszString);

    if (!pszNewString) {
        dwError = GetLastError();
    }

    *ppszNewString = pszNewString;

    return(dwError);
}

void
FreeSPDString(
    LPWSTR pszString
    )
{
    if (pszString) {
        FreeSPDStr(pszString);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

LPVOID
AllocSPDMem(
    DWORD cb
);

BOOL
FreeSPDMem(
   LPVOID pMem
);

LPVOID
ReallocSPDMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

LPWSTR
AllocSPDStr(
    LPWSTR pStr
);

BOOL
FreeSPDStr(
   LPWSTR pStr
);


BOOL
ReallocSPDStr(
   LPWSTR *ppStr,
   LPWSTR pStr
);

DWORD
AllocateSPDMemory(
    DWORD cb,
    LPVOID * ppMem
    );

void
FreeSPDMemory(
    LPVOID pMem
    );

DWORD
AllocateSPDString(
    LPWSTR pszString,
    LPWSTR * ppszNewString
    );

void
FreeSPDString(
    LPWSTR pszString
    );


#if DBG

extern LIST_ENTRY SPDMemList ;

extern CRITICAL_SECTION SPDMemCritSect ;

VOID InitSPDMem(
    VOID
    ) ;

VOID AssertSPDMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();


#else

#define InitSPDMem()
#define AssertSPDMemLeaks()

#define DumpMemoryTracker()



#endif


#ifdef __cplusplus
}
#endif

/*
inline void * _CRTAPI1
operator new(size_t size)
{
    return AllocSPDMem(size);
}

inline void  _CRTAPI1
operator delete(void * pv)
{
    FreeSPDMem(pv);
}*/


#endif // _MEMORY_H_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\globals.c ===
/*++


Copyright (c) 1999 Microsoft Corporation


Module Name:

    globals.c

Abstract:

    Holds global variable declarations.

Author:

    abhisheV    30-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"

/*
BOOL                        gbSPDRPCServerUp;

HANDLE                      ghServiceStopEvent;

CRITICAL_SECTION            gcServerListenSection;

DWORD                       gdwServersListening;

BOOL                        gbServerListenSection;


BOOL                        gbwsaStarted;

SOCKET                      gIfChangeEventSocket;

HANDLE                      ghIfChangeEvent;

HANDLE                      ghOverlapEvent;

WSAOVERLAPPED               gwsaOverlapped;

WSADATA                     gwsaData;


 
CRITICAL_SECTION            gcSPDSection;

BOOL                        gbSPDSection;
*/
 
//
// Policy Agent Store specific globals.
//

WIRELESS_POLICY_STATE gWirelessPolicyState;

PWIRELESS_POLICY_STATE gpWirelessPolicyState;

DWORD gCurrentPollingInterval;

DWORD gDefaultPollingInterval;

LPWSTR gpszWirelessDSPolicyKey;

LPWSTR gpszWirelessCachePolicyKey;

LPWSTR gpszLocPolicyAgent;

DWORD gdwDSConnectivityCheck;

HANDLE ghNewDSPolicyEvent;

HANDLE ghForcedPolicyReloadEvent;

HANDLE ghPolicyChangeNotifyEvent;
 
HANDLE ghPolicyEngineStopEvent;

HANDLE ghReApplyPolicy8021x = NULL;

DWORD gdwPolicyLoopStarted = 0;

DWORD gdwWirelessPolicyEngineInited = 0;
 

//PSECURITY_DESCRIPTOR gpSPDSD;

BOOL gbLoadingPersistence;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\loopmgr.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    loopmgr.c

Abstract:

    This module contains all of the code to drive the
    Loop Manager of Wireless Policy .

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


enum {
    //SERVICE_STOP_EVENT = 0,
    //INTERFACE_CHANGE_EVENT,
    //NEW_LOCAL_POLICY_EVENT,
    NEW_DS_POLICY_EVENT,
    FORCED_POLICY_RELOAD_EVENT,
    POLICY_ENGINE_STOP_EVENT,
    REAPPLY_POLICY_801X,
    WAIT_EVENT_COUNT
};



DWORD
ServiceStart(LPVOID lparam
    )
{
    DWORD dwError = 0;
    HANDLE hWaitForEvents[WAIT_EVENT_COUNT];
    BOOL bDoneWaiting = FALSE;
    DWORD dwWaitMilliseconds = 0;
    DWORD dwStatus = 0;
    time_t LastTimeOutTime = 0;

    /* Check for DS Policy Now */

    _WirelessDbg(TRC_TRACK, "Updating with DS Policy ");
    
    
    OnPolicyChanged(
                       gpWirelessPolicyState
                       );


    hWaitForEvents[NEW_DS_POLICY_EVENT] = ghNewDSPolicyEvent;
    hWaitForEvents[FORCED_POLICY_RELOAD_EVENT] = ghForcedPolicyReloadEvent;
    hWaitForEvents[POLICY_ENGINE_STOP_EVENT] = ghPolicyEngineStopEvent;
    hWaitForEvents[REAPPLY_POLICY_801X] = ghReApplyPolicy8021x;


    ComputeRelativePollingTime(
        LastTimeOutTime,
        TRUE,
        &dwWaitMilliseconds
        );


    time(&LastTimeOutTime);
    
    _WirelessDbg(TRC_TRACK, "Timeout period is %d ",dwWaitMilliseconds); 
    
    
    while (!bDoneWaiting) {

        gdwPolicyLoopStarted = 1;

        dwStatus = WaitForMultipleObjects(
                       WAIT_EVENT_COUNT,
                       hWaitForEvents,
                       FALSE,
                       dwWaitMilliseconds
                       );

        /*
        PADeleteInUsePolicies();
        */
        
        switch (dwStatus) {

       
        case POLICY_ENGINE_STOP_EVENT:

            dwError = ERROR_SUCCESS;
            bDoneWaiting = TRUE;
            _WirelessDbg(TRC_TRACK, "Policy Engine Stopping ");
            
            break;


        case REAPPLY_POLICY_801X:

            _WirelessDbg(TRC_TRACK, "ReApplying  the 8021X Policy  ");
            
            // Appropriate call for 8021x policy addition.
            if (gpWirelessPolicyState->dwCurrentState != POLL_STATE_INITIAL) {

                AddEapolPolicy(gpWirelessPolicyState->pWirelessPolicyData);
            }
	    ResetEvent(ghReApplyPolicy8021x);

            break;


        case NEW_DS_POLICY_EVENT:

            _WirelessDbg(TRC_TRACK, "Got a new DS policy event ");
            
            _WirelessDbg(TRC_NOTIF, "DBASE:Wireless Policy - Group Policy indication from WinLogon  ");
            
            
            ResetEvent(ghNewDSPolicyEvent);
            (VOID) OnPolicyChanged(
                       gpWirelessPolicyState
                       );
            break;

        case FORCED_POLICY_RELOAD_EVENT:

            ResetEvent(ghForcedPolicyReloadEvent);
            (VOID) OnPolicyChanged(
                       gpWirelessPolicyState

            );
            break;
 

        case WAIT_TIMEOUT:

            time(&LastTimeOutTime);
            _WirelessDbg(TRC_TRACK, "Timed out ");
            
            
            (VOID) OnPolicyPoll(
                       gpWirelessPolicyState
                       );
            break;

        case WAIT_FAILED:

            dwError = GetLastError();
            bDoneWaiting = TRUE;
            break;

        default:

            dwError = ERROR_INVALID_EVENT_COUNT;
            bDoneWaiting = TRUE;
            break;

        }

        ComputeRelativePollingTime(
            LastTimeOutTime,
            FALSE,
            &dwWaitMilliseconds
            );

    }



    return (dwError);
}


VOID
ComputeRelativePollingTime(
    time_t LastTimeOutTime,
    BOOL bInitialLoad,
    PDWORD pWaitMilliseconds
    )
{
    DWORD WaitMilliseconds = 0;
    DWORD DSReconnectMilliseconds = 0;
    time_t NextTimeOutTime = 0;
    time_t PresentTime = 0;
    long WaitSeconds = gDefaultPollingInterval;


    WaitMilliseconds = gCurrentPollingInterval * 1000;

    if (!WaitMilliseconds) {
        WaitMilliseconds = INFINITE;
    }

    DSReconnectMilliseconds = gdwDSConnectivityCheck*60*1000;

    if ((gpWirelessPolicyState->dwCurrentState != POLL_STATE_DS_DOWNLOADED) &&
        (gpWirelessPolicyState->dwCurrentState != POLL_STATE_LOCAL_DOWNLOADED)) {
        if (WaitMilliseconds > DSReconnectMilliseconds) {
            WaitMilliseconds = DSReconnectMilliseconds;
        }
    }

    if (!bInitialLoad && WaitMilliseconds != INFINITE) {

        //
        // LastTimeOutTime is the snapshot time value in the past when
        // we timed out waiting for multiple events.
        // Ideally, the time for the next time out, NextTimeOutTime, is
        // the time value in future which is sum of the last time when
        // we timed out + the current waiting time value.
        //

        NextTimeOutTime = LastTimeOutTime + (WaitMilliseconds/1000);

        //
        // However, the last time we may not have timed out waiting
        // for multiple events but rather came out because one of the
        // events other than WAIT_TIMEOUT happened.
        // However, on that event we may not have done a policy
        // poll to figure out whether there was a policy change or
        // not. If we again wait for WaitMilliseconds, then we are
        // un-knowingly making our net time for policy poll greater
        // than the alloted time interval value = WaitMilliseconds.
        // So, we need to adjust the WaitMilliseconds to such a value
        // that no matter what happens, we always do a policy poll
        // atmost every WaitMilliseconds time interval value.
        // The current time is PresentTime.
        //

        time(&PresentTime);

        WaitSeconds = (long) (NextTimeOutTime - PresentTime);

        if (WaitSeconds < 0) {
            WaitMilliseconds = 0;
        }
        else {
            WaitMilliseconds = WaitSeconds * 1000;
        }

    }

    *pWaitMilliseconds = WaitMilliseconds;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\init.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    init.h

Abstract:

    This module contains all of the code to
    initialize the variables for the WirelessPOl Service.

Author:

    abhisheV    30-September-1999
    taroonM      11/17/01

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"



DWORD
InitSPDThruRegistry(
    )
{
    DWORD dwError = 0;
    HKEY hKey = NULL;
    DWORD dwtype = REG_DWORD;
    DWORD dwsize = sizeof(DWORD);


    dwError = RegOpenKey(
                  HKEY_LOCAL_MACHINE,
                  gpszLocPolicyAgent,
                  &hKey
                  );
    if (dwError) {
        gdwDSConnectivityCheck = DEFAULT_DS_CONNECTIVITY_CHECK;
        dwError = ERROR_SUCCESS;
        BAIL_ON_WIN32_SUCCESS(dwError);
    }

    //
    // Get DS connectivity check polling interval in minutes.
    //

    dwError = RegQueryValueEx(
                  hKey,
                  L"DSConnectivityCheck",
                  0,
                  &dwtype,
                  (unsigned char *) &gdwDSConnectivityCheck,
                  &dwsize
                  );
    if (dwError || !gdwDSConnectivityCheck) {
        gdwDSConnectivityCheck = DEFAULT_DS_CONNECTIVITY_CHECK;
        dwError = ERROR_SUCCESS;
    }

success:

    if (hKey) {
        RegCloseKey(hKey);
    }

    return (dwError);
}


DWORD
InitSPDGlobals(
    )
{
    DWORD dwError = 0;
    SECURITY_ATTRIBUTES SecurityAttributes;
    LPWSTR pszLogFileName = L"WLogFile.txt";
    
    //dwError = InitializeSPDSecurity(&gpSPDSD);
    //BAIL_ON_WIN32_ERROR(dwError);

    //InitializeCriticalSection(&gcSPDAuditSection);
    //gbSPDAuditSection = TRUE;

    gdwPolicyLoopStarted = 0;
    gdwWirelessPolicyEngineInited = 0;

   
    memset(&SecurityAttributes, 0, sizeof(SECURITY_ATTRIBUTES));

    SecurityAttributes.nLength = sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor = NULL;
    SecurityAttributes.bInheritHandle = TRUE;

    ghNewDSPolicyEvent = CreateEvent(
                             &SecurityAttributes,
                             TRUE,
                             FALSE,
                             WIRELESS_NEW_DS_POLICY_EVENT
                             );

    if (!ghNewDSPolicyEvent) {
        dwError = GetLastError();
        _WirelessDbg(TRC_ERR, "%d In ghNewDSPolicyEvent check  ",dwError);
        
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
   //Taroon  define POLICY RELOAD and CHANGE NOTIFY in some global location -- ipsec does it in ipsec.h
   
    ghForcedPolicyReloadEvent = CreateEvent(
                                    &SecurityAttributes,
                                    TRUE,
                                    FALSE,
                                    NULL
                                    );
    if (!ghForcedPolicyReloadEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

   ghPolicyChangeNotifyEvent = CreateEvent(
                                    NULL,
                                    TRUE,
                                    FALSE,
                                    NULL 
                                    );
    if (!ghPolicyChangeNotifyEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ghPolicyEngineStopEvent = CreateEvent(
                             &SecurityAttributes,
                             TRUE,
                             FALSE,
                             NULL
                             );
    if (!ghPolicyEngineStopEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

     ghReApplyPolicy8021x = CreateEvent(
                             &SecurityAttributes,
                             TRUE,
                             FALSE,
                             NULL
                             );
    if (!ghReApplyPolicy8021x) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }
    


   

error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\loopmgr.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    loopmgr.h

Abstract:

    This module contains all of the code prototypes to drive the
    Loop Manager of WifiPol Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


DWORD
ServiceWait(
    );

DWORD
ServiceStart(
    );



VOID
ComputeRelativePollingTime(
    time_t LastTimeOutTime,
    BOOL bInitialLoad,
    PDWORD pWaitMilliseconds
    );



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\security.h ===
#define MAX_ACE 6

#define SPD_OBJECT_SERVER 0

#define SPD_OBJECT_COUNT 1

#define SERVER_ACCESS_ADMINISTER 0x00000001

#define SERVER_ACCESS_ENUMERATE 0x00000002

#define SERVER_READ (STANDARD_RIGHTS_READ |\
                     SERVER_ACCESS_ENUMERATE)

#define SERVER_WRITE (STANDARD_RIGHTS_WRITE |\
                      SERVER_ACCESS_ADMINISTER |\
                      SERVER_ACCESS_ENUMERATE)

#define SERVER_EXECUTE (STANDARD_RIGHTS_EXECUTE |\
                        SERVER_ACCESS_ENUMERATE)

#define SERVER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |\
                           SERVER_ACCESS_ADMINISTER |\
                           SERVER_ACCESS_ENUMERATE)


DWORD
InitializeSPDSecurity(
    PSECURITY_DESCRIPTOR * ppSPDSD
    );

DWORD
BuildSPDObjectProtection(
    DWORD dwAceCount,
    PUCHAR pAceType,
    PSID * ppAceSid,
    PACCESS_MASK pAceMask,
    PBYTE pInheritFlags,
    PSID pOwnerSid,
    PSID pGroupSid,
    PGENERIC_MAPPING pGenericMap,
    PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
ValidateSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    );

VOID
MapGenericToSpecificAccess(
    DWORD dwObjectType,
    ACCESS_MASK GenericAccess,
    PACCESS_MASK pSpecificAccess
    );

BOOL
GetTokenHandle(
    PHANDLE phToken
    );

DWORD
ValidateMMSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    );

DWORD
ValidateTxSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    );

DWORD
ValidateTnSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\main.c ===
#include "precomp.h"

DWORD WINAPI ServiceStart( LPVOID lparam);
DWORD WINAPI InitWirelessPolicy (void);

BOOL Is_Whistler_Home_Edition () 
{
     OSVERSIONINFOEX osvi;
     DWORDLONG dwlConditionMask = 0;

     // Initialize the OSVERSIONINFOEX structure.

     ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
     osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
     //osvi.dwMajorVersion = 5;
     //osvi.dwMinorVersion = 1;
     osvi.wSuiteMask  = VER_SUITE_PERSONAL; 


     // Initialize the condition mask.
     /*
     VER_SET_CONDITION( 
         dwlConditionMask, 
         VER_MAJORVERSION, 
         VER_EQUAL 
         );
     
    VER_SET_CONDITION( 
        dwlConditionMask, 
        VER_MINORVERSION, 
        VER_EQUAL 
        );

    VER_SET_CONDITION(
        dwlConditionMask, 
        VER_PRODUCT_TYPE, 
        VER_EQUAL 
        );
  */
    VER_SET_CONDITION(
        dwlConditionMask, 
        VER_SUITENAME, 
        VER_AND 
        );
    
   // Perform the test.

   return VerifyVersionInfo(
      &osvi, 
       VER_SUITENAME,
      dwlConditionMask
      );
}


DWORD
InitPolicyEngine(DWORD dwParam, HANDLE * hThread)
{

    DWORD dwError = 0;
    DWORD dwLocThreadId;
    HANDLE hLocThread = NULL;


    WiFiTrcInit();

    if (Is_Whistler_Home_Edition()) {
        _WirelessDbg(TRC_ERR, "Policy Engine Not Starting :: This is Home Edition ");
        return(dwError);
    }
    
    dwError = InitWirelessPolicy();
    BAIL_ON_WIN32_ERROR(dwError);

    _WirelessDbg(TRC_TRACK, "Starting the Policy Engine in a New Thread ");
    
    
    hLocThread = CreateThread( 
        NULL,                        // no security attributes 
        0,                           // use default stack size  
        ServiceStart,                  // thread function 
        &dwParam,                // argument to thread function 
        0,                           // use default creation flags 
        &dwLocThreadId);                // returns the thread identifier 

        
    if (hThread == NULL) 
   {
       _WirelessDbg(TRC_ERR, "CreateThread failed." );
       
       dwError = GetLastError();
   }
    BAIL_ON_WIN32_ERROR(dwError);

   *hThread = hLocThread;

   // Set the flag that Policy Engine is Initialized
   gdwWirelessPolicyEngineInited = 1;

    return(dwError);
    
error:

    //  State Cleanup Here

    ClearPolicyStateBlock(
        gpWirelessPolicyState
        );

    ClearSPDGlobals();

    WiFiTrcTerm();

    return(dwError);
}

DWORD 
TerminatePolicyEngine(HANDLE hThread)
{
    DWORD dwError =0;
    DWORD dwExitCode = 0;
    
   // send appropriate Event .... 

    if (Is_Whistler_Home_Edition()) {
        _WirelessDbg(TRC_ERR, "Policy Engine Not Started :: This is Home Edition ");
        WiFiTrcTerm();
        
        return(dwError);
    }

    if (!gdwWirelessPolicyEngineInited) {
    	// Policy Engine was not started. No need to do cleanup;
    	return(ERROR_NOT_SUPPORTED);
    	}
   
   if (!SetEvent(ghPolicyEngineStopEvent)) {
   	dwError = GetLastError();
   	BAIL_ON_WIN32_ERROR(dwError);
   	}

  dwError = WaitForSingleObject(hThread, INFINITE);
  if (dwError) {
  	_WirelessDbg(TRC_ERR, "Wait Failed ");
  	
  }
  BAIL_ON_WIN32_ERROR(dwError);

  _WirelessDbg(TRC_TRACK, "Thread Exited ");


   error:

   CloseHandle(hThread);

   ClearPolicyStateBlock(
        gpWirelessPolicyState
        );

   ClearSPDGlobals();

   WiFiTrcTerm();

   // Set that the wireless Policy Engine has been non-inited
   gdwWirelessPolicyEngineInited = 0;

   return(dwError);
   
}


DWORD 
ReApplyPolicy8021x(void)
{
    DWORD dwError =0;
    
 if (ghReApplyPolicy8021x == NULL) {
        dwError = ERROR_INVALID_STATE;
        _WirelessDbg(TRC_ERR, "Policy Loop Not Initialized Yet ");
	return(dwError);
    }

    _WirelessDbg(TRC_TRACK, " ReApplyPolicy8021x called ");
   // send appropriate Event .... 
     if (!SetEvent(ghReApplyPolicy8021x)) {
     	  dwError = GetLastError();
     }

   return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\policyinput.h ===
DWORD 
printPS(PWIRELESS_PS_DATA pWirelessPSData) ;

DWORD 
printPolicy(PWIRELESS_POLICY_DATA pWirelessPolicyData) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\precomp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    precomp.h

Abstract:

    Precompiled header for wifipol.dll.

Author:

    abhisheV    21-September-1999
    taroonm     11/21/01

Environment:

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <rpc.h>
#include <windows.h>
#include <imagehlp.h>
#include <tchar.h>
#include <conio.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <dsgetdc.h>

#ifdef __cplusplus
}
#endif

#include "winioctl.h"
#include "winsock2.h"
#include "winsock.h"
#include <userenv.h>
#include <wchar.h>
#include <winldap.h>
#include "ipexport.h"
#include <iphlpapi.h>
#include <nhapi.h>
#include <seopaque.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <msaudite.h>
#include <ntlsa.h>
#include <lsarpc.h>
#include <ntsam.h>
#include <lsaisrv.h>

#ifdef __cplusplus
}
#endif


#include "utils.h"
#include "memory.h"
#include "security.h"
#include "init.h"
#include "loopmgr.h"
#include "wirelessspd.h"


//
// Policy Agent Store specific headers.
//

//#include "oakdefs.h"
#include "wlstore2.h"
#include "..\..\wastore\ldaputil.h"
#include "..\..\wastore\structs.h"
#include "..\..\wastore\dsstore.h"
#include "..\..\wastore\regstore.h"
#include "..\..\wastore\procrule.h"
#include "..\..\wastore\persist.h"
#include "..\..\wastore\utils.h"
#include "polguids.h"
#include "pastore.h"


#include "externs.h"
#include "policyinput.h"

#include <wzcsapi.h>
#include "wifiext.h"
#include "wifipol.h"

// Florin's Stuff
#include "eapolpol.h"
#include <rtutils.h>
#include "tracing.h"

extern
DWORD
AllocateAndGetIfTableFromStack(
    OUT MIB_IFTABLE **ppIfTable,
    IN  BOOL        bOrder,
    IN  HANDLE      hHeap,
    IN  DWORD       dwFlags,
    IN  BOOL        bForceUpdate
    );


#ifdef BAIL_ON_WIN32_ERROR
#undef BAIL_ON_WIN32_ERROR
#endif

#ifdef BAIL_ON_LOCK_ERROR
#undef BAIL_ON_LOCK_ERROR
#endif


#define BAIL_ON_WIN32_ERROR(dwError)                \
    if (dwError) {                                  \
        goto error;                                 \
    }

#define BAIL_ON_LOCK_ERROR(dwError)                 \
    if (dwError) {                                  \
        goto lock;                                  \
    }

#define BAIL_ON_WIN32_SUCCESS(dwError) \
    if (!dwError) {                    \
        goto success;                  \
    }

#define BAIL_ON_LOCK_SUCCESS(dwError)  \
    if (!dwError) {                    \
        goto lock_success;             \
    }

#define ENTER_SPD_SECTION()             \
    EnterCriticalSection(&gcSPDSection) \

#define LEAVE_SPD_SECTION()             \
    LeaveCriticalSection(&gcSPDSection) \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\pastore.h ===
#define POLL_STATE_INITIAL             0
#define POLL_STATE_DS_DOWNLOADED       1
#define POLL_STATE_LOCAL_DOWNLOADED    2
#define POLL_STATE_CACHE_DOWNLOADED    3


typedef struct _WIRELESS_POLICY_STATE {
    DWORD dwCurrentState;
    union {
        LPWSTR pszDirectoryPolicyDN;
        LPWSTR pszCachePolicyDN;
    };
    DWORD CurrentPollingInterval;
    DWORD DefaultPollingInterval;
    DWORD DSIncarnationNumber;
    DWORD RegIncarnationNumber;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject;
    PWIRELESS_POLICY_DATA pWirelessPolicyData;
} WIRELESS_POLICY_STATE, * PWIRELESS_POLICY_STATE;


VOID
InitializePolicyStateBlock(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    );

DWORD
StartStatePollingManager(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    );

DWORD
PlumbDirectoryPolicy(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    );

DWORD
GetDirectoryPolicyDN(
    LPWSTR * ppszDirectoryPolicyDN
    );

DWORD
CheckDeleteOldPolicy(
    DWORD * dwDelete
    );

DWORD
LoadDirectoryPolicy(
    LPWSTR pszDirectoryPolicyDN,
    PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
    );

DWORD
PlumbCachePolicy(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    );

DWORD
GetCachePolicyDN(
    LPWSTR * ppszCachePolicyDN
    );

DWORD
LoadCachePolicy(
    LPWSTR pszCachePolicyDN,
    PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
    );



DWORD
AddPolicyInformation(
    PWIRELESS_POLICY_DATA pWirelessPolicyData
    );

DWORD
AddWZCPolicy(
    PWIRELESS_POLICY_DATA pWirelessPolicyData
   );

DWORD
AddEapolPolicy(
    PWIRELESS_POLICY_DATA pWirelessPolicyData
    );

DWORD
OnPolicyChanged(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    );

DWORD
OnPolicyChangedEx(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    );

DWORD
DeletePolicyInformation(
    PWIRELESS_POLICY_DATA pWirelessPolicyData
    );




VOID
ClearPolicyStateBlock(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    );

DWORD
OnPolicyPoll(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    );

DWORD
ProcessDirectoryPolicyPollState(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    );

DWORD
GetDirectoryIncarnationNumber(
    LPWSTR pszWirelessPolicyDN,
    DWORD * pdwIncarnationNumber
    );

DWORD
MigrateFromDSToCache(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    );

DWORD
ProcessCachePolicyPollState(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    );

DWORD
MigrateFromCacheToDS(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    );

DWORD
UpdateFromCacheToDS(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    );



DWORD
UpdatePolicyInformation(
    PWIRELESS_POLICY_DATA pOldWirelessPolicyData,
    PWIRELESS_POLICY_DATA pNewWirelessPolicyData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\pastore.c ===
#include "precomp.h"


VOID
InitializePolicyStateBlock(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    )
{
    memset(pWirelessPolicyState, 0, sizeof(WIRELESS_POLICY_STATE));
    pWirelessPolicyState->DefaultPollingInterval = gDefaultPollingInterval;
}


DWORD
StartStatePollingManager(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    )
{
    DWORD dwError = 0;



    dwError = PlumbDirectoryPolicy(
                  pWirelessPolicyState
                  );
    
    if (dwError) {

        dwError = PlumbCachePolicy(
                      pWirelessPolicyState
                      );
         
         BAIL_ON_WIN32_ERROR(dwError);
    	}
       
       

    //
    // The new polling interval has been set by either the
    // registry code or the DS code.
    //

    gCurrentPollingInterval = pWirelessPolicyState->CurrentPollingInterval;

    return (dwError);

error:

    //
    // On error, set the state to INITIAL.
    //

    pWirelessPolicyState->dwCurrentState = POLL_STATE_INITIAL;
    _WirelessDbg(TRC_STATE, "Policy State :: Initial State ");
        

    gCurrentPollingInterval = pWirelessPolicyState->DefaultPollingInterval;

    return (dwError);
}


DWORD
PlumbDirectoryPolicy(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    DWORD dwStoreType = WIRELESS_DIRECTORY_PROVIDER;
    DWORD dwSlientErrorCode = 0;
    BOOL bIsActivePolicy = FALSE;
    LPVOID lpMsgBuf;
    DWORD len = 0;
    DWORD i = 0;


   _WirelessDbg(TRC_NOTIF, "DBASE: Wireless Policy - Checking for Current Policy on DC ");
   
    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );
    
    BAIL_ON_WIN32_ERROR(dwError);
    bIsActivePolicy = TRUE;

    dwError = LoadDirectoryPolicy(
                  pszDirectoryPolicyDN,
                  &pWirelessPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    // Taroon:: For some reason, the dwChanged Field is written by ProcessNFA Routine. 
    // Ideally it should be written here first. May be, the when changed field is decided
    // based on if the NFA policy too has changed etc etc.
    // Unmarshalling of IPSEC happens in ProcessNFA. We get rid of that and call it right here.

    __try {
    dwError = UnmarshallWirelessPolicyObject(
                 pWirelessPolicyObject,
                 dwStoreType,
                 &pWirelessPolicyData
                 ); 
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwError = ERROR_INVALID_DATA;
    _WirelessDbg(TRC_ERR, "Got Invalid Data ");
    
    	}
   BAIL_ON_WIN32_ERROR(dwError);

      
   
    dwError = AddPolicyInformation(
                  pWirelessPolicyData
                  );
    
    if (pWirelessPolicyState->pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyState->pWirelessPolicyObject);
    }
    
    if (pWirelessPolicyState->pWirelessPolicyData) {
        FreeWirelessPolicyData(pWirelessPolicyState->pWirelessPolicyData);
    }
   
    if (pWirelessPolicyState->pszDirectoryPolicyDN) {
        FreeSPDStr(pWirelessPolicyState->pszDirectoryPolicyDN);
    }

    //
    // Delete the old cache and write the new one in.
    //

    DeleteRegistryCache();

    CacheDirectorytoRegistry(pWirelessPolicyObject);

    pWirelessPolicyState->pWirelessPolicyObject = pWirelessPolicyObject;

    pWirelessPolicyState->pWirelessPolicyData = pWirelessPolicyData;

    pWirelessPolicyState->pszDirectoryPolicyDN = pszDirectoryPolicyDN;

    //
    // Set the state to DS_DOWNLOADED.
    //

    pWirelessPolicyState->dwCurrentState = POLL_STATE_DS_DOWNLOADED;
    _WirelessDbg(TRC_STATE, "Policy State is DS Downloaded ");
        

    //
    // Compute the new polling interval.
    //

    pWirelessPolicyState->CurrentPollingInterval =  pWirelessPolicyData->dwPollingInterval;

    pWirelessPolicyState->DSIncarnationNumber = pWirelessPolicyData->dwWhenChanged;

    pWirelessPolicyState->RegIncarnationNumber = 0;

    gCurrentPollingInterval = pWirelessPolicyState->CurrentPollingInterval;

    dwError = ERROR_SUCCESS;
    
    return (dwError);

error:

    //
    // Check pszDirectoryPolicyDN for non-NULL.
    //


    if (pszDirectoryPolicyDN) {
        FreeSPDStr(pszDirectoryPolicyDN);
    }

    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyObject);
    }

    if (pWirelessPolicyData) {
        FreeWirelessPolicyData(pWirelessPolicyData);
    }

    return (dwError);
}


// This Pre-requisite for this function is that Policy state is either CACHE or DS

DWORD
CheckDeleteOldPolicy(
    DWORD *dwDelete
    )
{
    DWORD dwError = 0;
    HKEY hPolicyKey = NULL;
    DWORD dwSize = 0;
    DWORD dwSizeID = 0;
    DWORD dwSizeName = 0;
    DWORD dwToDelete = 1;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    LPWSTR pszWirelessPolicyID = NULL;
    LPWSTR pszPolicyID = NULL;
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszWirelessPolicyName = NULL;
    
    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszWirelessDSPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hPolicyKey
                  );

     BAIL_ON_WIN32_ERROR(dwError);



    dwError = RegstoreQueryValue(
                  hPolicyKey,
                  L"WirelessID",
                  REG_SZ,
                  (LPBYTE *)&pszWirelessPolicyID,
                  &dwSize
                  );

    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hPolicyKey,
                  L"DSWirelessPolicyName",
                  REG_SZ,
                  (LPBYTE *)&pszWirelessPolicyName,
                  &dwSize
                  );

    BAIL_ON_WIN32_ERROR(dwError);

   // account for the first {
   
   pszPolicyID = pszWirelessPolicyID+ wcslen(L"{");

   pWirelessPolicyData = gpWirelessPolicyState->pWirelessPolicyData;

   dwError = UuidToString(
                    &pWirelessPolicyData->PolicyIdentifier,
                    &pszStringUuid
                    );
   BAIL_ON_WIN32_ERROR(dwError);
   
   dwSizeID = wcslen(pszStringUuid) * sizeof(WCHAR);
   dwSizeName = wcslen(pszWirelessPolicyName) * sizeof(WCHAR);
   
   if (!memcmp(pszPolicyID, pszStringUuid, dwSizeID) && 
        (!memcmp(pszWirelessPolicyName, pWirelessPolicyData->pszWirelessName, dwSizeName)))
   {
       dwToDelete = 0;
   }

error:

   *dwDelete = dwToDelete;

    if (pszStringUuid) {
    	RpcStringFree(&pszStringUuid);
    }

   if (pszWirelessPolicyID) {
   	FreePolMem(pszWirelessPolicyID);
   }

   if (pszWirelessPolicyName) {
   	FreePolMem(pszWirelessPolicyName);
   }

    if (hPolicyKey) {
        CloseHandle(hPolicyKey);
    }

    return (dwError);
}



DWORD
GetDirectoryPolicyDN(
    LPWSTR * ppszDirectoryPolicyDN
    )
{
    DWORD dwError = 0;
    HKEY hPolicyKey = NULL;
    LPWSTR pszWirelessPolicyName = NULL;
    DWORD dwSize = 0;
    LPWSTR pszPolicyDN = NULL;
    LPWSTR pszDirectoryPolicyDN = NULL;


    *ppszDirectoryPolicyDN = NULL;

    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszWirelessDSPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hPolicyKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hPolicyKey,
                  L"DSWirelessPolicyPath",
                  REG_SZ,
                  (LPBYTE *)&pszWirelessPolicyName,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Move by LDAP:// to get the real DN and allocate
    // this string.
    // Fix this by fixing the gpo extension.
    //

    pszPolicyDN = pszWirelessPolicyName + wcslen(L"LDAP://");

    pszDirectoryPolicyDN = AllocSPDStr(pszPolicyDN);

    if (!pszDirectoryPolicyDN) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszDirectoryPolicyDN = pszDirectoryPolicyDN;

error:

    if (pszWirelessPolicyName) {
        FreeSPDStr(pszWirelessPolicyName);
    }

    if (hPolicyKey) {
        CloseHandle(hPolicyKey);
    }

    return (dwError);
}


DWORD
LoadDirectoryPolicy(
    LPWSTR pszDirectoryPolicyDN,
    PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
    )
{
    DWORD dwError = 0;
    LPWSTR pszDefaultDirectory = NULL;
    HLDAP hLdapBindHandle = NULL;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;


    dwError = ComputeDefaultDirectory(
                  &pszDefaultDirectory
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = OpenDirectoryServerHandle(
                  pszDefaultDirectory,
                  389,
                  &hLdapBindHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadPolicyObjectFromDirectory(
                  hLdapBindHandle,
                  pszDirectoryPolicyDN,
                  &pWirelessPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppWirelessPolicyObject = pWirelessPolicyObject;

cleanup:

    if (pszDefaultDirectory) {
        FreeSPDStr(pszDefaultDirectory);
    }

    if (hLdapBindHandle) {
        CloseDirectoryServerHandle(hLdapBindHandle);
    }

    return (dwError);

error:

    *ppWirelessPolicyObject = NULL;

    goto cleanup;
}


DWORD
PlumbCachePolicy(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszCachePolicyDN = NULL;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    DWORD dwStoreType = WIRELESS_REGISTRY_PROVIDER;
    DWORD dwSlientErrorCode = 0;
    BOOL bIsActivePolicy = FALSE;

   _WirelessDbg(TRC_NOTIF, "DBASE: Wireless Policy - Checking for Current Cached Policy  ");
   

    dwError = GetCachePolicyDN(
                  &pszCachePolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    bIsActivePolicy = TRUE;

    dwError = LoadCachePolicy(
                  pszCachePolicyDN,
                  &pWirelessPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

   __try {
    dwError = UnmarshallWirelessPolicyObject(
                 pWirelessPolicyObject,
                 dwStoreType,
                 &pWirelessPolicyData
                 ); 
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwError = ERROR_INVALID_DATA;
    	}
   BAIL_ON_WIN32_ERROR(dwError);


    dwError = AddPolicyInformation(
                  pWirelessPolicyData
                  );
 
    if (pWirelessPolicyState->pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyState->pWirelessPolicyObject);
    }

    if (pWirelessPolicyState->pWirelessPolicyData) {
        FreeWirelessPolicyData(pWirelessPolicyState->pWirelessPolicyData);
    }

    if (pWirelessPolicyState->pszCachePolicyDN) {
        FreeSPDStr(pWirelessPolicyState->pszCachePolicyDN);
    }

    pWirelessPolicyState->pWirelessPolicyObject = pWirelessPolicyObject;

    pWirelessPolicyState->pWirelessPolicyData = pWirelessPolicyData;

    pWirelessPolicyState->pszCachePolicyDN = pszCachePolicyDN;

    //
    // Set the state to CACHE_DOWNLOADED.
    //
    //

    pWirelessPolicyState->dwCurrentState = POLL_STATE_CACHE_DOWNLOADED;
    _WirelessDbg(TRC_STATE, "Policy State :: Cache Downloaded ");
        

    //
    // Compute the new polling interval.
    //

    pWirelessPolicyState->CurrentPollingInterval = pWirelessPolicyData->dwPollingInterval;

    pWirelessPolicyState->DSIncarnationNumber = 0;

    pWirelessPolicyState->RegIncarnationNumber = pWirelessPolicyData->dwWhenChanged;

    gCurrentPollingInterval = pWirelessPolicyState->CurrentPollingInterval;

    dwError = ERROR_SUCCESS;
    
    return (dwError);

error:

    //
    // Check pszCachePolicyDN for non-NULL.
    //


    if (pszCachePolicyDN) {
        FreeSPDStr(pszCachePolicyDN);
    }

    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyObject);
    }

    if (pWirelessPolicyData) {
        FreeWirelessPolicyData(pWirelessPolicyData);
    }

    return (dwError);
}


DWORD
GetCachePolicyDN(
    LPWSTR * ppszCachePolicyDN
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    LPWSTR pszCachePolicyDN = NULL;


    *ppszCachePolicyDN = NULL;

    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyPolicyDSToFQRegString(
                  pszDirectoryPolicyDN,
                  &pszCachePolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppszCachePolicyDN = pszCachePolicyDN;

error:

    if (pszDirectoryPolicyDN) {
        FreeSPDStr(pszDirectoryPolicyDN);
    }

    return (dwError);
}


DWORD
LoadCachePolicy(
    LPWSTR pszCachePolicyDN,
    PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;


    dwError = OpenRegistryWIRELESSRootKey(
                  NULL,
                  gpszWirelessCachePolicyKey,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadPolicyObjectFromRegistry(
                  hRegistryKey,
                  pszCachePolicyDN,
                  gpszWirelessCachePolicyKey,
                  &pWirelessPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppWirelessPolicyObject = pWirelessPolicyObject;

cleanup:

    if (hRegistryKey) {
        CloseHandle(hRegistryKey);
    }

    return (dwError);

error:

    *ppWirelessPolicyObject = NULL;

    goto cleanup;
}



DWORD
OnPolicyChanged(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    )
{
    DWORD dwError = 0;
    DWORD dwDelete = 1;

   // If Initial Start - Start afresh

    if (pWirelessPolicyState->dwCurrentState == POLL_STATE_INITIAL) {
    	StartStatePollingManager(pWirelessPolicyState);
    	return(dwError);
    }

    //
    // Check if the existing Policy Object has been changed.. Only in that case, delete the policy.
    //
    
    CheckDeleteOldPolicy(&dwDelete);

    if (dwDelete) 
    {

        //
       // Remove all the old policy that was plumbed.
       //

        dwError = DeletePolicyInformation(
            pWirelessPolicyState->pWirelessPolicyData
            );
    
        ClearPolicyStateBlock(
             pWirelessPolicyState
             );

           //
          // Calling the Initializer again.
          //

        dwError = StartStatePollingManager(
            pWirelessPolicyState
            );

        return (dwError);

    }

    // Policy Object is the same. Might be Modified Though. Call the On Policy Poll 
    _WirelessDbg(TRC_TRACK, "Policy Not New: Changing to Poll Function ");
    
    dwError = OnPolicyPoll(pWirelessPolicyState);
    return(dwError);

}




DWORD
OnPolicyChangedEx(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    )
{
    DWORD dwError = 0;

   // If Initial Start - Start afresh

    if (pWirelessPolicyState->dwCurrentState == POLL_STATE_INITIAL) {
    	StartStatePollingManager(pWirelessPolicyState);
    	return(dwError);
    }

     //
    // Remove all the old policy that was plumbed.
     //
   _WirelessDbg(TRC_TRACK, "OnPolicyChangeEx  called ");

     dwError = DeletePolicyInformation(
          pWirelessPolicyState->pWirelessPolicyData
          );
    
    ClearPolicyStateBlock(
         pWirelessPolicyState
         );

       //
      // Calling the Initializer again.
      //


     dwError = StartStatePollingManager(
        pWirelessPolicyState
        );

     return (dwError);

    
}


DWORD
DeletePolicyInformation(
    PWIRELESS_POLICY_DATA pWirelessPolicyData
    )
{
    DWORD dwError = 0;


    if (!pWirelessPolicyData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    _WirelessDbg(TRC_NOTIF, "DBASE: Wireless Policy - Deleting Existing Policy for Zero Conf / 802.1x ");
    

    _WirelessDbg(TRC_TRACK, "Deleting  Policy Information");
    _WirelessDbg(TRC_TRACK, "Deleted Policy is ");
    printPolicy(pWirelessPolicyData);
    

    dwError = AddWZCPolicy(NULL);
    if (dwError) {
    	_WirelessDbg(TRC_ERR, "Error in Deleting ZeroConfig Policy Error %d ", dwError);
    	
    	dwError = ERROR_SUCCESS;
    } else 
    {
        _WirelessDbg(TRC_TRACK, "ZeroConf Policy Deletion Succesful ");
        
    }
    	

    dwError = AddEapolPolicy(NULL);
    if (dwError) {
        _WirelessDbg(TRC_ERR, "Error in Deleting EAPOL Policy with Error No. %d ", dwError);
        
        dwError = ERROR_SUCCESS;
    } else 
    {
        _WirelessDbg(TRC_TRACK, "EAPOL  Policy Deletion Succesful ");
        
    }
    
    return (dwError);
}


VOID
ClearPolicyStateBlock(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    )
{
    if (pWirelessPolicyState->pWirelessPolicyObject) {
        FreeWirelessPolicyObject(
            pWirelessPolicyState->pWirelessPolicyObject
            );
        pWirelessPolicyState->pWirelessPolicyObject = NULL;
    }

    if (pWirelessPolicyState->pWirelessPolicyData) {
        FreeWirelessPolicyData(
            pWirelessPolicyState->pWirelessPolicyData
            );
        pWirelessPolicyState->pWirelessPolicyData = NULL;
    }

    if (pWirelessPolicyState->pszDirectoryPolicyDN) {
        FreeSPDStr(pWirelessPolicyState->pszDirectoryPolicyDN);
        pWirelessPolicyState->pszDirectoryPolicyDN = NULL;
    }

    pWirelessPolicyState->CurrentPollingInterval =  gDefaultPollingInterval;
    pWirelessPolicyState->DefaultPollingInterval =  gDefaultPollingInterval;
    pWirelessPolicyState->DSIncarnationNumber = 0;
    pWirelessPolicyState->RegIncarnationNumber = 0;
    pWirelessPolicyState->dwCurrentState = POLL_STATE_INITIAL;
    _WirelessDbg(TRC_STATE, "Policy State :: Initial State ");
        
}


DWORD
OnPolicyPoll(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    )
{
    DWORD dwError = 0;

    _WirelessDbg(TRC_NOTIF, "DBASE: Wireless Policy - Polling for Policy Changes ");
    

    switch (pWirelessPolicyState->dwCurrentState) {

    case POLL_STATE_DS_DOWNLOADED:
        dwError = ProcessDirectoryPolicyPollState(pWirelessPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    case POLL_STATE_CACHE_DOWNLOADED:
        dwError = ProcessCachePolicyPollState(pWirelessPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    case POLL_STATE_INITIAL:
        dwError = OnPolicyChangedEx(pWirelessPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    //
    // Set the new polling interval.
    //

    gCurrentPollingInterval = pWirelessPolicyState->CurrentPollingInterval;

    return (dwError);

error:

    //
    // If in any of the three states other than the initial state,
    // then there was an error in pulling down the incarnation number
    // or the Wireless Policy from either the directory or the registry
    // or there might not no longer be any Wireless policy assigned to 
    // this machine. So the  polling state must reset back to the 
    // start state through a forced policy change. This is also
    // necessary if the polling state is already in the initial state.
    //

    dwError = OnPolicyChangedEx(
                  pWirelessPolicyState
                  );

    return (dwError);
}


DWORD
ProcessDirectoryPolicyPollState(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    )
{
    DWORD dwError = 0;
    DWORD dwIncarnationNumber = 0;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    DWORD dwStoreType = WIRELESS_DIRECTORY_PROVIDER;
    DWORD dwSlientErrorCode = 0;


    //
    // The directory policy DN has to be the same, otherwise the
    // Wireless  extension in Winlogon would have already notified 
    // PA Store of the DS policy change.
    //

    dwError = GetDirectoryIncarnationNumber(
                   pWirelessPolicyState->pszDirectoryPolicyDN,
                   &dwIncarnationNumber
                   );
    if (dwError) {
        dwError = MigrateFromDSToCache(pWirelessPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        return (ERROR_SUCCESS);
    }

    if (dwIncarnationNumber == pWirelessPolicyState->DSIncarnationNumber) {

        //
        // The policy has not changed at all.
        //
        _WirelessDbg(TRC_NOTIF, "DBASE: Wireless Policy - Policy on DS has Not Changed ");
        
        
        return (ERROR_SUCCESS);
    }

    //
    // The incarnation number is different, so there's a need to 
    // update the policy.
    //

    dwError = LoadDirectoryPolicy(
                  pWirelessPolicyState->pszDirectoryPolicyDN,
                  &pWirelessPolicyObject
                  );
    if (dwError) {
        dwError = MigrateFromDSToCache(pWirelessPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        return (ERROR_SUCCESS);
    }

   __try {
    dwError = UnmarshallWirelessPolicyObject(
                 pWirelessPolicyObject,
                 dwStoreType,
                 &pWirelessPolicyData
                 ); 
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwError = ERROR_INVALID_DATA;
    	}

    if (dwError) {
        dwError = MigrateFromDSToCache(pWirelessPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        if (pWirelessPolicyObject) {
            FreeWirelessPolicyObject(pWirelessPolicyObject);
        }
        return (ERROR_SUCCESS);
    }

    dwError = UpdatePolicyInformation(
                  pWirelessPolicyState->pWirelessPolicyData,
                  pWirelessPolicyData
                  );

    if (pWirelessPolicyState->pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyState->pWirelessPolicyObject);
    }

    if (pWirelessPolicyState->pWirelessPolicyData) {
        FreeWirelessPolicyData(pWirelessPolicyState->pWirelessPolicyData);
    }

    //
    // Now delete the old cache and write the new one in.
    //

    DeleteRegistryCache();

    CacheDirectorytoRegistry(pWirelessPolicyObject);

    pWirelessPolicyState->pWirelessPolicyObject = pWirelessPolicyObject;

    pWirelessPolicyState->pWirelessPolicyData = pWirelessPolicyData;

    pWirelessPolicyState->CurrentPollingInterval = pWirelessPolicyData->dwPollingInterval;

    pWirelessPolicyState->DSIncarnationNumber = dwIncarnationNumber;

    //NotifyWirelessPolicyChange();

    dwError = ERROR_SUCCESS;
   
    return (dwError);

error:

    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyObject);
    }

    if (pWirelessPolicyData) {
        FreeWirelessPolicyData(pWirelessPolicyData);
    }

    return (dwError);
}


DWORD
GetDirectoryIncarnationNumber(
    LPWSTR pszWirelessPolicyDN,
    DWORD * pdwIncarnationNumber
    )
{
    DWORD dwError = 0;
    LPWSTR pszDefaultDirectory = NULL;
    HLDAP hLdapBindHandle = NULL;
    LPWSTR Attributes[] = {L"whenChanged", NULL};
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    WCHAR **strvalues = NULL;
    DWORD dwCount = 0;
    DWORD dwWhenChanged = 0;


    *pdwIncarnationNumber = 0;

    //
    // Open the directory store.
    //

    dwError = ComputeDefaultDirectory(
                  &pszDefaultDirectory
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = OpenDirectoryServerHandle(
                  pszDefaultDirectory,
                  389,
                  &hLdapBindHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszWirelessPolicyDN,
                  LDAP_SCOPE_BASE,
                  L"(objectClass=*)",
                  Attributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapGetValues(
                  hLdapBindHandle,
                  e,
                  L"whenChanged",
                  (WCHAR ***)&strvalues,
                  (int *)&dwCount
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwWhenChanged = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));

    *pdwIncarnationNumber = dwWhenChanged;

error:

    if (pszDefaultDirectory) {
        FreeSPDStr(pszDefaultDirectory);
    }

    if (hLdapBindHandle) {
        CloseDirectoryServerHandle(hLdapBindHandle);
    }

    if (res) {
        LdapMsgFree(res);
    }

    if (strvalues) {
        LdapValueFree(strvalues);
    }

    return (dwError);
}


DWORD
MigrateFromDSToCache(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszCachePolicyDN = NULL;


    dwError = GetCachePolicyDN(
                  &pszCachePolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pWirelessPolicyState->pszDirectoryPolicyDN) {
        FreeSPDStr(pWirelessPolicyState->pszDirectoryPolicyDN);
        pWirelessPolicyState->pszDirectoryPolicyDN = NULL;
    }

    pWirelessPolicyState->pszCachePolicyDN = pszCachePolicyDN;

    //
    // Keep pWirelessPolicyState->pWirelessPolicyData.
    // Keep pWirelessPolicyState->pWirelessPolicyObject.
    // Change the incarnation numbers.
    //

    pWirelessPolicyState->RegIncarnationNumber = pWirelessPolicyState->DSIncarnationNumber;

    pWirelessPolicyState->DSIncarnationNumber = 0;

    pWirelessPolicyState->dwCurrentState = POLL_STATE_CACHE_DOWNLOADED;
    _WirelessDbg(TRC_STATE, "Policy State :: Cache Downloaded ");
    
    _WirelessDbg(TRC_NOTIF, "DBASE: Wireless Policy - Error Syncing Policy with DC, Using Cached Policy ");
    
    //
    // Keep pWirelessPolicyState->CurrentPollingInterval.
    // Keep pWirelessPolicyState->DefaultPollingInterval.
    //

    gCurrentPollingInterval = pWirelessPolicyState->CurrentPollingInterval;

error:

    return (dwError);
}


DWORD
ProcessCachePolicyPollState(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    DWORD dwIncarnationNumber = 0;
    LPWSTR pszCachePolicyDN = NULL;


    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );

    if (!dwError) {

        dwError = GetDirectoryIncarnationNumber(
                      pszDirectoryPolicyDN,
                      &dwIncarnationNumber
                      );

        if (!dwError) {

            dwError = CopyPolicyDSToFQRegString(
                          pszDirectoryPolicyDN,
                          &pszCachePolicyDN
                          );

            if (!dwError) {

                if (!_wcsicmp(pWirelessPolicyState->pszCachePolicyDN, pszCachePolicyDN)) {

                    if (pWirelessPolicyState->RegIncarnationNumber == dwIncarnationNumber) {
                        dwError = MigrateFromCacheToDS(pWirelessPolicyState);
                    }
                    else {
                        dwError = UpdateFromCacheToDS(pWirelessPolicyState);
                    }

                    if (dwError) {
                        dwError = OnPolicyChangedEx(pWirelessPolicyState);
                    }

                }
                else {

                    dwError = OnPolicyChangedEx(pWirelessPolicyState);

                }

            }

        }

    }

    if (pszDirectoryPolicyDN) {
        FreeSPDStr(pszDirectoryPolicyDN);
    }

    if (pszCachePolicyDN) {
        FreeSPDStr(pszCachePolicyDN);
    }

    return (ERROR_SUCCESS);
}


DWORD
MigrateFromCacheToDS(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;


    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pWirelessPolicyState->pszCachePolicyDN) {
        FreeSPDStr(pWirelessPolicyState->pszCachePolicyDN);
        pWirelessPolicyState->pszCachePolicyDN = NULL;
    }

    pWirelessPolicyState->pszDirectoryPolicyDN = pszDirectoryPolicyDN; 

    //
    // Keep pWirelessPolicyState->pWirelessPolicyData.
    // Keep pWirelessPolicyState->pWirelessPolicyObject.
    // Change the incarnation numbers.
    //

    pWirelessPolicyState->DSIncarnationNumber = pWirelessPolicyState->RegIncarnationNumber;

    pWirelessPolicyState->RegIncarnationNumber = 0;

    pWirelessPolicyState->dwCurrentState = POLL_STATE_DS_DOWNLOADED;
    _WirelessDbg(TRC_NOTIF, "DBASE: Wireless Policy - Policy in sync with DC ");
    
    _WirelessDbg(TRC_STATE, "Policy State :: DS Downloaded ");
    
    //
    // Keep pWirelessPolicyState->CurrentPollingInterval.
    // Keep pWirelessPolicyState->DefaultPollingInterval.
    //

    gCurrentPollingInterval = pWirelessPolicyState->CurrentPollingInterval;


error:

    return (dwError);
}


DWORD
UpdateFromCacheToDS(
    PWIRELESS_POLICY_STATE pWirelessPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    DWORD dwStoreType = WIRELESS_DIRECTORY_PROVIDER;
    DWORD dwSlientErrorCode = 0;


    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LoadDirectoryPolicy(
                  pszDirectoryPolicyDN,
                  &pWirelessPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    __try {
    dwError = UnmarshallWirelessPolicyObject(
                 pWirelessPolicyObject,
                 dwStoreType,
                 &pWirelessPolicyData
                 ); 
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwError = ERROR_INVALID_DATA;
    	}
    
   BAIL_ON_WIN32_ERROR(dwError);

   _WirelessDbg(TRC_NOTIF, "DBASE: Wireless Policy - Policy in Sync with DC ");
   


    dwError = UpdatePolicyInformation(
                  pWirelessPolicyState->pWirelessPolicyData,
                  pWirelessPolicyData
                  );

    if (pWirelessPolicyState->pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyState->pWirelessPolicyObject);
    }

    if (pWirelessPolicyState->pWirelessPolicyData) {
        FreeWirelessPolicyData(pWirelessPolicyState->pWirelessPolicyData);
    }

    if (pWirelessPolicyState->pszCachePolicyDN) {
        FreeSPDStr(pWirelessPolicyState->pszCachePolicyDN);
    }

    //
    // Now delete the old cache and write the new one in.
    //

    DeleteRegistryCache();

    CacheDirectorytoRegistry(pWirelessPolicyObject);

    pWirelessPolicyState->pWirelessPolicyObject = pWirelessPolicyObject;

    pWirelessPolicyState->pWirelessPolicyData = pWirelessPolicyData;

    pWirelessPolicyState->pszDirectoryPolicyDN = pszDirectoryPolicyDN;

    //
    // Set the state to DS-DOWNLOADED.
    //

    pWirelessPolicyState->dwCurrentState = POLL_STATE_DS_DOWNLOADED;
    _WirelessDbg(TRC_STATE, "Policy State :: DS Downloaded ");
    
    _WirelessDbg(TRC_NOTIF, "DBASE: Wireless Policy Synced with DS ");
    
    //
    // Compute the new polling interval.
    //

    pWirelessPolicyState->CurrentPollingInterval =  pWirelessPolicyData->dwPollingInterval;

    pWirelessPolicyState->DSIncarnationNumber = pWirelessPolicyData->dwWhenChanged;

    pWirelessPolicyState->RegIncarnationNumber = 0;

    gCurrentPollingInterval = pWirelessPolicyState->CurrentPollingInterval;

    //NotifyWirelessPolicyChange();

    dwError = ERROR_SUCCESS;
   
    return (dwError);

error:

    if (pszDirectoryPolicyDN) {
        FreeSPDStr(pszDirectoryPolicyDN);
    }

    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyObject);
    }

    if (pWirelessPolicyData) {
        FreeWirelessPolicyData(pWirelessPolicyData);
    }

    return (dwError);
}


DWORD
GetRegistryIncarnationNumber(
    LPWSTR pszWirelessPolicyDN,
    DWORD * pdwIncarnationNumber
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    DWORD dwType = REG_DWORD;
    DWORD dwWhenChanged = 0;
    DWORD dwSize = sizeof(DWORD);


    *pdwIncarnationNumber = 0;

    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  pszWirelessPolicyDN,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegQueryValueExW(
                  hRegKey,
                  L"whenChanged",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwWhenChanged,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

     *pdwIncarnationNumber = dwWhenChanged;

error:

    if (hRegKey) {
        CloseHandle(hRegKey);
    }

    return(dwError);
}


DWORD
UpdatePolicyInformation(
    PWIRELESS_POLICY_DATA pOldWirelessPolicyData,
    PWIRELESS_POLICY_DATA pNewWirelessPolicyData
    )
{
    DWORD dwError = 0;
    _WirelessDbg(TRC_TRACK, "Updating Policy Information");
    
    _WirelessDbg(TRC_TRACK, "Old Policy is ");
    printPolicy(pOldWirelessPolicyData);
    _WirelessDbg(TRC_TRACK, "New Policy is ");
    printPolicy(pNewWirelessPolicyData);
    

    _WirelessDbg(TRC_NOTIF, "DBASE: Wireless Policy - Updating Policy for Zero Conf / 802.1x ");
    
    
    dwError = AddWZCPolicy(pNewWirelessPolicyData);
    if (dwError) {
    	_WirelessDbg(TRC_ERR, "Error in Updating the Zero Conf Policy Error Code %d ", dwError);
    	
    	dwError = ERROR_SUCCESS;
    } else 
    {
         _WirelessDbg(TRC_TRACK, "Policy Update for Zero Conf Successful ");
         
    }


    dwError = AddEapolPolicy(pNewWirelessPolicyData);
    if (dwError) {
        _WirelessDbg(TRC_ERR, "Error in Applying EAPOL Policy Error Code %d ", dwError);
        
        dwError = ERROR_SUCCESS;
    } else
    {
         _WirelessDbg(TRC_TRACK, "Policy Update for EAPOL Successful ");
         
    }
    
    return (dwError);
}

DWORD
AddPolicyInformation(
    PWIRELESS_POLICY_DATA pWirelessPolicyData
    )
{
    DWORD dwError = 0;

    _WirelessDbg(TRC_TRACK, "Adding Policy ");
    

    _WirelessDbg(TRC_NOTIF, "DBASE: Wireless Policy - Adding Policy for Zero Conf / 802.1x ");
    
    // Find the diff here. 
    // Compare that Guids are same and the dwChanged are same..
    // Then look for other differences

    
    dwError = AddWZCPolicy(pWirelessPolicyData);
    if (dwError) {
    	_WirelessDbg(TRC_ERR, "Error in ADDing Zero Conf the Policy Error Code  %d ", dwError);
    	
    	dwError = ERROR_SUCCESS;
    	} else 
    	{
        _WirelessDbg(TRC_TRACK, "ZeroConf Policy Addition Succesful ");
        
       }

    dwError = AddEapolPolicy(pWirelessPolicyData);
    if (dwError) {
        _WirelessDbg(TRC_ERR, "Error in Adding EAPOL Policy Error Code %d ", dwError);
        
        dwError = ERROR_SUCCESS;
    } else 
    {
        _WirelessDbg(TRC_TRACK, "EAPOL Policy Addition Succesful ");
        
    }
    
    return (dwError);
}


DWORD 
AddWZCPolicy(PWIRELESS_POLICY_DATA pWirelessPolicyData) 
{


    DWORD dwError = 0;
    DWORD i=0;
    DWORD dwNumPSSettings  = 0;
    DWORD dwCtlFlags = 0;

    PINTF_ENTRY pIntfEntry = NULL;
    PWZC_802_11_CONFIG_LIST pWZCConfigList = NULL;
    DWORD dwWZCConfigListSize = 0;
    PWZC_WLAN_CONFIG pWZCConfig = NULL;
    PWIRELESS_PS_DATA *ppWirelessPSData = NULL;
    DWORD dwInFlags = 0;
    DWORD dwOutFlags = 0;
    DWORD dwSSIDSize = 0;
    WCHAR pszTempSSID[33];
    BYTE pszOutSSID[33];

    
    _WirelessDbg(TRC_TRACK,  "Adding Wireless Zero Config Informaiton ");
    
    printPolicy(pWirelessPolicyData);
    

    pIntfEntry = (PINTF_ENTRY) AllocSPDMem(sizeof(INTF_ENTRY));
    if (!pIntfEntry) {
    	dwError = GetLastError();
    }

    if (!pWirelessPolicyData) {

        dwInFlags |= INTF_ALL_FLAGS;
        dwInFlags |= INTF_PREFLIST;
        pIntfEntry->rdStSSIDList.dwDataLen = 0;
        pIntfEntry->rdStSSIDList.pData = NULL;
        
        dwError = LstSetInterface(dwInFlags, pIntfEntry, &dwOutFlags);
        return (dwError);
    }

     if (pWirelessPolicyData->dwDisableZeroConf == 0) {
        dwCtlFlags |= INTFCTL_ENABLED;
    	}

    if (pWirelessPolicyData->dwConnectToNonPreferredNtwks) {
    	dwCtlFlags |= INTFCTL_FALLBACK;
    	}

    switch (pWirelessPolicyData->dwNetworkToAccess) {

    	case WIRELESS_ACCESS_NETWORK_ANY :

    		dwCtlFlags  |= INTFCTL_CM_MASK & Ndis802_11AutoUnknown; 
    		break;

    	case WIRELESS_ACCESS_NETWORK_AP :

              dwCtlFlags  |= INTFCTL_CM_MASK & Ndis802_11Infrastructure;
    		break;

       case WIRELESS_ACCESS_NETWORK_ADHOC:

       	dwCtlFlags |= INTFCTL_CM_MASK & Ndis802_11IBSS;
       	break;


       default:
       	dwCtlFlags  |= INTFCTL_CM_MASK & Ndis802_11AutoUnknown; 
    		break;

    	}

    dwCtlFlags |= INTFCTL_POLICY;
    dwCtlFlags |= INTFCTL_VOLATILE;
    

    dwNumPSSettings = pWirelessPolicyData->dwNumPreferredSettings;
    if (dwNumPSSettings != 0) {
        dwWZCConfigListSize = (dwNumPSSettings-1) * sizeof(WZC_WLAN_CONFIG) + sizeof(WZC_802_11_CONFIG_LIST);
    } else 
    {
         dwWZCConfigListSize = sizeof(WZC_802_11_CONFIG_LIST);
    }
    
    
    pWZCConfigList =  (PWZC_802_11_CONFIG_LIST) AllocSPDMem(dwWZCConfigListSize);

    if (!pWZCConfigList) {
    	dwError = GetLastError();
    	BAIL_ON_WIN32_ERROR(dwError);
    }

   pWZCConfig = (PWZC_WLAN_CONFIG) &(pWZCConfigList->Config);
   
   ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
   
   for (i = 0; i < dwNumPSSettings; ++i) {

       // If the SSID is 32 bit in length, we need to null terminate it so that the following call succeeds.
       // SSid cannont take more than 32 bytes.. it becomes an issue with 32 byte SSID ..as it cannot null
       // terminate it. So copy to a temp variable and then copy 32 bytes.

       wcsncpy(pszTempSSID, ppWirelessPSData[i]->pszWirelessSSID, 32);
     	pszTempSSID[32] = L'\0';

   	dwSSIDSize = WideCharToMultiByte (
   		CP_ACP,
              0,
              pszTempSSID,   //ppWirelessPSData[i]->pszWirelessSSID,
              -1,
              pszOutSSID,
              MAX_SSID_LEN +1 ,
              NULL,
              NULL);
   	
   	if (dwSSIDSize == 0) 
       {
            dwError = GetLastError();
       }
   	
   	BAIL_ON_WIN32_ERROR(dwError);

   	memcpy(pWZCConfig[i].Ssid.Ssid, pszOutSSID, 32);

       pWZCConfig[i].Ssid.SsidLength = dwSSIDSize -1; 

       if (ppWirelessPSData[i]->dwNetworkType == WIRELESS_NETWORK_TYPE_ADHOC)
       {
       	pWZCConfig[i].InfrastructureMode = Ndis802_11IBSS;
      	} else {
      	
              pWZCConfig[i].InfrastructureMode = Ndis802_11Infrastructure;
      	}

       if (ppWirelessPSData[i]->dwNetworkAuthentication) {
       	
       	pWZCConfig[i].AuthenticationMode = Ndis802_11AuthModeShared;

       } else {
       
             pWZCConfig[i].AuthenticationMode = Ndis802_11AuthModeOpen;
       }

       if (ppWirelessPSData[i]->dwWepEnabled) {
       	pWZCConfig[i].Privacy = 1;
       } else {
             pWZCConfig[i].Privacy = 0;
       }

       pWZCConfig[i].dwCtlFlags = 0;
       
       if (ppWirelessPSData[i]->dwAutomaticKeyProvision) {

           pWZCConfig[i].dwCtlFlags &=  ~WZCCTL_WEPK_PRESENT;
	   pWZCConfig[i].KeyLength = 0;

       } else {

           pWZCConfig[i].dwCtlFlags |=  WZCCTL_WEPK_PRESENT;
           pWZCConfig[i].KeyLength = 5;
       }
       
       pWZCConfig[i].dwCtlFlags |= WZCCTL_VOLATILE;
       pWZCConfig[i].dwCtlFlags |= WZCCTL_POLICY;

       pWZCConfig[i].Length = sizeof(WZC_WLAN_CONFIG);
       
   }

   pWZCConfigList->NumberOfItems = dwNumPSSettings;
   pWZCConfigList->Index = dwNumPSSettings;

   pIntfEntry->dwCtlFlags = dwCtlFlags;
   pIntfEntry->rdStSSIDList.dwDataLen = dwWZCConfigListSize;
   pIntfEntry->rdStSSIDList.pData = (LPBYTE) pWZCConfigList;

   dwInFlags |= INTF_ALL_FLAGS;
   dwInFlags |= INTF_PREFLIST;

   dwError = LstSetInterface(dwInFlags, pIntfEntry, &dwOutFlags);
   
error:

    if (pWZCConfigList) 
    	FreeSPDMem(pWZCConfigList);

    if (pIntfEntry)
    	FreeSPDMem(pIntfEntry);

    return (dwError);
}



DWORD
AddEapolPolicy(PWIRELESS_POLICY_DATA pWirelessPolicyData)
{
    DWORD dwError = 0;
    PEAPOL_POLICY_LIST pEapolPolicyList = NULL;

    dwError = ConvertWirelessPolicyDataToEAPOLList(
        pWirelessPolicyData, 
        &pEapolPolicyList
        );
    BAIL_ON_WIN32_ERROR(dwError);

    _WirelessDbg(TRC_TRACK, "Calling into EAPOL API ");
    
    dwError = ElPolicyChange(pEapolPolicyList);

    _WirelessDbg(TRC_TRACK, "Call to EAPOL API returned with code %d ", dwError);

    if (pEapolPolicyList) {
    	FreeEAPOLList(pEapolPolicyList);
    }

error:

    return(dwError);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\policyinput.c ===
#include "precomp.h"



DWORD 
printPS(PWIRELESS_PS_DATA pWirelessPSData) 
{

DWORD dwError = 0;
DWORD i = 0;
 

if (!pWirelessPSData) {
   	dwError = ERROR_OUTOFMEMORY;
   	BAIL_ON_WIN32_ERROR(dwError);
   	}

_WirelessDbg(TRC_TRACK, "SSID: %S",pWirelessPSData->pszWirelessSSID);
_WirelessDbg(TRC_TRACK, "SSIDLen: %d",pWirelessPSData->dwWirelessSSIDLen);
_WirelessDbg(TRC_TRACK, "WepEnabled: %d",pWirelessPSData->dwWepEnabled);
_WirelessDbg(TRC_TRACK, "Id: %d",pWirelessPSData->dwId);
_WirelessDbg(TRC_TRACK, "Network Type: %d",pWirelessPSData->dwNetworkType);
_WirelessDbg(TRC_TRACK, "NetworkAuthentication: %d",pWirelessPSData->dwNetworkAuthentication);
_WirelessDbg(TRC_TRACK, "Automatic Key Provision: %d",pWirelessPSData->dwAutomaticKeyProvision);
_WirelessDbg(TRC_TRACK, "Enable8021x: %d",pWirelessPSData->dwEnable8021x);
_WirelessDbg(TRC_TRACK, "Enable8021xMode: %d",pWirelessPSData->dw8021xMode);
_WirelessDbg(TRC_TRACK, "Eap Type: %d",pWirelessPSData->dwEapType);
_WirelessDbg(TRC_TRACK, "EAP Data Len: %d",pWirelessPSData->dwEAPDataLen);
if (pWirelessPSData->dwEAPDataLen) {
    _WirelessDbg(TRC_TRACK, "EAP Data is: ");
     WLPOLICY_DUMPB(pWirelessPSData->pbEAPData,pWirelessPSData->dwEAPDataLen);
}
_WirelessDbg(TRC_TRACK, "Machine Authentication: %d",pWirelessPSData->dwMachineAuthentication);
_WirelessDbg(TRC_TRACK, "MachineAuthenticationType: %d",pWirelessPSData->dwMachineAuthenticationType);
_WirelessDbg(TRC_TRACK, "GuestAuthentication: %d",pWirelessPSData->dwGuestAuthentication);
_WirelessDbg(TRC_TRACK, "IEEE 8021x MaxStart: %d",pWirelessPSData->dwIEEE8021xMaxStart);
_WirelessDbg(TRC_TRACK, "IEEE 8021x Start Period: %d",pWirelessPSData->dwIEEE8021xStartPeriod);
_WirelessDbg(TRC_TRACK, "IEEE 8021x Auth Period: %d",pWirelessPSData->dwIEEE8021xAuthPeriod);
_WirelessDbg(TRC_TRACK, "IEEE 8021x Held Period: %d",pWirelessPSData->dwIEEE8021xHeldPeriod);
_WirelessDbg(TRC_TRACK, "IEEE Preferrerd Setting Description: ");
if (pWirelessPSData->pszDescription) {
	_WirelessDbg(TRC_TRACK, "%S",pWirelessPSData->pszDescription);
}
_WirelessDbg(TRC_TRACK, "Description Len: %d",pWirelessPSData->dwDescriptionLen);

_WirelessDbg(TRC_TRACK,  "TotalSize: %d",pWirelessPSData->dwPSLen);

error:

    return(dwError);

}

DWORD 
printPolicy(PWIRELESS_POLICY_DATA pWirelessPolicyData) 
{

DWORD dwError = 0;
DWORD i = 0;
DWORD dwNumPreferredSettings = 0;
PWIRELESS_PS_DATA *ppWirelessPSDatas = NULL;
LPWSTR pszStringUuid = NULL;

_WirelessDbg(TRC_TRACK,  " Policy is ");

if (!pWirelessPolicyData) {
   	dwError = ERROR_OUTOFMEMORY;
   	BAIL_ON_WIN32_ERROR(dwError);
   	}

dwError = UuidToString(
                    &pWirelessPolicyData->PolicyIdentifier,
                    &pszStringUuid
                    );
_WirelessDbg(TRC_TRACK,  "Policy ID: %S ",pszStringUuid);
_WirelessDbg(TRC_TRACK,  "Policy Name: %S",pWirelessPolicyData->pszWirelessName);
_WirelessDbg(TRC_TRACK,  "Policy Description: %S",pWirelessPolicyData->pszDescription);
_WirelessDbg(TRC_TRACK,  "Disable Zero Conf: %d",pWirelessPolicyData->dwDisableZeroConf);
_WirelessDbg(TRC_TRACK,  "Network To Access: %d",pWirelessPolicyData->dwNetworkToAccess);
_WirelessDbg(TRC_TRACK,  "Polling Interval: %d",pWirelessPolicyData->dwPollingInterval);
_WirelessDbg(TRC_TRACK,  "Connect To Non Preferred networks: %d",pWirelessPolicyData->dwConnectToNonPreferredNtwks);
_WirelessDbg(TRC_TRACK,  "Num Preferred Settings: %d",pWirelessPolicyData->dwNumPreferredSettings);
_WirelessDbg(TRC_TRACK,  "Num AP Networks:  %d",pWirelessPolicyData->dwNumAPNetworks);

dwNumPreferredSettings = pWirelessPolicyData->dwNumPreferredSettings;
ppWirelessPSDatas = pWirelessPolicyData->ppWirelessPSData;
for(i=0;i< pWirelessPolicyData->dwNumPreferredSettings;++i) {
	_WirelessDbg(TRC_TRACK,  "Printing PS %d ",i);
	printPS(*(ppWirelessPSDatas+i));	
}	
return (0);

error:
	

    return(dwError);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\security.c ===
#include "precomp.h"


GENERIC_MAPPING GenericMapping[SPD_OBJECT_COUNT] = {
    {
      SERVER_READ,
      SERVER_WRITE,
      SERVER_EXECUTE,
      SERVER_ALL_ACCESS
    }
};


DWORD
InitializeSPDSecurity(
    PSECURITY_DESCRIPTOR * ppSPDSD
    )
{
    DWORD dwError = 0;
    BOOL bOK = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID pAdminAliasSid = NULL;
    DWORD dwAceCount = 0;
    UCHAR AceType[MAX_ACE];
    PSID AceSid[MAX_ACE];
    ACCESS_MASK AceMask[MAX_ACE];
    BYTE InheritFlags[MAX_ACE];
    DWORD dwObjectType = SPD_OBJECT_SERVER;
    PSECURITY_DESCRIPTOR pSPDSD = NULL;


    //
    // Administrator Alias SID.
    //

    bOK = AllocateAndInitializeSid(
              &NtAuthority,
              2,
              SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_ADMINS,
              0, 0, 0, 0, 0, 0,
              &pAdminAliasSid
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    AceType[dwAceCount] = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[dwAceCount] = pAdminAliasSid;
    AceMask[dwAceCount] = SERVER_ALL_ACCESS;
    InheritFlags[dwAceCount] = 0;
    dwAceCount++;

    AceType[dwAceCount] = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[dwAceCount] = pAdminAliasSid;
    AceMask[dwAceCount] = GENERIC_ALL;
    InheritFlags[dwAceCount] = INHERIT_ONLY_ACE |
                               CONTAINER_INHERIT_ACE |
                               OBJECT_INHERIT_ACE;
    dwAceCount++;

    if (dwAceCount > MAX_ACE) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = BuildSPDObjectProtection(
                  dwAceCount,
                  AceType,
                  AceSid,
                  AceMask,
                  InheritFlags,
                  pAdminAliasSid,
                  pAdminAliasSid,
                  &GenericMapping[dwObjectType],
                  &pSPDSD
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppSPDSD = pSPDSD;

cleanup:

    if (pAdminAliasSid) {
        FreeSid(pAdminAliasSid);
    }

    return (dwError);

error:

    *ppSPDSD = NULL;

    goto cleanup;
}


DWORD
BuildSPDObjectProtection(
    DWORD dwAceCount,
    PUCHAR pAceType,
    PSID * ppAceSid,
    PACCESS_MASK pAceMask,
    PBYTE pInheritFlags,
    PSID pOwnerSid,
    PSID pGroupSid,
    PGENERIC_MAPPING pGenericMap,
    PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
{
    DWORD dwError = 0;
    BOOL bOK = FALSE;
    SECURITY_DESCRIPTOR Absolute;
    DWORD dwDaclLength = 0;
    DWORD i = 0;
    PACL pTmpAcl= NULL;
    PACCESS_ALLOWED_ACE pTmpAce = NULL;
    DWORD dwSDLength = 0;
    PSECURITY_DESCRIPTOR pRelative = NULL;


    bOK = InitializeSecurityDescriptor(
              &Absolute,
              SECURITY_DESCRIPTOR_REVISION1
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bOK = SetSecurityDescriptorOwner(
              &Absolute,
              pOwnerSid,
              FALSE
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bOK = SetSecurityDescriptorGroup(
              &Absolute,
              pGroupSid,
              FALSE
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Build the Discretionary ACL:
    //     Calculate its length.
    //     Allocate it.
    //     Initialize it.
    //     Add each ACE.
    //     Set ACE as InheritOnly if necessary.
    //     Add it to the security descriptor.
    //

    dwDaclLength = (DWORD) sizeof(ACL);

    for (i = 0; i < dwAceCount; i++) {

        dwDaclLength += GetLengthSid(ppAceSid[i]) +
                        (DWORD) sizeof(ACCESS_ALLOWED_ACE) -
                        (DWORD) sizeof(DWORD);

        //
        // Subtract out SidStart field length.
        //

    }

    pTmpAcl = (PACL) AllocSPDMem(dwDaclLength);

    if (!pTmpAcl) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bOK = InitializeAcl(
              pTmpAcl,
              dwDaclLength,
              ACL_REVISION2
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwAceCount; i++) {

        if (pAceType[i] == ACCESS_ALLOWED_ACE_TYPE) {
            bOK = AddAccessAllowedAce(
                      pTmpAcl,
                      ACL_REVISION2,
                      pAceMask[i],
                      ppAceSid[i]
                      );
        }
        else {
            bOK = AddAccessDeniedAce(
                      pTmpAcl,
                      ACL_REVISION2,
                      pAceMask[i],
                      ppAceSid[i]
                      );
        }
        if (!bOK) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pInheritFlags[i] != 0) {

            bOK = GetAce(pTmpAcl, i, (LPVOID *) &pTmpAce);
            if (!bOK) {
                dwError = GetLastError();
                BAIL_ON_WIN32_ERROR(dwError);
            }

            pTmpAce->Header.AceFlags = pInheritFlags[i];

        }

    }

    bOK = SetSecurityDescriptorDacl(
              &Absolute,
              TRUE,
              pTmpAcl,
              FALSE
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Convert the security descriptor from absolute to self-relative:
    //     Get the length needed.
    //     Allocate that much memory.
    //     Copy it.
    //     Free the generated absolute ACLs.
    //

    dwSDLength = GetSecurityDescriptorLength(&Absolute);

    //
    // Must allocate the relative SD from heap.
    //

    pRelative = LocalAlloc(0, dwSDLength);
    if (!pRelative) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bOK = MakeSelfRelativeSD(&Absolute, pRelative, &dwSDLength);
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppSecurityDescriptor = pRelative;

cleanup:

    if (pTmpAcl){
        FreeSPDMem(pTmpAcl);
    }

    return (dwError);

error:

    *ppSecurityDescriptor = NULL;

    if (pRelative) {
        LocalFree(pRelative);
    }

    goto cleanup;
}


DWORD
ValidateSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    )
{
    DWORD dwError = 0;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    ACCESS_MASK MappedDesiredAccess = 0;
    BOOL bOK = FALSE;
    HANDLE hClientToken = NULL;
    BYTE PrivilegeSetBuffer[256];
    DWORD dwPrivilegeSetBufferLen = 256;
    PPRIVILEGE_SET pPrivilegeSet = NULL;
    BOOL bAccessCheckOK = FALSE;
    ACCESS_MASK GrantedAccess = 0;
    BOOL bAccessStatus = FALSE;


    memset(PrivilegeSetBuffer, 0, dwPrivilegeSetBufferLen);

    switch (dwObjectType) {

    case SPD_OBJECT_SERVER:
        pSecurityDescriptor = gpSPDSD;
        break;

    default:
        dwError = ERROR_ACCESS_DENIED;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    MapGenericToSpecificAccess(
        dwObjectType,
        DesiredAccess,
        &MappedDesiredAccess
        );

    bOK = GetTokenHandle(&hClientToken);
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pPrivilegeSet = (PPRIVILEGE_SET) PrivilegeSetBuffer;

    bAccessCheckOK = AccessCheck(
                         pSecurityDescriptor,
                         hClientToken,
                         MappedDesiredAccess,
                         &GenericMapping[dwObjectType],
                         pPrivilegeSet,
                         &dwPrivilegeSetBufferLen,
                         &GrantedAccess,
                         &bAccessStatus
                         );
    if (!bAccessCheckOK) {
        if (GetLastError() == ERROR_NO_IMPERSONATION_TOKEN) {
            dwError = ERROR_SUCCESS;
            GrantedAccess = MappedDesiredAccess;
        }
        else {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    else {
        if (!bAccessStatus) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pGrantedAccess) {
        *pGrantedAccess = GrantedAccess;
    }

cleanup:

    if (hClientToken) {
        CloseHandle(hClientToken);
    }

    return (dwError);

error:

    if (pGrantedAccess) {
        *pGrantedAccess = 0;
    }

    goto cleanup;
}


VOID
MapGenericToSpecificAccess(
    DWORD dwObjectType,
    ACCESS_MASK GenericAccess,
    PACCESS_MASK pSpecificAccess
    )
{
    *pSpecificAccess = GenericAccess;

    MapGenericMask(
        pSpecificAccess,
        &GenericMapping[dwObjectType]
        );
}


BOOL
GetTokenHandle(
    PHANDLE phToken
    )
{
    if (!OpenThreadToken(
            GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            TRUE,
            phToken)) {

        if (GetLastError() == ERROR_NO_TOKEN) {

            //
            // This means that there's no impersonation.
            // Get the token out of the process.
            //

            if (!OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                    phToken)) {
                return (FALSE);
            }

        } 
        else {
            return (FALSE);
        }

    }

    return (TRUE);
}

#ifdef TAROONZERO
DWORD
ValidateMMSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    )
{
    DWORD dwError = 0;
    ACCESS_MASK GrantedAccess = 0;


    dwError = ValidateSecurity(
                  dwObjectType,
                  DesiredAccess,
                  pObjectHandle,
                  &GrantedAccess
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pGrantedAccess) {
        *pGrantedAccess = GrantedAccess;
    }

    return (dwError);

error:

    if (pGrantedAccess) {
        *pGrantedAccess = 0;
    }

    return (dwError);
}


DWORD
ValidateTxSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    )
{
    DWORD dwError = 0;
    ACCESS_MASK GrantedAccess = 0;


    dwError = ValidateSecurity(
                  dwObjectType,
                  DesiredAccess,
                  pObjectHandle,
                  &GrantedAccess
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pGrantedAccess) {
        *pGrantedAccess = GrantedAccess;
    }

    return (dwError);

error:

    if (pGrantedAccess) {
        *pGrantedAccess = 0;
    }

    return (dwError);
}


DWORD
ValidateTnSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    )
{
    DWORD dwError = 0;
    ACCESS_MASK GrantedAccess = 0;


    dwError = ValidateSecurity(
                  dwObjectType,
                  DesiredAccess,
                  pObjectHandle,
                  &GrantedAccess
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pGrantedAccess) {
        *pGrantedAccess = GrantedAccess;
    }

    return (dwError);

error:

    if (pGrantedAccess) {
        *pGrantedAccess = 0;
    }

    return (dwError);
}
#endif TAROONZERO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\structs.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    structs.h

Abstract:

    This module contains all of the internal structures
    for WirelessPOL Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


#define TCP_PROTOCOL     6

#define UDP_PROTOCOL    17


#define WEIGHT_ADDRESS_TIE_BREAKER          0x00000001
#define WEIGHT_SPECIFIC_SOURCE_PORT         0x00000002
#define WEIGHT_SPECIFIC_DESTINATION_PORT    0x00000004
#define WEIGHT_SPECIFIC_PROTOCOL            0x00000100
 


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\tracing.h ===
#define WIFI_TRC_NAME        TEXT("Wlpolicy")

// trace identifier
extern DWORD            g_TraceLog;

#define TRC_TRACK       0x00020000      // logs the code path
#define TRC_ERR         0x00080000      // logs error conditions
#define TRC_NOTIF       0x00200000      // Messages meant for DBASE
#define TRC_STATE       0x01000000      // logs state machine related stuff


// debug utility calls
VOID _WirelessDbg(DWORD dwFlags, LPCSTR lpFormat, ...);

VOID WiFiTrcInit();

VOID WiFiTrcTerm();

#define WLPOLICY_DUMPB(pbBuf,dwBuf)                                        \
        TraceDumpEx(g_TraceLog, TRC_TRACK | TRACE_USE_MASK,(LPBYTE)pbBuf,dwBuf,1,0,NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\utils.h ===
BOOL
AreGuidsEqual(
    GUID OldGuid,
    GUID gNewGuid
    );

VOID
CopyGuid(
    GUID gInGuid,
    GUID * pgOutGuid
    );

DWORD
CopyName(
    LPWSTR pszInName,
    LPWSTR * ppszOutName
    );

BOOL
AreNamesEqual(
    LPWSTR pszOldName,
    LPWSTR pszNewName
    );

DWORD
SPDImpersonateClient(
    PBOOL pbImpersonating
    );

VOID
SPDRevertToSelf(
    BOOL bImpersonating
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\tracing.c ===
#include "precomp.h"

// global tracing variables
DWORD g_WirelessTraceLog;

// debug utility calls
VOID _WirelessDbg(DWORD dwFlags, LPCSTR lpFormat, ...)
{
    va_list arglist;
    va_start(arglist, lpFormat);

    TraceVprintfExA(
        g_WirelessTraceLog,
        dwFlags | TRACE_USE_MASK,
        lpFormat,
        arglist);
}


VOID WiFiTrcInit()
{
    g_WirelessTraceLog = TraceRegister(WIFI_TRC_NAME);
}

VOID WiFiTrcTerm()
{
    TraceDeregister(g_WirelessTraceLog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\utils.c ===
#include "precomp.h"


BOOL
AreGuidsEqual(
    GUID gOldGuid,
    GUID gNewGuid
    )
{
    if (!memcmp(
            &(gOldGuid),
            &(gNewGuid),
            sizeof(GUID))) {
        return (TRUE);
    }

    return (FALSE);
}


VOID
CopyGuid(
    GUID gInGuid,
    GUID * pgOutGuid
    )
{
    memcpy(
        pgOutGuid,
        &gInGuid,
        sizeof(GUID)
        );
}

/*
DWORD
CopyName(
    LPWSTR pszInName,
    LPWSTR * ppszOutName
    )
{
    DWORD dwError = 0;
    LPWSTR pszOutName = NULL;


    if (pszInName && *(pszInName)) {

        dwError = SPDApiBufferAllocate(
                      wcslen(pszInName)*sizeof(WCHAR) + sizeof(WCHAR),
                      &pszOutName
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        wcscpy(pszOutName, pszInName);

    }

    *ppszOutName = pszOutName;
    return (dwError);

error:

    *ppszOutName = NULL;
    return (dwError);
}


DWORD
SPDApiBufferAllocate(
    DWORD dwByteCount,
    LPVOID * ppBuffer
    )
{
    DWORD dwError = 0;

    if (ppBuffer == NULL) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppBuffer = NULL;
    *ppBuffer = MIDL_user_allocate(dwByteCount);

    if (*ppBuffer == NULL) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        memset((LPBYTE) *ppBuffer, 0, dwByteCount);
    }

error:

    return (dwError);
}


VOID
SPDApiBufferFree(
    LPVOID pBuffer
    )
{
    if (pBuffer) {
        MIDL_user_free(pBuffer);
    }
}

*/
BOOL
AreNamesEqual(
    LPWSTR pszOldName,
    LPWSTR pszNewName
    )
{
    BOOL bEqual = FALSE;


    if (pszOldName && *pszOldName) {

        if (!pszNewName || !*pszNewName) {
            bEqual = FALSE;
        }
        else {

            if (!_wcsicmp(pszOldName, pszNewName)) {
                bEqual = TRUE;
            }
            else {
                bEqual = FALSE;
            }

        }

    }
    else {

        if (!pszNewName || !*pszNewName) {
            bEqual = TRUE;
        }
        else {
            bEqual = FALSE;
        }

    }

    return (bEqual);
}


DWORD
SPDImpersonateClient(
    PBOOL pbImpersonating
    )
{
    DWORD dwError = 0;


    dwError = RpcImpersonateClient(NULL);
    BAIL_ON_WIN32_ERROR(dwError);

    *pbImpersonating = TRUE;
    return (dwError);

error:

    *pbImpersonating = FALSE;
    return (dwError);
}


VOID
SPDRevertToSelf(
    BOOL bImpersonating
    )
{
    if (bImpersonating) {
        RpcRevertToSelf();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\wirelessspd.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    ipsecspd.c

Abstract:

    This module contains all of the code to drive
    the WirelessPOl Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD WINAPI InitWirelessPolicy ( )
{
    DWORD dwError = 0;

    InitMiscGlobals();

    dwError = InitSPDThruRegistry();
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    
    dwError = InitSPDGlobals();
    BAIL_ON_WIN32_ERROR(dwError);

    _WirelessDbg(TRC_TRACK, "Starting the Service Wait Loop ");
    

    InitializePolicyStateBlock(
        gpWirelessPolicyState
        );

     // Intialize the policy Engine with Cached Wireless Policy


     dwError = PlumbCachePolicy(
         gpWirelessPolicyState
          );

     if (dwError) {
         gpWirelessPolicyState->dwCurrentState = POLL_STATE_INITIAL;

         _WirelessDbg(TRC_STATE, "Policy State :: Initial State ");
         

         gCurrentPollingInterval = gpWirelessPolicyState->DefaultPollingInterval;
         dwError = 0;      // dont return this error 
     	}


    return(dwError);
    
error:

    WirelessSPDShutdown(dwError);

    return(dwError);
}


VOID
WirelessSPDShutdown(
    IN DWORD dwErrorCode
    )
{
/*
    gbIKENotify = FALSE;
    */
    
    DeletePolicyInformation(NULL);

    ClearPolicyStateBlock(
        gpWirelessPolicyState
        );

    ClearSPDGlobals();
    return;
}


VOID
ClearSPDGlobals(
    )
{
    
    if (ghNewDSPolicyEvent) {
        CloseHandle(ghNewDSPolicyEvent);
        ghNewDSPolicyEvent = NULL;
    }
    
    if (ghForcedPolicyReloadEvent) {
        CloseHandle(ghForcedPolicyReloadEvent);
        ghForcedPolicyReloadEvent = NULL;
    }

    if (ghPolicyChangeNotifyEvent) {
        CloseHandle(ghPolicyChangeNotifyEvent);
        ghPolicyChangeNotifyEvent = NULL;
    }

    if (ghPolicyEngineStopEvent) {
    	CloseHandle(ghPolicyEngineStopEvent);
    	}

    if (ghReApplyPolicy8021x) {
    	CloseHandle(ghReApplyPolicy8021x);
    	}
    
    /*
    if (gbSPDAuditSection) {
        DeleteCriticalSection(&gcSPDAuditSection);
    }
    
    
    if (gpSPDSD) {
        LocalFree(gpSPDSD);
        gpSPDSD = NULL;
        
    }
    */
}


VOID
InitMiscGlobals(
    )
{
    //
    // Init globals that aren't cleared on service stop to make sure
    // everything's in a known state on start.  This allows us to
    // stop/restart without having our DLL unloaded/reloaded first.
    //

    gpWirelessPolicyState        = &gWirelessPolicyState;
    gCurrentPollingInterval   = 0;
    gDefaultPollingInterval   = 166*60; // (seconds).
    gpszWirelessDSPolicyKey      = L"SOFTWARE\\Policies\\Microsoft\\Windows\\Wireless\\GPTWirelessPolicy";
    gpszWirelessCachePolicyKey   = L"SOFTWARE\\Policies\\Microsoft\\Windows\\Wireless\\Policy\\Cache";
    gpszLocPolicyAgent        = L"SYSTEM\\CurrentControlSet\\Services\\WZCSVC";
    gdwDSConnectivityCheck    = 0;
    ghNewDSPolicyEvent        = NULL;
    ghForcedPolicyReloadEvent = NULL;
    ghPolicyChangeNotifyEvent = NULL;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\wifiext.h ===
extern 
DWORD
ElPolicyChange(
    IN PEAPOL_POLICY_LIST pEAPOLPolicyList
    );

extern
DWORD
LstSetInterface(
    DWORD       dwInFlags,
    PINTF_ENTRY pIntfEntry,
    LPDWORD     pdwOutFlags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlpolicy\wirelessspd.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    wirelessspd.h

Abstract:

    This module contains all of the code prototypes
    to drive the wireless Policy .

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


#define SERVICE_CONTROL_NEW_LOCAL_POLICY 129

#define SERVICE_CONTROL_FORCED_POLICY_RELOAD 130





VOID
WirelessSPDShutdown(
    IN DWORD    dwErrorCode
    );


VOID
ClearSPDGlobals(
    );



VOID
InitMiscGlobals(
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\about.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       
//
//  Contents:   About Pane
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "about.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// TODO: none of this CSnapinAboutImpl code appears to be working

CSnapinAboutImpl::CSnapinAboutImpl()
{
}


CSnapinAboutImpl::~CSnapinAboutImpl()
{
}

HRESULT CSnapinAboutImpl::AboutHelper(UINT nID, CString* pAddString, LPOLESTR* lpPtr)
{
    if (lpPtr == NULL)
        return E_POINTER;
    
    CString s;
    
    // Needed for Loadstring
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    s.LoadString(nID);
    
    if (pAddString != NULL)
    {
        s += *pAddString;
    }
    
    *lpPtr = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc((s.GetLength() + 1)* sizeof(wchar_t)));
    
    if (*lpPtr == NULL)
        return E_OUTOFMEMORY;
    
    lstrcpy(*lpPtr, (LPCTSTR)s);
    
    return S_OK;
}


STDMETHODIMP CSnapinAboutImpl::GetSnapinDescription(LPOLESTR* lpDescription)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return AboutHelper(IDS_DESCRIPTION, lpDescription);
}


STDMETHODIMP CSnapinAboutImpl::GetProvider(LPOLESTR* lpName)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return AboutHelper(IDS_COMPANY, lpName);
}


STDMETHODIMP CSnapinAboutImpl::GetSnapinVersion(LPOLESTR* lpVersion)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    CString strAddString;
    strAddString.LoadString (IDS_ABOUTGLUESTRING);
    
    return AboutHelper(IDS_VERSION, lpVersion);
}


STDMETHODIMP CSnapinAboutImpl::GetSnapinImage(HICON* hAppIcon)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    if (hAppIcon == NULL)
        return E_POINTER;
    
    *hAppIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_APPICON));
    
    ASSERT(*hAppIcon != NULL);
    return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}


STDMETHODIMP CSnapinAboutImpl::GetStaticFolderImage(HBITMAP* hSmallImage,
                                                    HBITMAP* hSmallImageOpen,
                                                    HBITMAP* hLargeImage,
                                                    COLORREF* cLargeMask)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    if ((hSmallImage == NULL)
        || (hSmallImageOpen == NULL)
        || (hLargeImage == NULL)
        || (cLargeMask == NULL))
        return E_POINTER;
    
    *hSmallImage = LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDB_16x16));
    *hSmallImageOpen = LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDB_16x16));
    *hLargeImage = LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDB_32x32)); 
    *cLargeMask = RGB(255, 0, 255);
    
    return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\ccomp.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Ccomp.h
//
//  Contents:   Wifi Policy management Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#ifndef _CCOMP_H
#define _CCOMP_H

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// Extra cruft (where should we put this?)

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

enum CUSTOM_VIEW_ID
{
    VIEW_DEFAULT_LV = 0,
    VIEW_CALENDAR_OCX = 1,
    VIEW_MICROSOFT_URL = 2,
};

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

// forward decl
class CComponentDataImpl;

class CComponentImpl :
public IComponent,
public IExtendContextMenu,
public IExtendControlbar,
public IExtendPropertySheet,
public IResultDataCompare,
public CComObjectRoot
{
public:
    CComponentImpl();
    ~CComponentImpl();
    
    BEGIN_COM_MAP(CComponentImpl)
        COM_INTERFACE_ENTRY(IComponent)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IExtendControlbar)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(IResultDataCompare)
    END_COM_MAP()
        
        friend class CDataObject;
    static long lDataObjectRefCount;
    
    // IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    
    STDMETHOD(GetDisplayInfo)(LPRESULTDATAITEM pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT pDataObjectA, LPDATAOBJECT pDataObjectB);
    
    // IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);
    
    // IExtendControlbar interface
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    
    // IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);
    
public:
    // IPersistStream interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    
    // Helpers for CComponentImpl
public:
    void SetIComponentData(CComponentDataImpl* pData);
    
#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1
    
    // IExtendContextMenu
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, long *pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);
    
    // Helper functions
protected:
    void Construct();
    
    // Interface pointers
protected:
    LPCONSOLE           m_pConsole;   // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;  // Result pane's header control interface
    LPCOMPONENTDATA     m_pComponentData;
    LPCONSOLEVERB       m_pConsoleVerb; // pointer the console verb
    LPRESULTDATA        m_pResultData;      // My interface pointer to the result pane
    CComPtr <IControlbar> m_spControlbar;   // Used by IExtendControlbar implementation
    CComponentDataImpl*  m_pCComponentData;
    
private:
    CUSTOM_VIEW_ID  m_CustomViewID;
    DWORD   m_dwSortOrder;  // default is 0, else RSI_DESCENDING
    int     m_nSortColumn;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\ccomp.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       ccomp.cpp
//
//  Contents:   
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// contruction/descruction

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentImpl);

CComponentImpl::CComponentImpl() 
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentImpl);
    Construct();
}

CComponentImpl::~CComponentImpl()
{
#if DBG==1
    ASSERT(dbg_cRef == 0);
#endif 
    
    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentImpl);
    
    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);
}

void CComponentImpl::Construct()
{
#if DBG==1
    dbg_cRef = 0;
#endif 
    
    m_pConsole = NULL;
    m_pHeader = NULL;
    m_pResultData = NULL;
    m_pComponentData = NULL;
    m_pConsoleVerb = NULL;
    m_CustomViewID = VIEW_DEFAULT_LV;
    m_dwSortOrder = 0;  // default is 0, else RSI_DESCENDING
    m_nSortColumn = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CComponentImpl's IComponent multiple view/instance helper functions

STDMETHODIMP CComponentImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    OPT_TRACE( _T("CComponentImpl::QueryDataObject this-%p, cookie-%p\n"), this, cookie );
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    if (ppDataObject == NULL)
    {
        TRACE(_T("CComponentImpl::QueryDataObject called with ppDataObject==NULL \n"));
        return E_UNEXPECTED;
    }
    
    if (cookie == NULL)
    {
        TRACE(_T("CComponentImpl::QueryDataObject called with cookie==NULL \n"));
        return E_UNEXPECTED;
    }
    
    *ppDataObject = NULL;
    
    IUnknown* pUnk = (IUnknown *) cookie;
#ifdef _DEBUG
    HRESULT hr =  pUnk->QueryInterface( IID_IDataObject, (void**)ppDataObject );
    OPT_TRACE(_T("    QI on cookie-%p -> pDataObj-%p\n"), cookie, *ppDataObject);
    return hr;
#else
    return pUnk->QueryInterface( IID_IDataObject, (void**)ppDataObject );
#endif  //#ifdef _DEBUG
}

void CComponentImpl::SetIComponentData(CComponentDataImpl* pData)
{
    ASSERT(pData);
    ASSERT(m_pComponentData == NULL);
    LPUNKNOWN pUnk = pData->GetUnknown();
    HRESULT hr;
    
    // store their IComponentData for later use
    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));
    
    // store their CComponentData for later use
    m_pCComponentData = pData;
}

STDMETHODIMP CComponentImpl::GetResultViewType(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    ASSERT (m_CustomViewID == VIEW_DEFAULT_LV);
    return S_FALSE;
}

STDMETHODIMP CComponentImpl::Initialize(LPCONSOLE lpConsole)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr = E_UNEXPECTED;
    
    ASSERT(lpConsole != NULL);
    
    // Save the IConsole pointer 
    m_pConsole = lpConsole;
    m_pConsole->AddRef();
    
    // QI for IHeaderCtrl
    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl, reinterpret_cast<void**>(&m_pHeader));
    ASSERT (hr == S_OK);
    if (hr != S_OK)
    {
        return hr;
    }
    // Pass the IHeaderCtrl Interface on to the console
    m_pConsole->SetHeader(m_pHeader);
    
    // QI for IResultData
    hr = m_pConsole->QueryInterface(IID_IResultData, reinterpret_cast<void**>(&m_pResultData));
    ASSERT (hr == S_OK);
    if (hr != S_OK)
    {
        return hr;
    }
    // m_pCComponentData->SetResultData (m_pResultData);
    
    // get the IControlVerb interface to support enable/disable of verbs (ie CUT/PASTE etc)
    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    ASSERT(hr == S_OK);
    
    return hr;
}

STDMETHODIMP CComponentImpl::Destroy(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);
        
        SAFE_RELEASE(m_pResultData);
        
        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        SAFE_RELEASE(m_pComponentData); // QI'ed in IComponentDataImpl::CreateComponent
        
        SAFE_RELEASE(m_pConsoleVerb);
    }
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CComponentImpl's IComponent view/data helper functions
STDMETHODIMP CComponentImpl::GetDisplayInfo(LPRESULTDATAITEM pResult)
{   
    OPT_TRACE(_T("CComponentImpl::GetDisplayInfo this-%p pUnk-%p\n"), this, pResult->lParam);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    ASSERT(pResult != NULL);
    if (NULL == pResult)
        // gack!
        return E_INVALIDARG;
    
    ASSERT( NULL != pResult->lParam );
    if (NULL == pResult->lParam)
    {
        TRACE(_T("CComponentImpl::GetDisplayInfo RESULTDATAITEM.lParam == NULL\n"));
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
    
    IUnknown* pUnk = (IUnknown*)pResult->lParam;
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData( pUnk );
    if (spData == NULL)
    {
        TRACE(_T("CComponentImpl::GetDisplayInfo QI for IWirelessSnapInDataObject FAILED\n"));
        return E_UNEXPECTED;
    }
    return spData->GetResultDisplayInfo( pResult );
}

/////////////////////////////////////////////////////////////////////////////
// CComponentImpl's I????? misc helper functions 
// TODO: Some misc functions don't appear to ever be called?
STDMETHODIMP CComponentImpl::GetClassID(CLSID *pClassID)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    ASSERT (0);
    // TODO: CComponentDataImpl::GetClassID and CComponentImpl::GetClassID are identical (?)
    ASSERT(pClassID != NULL);
    
    // Copy the CLSID for this snapin
    *pClassID = CLSID_Snapin;
    
    return E_NOTIMPL;
}

// This compares two data objects to see if they are the same object.  
STDMETHODIMP CComponentImpl::CompareObjects(LPDATAOBJECT pDataObjectA, LPDATAOBJECT pDataObjectB)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    if (NULL == pDataObjectA || NULL == pDataObjectB)
        return E_INVALIDARG;
    
    HRESULT res = S_FALSE;
    
    // we need to check to make sure both objects belong to us...
    if (m_pCComponentData)
    {
        HRESULT hr;
        GUID guidA;
        GUID guidB;
        // Obtain GUID for A
        CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spDataA(pDataObjectA);
        if (spDataA == NULL)
        {
            TRACE(_T("CComponentImpl::CompareObjects - QI for IWirelessSnapInDataObject[A] FAILED\n"));
            return E_UNEXPECTED;
        }
        hr = spDataA->GetGuidForCompare( &guidA );
        ASSERT(hr == S_OK);
        
        // Obtain GUID for B
        CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spDataB(pDataObjectB);
        if (spDataB == NULL)
        {
            TRACE(_T("CComponentImpl::CompareObjects - QI for IWirelessSnapInDataObject[B] FAILED\n"));
            return E_UNEXPECTED;
        }
        hr &= spDataB->GetGuidForCompare( &guidB );
        ASSERT(hr == S_OK);
        
        // Compare GUIDs
        if (IsEqualGUID( guidA, guidB ))
        {
            return S_OK;
        } 
    }
    
    // they were not ours, or they couldn't have been ours...
    return E_UNEXPECTED;
}

// This Compare is used to sort the item's in the result pane using the C runtime's
// string comparison function.
STDMETHODIMP CComponentImpl::Compare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    OPT_TRACE(_T("CComponentImpl::Compare cookieA-%p, cookieB-%p, Column-%i, userParam-%i\n"), cookieA, cookieB, *pnResult, lUserParam );
    
    // Get pDataObject for item A
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spDataA((LPDATAOBJECT)cookieA);
    if (spDataA == NULL)
    {
        TRACE(_T("CComponentImpl::Compare - QI for IWirelessSnapInDataObject[A] FAILED\n"));
        return E_UNEXPECTED;
    }
    
    // Get pDataObject for item B
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spDataB((LPDATAOBJECT)cookieB);
    if (spDataB == NULL)
    {
        TRACE(_T("CComponentImpl::Compare - QI for IWirelessSnapInDataObject[B] FAILED\n"));
        return E_UNEXPECTED;
    }
    
    HRESULT hr = S_OK;
    do
    {
        RESULTDATAITEM rdiA;
        RESULTDATAITEM rdiB;
        
        // Obtain item A's sort string
        rdiA.mask = RDI_STR;
        rdiA.nCol = *pnResult;    // obtain string for this column
        hr = spDataA->GetResultDisplayInfo( &rdiA );
        if (hr != S_OK)
        {
            TRACE(_T("CComponentImpl::Compare - IWirelessSnapInDataObject[A].GetResultDisplayInfo FAILED\n"));
            hr = E_UNEXPECTED;
            break;
        }
        
        // Obtain item B's sort string
        rdiB.mask = RDI_STR;
        rdiB.nCol = *pnResult;    // obtain string for this column
        hr = spDataB->GetResultDisplayInfo( &rdiB );
        if (hr != S_OK)
        {
            TRACE(_T("CComponentImpl::Compare - IWirelessSnapInDataObject[B].GetResultDisplayInfo FAILED\n"));
            hr = E_UNEXPECTED;
            break;
        }
        
        // Compare strings for sort
        *pnResult = _tcsicmp( rdiA.str, rdiB.str );
    } while (0);    // simulate try block
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Event handlers for IFrame::Notify
STDMETHODIMP CComponentImpl::Notify(LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    OPT_TRACE(_T("CComponentImpl::Notify pDataObject-%p\n"), pDataObject);
    if (pDataObject == NULL)
    {
        if (MMCN_PROPERTY_CHANGE == event)
        {
            if (param)
            {
                IWirelessSnapInDataObject * pData = (IWirelessSnapInDataObject *)param;
                //used IComponentData's IIconsole, fix for bug 464858
                //pData->Notify(event, arg, param, FALSE, m_pConsole, m_pHeader );
                pData->Notify(event, arg, param, FALSE, m_pCComponentData->m_pConsole, m_pHeader );
            }
        }
        
        if (MMCN_COLUMN_CLICK == event)
        {
            ASSERT( NULL != m_pCComponentData );    // should always have this
            
            // MMCN_COLUMN_CLICK is specified as having a NULL pDataObject.
            
            ASSERT( NULL != m_pResultData );
            if (NULL != m_pResultData)
            {
                // Save sort request details
                m_nSortColumn = arg;
                m_dwSortOrder = param;
                
                // Sort all result items
                HRESULT hr = m_pResultData->Sort( arg, param, 0 );
                
                return hr;
            }
            
            return E_UNEXPECTED;
        }
        
        TRACE(_T("CComponentImpl::Notify ERROR(?) called with pDataObject==NULL for event-%i\n"), event);
        // If this asserts, look at "event" and determine whether it is normal for
        // pDataObject to be NULL.  If so add code above to handle event.
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
    
    if (MMCN_VIEW_CHANGE == event)
    {
        // Pack info for sorting result view into the hint for this event.  Its safe
        // to do this because all calls to IConsole::UpdateAllViews from within this
        // snap-in do not use the hint.
        param = MAKELONG( m_nSortColumn, m_dwSortOrder );
    }
    
    // Pass call to result item.
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData( pDataObject );
    if (spData == NULL)
    {
        // If we are loaded as an extension snapin, let our static node handle this.
        if (NULL != m_pCComponentData->GetStaticScopeObject()->GetExtScopeObject())
        {
            CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> 
                spExtData( m_pCComponentData->GetStaticScopeObject()->GetExtScopeObject() );
            if (spExtData != NULL)
            {
                HRESULT hr;
                hr = spExtData->Notify( event, arg, param, FALSE, m_pConsole, m_pHeader );
                return hr;
            }
            ASSERT( FALSE );
        }
        TRACE(_T("CComponentImpl::Notify - QI for IWirelessSnapInDataObject FAILED\n"));
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
    
    return spData->Notify( event, arg, param, FALSE, m_pConsole, m_pHeader );
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation
STDMETHODIMP CComponentImpl::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT pDataObject)
{
    if (pDataObject == NULL)
    {
        TRACE(_T("CComponentImpl::CreatePropertyPages called with pDataObject == NULL\n"));
        return E_UNEXPECTED;
    }
    
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData(pDataObject);
    if (spData == NULL)
    {
        TRACE(_T("CComponentImpl::CreatePropertyPages - QI for IWirelessSnapInDataObject FAILED\n"));
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
    return spData->CreatePropertyPages( lpProvider, handle );
}

STDMETHODIMP CComponentImpl::QueryPagesFor(LPDATAOBJECT pDataObject)
{
    if (pDataObject == NULL)
    {
        TRACE(_T("CComponentImpl::QueryPagesFor called with pDataObject == NULL\n"));
        return E_UNEXPECTED;
    }
    
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData(pDataObject);
    if (spData == NULL)
    {
        TRACE(_T("CComponentImpl::QueryPagesFor - QI for IWirelessSnapInDataObject FAILED\n"));
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
    return spData->QueryPagesFor();
}

/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenus Implementation
STDMETHODIMP CComponentImpl::AddMenuItems(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pContextMenuCallback, long *pInsertionAllowed)
{
    if (pDataObject == NULL)
    {
        TRACE(_T("CComponentImpl::AddMenuItems called with pDataObject == NULL\n"));
        return E_UNEXPECTED;
    }
    
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData(pDataObject);
    if (spData == NULL)
    {
        TRACE(_T("CComponentImpl::AddMenuItems - QI for IWirelessSnapInDataObject FAILED\n"));
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
    return spData->AddMenuItems( pContextMenuCallback, pInsertionAllowed );
}

STDMETHODIMP CComponentImpl::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    if (pDataObject == NULL)
    {
        TRACE(_T("CComponentImpl::Command called with pDataObject == NULL\n"));
        return E_UNEXPECTED;
    }
    
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData(pDataObject);
    if (spData == NULL)
    {
        TRACE(_T("CComponentImpl::Command - QI for IWirelessSnapInDataObject FAILED\n"));
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
    return spData->Command( nCommandID, NULL /*IConsoleNameSpace* */ );
}

/////////////////////////////////////////////////////////////////////////////
// IExtendControlbar Implementation

STDMETHODIMP CComponentImpl::SetControlbar( LPCONTROLBAR pControlbar )
{
    OPT_TRACE( _T("CComponentImpl::IExtendControlbar::SetControlbar\n") );
    
    // pControlbar was obtained by MMC (MMCNDMGR) from our CComponentImpl by doing
    // a QI on IExtendControlbar.  Save it so we can use it later.
    // Note: Always assign pControlbar to our smart pointer.  pControlbar == NULL
    // when MMC wants us to release the interface we already have.
    m_spControlbar = pControlbar;
    return S_OK;
}

STDMETHODIMP CComponentImpl::ControlbarNotify( MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param )
{
    OPT_TRACE( _T("CComponentImpl::IExtendControlbar::ControlbarNotify\n") );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    // Obtain the data obj of the currently selected item.
    LPDATAOBJECT pDataObject = NULL;
    if (event == MMCN_BTN_CLICK)
    {
        pDataObject = (LPDATAOBJECT)arg;
    }
    else if (event == MMCN_SELECT)
    {
        pDataObject = (LPDATAOBJECT)param;
    }
    
    if (NULL == pDataObject)
    {
        // This can happen on a MMCN_BTN_CLICK if the result pane is clicked, but not
        // on a result item, then a scope item toolbar button is pressed.  In this case
        // check for one of the known scope item toolbar commands.
        if (IDM_CREATENEWSECPOL == param )
        {
            pDataObject = m_pCComponentData->GetStaticScopeObject();
        }
        else
        {
            TRACE(_T("CComponentImpl::ControlbarNotify - ERROR no IDataObject available\n"));
            return E_UNEXPECTED;
        }
    }
    
    // Let selected item handle command
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData( pDataObject );
    if (spData == NULL)
    {
        TRACE(_T("CComponentImpl::ControlbarNotify - QI for IWirelessSnapInDataObject FAILED\n"));
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
    HRESULT hr = spData->ControlbarNotify( m_spControlbar, (IExtendControlbar*)this,
        event, arg, param );
    
    // If the command was not handled by the selected item, pass it to our static
    // scope obj.
    if (E_NOTIMPL == hr || S_FALSE == hr)
    {
        if (m_pCComponentData->GetStaticScopeObject() != pDataObject)
        {
            CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> 
                spScopeData( m_pCComponentData->GetStaticScopeObject() );
            if (spScopeData == NULL)
            {
                TRACE(_T("CComponentImpl::ControlbarNotify - StaticScopeObj.QI for IWirelessSnapInDataObject FAILED\n"));
                ASSERT( FALSE );
                return E_UNEXPECTED;
            }
            hr = spScopeData->ControlbarNotify( m_spControlbar, (IExtendControlbar*)this,
                event, arg, param );
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\about.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       
//
//  Contents:   
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#ifndef _ABOUT_H
#define _ABOUT_H

class CSnapinAboutImpl :
public ISnapinAbout,
public CComObjectRoot,
public CComCoClass<CSnapinAboutImpl, &CLSID_About>
{
public:
    CSnapinAboutImpl();
    ~CSnapinAboutImpl();
    
public:
    DECLARE_REGISTRY(CSnapinAboutImpl, _T("Wireless.About.1"), _T("Wireless.About"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
        
        BEGIN_COM_MAP(CSnapinAboutImpl)
        COM_INTERFACE_ENTRY(ISnapinAbout)
        END_COM_MAP()
        
public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage,
        HBITMAP* hSmallImageOpen,
        HBITMAP* hLargeImage,
        COLORREF* cLargeMask);
    
    // Internal functions
private:
    HRESULT AboutHelper(UINT nID, CString* pAddString, LPOLESTR* lpPtr);
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr) {return AboutHelper(nID, NULL, lpPtr);};
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\chap.cpp ===
// chap.cpp : implementation file
//

#include "stdafx.h"
#include "nfaa.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMSCHAPSetting dialog

CMSCHAPSetting::CMSCHAPSetting(CWnd* pParent /*=NULL*/)
	: CDialog(CMSCHAPSetting::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMSCHAPSetting)
	//m_dwValidateServerCertificate = FALSE;
	//}}AFX_DATA_INIT
	m_bReadOnly = FALSE;

}

void CMSCHAPSetting::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMSCHAPSetting)
       DDX_Check(pDX, IDC_CHAP_AUTO_WINLOGIN, m_dwAutoWinLogin);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMSCHAPSetting, CDialog)
	//{{AFX_MSG_MAP(CMSCHAPSetting)
	ON_WM_HELPINFO()
       ON_BN_CLICKED(IDC_CHAP_AUTO_WINLOGIN, OnCheckCHAPAutoLogin)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMSCHAPSetting message handlers

BOOL CMSCHAPSetting::OnInitDialog()
{
	CDialog::OnInitDialog();

       m_dwAutoWinLogin = 
        *pdwAutoWinLogin ? TRUE : FALSE;

       if (m_bReadOnly) {
       	SAFE_ENABLEWINDOW(IDC_CHAP_AUTO_WINLOGIN, FALSE);
       	}

       UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CMSCHAPSetting::ControlsValuesToSM(
	DWORD *pdwAutoWinLogin
	)
{
       DWORD dwAutoWinLogin = 0;
	// pull all our data from the controls
       UpdateData(TRUE);	

    dwAutoWinLogin = 
        m_dwAutoWinLogin ? 1 : 0;

    *pdwAutoWinLogin = dwAutoWinLogin;

    return;
}

void CMSCHAPSetting::OnOK()
{
	UpdateData (TRUE);
	ControlsValuesToSM(pdwAutoWinLogin);
	CDialog::OnOK();
}

BOOL CMSCHAPSetting::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DWORD* pdwHelp = (DWORD*) &g_aHelpIDs_IDD_CHAP_SETTINGS[0];
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
            c_szWlsnpHelpFile,
            HELP_WM_HELP,
            (DWORD_PTR)(LPVOID)pdwHelp);
    }
    
    return TRUE;
}

void CMSCHAPSetting::OnCheckCHAPAutoLogin()
{
    UpdateData(TRUE);
}

BOOL CMSCHAPSetting::Initialize(
	DWORD *padwAutoWinLogin,
	BOOL bReadOnly
	)
{
    m_bReadOnly = bReadOnly;
    pdwAutoWinLogin = padwAutoWinLogin;
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\ccompdta.h ===
#ifndef _CCOMPDTA_H
#define _CCOMPDTA_H


// forward decls
class CWirelessManagerFolder;
class CSnapObject;

class CComponentDataImpl:
public IComponentData,
#ifdef WIZ97WIZARDS
public IExtendPropertySheet2,
#else
public IExtendPropertySheet,
#endif
public IExtendContextMenu,
public IPersistStream,
public ISnapinHelp,
public CComObjectRoot
{
    BEGIN_COM_MAP(CComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
#ifdef WIZ97WIZARDS
        COM_INTERFACE_ENTRY(IExtendPropertySheet2)
#else
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
#endif
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(ISnapinHelp)
        COM_INTERFACE_ENTRY(IPersistStream)
    END_COM_MAP()
        
        friend class CComponentImpl;
    friend class CDataObject;
    
    CComponentDataImpl();
    ~CComponentDataImpl();
    
public:
    virtual const CLSID& GetCoClassID() = 0;
    
public:
    // IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT pDataobject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);
    
    // IExtendPropertySheet interface
public:
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataobject);
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT pDataobject);
#ifdef WIZ97WIZARDS 
    STDMETHOD(GetWatermarks)(LPDATAOBJECT pDataobject, HBITMAP* lphWatermark, HBITMAP* lphHeader, HPALETTE* lphPalette, BOOL* bStretch);
#endif
    
    // IExtendContextMenu
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, long *pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);
    
public:
    // IPersistStream interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);
    
    // ISnapinHelp interface member
public:
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
    
#if DBG==1
public:
    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1
    
private:
    LPCONSOLENAMESPACE      m_pConsoleNameSpace;    // My interface pointer to the scope pane
    LPCONSOLE               m_pConsole;    // My interface pointer to the console
    HSCOPEITEM              m_pRootFolderScopeItem;
    BOOL                    m_bIsDirty;
    BOOL                    m_bRsop;
    
    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL InternalIsDirty() { return m_bIsDirty; }
    
    void AddScopeItemToResultPane(MMC_COOKIE cookie);
    // BOOL IsScopePaneNode(LPDATAOBJECT pDataobject);
    HRESULT GetDomainDnsName(CString & strName);
    HRESULT GetDomainGPOName(CString & strName);
    
public:
    CComObject <CWirelessManagerFolder>* GetStaticScopeObject () {return m_pScopeRootFolder;};
    // the returned interface will be valid for the duration of the call, but if you intend on
    // storing it you must AddRef
    IGPEInformation* UseGPEInformationInterface() {return m_pGPEInformation;};
    IRSOPInformation* UseRSOPInformationInterface() {return m_pRSOPInformation;};
    BOOL IsRsop() { return m_bRsop; };
    
    
    LPCONSOLE GetConsole() {return m_pConsole;};
    LPCONSOLENAMESPACE GetConsoleNameSpace () {return m_pConsoleNameSpace;};
    
    void EnumLocation (enum STORAGE_LOCATION enumLocation);
    enum STORAGE_LOCATION EnumLocation()
    {
        return m_enumLocation;
    }
    
    void RemoteMachineName (CString sRemoteMachineName) {m_sRemoteMachineName = sRemoteMachineName;}
    CString RemoteMachineName () {return m_sRemoteMachineName;}
    void DomainGPOName (CString sDomainGPOName) {m_sDomainGPOName = sDomainGPOName;}
    CString DomainGPOName () {return m_sDomainGPOName;}
    
    LPPROPERTYSHEETPROVIDER m_pPrshtProvider;
    
    HANDLE GetPolicyStoreHandle()
    {
        return(m_hPolicyStore);
    }
    
    DWORD OpenPolicyStore();
    
    
    void IssueStorageWarning (BOOL bWarn)
    {
        m_bStorageWarningIssued = !bWarn;
    }
    BOOL m_bStorageWarningIssued;
    BOOL m_bLocationStorageWarningIssued;
    
    BOOL m_bAttemptReconnect;
    
private:
    CComObject <CWirelessManagerFolder>* m_pScopeRootFolder; 
    IGPEInformation* m_pGPEInformation;
    IRSOPInformation* m_pRSOPInformation;
    
    
    enum STORAGE_LOCATION m_enumLocation;
    
    HANDLE m_hPolicyStore;
    IWbemServices *m_pWbemServices;
    
    CString m_sRemoteMachineName;
    CString m_sDomainGPOName;
    BOOL m_bDontDisplayRootFolderProperties;
    BOOL m_bNeedCleanUpWSA;
    
#ifdef _DEBUG
    friend class CDataObject;
    int     m_cDataObjects;
#endif
    
    // for winsock
    WSADATA wsaData;
};

// TODO: declare registry values appear to conflict with step four and others

class CComponentDataPrimaryImpl : public CComponentDataImpl,
public CComCoClass<CComponentDataPrimaryImpl, &CLSID_Snapin>
{
public:
    DECLARE_REGISTRY(CComponentImpl, _T("Wireless.Snapin.1"), _T("Wireless.Snapin"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
        CComponentDataPrimaryImpl();
    virtual const CLSID & GetCoClassID(){ return CLSID_Snapin; }
};

class CComponentDataExtensionImpl : public CComponentDataImpl,
public CComCoClass<CComponentDataExtensionImpl, &CLSID_Extension>
{
public:
    DECLARE_REGISTRY(CComponentImpl, _T("Wireless.Extension.1"), _T("Wireless.Extension"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
        virtual const CLSID & GetCoClassID(){ return CLSID_Extension; }
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\ccompdta.cpp ===
#include "stdafx.h"

#include "sceattch.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// polstore is not threadsafe: we have multiple threads so we wrap critical sections around our calls to polstore
CCriticalSection g_csPolStore;

// Description:
//
//     Safe version of strlen, that will not Access Violate if
//     passed a bad pointer or a non-null terminated string.
//     A non-null terminated string is detected by making
//     sure we do not read past the string into memory we do not own.
//       
//
// Arguments:
//
//     pszStr - Input string.
//     pcchStrLen - pointer to variable in which to return string length.
//
// Return Value:
//      ERROR_INVALID_PARAMETER - if pszStr points to an invalid string.
//      ERROR_SUCCESS
//

DWORD
WlsnpStringLenW(
    IN LPCWSTR pszStr,
    OUT size_t* pcchStrLen
    )
{
    BOOL fBadStr = TRUE;
    DWORD dwError = ERROR_SUCCESS;
    size_t cchStrLen = 0;

    if (!pszStr) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    __try {
        cchStrLen = wcslen(pszStr);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    *pcchStrLen = cchStrLen;
    
    return dwError;

error:
    *pcchStrLen = 0;
    
    return dwError;
}

// Useful string safe function
// Description:
//
//     Safe string searching routine that will not Access Violate if
//     passed bad pointers or non-null terminated strings.
//     pszStartOfMatch is a pointer to the start of the first match
//     of the string to search for in the string to search.
//
//
// Arguments:
//
//     pszStrToSearch - Input string to search in.
//     pszStrToFind - Input string to search for.
//     bIsCaseSensitive - if true, perform case sensitive search
//     pszStartOfMatch - pointer to first occurrance of pszStrToFind
//                       within pszStrToSearch
//
// Return Value:
//      ERROR_INVALID_PARAMETER - if either input string points to an invalid string.
//      ERROR_SUCCESS
//

DWORD
WINAPI
WlsnpStringFindW(
	IN LPCWSTR pszStrToSearch,
	IN LPCWSTR pszStrToFind,
	IN BOOL bIsCaseSensitive,
	OUT LPCWSTR* ppszStartOfMatch
	)
{
	DWORD dwError = ERROR_SUCCESS;
	size_t uiSearchLen;
	size_t uiFindLen;
	size_t i;

	*ppszStartOfMatch = 0;

	WlsnpStringLenW(pszStrToSearch, &uiSearchLen);
	BAIL_ON_WIN32_ERROR(dwError);
	WlsnpStringLenW(pszStrToFind, &uiFindLen);
	BAIL_ON_WIN32_ERROR(dwError);

	i = 0;
	if (bIsCaseSensitive)
	{
		while ((*ppszStartOfMatch == 0) && ((uiSearchLen - i) >= uiFindLen))
		{
			if (wcsncmp(&pszStrToSearch[i], pszStrToFind, uiFindLen) == 0)
			{
				*ppszStartOfMatch = &pszStrToSearch[i];
			}
			++i;
		}
	}
	else
	{
		while ((*ppszStartOfMatch == 0) && ((uiSearchLen - i) >= uiFindLen))
		{
			if (_wcsnicmp(&pszStrToSearch[i], pszStrToFind, uiFindLen) == 0)
			{
				*ppszStartOfMatch = &pszStrToSearch[i];
			}
			++i;
		}
	}

error:
	return dwError;
}



///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl);

CComponentDataImpl::CComponentDataImpl()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl);
    
    // Initialize members
    m_pConsoleNameSpace = NULL;
    m_pPrshtProvider = NULL;
    m_pConsole = NULL;
    m_pRootFolderScopeItem = NULL;
    m_bIsDirty = FALSE;
    m_enumLocation = LOCATION_LOCAL;
    m_bDontDisplayRootFolderProperties = FALSE;
    m_bStorageWarningIssued = FALSE;
    m_bLocationStorageWarningIssued = FALSE;
    m_bAttemptReconnect = TRUE;
    m_bNeedCleanUpWSA = FALSE;
    m_hPolicyStore = NULL;
    
    m_pScopeRootFolder = NULL;
    m_pGPEInformation = NULL;
    
    m_bRsop = FALSE;
    m_pRSOPInformation = NULL;
    
    
#ifdef _DEBUG
    m_cDataObjects = 0;
#endif
    
    // create our initial folder
    CComObject <CWirelessManagerFolder>::CreateInstance(&m_pScopeRootFolder); 
    if (m_pScopeRootFolder == NULL)
    {
        // note: we are in a seriously bad state(!)
        // but this is ok, because we will now 'fail to initialize' and
        // mmc deals ok
        return;
    }
    
    // we are storing, and later using, m_pScopeRootFolder so AddRef it
    m_pScopeRootFolder->AddRef(); 
    
    m_pScopeRootFolder->SetDataObjectType( CCT_SCOPE );
    m_pScopeRootFolder->Initialize (this, NULL, FOLDER_IMAGE_IDX, OPEN_FOLDER_IMAGE_IDX, FALSE);
    m_pScopeRootFolder->GetScopeItem()->mask |= SDI_PARAM;
    m_pScopeRootFolder->GetScopeItem()->lParam = (LPARAM)m_pScopeRootFolder;
#ifdef _DEBUG
    m_pScopeRootFolder->SetComponentData(this);
#endif
    
}

CComponentDataImpl::~CComponentDataImpl()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl);
    
    // Some snap-in is hanging on to data objects.
    // If they access, it will crash!!!
    ASSERT(m_cDataObjects == 0);
    
    // release our interfaces
    SAFE_RELEASE(m_pScopeRootFolder); // triggers delete up sub folders
    SAFE_RELEASE(m_pConsoleNameSpace);
    SAFE_RELEASE(m_pConsole);
    SAFE_RELEASE(m_pPrshtProvider);
    SAFE_RELEASE(m_pGPEInformation);
    
    // cleanup winsock if we got it
    if (m_bNeedCleanUpWSA)
        WSACleanup();
}

STDMETHODIMP CComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr = E_UNEXPECTED;
    
    // TODO: clean this up and add error checking!
    ASSERT(pUnknown != NULL);
    
    // MMC should only call ::Initialize once!
    ASSERT(m_pConsoleNameSpace == NULL);
    pUnknown->QueryInterface(IID_IConsoleNameSpace, reinterpret_cast<void**>(&m_pConsoleNameSpace));
    
    pUnknown->QueryInterface(IID_IPropertySheetProvider, reinterpret_cast<void**>(&m_pPrshtProvider));
    
    // add the images for the scope tree
    CBitmap bmp16x16;
    LPIMAGELIST lpScopeImage;
    
    hr = pUnknown->QueryInterface(IID_IConsole, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);
    
    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    
    ASSERT(hr == S_OK);
    
    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);
    
    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
        reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)), 0, RGB(255, 0, 255));
    
    lpScopeImage->Release();
    
    // attempt to start winsock
    WORD wsaVersion = MAKEWORD(2,0);
    DWORD dwRet;
    dwRet = WSAStartup(wsaVersion, &wsaData);
    ASSERT (0 == dwRet);
    if (0 == dwRet)
    {
        // make sure we got a version we expected, but don't really
        // bother with any other failures as all this will effect is the
        // DNS lookup, which will just cram in a DNS name without looking
        // it up first... shrug.
        if ((LOBYTE(wsaData.wVersion) != LOBYTE(wsaVersion)) ||
            (HIBYTE(wsaData.wVersion) != HIBYTE(wsaVersion))) {
            WSACleanup();
        }
        else
        {
            m_bNeedCleanUpWSA = TRUE;
        }
    }
    
    
    return S_OK;
}


DWORD
CComponentDataImpl::OpenPolicyStore(
                                    )
{
    
    DWORD dwError = 0;
    HANDLE hPolicyStore = NULL;
    
    if (m_hPolicyStore)
    {
        WirelessClosePolicyStore(m_hPolicyStore);
        m_hPolicyStore = NULL;
    }
    
    DWORD dwProvider = WIRELESS_REGISTRY_PROVIDER;
    CString strLocationName;
    CString strDSGPOName;
    switch(EnumLocation())
    {
    case LOCATION_REMOTE:
        strLocationName = RemoteMachineName();
        break;
        
    case LOCATION_GLOBAL:
        strLocationName = RemoteMachineName();
        strDSGPOName = DomainGPOName();
        dwProvider = WIRELESS_DIRECTORY_PROVIDER;
        break;
        
    case LOCATION_WMI:
        strLocationName = RemoteMachineName(); //rsop namespace
        dwProvider = WIRELESS_WMI_PROVIDER;
        break;
        
    case LOCATION_LOCAL:
    default:
        break;
    }
    /* 
    dwError = WirelessOpenPolicyStore(
        (LPWSTR) (LPCWSTR) strLocationName,
        dwProvider,
        NULL,
        &hPolicyStore
        );
        */
        dwError = WirelessGPOOpenPolicyStore(
        (LPWSTR) (LPCWSTR) strLocationName,
        dwProvider,
        (LPWSTR) (LPCWSTR) strDSGPOName,
        NULL,
        &hPolicyStore
        );
    
    if (dwError) {
        
        Destroy();
        
        return(dwError);
    }
    
    m_hPolicyStore = hPolicyStore;
    
    return dwError;
}


STDMETHODIMP CComponentDataImpl::CreateComponent(LPCOMPONENT* ppComponent)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    ASSERT(ppComponent != NULL);
    
    CComObject<CComponentImpl>* pObject;
    CComObject<CComponentImpl>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);
    
    // Store IComponentData
    pObject->SetIComponentData(this);
    
    return pObject->QueryInterface(IID_IComponent, reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CComponentDataImpl::Notify(LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    OPT_TRACE( _T("CComponentDataImpl::Notify pDataObject-%p\n"), pDataObject );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    ASSERT(m_pConsoleNameSpace != NULL);
    
    HRESULT hr = S_FALSE;
    
    // Need pDataObject unless the event is one of these:
    //  -MMCN_PROPERTY_CHANGE because this event is generated by a
    //  MMCPropertyChangeNotify() which does not take pDataObject as an argument.
    //
    //  -MMCN_COLUMN_CLICK because it is defined as having a NULL pDataObject.
    
    if (pDataObject == NULL && MMCN_PROPERTY_CHANGE != event && MMCN_COLUMN_CLICK != event)
    {
        TRACE(_T("CComponentDataImpl::Notify ERROR(?) called with pDataObject==NULL on event-%i\n"), event);
        // Is this an event for which there should be no IDataObj?  If so, add it to
        // the if statement above.
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
    
    switch(event)
    {
    case MMCN_REMOVE_CHILDREN:
        {
            //
            // In RSoP, we may get called to refresh the scope pane when the query
            // is re-executed -- if this happens, current nodes will be removed and
            // we must reset all of our cached information.  We reset the relevant
            // information below
            //
            
            if ( ((HSCOPEITEM)arg != NULL) && m_bRsop && (m_pRSOPInformation != NULL) )
            {
                m_pRSOPInformation->Release();
                
                m_pRSOPInformation = NULL;
                
            }
            break;
        }
        
        
    case MMCN_EXPANDSYNC:
        {
            //this event is not supported
            return S_FALSE;
            break;
        }
        
    case MMCN_EXPAND:
        {
            if (pDataObject)
            {
                // if we are an extension snap-in, IDataObject is from the parent snap-in and so it
                // won't know about the IID_IWirelessSnapInDataObject interface. Otherwise we created
                // the root now (IDataObject) so it does respond to the query, and we don't want
                // to do our extension snapin stuff
                CComQIPtr <IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData(pDataObject);
                if ( spData )
                {
                    //should be internal format, as the external snapin does not know about our format
                    return spData->Notify( event, arg, param, TRUE, m_pConsole, NULL );
                }
                else
                {
                    
                    //we may be in extension sanpin now
                    
                    UINT cfModeType = RegisterClipboardFormat(CCF_SCE_RSOP_UNKNOWN);
                    STGMEDIUM ObjMediumMode = { TYMED_HGLOBAL, NULL };
                    FORMATETC fmteMode = {(CLIPFORMAT)cfModeType, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                    ObjMediumMode.hGlobal = GlobalAlloc(GMEM_SHARE|GMEM_ZEROINIT, sizeof(DWORD*));
                    if (NULL == ObjMediumMode.hGlobal)
                    {
                        DWORD dwError = GetLastError();
                        hr = HRESULT_FROM_WIN32(dwError);
                        return hr;
                    } 
                    
                    hr = pDataObject->GetDataHere (&fmteMode, &ObjMediumMode);
                    
                    LPUNKNOWN pUnkRSOP = *((LPUNKNOWN*) (ObjMediumMode.hGlobal));
                    ASSERT (pUnkRSOP);
                    
                    
                    if(pUnkRSOP) {
                        if ( m_pRSOPInformation )
                        {
                            m_pRSOPInformation->Release();
                            m_pRSOPInformation = NULL;
                        }
                        hr = pUnkRSOP->QueryInterface(IID_IRSOPInformation, (LPVOID *)&m_pRSOPInformation);
                        pUnkRSOP->Release();
                    }
                    
                    GlobalFree(ObjMediumMode.hGlobal);
                    
                    if(m_pRSOPInformation)
                    {
                        m_bRsop = TRUE;
                    }
                    
                    if(m_pRSOPInformation)
                    {
                        ////RSOP case
                        UINT cfModeType = RegisterClipboardFormat(CCF_SCE_MODE_TYPE);
                        STGMEDIUM ObjMediumMode = { TYMED_HGLOBAL, NULL };
                        FORMATETC fmteMode = {(CLIPFORMAT)cfModeType, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                        ObjMediumMode.hGlobal = GlobalAlloc(GMEM_SHARE|GMEM_ZEROINIT, sizeof(DWORD*));
                        if (NULL == ObjMediumMode.hGlobal)
                        {
                            DWORD dwError = GetLastError();
                            m_pRSOPInformation->Release();
                            m_pRSOPInformation = NULL;
                            return HRESULT_FROM_WIN32(dwError);
                        }
                        
                        DWORD dwSCEMode = SCE_MODE_UNKNOWN;
                        
                        hr = pDataObject->GetDataHere (&fmteMode, &ObjMediumMode);
                        
                        dwSCEMode = *(DWORD*)(ObjMediumMode.hGlobal);
                        GlobalFree(ObjMediumMode.hGlobal);
                        
                        //Bug296532, Wireless shouldn't show up as an extention unless we are in
                        // the following SCE modes
                        
                        if (!
                            (SCE_MODE_LOCAL_COMPUTER == dwSCEMode ||
                            SCE_MODE_DOMAIN_COMPUTER == dwSCEMode ||
                            SCE_MODE_OU_COMPUTER == dwSCEMode ||
                            SCE_MODE_REMOTE_COMPUTER == dwSCEMode ||
                            SCE_MODE_RSOP_COMPUTER == dwSCEMode)
                            )
                        {
                            m_pRSOPInformation->Release();
                            m_pRSOPInformation = NULL;
                            hr = S_FALSE;
                            return hr;
                        }
                        
                        const int cchMaxLength = 512;
                        WCHAR szNameSpace[cchMaxLength];
                        
                        if (m_pRSOPInformation->GetNamespace(GPO_SECTION_MACHINE, szNameSpace, cchMaxLength) == S_OK) 
                        {
                            RemoteMachineName(szNameSpace);
                        }
                        else
                        {
                            RemoteMachineName (L"");
                        }
                        
                        EnumLocation (LOCATION_WMI);
                        m_pScopeRootFolder->SetExtScopeObject( m_pScopeRootFolder );
                    } //if(m_pRSOPInformation)
                    else
                    {
                        // The GPT knows where we are loaded from (DS, Local, Remote)
                        // and will provide that information via its interface
                        UINT cfModeType = RegisterClipboardFormat(CCF_SCE_GPT_UNKNOWN);
                        STGMEDIUM ObjMediumMode = { TYMED_HGLOBAL, NULL };
                        FORMATETC fmteMode = {(CLIPFORMAT)cfModeType, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                        ObjMediumMode.hGlobal = GlobalAlloc(GMEM_SHARE|GMEM_ZEROINIT, sizeof(DWORD*));
                        if (NULL == ObjMediumMode.hGlobal)
                        {
                            DWORD dwError = GetLastError();
                            hr = HRESULT_FROM_WIN32(dwError);
                            return hr;
                        }
                        
                        hr = pDataObject->GetDataHere (&fmteMode, &ObjMediumMode);
                        
                        // yes, CCF_SCE_GPT_UNKNOWN implies a GPT unknown, but what we actually
                        // get is an unknown for a GPE!!
                        LPUNKNOWN pUnkGPE = *((LPUNKNOWN*) (ObjMediumMode.hGlobal));
                        ASSERT (pUnkGPE);
                        // if we didn't get an IUNKNOWN something is serously wrong
                        if (pUnkGPE == NULL)
                        {
                            GlobalFree(ObjMediumMode.hGlobal);
                            hr = E_FAIL;
                            return hr;
                        }
                        
                        // need to look for the GPE interface
                        if ( m_pGPEInformation )
                        {
                            m_pGPEInformation->Release();
                            m_pGPEInformation = NULL;
                        }
                        hr = pUnkGPE->QueryInterface(cGPEguid, (void**) &m_pGPEInformation);    
                        // this is an alternative way of doing that QI if we wanted, I like the
                        // more direct approach
                        // CComQIPtr <IGPTInformation, &cGPTguid> spGPTInformation(pUnkGPT);
                        
                        // since calling GetDataHere is equivalent (so to speak) to a CreateInstance call
                        // we need to release the IUnknown
                        pUnkGPE->Release();
                        GlobalFree(ObjMediumMode.hGlobal);
                        
                        // check to see if we got it
                        if (m_pGPEInformation != NULL)
                        {
                            UINT cfModeType = RegisterClipboardFormat(CCF_SCE_MODE_TYPE);
                            STGMEDIUM ObjMediumMode = { TYMED_HGLOBAL, NULL };
                            FORMATETC fmteMode = {(CLIPFORMAT)cfModeType, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                            ObjMediumMode.hGlobal = GlobalAlloc(GMEM_SHARE|GMEM_ZEROINIT, sizeof(DWORD*));
                            if (NULL == ObjMediumMode.hGlobal)
                            {
                                DWORD dwError = GetLastError();
                                return HRESULT_FROM_WIN32(dwError);
                            }
                            
                            DWORD dwSCEMode = SCE_MODE_UNKNOWN;
                            
                            hr = pDataObject->GetDataHere (&fmteMode, &ObjMediumMode);
                            
                            dwSCEMode = *(DWORD*)(ObjMediumMode.hGlobal);
                            GlobalFree(ObjMediumMode.hGlobal);
                            
                            //Bug296532, Wireless shouldn't show up as an extention unless we are in
                            // the following SCE modes
                            if (!
                                (SCE_MODE_LOCAL_COMPUTER == dwSCEMode ||
                                SCE_MODE_DOMAIN_COMPUTER == dwSCEMode ||
                                SCE_MODE_OU_COMPUTER == dwSCEMode ||
                                SCE_MODE_REMOTE_COMPUTER == dwSCEMode ||
                                SCE_MODE_RSOP_COMPUTER == dwSCEMode)
                                )
                            {
                                m_pGPEInformation->Release();
                                m_pGPEInformation = NULL;
                                return S_FALSE;
                            }
                            
                            CString strName;
                            m_pGPEInformation->GetName (strName.GetBuffer(MAX_PATH), MAX_PATH);
                            strName.ReleaseBuffer (-1);
                            
                            GROUP_POLICY_OBJECT_TYPE gpoType;
                            m_pGPEInformation->GetType (&gpoType);
                            
                            
                            switch (gpoType)
                            {
                            case GPOTypeLocal:
                                {
                                    // redirect to local machine
                                    RemoteMachineName (L"");
                                    EnumLocation (LOCATION_LOCAL);
                                    hr = S_FALSE;
                                    return(hr);
                                    break;
                                }
                            case GPOTypeRemote:
                                // redirect to the GetName machine
                                RemoteMachineName (strName);
                                EnumLocation (LOCATION_REMOTE);
                                break;
                            case GPOTypeDS:
                                {
                                    hr = GetDomainDnsName(strName);
                                    
                                    if ( FAILED(hr) )
                                        return hr;
                                    
                                    RemoteMachineName (strName);

                                    hr = GetDomainGPOName(strName);
                                    if ( FAILED(hr) )
                                    	return hr;

                                    DomainGPOName(strName);
                                    
                                    EnumLocation (LOCATION_GLOBAL);
                                    break;
                                }
                            }//switch (gpoType)
                            
                            // we save the m_pGPEInformation interface for later use instead of:
                            // pGPEInformation->Release();
                        }//if (m_pGPEInformation != NULL)
                        
                        // If we made it here we were loaded as an extension snap-in.  Only do this once.
                        m_pScopeRootFolder->SetExtScopeObject( m_pScopeRootFolder );
                        
                    } //else if(m_pRSOPInformation)
                }
                
                
            } //if (pDataObject)
            
            break;
        } //case MMCN_EXPAND
        
        default:
            break;
    }//switch
    
    
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData(pDataObject);
    if (spData == NULL)
    {
        // Either we are loaded as an extension snapin (so it doesn't know about our
        // internal interface), or pDataObject is NULL.  In either case, we can pass
        // the event on.
        LPUNKNOWN pUnkScope;
        
        if (NULL != m_pScopeRootFolder->GetExtScopeObject())
        {
            // We are loaded as an extension snapin, let the designated extension
            // scope object handle the event.
            pUnkScope = reinterpret_cast<LPUNKNOWN>(m_pScopeRootFolder->GetExtScopeObject());
        }
        else
        {
            // Let our static scope object handle the event.
            pUnkScope = reinterpret_cast<LPUNKNOWN>(m_pScopeRootFolder);
        }
        
        // Pass on event
        ASSERT( NULL != pUnkScope );
        if (NULL != pUnkScope)
        {
            CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject>
                spExtData( pUnkScope );
            if (spExtData != NULL)
            {
                return spExtData->Notify( event, arg, param, TRUE, m_pConsole, NULL );
            }
            ASSERT( FALSE );
        }
        
        TRACE(_T("CComponentDataImpl::Notify - QI for IWirelessSnapInDataObject failed\n"));
        ASSERT( FALSE );
        hr = E_UNEXPECTED;
    }
    else
    {
        return spData->Notify( event, arg, param, TRUE, m_pConsole, NULL );
    }
    
    return hr;
    
}


HRESULT CComponentDataImpl::GetDomainGPOName(CString & strName)
{
    WCHAR szADsPathName[MAX_PATH];
    HRESULT hr = S_OK;
    CString szName;
    CString szPrefixName;
    
    
    hr = m_pGPEInformation->GetDSPath(
        GPO_SECTION_MACHINE,
        szADsPathName,
        MAX_PATH
        );

    //Truncate the LDAP:// from the string
    szName = _wcsninc( szADsPathName, 7);  
    //szPrefixName =  L"CN=Windows,CN=Microsoft,";
    //strName = szPrefixName+szName;
    strName = szName;
    
    return hr;
}


HRESULT CComponentDataImpl::GetDomainDnsName(CString & strName)
{
    WCHAR szADsPathName[MAX_PATH];
    WCHAR *szDnsName = NULL;
    LPCWSTR pszDirectoryName = NULL;
    ULONG ulSize = 0;
    HRESULT hr = S_OK;
    
    
    m_pGPEInformation->GetDSPath(
        GPO_SECTION_MACHINE,
        szADsPathName,
        MAX_PATH
        );
    
    WlsnpStringFindW(szADsPathName, L"dc=", false, &pszDirectoryName);
    
    TranslateName (
        pszDirectoryName ,            // object name
        NameFullyQualifiedDN,         // name format
        NameCanonical,                // new name format
        szDnsName,                    // name buffer
        &ulSize                       // buffer size
        );
    
    szDnsName = (WCHAR *) LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)* (ulSize+1));
    
    if ( szDnsName == NULL )
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }
    
    if ( !TranslateName (
        pszDirectoryName ,            // object name
        NameFullyQualifiedDN,         // name format
        NameCanonical,                // new name format
        szDnsName,                    // name buffer
        &ulSize                       // buffer size
        ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LocalFree( szDnsName );
        return hr;
    }
    
    
    if ( szDnsName[lstrlen(szDnsName) -1 ] == _T('/') )
    {
        szDnsName[lstrlen(szDnsName) -1 ] = _T('\0');
    }
    strName = szDnsName;
    LocalFree( szDnsName );
    
    return hr;
}

STDMETHODIMP CComponentDataImpl::Destroy()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    // since they are shutting us down, we use our static node
    
    // Use our member data object to handle call.
    IUnknown* pUnk = (IUnknown*) NULL;
    HRESULT hr = GetStaticScopeObject()->QueryInterface(IID_IUnknown, (void**)&pUnk);
    ASSERT (hr == S_OK);  
    if (NULL == pUnk)
        return E_UNEXPECTED;
    
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData( pUnk );
    if (spData == NULL)
    {
        TRACE(_T("CComponentDataImpl::GetDisplayInfo QI for IWirelessSnapInDataObject FAILED\n"));
        return E_UNEXPECTED;
    }
    spData->Destroy ();
    
    // Used our member data object to handle call, release it.
    pUnk->Release();
    
    return hr;
}

STDMETHODIMP CComponentDataImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    OPT_TRACE( _T("CComponentDataImpl::QueryDataObject this-%p, cookie-%p\n"), this, cookie );
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    // return failure since we weren't able to get up and running
    // causes mmc to report 'snapin failed to initialize'
    if (m_pScopeRootFolder == NULL)
    {
        return E_UNEXPECTED;
    }
    ASSERT( m_pScopeRootFolder->NodeName().GetLength() );   // we should know our own display name
    
    if (NULL == ppDataObject)
    {
        TRACE(_T("CComponentDataImpl::QueryDataObject - ERROR ppDataObject is NULL\n"));
        return E_UNEXPECTED;
    }
    
    *ppDataObject = NULL;
    
#ifdef _DEBUG
    HRESULT hr;
    if (cookie == NULL)
    {
        hr = m_pScopeRootFolder->QueryInterface( IID_IDataObject, (void**)(ppDataObject) );
        OPT_TRACE(_T("    QI on m_pScopeRootFolder-%p -> pDataObj-%p\n"), m_pScopeRootFolder, *ppDataObject);
        ASSERT(hr == S_OK);
        ASSERT( NULL != *ppDataObject );
        return hr;
    }
    
    IUnknown* pUnk = (IUnknown*) cookie;
    hr = pUnk->QueryInterface( IID_IDataObject, (void**)(ppDataObject) );
    OPT_TRACE(_T("    QI on cookie-%p -> pDataObj-%p\n"), cookie, *ppDataObject);
    ASSERT(hr == S_OK);
    return hr;
#else
    if (cookie == NULL)
        return m_pScopeRootFolder->QueryInterface( IID_IDataObject, (void**)(ppDataObject) );
    IUnknown* pUnk = (IUnknown*) cookie;
    return pUnk->QueryInterface( IID_IDataObject, (void**)(ppDataObject) );
#endif
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members
STDMETHODIMP CComponentDataImpl::GetClassID(CLSID *pClassID)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    ASSERT (0);
    // TODO: CComponentDataImpl::GetClassID and CComponentImpl::GetClassID are identical (?)
    ASSERT(pClassID != NULL);
    
    // Copy the CLSID for this snapin
    *pClassID = CLSID_Snapin;
    
    return S_OK;
}

STDMETHODIMP CComponentDataImpl::IsDirty()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    // return dirty state
    return InternalIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CComponentDataImpl::Load(IStream *pStm)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    unsigned long read;
    
    // NOTE: it looks like there is a strange case were the MMC will
    // attempt to load the properties for the root node a second (or more)
    // time. To do so right click on an item in the results pane and then
    // double click on the empty space in the results pane
    m_bDontDisplayRootFolderProperties = TRUE;
    
    // read the location enum
    HRESULT hr = pStm->Read (&m_enumLocation, sizeof (enum STORAGE_LOCATION), &read);
    if ((hr != S_OK) || (read != sizeof (enum STORAGE_LOCATION)))
    {
        // for debug purposes, we should assert here
        ASSERT (0);
        
        // make sure we have a valid (even if incorrect) value
        m_enumLocation = LOCATION_LOCAL;
        
        // TODO: look into better return value(s)
        return E_UNEXPECTED;
    }
    
    // read the size of the location string
    unsigned int iStrLen;
    hr = pStm->Read (&iStrLen, sizeof (unsigned int), &read);
    if ((hr == S_OK) && (read == sizeof (unsigned int)))
    {
        // read the string itself
        LPCTSTR szStr = (LPCTSTR) malloc (iStrLen);
        hr = pStm->Read ((void*) szStr, iStrLen, &read);
        if ((hr == S_OK) && (read == iStrLen))
        {   
            m_sRemoteMachineName = szStr;
            free ((void*)szStr);
            
            // we don't want to allow the location page to come up
            if (m_pScopeRootFolder)
            {
                m_pScopeRootFolder->LocationPageDisplayEnable(FALSE);
            }
            return S_OK;
        }
        // need to delete here as well
        free ((void*)szStr);
    }
    
    // we only get to here in an error situation
    ASSERT (0);
    
    // make sure we have a valid (even if incorrect) value
    m_enumLocation = LOCATION_GLOBAL;
    m_sRemoteMachineName = _T("");
    
    // TODO: look into better return value(s)
    return E_UNEXPECTED;
}

STDMETHODIMP CComponentDataImpl::Save(IStream *pStm, BOOL fClearDirty)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    unsigned long written;
    
    // save the storage location
    HRESULT hr = pStm->Write(&m_enumLocation, sizeof (enum STORAGE_LOCATION), &written);
    if ((hr != S_OK) || (written != sizeof (enum STORAGE_LOCATION)))
    {
        ASSERT (0);
        // TODO: look into better return value(s)
        return E_UNEXPECTED;
    }
    
    // save the length of the location string
    unsigned int iStrLen = m_sRemoteMachineName.GetLength()*sizeof(wchar_t)+sizeof(wchar_t);
    hr = pStm->Write(&iStrLen, sizeof (unsigned int), &written);
    if ((hr != S_OK) || (written != sizeof (unsigned int)))
    {
        ASSERT (0);
        // TODO: look into better return value(s)
        return E_UNEXPECTED;
    }
    
    // save the location string itself
    hr = pStm->Write((LPCTSTR) m_sRemoteMachineName, iStrLen, &written);
    if ((hr != S_OK) || (written != iStrLen))
    {
        ASSERT (0);
        // TODO: look into better return value(s)
        return E_UNEXPECTED;
    }
    
    // if fClearDirty we clear it out
    if (fClearDirty == TRUE)
    {
        ClearDirty();
    }
    
    return S_OK;
}

STDMETHODIMP CComponentDataImpl::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    // Set the size of the string to be saved
    ULISet32(*pcbSize, sizeof (enum STORAGE_LOCATION));
    return S_OK;
}

STDMETHODIMP CComponentDataImpl::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    if (pScopeDataItem == NULL)
    {
        TRACE(_T("CComponentDataImpl::GetDisplayInfo called with pScopeDataItem == NULL\n"));
        return E_UNEXPECTED;
    }
    
    IUnknown* pUnk = (IUnknown*) pScopeDataItem->lParam;
    if (pUnk == NULL)
    {
        // Use our member data object to handle call.
        HRESULT hr = GetStaticScopeObject()->QueryInterface(IID_IUnknown, (void**)&pUnk);
        ASSERT (hr == S_OK);  
        if (NULL == pUnk)
            return E_UNEXPECTED;
    }
    
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData( pUnk );
    if (spData == NULL)
    {
        TRACE(_T("CComponentDataImpl::GetDisplayInfo QI for IWirelessSnapInDataObject FAILED\n"));
        return E_UNEXPECTED;
    }
    HRESULT hr = spData->GetScopeDisplayInfo( pScopeDataItem );
    
    if (NULL == pScopeDataItem->lParam)
        // Used our member data object to handle call, release it.
        pUnk->Release();
    
    return hr;
}

STDMETHODIMP CComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    ASSERT (0);
    return E_UNEXPECTED;
    
    // NOTE: to implement look to CComponentImpl::CompareObjects
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation
STDMETHODIMP CComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    if (lpDataObject == NULL)
    {
        TRACE(_T("CComponentDataImpl::QueryPagesFor called with lpDataObject == NULL\n"));
        return E_UNEXPECTED;
    }
    
    CComQIPtr <IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData(lpDataObject);
    if (spData == NULL)
    {
        TRACE(_T("CComponentDataImpl::QueryPagesFor - QI for IWirelessSnapInDataObject FAILED\n"));
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
    return spData->QueryPagesFor();
    
}

STDMETHODIMP CComponentDataImpl::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    if (lpDataObject == NULL)
    {
        TRACE(_T("CComponentDataImpl::CreatePropertyPages called with lpDataObject==NULL\n"));
        return E_UNEXPECTED;
    }
    CComQIPtr <IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData(lpDataObject);
    if (spData == NULL)
    {
        TRACE(_T("CComponentDataImpl::CreatePropertyPages QI for IWirelessSnapInDataObject FAILED\n"));
        return E_UNEXPECTED;
    }
    return spData->CreatePropertyPages( lpProvider, handle );
}

#ifdef WIZ97WIZARDS
STDMETHODIMP CComponentDataImpl::GetWatermarks (LPDATAOBJECT lpDataObject, HBITMAP* lphWatermark, HBITMAP* lphHeader, HPALETTE* lphPalette, BOOL* bStretch)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    CBitmap* pbmpWatermark = new CBitmap;
    CBitmap* pbmpHeader = new CBitmap;
    
    if ((pbmpWatermark == NULL) || (pbmpHeader == NULL))
        return E_UNEXPECTED;
    
    // Load the bitmaps
    pbmpWatermark->LoadBitmap(IDB_WPOLICY);
    pbmpHeader->LoadBitmap(IDB_BPOLICY);
    
    *lphWatermark = static_cast<HBITMAP>(*pbmpWatermark);
    *lphHeader = static_cast<HBITMAP>(*pbmpHeader);
    *lphPalette = NULL;
    *bStretch = TRUE;
    
    return S_OK;
}
#endif

STDMETHODIMP CComponentDataImpl::AddMenuItems(LPDATAOBJECT lpDataObject, LPCONTEXTMENUCALLBACK pContextMenuCallback, long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    if (lpDataObject == NULL)
    {
        TRACE(_T("CComponentDataImpl::AddMenuItems called with piDataObject==NULL\n"));
        return E_UNEXPECTED;
    }
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData(lpDataObject);
    if (spData == NULL)
    {
        TRACE(_T("CComponentDataImpl::AddMenuItems QI for IWirelessSnapInDataObject FAILED\n"));
        return E_UNEXPECTED;
    }
    return spData->AddMenuItems( pContextMenuCallback, pInsertionAllowed );
}


STDMETHODIMP CComponentDataImpl::Command(long nCommandID, LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    ASSERT( NULL != m_pConsoleNameSpace );
    if (lpDataObject == NULL)
    {
        TRACE(_T("CComponentDataImpl::Command called with lpDataObject==NULL\n"));
        return E_UNEXPECTED;
    }
    CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData(lpDataObject);
    if (spData == NULL)
    {
        TRACE(_T("CComponentDataImpl::Command QI for IWirelessSnapInDataObject FAILED\n"));
        return E_UNEXPECTED;
    }
    return spData->Command( nCommandID, m_pConsoleNameSpace );
}

STDMETHODIMP CComponentDataImpl::GetHelpTopic (LPOLESTR* lpCompiledHelpFile)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    if (lpCompiledHelpFile == NULL)
        return E_POINTER;
    
    // need to form a complete path to the .chm file
    CString s, s2; 
    s.LoadString(IDS_HELPCONTENTSFILE);
    DWORD dw = ExpandEnvironmentStrings (s, s2.GetBuffer (512), 512);
    s2.ReleaseBuffer (-1);
    if ((dw == 0) || (dw > 512))
    {
        return E_UNEXPECTED;
    }
    
    *lpCompiledHelpFile = reinterpret_cast<LPOLESTR>
        (CoTaskMemAlloc((s2.GetLength() + 1)* sizeof(wchar_t)));
    if (*lpCompiledHelpFile == NULL)
        return E_OUTOFMEMORY;
    USES_CONVERSION;
    wcscpy(*lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)s2));
    return S_OK;
}

void CComponentDataImpl::EnumLocation (enum STORAGE_LOCATION enumLocation)
{
    SetDirty();
    m_enumLocation = enumLocation;
    
    // our enumlocation changed, so we should change the nodename of our
    // manager folder
    if (m_pScopeRootFolder)
    {
        m_pScopeRootFolder->SetNodeNameByLocation();
    }
}

///////////////////////////////////////////////////////////////////////////////
// class CComponentDataPrimaryImpl : IComponentData implementation
CComponentDataPrimaryImpl::CComponentDataPrimaryImpl() : CComponentDataImpl()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT( NULL != GetStaticScopeObject() );
    
    // Store the coclass with the data object
    // GetStaticScopeObject()->INTERNALclsid( GetCoClassID() );
    GetStaticScopeObject()->clsid (GetCoClassID()); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\chap.h ===
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// chap.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMSCHAPSetting dialog

class CMSCHAPSetting : public CDialog
{
// Construction
public:
	CMSCHAPSetting(CWnd* pParent = NULL);   // standard constructor
	BOOL  Initialize ( DWORD * pdwAutoLogin, BOOL bReadOnly = FALSE);

// Dialog Data
	//{{AFX_DATA(CMSCHAPSetting)
	enum { IDD = IDD_CHAP_CONFIGURE};
       BOOL   m_dwAutoWinLogin;
	//}}AFX_DATA



// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMSCHAPSetting)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

       DWORD *pdwAutoWinLogin;
       BOOL m_bReadOnly;

	// Generated message map functions
	//{{AFX_MSG(CMSCHAPSetting)
	virtual BOOL OnInitDialog();
	virtual void OnOK();

	
	afx_msg void OnCheckCHAPAutoLogin();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void ControlsValuesToSM (DWORD *pdwAutoWinLogin);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\dataobj.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Dataobj.cpp
//
//  Contents:   Wifi Policy management Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include "DataObj.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// Register used clipboard formats

///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.
unsigned int CSnapInClipboardFormats::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CSnapInClipboardFormats::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);  

unsigned int CSnapInClipboardFormats::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME); 
unsigned int CSnapInClipboardFormats::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID); 
unsigned int CSnapInClipboardFormats::m_cfDSObjectNames  = RegisterClipboardFormat(CFSTR_DSOBJECTNAMES); 
unsigned int CSnapInClipboardFormats::m_cfWorkstation    = RegisterClipboardFormat(SNAPIN_WORKSTATION);

unsigned int CSnapInClipboardFormats::m_cfPolicyObject   = RegisterClipboardFormat(CFSTR_WIFIPOLICYOBJECT);


/////////////////////////////////////////////////////////////////////////////
// Data object extraction helpers
CLSID* ExtractClassID(LPDATAOBJECT lpDataObject)
{
    OPT_TRACE(_T("ExtractClassID\n"));
    return Extract<CLSID>(lpDataObject, CSnapInClipboardFormats::m_cfCoClass);    
}

GUID* ExtractNodeType(LPDATAOBJECT lpDataObject)
{
    OPT_TRACE(_T("ExtractNodeType\n"));
    return Extract<GUID>(lpDataObject, CSnapInClipboardFormats::m_cfNodeType);    
}

wchar_t* ExtractWorkstation(LPDATAOBJECT lpDataObject)
{
    OPT_TRACE(_T("ExtractWorkstation\n"));
    return Extract<wchar_t>(lpDataObject, CSnapInClipboardFormats::m_cfWorkstation);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\genpage.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Genpage.h
//
//  Contents:  Wireless Network Policy Management Snapin - Properties Page of Wireless Policy
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#if !defined(AFX_GENPAGE_H__FBD58E78_E2B5_11D0_B859_00A024CDD4DE__INCLUDED_)
#define AFX_GENPAGE_H__FBD58E78_E2B5_11D0_B859_00A024CDD4DE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// GenPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGenPage dialog

class CGenPage : public CSnapinPropPage
{
    DECLARE_DYNCREATE(CGenPage)
        
        // Construction
public:
    CGenPage(UINT nIDTemplate = IDD_WIRELESSGENPROP);
    ~CGenPage();
    
    // Dialog Data
    UINT m_dlgIDD;
    
    //{{AFX_DATA(CGenPage)
    CEdit   m_edName;
    CEdit   m_edDescription;
    DWORD   m_dwPollingInterval;
    BOOL m_dwEnableZeroConf;
    BOOL m_dwConnectToNonPreferredNtwks;
    CComboBox m_cbdwNetworksToAccess;
    
    //DWORD   m_dwPollInterval;
    //}}AFX_DATA
    
    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CGenPage)
public:
    virtual BOOL OnApply();
    virtual void OnCancel();
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL
    
    virtual void OnManagerApplied();
    
    //UINT static AFX_CDECL DoAdvancedThread(LPVOID pParam);
    DWORD m_MMCthreadID;
    
    // Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CGenPage)
    virtual BOOL OnInitDialog();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    //afx_msg void OnAdvanced();
    afx_msg void OnChangedName();
    afx_msg void OnChangedDescription();
    
    afx_msg void OnChangedOtherParams();
    
    //afx_msg void OnChangedPollInterval();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
        
        void SetNewSheetTitle();
    
    // CCriticalSection m_csDlg;
    /*    CDialog* m_pDlgIKE; */
    
    CString m_strOldName;
    
    BOOL m_bNameChanged;    // TRUE if IDC_EDNAME's contents changed
    
    BOOL m_bPageInitialized;
    
    // taroonm virtual BOOL OnKillActive();
private:
    BOOL m_bReadOnly;
    void DisableControls();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GENPAGE_H__FBD58E78_E2B5_11D0_B859_00A024CDD4DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\genpage.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Genpage.cpp
//
//  Contents:  Wireless Network Policy Management Snapin  WIFI Policy General Properties
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------


#include "stdafx.h"
#include "sprpage.h"
#include "GenPage.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGenPage property page

IMPLEMENT_DYNCREATE(CGenPage, CSnapinPropPage)

//CGenPage::CGenPage() : CSnapinPropPage(CGenPage::IDD)
CGenPage::CGenPage(UINT nIDTemplate) : CSnapinPropPage(nIDTemplate)
{
    //{{AFX_DATA_INIT(CGenPage)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    
    m_dlgIDD = nIDTemplate;
    m_bNameChanged = FALSE;
    m_bPageInitialized = FALSE;
    m_dwEnableZeroConf = FALSE;
    m_dwConnectToNonPreferredNtwks = FALSE;
    m_dwPollingInterval = 90;
    m_MMCthreadID = ::GetCurrentThreadId();
    m_bReadOnly = FALSE;
}

CGenPage::~CGenPage()
{
}

void CGenPage::DoDataExchange(CDataExchange* pDX)
{
    CSnapinPropPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGenPage)
    DDX_Control(pDX, IDC_EDNAME, m_edName);
    DDX_Control(pDX, IDC_EDDESCRIPTION, m_edDescription);
    DDX_Check(pDX,IDC_DISABLE_ZERO_CONF,m_dwEnableZeroConf);
    DDX_Check(pDX,IDC_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS,m_dwConnectToNonPreferredNtwks);
    DDX_Control(pDX,IDC_COMBO_NETWORKS_TO_ACCESS, m_cbdwNetworksToAccess);
    DDX_Text(pDX, IDC_POLLING_INTERVAL, m_dwPollingInterval);
    // Limit polling interval to 30 days 
    DDV_MinMaxDWord(pDX, m_dwPollingInterval, 0, 43200);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CGenPage, CSnapinPropPage)
//{{AFX_MSG_MAP(CGenPage)
ON_WM_HELPINFO()
ON_EN_CHANGE(IDC_EDNAME, OnChangedName)
ON_EN_CHANGE(IDC_EDDESCRIPTION, OnChangedDescription)
ON_EN_CHANGE(IDC_POLLING_INTERVAL, OnChangedOtherParams)
ON_BN_CLICKED(IDC_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS, OnChangedOtherParams)
ON_BN_CLICKED(IDC_DISABLE_ZERO_CONF, OnChangedOtherParams)
ON_CBN_SELENDOK(IDC_COMBO_NETWORKS_TO_ACCESS, OnChangedOtherParams)

//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGenPage message handlers
BOOL CGenPage::OnInitDialog()
{
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    CString pszTemp;
    DWORD dwNetworksToAccessIndex = 0;
    DWORD dwPollingInterval = 0;
    
    // call base class init
    CSnapinPropPage::OnInitDialog();
    
    m_bPageInitialized = TRUE;
    
    // show the wait cursor in case there is a huge description being accessed
    CWaitCursor waitCursor;
    
    
    pWirelessPolicyData = GetResultObject()->GetWirelessPolicy();
    
    
    m_edName.SetLimitText(c_nMaxName);
    m_edDescription.SetLimitText(c_nMaxName);
    
    // initialize our edit controls
    
    
    ASSERT(pWirelessPolicyData);
    if (pWirelessPolicyData->pszWirelessName) {
        
        m_edName.SetWindowText (pWirelessPolicyData->pszWirelessName);
        
        m_strOldName = pWirelessPolicyData->pszWirelessName;
    }
    
    if (pWirelessPolicyData->pszDescription) {
        
        m_edDescription.SetWindowText (pWirelessPolicyData->pszDescription);
        
    }
    
    m_dwEnableZeroConf = pWirelessPolicyData->dwDisableZeroConf ? FALSE : TRUE;
    
    m_dwConnectToNonPreferredNtwks = 
        pWirelessPolicyData->dwConnectToNonPreferredNtwks ? TRUE : FALSE;
    
    pszTemp.LoadString(IDS_WIRELESS_ACCESS_NETWORK_ANY);
    m_cbdwNetworksToAccess.AddString(pszTemp);
    
    pszTemp.LoadString(IDS_WIRELESS_ACCESS_NETWORK_AP);
    m_cbdwNetworksToAccess.AddString(pszTemp);
    
    pszTemp.LoadString(IDS_WIRELESS_ACCESS_NETWORK_ADHOC);
    m_cbdwNetworksToAccess.AddString(pszTemp);
    
    switch (pWirelessPolicyData->dwNetworkToAccess) {
        
    case WIRELESS_ACCESS_NETWORK_ANY: 
        dwNetworksToAccessIndex = 0;
        break;
        
    case WIRELESS_ACCESS_NETWORK_AP:
        dwNetworksToAccessIndex = 1;
        break;
        
    case WIRELESS_ACCESS_NETWORK_ADHOC: 
        dwNetworksToAccessIndex = 2;
        break;
        
    default:
        dwNetworksToAccessIndex = 0;
        break;
    }
    
    m_cbdwNetworksToAccess.SetCurSel(dwNetworksToAccessIndex);
    
    m_dwPollingInterval = pWirelessPolicyData->dwPollingInterval / 60;
    
    if (pWirelessPolicyData->dwFlags & WLSTORE_READONLY) {
        m_bReadOnly = TRUE;
    }
    
    if (m_bReadOnly) {
        DisableControls();
    }
    
    // add context help to the style bits
    if (GetParent())
    {
        GetParent()->ModifyStyleEx (0, WS_EX_CONTEXTHELP, 0);
    }
    UpdateData (FALSE);
    
    // OK, we can start paying attention to modifications made via dlg controls now.
    // This should be the last call before returning from OnInitDialog.
    OnFinishInitDialog();
    
    return TRUE;  // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CGenPage::OnApply()
{
    CString strName;
    CString strDescription;
    LPWSTR pszDescription = NULL;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    DWORD dwNetworksToAccesssIndex = 0;
    DWORD dwDisableZeroConf = 0;
    DWORD dwAutomaticallyConnectToNonPreferredNtwks = 0;
    DWORD dwNetworksToAccess = 0;
    
    
    pWirelessPolicyData = GetResultObject()->GetWirelessPolicy();
    
    
    // pull our data out of the controls and into the object
    
    if (!UpdateData (TRUE))
        // Data was not valid, return for user to correct it.
        return CancelApply();
    
    m_edName.GetWindowText (strName);
    m_edDescription.GetWindowText (strDescription);

    if (strName.IsEmpty()) {

    	ReportError(IDS_OPERATION_FAILED_NULL_POLICY, 0);
    	m_edName.SetWindowText (pWirelessPolicyData->pszWirelessName);
    	return CancelApply();
    }
    
    ASSERT(pWirelessPolicyData);
    if (pWirelessPolicyData->pszOldWirelessName) {
    	FreePolStr(pWirelessPolicyData->pszOldWirelessName);
    	}

    pWirelessPolicyData->pszOldWirelessName = pWirelessPolicyData->pszWirelessName;
    pWirelessPolicyData->pszWirelessName = AllocPolStr(strName);
    FreeAndThenDupString(&pWirelessPolicyData->pszDescription, strDescription);
    
    
    pWirelessPolicyData->dwPollingInterval =  (m_dwPollingInterval*60);
    
    dwNetworksToAccesssIndex = m_cbdwNetworksToAccess.GetCurSel();
    
    switch (dwNetworksToAccesssIndex) { 
    case 0 :
        dwNetworksToAccess = WIRELESS_ACCESS_NETWORK_ANY;
        break;
        
    case 1 :
        dwNetworksToAccess = WIRELESS_ACCESS_NETWORK_AP;
        break;
        
    case 2 :
        dwNetworksToAccess = WIRELESS_ACCESS_NETWORK_ADHOC;
        break;
    }
    
    pWirelessPolicyData->dwNetworkToAccess = dwNetworksToAccess;
    
    dwDisableZeroConf = m_dwEnableZeroConf ? 0 : 1;
    
    pWirelessPolicyData->dwDisableZeroConf = dwDisableZeroConf;
    
    dwAutomaticallyConnectToNonPreferredNtwks = 
        m_dwConnectToNonPreferredNtwks ? 1 : 0;
    
    pWirelessPolicyData->dwConnectToNonPreferredNtwks = 
        dwAutomaticallyConnectToNonPreferredNtwks;
    
    
    return CSnapinPropPage::OnApply();
}

void CGenPage::OnCancel()
{
    //This is a workaround to fix 343052. When there is sub dialog open and the user
    //click the corresponding result pane node, this function can get called when press
    //"ESC" or ALT_F4 although the policy property sheet is disabled.
    //We post a WM_CLOSE to the sub dialog to force them to close.
    
    //if there is any sub dialog active, force them to close
    //m_pDlgIKE may be set to NULL by the child thread during the mean time (although
    //the chance is very slim). Add a lock there to avoid potential AV
    //CSingleLock cLock(&m_csDlg);
    
    /* taroonm
    cLock.Lock();
    
      if (m_pDlgIKE)
      {
      HWND hwndDlg = m_pDlgIKE->GetSafeHwnd();
      
        if (hwndDlg)
        {
        ::PostMessage(hwndDlg, WM_CLOSE, 0, 0);
        }
        }
        
          cLock.Unlock();
    */
    CSnapinPropPage::OnCancel();
}


BOOL CGenPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DWORD* pdwHelp = (DWORD*) &g_aHelpIDs_IDD_WIRELESSGENPROP[0];
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
            c_szWlsnpHelpFile,
            HELP_WM_HELP,
            (DWORD_PTR)(LPVOID)pdwHelp);
    }
    
    return CSnapinPropPage::OnHelpInfo(pHelpInfo);
}

void CGenPage::OnChangedName()
{
    m_bNameChanged = TRUE;
    SetModified();
}

void CGenPage::OnChangedDescription()
{
    SetModified();
}

void CGenPage::OnChangedOtherParams()
{
    SetModified();
    
}
void CGenPage::SetNewSheetTitle()
{
    //dont set new tile if page is not initialized or no result object associated
    if (NULL == GetResultObject() || !m_bPageInitialized)
        return;
    
    PWIRELESS_POLICY_DATA pWirelessPolicyData = GetResultObject()->GetWirelessPolicy();
    
    if (NULL == pWirelessPolicyData->pszWirelessName)
        return;
    
    if (0 == m_strOldName.Compare(pWirelessPolicyData->pszWirelessName))
        return;
    
    CPropertySheet *psht = (CPropertySheet*)GetParent();
    
    //sometimes the psh can be NULL, for example if the page is never initialized
    if (NULL == psht)
    {
        return;
    }
    
    CString strTitle;
    psht->GetWindowText( strTitle );
    
    
    CString strAppendage;
    int nIndex;
    
    // Get the name from the DS, this is the original policy name used to
    // generate the prop sheet's title.
    
    // Assume the sheet title is of the form "<policy name> Properties",
    // and that the DSObject name is the one used to create the title.
    // This would not be true if there has been >1 rename in the General
    // page during this invocation of the owning prop sheet.
    if (-1 != (nIndex = strTitle.Find( (LPCTSTR)m_strOldName )))
    {
        CString strNewTitle;
        strNewTitle = strTitle.Left(nIndex);
        strAppendage = strTitle.Right( strTitle.GetLength() - m_strOldName.GetLength() );
        strNewTitle += pWirelessPolicyData->pszWirelessName;
        strNewTitle += strAppendage;
        psht->SetTitle( (LPCTSTR)strNewTitle );
        
        m_strOldName = pWirelessPolicyData->pszWirelessName;
    }
}

void CGenPage::OnManagerApplied()
{
    SetNewSheetTitle();
}

void CGenPage::DisableControls()
{
    SAFE_ENABLEWINDOW (IDC_EDNAME, FALSE);
    SAFE_ENABLEWINDOW (IDC_EDDESCRIPTION, FALSE);
    SAFE_ENABLEWINDOW (IDC_POLLING_INTERVAL, FALSE);
    SAFE_ENABLEWINDOW(IDC_COMBO_NETWORKS_TO_ACCESS, FALSE);
    SAFE_ENABLEWINDOW(IDC_DISABLE_ZERO_CONF, FALSE);
    SAFE_ENABLEWINDOW(IDC_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS, FALSE);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\dataobj.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Dataobj.h
//
//  Contents:   Wifi Policy management Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#ifndef _DATAOBJ_H
#define _DATAOBJ_H

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)


/////////////////////////////////////////////////////////////////////////////
// class CSnapInClipboardFormats - contains the clipboard formats supported
// by the WIRELESS snap-in
class CSnapInClipboardFormats
{
public:
    
    // Clipboard formats that are required by the console
    static unsigned int    m_cfNodeType;        // Required by the console
    static unsigned int    m_cfNodeTypeString;  // Required by the console
    static unsigned int    m_cfDisplayName;     // Required by the console
    static unsigned int    m_cfCoClass;         // Required by the console
    
    // static unsigned int    m_cfInternal;        // Step 3
    static unsigned int        m_cfWorkstation;     // Published information
    
    static unsigned int    m_cfDSObjectNames;        // Published information
    static unsigned int    m_cfPolicyObject;
};

/////////////////////////////////////////////////////////////////////////////
// Template class to extract the TYPE format from the data object
template <class TYPE>
TYPE* Extract(LPDATAOBJECT lpDataObject, unsigned int cf)
{
    ASSERT(lpDataObject != NULL);
    
    TYPE* p = NULL;
    
    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { (CLIPFORMAT)cf, NULL,
        DVASPECT_CONTENT, -1, TYMED_HGLOBAL
    };
    
    // Allocate memory for the stream
    int len = (int)((cf == CDataObject::m_cfWorkstation) ?
        ((MAX_COMPUTERNAME_LENGTH+1) * sizeof(TYPE)) : sizeof(TYPE));
    
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);
    
    // Get the workstation name from the data object
    do
    {
        if (stgmedium.hGlobal == NULL)
        {
            TRACE(_T("Extract - stgmedium.hGlobal == NULL\n"));
            break;
        }
        
        if (lpDataObject->GetDataHere(&formatetc, &stgmedium) != S_OK)
        {
            TRACE(_T("Extract - GetDataHere FAILED\n"));
            break;
        }
        
        p = reinterpret_cast<TYPE*>(stgmedium.hGlobal);
        
        if (p == NULL)
        {
            TRACE(_T("Extract - stgmedium.hGlobal cast to NULL\n"));
            break;
        }
        
    } while (FALSE);
    
    return p;
}

// helper methods extracting data from data object
// INTERNAL *   ExtractInternalFormat(LPDATAOBJECT lpDataObject);
wchar_t *    ExtractWorkstation(LPDATAOBJECT lpDataObject);
GUID *       ExtractNodeType(LPDATAOBJECT lpDataObject);
CLSID *      ExtractClassID(LPDATAOBJECT lpDataObject);

#define FREE_DATA(pData) \
    ASSERT(pData != NULL); \
    do { if (pData != NULL) \
    GlobalFree(pData); } \
while(0);


/////////////////////////////////////////////////////////////////////////////
// Template class implementing IDataObject for the WIRELESS snap-in
template <class T>
class ATL_NO_VTABLE CDataObjectImpl :
public IDataObject,
public CSnapInClipboardFormats
{
    friend class CComponentImpl;
    
    // Construction/Destruction
public:
    CDataObjectImpl()
#ifdef _DEBUG
        : m_ComponentData( NULL )
#endif
    {
        DSOBJECTObjectNamesPtr (NULL);
        POLICYOBJECTPtr (NULL);
        // INTERNALCookie (0);
    };
    ~CDataObjectImpl()
    {
#ifdef _DEBUG
        SetComponentData( NULL );
#endif
        if (DSOBJECTObjectNamesPtr() != NULL)
        {
            // TODO: we need to free the memory associated with this
            ASSERT (0);
            // and null the member ptr
            DSOBJECTObjectNamesPtr(NULL);
        }
        if (POLICYOBJECTPtr() != NULL)
        {
            delete POLICYOBJECTPtr();
            POLICYOBJECTPtr (NULL);
        }
    };
    
    // Standard IDataObject methods
public:
    // Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease);
    
    
    // Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };
    
    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
        LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL;     };
    
    
    // Implementation
public:
    STDMETHOD_(const GUID*, GetDataObjectTypeGuid)() { return &cNodeTypeWirelessMan; }
    STDMETHOD_(const wchar_t*, GetDataStringObjectTypeGuid)() { return cszNodeTypeWirelessMan; }
    
    // This is used only as a diagnostic in debug builds to track if
    // anyone is hanging on to any data objects that's have been handed out
    // Snapin's should view context data objects as ephemeral.
#ifdef _DEBUG
public:
    void SetComponentData(CComponentDataImpl* pCCD)
    {
        ASSERT((m_ComponentData == NULL && pCCD != NULL) || pCCD == NULL);
        m_ComponentData = pCCD;
    } ;
private:
    CComponentDataImpl* m_ComponentData;
#endif
    
public:
    // access functions for IDataObject hglobal data in its raw form(s)
    // void INTERNALCookie(long cookie) { m_internalData.cookie( cookie );}
    // long INTERNALCookie() {return m_internalData.cookie();}
    
    // void INTERNALType(DATA_OBJECT_TYPES type) {ASSERT(m_internalData.type() ==  CCT_UNINITIALIZED); m_internalData.type(type);}
    // DATA_OBJECT_TYPES INTERNALType() {return m_internalData.type();}
    
    //void INTERNALclsid(const CLSID& clsid) {m_internalData.clsid( clsid );}
    //CLSID INTERNALclsid () {return m_internalData.clsid();}
    
    void clsid(const CLSID& clsid) {m_clsid = clsid;}
    CLSID clsid () {return m_clsid;}
    
    void DSOBJECTObjectNamesPtr (DSOBJECTNAMES* pDSObjectNames) {m_pDSObjectNamesPtr = pDSObjectNames;}
    DSOBJECTNAMES* DSOBJECTObjectNamesPtr () {return m_pDSObjectNamesPtr;}
    
    void POLICYOBJECTPtr (POLICYOBJECT* pPolicyObjPtr) {m_pPolicyObjPtr = pPolicyObjPtr;}
    POLICYOBJECT* POLICYOBJECTPtr () {return m_pPolicyObjPtr;}
    
    void NodeName (CString &strNodeName) {m_strNodeName = strNodeName;};
    CString NodeName () {return m_strNodeName;};
    
protected:
    // allocate hglobal helpers
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium);
    HRESULT CreateWorkstationName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreateDSObjectNames(LPSTGMEDIUM lpMedium);
    HRESULT CreatePolicyObject(LPSTGMEDIUM lpMedium);
    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
    int DataGlobalAllocLen (CLIPFORMAT cf);
    
    // data associated with this IDataObject
    // INTERNAL m_internalData;
    POLICYOBJECT* m_pPolicyObjPtr;
    DSOBJECTNAMES* m_pDSObjectNamesPtr;
    CString m_strNodeName;
    
    // Class ID of who created this data object
    CLSID   m_clsid;
};

/////////////////////////////////////////////////////////////////////////////
// template CDataObjectImpl - IDataObject interface

template <class T>
STDMETHODIMP CDataObjectImpl<T>::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
    OPT_TRACE(_T("CDataObjectImpl<T>::GetData this-%p\n"), this);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    T* pThis = (T*)this;
    
    // allocate the memory
    int iLen = DataGlobalAllocLen (lpFormatetcIn->cfFormat);
    if (iLen != -1)
    {
        // allocate the required amount of memory
        lpMedium->hGlobal = GlobalAlloc(GMEM_SHARE, iLen);
        
        // make sure they know they need to free this memory
        lpMedium->pUnkForRelease = NULL;
        
        // put the data in it
        if (lpMedium->hGlobal != NULL)
        {
            // make use of
            return pThis->GetDataHere(lpFormatetcIn, lpMedium);
            
        }
    }
    
    OPT_TRACE(_T("CDataObjectImpl<T>::GetData format-%i return E_UNEXPECTED\n"), lpFormatetcIn->cfFormat);
    return E_UNEXPECTED;
}

template <class T>
STDMETHODIMP CDataObjectImpl<T>::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    OPT_TRACE(_T("CDataObjectImpl<T>::GetDataHere this-%p\n"), this);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
#ifdef DO_TRACE
    {
        CLIPFORMAT cfDebug = lpFormatetc->cfFormat;
        if (cfDebug == m_cfNodeType)
        {
            OPT_TRACE(_T("    Format: NodeTypeData\n"));
        } else if (cfDebug == m_cfCoClass)
        {
            OPT_TRACE(_T("    Format: CoClassID\n"));
        } else if(cfDebug == m_cfNodeTypeString)
        {
            OPT_TRACE(_T("    Format: NodeTypeString\n"));
        } else if (cfDebug == m_cfDisplayName)
        {
            OPT_TRACE(_T("    Format: DisplayName\n"));
            //} else if (cfDebug == m_cfInternal)
            //{
            //    OPT_TRACE(_T("    Format: INTERNAL\n"));
        } else if (cfDebug == m_cfWorkstation)
        {
            OPT_TRACE(_T("    Format: Workstation\n"));
        } else if (cfDebug == m_cfDSObjectNames)
        {
            OPT_TRACE(_T("    Format: DSObjectNames\n"));
        } else if (cfDebug == m_cfPolicyObject)
        {
            OPT_TRACE(_T("    Format: PolicyObject\n"));
        } else
        {
            OPT_TRACE(_T("    ERROR, Unknown format\n"));
        }
    }
#endif  //#ifdef DO_TRACE
    
    HRESULT hr = DV_E_CLIPFORMAT;
    
    T* pThis = (T*)this;
    
    // Based on the CLIPFORMAT create the alloc the correct amount
    // of memory and write the data to it
    const CLIPFORMAT cf = lpFormatetc->cfFormat;
    
    if (cf == m_cfNodeType)
    {
        hr = pThis->CreateNodeTypeData(lpMedium);
    } else if (cf == m_cfCoClass)
    {
        hr = pThis->CreateCoClassID(lpMedium);
    } else if(cf == m_cfNodeTypeString)
    {
        hr = pThis->CreateNodeTypeStringData(lpMedium);
    } else if (cf == m_cfDisplayName)
    {
        hr = pThis->CreateDisplayName(lpMedium);
        //} else if (cf == m_cfInternal)
        //{
        //    hr = pThis->CreateInternal(lpMedium);
    } else if (cf == m_cfWorkstation)
    {
        hr = pThis->CreateWorkstationName(lpMedium);
    } else if (cf == m_cfDSObjectNames)
    {
        hr = pThis->CreateDSObjectNames(lpMedium);
    } else if (cf == m_cfPolicyObject)
    {
        hr = pThis->CreatePolicyObject (lpMedium);
    }
    
    return hr;
}

template <class T>
STDMETHODIMP CDataObjectImpl<T>::SetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
{
    OPT_TRACE(_T("CDataObjectImpl<T>::SetData this-%p\n"), this);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = E_NOTIMPL;
    
    // only implemeneted for cf == m_cfPolicyObject
    const CLIPFORMAT cf = lpFormatetc->cfFormat;
    if (cf == m_cfPolicyObject)
    {
        // let our POLICYOBJECT pull its data out of the ObjMedium
        if (POLICYOBJECTPtr() != NULL)
        {
            hr = POLICYOBJECTPtr()->FromObjMedium (lpMedium);
            
            // did the user OK or Apply some settings?
            if (POLICYOBJECTPtr()->dwInterfaceFlags() == POFLAG_APPLY)
            {
                // well then...
                ASSERT (0);
                ::MMCPropertyChangeNotify(POLICYOBJECTPtr()->lMMCUpdateHandle(), NULL /*INTERNALCookie()*/);
            }
        }
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// template CDataObjectImpl - protected members

template <class T>
HRESULT CDataObjectImpl<T>::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    const GUID* pcObjectType = NULL;
    T* pThis = (T*)this;
    
    // get correct object type
    pcObjectType = pThis->GetDataObjectTypeGuid ();
    
    return Create(reinterpret_cast<const void*>(pcObjectType), sizeof(GUID), lpMedium);
}

template <class T>
HRESULT CDataObjectImpl<T>::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    const wchar_t* cszObjectType = NULL;
    T* pThis = (T*)this;
    
    // get correct object type string
    cszObjectType = pThis->GetDataStringObjectTypeGuid ();
    
    return Create(cszObjectType, ((wcslen(cszObjectType)+1) * sizeof(wchar_t)), lpMedium);
}

template <class T>
HRESULT CDataObjectImpl<T>::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager
    return Create(NodeName(), ((NodeName().GetLength()+1) * sizeof(wchar_t)), lpMedium);
}


template <class T>
HRESULT CDataObjectImpl<T>::CreateWorkstationName(LPSTGMEDIUM lpMedium)
{
    wchar_t pzName[MAX_COMPUTERNAME_LENGTH+1] = {0};
    DWORD len = MAX_COMPUTERNAME_LENGTH+1;
    
    if (GetComputerName(pzName, &len) == FALSE)
    {
        TRACE(_T("CDataObjectImpl<T>::CreateWorkstationName returning E_FAIL\n"));
        return E_FAIL;
    }
    
    // Add 1 for the NULL and calculate the bytes for the stream
    return Create(pzName, ((len+1)* sizeof(wchar_t)), lpMedium);
}

template <class T>
HRESULT CDataObjectImpl<T>::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create(reinterpret_cast<const void*>(&clsid()), sizeof(CLSID), lpMedium);
}

template <class T>
HRESULT CDataObjectImpl<T>::CreateDSObjectNames(LPSTGMEDIUM lpMedium)
{
    int len = 0;
    HRESULT hr = S_OK;
    
    len = DataGlobalAllocLen((CLIPFORMAT)m_cfDSObjectNames);
    
    hr = Create(DSOBJECTObjectNamesPtr(), len, lpMedium);
    
    return(hr);
}

template <class T>
HRESULT CDataObjectImpl<T>::CreatePolicyObject(LPSTGMEDIUM lpMedium)
{
    HRESULT hr = E_UNEXPECTED;
    
    // can only do this if there is a POLICYOBJECTPtr
    if (POLICYOBJECTPtr() != NULL)
    {
        // allocate a POLICYOBJECTSTRUCT of the correct length
        int iLen = POLICYOBJECTPtr()->DataGlobalAllocLen();
        POLICYOBJECTSTRUCT* pPolicyStruct = (POLICYOBJECTSTRUCT* ) malloc (iLen);
        
        if (POLICYOBJECTPtr()->ToPolicyStruct (pPolicyStruct) == S_OK)
        {
            return Create (reinterpret_cast<const void*>(pPolicyStruct), iLen, lpMedium);
        };
    }
    
    return hr;      
}

template <class T>
HRESULT CDataObjectImpl<T>::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;
    
    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;
    
    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);
        
        if (hr == S_OK)
        {
            // Write to the stream the number of bytes
            unsigned long written;
            hr = lpStream->Write(pBuffer, len, &written);
            
            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }
    
    return hr;
}

template <class T>
int CDataObjectImpl<T>::DataGlobalAllocLen (CLIPFORMAT cf)
{
    int iLen = -1;
    
    // need to determine the correct amount of space depending on the time
    if (cf == CSnapInClipboardFormats::m_cfCoClass)
    {
        iLen = sizeof (CLSID);
    } else if (cf == m_cfNodeType)
    {
        iLen = sizeof (GUID);
    } else if (cf == m_cfWorkstation)
    {
        iLen = ((MAX_COMPUTERNAME_LENGTH+1) * sizeof(wchar_t));
    } else if (cf == m_cfDSObjectNames)
    {
        // compute size of the DSOBJECTNAMES structure
        if (DSOBJECTObjectNamesPtr() != NULL)
        {
            CString strName = (LPWSTR)ByteOffset(DSOBJECTObjectNamesPtr(), DSOBJECTObjectNamesPtr()->aObjects[0].offsetName);;
            CString strClass = (LPWSTR)ByteOffset(DSOBJECTObjectNamesPtr(), DSOBJECTObjectNamesPtr()->aObjects[0].offsetClass);;
            iLen = sizeof(DSOBJECTNAMES) + sizeof(DSOBJECT);
            iLen += strName.GetLength()*sizeof(wchar_t)+1 + strClass.GetLength()*sizeof(wchar_t)+1;
        }
    } else if (cf == m_cfPolicyObject)
    {       
        // compute size of the needed POLICYSTORAGE structure
        iLen = POLICYOBJECTPtr()->DataGlobalAllocLen();
    } else
    {
        // unknown type!!
    }
    
    return iLen;
}

/////////////////////////////////////////////////////////////////////////////
// class CDataObject - standalone instantiation of IDataObject implementation
class CDataObject :
public CDataObjectImpl <CDataObject>,
public CComObjectRoot
{
    friend class CComponentImpl;
public:
    CDataObject() {};
    virtual ~CDataObject() {};
    
    // ATL Maps
    DECLARE_NOT_AGGREGATABLE(CDataObject)
        BEGIN_COM_MAP(CDataObject)
        COM_INTERFACE_ENTRY(IDataObject)
        END_COM_MAP()
        
        // Standard IDataObject methods implemented in CDataObjectImpl
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\helpids.h ===
#define IDH_WIRELESS_POLICY_NAME 50000001
#define IDH_WIRELESS_POLICY_DESCRIPTION 50000002
#define IDH_POLLING_INTERVAL 50000003
#define IDH_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS 50000004
#define IDH_NETWORKS_TO_ACCESS 50000005
#define IDH_DISABLE_ZERO_CONF 50000006

#define IDH_PS_LIST  50000021
#define IDH_ACTION_PS_ADD 50000022
#define IDH_ACTION_PS_EDIT 50000023
#define IDH_ACTION_PS_REMOVE 50000024
#define IDH_PS_UP 50000025
#define IDH_PS_DOWN 50000026

#define IDH_SSID_NAME 50000041
#define IDH_PS_DESCRIPTION 50000042
#define IDH_NETWORK_KEY 50000043
#define IDH_WEP_ENABLED 50000044
#define IDH_NETWORK_AUTHENTICATION 50000045
#define IDH_AUTOMATIC_KEY_PROVISION 50000046
#define IDH_NETWORK_TYPE 50000047

#define IDH_ENABLE_8021X 50000061
#define IDH_8021X_MODE 50000062
#define IDH_IEEE8021X_MAX_START 50000063
#define IDH_IEEE8021X_START_PERIOD 50000064
#define IDH_IEEE8021X_HELD_PERIOD 50000065
#define IDH_IEEE8021X_AUTH_PERIOD 50000066
#define IDH_EAP_TYPE 50000067
#define IDH_CERT_TYPE 50000068
#define IDH_VALIDATE_SERVER_CERT 50000069
#define IDH_GUEST_AUTHENTICATION 50000070
#define IDH_MACHINE_AUTHENTICATION 50000071
#define IDH_MC_AUTHENTICATION_TYPE 50000072
#define IDH_EAP_CONFIGURE 50000073

#define IDH_NEW_POLICY_NAME 50000081
#define IDH_NEW_POLICY_DESCRIPTION 50000082

#define IDH_EDIT_POLICY_PROPERTIES 50000091

#define IDH_OTHER_ACTIVE_DIRECTORY_DOMAIN 50000101
#define IDH_ACTIVE_DIRECTORY_DOMAIN 50000102
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\mngrfldr.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Mngrfldr.cpp
//
//  Contents:  Wireless Policy Snapin - Policy Main Page Manager.
// 
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "stdafx.h"



// #include "lm.h"
#include "dsgetdc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define RESULTVIEW_COLUMN_COUNT 3

///////////////////////////////////////////////////////////////////////////////
// class CWirelessManagerFolder - represents the MMC scope view item

CWirelessManagerFolder::CWirelessManagerFolder () :
m_bEnumerated( FALSE ),
m_pExtScopeObject( NULL ),
m_ptszResultDisplayName( NULL ),
m_dwSortOrder( 0 ),  // default is 0, else RSI_DESCENDING
m_nSortColumn( 0 ),
m_dwNumPolItems( 1 )
{
    // INTERNALCookie( (LONG_PTR)this );
    ZeroMemory( &m_ScopeItem, sizeof( SCOPEDATAITEM ) );
    
    m_bLocationPageOk = TRUE;
    m_bScopeItemInserted = FALSE;
}

CWirelessManagerFolder::~CWirelessManagerFolder ()
{
    DELETE_OBJECT(m_ptszResultDisplayName);
    
    // No need to release since we never did an AddRef
    m_pExtScopeObject = NULL;
    
}

void CWirelessManagerFolder::SetNodeNameByLocation()
{
    // Construct display name.  Assume this doesn't change during a single
    // invocation of this snap-in????
    
    CString nodeName;
    CString nodeNameOn;
    
    // If this folder is being asked for scope info, it better know
    // where ComponentData is.
    ASSERT( NULL != m_pComponentDataImpl );
    
    // Concatenate a string containing the location of this node
    switch (m_pComponentDataImpl->EnumLocation())
    {
    case LOCATION_REMOTE:
        {
            nodeNameOn = L"\\\\";
            nodeNameOn += m_pComponentDataImpl->RemoteMachineName ();
            break;
        }
    case LOCATION_GLOBAL:
        {
            nodeNameOn.LoadString (IDS_NODENAME_GLOBAL);
            
            if (m_pComponentDataImpl->RemoteMachineName().GetLength() > 0)
            {
                nodeNameOn += L" (";
                nodeNameOn += m_pComponentDataImpl->RemoteMachineName();
                nodeNameOn += L")";
            }
            
            // TODO: concider using this code to display the dns domain name
            // even when not specified. Unfortunately MMC stashes this in the
            // .MSC file IN IT'S OWN SECTION and uses it when the node is
            // first displayed. So it would be incorrect until the snapin
            // was loaded and had a chance to change it (assuming the .MSC file
            // was created in a different domain). So for now we don't do this
            /*
            // let them know which (DNS domain name) is
            // being used
            PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
            DWORD Flags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY;
            DWORD dwStatus = DsGetDcName(NULL,
            NULL,
            NULL,
            NULL,
            Flags,
            &pDomainControllerInfo
            ) ;
            if (dwStatus == NO_ERROR)
            {
            nodeNameOn += L" (";
            nodeNameOn += pDomainControllerInfo->DomainName;
            nodeNameOn += L")";
            }
            */
            
            break;
        }
        
    default:
        {
            nodeNameOn.LoadString (IDS_NODENAME_GLOBAL);
            
            if (m_pComponentDataImpl->RemoteMachineName().GetLength() > 0)
            {
                nodeNameOn += L" (";
                nodeNameOn += m_pComponentDataImpl->RemoteMachineName();
                nodeNameOn += L")";
            }
            break;
        }
        
    }
    // nodeName has a %s in it, which is where nodeNameOn goes
     nodeName.LoadString (IDS_NODENAME_BASE);
    //nodeName.FormatMessage (IDS_NODENAME_BASE ,nodeNameOn);
    // nodeName += nodeNameOn;
    
    OPT_TRACE(_T("CWirelessManagerFolder::Initialize(%p) created node name-%s\n"), this, (LPCTSTR)nodeName);
    
    // store name in our dataobject
    NodeName( nodeName );
}

void CWirelessManagerFolder::Initialize
(
 CComponentDataImpl* pComponentDataImpl,
 CComponentImpl* pComponentImpl,
 int nImage,
 int nOpenImage,
 BOOL bHasChildrenBox
 )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    // call base class initializer
    CSnapObject::Initialize( pComponentDataImpl, pComponentImpl, FALSE );
    
    ZeroMemory( &m_ScopeItem, sizeof( SCOPEDATAITEM ) );
    GetScopeItem()->mask = SDI_STR;
    GetScopeItem()->displayname = (unsigned short*)(-1);
    
    // Add close image
    GetScopeItem()->mask |= SDI_IMAGE;
    GetScopeItem()->nImage = nImage;
    
    // Add open image
    GetScopeItem()->mask |= SDI_OPENIMAGE;
    GetScopeItem()->nOpenImage = nOpenImage;
    
    // TODO: folder children flag needs to be dynamic based on actual children (PS: it doesn't work anyway!?)
    // Add button to node if the folder has children
    if (bHasChildrenBox)
    {
        GetScopeItem()->mask |= SDI_CHILDREN;
        GetScopeItem()->cChildren = 1;
    }
    
    ASSERT( NodeName().IsEmpty() ); // there should be no name since we are initializing
    
    // get our default node name set
    SetNodeNameByLocation ();


}

//////////////////////////////////////////////////////////////////////////
// handle IExtendContextMenu
STDMETHODIMP CWirelessManagerFolder::AddMenuItems
(
 LPCONTEXTMENUCALLBACK pContextMenuCallback,
 long *pInsertionAllowed
 )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CONTEXTMENUITEM mItem;
    HRESULT hr = S_OK;
    
    if ( m_pComponentDataImpl->IsRsop() )
    {
        //do not need any context menu for rsop mode
        return hr;
    }
    
    
    //if we haven't open the storage yet, don't show the context menus
    if (NULL == m_pComponentDataImpl->GetPolicyStoreHandle())
    {
        return hr;
    }
    
    LONG lFlags = 0;
    
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP && (m_dwNumPolItems == 0))
    {
        CString strMenuText;
        CString strMenuDescription;
        
        // create policy
        strMenuText.LoadString (IDS_MENUTEXT_CREATENEWSECPOL);
        strMenuDescription.LoadString (IDS_MENUDESCRIPTION_CREATENEWSECPOL);
        CONFIGUREITEM (mItem, strMenuText, strMenuDescription, IDM_CREATENEWSECPOL, CCM_INSERTIONPOINTID_PRIMARY_TOP, lFlags, 0);
        hr &= pContextMenuCallback->AddItem(&mItem);
        ASSERT(hr == S_OK);
        
    }
    
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW && (m_dwNumPolItems == 0))
    {
        CString strMenuText;
        CString strMenuDescription;
        
        // Vbug 25 indicates that all _TOP menu options must ALSO be added under TASK or NEW:
        
        // create policy
        strMenuText.LoadString (IDS_MENUTEXT_CREATENEWSECPOL);
        strMenuDescription.LoadString (IDS_MENUDESCRIPTION_CREATENEWSECPOL);
        CONFIGUREITEM (mItem, strMenuText, strMenuDescription, IDM_CREATENEWSECPOL, CCM_INSERTIONPOINTID_PRIMARY_TASK, lFlags, 0);
        hr = pContextMenuCallback->AddItem(&mItem);
        ASSERT(hr == S_OK);
    }
    
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
    {
        CString strMenuText;
        CString strMenuDescription;
        
        // Vbug 25 indicates that all _TOP menu options must ALSO be added under TASK or NEW:
        
    }
    
    return hr;
}

STDMETHODIMP_(BOOL) CWirelessManagerFolder::UpdateToolbarButton(
                                                             UINT id,                 // button ID
                                                             BOOL bSnapObjSelected,   // ==TRUE when result/scope item is selected
                                                             BYTE fsState )           // enable/disable this button state by returning TRUE/FALSE
{
    if ( m_pComponentDataImpl->IsRsop() && ( IDM_CREATENEWSECPOL == id ) )
        return FALSE;

   // GPO Change stuff
   if ((m_dwNumPolItems > 0) && (IDM_CREATENEWSECPOL == id))
   	return FALSE;
    
    if ((fsState == ENABLED) && m_pComponentDataImpl->GetPolicyStoreHandle())
        return TRUE;
    if ((fsState == INDETERMINATE) && NULL == m_pComponentDataImpl->GetPolicyStoreHandle())
        return TRUE;
    return FALSE;
}

STDMETHODIMP CWirelessManagerFolder::Command
(
 long lCommandID,
 IConsoleNameSpace *pNameSpace
 )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hrReturn = S_OK;
    
    DWORD dwError = ERROR_SUCCESS;
    
    //
    // You can always talk to storage
    //
    
    switch (lCommandID)
    {
    case IDM_CREATENEWSECPOL:
        {
            // get a name for our new security policy
            CString strUName;
	    DWORD dwError = 0;
            GenerateUniqueSecPolicyName (strUName, IDS_NEWWIRELESSPOLICYNAME);
            
            PWIRELESS_POLICY_DATA pPolicy = NULL;
            hrReturn = CreateWirelessPolicyDataBuffer(&pPolicy);
            if (FAILED(hrReturn))
            {
                break;
            }
            
            pPolicy->pszWirelessName = AllocPolStr(strUName);
            pPolicy->pszOldWirelessName = NULL;
            
            // create the new wireless policy item
            CComObject <CSecPolItem> * pNewPolItem;
            CComObject <CSecPolItem>::CreateInstance(&pNewPolItem);
            if (NULL == pNewPolItem)
            {
                FreeWirelessPolicyData(pPolicy);
                return E_OUTOFMEMORY;
            }
            
            //Add ref to control the life time of the object
            pNewPolItem->AddRef();
            
            // initialize our new item
            
            
            pNewPolItem->Initialize (
                pPolicy,
                m_pComponentDataImpl,
                m_pComponentImpl,
                TRUE);
            
            // Force the properties of the new item to display.
            //
            // Note: This must be a wizard because other code assumes it is so:
            // 1. If this is ever changed to add a policy without using the wizard,
            // CSecPolRulesPage::OnCancel() must be modified to distinguish between
            // the sheet which adds the policy, and the sheet which is displayed
            // after the wizard Finishes.
            //
            // 2. ForcePropertiesDisplay returns 1 for cancel ONLY on wizard.
            HRESULT hr = pNewPolItem->DisplaySecPolProperties (strUName);
            
            if (S_OK == hr)
            {
                hrReturn = CreateWirelessPolicy(pPolicy);
                
                if (FAILED(hrReturn))
                {
                    ReportError(IDS_SAVE_ERROR, hrReturn);
		    dwError = 1;
                    
                }
                else
                {
                    m_pComponentDataImpl->GetConsole()->UpdateAllViews( this, 0,0 );
                    
                    if (pNewPolItem->IsPropertyChangeHookEnabled())
                    {
                        pNewPolItem->EnablePropertyChangeHook(FALSE);
                        pNewPolItem->DoPropertyChangeHook();
                    }
                }
            } else
	    {
		dwError = 1;
	    }
            
            pNewPolItem->Release();

            // GPO Change : 
            //
            // inform GPE that the policy has been added or deleted
            //
	    //
	    if (dwError) {
		break;
	    }

            GUID guidClientExt = CLSID_WIRELESSClientEx;
            GUID guidSnapin = CLSID_Snapin;
            
            m_pComponentDataImpl->UseGPEInformationInterface()->PolicyChanged (
            TRUE,
            TRUE,
            &guidClientExt,
            &guidSnapin
             );
            
            break;
        }
        
        
    default:
        hrReturn = S_FALSE;
        break;
    }
    
    // S_FALSE if we didn't handle command
    return hrReturn;
}

 STDMETHODIMP CWirelessManagerFolder::QueryPagesFor( void )
 {
     // we only want to display the location page once
     HRESULT hr = E_UNEXPECTED;
     if (m_bLocationPageOk)
     {
         // display our locations dialog via this
         hr = S_OK;
     }
     
     return hr;
 }
 
 // Notify helper
 STDMETHODIMP CWirelessManagerFolder::OnPropertyChange(LPARAM lParam, LPCONSOLE pConsole )
 {
     if (NULL != lParam)
     {
         // If lParam knows about our internal interface, let it handle this event
         CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject>
             spData( (LPUNKNOWN)lParam );
         if (spData != NULL)
         {
             return spData->Notify( MMCN_PROPERTY_CHANGE, 0, 0, FALSE, pConsole, NULL /* IHeaderCtrl* */ );
         }
     }
     // call base class
     return CWirelessSnapInDataObjectImpl<CWirelessManagerFolder>::OnPropertyChange( lParam, pConsole );
 }
 
 // let us know when we are 'bout to go away
 STDMETHODIMP CWirelessManagerFolder::Destroy ( void )
 {
     // nothing to say about the destroy
     
     return S_OK;
 }
 
 // handle IComponent and IComponentData
 STDMETHODIMP CWirelessManagerFolder::Notify
     (
     MMC_NOTIFY_TYPE event,
     LPARAM arg,
     LPARAM param,
     BOOL bComponentData,    // TRUE when caller is IComponentData
     IConsole *pConsole,
     IHeaderCtrl *pHeader
     )
 {
#ifdef DO_TRACE
     OPT_TRACE(_T("CWirelessManagerFolder::Notify this-%p "), this);
     switch (event)
     {
     case MMCN_ACTIVATE:
         OPT_TRACE(_T("MMCN_ACTIVATE\n"));
         break;
     case MMCN_ADD_IMAGES:
         OPT_TRACE(_T("MMCN_ADD_IMAGES\n"));
         break;
     case MMCN_BTN_CLICK:
         OPT_TRACE(_T("MMCN_BTN_CLICK\n"));
         break;
     case MMCN_CLICK:
         OPT_TRACE(_T("MMCN_CLICK\n"));
         break;
     case MMCN_COLUMN_CLICK:
         OPT_TRACE(_T("MMCN_COLUMN_CLICK\n"));
         break;
     case MMCN_CONTEXTMENU:
         OPT_TRACE(_T("MMCN_CONTEXTMENU\n"));
         break;
     case MMCN_CUTORMOVE:
         OPT_TRACE(_T("MMCN_CUTORMOVE\n"));
         break;
     case MMCN_DELETE:
         OPT_TRACE(_T("MMCN_DELETE\n"));
         break;
     case MMCN_DESELECT_ALL:
         OPT_TRACE(_T("MMCN_DESELECT_ALL\n"));
         break;
     case MMCN_EXPAND:
         OPT_TRACE(_T("MMCN_EXPAND\n"));
         break;
     case MMCN_HELP:
         OPT_TRACE(_T("MMCN_HELP\n"));
         break;
     case MMCN_MENU_BTNCLICK:
         OPT_TRACE(_T("MMCN_MENU_BTNCLICK\n"));
         break;
     case MMCN_MINIMIZED:
         OPT_TRACE(_T("MMCN_MINIMIZED\n"));
         break;
     case MMCN_PASTE:
         OPT_TRACE(_T("MMCN_PASTE\n"));
         break;
     case MMCN_PROPERTY_CHANGE:
         OPT_TRACE(_T("MMCN_PROPERTY_CHANGE\n"));
         break;
     case MMCN_QUERY_PASTE:
         OPT_TRACE(_T("MMCN_QUERY_PASTE\n"));
         break;
     case MMCN_REFRESH:
         OPT_TRACE(_T("MMCN_REFRESH\n"));
         break;
     case MMCN_REMOVE_CHILDREN:
         OPT_TRACE(_T("MMCN_REMOVE_CHILDREN\n"));
         break;
     case MMCN_RENAME:
         OPT_TRACE(_T("MMCN_RENAME\n"));
         break;
     case MMCN_SELECT:
         OPT_TRACE(_T("MMCN_SELECT\n"));
         break;
     case MMCN_SHOW:
         OPT_TRACE(_T("MMCN_SHOW\n"));
         break;
     case MMCN_VIEW_CHANGE:
         OPT_TRACE(_T("MMCN_VIEW_CHANGE\n"));
         break;
     case MMCN_SNAPINHELP:
         OPT_TRACE(_T("MMCN_SNAPINHELP\n"));
         break;
     case MMCN_CONTEXTHELP:
         OPT_TRACE(_T("MMCN_CONTEXTHELP\n"));
         break;
     case MMCN_INITOCX:
         OPT_TRACE(_T("MMCN_INITOCX\n"));
         break;
     case MMCN_FILTER_CHANGE:
         OPT_TRACE(_T("MMCN_FILTER_CHANGE\n"));
         break;
     default:
         OPT_TRACE(_T("Unknown event\n"));
         break;
     }
#endif   //#ifdef DO_TRACE
     
     AFX_MANAGE_STATE(AfxGetStaticModuleState());
     HRESULT hr = S_FALSE;
     
     // handle the event
     switch(event)
     {
     case MMCN_CONTEXTHELP:
         {
             CComQIPtr <IDisplayHelp, &IID_IDisplayHelp> pDisplayHelp ( pConsole );
             ASSERT( pDisplayHelp != NULL );
             if (pDisplayHelp)
             {
                 // need to form a complete path to the .chm file
                 CString s, s2;
                 s.LoadString(IDS_HELPCONCEPTSFILE);
                 DWORD dw = ExpandEnvironmentStrings (s, s2.GetBuffer (512), 512);
                 s2.ReleaseBuffer (-1);
                 if ((dw == 0) || (dw > 512))
                 {
                     return E_UNEXPECTED;
                 }
                 pDisplayHelp->ShowTopic(s2.GetBuffer(512));
                 s2.ReleaseBuffer (-1);
                 hr = S_OK;
             }
             break;
         }
     case MMCN_SELECT:
         {
             BOOL bSelect = (BOOL) HIWORD(arg);
             
             if (bSelect)
             {
                 // Obtain IConsoleVerb from console
                 CComPtr<IConsoleVerb> spVerb;
                 pConsole->QueryConsoleVerb( &spVerb );
                 
                 // call object to set verb state
                 AdjustVerbState( (IConsoleVerb*)spVerb );
             }
             hr = S_OK;
             break;
         }
     case MMCN_SHOW:
         {
             // Note - arg is TRUE when it is time to enumerate
             if (arg == TRUE)
             {
                 CWaitCursor waitCursor; // turn on the hourglass
                 
                 CComQIPtr <IResultData, &IID_IResultData> pResultData( pConsole );
                 ASSERT( pResultData != NULL );
                 
                 
                 ASSERT( pHeader != NULL );
                 SetHeaders( pHeader, pResultData );
                 
                 //$review sometimes the MMCN_SELECT was not sent to the snapin when the node
                 //is selected, use MMCN_SHOW to adjustverbstate instead
                 CComPtr<IConsoleVerb> spVerb;
                 pConsole->QueryConsoleVerb( &spVerb );
                 AdjustVerbState((IConsoleVerb*)spVerb);
                 
                 // enumerate result items in that Folder
                 EnumerateResults( pResultData, m_nSortColumn, m_dwSortOrder );
             }
             else
             {
                 // TODO: free data associated with the result pane items, because
                 // TODO: your node is no longer being displayed (??)
                 
                 CComQIPtr <IResultData, &IID_IResultData> pResultData( pConsole );
                 ASSERT( pResultData != NULL );
                 
                 // if we have a handle to the pResultData
                 if (pResultData)
                 {
                     // zip through and free off any result items we have laying around
                     RESULTDATAITEM resultItem;
                     ZeroMemory(&resultItem, sizeof(resultItem));
                     resultItem.mask = RDI_PARAM | RDI_STATE;
                     resultItem.nIndex = -1;
                     resultItem.nState = LVNI_ALL;
                     HRESULT hr;
                     do
                     {
                         hr = pResultData->GetNextItem (&resultItem);
                         if (hr == S_OK)
                         {
                             // free it off
                             // if it ain't the right type of object we'll leak it
                             IUnknown* pUnk = (IUnknown*)resultItem.lParam;
                             ASSERT (pUnk);
                             if (pUnk)
                             {
                                 CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData( pUnk );
                                 if (spData)
                                 {
                                     // release it in prep for tossing all the objects
                                     spData.Release();
                                 }
                             }
                             
                         }
                     } while (hr == S_OK);
                     
                     // now release this handle to their interface
                     // m_pResultData->Release();
                 }
                 
                 
                 
                 // NOTE: but the following, found in the sample snapin at this point,
                 // NOTE: conflicted with my above comment...
                 // Note: The console will remove the items from the result pane
             }
             return S_OK;
         }
     case MMCN_PROPERTY_CHANGE:
         {
             hr = OnPropertyChange( param, pConsole );
             
             break;
         }
     case MMCN_DELETE:
         {
             CThemeContextActivator activator;
             // delete the item
             if (AfxMessageBox (IDS_SUREYESNO, MB_YESNO | MB_DEFBUTTON2) == IDYES)
             {
                 hr = OnDelete( arg, param );
                 if (S_OK == hr)
                 {
                     // CAN'T DO THIS ON A STRICTLY SCOPE DELETE
                     /*
                     // find reference to the parent (get pDataObject of parent)
                     SCOPEDATAITEM parentScopeDataItem;
                     parentScopeDataItem.ID = m_pScopeItem->relativeID;
                     parentScopeDataItem.mask = RDI_STR | RDI_PARAM | RDI_INDEX;
                     hr = m_pComponentDataImpl->GetConsoleNameSpace()->GetItem (&parentScopeDataItem);
                     ASSERT (SUCCEEDED(hr));
                     CSnapFolder* pParentFolder = reinterpret_cast<CSnapFolder*>(parentScopeDataItem.lParam);
                     
                       // now tell the parent to refresh
                       pParentFolder->ForceRefresh (NULL);
                     */
                 }
             }
             break;
         }
     case MMCN_REMOVE_CHILDREN:
         {
             SetEnumerated(FALSE);
	     m_bScopeItemInserted = FALSE;
             break;
         }
     case MMCN_RENAME:
         {
             hr = OnRename (arg, param);
             break;
         }
     case MMCN_EXPAND:
         {
             if (arg == TRUE)
             {
                 // TODO: if this is the root node this is our chance to save off the HSCOPEITEM of roots parent
                 //if (pInternal->m_cookie == NULL)
                 //      m_pRootFolderScopeItem = pParent;
                 
                 CComQIPtr <IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace( pConsole );
                 // tell this folder to enumerate itself to the scope pane
                 OnScopeExpand( (IConsoleNameSpace*)spConsoleNameSpace, param );
                 
                 hr = S_OK;
             } else
             {
                 // TODO: handle MMCN_EXPAND arg == FALSE
                 ASSERT (0);
                 hr = S_FALSE;
             }
             break;
         }
     case MMCN_VIEW_CHANGE:
         {
             // Obtain IResultData
             CComQIPtr <IResultData, &IID_IResultData> pResultData( pConsole );
             ASSERT( pResultData != NULL );
             
             // Hint contains sort info, save it for calls to EnumerateResults
             m_nSortColumn = LOWORD( param );
             m_dwSortOrder = HIWORD( param );
             
             ASSERT( RESULTVIEW_COLUMN_COUNT > m_nSortColumn );
             ASSERT( 0 == m_dwSortOrder || RSI_DESCENDING == m_dwSortOrder );
             
             ForceRefresh( pResultData );
             break;
         }
     case MMCN_REFRESH:
         {
             // reset the reconnect flag
             m_pComponentDataImpl->m_bAttemptReconnect = TRUE;
             
             // Cause result pane to refresh its policy list
             hr = pConsole->UpdateAllViews( this, 0, 0 );
             ASSERT(hr == S_OK);
             break;
         }
     case MMCN_ADD_IMAGES:
         {
             // Obtain IImageList from console
             CComPtr<IImageList> spImage;
             HRESULT hr = pConsole->QueryResultImageList( &spImage );
             ASSERT(hr == S_OK);
             
             OnAddImages( arg, param, (IImageList*)spImage );
             hr = S_OK;
             break;
         }
     default:
         break;
    }
    
    return hr;
}

// handle IComponent
STDMETHODIMP CWirelessManagerFolder::GetResultDisplayInfo( RESULTDATAITEM *pResultDataItem )
{
    TCHAR *temp = NULL;
    DWORD dwError = S_OK;
    
    OPT_TRACE(_T("CWirelessManagerFolder::GetResultDisplayInfo this-%p\n"), this);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    // We should be here only if we are loaded as an extension snap-in.
    ASSERT( NULL != GetExtScopeObject() );
    
    // are they looking for the image?
    if (pResultDataItem->mask & RDI_IMAGE)
    {
        pResultDataItem->nImage = GetScopeItem()->nImage;
        OPT_TRACE(_T("    returning image[%i]\n"), GetScopeItem()->nImage);
    }
    
    // are they looking for a string?
    if (pResultDataItem->mask & RDI_STR)
    {
        // which column?
        switch (pResultDataItem->nCol)
        {
        case 0:
            // node name
            temp = (TCHAR*)realloc( m_ptszResultDisplayName, (NodeName().GetLength()+1)*sizeof(TCHAR) );
            if (temp != NULL)
            {
                m_ptszResultDisplayName = temp;
                lstrcpy (m_ptszResultDisplayName, NodeName().GetBuffer(20));
            } else
            {
                dwError = GetLastError();
            }
            NodeName().ReleaseBuffer(-1);
            pResultDataItem->str = m_ptszResultDisplayName;
            OPT_TRACE(_T("    returning node name-%s\n"), m_ptszResultDisplayName);
            break;
        case 1:
            {
                // node description
                CString strDescription;
                strDescription.LoadString (IDS_DESCRIPTION);
                temp = (TCHAR*) realloc (m_ptszResultDisplayName, (strDescription.GetLength()+1)*sizeof(TCHAR));
                if (temp != NULL)
                {
                    m_ptszResultDisplayName = temp;
                    lstrcpy (m_ptszResultDisplayName, strDescription.GetBuffer(20));
                } else
                {
                   dwError = GetLastError(); 
                }
                strDescription.ReleaseBuffer(-1);
                pResultDataItem->str = m_ptszResultDisplayName;
                OPT_TRACE(_T("    returning node description-%s\n"), m_ptszResultDisplayName);
                break;
            }
        default:
            pResultDataItem->str = (LPOLESTR)_T("");
            OPT_TRACE(_T("    returning NULL string\n"));
            break;
        }
    }
    
    return HRESULT_FROM_WIN32(dwError);
}

// handle IComponentData
STDMETHODIMP CWirelessManagerFolder::GetScopeDisplayInfo( SCOPEDATAITEM *pScopeDataItem )
{
    OPT_TRACE(_T("CWirelessManagerFolder::GetScopeDisplayInfo SCOPEDATAITEM.lParam-%p\n"), pScopeDataItem->lParam);
    if (pScopeDataItem->mask & SDI_STR)
    {
        ASSERT( NodeName().GetLength() );
        OPT_TRACE(_T("    display string-%s\n"), (LPCTSTR)NodeName());
        // return display string
        pScopeDataItem->displayname = (LPTSTR)(LPCTSTR)NodeName();
    }
    if (pScopeDataItem->mask & SDI_IMAGE)
        pScopeDataItem->nImage = GetScopeItem()->nImage;
    if (pScopeDataItem->mask & SDI_OPENIMAGE)
        pScopeDataItem->nOpenImage = GetScopeItem()->nOpenImage;
    if (pScopeDataItem->mask & SDI_CHILDREN)
        pScopeDataItem->cChildren = 0;  // WIFI mgr is always a scope leaf node
    return S_OK;
}


// IWirelessSnapInData
STDMETHODIMP CWirelessManagerFolder::GetScopeData( SCOPEDATAITEM **ppScopeDataItem )
{
    ASSERT( NULL == ppScopeDataItem );
    
    if (NULL == ppScopeDataItem)
        return E_INVALIDARG;
    *ppScopeDataItem = GetScopeItem();
    return S_OK;
}

STDMETHODIMP CWirelessManagerFolder::GetGuidForCompare( GUID *pGuid )
{
    return E_UNEXPECTED;
}

STDMETHODIMP CWirelessManagerFolder::AdjustVerbState (LPCONSOLEVERB pConsoleVerb)
{
    HRESULT hr = S_OK;
    
    // Don't need to call base class, it disables REFRESH
    if ( m_pComponentDataImpl->IsRsop() ) {
        hr = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
    } else {
        // Enable refresh
        hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, HIDDEN, FALSE);
        ASSERT (hr == S_OK);
        hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE);
        ASSERT (hr == S_OK);
    }
    
    // double make sure that properties is disabled
    // (we don't ever enabled it but we have been seeing it work on some builds
    // and not on others, i suspect this is an uninitialized variable in MMCland)
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
    ASSERT (hr == S_OK);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
    ASSERT (hr == S_OK);
    
    return hr;
}

void CWirelessManagerFolder::RemoveResultItem(LPUNKNOWN pUnkWalkingDead)
{
    // free it off
    // if it ain't the right type of object we'll leak it
    ASSERT (pUnkWalkingDead);
    if (pUnkWalkingDead)
    {
        CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData( pUnkWalkingDead );
        if (spData)
        {
            // release it in prep for tossing all the objects
            spData.Release();
        }
    }
}

///////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CWirelessManagerFolder::EnumerateResults (
                                       LPRESULTDATA pResult, int nSortColumn, DWORD dwSortOrder
                                       )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    HANDLE hPolicyStore = NULL;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    PWIRELESS_POLICY_DATA pPolicy = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD dwError = 0;
    PWIRELESS_POLICY_DATA * ppWirelessPolicyData = NULL;
    
    
    // Obtain storage containing policies
    
    hPolicyStore = m_pComponentDataImpl->GetPolicyStoreHandle();
    
    if (NULL == hPolicyStore)
        return hr;
 
    m_dwNumPolItems = 0;
    dwError = WirelessEnumPolicyData(
        hPolicyStore,
        &ppWirelessPolicyData,
        &dwNumPolicyObjects
        );
   /* Taroon BUG: Memory Leak.. Not freeing ppWirelessPolicyData*/
    if ( dwError != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwError);
        return hr;
    }
    
    for (i = 0; i < dwNumPolicyObjects; i++) {
        
        // create a new CSecPolItem
        
        pPolicy = *(ppWirelessPolicyData + i);
        
        LPCSECPOLITEM pItem;
        CComObject <CSecPolItem>::CreateInstance(&pItem);
        
        // initialize the item
        
        pItem->Initialize (pPolicy, m_pComponentDataImpl, m_pComponentImpl, FALSE);
        
        pItem->GetResultItem()->mask |= RDI_PARAM;
        pItem->GetResultItem()->lParam = (LPARAM) pItem;
        OPT_TRACE(_T("    setting RESULTDATAITEM.lParam-%p\n"), pItem);
        
        // QI to increment ref count
        LPUNKNOWN pUnk;
        hr = pItem->QueryInterface(IID_IUnknown, (void**)&pUnk);
        ASSERT (hr == S_OK);
        OPT_TRACE(_T("    QI on ComObject->IUnknown - %p->%p\n"), pItem, pUnk);
        
        // add item to result pane
        LPRESULTDATAITEM prdi = NULL;
        dynamic_cast<IWirelessSnapInDataObject*>(pItem)->GetResultData(&prdi);
        ASSERT( NULL != prdi );
        hr = pResult->InsertItem( prdi );
        
        // when the item is removed from the UI the QI'd interface will be released
        
        
    }

    m_dwNumPolItems = dwNumPolicyObjects;
    
    // set the sort parameters
    if (m_dwNumPolItems > 1) {
        pResult->Sort( nSortColumn, dwSortOrder, 0 );
    	}
    
    return hr;
}

STDMETHODIMP_(void) CWirelessManagerFolder::SetHeaders(LPHEADERCTRL pHeader, LPRESULTDATA pResult)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(pResult != NULL);
    
    // set the description bar text
    CString strDesc;
    strDesc.LoadString (IDS_SNAPIN_DESC);
    pResult->SetDescBarText(strDesc.GetBuffer(5));
    
    
    CString strName;
    
    //first two columns are common for both rsop and non-rsop case
    strName.LoadString (IDS_COLUMN_NAME);
    pHeader->InsertColumn(COL_NAME, strName, LVCFMT_LEFT, 140);            
    
    strName.LoadString (IDS_COLUMN_DESCRIPTION);
    pHeader->InsertColumn(COL_DESCRIPTION, strName, LVCFMT_LEFT, 160);

    // GPO New
    
    if ( !m_pComponentDataImpl->IsRsop() )
    {
         /* 
        // if it is local or remote then third column is the ASSIGNED column
        if ((m_pComponentDataImpl->EnumLocation()==LOCATION_REMOTE)
            || (m_pComponentDataImpl->EnumLocation()==LOCATION_LOCAL)
            // extension snapin?
            || ((m_pComponentDataImpl->EnumLocation()==LOCATION_GLOBAL) && (NULL != m_pComponentDataImpl->GetStaticScopeObject()->GetExtScopeObject()))
            )
        {
            strName.LoadString (IDS_COLUMN_POLICYASSIGNED);
            pHeader->InsertColumn(COL_ACTIVE, strName, LVCFMT_LEFT, 160);
        }
        
        //for ds case, date stored in polstore is not valid, do not show for ds
        if (m_pComponentDataImpl->EnumLocation() != LOCATION_GLOBAL )
        {
            strName.LoadString (IDS_POLICY_MODIFIEDTIME);
            pHeader->InsertColumn(COL_LAST_MODIFIED, strName, LVCFMT_LEFT, 160);
        }
        */
    }
    else
    {
        //rsop case, columns will be different
        strName.LoadString(IDS_COLUMN_GPONAME);
        pHeader->InsertColumn(COL_GPONAME, strName, LVCFMT_LEFT, 160);
        
        strName.LoadString(IDS_COLUMN_PRECEDENCE);
        pHeader->InsertColumn(COL_PRECEDENCE, strName, LVCFMT_LEFT, 160);
        
        strName.LoadString(IDS_COLUMN_OU);
        pHeader->InsertColumn(COL_OU, strName, LVCFMT_LEFT, 160);

        m_nSortColumn = COL_PRECEDENCE;
    }
    
    
}






/////////////////////////////////////////////////////////////////////////////

void CWirelessManagerFolder::GenerateUniqueSecPolicyName (CString& strName, UINT nID)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    BOOL bUnique = TRUE;
    int iUTag = 0;
    CString strUName;
    
    DWORD dwError = 0;
    DWORD i = 0;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    PWIRELESS_POLICY_DATA * ppWirelessPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    
    // if an nID was passed in then start with that
    if (nID != 0)
    {
        strName.LoadString (nID);
    }
    
    // zip through the policies and verify name is unique
    do
    {
        HANDLE hPolicyStore = NULL;
        
        // only start tacking numbers on after the first pass
        if (iUTag > 0)
        {
            TCHAR buff[32];
            wsprintf (buff, _T(" (%d)"), iUTag);
            strUName = strName + buff;
            bUnique = TRUE;
        } else
        {
            strUName = strName;
            bUnique = TRUE;
        }
        
        hPolicyStore = m_pComponentDataImpl->GetPolicyStoreHandle();
        
        dwError = WirelessEnumPolicyData(
            hPolicyStore,
            &ppWirelessPolicyData,
            &dwNumPolicyObjects
            );
        
        for (i = 0; i < dwNumPolicyObjects; i++) {
            
            pWirelessPolicyData = *(ppWirelessPolicyData + i);
            if (0 == strUName.CompareNoCase(pWirelessPolicyData->pszWirelessName)) {
                // set bUnique to FALSE
                bUnique = FALSE;
                iUTag++;
                
            }
            FreeWirelessPolicyData(pWirelessPolicyData);
        }
        
    }
    while (bUnique == FALSE);
    
    // done
    strName = strUName;
}


HRESULT CWirelessManagerFolder::ForceRefresh( LPRESULTDATA pResultData )
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;
    BOOL bNeedChangeToolbar = FALSE;
    
    //if haven't successfully opened the storage yet, try again now.
    if (NULL == m_pComponentDataImpl->GetPolicyStoreHandle())
    {
        DWORD dwError = 0;
        dwError = m_pComponentDataImpl->OpenPolicyStore();
        if (ERROR_SUCCESS != dwError)
        {
            hr = HRESULT_FROM_WIN32(dwError);
            ReportError(IDS_POLMSG_EFAIL, hr);
            return hr;
        }
        
        ASSERT(NULL != m_pComponentDataImpl->GetPolicyStoreHandle());
        
    }
    
    // turn on the hourglass
    CWaitCursor waitCursor;
    
    // to determine if we should delete the result items
    CPtrList deletedList;
    CPtrList releaseList;
    BOOL bEnumerateItems = FALSE;
    
    // release the interface for each of these result items as
    // we are 'bout to nuke them
    RESULTDATAITEM resultItem;
    ZeroMemory(&resultItem, sizeof(resultItem));
    resultItem.mask = RDI_PARAM | RDI_STATE | RDI_INDEX;
    resultItem.nIndex = -1;
    resultItem.nState = LVNI_ALL;
    
    // get the next item
    hr = pResultData->GetNextItem (&resultItem);
    if (hr == S_OK)
    {
        while (hr == S_OK)
        {
            // if we recieved a scope node from the enumerations bail, they
            // are refreshing a view that is displaying our scope node, not
            // our result items (the only things that need to be refreshed)
            
            // NOTE: an alternate (and more correct?) way to do this could
            // be to keep track of our IComponent instances; in this situation
            // we actually have two of them and if we knew which one we
            // were we'd know if there were any result items to be refreshed
            // We can't currently do this because the CWirelessManagerFolder is
            // stored in the IComponentData implementation.
            if (resultItem.bScopeItem == TRUE)
                return S_OK;
            
            // free it off
            // if it ain't the right type of object we'll leak it
            IUnknown* pUnk = (IUnknown*)resultItem.lParam;
            ASSERT (pUnk);
            if (pUnk)
            {
                CComQIPtr<IWirelessSnapInDataObject, &IID_IWirelessSnapInDataObject> spData( pUnk );
                if (spData)
                {
                    // delete it
                    HRESULTITEM actualItemID;
                    if (pResultData->FindItemByLParam (resultItem.lParam, &actualItemID) == S_OK)
                    {
                        // save for delete, release and note that we need to do deletion
                        deletedList.AddHead ((void*)actualItemID);
                        releaseList.AddHead ((void*)spData);
                        
                        bEnumerateItems = TRUE;
                    }
                } else
                {
                    OPT_TRACE(_T("\tCWirelessManagerFolder::ForceRefresh(%p) couldn't QI on pUnk\n"), this);
                }
                
            }
            
            // get the next item
            hr = pResultData->GetNextItem (&resultItem);
        }
    } else
    {
        // there was _nothing_ in the list; so we enumerate anyway to see
        // if there is something to add
        bEnumerateItems = TRUE;
    }
    
    if (bEnumerateItems)
    {
        // delete them
        while (!deletedList.IsEmpty())
        {
            LONG_PTR pLong = (LONG_PTR)deletedList.RemoveHead();
            pResultData->DeleteItem (pLong, 0);
            OPT_TRACE(_T("\tCWirelessManagerFolder::ForceRefresh(%p) deleting item,    itemID(%p)\n"), this, pLong);
        }
        // we have no longer been enumerated
        SetEnumerated(FALSE);
        // re-add all items to our local list, which re-connects to storage
        // for us; so we want to make sure that any warnings are displayed
        m_pComponentDataImpl->IssueStorageWarning (TRUE);
        
        //EnumerateResults( pResultData, m_nSortColumn, m_dwSortOrder );
        HRESULT hrTemp = EnumerateResults( pResultData, m_nSortColumn, m_dwSortOrder );
        
        //If the rpc connection is broken after we open the storage last time, the handle will
        //become invalid. We need to re-open the storage to get a new handle.
        if (FAILED(hrTemp))
        {
            dwError = m_pComponentDataImpl->OpenPolicyStore();
            if (ERROR_SUCCESS != dwError)
            {
                hrTemp = HRESULT_FROM_WIN32(dwError);
            }
            else
            {
                hrTemp = EnumerateResults( pResultData, m_nSortColumn, m_dwSortOrder );
            }
        }
        
        if (FAILED(hrTemp))
        {
            bNeedChangeToolbar = TRUE;
            
            //ReportError(IDS_POLMSG_EFAIL, hrTemp);
        }
        
        //release them
        while (!releaseList.IsEmpty())
        {
            IWirelessSnapInDataObject* spData = (IWirelessSnapInDataObject*)releaseList.RemoveHead();
            OPT_TRACE(_T("\tCWirelessManagerFolder::ForceRefresh(%p) releasing spData (%p)\n"), this, spData);
            spData->Release();
        }
        
    }
    
    return hr;
}

HRESULT CWirelessManagerFolder::OnScopeExpand( LPCONSOLENAMESPACE pConsoleNameSpace, HSCOPEITEM hScopeItem )
{
    // paramater validation
    ASSERT(pConsoleNameSpace != NULL);
    
    // turn on the hourglass
    CWaitCursor waitCursor;
    
    HRESULT hr = S_OK;
    // for later addition of sub-items we need to store our ID...
    // (note that if we were inserted by ourself we would already have a valid id here
    // ASSERT(hScopeItem != NULL);
    GetScopeItem()->ID = hScopeItem;
    
    if (!IsEnumerated())
    {
        // Insert the scope item if we are an extension snap-in
        if (NULL != GetExtScopeObject() && !m_bScopeItemInserted)
        {
            // Set the parent
            GetScopeItem()->relativeID = hScopeItem;
            
            // insert it into the scope
            hr = pConsoleNameSpace->InsertItem( GetScopeItem() );
            ASSERT(hr == S_OK);

	    m_bScopeItemInserted = TRUE;
            
            // Note - On return, the ID member of 'm_pScopeItem'
            // contains the handle to the newly inserted item!
            ASSERT( GetScopeItem()->ID != NULL );
        }
        
        DWORD dwError = 0;
        dwError = m_pComponentDataImpl->OpenPolicyStore();
        if (ERROR_SUCCESS != dwError)
        {
            hr = HRESULT_FROM_WIN32(dwError);
            ReportError(IDS_POLMSG_EFAIL, hr);
        }
        
        // We have been enumerated
        SetEnumerated(TRUE);
    }
    
    return hr;
}

HRESULT CWirelessManagerFolder::OnAddImages(LPARAM arg, LPARAM param, IImageList* pImageList )
{
    ASSERT( NULL != pImageList );
    // TODO: what is arg, this only succeeds if it is not 0 but it isn't used...
    if (arg == 0)
        return E_INVALIDARG;
    
    CBitmap bmp16x16;
    CBitmap bmp32x32;
    
    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);
    
    // Set the images
    HRESULT hr = pImageList->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)), reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)), 0, RGB(255, 0, 255));
    ASSERT (hr == S_OK);
    
    return S_OK;
}

HRESULT CWirelessManagerFolder::CreateWirelessPolicy(PWIRELESS_POLICY_DATA pPolicy)
{
    ASSERT(pPolicy);
    HRESULT hr = S_OK;
    
    HANDLE hPolicyStore = NULL;

    // NEW GPO
    // Add Microsoft/Windows in Policies Container if its not there.
    
    CString szMachinePath;
    szMachinePath = m_pComponentDataImpl->DomainGPOName();
    hr = AddWirelessPolicyContainerToGPO(szMachinePath);
    if (FAILED(hr)) {
    	goto Error;
    	} 
    
    hPolicyStore = m_pComponentDataImpl->GetPolicyStoreHandle();
    ASSERT(hPolicyStore);
    
    CWRg(WirelessCreatePolicyData(hPolicyStore,
        pPolicy));
    
Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\helparr.h ===
CONST WCHAR c_szWlsnpHelpFile[]  = L"%windir%\\help\\wireless.hlp";

const DWORD g_aHelpIDs_IDD_LOCATIONPAGE[]=
{
    IDC_RADIOSPECIFICDIRECTORYSERVICE, IDH_OTHER_ACTIVE_DIRECTORY_DOMAIN, // Select Computer: "Manage domain policy for another &domain:" (Button)
        IDC_EDITDNSDOMAIN, IDH_OTHER_ACTIVE_DIRECTORY_DOMAIN, // Select Computer: "" (Edit)
        IDC_RADIODIRECTORYSERVICE, IDH_ACTIVE_DIRECTORY_DOMAIN, // Select Computer: "&Manage domain policy for this computer's domain" (Button)
        0, 0
};



const DWORD g_aHelpIDs_IDD_PROPPAGE_N_DONE[]=
{
    IDC_CHECKPROPERTIES, IDH_EDIT_POLICY_PROPERTIES, // Filter Action Wizard: "Edit &properties" (Button)
        0, 0
};




const DWORD g_aHelpIDs_IDD_PS_LIST[]=
{
    IDI_ICON, -1,
        IDC_STATIC_INFOTEXT, -1,
        IDC_SEPARATOR, -1,
        IDC_STATIC_PS_LIST, IDH_PS_LIST,
        IDC_PS_LIST, IDH_PS_LIST,
        IDC_ACTION_PS_ADD, IDH_ACTION_PS_ADD,
        IDC_ACTION_PS_EDIT, IDH_ACTION_PS_EDIT,
        IDC_ACTION_PS_REMOVE, IDH_ACTION_PS_REMOVE,
        IDC_PS_UP, IDH_PS_UP,
        IDC_PS_DOWN, IDH_PS_DOWN,
        0, 0
};


const DWORD g_aHelpIDs_IDD_8021X_PROPERTY_PAGE[] =
{
    IDC_ENABLE_8021X, IDH_ENABLE_8021X,
        IDC_STATIC_8021X_MODE, IDH_8021X_MODE,
        IDC_COMBO_8021X_MODE, IDH_8021X_MODE,
        IDC_STATIC_MAX_START, IDH_IEEE8021X_MAX_START,
        IDC_IEEE8021X_MAX_START, IDH_IEEE8021X_MAX_START,
        IDC_STATIC_START_PERIOD,IDH_IEEE8021X_START_PERIOD,
        IDC_IEEE8021X_START_PERIOD, IDH_IEEE8021X_START_PERIOD,
        IDC_STATIC_HELD_PERIOD,IDH_IEEE8021X_HELD_PERIOD,
        IDC_IEEE8021X_HELD_PERIOD, IDH_IEEE8021X_HELD_PERIOD,
        IDC_STATIC_AUTH_PERIOD,IDH_IEEE8021X_AUTH_PERIOD,
        IDC_IEEE8021X_AUTH_PERIOD, IDH_IEEE8021X_AUTH_PERIOD,
        IDC_STATIC_EAP_TYPE, IDH_EAP_TYPE,
        IDC_EAP_TYPE_COMBO, IDH_EAP_TYPE,
        IDC_EAP_CONFIGURE, IDH_EAP_CONFIGURE,
        IDC_GUEST_AUTHENTICATION, IDH_GUEST_AUTHENTICATION,
        IDC_MACHINE_AUTHENTICATION, IDH_MACHINE_AUTHENTICATION,
        IDC_COMBO_MC_AUTH_TYPE, IDH_MC_AUTHENTICATION_TYPE,
        IDC_STATIC_AUTH_TYPE, IDH_MC_AUTHENTICATION_TYPE,
        0, 0
};

const DWORD g_aHelpIDs_IDD_SSID[]=
{
    IDC_STATIC_SSID_NAME, IDH_SSID_NAME,
        IDC_SSID_NAME, IDH_SSID_NAME,
        IDC_STATIC_PS_DESCRIPTION, IDH_PS_DESCRIPTION,
        IDC_PS_DESCRIPTION, IDH_PS_DESCRIPTION,
        IDC_STATIC_NETWORK_KEY, IDH_NETWORK_KEY,
        IDC_WEP_ENABLED, IDH_WEP_ENABLED,
        IDC_NETWORK_AUTHENTICATION, IDH_NETWORK_AUTHENTICATION,
        IDC_AUTOMATIC_KEY_PROVISION, IDH_AUTOMATIC_KEY_PROVISION,
        IDC_NETWORK_TYPE, IDH_NETWORK_TYPE,
        0,0
};




const DWORD g_aHelpIDs_IDD_WIRELESSGENPROP[]=
{
    IDC_STATIC_NAME, IDH_WIRELESS_POLICY_NAME,
        IDC_EDNAME, IDH_WIRELESS_POLICY_NAME,
        IDC_STATIC_DESCRIPTION, IDH_WIRELESS_POLICY_DESCRIPTION,
        IDC_EDDESCRIPTION, IDH_WIRELESS_POLICY_DESCRIPTION,
        IDC_POLLING_INTERVAL, IDH_POLLING_INTERVAL,
        IDC_STATIC_POLLING_INTERVAL, IDH_POLLING_INTERVAL,
        IDC_STATIC_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS, IDH_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS,
        IDC_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS, IDH_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS,
        IDC_STATIC_NETWORKS_TO_ACCESS, IDH_NETWORKS_TO_ACCESS,
        IDC_COMBO_NETWORKS_TO_ACCESS, IDH_NETWORKS_TO_ACCESS,
        IDC_STATIC_DISABLE_ZERO_CONF, IDH_DISABLE_ZERO_CONF,
        IDC_DISABLE_ZERO_CONF, IDH_DISABLE_ZERO_CONF,
        IDC_STATIC_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS, IDH_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS,
        IDC_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS, IDH_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS,   
        0, 0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_G_NAMEDESCRIPTION[]=
{
    IDC_STATIC_NEW_POLICY_NAME, IDH_NEW_POLICY_NAME,
        IDC_NEW_POLICY_NAME, IDH_NEW_POLICY_NAME,
        IDC_STATIC_NEW_POLICY_DESCRIPTION, IDH_NEW_POLICY_DESCRIPTION,
        IDC_NEW_POLICY_DESCRIPTION, IDH_NEW_POLICY_DESCRIPTION,
        0,0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_P_WELCOME[]=
{
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\ipsutil.h ===
#ifndef INCLUDE_IPSUTIL_H
#define INCLUDE_IPSUTIL_H

// This file contains utility functions for wireless components

// Function: SELECT_PREV_LISTITEM
// Description: 
//  Intended to be used after deleting a CListCtrl item to reset
//  the selected item.
// Returns:
//  index - returns with the new index which is -1 if the list
//  is empty.
template<class T>
inline int SELECT_PREV_LISTITEM(T &list, int nIndex)
{
    int nSelectIndex;
    if (0 == list.GetItemCount())
        return -1;
    else
        nSelectIndex = max( 0, nIndex - 1 );
    
    ASSERT( nSelectIndex < list.GetItemCount() );
    
    if (nSelectIndex >= 0)
    {
        VERIFY(list.SetItemState( nSelectIndex, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED ));
    }
    return nSelectIndex;
}

// Function: SELECT_NO_LISTITEM
// Description:
//  This function is intended to used on a CListCtrl.  It ensures
//  no list items are selected.
template<class T>
inline void SELECT_NO_LISTITEM(T &list)
{
    
    if (0 == list.GetSelectedCount())
        return;
    int nIndex = -1;
    while (-1 != (nIndex = list.GetNextItem( nIndex, LVNI_SELECTED )))
    {
        VERIFY(list.SetItemState( nIndex, 0, LVIS_SELECTED | LVIS_FOCUSED ));
    }
    ASSERT( 0 == list.GetSelectedCount() );
    
    return;
}

// Function: SET_POST_REMOVE_FOCUS
// Description:
//  This function is intended to be used on a dialogs.  It sets the
//  focus to an appropriate control after a list item has been deleted.
template<class T>
inline void SET_POST_REMOVE_FOCUS( T *pDlg, int nListSel, UINT nAddId, UINT nRemoveId, CWnd *pWndPrevFocus )
{
    ASSERT( 0 != nAddId );
    ASSERT( 0 != nRemoveId );
    
    // Fix up focus, if necessary
    if (::GetFocus() == NULL)
    {
        if (-1 == nListSel)
        {
            // Set focus to add button when theres is nothing in the list
            CWnd *pWndButton = pDlg->GetDlgItem( nAddId );
            ASSERT( NULL != pWndButton );
            pDlg->GotoDlgCtrl( pWndButton );
        }
        else
        {
            if (NULL != pWndPrevFocus)
            {
                // Restore lost focus
                pDlg->GotoDlgCtrl( pWndPrevFocus );
            }
            else
            {
                // Restore focus to remove button
                CWnd *pWndButton = pDlg->GetDlgItem( nRemoveId );
                ASSERT( NULL != pWndButton );
                pDlg->GotoDlgCtrl( pWndButton );
            }
        }
    }
    
    return;
}

#endif  //#ifndef INCLUDE_IPSUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\new.h ===
HRESULT
AddWirelessPolicyContainerToGPO(
                     const CString & pszMachinePath
                     );

HRESULT
AddPolicyInformation(
                     LPWSTR pszMachinePath,
                     LPWSTR pszName,
                     LPWSTR pszDescription,
                     LPWSTR pszPathName
                     );

HRESULT
DeletePolicyInformation(
                        LPWSTR pszMachinePath
                        );

HRESULT
ConvertADsPathToDN(
                   LPWSTR pszPathName,
                   BSTR * ppszPolicyDN
                   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\new.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       New.cpp
//
//  Contents:  Wireless Policy Snapin - New Policy Creation 
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <htmlhelp.h>

#include "activeds.h"
#include "iadsp.h"
#include "new.h"


HRESULT
CreateDirectoryAndBindToObject(
                               IDirectoryObject * pParentContainer,
                               LPWSTR pszCommonName,
                               LPWSTR pszObjectClass,
                               IDirectoryObject ** ppDirectoryObject
                               )
{
    ADS_ATTR_INFO AttrInfo[2];
    ADSVALUE classValue;
    HRESULT hr = S_OK;
    IADsContainer * pADsContainer = NULL;
    IDispatch * pDispatch = NULL;
    
    //
    // Populate ADS_ATTR_INFO structure for new object
    //
    classValue.dwType = ADSTYPE_CASE_IGNORE_STRING;
    classValue.CaseIgnoreString = pszObjectClass;
    
    AttrInfo[0].pszAttrName = L"objectClass";
    AttrInfo[0].dwControlCode = ADS_ATTR_UPDATE;
    AttrInfo[0].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
    AttrInfo[0].pADsValues = &classValue;
    AttrInfo[0].dwNumValues = 1;
    
    hr = pParentContainer->CreateDSObject(
        pszCommonName,
        AttrInfo,
        1,
        &pDispatch
        );
    if ((FAILED(hr) && (hr == E_ADS_OBJECT_EXISTS)) ||
        (FAILED(hr) && (hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS)))){
        
        hr = pParentContainer->QueryInterface(
            IID_IADsContainer,
            (void **)&pADsContainer
            );
        BAIL_ON_FAILURE(hr);
        
        hr = pADsContainer->GetObject(
            pszObjectClass,
            pszCommonName,
            &pDispatch
            );
        BAIL_ON_FAILURE(hr);
        
    }
    
    hr = pDispatch->QueryInterface(
        IID_IDirectoryObject,
        (void **)ppDirectoryObject
        );
    
error:
    
    if (pADsContainer) {
        
        pADsContainer->Release();
    }
    
    if (pDispatch) {
        
        pDispatch->Release();
    }
    
    return(hr);
}

HRESULT
CreateChildPath(
                LPWSTR pszParentPath,
                LPWSTR pszChildComponent,
                BSTR * ppszChildPath
                )
{
    HRESULT hr = S_OK;
    IADsPathname     *pPathname = NULL;
    
    hr = CoCreateInstance(
        CLSID_Pathname,
        NULL,
        CLSCTX_ALL,
        IID_IADsPathname,
        (void**)&pPathname
        );
    BAIL_ON_FAILURE(hr);
    
    hr = pPathname->Set(pszParentPath, ADS_SETTYPE_FULL);
    BAIL_ON_FAILURE(hr);
    
    hr = pPathname->AddLeafElement(pszChildComponent);
    BAIL_ON_FAILURE(hr);
    
    hr = pPathname->Retrieve(ADS_FORMAT_X500, ppszChildPath);
    BAIL_ON_FAILURE(hr);
    
error:
    if (pPathname) {
        pPathname->Release();
    }
    
    return(hr);
}



HRESULT
ConvertADsPathToDN(
                   LPWSTR pszPathName,
                   BSTR * ppszPolicyDN
                   )
{
    HRESULT hr = S_OK;
    IADsPathname     *pPathname = NULL;
    
    hr = CoCreateInstance(
        CLSID_Pathname,
        NULL,
        CLSCTX_ALL,
        IID_IADsPathname,
        (void**)&pPathname
        );
    BAIL_ON_FAILURE(hr);
    
    hr = pPathname->Set(pszPathName, ADS_SETTYPE_FULL);
    BAIL_ON_FAILURE(hr);
    
    hr = pPathname->Retrieve(ADS_FORMAT_X500_DN, ppszPolicyDN);
    BAIL_ON_FAILURE(hr);
    
error:
    
    if (pPathname) {
        pPathname->Release();
    }
    
    
    return(hr);
}

// Create Container for Our Policies. 

HRESULT
AddWirelessPolicyContainerToGPO(
                      const CString & szMachinePath
                     )
{
    
    HRESULT hr = S_OK;
    IDirectoryObject * pMachineContainer = NULL;
    IDirectoryObject * pWindowsContainer = NULL;
    IDirectoryObject * pMicrosoftContainer = NULL;
    IDirectoryObject * pWirelessContainer = NULL;
    
    BSTR pszMicrosoftPath = NULL;
    BSTR pszWindowsPath = NULL;
    BSTR pszWirelessPath = NULL;
    CString szCompleteMachinePath;
    LPWSTR  szMachineContainerPath;
    CString prefixMachinePath;

    prefixMachinePath = L"LDAP://";

    szCompleteMachinePath = prefixMachinePath + szMachinePath;
    szMachineContainerPath = szCompleteMachinePath.GetBuffer(0);
    
    hr = ADsGetObject(
        szMachineContainerPath,
        IID_IDirectoryObject,
        (void **)&pMachineContainer
        );
    BAIL_ON_FAILURE(hr);
    
    
    // Build the fully qualified ADsPath for my object
    
    
    hr = CreateChildPath(
        szMachineContainerPath,
        L"cn=Microsoft",
        &pszMicrosoftPath
        );
    BAIL_ON_FAILURE(hr);
    
    hr = CreateChildPath(
        pszMicrosoftPath,
        L"cn=Windows",
        &pszWindowsPath
        );
    BAIL_ON_FAILURE(hr);

    hr = CreateChildPath(
        pszWindowsPath,
        L"cn=Wireless",
        &pszWirelessPath
        );
    BAIL_ON_FAILURE(hr);
    
    hr = ADsGetObject(
        pszWirelessPath,
        IID_IDirectoryObject,
        (void **)&pWirelessContainer
        );
    
    if (FAILED(hr)) {
        
        //
        // Bind to the Machine Container
        //
        
        hr = CreateDirectoryAndBindToObject(
            pMachineContainer,
            L"cn=Microsoft",
            L"container",
            &pMicrosoftContainer
            );
        BAIL_ON_FAILURE(hr);
        
        hr = CreateDirectoryAndBindToObject(
            pMicrosoftContainer,
            L"cn=Windows",
            L"container",
            &pWindowsContainer
            );
        BAIL_ON_FAILURE(hr);

        hr = CreateDirectoryAndBindToObject(
            pWindowsContainer,
            L"cn=Wireless",
            L"container",
            &pWirelessContainer
            );
        BAIL_ON_FAILURE(hr);
    }
    
error:
    
     if (pWirelessContainer) {
        pWirelessContainer->Release();
     }


    if (pWindowsContainer) {
        pWindowsContainer->Release();
    }

    if (pMicrosoftContainer) {
        pMicrosoftContainer->Release();
    }
    
    if (pMachineContainer) {
        pMachineContainer->Release();
    }
    
    if (pszMicrosoftPath) {
        SysFreeString(pszMicrosoftPath);
    }
    
    
    if (pszWindowsPath) {
        SysFreeString(pszWindowsPath);
        
    }
    
    
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\nfabpage.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Nfabpage.cpp
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWirelessBasePage property page base class

IMPLEMENT_DYNCREATE(CWirelessBasePage, CSnapPage)

BEGIN_MESSAGE_MAP(CWirelessBasePage, CSnapPage)
//{{AFX_MSG_MAP(CWirelessBasePage)
ON_WM_DESTROY()
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CWirelessBasePage::CWirelessBasePage (UINT nIDTemplate, BOOL bWiz97 /*=FALSE*/, BOOL bFinishPage /*=FALSE*/) : CWiz97BasePage(nIDTemplate, bWiz97, bFinishPage)
{
    m_pWirelessPSData = NULL;
    m_pPolicyNfaOwner = NULL;
    m_pComponentDataImpl = NULL;
}

CWirelessBasePage::~CWirelessBasePage ()
{
    if (m_pWirelessPSData != NULL)
    {
        
    }
}

void CWirelessBasePage::Initialize (PWIRELESS_PS_DATA pWirelessPSData, CComponentDataImpl* pComponentDataImpl)
{
    // store the params
    m_pComponentDataImpl = pComponentDataImpl;
    m_pWirelessPSData = pWirelessPSData;
    
    // Initialize base class
    CSnapPage::Initialize( NULL);
};

#ifdef WIZ97WIZARDS
void CWirelessBasePage::InitWiz97 (CComObject<CSecPolItem> *pSecPolItem, PWIRELESS_PS_DATA pWirelessPSData, CComponentDataImpl* pComponentDataImpl, DWORD dwFlags, DWORD dwWizButtonFlags, UINT nHeaderTitle, UINT nSubTitle)
{
    // store the params
    m_pWirelessPSData = pWirelessPSData;
    m_pComponentDataImpl = pComponentDataImpl;
    
    
    // initialize baseclass
    CWiz97BasePage::InitWiz97 (pSecPolItem, dwFlags, dwWizButtonFlags, nHeaderTitle, nSubTitle);
};
#endif

/////////////////////////////////////////////////////////////////////////////
// CWirelessBasePage message handlers

BOOL CWirelessBasePage::OnSetActive()
{
    // there can only be one
    CPropertySheet* pSheet = (CPropertySheet*) GetParent(); 
    if (GetParent())
    {
        // add context help to the style bits
        GetParent()->ModifyStyleEx (0, WS_EX_CONTEXTHELP, 0);
    }
    
    return CWiz97BasePage::OnSetActive();
}

////////////////////////////////////////////////////////////////////////////
// CPSPropSheetManager

BOOL CPSPropSheetManager::OnApply()
{
    BOOL bRet = TRUE;
    
    //Query each page to apply
    bRet = CPropertySheetManager::OnApply();
    
    //if some page refuse to apply, dont do anything
    if (!bRet)
        return bRet;
    
    HRESULT hr = S_OK;
    
    //tell the pages that the apply is done
    NotifyManagerApplied();
    
    return bRet;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\mngrfldr.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Mngrfldr.h
//
//  Contents:  Wireless Policy Snapin - Policy Main Page Manager.
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#ifndef _MNGRFLDR_H
#define _MNGRFLDR_H

///////////////////////////////////////////////////////////////////////////////
// class CWirelessManagerFolder - represents the MMC scope view item

class CWirelessManagerFolder :
public CWirelessSnapInDataObjectImpl <CWirelessManagerFolder>,
public CDataObjectImpl <CWirelessManagerFolder>,
public CComObjectRoot,
public CSnapObject
{
    
    // ATL Maps
    DECLARE_NOT_AGGREGATABLE(CWirelessManagerFolder)
        BEGIN_COM_MAP(CWirelessManagerFolder)
        COM_INTERFACE_ENTRY(IDataObject)
        COM_INTERFACE_ENTRY(IWirelessSnapInDataObject)
        END_COM_MAP()
        
public:
    CWirelessManagerFolder ();
    virtual ~CWirelessManagerFolder ();
    
    virtual void Initialize (CComponentDataImpl* pComponentDataImpl, CComponentImpl* pComponentImpl, int nImage, int nOpenImage, BOOL bHasChildrenBox);
    
public:
    // IWirelessSnapInDataObject interface
    // handle IExtendContextMenu
    STDMETHOD(AddMenuItems)( LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed );
    STDMETHOD(Command)( long lCommandID,
        IConsoleNameSpace *pNameSpace );
    STDMETHOD(QueryPagesFor)( void );
    // Notify helper
    STDMETHOD(OnPropertyChange)(LPARAM lParam, LPCONSOLE pConsole );
    // let us know when we are 'bout to go away
    STDMETHOD(Destroy)( void );
    // handle IComponent and IComponentData
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
        BOOL bComponentData,
        IConsole *pConsole,
        IHeaderCtrl *pHeader );
    // handle IComponent
    STDMETHOD(GetResultDisplayInfo)( RESULTDATAITEM *pResultDataItem );
    // handle IComponentData
    STDMETHOD(GetScopeDisplayInfo)( SCOPEDATAITEM *pScopeDataItem );
    // IWirelessSnapInData
    STDMETHOD(GetScopeData)( SCOPEDATAITEM **ppScopeDataItem );
    STDMETHOD(GetGuidForCompare)( GUID *pGuid );
    STDMETHOD(AdjustVerbState)(LPCONSOLEVERB pConsoleVerb);
    STDMETHOD_(BOOL, UpdateToolbarButton)( UINT id,                 // button ID
        BOOL bSnapObjSelected,   // ==TRUE when result/scope item is selected
        BYTE fsState );           // enable/disable this button state by returning TRUE/FALSE
    void RemoveResultItem( LPUNKNOWN pUnkWalkingDead );
    
public:
    STDMETHOD_(void, SetHeaders)(LPHEADERCTRL pHeader, LPRESULTDATA pResult);
    STDMETHOD(EnumerateResults)(LPRESULTDATA pResult, int nSortColumn, DWORD dwSortOrder);
    
    
    // ExtendContextMenu helpers
public:
    // Note: The following IDM_* have been defined in resource.h because they
    // are potential candidates for toolbar buttons.  The value assigned to
    // each IDM_* is the value of the related IDS_MENUDESCRIPTION_* string ID.
    /*
    enum
    {
    // Identifiers for each of the commands/views to be inserted into the context menu
    IDM_CREATENEWSECPOL,
    IDM_MANAGENEGPOLS_FILTERS,
    IDM_IMPORTFILE,
    IDM_EXPORTFILE,
    IDM_POLICYINTEGRITYCHECK,
    IDM_RESTOREDEFAULTPOLICIES
    };
    */
    
    // IExtendControlbar helpers
public:
    BEGIN_SNAPINTOOLBARID_MAP(CWirelessManagerFolder)
        SNAPINTOOLBARID_ENTRY(IDR_TOOLBAR_WIRELESS_MGR_SCOPE)
        END_SNAPINTOOLBARID_MAP(CWirelessManagerFolder)
        
        // Notify helpers
protected:
    HRESULT ForceRefresh( LPRESULTDATA pResultData );
    HRESULT OnScopeExpand( LPCONSOLENAMESPACE pConsoleNameSpace, HSCOPEITEM hScopeItem );
    HRESULT OnAddImages(LPARAM arg, LPARAM param, IImageList* pImageList );
    
    // attributes
public:
    void SetExtScopeObject( CComObject<CWirelessManagerFolder>* pScope )
    {
        ASSERT( NULL == m_pExtScopeObject );
        m_pExtScopeObject = pScope;
    }
    CComObject<CWirelessManagerFolder>* GetExtScopeObject() { return m_pExtScopeObject; }
    LPSCOPEDATAITEM GetScopeItem() {return &m_ScopeItem;};
    void SetNodeNameByLocation();
    void LocationPageDisplayEnable (BOOL bOk) {m_bLocationPageOk = bOk;};
    
protected:
    BOOL IsEnumerated() {return m_bEnumerated;};
    void SetEnumerated(BOOL bState) { m_bEnumerated = bState; };
    void GenerateUniqueSecPolicyName (CString& strName, UINT nID);
    HRESULT CreateWirelessPolicy(PWIRELESS_POLICY_DATA pPolicy);
    
private:
    CComObject <CWirelessManagerFolder>    *m_pExtScopeObject;  // NULL if we are a standalone snap-in
    
    TCHAR   *m_ptszResultDisplayName;
    BOOL    m_bEnumerated;
    SCOPEDATAITEM   m_ScopeItem;
    BOOL m_bLocationPageOk;
    
    DWORD   m_dwSortOrder;  // default is 0, else RSI_DESCENDING
    int     m_nSortColumn;
    BOOL    m_bScopeItemInserted;
    int     m_dwNumPolItems;
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\nfaa.h ===
#if !defined(AFX_NFAA_H__5A483ED1_41B7_11D1_89DB_00A024CDD4DE__INCLUDED_)
#define AFX_NFAA_H__5A483ED1_41B7_11D1_89DB_00A024CDD4DE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// NFAa.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPS8021XPropPage dialog

class CPS8021XPropPage : public CWirelessBasePage
{
    DECLARE_DYNCREATE(CPS8021XPropPage)
        
        // Construction
public:
    CPS8021XPropPage(UINT nIDTemplate);
    CPS8021XPropPage();
    ~CPS8021XPropPage();
    
    // Dialog Data
    //{{AFX_DATA(CPS8021XPropPage)
    enum { IDD = IDD_8021X_PROPERTY_PAGE };
    BOOL m_dwEnable8021x;
    INT m_dw8021xMode;
    CComboBox m_cbCertificateType;
    BOOL   m_dwValidateServerCertificate;
    BOOL m_dwMachineAuthentication;
    INT m_dwMachineAuthenticationType;
    BOOL m_dwGuestAuthentication;
    HWND    m_hwnd8021xCheck; // Handle for 8021x checkbox
    DWORD     m_dwIEEE8021xMaxStart;
    DWORD     m_dwIEEE8021xStartPeriod;
    DWORD     m_dwIEEE8021xAuthPeriod;
    DWORD     m_dwIEEE8021xHeldPeriod;
    CComboBox m_cbEapType;
    CComboBox m_cb8021xMode;
    CComboBox m_cbMachineAuthenticationType;
    
    
    //}}AFX_DATA
    
    void  CPS8021XPropPage::Initialize ( PWIRELESS_PS_DATA , CComponentDataImpl *, BOOL); 
    
    
    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPS8021XPropPage)
    virtual LRESULT OnWizardNext();
    virtual BOOL OnWizardFinish();
    virtual BOOL OnApply();
    virtual void OnCancel();
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL
    
    // Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPS8021XPropPage)
    virtual BOOL OnInitDialog();
    void DisplayEnable8021x();
    void DisplayEapType();
    void DisplayMachineAuthentication();
    afx_msg void OnSel8021xMode();
    afx_msg void OnCheck8021x();
    afx_msg void OnSelCertType();
    afx_msg void OnCheckValidateServerCert();
    afx_msg void OnSelMachineAuthenticationType();
    afx_msg void OnCheckMachineAuthentication();
    afx_msg void OnCheckGuestAuthentication();
    afx_msg void OnIEEE8021xParams();
    afx_msg void OnSelEapType();
    afx_msg DWORD CPS8021XPropPage::OnProperties();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
        
        BOOL ControlDataToWirelessPS();
private:
    BOOL m_bReadOnly;
    BOOL m_bHasApplied; // So that we apply only once
    DTLLIST *  pListEapcfgs;
    DWORD dwEAPUpdated;
    void DisableControls();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NFAA_H__5A483ED1_41B7_11D1_89DB_00A024CDD4DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\nfaa.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Nfaa.cpp
//
//  Contents:  Wireless Policy Snapin - IEEE 8021.x property page for each PS.
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------
#include "stdafx.h"

#include "NFAa.h"
#include "wzcsapi.h"
#include <raseapif.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPS8021XPropPage property page

IMPLEMENT_DYNCREATE(CPS8021XPropPage, CWirelessBasePage)

CPS8021XPropPage::CPS8021XPropPage(UINT nIDTemplate) : CWirelessBasePage(nIDTemplate)
{
    //{{AFX_DATA_INIT(CPS8021XPropPage)
    m_dwEnable8021x = FALSE;
    m_dwValidateServerCertificate = FALSE;
    m_dwMachineAuthentication = FALSE;
    m_dwGuestAuthentication = FALSE;
    dwEAPUpdated = 0;
    pListEapcfgs = NULL;
    m_bHasApplied = FALSE;
    
    //}}AFX_DATA_INIT
}

CPS8021XPropPage::CPS8021XPropPage() : CWirelessBasePage(CPS8021XPropPage::IDD)
{
    //{{AFX_DATA_INIT(CPS8021XPropPage)
    m_dwEnable8021x = FALSE;
    m_dwValidateServerCertificate = FALSE;
    m_dwMachineAuthentication = FALSE;
    m_dwGuestAuthentication = FALSE;
    dwEAPUpdated = 0;
    pListEapcfgs = NULL;
    m_bHasApplied = FALSE;
    
    //}}AFX_DATA_INIT
}

CPS8021XPropPage::~CPS8021XPropPage()
{
    EAPCFG* pEapcfg = NULL;
    DTLNODE *pNodeEap = NULL;
    
    if (pListEapcfgs) {

        // Delete the data allocated using AllocPolMem
        for (pNodeEap = DtlGetFirstNode(pListEapcfgs);
                 pNodeEap;
                 pNodeEap = DtlGetNextNode(pNodeEap)
             	)
        {
            pEapcfg = (EAPCFG* )DtlGetData(pNodeEap);
            ASSERT( pEapcfg );

            if (pEapcfg->pData) {
            	FreePolMem(pEapcfg->pData);
            }
            pEapcfg->pData = NULL;
            pEapcfg->cbData = 0;
        }
        DtlDestroyList (pListEapcfgs, DestroyEapcfgNode);
    }
    pListEapcfgs = NULL;
    
}

void CPS8021XPropPage::DoDataExchange(CDataExchange* pDX)
{
    CWirelessBasePage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPS8021XPropPage)
    DDX_Check(pDX, IDC_ENABLE_8021X, m_dwEnable8021x);
    DDX_Control(pDX, IDC_COMBO_8021X_MODE, m_cb8021xMode);
    DDX_Check(pDX, IDC_MACHINE_AUTHENTICATION, m_dwMachineAuthentication);
    DDX_Check(pDX, IDC_GUEST_AUTHENTICATION, m_dwGuestAuthentication);
    DDX_Control(pDX, IDC_COMBO_MC_AUTH_TYPE, m_cbMachineAuthenticationType);
    DDX_Text(pDX, IDC_IEEE8021X_MAX_START, m_dwIEEE8021xMaxStart);
    DDX_Text(pDX, IDC_IEEE8021X_START_PERIOD, m_dwIEEE8021xStartPeriod);
    DDX_Text(pDX, IDC_IEEE8021X_AUTH_PERIOD, m_dwIEEE8021xAuthPeriod);
    DDX_Text(pDX, IDC_IEEE8021X_HELD_PERIOD, m_dwIEEE8021xHeldPeriod);
    DDX_Control(pDX, IDC_EAP_TYPE_COMBO, m_cbEapType);
    
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPS8021XPropPage, CWirelessBasePage)
//{{AFX_MSG_MAP(CPS8021XPropPage)
ON_CBN_SELENDOK(IDC_COMBO_8021X_MODE, OnSel8021xMode)
ON_BN_CLICKED(IDC_ENABLE_8021X, OnCheck8021x)
ON_CBN_SELENDOK(IDC_COMBO_MC_AUTH_TYPE, OnSelMachineAuthenticationType)
ON_BN_CLICKED(IDC_GUEST_AUTHENTICATION, OnCheckGuestAuthentication)
ON_BN_CLICKED(IDC_MACHINE_AUTHENTICATION, OnCheckMachineAuthentication)
ON_EN_CHANGE(IDC_IEEE8021X_MAX_START,OnIEEE8021xParams)
ON_EN_CHANGE(IDC_IEEE8021X_START_PERIOD,OnIEEE8021xParams)
ON_EN_CHANGE(IDC_IEEE8021X_HELD_PERIOD,OnIEEE8021xParams)
ON_EN_CHANGE(IDC_IEEE8021X_AUTH_PERIOD,OnIEEE8021xParams)
ON_CBN_SELENDOK(IDC_EAP_TYPE_COMBO, OnSelEapType)
ON_BN_CLICKED(IDC_EAP_CONFIGURE, OnProperties)

ON_WM_HELPINFO()
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPS8021XPropPage message handlers
BOOL CPS8021XPropPage::OnInitDialog()
{
    DWORD     dwIEEE8021xMaxStart;
    DWORD     dwIEEE8021xStartPeriod;
    DWORD     dwIEEE8021xAuthPeriod;
    DWORD     dwIEEE8021xHeldPeriod;
    CString   pszIEEE8021xMaxStart;
    CString   pszIEEE8021xStartPeriod;
    CString   pszIEEE8021xAuthPeriod;
    CString   pszIEEE8021xHeldPeriod;
    CString pszTemp;
    DWORD dwEapIndex;
    DWORD dw8021xModeIndex;
    DWORD dwMachineAuthenticationTypeIndex;
    DWORD  dwCertTypeIndex;
    DWORD dwEAPType = 0;
    DWORD dwEAPDataLen = 0;
    LPBYTE pbEAPData = NULL;
    DTLNODE*    pOriginalEapcfgNode = NULL;
    BYTE        *pbData = NULL;
    DWORD       cbData = 0;
    DTLNODE* pNode = NULL;
    DWORD i = 0;
    DWORD dwEAPSel = 0;

    
    m_bHasApplied = FALSE;

    CWirelessBasePage::OnInitDialog();
    
    
    
    ASSERT( NULL != WirelessPS() );
    
    // get data from storage 
    
    PWIRELESS_PS_DATA pWirelessPSData = NULL;
    
    pWirelessPSData = WirelessPS();

    dwEAPType = pWirelessPSData->dwEapType;
    dwEAPDataLen = pWirelessPSData->dwEAPDataLen;
    pbEAPData = pWirelessPSData->pbEAPData;
    
    // Initialize EAP package list
    // Read the EAPCFG information from the registry and find the node
    // selected in the entry, or the default, if none.

    pListEapcfgs = NULL;

    pListEapcfgs = ::ReadEapcfgList (EAPOL_MUTUAL_AUTH_EAP_ONLY);

    if (pListEapcfgs)
    {

        for (pNode = DtlGetFirstNode(pListEapcfgs);
             pNode;
             pNode = DtlGetNextNode(pNode)
             	)
        {
            EAPCFG* pEapcfg = (EAPCFG* )DtlGetData(pNode);
            ASSERT( pEapcfg );

            cbData = 0;
            pbData = NULL;

            i = m_cbEapType.AddString(pEapcfg->pszFriendlyName);
            m_cbEapType.SetItemDataPtr(i, pNode);

            if (pEapcfg->dwKey == dwEAPType) {
                cbData = dwEAPDataLen;
                if (dwEAPDataLen) {
                	pbData = (LPBYTE) AllocPolMem(dwEAPDataLen);
                	if (!pbData) {
                		return FALSE;
                	}
                	memcpy(pbData, pbEAPData, dwEAPDataLen);
                }
                dwEAPSel = i;
            	}

            pEapcfg->pData = pbData;
            pEapcfg->cbData = cbData;
         }

         // Choose the EAP name that will appear in the combo box
         
         m_cbEapType.SetCurSel(dwEAPSel);

    }
    
    
    m_dwIEEE8021xMaxStart =
        pWirelessPSData->dwIEEE8021xMaxStart;
    m_dwIEEE8021xStartPeriod = 
        pWirelessPSData->dwIEEE8021xStartPeriod;
    m_dwIEEE8021xAuthPeriod = 
        pWirelessPSData->dwIEEE8021xAuthPeriod;
    m_dwIEEE8021xHeldPeriod =
        pWirelessPSData->dwIEEE8021xHeldPeriod;
    
    m_dwGuestAuthentication = 
        pWirelessPSData->dwGuestAuthentication ? TRUE : FALSE;
    
    m_dwEnable8021x = 
        pWirelessPSData->dwEnable8021x ? TRUE : FALSE;
    
    pszTemp.LoadString(IDS_8021X_MODE_NO_TRANSMIT);
    m_cb8021xMode.AddString(pszTemp);
    
    pszTemp.LoadString(IDS_8021X_MODE_NAS_TRANSMIT);
    m_cb8021xMode.AddString(pszTemp);
    
    pszTemp.LoadString(IDS_8021X_MODE_TRANSMIT);
    m_cb8021xMode.AddString(pszTemp);
    
    switch (pWirelessPSData->dw8021xMode)
    {
        
    case WIRELESS_8021X_MODE_NO_TRANSMIT_EAPOLSTART_WIRED: 
        dw8021xModeIndex = 0;
        break;
    case WIRELESS_8021X_MODE_NAS_TRANSMIT_EAPOLSTART_WIRED:
        dw8021xModeIndex = 1;
        break;
    case WIRELESS_8021X_MODE_TRANSMIT_EAPOLSTART_WIRED: 
        dw8021xModeIndex = 2;
        break;
    default:
        dw8021xModeIndex = 0;
        break;
    }
    
    m_cb8021xMode.SetCurSel(dw8021xModeIndex);
    
    m_dwMachineAuthentication = 
        pWirelessPSData->dwMachineAuthentication ? TRUE : FALSE;
    
    pszTemp.LoadString(IDS_MC_AUTH_TYPE_MC_NO_USER);
    m_cbMachineAuthenticationType.AddString(pszTemp);
    
    pszTemp.LoadString(IDS_MC_AUTH_TYPE_USER_DONTCARE_MC);
    m_cbMachineAuthenticationType.AddString(pszTemp);
    
    
    pszTemp.LoadString(IDS_MC_AUTH_TYPE_MC_ONLY);
    m_cbMachineAuthenticationType.AddString(pszTemp);
    
    
    switch (pWirelessPSData->dwMachineAuthenticationType)
    {
    case WIRELESS_MC_AUTH_TYPE_MC_NO_USER:
        dwMachineAuthenticationTypeIndex = 0;
        break;
    case WIRELESS_MC_AUTH_TYPE_USER_DONTCARE_MC:
        dwMachineAuthenticationTypeIndex = 1;
        break;
    case WIRELESS_MC_AUTH_TYPE_MC_ONLY:
        dwMachineAuthenticationTypeIndex = 2;
        break;
        
    default:
        dwMachineAuthenticationTypeIndex = 0;
        break;
    }
    m_cbMachineAuthenticationType.SetCurSel(dwMachineAuthenticationTypeIndex);
    
    
    DisplayEnable8021x();
    
    if (m_bReadOnly) {
        DisableControls();
    }
    
    
    // set radio correctly
    UpdateData (FALSE);
    
    // set radio controled edits correctly
    //OnRadioAdapterType();
    
    // OK, we can start paying attention to modifications made via dlg controls now.
    // This should be the last call before returning from OnInitDialog.
    OnFinishInitDialog();
    
    return TRUE;  // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE
}


void
CPS8021XPropPage::DisplayEnable8021x()
{
    if(m_dwEnable8021x) {
        
        SAFE_ENABLEWINDOW(IDC_COMBO_8021X_MODE, TRUE);
        SAFE_ENABLEWINDOW(IDC_STATIC_8021X_MODE, TRUE);
        SAFE_ENABLEWINDOW(IDC_EAP_TYPE_COMBO, TRUE);
        SAFE_ENABLEWINDOW(IDC_STATIC_EAP_TYPE, TRUE);
        SAFE_ENABLEWINDOW(IDC_IEEE8021X_MAX_START, TRUE);
        SAFE_ENABLEWINDOW(IDC_IEEE8021X_START_PERIOD, TRUE);
        SAFE_ENABLEWINDOW(IDC_IEEE8021X_HELD_PERIOD, TRUE);
        SAFE_ENABLEWINDOW(IDC_IEEE8021X_AUTH_PERIOD, TRUE);
        SAFE_ENABLEWINDOW(IDC_STATIC_MAX_START, TRUE);
        SAFE_ENABLEWINDOW(IDC_STATIC_START_PERIOD, TRUE);
        SAFE_ENABLEWINDOW(IDC_STATIC_HELD_PERIOD, TRUE);
        SAFE_ENABLEWINDOW(IDC_STATIC_AUTH_PERIOD, TRUE);
        SAFE_ENABLEWINDOW(IDC_STATIC_8021X_PARAMS, TRUE);
        
        DisplayEapType();
        
        
    } else {
        
        SAFE_ENABLEWINDOW(IDC_COMBO_8021X_MODE,FALSE);
        SAFE_ENABLEWINDOW(IDC_STATIC_8021X_MODE,FALSE);
        SAFE_ENABLEWINDOW(IDC_EAP_TYPE_COMBO,FALSE);
        SAFE_ENABLEWINDOW(IDC_STATIC_EAP_TYPE, FALSE);
        SAFE_ENABLEWINDOW(IDC_IEEE8021X_MAX_START, FALSE);
        SAFE_ENABLEWINDOW(IDC_IEEE8021X_START_PERIOD, FALSE);
        SAFE_ENABLEWINDOW(IDC_IEEE8021X_HELD_PERIOD, FALSE);
        SAFE_ENABLEWINDOW(IDC_IEEE8021X_AUTH_PERIOD, FALSE);
        SAFE_ENABLEWINDOW(IDC_STATIC_MAX_START, FALSE);
        SAFE_ENABLEWINDOW(IDC_STATIC_START_PERIOD, FALSE);
        SAFE_ENABLEWINDOW(IDC_STATIC_HELD_PERIOD, FALSE);
        SAFE_ENABLEWINDOW(IDC_STATIC_AUTH_PERIOD, FALSE);
        SAFE_ENABLEWINDOW(IDC_STATIC_8021X_PARAMS, FALSE);
        SAFE_ENABLEWINDOW(IDC_STATIC_CERT_TYPE,FALSE);
        SAFE_ENABLEWINDOW(IDC_MACHINE_AUTHENTICATION,FALSE);
        SAFE_ENABLEWINDOW(IDC_GUEST_AUTHENTICATION,FALSE);
        SAFE_ENABLEWINDOW(IDC_EAP_CONFIGURE, FALSE);
        SAFE_ENABLEWINDOW(IDC_COMBO_MC_AUTH_TYPE,FALSE);
        SAFE_ENABLEWINDOW(IDC_STATIC_AUTH_TYPE,FALSE);
    }
    
    
    return;
}

void 
CPS8021XPropPage::DisplayEapType()
{
    DWORD dwEapIndex = 0;
    DTLNODE *pNode = NULL;
    EAPCFG *pEapcfg = NULL;
    DWORD dwEAPType = 0;
    
    dwEapIndex = m_cbEapType.GetCurSel();

    pNode = (DTLNODE *) m_cbEapType.GetItemDataPtr(dwEapIndex);
    ASSERT( pNode );

    pEapcfg = (EAPCFG* )DtlGetData( pNode );
    ASSERT( pEapcfg );

    dwEAPType = pEapcfg->dwKey;
    
    switch (dwEAPType) {
        case EAP_TYPE_MD5:
            // dwEapType = WIRELESS_EAP_TYPE_MD5;
            SAFE_ENABLEWINDOW(IDC_STATIC_CERT_TYPE,FALSE);
            SAFE_ENABLEWINDOW(IDC_MACHINE_AUTHENTICATION,FALSE);
            SAFE_ENABLEWINDOW(IDC_GUEST_AUTHENTICATION,FALSE);
            SAFE_ENABLEWINDOW(IDC_EAP_CONFIGURE, FALSE);
            SAFE_ENABLEWINDOW(IDC_COMBO_MC_AUTH_TYPE,FALSE);
            SAFE_ENABLEWINDOW(IDC_STATIC_AUTH_TYPE,FALSE);
            break;

        default : 
            SAFE_ENABLEWINDOW(IDC_STATIC_CERT_TYPE,TRUE);
            SAFE_ENABLEWINDOW(IDC_MACHINE_AUTHENTICATION,TRUE);
            SAFE_ENABLEWINDOW(IDC_GUEST_AUTHENTICATION,TRUE);
            SAFE_ENABLEWINDOW(IDC_EAP_CONFIGURE, TRUE);
            DisplayMachineAuthentication();
            break;
    }
    
}

void
CPS8021XPropPage::DisplayMachineAuthentication()
{
    
    if (m_dwMachineAuthentication) {
        SAFE_ENABLEWINDOW(IDC_COMBO_MC_AUTH_TYPE,TRUE);
        SAFE_ENABLEWINDOW(IDC_STATIC_AUTH_TYPE, TRUE);
    } else {
        SAFE_ENABLEWINDOW(IDC_COMBO_MC_AUTH_TYPE,FALSE);
        SAFE_ENABLEWINDOW(IDC_STATIC_AUTH_TYPE,FALSE);
    }
}


BOOL CPS8021XPropPage::OnWizardFinish()
{
    // just transfer to our OnApply, as it does the right stuff
    if (OnApply())
    {
        // go ahead and finish
        return TRUE;
    }
    
    // don't allow us to finish
    return FALSE;
}

LRESULT CPS8021XPropPage::OnWizardNext()
{
    // just transfer to our OnApply, as it does the right stuff
    if (ControlDataToWirelessPS())
    {
        // go ahead and move to next page
        return CWirelessBasePage::OnWizardNext();
    }
    
    // don't allow us to go on to the next page
    return -1;
}

BOOL CPS8021XPropPage::OnApply()
{
    if (!m_bReadOnly) { 
    // Save data from page
        if (!m_bHasApplied)
	{
            ControlDataToWirelessPS();
	}
    }
    // ok, everything is cool
    return CWirelessBasePage::OnApply();
}

void CPS8021XPropPage::OnCheck8021x()
{
    UpdateData(TRUE);
    SetModified();
    DisplayEnable8021x();
}


void CPS8021XPropPage::OnSel8021xMode()
{
    UpdateData(TRUE);
    SetModified();
}


void CPS8021XPropPage::OnSelCertType()
{
    UpdateData(TRUE);
    SetModified();
}

void CPS8021XPropPage::OnCheckValidateServerCert()
{
    UpdateData(TRUE);
    SetModified();
    //DisableWindow(m_hwnd8021xCheck);
}

void CPS8021XPropPage::OnSelMachineAuthenticationType()
{
    UpdateData(TRUE);
    SetModified();
}

void CPS8021XPropPage::OnCheckGuestAuthentication()
{
    UpdateData (TRUE);
    SetModified();
}

void CPS8021XPropPage::OnCheckMachineAuthentication()
{
    UpdateData (TRUE);
    SetModified();
    DisplayMachineAuthentication();
}

void CPS8021XPropPage::OnIEEE8021xParams()
{
    UpdateData (TRUE);
    SetModified();
}

void CPS8021XPropPage::OnSelEapType()
{
    UpdateData(TRUE);
    SetModified();
    dwEAPUpdated = 1;
    DisplayEapType();
}

BOOL CPS8021XPropPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DWORD* pdwHelp = (DWORD*) &g_aHelpIDs_IDD_8021X_PROPERTY_PAGE[0];
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
            c_szWlsnpHelpFile,
            HELP_WM_HELP,
            (DWORD_PTR)(LPVOID)pdwHelp);
    }
    
    return CWirelessBasePage::OnHelpInfo(pHelpInfo);
}

BOOL CPS8021XPropPage::ControlDataToWirelessPS()
{
    PWIRELESS_PS_DATA pWirelessPSData = NULL;
    LPWSTR  pszNewInterfaceName = NULL;
    
    DWORD dwIEEE8021xMaxStart;
    DWORD dwIEEE8021xStartPeriod;
    DWORD dwIEEE8021xAuthPeriod;
    DWORD dwIEEE8021xHeldPeriod;
    
    CString pszIEEE8021xMaxStart;
    CString pszIEEE8021xStartPeriod;
    CString pszIEEE8021xAuthPeriod;
    CString pszIEEE8021xHeldPeriod;
    
    DWORD dwEnable8021x;
    DWORD dw8021xMode;
    DWORD dwEapType;
    DWORD dwCertificateType;
    DWORD dwValidateServerCertificate;
    
    DWORD dwMachineAuthentication;
    DWORD dwMachineAuthenticationType;
    DWORD dwGuestAuthentication;
    
    DWORD dwEapIndex;
    DWORD dw8021xModeIndex;
    DWORD dwMachineAuthenticationTypeIndex;
    DWORD dwCertificateTypeIndex;
    DTLNODE *pNode = NULL;
    EAPCFG *pEapcfg = NULL;
    
    
    pWirelessPSData = WirelessPS();
    
    UpdateData (TRUE);
    
    dwEnable8021x = 
        m_dwEnable8021x ? 1 : 0;
    
    dw8021xModeIndex = m_cb8021xMode.GetCurSel();
    
    switch (dw8021xModeIndex) { 
    case 0 :
        dw8021xMode = 
            WIRELESS_8021X_MODE_NO_TRANSMIT_EAPOLSTART_WIRED;
        break;
    case 1 :
        dw8021xMode = 
            WIRELESS_8021X_MODE_NAS_TRANSMIT_EAPOLSTART_WIRED;
        break;
    case 2 :
        dw8021xMode = 
            WIRELESS_8021X_MODE_TRANSMIT_EAPOLSTART_WIRED;
        break;
    }
    
    dwEapIndex = m_cbEapType.GetCurSel();

    pNode = (DTLNODE *) m_cbEapType.GetItemDataPtr(dwEapIndex);
    ASSERT( pNode );

    pEapcfg = (EAPCFG* )DtlGetData( pNode );
    ASSERT( pEapcfg );

    dwEapType = pEapcfg->dwKey;

    if (dwEAPUpdated) {
        // since pEapcfg->pData is created by us, copy the pointer as is. 
        if (pWirelessPSData->pbEAPData) {
        	FreePolMem(pWirelessPSData->pbEAPData);
        	}

        pWirelessPSData->dwEAPDataLen = pEapcfg->cbData;
        pWirelessPSData->pbEAPData = pEapcfg->pData;

        pEapcfg->cbData = 0;
        pEapcfg->pData = NULL;
    }
    	
    dwCertificateTypeIndex = m_cbCertificateType.GetCurSel();
    
    
    switch (dwCertificateTypeIndex) {
    case 0 :
        dwCertificateType = 
            WIRELESS_CERT_TYPE_SMARTCARD; 
        break;
        
    case 1 : 
        dwCertificateType = 
            WIRELESS_CERT_TYPE_MC_CERT;
        break;
    }
    
    dwValidateServerCertificate = 
        m_dwValidateServerCertificate ? 1 : 0;
    
    dwMachineAuthentication = 
        m_dwMachineAuthentication ? 1 : 0;
    
    
    dwMachineAuthenticationTypeIndex = m_cbMachineAuthenticationType.GetCurSel();
    
    switch (dwMachineAuthenticationTypeIndex)
    {
    case 0 :
        dwMachineAuthenticationType =
            WIRELESS_MC_AUTH_TYPE_MC_NO_USER;
        break;
        
    case 1 : 
        dwMachineAuthenticationType = 
            WIRELESS_MC_AUTH_TYPE_USER_DONTCARE_MC;
        break;
        
    case 2 : 
        dwMachineAuthenticationType = 
            WIRELESS_MC_AUTH_TYPE_MC_ONLY;
        break;
    }
    
    dwGuestAuthentication = 
        m_dwGuestAuthentication ? 1 : 0;
    
    
    pWirelessPSData->dwEnable8021x = dwEnable8021x;
    pWirelessPSData->dw8021xMode = dw8021xMode;
    pWirelessPSData->dwEapType = dwEapType;
    pWirelessPSData->dwMachineAuthentication = dwMachineAuthentication;
    pWirelessPSData->dwMachineAuthenticationType = dwMachineAuthenticationType;
    pWirelessPSData->dwGuestAuthentication = dwGuestAuthentication;
    
    pWirelessPSData->dwIEEE8021xMaxStart = 
        m_dwIEEE8021xMaxStart;
    pWirelessPSData->dwIEEE8021xStartPeriod = 
        m_dwIEEE8021xStartPeriod; 
    pWirelessPSData->dwIEEE8021xAuthPeriod = 
        m_dwIEEE8021xAuthPeriod; 
    pWirelessPSData->dwIEEE8021xHeldPeriod = 
        m_dwIEEE8021xHeldPeriod; 

    m_bHasApplied = TRUE;
    
    
    return TRUE;
}


void 
CPS8021XPropPage::Initialize (
                         PWIRELESS_PS_DATA pWirelessPSData, 
                         CComponentDataImpl* pComponentDataImpl,
                         BOOL dwFlags = WLSTORE_READWRITE
                         )
{
    m_bReadOnly = dwFlags & WLSTORE_READONLY;
    CWirelessBasePage::Initialize(pWirelessPSData, pComponentDataImpl);
}

void CPS8021XPropPage::DisableControls()
{
    SAFE_ENABLEWINDOW(IDC_ENABLE_8021X, FALSE);
    SAFE_ENABLEWINDOW(IDC_COMBO_8021X_MODE,FALSE);
    SAFE_ENABLEWINDOW(IDC_STATIC_8021X_MODE,FALSE);
    SAFE_ENABLEWINDOW(IDC_EAP_TYPE_COMBO,FALSE);
    SAFE_ENABLEWINDOW(IDC_STATIC_EAP_TYPE, FALSE);
    SAFE_ENABLEWINDOW(IDC_IEEE8021X_MAX_START, FALSE);
    SAFE_ENABLEWINDOW(IDC_IEEE8021X_START_PERIOD, FALSE);
    SAFE_ENABLEWINDOW(IDC_IEEE8021X_HELD_PERIOD, FALSE);
    SAFE_ENABLEWINDOW(IDC_IEEE8021X_AUTH_PERIOD, FALSE);
    SAFE_ENABLEWINDOW(IDC_STATIC_MAX_START, FALSE);
    SAFE_ENABLEWINDOW(IDC_STATIC_START_PERIOD, FALSE);
    SAFE_ENABLEWINDOW(IDC_STATIC_HELD_PERIOD, FALSE);
    SAFE_ENABLEWINDOW(IDC_STATIC_AUTH_PERIOD, FALSE);
    SAFE_ENABLEWINDOW(IDC_STATIC_8021X_PARAMS, FALSE);
    SAFE_ENABLEWINDOW(IDC_STATIC_CERT_TYPE,FALSE);
    SAFE_ENABLEWINDOW(IDC_MACHINE_AUTHENTICATION,FALSE);
    SAFE_ENABLEWINDOW(IDC_GUEST_AUTHENTICATION,FALSE);
    SAFE_ENABLEWINDOW(IDC_COMBO_MC_AUTH_TYPE,FALSE);
    SAFE_ENABLEWINDOW(IDC_STATIC_AUTH_TYPE,FALSE);
}


DWORD
CPS8021XPropPage::OnProperties(
       )
{

    DWORD dwError = 0;
    DTLNODE*    pNode = NULL;
    EAPCFG*     pEapcfg = NULL;
    RASEAPINVOKECONFIGUI pInvokeConfigUi;
    RASEAPFREE  pFreeConfigUIData;
    HINSTANCE   h;
    BYTE*       pbEAPData = NULL;
    DWORD       cbEAPData = 0;
    HWND hWnd;
    LPBYTE pbNewEAPData = NULL;
  
    DWORD dwEapTypeIndex = 0;

    // Look up the selected package configuration and load the associated
    // configuration DLL.
   
    dwEapTypeIndex = m_cbEapType.GetCurSel();
    pNode = (DTLNODE *) m_cbEapType.GetItemDataPtr(dwEapTypeIndex);

    if (!pNode)
    {
        return E_UNEXPECTED;
    }
    
    pEapcfg = (EAPCFG* )DtlGetData( pNode );
    ASSERT( pEapcfg );
    if (!pEapcfg) {
    	return E_UNEXPECTED;
    	}
    
    h = NULL;
    if (!(h = LoadLibrary( pEapcfg->pszConfigDll ))
        || !(pInvokeConfigUi =
                (RASEAPINVOKECONFIGUI )GetProcAddress(
                    h, "RasEapInvokeConfigUI" ))
        || !(pFreeConfigUIData =
                (RASEAPFREE) GetProcAddress(
                    h, "RasEapFreeMemory" )))
    {
        // Cannot load configuration DLL
        if (h)
        {
            FreeLibrary( h );
        }
        return E_FAIL;
    }


    // Call the configuration DLL to popup it's custom configuration UI.

    pbEAPData = NULL;
    cbEAPData = 0;
    hWnd = GetParent()->m_hWnd;
    dwError = pInvokeConfigUi(
                    pEapcfg->dwKey,
                    hWnd,
                    RAS_EAP_FLAG_8021X_AUTH,
                    pEapcfg->pData,
                    pEapcfg->cbData,
                    &pbEAPData,
                    &cbEAPData
                    );
    /*TAROON* User hitting cancel is also an error */
    if (dwError)
    {
        FreeLibrary( h );
        return E_FAIL;
    }


    if (pbEAPData && cbEAPData)
    {
            // Copy it into the eap node
            pbNewEAPData = (LPBYTE) AllocPolMem(cbEAPData);
            if (!pbNewEAPData)
            {
                dwError = GetLastError();
                return(dwError);
            }
            memcpy(pbNewEAPData, pbEAPData, cbEAPData);
    }
    
    pFreeConfigUIData( pbEAPData );
    if (pEapcfg->pData) {
        FreePolMem(pEapcfg->pData);
    	}
    
    pEapcfg->pData = pbNewEAPData;
    pEapcfg->cbData = cbEAPData;

    dwEAPUpdated = 1;
    
    FreeLibrary( h );

    return dwError;
}

void
CPS8021XPropPage::OnCancel()
{
    EAPCFG* pEapcfg = NULL;
    DTLNODE *pNodeEap = NULL;
    
    if (pListEapcfgs) {

        // Delete the data allocated using AllocPolMem
        for (pNodeEap = DtlGetFirstNode(pListEapcfgs);
                 pNodeEap;
                 pNodeEap = DtlGetNextNode(pNodeEap)
             	)
        {
            pEapcfg = (EAPCFG* )DtlGetData(pNodeEap);
            ASSERT( pEapcfg );

            if (pEapcfg->pData) {
            	FreePolMem(pEapcfg->pData);
            }
            pEapcfg->pData = NULL;
            pEapcfg->cbData = 0;
        }
        DtlDestroyList (pListEapcfgs, DestroyEapcfgNode);
    }
    pListEapcfgs = NULL;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\peap.cpp ===
// peap.cpp : implementation file
//

#include "stdafx.h"
#include "nfaa.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPEAPSetting dialog

CPEAPSetting::CPEAPSetting(CWnd* pParent /*=NULL*/)
	: CDialog(CPEAPSetting::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPEAPSetting)
	//m_dwValidateServerCertificate = FALSE;
	//}}AFX_DATA_INIT
	m_bReadOnly = FALSE;

}

void CPEAPSetting::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPEAPSetting)
       DDX_Control(pDX, IDC_COMBO_PEAP_AUTH_TYPE, m_cbPEAPAuthType);
       DDX_Check(pDX, IDC_PEAP_VALIDATE_SERVER_CERT, m_dwValidateServerCertificate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPEAPSetting, CDialog)
	//{{AFX_MSG_MAP(CPEAPSetting)
	ON_WM_HELPINFO()
       ON_CBN_SELENDOK(IDC_COMBO_PEAP_AUTH_TYPE, OnSelPEAPAuthType)
       ON_BN_CLICKED(IDC_PEAP_VALIDATE_SERVER_CERT, OnCheckValidateServerCert)
       ON_BN_CLICKED(IDC_PEAP_AUTH_CONFIGURE, OnConfigure)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPEAPSetting message handlers

BOOL CPEAPSetting::OnInitDialog()
{
	CDialog::OnInitDialog();
	CString pszTemp;
	DWORD dwPEAPAuthTypeIndex = 0;

	if (!pPEAPProperties) {
		return FALSE;
		}

	pszTemp.LoadString(IDS_PEAP_AUTH_TYPE_MSCHAP_V2);
       m_cbPEAPAuthType.AddString(pszTemp);

       pszTemp.LoadString(IDS_EAP_TYPE_TLS);
       m_cbPEAPAuthType.AddString(pszTemp);
    
       switch (pPEAPProperties->dwPEAPAuthType)
      {
           case EAP_TYPE_MSCHAP_V2: 
             dwPEAPAuthTypeIndex = 0;
             break;
           case WIRELESS_EAP_TYPE_TLS:
           	dwPEAPAuthTypeIndex = 1;
              break;
           
           default:
              dwPEAPAuthTypeIndex = 0;
              break;
     }
    
       m_cbPEAPAuthType.SetCurSel(dwPEAPAuthTypeIndex);
    
       m_dwValidateServerCertificate = 
        pPEAPProperties->dwValidateServerCert ? TRUE : FALSE;

       dwAutoWinLogin = pPEAPProperties->dwAutoLogin;

       TLSProperties.dwCertType = 
           pPEAPProperties->dwPEAPTLSCertificateType;
       TLSProperties.dwValidateServerCert =
           pPEAPProperties->dwPEAPTLSValidateServerCertificate;

       if (m_bReadOnly) {
       	SAFE_ENABLEWINDOW(IDC_COMBO_PEAP_AUTH_TYPE, FALSE);
       	SAFE_ENABLEWINDOW(IDC_PEAP_VALIDATE_SERVER_CERT, FALSE);
       	SAFE_ENABLEWINDOW(IDC_PEAP_AUTH_TYPE, FALSE);
       	}

       UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPEAPSetting::ControlsValuesToSM (PPEAP_PROPERTIES pPEAPProperties)
{
	// pull all our data from the controls
       UpdateData(TRUE);	

	DWORD dwPEAPAuthTypeIndex = 0;
	DWORD dwPEAPAuthType = 0;
	DWORD dwValidateServerCertificate = 0;

	dwPEAPAuthTypeIndex = m_cbPEAPAuthType.GetCurSel();
    
    
       switch (dwPEAPAuthTypeIndex) {
        case 0 :
            dwPEAPAuthType = 
                EAP_TYPE_MSCHAP_V2;
            pPEAPProperties->dwAutoLogin = dwAutoWinLogin;
            break;

        case 1:
            dwPEAPAuthType = 
            	  WIRELESS_EAP_TYPE_TLS;
            pPEAPProperties->dwPEAPTLSCertificateType =
                TLSProperties.dwCertType;
            pPEAPProperties->dwPEAPTLSValidateServerCertificate =
                TLSProperties.dwValidateServerCert;
            break;
    }
    
    dwValidateServerCertificate = 
        m_dwValidateServerCertificate ? 1 : 0;

    pPEAPProperties->dwPEAPAuthType = dwPEAPAuthType;
    pPEAPProperties->dwValidateServerCert = dwValidateServerCertificate;
    
}

void CPEAPSetting::OnOK()
{
	UpdateData (TRUE);
	ControlsValuesToSM(pPEAPProperties);
	CDialog::OnOK();
}

BOOL CPEAPSetting::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DWORD* pdwHelp = (DWORD*) &g_aHelpIDs_IDD_PEAP_SETTINGS[0];
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
            c_szWlsnpHelpFile,
            HELP_WM_HELP,
            (DWORD_PTR)(LPVOID)pdwHelp);
    }
    
    return TRUE;
}

void CPEAPSetting::OnSelPEAPAuthType()
{
    UpdateData(TRUE);
}

void CPEAPSetting::OnCheckValidateServerCert()
{
    UpdateData(TRUE);
}

BOOL CPEAPSetting::Initialize(
	PPEAP_PROPERTIES paPEAPProperties,
	BOOL bReadOnly
	)
{
    pPEAPProperties = paPEAPProperties;
    m_bReadOnly = bReadOnly;
    if (!pPEAPProperties) {
    	return(FALSE);
    	}
    return(TRUE);
}


void CPEAPSetting::OnConfigure()
{
	CMSCHAPSetting CHAPdlg;
       DWORD dwPEAPAuthTypeIndex = 0;
       DWORD dwPEAPAuthType = 0;
       CTLSSetting TLSDlg;

     // Get the Current Selection

     dwPEAPAuthTypeIndex = m_cbPEAPAuthType.GetCurSel();
    
    switch (dwPEAPAuthTypeIndex) {
    case 0: 
        dwPEAPAuthType = EAP_TYPE_MSCHAP_V2;
        break;
    case 1:
    	 dwPEAPAuthType = WIRELESS_EAP_TYPE_TLS;
    	 break;
    }

    if (dwPEAPAuthType == EAP_TYPE_MSCHAP_V2) {
    
	 CHAPdlg.Initialize (&dwAutoWinLogin, m_bReadOnly);
	 if (IDCANCEL == CHAPdlg.DoModal())
            return;

        UpdateData( FALSE );
    }
    
    if (dwPEAPAuthType == WIRELESS_EAP_TYPE_TLS) {
    	TLSDlg.Initialize(&TLSProperties, m_bReadOnly);
    	if (IDCANCEL == TLSDlg.DoModal())
    		return;
    }
       return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\nfabpage.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Nfabpage.h
//
//  Contents:  Wireless Policy Snapin 
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#ifndef _NFABPAGE_H
#define _NFABPAGE_H


// CWirelessBasePage.h : header file
//

class CWirelessBasePage : public CWiz97BasePage
{
    DECLARE_DYNCREATE(CWirelessBasePage)
        
        
        CWirelessBasePage(UINT nIDTemplate, BOOL bWiz97=FALSE, BOOL bFinishPage=FALSE);
    CWirelessBasePage() {ASSERT(0);};
    ~CWirelessBasePage();
    
    void CWirelessBasePage::Initialize (PWIRELESS_PS_DATA pWirelessPSData, CComponentDataImpl* pComponentDataImpl);
    
    
#ifdef WIZ97WIZARDS
public:
    void InitWiz97 (CComObject<CSecPolItem> *pSecPolItem, PWIRELESS_PS_DATA pWirelessPSData, CComponentDataImpl* pComponentDataImpl, DWORD dwFlags, DWORD dwWizButtonFlags = 0, UINT nHeaderTitle = 0, UINT nSubTitle = 0);
#endif
    
    // Overrides
public:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWirelessBasePage)
public:
protected:
    virtual BOOL OnSetActive();
    //}}AFX_VIRTUAL
    
    // There are paths we can use to get storage, sometimes we have an PS, sometimes we have a ComponentDataImpl
    // and sometimes we have both. It used to be that we called one of two functions to dig down to it, but now
    // we call one function and it does the digging for us
    
    HANDLE GetPolicyStoreHandle()
    {
        
        return(m_pComponentDataImpl->GetPolicyStoreHandle());
    }
    
    PWIRELESS_PS_DATA WirelessPS() {return m_pWirelessPSData;};
    // Implementation
protected:
    //{{AFX_MSG(CWirelessBasePage)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
        
        PWIRELESS_PS_DATA m_pWirelessPSData;
    CComponentDataImpl* m_pComponentDataImpl;
    // !NULL if the owning (non-Wiz) propsheet was created to Add a new PS.
    // Its a new PS so its not owned by a policy yet.  Otherwise this is
    // NULL since the PS's backpointer will be used to commit the owning
    // policy.
    PWIRELESS_POLICY_DATA    m_pPolicyNfaOwner;
};

class CPSPropSheetManager : public CPropertySheetManager
{
public:
    CPSPropSheetManager() :
      CPropertySheetManager(),
          m_pWirelessPSData(NULL),
          m_bIsNew(FALSE)
      {}
      
      void SetData(
          CSecPolItem *   pResultItem,
          PWIRELESS_PS_DATA pWirelessPSData,
          BOOL bIsNew
          )
      {
          m_pResultItem = pResultItem;
          m_pWirelessPSData = pWirelessPSData;
          m_bIsNew = bIsNew;
      }
      
      virtual BOOL OnApply();
      
protected:
    CSecPolItem * m_pResultItem;
    PWIRELESS_PS_DATA m_pWirelessPSData;
    BOOL m_bIsNew;
};


const UINT c_nMaxSSIDLen = 32;
const UINT c_nMaxDescriptionLen = 255;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\snpobj.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Snpobj.cpp
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------
#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////

// Construction/destruction
CSnapObject::CSnapObject ()
{
    // init members
    m_pComponentDataImpl = NULL;
    m_pComponentImpl = NULL;
    m_bChanged = FALSE;
    m_hConsole = NULL;
}

CSnapObject::~CSnapObject()
{
    
    // free off the notify handle
    if (m_hConsole != NULL)
    {
        // Note - This needs to be called only once.
        // If called more than once, it will gracefully return an error.
        // MMCFreeNotifyHandle(m_hConsole);
        m_hConsole = NULL;
    }
    
};

void CSnapObject::Initialize (CComponentDataImpl* pComponentDataImpl,CComponentImpl* pComponentImpl, BOOL bTemporaryDSObject)
{
    ASSERT( NULL == pComponentImpl );   // is this ever valid? if not remove it
    m_pComponentDataImpl = pComponentDataImpl;
    m_pComponentImpl = pComponentImpl;
};


/////////////////////////////////////////////////////////////////////////////
// Protected members


int CSnapObject::PopWiz97Page ()
{
    int i;
    i = m_stackWiz97Pages.top();
    m_stackWiz97Pages.pop();
    return i;
}

void CSnapObject::PushWiz97Page (int nIDD)
{
    m_stackWiz97Pages.push(nIDD);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\peap.h ===
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// peap.h : header file
//

#include "chap.h"

typedef struct _PEAP_PROPERTIES {
    DWORD dwPEAPAuthType;
    DWORD dwValidateServerCert;
    DWORD dwPEAPTLSValidateServerCertificate;
    DWORD dwPEAPTLSCertificateType;
    DWORD dwAutoLogin;
} PEAP_PROPERTIES, *PPEAP_PROPERTIES;

/////////////////////////////////////////////////////////////////////////////
// CPEAPSetting dialog

class CPEAPSetting : public CDialog
{
// Construction
public:
	CPEAPSetting(CWnd* pParent = NULL);   // standard constructor
	BOOL  Initialize ( PPEAP_PROPERTIES pPEAPProperties, BOOL bReadOnly = FALSE);

// Dialog Data
	//{{AFX_DATA(CPEAPSetting)
	enum { IDD = IDD_PEAP_SETTINGS};
       CComboBox m_cbPEAPAuthType;
       BOOL   m_dwValidateServerCertificate;
	//}}AFX_DATA



// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPEAPSetting)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
              DWORD dwAutoWinLogin;
              TLS_PROPERTIES TLSProperties;
       	PPEAP_PROPERTIES pPEAPProperties;
       	BOOL m_bReadOnly;

	// Generated message map functions
	//{{AFX_MSG(CPEAPSetting)
	virtual BOOL OnInitDialog();
	virtual void OnOK();

	
	afx_msg void OnCheckValidateServerCert();
	afx_msg void OnSelPEAPAuthType();
	afx_msg void OnConfigure();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void ControlsValuesToSM (PPEAP_PROPERTIES pPEAPProperties);

	
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by snapin.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NAME                        2
#define IDS_SIZE                        3
#define IDC_PEAP_AUTH_CONFIGURE         3
#define IDS_TYPE                        4
#define IDS_PEAP_AUTH_TYPE_MSCHAP_V2    5
#define IDS_DESCRIPTION                 6
#define IDS_VERSION                     7
#define IDS_COMPANY                     8
#define IDS_EAP_TYPE_PEAP               9
#define IDS_BOLD_FONT_NAME              10
#define IDS_BOLD_FONT_SIZE              11
#define IDS_SUREYESNO                   24
#define IDS_PORTRANGEERROR              30
#define IDS_REMOVINGERROR               35
#define IDS_ACCESSDENIEDERROR           36
#define IDS_POLICY_ASSIGNEDYES          53
#define IDS_POLICY_ASSIGNEDNO           54
#define IDS_ABOUTGLUESTRING             60
#define IDS_POLMSG_DCNOTFOUND           61
#define IDS_POLMSG_DIRNOTFOUND          62
#define IDS_POLMSG_CANNOTCREATECONTAINER 63
#define IDS_POLMSG_ACCESSDENIED         64
#define IDS_POLMSG_EFAIL                65
#define IDS_COLUMN_TYPE                 66
#define IDS_COLUMN_NAME                 69
#define IDS_COLUMN_DESCRIPTION          70
#define IDS_MENUTEXT_CREATENEWSECPOL    74
#define IDS_MENUDESCRIPTION_CREATENEWSECPOL 75
#define IDM_CREATENEWSECPOL             75
#define IDS_MENUTEXT_IMPORTFILE         78
#define IDS_MENUDESCRIPTION_IMPORTFILE  79
#define IDS_COLUMN_INVALID              86
#define IDS_MENUTEXT_UNASSIGN           87
#define IDS_MENUDESCRIPTION_UNASSIGN    88
#define IDM_UNASSIGN                    88
#define IDS_MENUTEXT_ASSIGN             89
#define IDS_MENUDESCRIPTION_ASSIGN      90
#define IDM_ASSIGN                      90
#define IDS_COLUMN_SSIDNAME             91
#define IDS_COLUMN_AUTHMETHOD           93
#define IDS_COLUMN_PRIVACY              94
#define IDS_DATAERROR                   104
#define IDD_LOCATIONPAGE                107
#define IDS_COLUMN_POLICYASSIGNED       107
#define IDS_COLUMN_GPONAME              108
#define IDD_WIRELESSGENPROP             109
#define IDS_COLUMN_PRECEDENCE           109
#define IDS_COLUMN_OU                   110
#define IDD_PROPPAGE_G_NAMEDESCRIPTION  111
#define IDS_NODENAME_BASE               116
#define IDS_NODENAME_GLOBAL             117
#define IDD_PROPPAGE_N_DONE             141
#define IDS_POLICY_ASSIGNED_PANOTRUNNING 142
#define IDS_POLICY_ASSIGNED_DSOVERRIDE  143
#define IDS_HELPCONTENTSFILE            156
#define IDS_L_INTERIORTITLE             176
#define IDS_L_INTERIORSUBTITLE          200
#define IDB_16x16                       202
#define IDB_32x32                       203
#define IDI_FOLDER                      205
#define IDC_ACTION_PS_ADD               205
#define IDC_ACTION_PS_EDIT              206
#define IDC_ACTION_PS_REMOVE            207
#define IDC_PS_LIST                     208
#define IDI_APPICON_OLD                 209
#define IDI_ICON                        210
#define IDC_EDDESCRIPTION               214
#define IDB_CHECKS                      216
#define IDB_RADIOS                      217
#define IDD_PS_LIST                     218
#define IDI_FILTER                      220
#define IDD_8021X_PROPERTY_PAGE         223
#define IDI_WARNINGSYMBOL               227
#define IDR_TOOLBAR_WIRELESS_MGR_SCOPE  228
#define IDR_TOOLBAR_SECPOL_RESULT       230
#define IDB_WPOLICY                     231
#define IDB_BPOLICY                     232
#define IDB_BNEG                        233
#define IDB_WNEG                        234
#define IDB_BRULE                       235
#define IDB_BFILTER                     236
#define IDD_PROPPAGE_P_WELCOME          237
#define IDB_WRULE                       237
#define IDB_WFILTER                     238
#define IDD_WIFIGEN_WIZBASE             252
#define IDC_EDNAME                      258
#define IDS_ERROR_NODNSDOMAINNAME       259
#define IDS_ERROR_REASSIGNDEFAULTPOLICY 260
#define IDS_REFRESHERROR                261
#define IDC_CHECKPROPERTIES             262
#define IDS_PROPPAGE_RI_T_CONNTYPE      267
#define IDS_WARN_POLSTOREPREVIOUSVERSION 280
#define IDS_WARN_POLSTORELATERVERSION   281
#define IDS_WARN_POLSTOREWRONGVERSIONPREVIOUS 282
#define IDS_WARN_POLSTOREWRONGPROVIDER  283
#define IDS_WARN_POLSTORENOVERSION      284
#define IDS_WARN_POLSTOREWRONGVERSIONLATER 285
#define IDS_WARNING_DISPLAY_ROOTCAFROMLOCALMACHINE 286
#define IDS_WARNNONAME                  287
#define IDS_HELPCONCEPTSFILE            288
#define IDS_WARNRECONNECT               289
#define IDS_POLICY_MODIFIEDTIME         301
#define IDC_RADIODIRECTORYSERVICE       319
#define IDC_STATIC_NAME                 368
#define IDC_STATIC_DESCRIPTION          369
#define IDC_STATIC_INFOTEXT             373
#define IDC_STATIC_PS_LIST              385
#define IDC_INFORMATIVETEXT             410
#define IDC_EDITDNSDOMAIN               432
#define IDD_SSID                        523
#define IDS_ERROR_SYSTEM_ERROR_FORMAT   601
#define IDS_8021X_ENABLED               605
#define IDS_8021X_DISABLED              606
#define IDS_WEP_ENABLED                 607
#define IDS_WEP_DISABLED                608
#define IDS_NETWORK_ADHOC               609
#define IDS_NETWORK_AP                  610
#define IDS_EDIT_TITLE                  611
#define IDC_NETWORK_TYPE                1005
#define IDC_WEP_ENABLED                 1008
#define IDC_NETWORK_AUTHENTICATION      1010
#define IDC_RADIOSPECIFICDIRECTORYSERVICE 1013
#define IDC_NEW_POLICY_NAME             1014
#define IDC_NEW_POLICY_DESCRIPTION      1015
#define IDC_EAP_TYPE_COMBO              1025
#define IDC_COMBO_NETWORKS_TO_ACCESS    1025
#define IDS_ERROR_RESOLVE_DNS           3000
#define IDS_WARNING_DNS_SOURCE          3001
#define IDS_WARNING_DNS_DEST            3002
#define IDS_IPADDR_SEPARATOR            3004
#define IDS_ERR_OUTOFMEMORY             3005
#define IDS_ERROR_EMPTY_POL_NAME        3006
#define IDS_ERROR_IKE_SESSION           3007
#define IDS_SAVE_ERROR                  5001
#define IDS_LOAD_ERROR                  5002
#define IDS_OPERATION_FAIL              5003
#define IDS_ADD_ERROR                   5004
#define IDS_NONE                        5005
#define IDS_EAP_TYPE_TLS                5006
#define IDS_EAP_TYPE_MD5                5007
#define IDS_CERT_TYPE_SMARTCARD         5008
#define IDS_CERT_TYPE_MC_CERT           5009
#define IDS_MC_AUTH_TYPE_MC_NO_USER     5010
#define IDS_MC_AUTH_TYPE_USER_DONTCARE_MC 5011
#define IDS_MC_AUTH_TYPE_MC_ONLY        5012
#define IDS_8021X_MODE_NO_TRANSMIT      5013
#define IDS_8021X_MODE_NAS_TRANSMIT     5014
#define IDS_8021X_MODE_TRANSMIT         5015
#define IDS_WIRELESS_ACCESS_NETWORK_ANY 5016
#define IDS_WIRELESS_ACCESS_NETWORK_AP  5017
#define IDS_WIRELESS_ACCESS_NETWORK_ADHOC 5018
#define IDS_WIRELESS_PROPPAGE_PI_T_NAME 5019
#define IDS_WIRELESS_PROPPAGE_PI_ST_NAME 5020
#define IDS_NEWWIRELESSPOLICYNAME       5021
#define IDS_NEW_PS_NAME                 5022
#define IDS_OPERATION_FAILED_DUP_SSID   5023
#define IDS_DISPLAY_ERROR               5024
#define IDS_OPERATION_FAILED_NULL_SSID  5025
#define IDS_OPERATION_FAILED_NULL_POLICY 5026
#define IDS_NEW_PREFERRED_SETTING 5027
#define IDS_SAMPLE_DESCRIPTION 5028
#define IDC_SEPARATOR                   6002
#define IDB_PSTYPE                      6004
#define IDI_ICON3                       6016
#define IDI_ICON1                       6019
#define IDI_ICON4                       6020
#define IDI_ICON5                       6021
#define IDI_APPI                        6026
#define IDI_ICON10                      6029
#define IDI_APPICON                     6030
#define IDI_ICON7                       6031
#define IDI_ICON8                       6032
#define IDI_ICON9                       6033
#define IDD_TLS_SETTINGS                6034
#define IDD_PEAP_SETTINGS               6035
#define IDD_CHAP_CONFIGURE              6036
#define IDC_ENABLE_8021X                7002
#define IDC_MACHINE_AUTHENTICATION      7005
#define IDC_GUEST_AUTHENTICATION        7006
#define IDC_SSID_NAME                   7008
#define IDC_PS_DESCRIPTION              7009
#define IDC_AUTOMATIC_KEY_PROVISION     7013
#define IDC_IEEE8021X_MAX_START         7015
#define IDC_IEEE8021X_START_PERIOD      7016
#define IDC_IEEE8021X_HELD_PERIOD       7017
#define IDC_IEEE8021X_AUTH_PERIOD       7018
#define IDC_COMBO_8021X_MODE            7019
#define IDC_COMBO_MC_AUTH_TYPE          7021
#define IDC_PS_UP                       7022
#define IDC_PS_DOWN                     7023
#define IDC_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS 7024
#define IDC_DISABLE_ZERO_CONF           7025
#define IDC_POLLING_INTERVAL            7026
#define IDC_STATIC_8021X_MODE           7027
#define IDC_STATIC_8021X_PARAMS         7028
#define IDC_STATIC_MAX_START            7029
#define IDC_STATIC_START_PERIOD         7030
#define IDC_STATIC_HELD_PERIOD          7031
#define IDC_STATIC_AUTH_PERIOD          7032
#define IDC_STATIC_EAP_TYPE             7033
#define IDC_STATIC_CERT_TYPE            7034
#define IDC_STATIC_AUTH_TYPE            7035
#define IDC_STATIC_DISABLE_ZERO_CONF    7036
#define IDC_STATIC_AUTOMATICALLY_CONNECT_TO_NON_PREFERRED_NTWKS 7037
#define IDC_STATIC_NETWORKS_TO_ACCESS   7038
#define IDC_STATIC_POLLING_INTERVAL     7039
#define IDC_STATIC_SSID_NAME            7040
#define IDC_STATIC_PS_DESCRIPTION       7041
#define IDC_STATIC_NEW_POLICY_NAME      7042
#define IDC_STATIC_NEW_POLICY_DESCRIPTION 7043
#define IDC_EAP_CONFIGURE               7044
#define IDC_COMBO_TLS_CERT_TYPE         7045
#define IDC_TLS_VALIDATE_SERVER_CERT    7046
#define IDC_PEAP_AUTH_TYPE              7047
#define IDC_COMBO_PEAP_AUTH_TYPE        7050
#define IDC_PEAP_VALIDATE_SERVER_CERT   7051
#define IDC_CHAP_AUTO_WINLOGIN          7052
#define IDC_POLICY_WIZARD_TITLE         7053
#define IDC_POLICY_WIZARD_DONE          7054
#define IDC_STATIC_NETWORK_KEY          15057

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        6035
#define _APS_NEXT_COMMAND_VALUE         32785
#define _APS_NEXT_CONTROL_VALUE         7055
#define _APS_NEXT_SYMED_VALUE           8000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\snapin.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       snapin.cpp
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include "initguid.h"
#include "about.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Snapin, CComponentDataPrimaryImpl)
OBJECT_ENTRY(CLSID_Extension, CComponentDataExtensionImpl)
OBJECT_ENTRY(CLSID_About, CSnapinAboutImpl)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CSnapinApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
};

CSnapinApp theApp;

BOOL CSnapinApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance);
    
    // set the application name:
    //First free the string allocated by MFC at CWinApp startup.
    //The string is allocated before InitInstance is called.
    free((void*)m_pszAppName);
    //Change the name of the application file.
    //The CWinApp destructor will free the memory.
    CString strName;
    strName.LoadString (IDS_NAME);
    m_pszAppName=_tcsdup(strName);
    
    SHFusionInitializeFromModuleID (m_hInstance, 2);
    
    return CWinApp::InitInstance();
}

int CSnapinApp::ExitInstance()
{
    SHFusionUninitialize();
    _Module.Term();
    
    DEBUG_VERIFY_INSTANCE_COUNT(CComponentImpl);
    DEBUG_VERIFY_INSTANCE_COUNT(CComponentDataImpl);
    
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer(FALSE);
    
    if (hr == S_OK)
    {
        // the dll was registered ok, so proceed to do the MMC registry fixups
        
        // open the registry at \\My Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MMC\SnapIns
        HKEY hkMMC = NULL;
        LONG lErr = RegOpenKeyEx (HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"), 0, KEY_ALL_ACCESS, &hkMMC);
        if (lErr == ERROR_SUCCESS)
        {
            // create our subkey(s)
            HKEY hkSub = NULL;
            lErr = RegCreateKey (hkMMC, cszSnapin, &hkSub);
            if (lErr == ERROR_SUCCESS)
            {
                // A couple of simple values into our subkey
                // NameString = IP Security Management
                // NodeType = {36703241-D16C-11d0-9CE4-0080C7221EBD}
                // Version = 1.0
                
                // TODO: resource hardcoded strings
                
                CString strName;
                strName.LoadString (IDS_NAME);
                lErr = RegSetValueEx (hkSub, _T("NameString"), 0, REG_SZ, (CONST BYTE *)(LPCTSTR)strName, strName.GetLength() * sizeof (TCHAR));
                ASSERT (lErr == ERROR_SUCCESS);
                
                
                TCHAR szModuleFileName[MAX_PATH * 2 + 1];
                ZeroMemory(szModuleFileName, sizeof(szModuleFileName));
                DWORD dwRet = ::GetModuleFileName(_Module.GetModuleInstance(),
                    szModuleFileName,
                    DimensionOf(szModuleFileName)-1);
		szModuleFileName[MAX_PATH*2] = L'\0';
                if (0 != dwRet)
                {
                    CString strNameIndirect;
                    strNameIndirect.Format(_T("@%s,-%u"),
                        szModuleFileName,
                        IDS_NAME);
                    lErr = RegSetValueEx(hkSub,
                        _T("NameStringIndirect"),
                        0,
                        REG_SZ,
                        (CONST BYTE *)(LPCTSTR)strNameIndirect,
                        strNameIndirect.GetLength() * sizeof (TCHAR)); 
                    ASSERT (lErr == ERROR_SUCCESS);
                }
                
                
                
                //lErr = RegSetValueEx  (hkSub, _T("NodeType"), 0, REG_SZ, (CONST BYTE *)&(_T("{36703241-D16C-11d0-9CE4-0080C7221EBD}")), wcslen (_T("{36703241-D16C-11d0-9CE4-0080C7221EBD}")) * sizeof (TCHAR));
                //ASSERT (lErr == ERROR_SUCCESS);
                
                lErr = RegSetValueEx  (hkSub, _T("NodeType"), 0, REG_SZ, (CONST BYTE *)&(_T("{36D6CA65-3367-49de-BB22-1907554F6075}")), wcslen (_T("{36D6CA65-3367-49de-BB22-1907554F6075}")) * sizeof (TCHAR));
                ASSERT (lErr == ERROR_SUCCESS);
                
                lErr = RegSetValueEx  (hkSub, _T("Provider"), 0, REG_SZ, (CONST BYTE *)&(_T("Microsoft Corporation")), wcslen (_T("Microsoft Corporation")) * sizeof (TCHAR));
                ASSERT (lErr == ERROR_SUCCESS);
                
                lErr = RegSetValueEx  (hkSub, _T("Version"), 0, REG_SZ, (CONST BYTE *)&(_T("1.0")), wcslen (_T("1.01")) * sizeof (TCHAR));
                ASSERT (lErr == ERROR_SUCCESS);
                
                lErr = RegSetValueEx  (hkSub, _T("About"), 0, REG_SZ, (CONST BYTE *)&(_T("{DD468E14-AF42-4d63-8908-EDAC4A9E67AE}")), wcslen (_T("{DD468E14-AF42-4d63-8908-EDAC4A9E67AE}")) * sizeof (TCHAR));
                ASSERT (lErr == ERROR_SUCCESS);


                HKEY hkType = NULL;
                /*
                // create "StandAlone" subkey
                lErr = RegCreateKey (hkSub, _T("StandAlone"), &hkType);
                ASSERT (lErr == ERROR_SUCCESS);
                RegCloseKey( hkType );
                */
                
                hkType = NULL;
                
                
                // create "Extension" subkey
                lErr = RegCreateKey (hkSub, _T("Extension"), &hkType);
                ASSERT (lErr == ERROR_SUCCESS);
                RegCloseKey( hkType );
                hkType = NULL;
                
                // close the hkSub
                RegCloseKey (hkSub);
            }
            
            // close the hkMMC
            RegCloseKey (hkMMC);
            hkMMC = NULL;
            
            // Register as an extension to the Security Template snap-in
            {
#define WIRELESS_POLMGR_NAME _T("Wireless Network Policy Manager Extension")
                // lstruuidNodetypeSceTemplate is defined as L"{668A49ED-8888-11d1-AB72-00C04FB6C6FA}" in sceattch.h
                
                // open the registry at \\My Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MMC\Node Types
                lErr = RegOpenKeyEx( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes"), 0, KEY_ALL_ACCESS, &hkMMC );
                ASSERT( lErr == ERROR_SUCCESS );
                if (lErr == ERROR_SUCCESS)
                {
                    HKEY hkNameSpace = NULL;
                    // Now open the Security Template entry: {668A49ED-8888-11d1-AB72-00C04FB6C6FA}\Extensions\NameSpace
                    lErr = RegCreateKey( hkMMC, _T("{668A49ED-8888-11d1-AB72-00C04FB6C6FA}\\Extensions\\NameSpace"), &hkNameSpace );
                    ASSERT( lErr == ERROR_SUCCESS );
                    if (lErr == ERROR_SUCCESS)
                    {
                        // We want to add ourselves as an extension to the Security editor
                        //lErr = RegSetValueEx( hkNameSpace, _T("{DEA8AFA0-CC85-11d0-9CE2-0080C7221EBD}" ),
                        lErr = RegSetValueEx( hkNameSpace, cszSnapin,
                            0, REG_SZ, (CONST BYTE *)&(WIRELESS_POLMGR_NAME),
                            wcslen( WIRELESS_POLMGR_NAME ) * sizeof (TCHAR));
                        ASSERT( lErr == ERROR_SUCCESS );
                        
                    }
                }
            }
            
        } else
        {
            ASSERT (0);
            hr = E_UNEXPECTED;
        }
        
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\snpobj.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:      Snpobj.h
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#ifndef _SNPOBJ_H
#define _SNPOBJ_H

#include <stack>
using namespace std;
typedef stack<int> STACK_INT;

/*
// cookies should be initialized to an invalid memory address
#define UNINITIALIZED_COOKIE -1
*/

class CComponentDataImpl;
class CComponentImpl;

///////////////////////////////////////////////////////////////////////////////
// class CSnapObject
class CSnapObject
{
    // general object functionality
public:
    // construct/destruct
    CSnapObject ();
    virtual ~CSnapObject ();
    
    // these should not be being used!!
    virtual BOOL operator == (const CSnapObject& rhs) const { ASSERT (0); return FALSE;};
    virtual BOOL operator == (LONG_PTR pseudothis) const { ASSERT (0); return FALSE; };
    
    // initialization
public:
    virtual void Initialize (CComponentDataImpl* pComponentDataImpl, CComponentImpl* pComponentImpl, BOOL bTemporaryDSObject);
    
    
    // Psuedo this ptr functionality
public: 
    virtual LONG_PTR thisPtr() {return reinterpret_cast<LONG_PTR>(this);};
    
    // helpers
public:
    
    virtual void SetNotificationHandle (LONG_PTR hConsole) 
    {
        if (m_hConsole)
            MMCFreeNotifyHandle(m_hConsole);
        
        m_hConsole = hConsole;
    };
    virtual void FreeNotifyHandle()
    {
        if (m_hConsole)
            MMCFreeNotifyHandle(m_hConsole);
        
        m_hConsole = NULL;
    }
    virtual LONG_PTR GetNotifyHandle()
    {
        return m_hConsole;
    }
    
    virtual int PopWiz97Page ();
    virtual void PushWiz97Page (int nIDD);
    
    // Attributes
public:
    CComponentDataImpl* m_pComponentDataImpl;
    CComponentImpl*  m_pComponentImpl;   // TODO: not used(?), remove
protected:
    
protected:
    
private:
    // Handle given to the snap-in by the console
    LONG_PTR  m_hConsole;
    bool   m_bChanged;
    
    STACK_INT  m_stackWiz97Pages;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\snppage.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Snppage.cpp
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "stdafx.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSnapPage property page base class

IMPLEMENT_DYNCREATE(CSnapPage, CPropertyPage)

BEGIN_MESSAGE_MAP(CSnapPage, CPropertyPage)
//{{AFX_MSG_MAP(CSnapPage)
ON_WM_DESTROY()
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CSnapPage::CSnapPage (UINT nIDTemplate, BOOL bWiz97, UINT nNextIDD) : CPropertyPage(nIDTemplate)
{
    m_pspiResultItem = NULL;
    m_pDefaultCallback = NULL;
    m_bDoRefresh = TRUE;
    m_bModified = FALSE;
    m_bInitializing = FALSE;
#ifdef _DEBUG
    m_bDebugNewState = false;
#endif
    
    // if they set this to begin with, but note that calling InitWiz97 turns this on anyway
    m_bWiz97 = bWiz97;
    
    m_nIDD = nIDTemplate;
    m_nNextIDD = nNextIDD;
    
#ifdef WIZ97WIZARDS
    // copy the base class m_psp to ours
    m_psp.dwSize = sizeof (CPropertyPage::m_psp);
    memcpy (&m_psp, &(CPropertyPage::m_psp), CPropertyPage::m_psp.dwSize);
    m_psp.dwSize = sizeof (PROPSHEETPAGE);
    
    m_pWiz97Sheet = NULL;
    m_pHeaderTitle = NULL;
    m_pHeaderSubTitle = NULL;
    
    m_pstackWiz97Pages = NULL;
#endif
}

CSnapPage::~CSnapPage ()
{
    // guess we are done with the m_pspiResultItem, decrement its reference count
    if (m_pspiResultItem)
    {
        m_pspiResultItem->Release();
        m_pspiResultItem = NULL;
    }
    
    // Page's parent or caller will delete these objs
    m_pstackWiz97Pages = NULL;
    
#ifdef WIZ97WIZARDS
    DELETE_OBJECT(m_pHeaderTitle);
    DELETE_OBJECT(m_pHeaderSubTitle);
#endif
}

UINT CALLBACK CSnapPage::PropertyPageCallback (HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    // get our psuedo this pointer
    CSnapPage* pThis = (CSnapPage*) ppsp->lParam;
    // get the default callback pointer
    UINT (CALLBACK* pDefaultCallback) (HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp) = pThis->m_pDefaultCallback;
    
    switch (uMsg)
    {
    case PSPCB_RELEASE:
        {
            // Delete ourself
            AFX_MANAGE_STATE(AfxGetStaticModuleState());
            delete pThis;
            break;
        }
    }
    
    // call the default cleanup function if there was one (because we are using
    // mfc and it always puts in a callback for itself there should be one... or
    // we block the page from coming up)
    if (pDefaultCallback)
    {
        return pDefaultCallback (hwnd, uMsg, ppsp);
    }
    
    // There should be a default callback to handle creation, otherwise page will not
    // be created because we return 0.
    ASSERT( PSPCB_CREATE != uMsg );
    
    // to create the page 1 allows it and 0 says 'no way'
    return 0;
}

#ifdef WIZ97WIZARDS
BOOL CSnapPage::OnSetActive()
{
    // NOTE: we only ever want to do this if it is a wizard, otherwise the
    // cancel button gets the default focus!
    if (m_bWiz97)
    {
        // now we can set our buttons correctly
        GetParent()->SendMessage(PSM_SETWIZBUTTONS, 0, m_dwWizButtonFlags);
    }
    
    return CPropertyPage::OnSetActive();
}

LRESULT CSnapPage::OnWizardBack()
{
    // use the snapitem to help us keep track of wizard state
    if (m_pspiResultItem)
    {
        // pop to the last page
        return m_pspiResultItem->PopWiz97Page ();
    }
    else if (NULL != m_pstackWiz97Pages)
    {
        // Or, use our own stack, if we have one
        return PopWiz97Page();
    }
    
    return CPropertyPage::OnWizardBack();
}

LRESULT CSnapPage::OnWizardNext()
{
    // use the snapitem to help us keep track of wizard state
    if (m_pspiResultItem)
    {
        // push our id, in case they need to use the 'back' button
        m_pspiResultItem->PushWiz97Page (m_nIDD);
    }
    else if (NULL != m_pstackWiz97Pages)
    {
        // Or, use our own stack, if we have one
        PushWiz97Page( m_nIDD );
    }
    
    // If we have the ID of the next page, return it, otherwise return default
    return ((m_nNextIDD != -1) ? m_nNextIDD : CPropertyPage::OnWizardNext());
}

int CSnapPage::PopWiz97Page ()
{
    ASSERT( NULL != m_pstackWiz97Pages );
    
    // There better be something on the stack if we're popping it
    ASSERT( m_pstackWiz97Pages->size() );
    
    int i;
    i = m_pstackWiz97Pages->top();
    m_pstackWiz97Pages->pop();
    return i;
}

void CSnapPage::PushWiz97Page (int nIDD)
{
    ASSERT( NULL != m_pstackWiz97Pages );
    m_pstackWiz97Pages->push(nIDD);
}

BOOL CSnapPage::InitWiz97( CComObject<CSecPolItem> *pSecPolItem, DWORD dwFlags, DWORD dwWizButtonFlags, UINT nHeaderTitle, UINT nSubTitle )
{
    CommonInitWiz97( pSecPolItem, dwFlags, dwWizButtonFlags, nHeaderTitle, nSubTitle );
    // Use our own callback.
    SetCallback( CSnapPage::PropertyPageCallback );
    
    return S_OK;
}

BOOL CSnapPage::InitWiz97( LPFNPSPCALLBACK pfnCallback, CComObject<CSecPolItem> *pSecPolItem, DWORD dwFlags,  DWORD dwWizButtonFlags /*= 0*/, UINT nHeaderTitle /*= 0*/, UINT nSubTitle /*= 0*/, STACK_INT *pstackPages /*=NULL*/)
{
    CommonInitWiz97( pSecPolItem, dwFlags, dwWizButtonFlags, nHeaderTitle, nSubTitle );
    // Use the caller's callback which should call ours after it does whatever it does.
    SetCallback( pfnCallback );
    // Use the stack owned by our parent sheet
    m_pstackWiz97Pages = pstackPages;
    
    return S_OK;
}

void CSnapPage::CommonInitWiz97( CComObject<CSecPolItem> *pSecPolItem, DWORD dwFlags,  DWORD dwWizButtonFlags, UINT nHeaderTitle, UINT nSubTitle )
{
    m_psp.dwFlags |= dwFlags;
    
    // they called us this way, so ... they must expect ...
    m_bWiz97 = TRUE;
    
    // get strings
    CString str;
    str.LoadString (nHeaderTitle);
    m_pHeaderTitle = (TCHAR*) malloc ((str.GetLength()+1)*sizeof(TCHAR));
    if (m_pHeaderTitle)
    {
        lstrcpy (m_pHeaderTitle, str.GetBuffer(20));
    } else
    {
        m_pHeaderTitle = _T("\0");
    }
    str.ReleaseBuffer(-1);
    
    str.LoadString (nSubTitle);
    m_pHeaderSubTitle = (TCHAR*) malloc ((str.GetLength()+1)*sizeof(TCHAR));
    if (m_pHeaderSubTitle)
    {
        lstrcpy (m_pHeaderSubTitle, str.GetBuffer(20));
    } else
    {
        m_pHeaderSubTitle = _T("\0");
    }
    
    m_psp.pszHeaderTitle = m_pHeaderTitle;
    m_psp.pszHeaderSubTitle = m_pHeaderSubTitle;
    
    // save off the button flags
    m_dwWizButtonFlags = dwWizButtonFlags;
    
    // save the snapitem
    SetResultObject(pSecPolItem);
}

void CSnapPage::SetCallback( LPFNPSPCALLBACK pfnCallback )
{
    // attempt the wilder CSnapPage mmc stuff
    
    // store the existing Callback information (if any)
    if (m_psp.dwFlags |= PSP_USECALLBACK)
    {
        m_pDefaultCallback = m_psp.pfnCallback;
    }
    
    // hook up our callback function
    m_psp.dwFlags |= PSP_USECALLBACK;
    m_psp.lParam = reinterpret_cast<LONG_PTR>(this);
    m_psp.pfnCallback = pfnCallback;
    
    // IF WE SWITCH TO DLL VERSION OF MFC WE NEED THIS
    // hook up mmc (this is an mmc hack to avoid an issue with AFX_MANAGE_STATE in MFC)
    HRESULT hr = ::MMCPropPageCallback (&m_psp);
    ASSERT (hr == S_OK);
}

#endif

void CSnapPage::SetPostRemoveFocus( int nListSel, UINT nAddId, UINT nRemoveId, CWnd *pwndPrevFocus )
{
    ASSERT( 0 != nAddId );
    ASSERT( 0 != nRemoveId );
    
    // Fix up focus, if necessary
    SET_POST_REMOVE_FOCUS<CDialog>( this, nListSel, nAddId, nRemoveId, pwndPrevFocus );
}

BOOL CSnapPage::OnWizardFinish()
{
    return CPropertyPage::OnWizardFinish();
}

HRESULT CSnapPage::Initialize( CComObject<CSecPolItem> *pSecPolItem)
{
    HRESULT hr = S_OK;
    
    // turn on an hourglass
    CWaitCursor waitCursor;
    
    // store the snap object
    ASSERT( NULL == m_pspiResultItem );
    
    SetResultObject(pSecPolItem);
    
    ASSERT( NULL != m_pspiResultItem );
    
    // store the existing Callback information (if any)
    if (m_psp.dwFlags |= PSP_USECALLBACK)
    {
        m_pDefaultCallback = m_psp.pfnCallback;
    }
    
    // hook up our callback function
    m_psp.dwFlags |= PSP_USECALLBACK;
    m_psp.lParam = reinterpret_cast<LONG_PTR>(this);
    m_psp.pfnCallback = CSnapPage::PropertyPageCallback;
    
    // IF WE SWITCH TO DLL VERSION OF MFC WE NEED THIS
    // hook up mmc (this is an mmc hack to avoid an issue with AFX_MANAGE_STATE in MFC)
    hr = ::MMCPropPageCallback (&m_psp);
    ASSERT (hr == S_OK);
    
    return hr;
};

void CSnapPage::SetModified( BOOL bChanged /*= TRUE*/ )
{
    // Ignore modifications made during dialog initialization, its not
    // the user doing anything.
    if (!HandlingInitDialog())
    {
        m_bModified = bChanged;
        
        if (bChanged && m_spManager.p)
            m_spManager->SetModified(TRUE);
    }
    CPropertyPage::SetModified( bChanged );
}

/////////////////////////////////////////////////////////////////////////////
// CSnapPage message handlers

BOOL CSnapPage::OnInitDialog()
{
    m_bInitializing = TRUE;
    
#ifdef _DEBUG
    if (m_bDebugNewState)
    {
        // Page should be unmodified, unless its explicitly set new.
        ASSERT( m_bModified );
    }
    else
    {
        ASSERT( !m_bModified );
    }
#endif
    
    // add context help to the style bits
    if (GetParent())
    {
        //GetParent()->ModifyStyleEx (0, WS_EX_CONTEXTHELP, 0);
    }
    
    // call base class and dis-regard return value as per the docs
    CPropertyPage::OnInitDialog();
    
    return TRUE;
}

BOOL CSnapPage::OnApply()
{
    BOOL fRet = TRUE;
    if (!m_bWiz97)   //$review do we need this bool check here?
    {
        m_bModified = FALSE;
        
        if (m_spManager.p && m_spManager->IsModified()) //to avoid call mutliple times
        {
            //the manager will force other pages in the sheet to apply
            fRet = m_spManager->OnApply();
        }
        
    }
    
    if (fRet)
    {
        return CPropertyPage::OnApply();
    }
    else
    {
        //Some page refuse to apply, we set this page back to dirty (will also
        //  in turn set the property sheet manager to dirty)
        SetModified();
    }
    
    return fRet;
}

void CSnapPage::OnCancel()
{
    
    if (m_spManager.p)
    {
        m_spManager->OnCancel();
    }
    
    // pass to base class
    CPropertyPage::OnCancel();
}

void CSnapPage::OnDestroy()
{
    CPropertyPage::OnDestroy();
}


BOOL CSnapPage::ActivateThisPage()
{
    BOOL bRet = FALSE;
    // Activate this page so it is visible.  Return TRUE if successful.
    // if the page is in a wizard, it wont have a property sheet manager
    if (m_spManager.p)
    {
        CPropertySheet * pSheet = m_spManager->PropertySheet();
        if (pSheet)
        {
            pSheet->SetActivePage(this);
            bRet = TRUE;
        }
    }
    
    return bRet;
}

BOOL CSnapPage::CancelApply()
{
    // This function should be called from OnApply when changes made
    // to the page are being rejected.
    
    
    // Return FALSE to abort the OnApply
    return FALSE;
}


IMPLEMENT_DYNCREATE(CSnapinPropPage, CSnapPage)

//Check whether the Cancel button of the property sheet is disabled by CancelToClose
BOOL CSnapPage::IsCancelEnabled()
{
    BOOL    fRet = TRUE;
    
    CWnd * pWnd = GetParent()->GetDlgItem(IDCANCEL);
    ASSERT(pWnd);
    
    if (pWnd)
    {
        fRet = pWnd->IsWindowEnabled();
    }
    
    return fRet;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\snapin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.15 */
/* at Thu Oct 03 17:06:29 1996
*/
/* Compiler settings for Snapin.idl:
Os, W1, Zp8, env=Win32, ms_ext, c_ext
error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __Snapin_h__
#define __Snapin_h__

#ifdef __cplusplus
extern "C"{
#endif 
    
    /* Forward Declarations */ 
    
#ifndef __IComponent_FWD_DEFINED__
#define __IComponent_FWD_DEFINED__
    typedef interface IComponent IComponent;
#endif  /* __IComponent_FWD_DEFINED__ */
    
    
    /* header files for imported files */
#include "oaidl.h"
    
    void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
    void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 
    
#ifndef __IComponent_INTERFACE_DEFINED__
#define __IComponent_INTERFACE_DEFINED__
    
    /****************************************
    * Generated header for interface: IComponent
    * at Thu Oct 03 17:06:29 1996
    * using MIDL 3.00.15
    ****************************************/
    /* [unique][helpstring][uuid][object] */ 
    
    
    
    EXTERN_C const IID IID_IComponent;
    
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IComponent : public IUnknown
    {
    public:
    };
    
#else  /* C style interface */
    
    typedef struct IComponentVtbl
    {
        BEGIN_INTERFACE
            
            HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
            
            ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponent __RPC_FAR * This);
        
        END_INTERFACE
    } IComponentVtbl;
    
    interface IComponent
    {
        CONST_VTBL struct IComponentVtbl __RPC_FAR *lpVtbl;
    };
    
    
    
#ifdef COBJMACROS
    
    
#define IComponent_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
    
#define IComponent_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)
    
#define IComponent_Release(This) \
    (This)->lpVtbl -> Release(This)
    
    
#endif /* COBJMACROS */
    
    
#endif  /* C style interface */
    
    
    
    
#endif  /* __IComponent_INTERFACE_DEFINED__ */
    
    
    
#ifndef __SNAPINLib_LIBRARY_DEFINED__
#define __SNAPINLib_LIBRARY_DEFINED__
    
    /****************************************
    * Generated header for library: SNAPINLib
    * at Thu Oct 03 17:06:29 1996
    * using MIDL 3.00.15
    ****************************************/
    /* [helpstring][version][uuid] */ 
    
    
    
    EXTERN_C const IID LIBID_SNAPINLib;
    
#ifdef __cplusplus
    EXTERN_C const CLSID CLSID_Snapin;
    
    class Snapin;
#endif
#endif /* __SNAPINLib_LIBRARY_DEFINED__ */
    
    /* Additional Prototypes for ALL interfaces */
    
    /* end of Additional Prototypes */
    
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\snpdata.h ===
#ifndef INCLUDE_SNPDATA_H
#define INCLUDE_SNPDATA_H

#include "snapdata.h"   // interface definition for IWirelessSnapInDataObject

// forward declaration for spolitem stuff
class CSecPolItem;
typedef CComObject<CSecPolItem>* LPCSECPOLITEM;

///////////////////////////////////////////////////////////////////////////////
// Macros to be used for adding toolbars to CSnapObject derived objects.
// See CSnapObject class definition for example.
#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
    STDMETHOD_(CSnapInToolbarInfo*, GetToolbarInfo)(void) \
{ \
    if (NULL == m_aToolbarInfo) \
{ \
    CSnapInToolbarInfo m_tbInfo_##theClass[] = \
{
#define SNAPINTOOLBARID_ENTRY(id) \
{ NULL, NULL, NULL, id, 0, NULL },
#define END_SNAPINTOOLBARID_MAP(theClass) \
{ NULL, NULL, NULL, 0, 0, NULL } \
}; \
    int nElemCount = sizeof(m_tbInfo_##theClass)/sizeof(CSnapInToolbarInfo); \
    if (nElemCount > 1) \
{ \
    m_aToolbarInfo = new CSnapInToolbarInfo[nElemCount]; \
    if (NULL != m_aToolbarInfo) \
{ \
    CopyMemory( m_aToolbarInfo, m_tbInfo_##theClass, sizeof( CSnapInToolbarInfo ) * nElemCount ); \
} \
} \
    else { \
    ASSERT( 1 == nElemCount ); /* the NULL entry marking end-of-array */ \
    ASSERT( 0 == m_tbInfo_##theClass[0].m_idToolbar ); \
} \
} \
    return m_aToolbarInfo; \
}

///////////////////////////////////////////////////////////////////////////////
// struct CSnapInToolbarInfo - Used to add a toolbar to MMC for a result/scope item.
struct CSnapInToolbarInfo
{
public:
    TCHAR** m_pStrToolTip;      // array of tooltip strings
    TCHAR** m_pStrButtonText;   // NOT USED (array of button text strings)
    UINT* m_pnButtonID;         // array of button IDs
    UINT m_idToolbar;           // id of toolbar
    UINT m_nButtonCount;        // # of buttons on toolbar
    IToolbar* m_pToolbar;       // Interface ptr
    
    ~CSnapInToolbarInfo()
    {
        if (m_pStrToolTip)
        {
            for (UINT i = 0; i < m_nButtonCount; i++)
            {
                delete m_pStrToolTip[i];
                m_pStrToolTip[i] = NULL;
            }
            delete [] m_pStrToolTip;
            m_pStrToolTip = NULL;
        }
        
        if (m_pStrButtonText)
        {
            for (UINT i = 0; i < m_nButtonCount; i++)
            {
                delete m_pStrButtonText[i];
                m_pStrButtonText[i] = NULL;
            }
            
            delete [] m_pStrButtonText;
            m_pStrButtonText = NULL;
        }
        
        if (m_pnButtonID)
        {
            delete m_pnButtonID;
            m_pnButtonID = NULL;
        }
        
        m_nButtonCount = 0;
        if (m_pToolbar)
            m_pToolbar->Release();
        m_pToolbar = NULL;
    }
};

///////////////////////////////////////////////////////////////////////////////
struct CSnapInToolBarData
{
    WORD wVersion;
    WORD wWidth;
    WORD wHeight;
    WORD wItemCount;
    //WORD aItems[wItemCount]
    
    WORD* items()
    { return (WORD*)(this+1); }
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)

///////////////////////////////////////////////////////////////////////////////
// class CWirelessSnapInDataObjectImpl - Implementation of private COM interface

template <class T>
class CWirelessSnapInDataObjectImpl :
public IWirelessSnapInDataObject
{
public:
    CWirelessSnapInDataObjectImpl() :
      m_DataObjType( CCT_UNINITIALIZED ),
          m_aToolbarInfo( NULL ),
          m_bEnablePropertyChangeHook( FALSE )
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::CWirelessSnapInDataObjectImpl this-%p\n"), this);
      }
      
      virtual ~CWirelessSnapInDataObjectImpl()
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::~CWirelessSnapInDataObjectImpl this-%p\n"), this);
          // Clean up array of toolbar info
          if (NULL != m_aToolbarInfo)
          {
              delete [] m_aToolbarInfo;
              m_aToolbarInfo = NULL;
          }
      }
      
      ///////////////////////////////////////////////////////////////////////////
      // Interface to handle IExtendContextMenu
      STDMETHOD(AddMenuItems)( LPCONTEXTMENUCALLBACK piCallback,
          long *pInsertionAllowed )
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::AddMenuItems NOT implemented, this-%p\n"), this);
          return E_NOTIMPL;
      }
      STDMETHOD(Command)( long lCommandID,
          IConsoleNameSpace *pNameSpace )
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::Command NOT implemented, this-%p\n"), this);
          return E_NOTIMPL;
      }
      
      ///////////////////////////////////////////////////////////////////////////
      // IExtendContextMenu helpers
      // Non-interface members intended to be overridden by instantiated class.
      STDMETHOD(AdjustVerbState)(LPCONSOLEVERB pConsoleVerb)
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::AdjustVerbState this-%p\n"), this);
          
          HRESULT hr = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, FALSE);
          ASSERT (hr == S_OK);
          hr = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
          ASSERT (hr == S_OK);
          return hr;
      }
      
      ///////////////////////////////////////////////////////////////////////////
      // Interface to handle IExtendPropertySheet
      STDMETHOD(CreatePropertyPages)( LPPROPERTYSHEETCALLBACK lpProvider,
          LONG_PTR handle )
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::CreatePropertyPages this-%p\n"), this);
          return S_OK;    // no prop pages added by default
      }
      STDMETHOD(QueryPagesFor)( void )
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::QueryPagesFor NOT implemented this-%p\n"), this);
          return E_NOTIMPL;
      }
      
      ///////////////////////////////////////////////////////////////////////////
      // Interface to handle IExtendControlbar
      STDMETHOD(ControlbarNotify)( IControlbar *pControlbar,
          IExtendControlbar *pExtendControlbar,
          MMC_NOTIFY_TYPE event,
          LPARAM arg,
          LPARAM param )
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::ControlbarNotify this-%p\n"), this);
          
          AFX_MANAGE_STATE(AfxGetStaticModuleState());
          
          T* pThis = (T*)this;
          HRESULT hr;
          
          // Load object's toolbar (if any) and associated baggage.
          pThis->SetControlbar(pControlbar, pExtendControlbar);
          
          if(MMCN_SELECT == event)
          {
              BOOL bScope = (BOOL) LOWORD(arg);
              BOOL bSelect = (BOOL) HIWORD (arg);
              
              // A scope item has been selected
              CSnapInToolbarInfo* pInfo = pThis->GetToolbarInfo();
              if (pInfo == NULL)
                  return S_OK;
              
              // Attach toolbar to console, and set button states with UpdateToolbarButton()
              for(; pInfo->m_idToolbar; pInfo++)
              {
                  // When a result item has been deselected, remove its toolbar.
                  // Otherwise add the object's toolbar.  Note: the scope item's
                  // toolbar is always displayed as long as we're in its "scope",
                  // thats why we Detach() for a result item only.
                  if (!bScope && !bSelect)
                  {
                      hr = pControlbar->Detach(pInfo->m_pToolbar);
                      ASSERT (hr == S_OK);
                  }
                  else
                  {
                      hr = pControlbar->Attach(TOOLBAR, pInfo->m_pToolbar);
                      ASSERT (hr == S_OK);
                  }
                  for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
                  {
                      if (pInfo->m_pnButtonID[i])
                      {
                          // set the button state properly for each valid state
                          pInfo->m_pToolbar->SetButtonState( pInfo->m_pnButtonID[i], ENABLED, UpdateToolbarButton( pInfo->m_pnButtonID[i], bSelect, ENABLED ));
                          pInfo->m_pToolbar->SetButtonState( pInfo->m_pnButtonID[i], CHECKED, UpdateToolbarButton( pInfo->m_pnButtonID[i], bSelect, CHECKED ));
                          pInfo->m_pToolbar->SetButtonState( pInfo->m_pnButtonID[i], HIDDEN, UpdateToolbarButton( pInfo->m_pnButtonID[i], bSelect, HIDDEN ));
                          pInfo->m_pToolbar->SetButtonState( pInfo->m_pnButtonID[i], INDETERMINATE, UpdateToolbarButton( pInfo->m_pnButtonID[i], bSelect, INDETERMINATE ));
                          pInfo->m_pToolbar->SetButtonState( pInfo->m_pnButtonID[i], BUTTONPRESSED, UpdateToolbarButton( pInfo->m_pnButtonID[i], bSelect, BUTTONPRESSED ));
                      }
                  }
              }
              return S_OK;
          }
          
          // This is supposed to be the only other event IExtendControlbar receives.
          ASSERT( MMCN_BTN_CLICK == event );
          return pThis->Command( (UINT)param, NULL );
      }
      STDMETHOD(SetControlbar)( IControlbar *pControlbar,
          IExtendControlbar *pExtendControlbar )
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::SetControlbar this-%p\n"), this);
          
          AFX_MANAGE_STATE(AfxGetStaticModuleState());
          
          T* pThis = (T*)this;
          
          CSnapInToolbarInfo* pInfo = pThis->GetToolbarInfo();
          if (pInfo == NULL)
              return S_OK;
          
          for( ; pInfo->m_idToolbar; pInfo++)
          {
              if (pInfo->m_pToolbar)
                  continue;
              
              HBITMAP hBitmap = LoadBitmap( AfxGetInstanceHandle(), MAKEINTRESOURCE(pInfo->m_idToolbar) );
              if (hBitmap == NULL)
                  return S_OK;
              
              HRSRC hRsrc = ::FindResource( AfxGetInstanceHandle(), MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR );
              if (hRsrc == NULL)
                  return S_OK;
              
              HGLOBAL hGlobal = LoadResource( AfxGetInstanceHandle(), hRsrc );
              if (hGlobal == NULL)
                  return S_OK;
              
              CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource( hGlobal );
              if (pData == NULL)
                  return S_OK;
              ASSERT( pData->wVersion == 1 );
              
              pInfo->m_nButtonCount = pData->wItemCount;
              pInfo->m_pnButtonID = new UINT[pInfo->m_nButtonCount];
              MMCBUTTON *pButtons = new MMCBUTTON[pData->wItemCount];
              
              pInfo->m_pStrToolTip = new TCHAR* [pData->wItemCount];
              if (pInfo->m_pStrToolTip == NULL)
                  continue;
              
              for (int i = 0, j = 0; i < pData->wItemCount; i++)
              {
                  pInfo->m_pStrToolTip[i] = NULL;
                  memset(&pButtons[i], 0, sizeof(MMCBUTTON));
                  pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
                  if (pButtons[i].idCommand)
                  {
                      pButtons[i].nBitmap = j++;
                      // get the statusbar string and allow modification of the button state
                      TCHAR strStatusBar[512];
                      LoadString( AfxGetInstanceHandle(), pButtons[i].idCommand, strStatusBar, 512 );
                      
                      pInfo->m_pStrToolTip[i] = new TCHAR[lstrlen(strStatusBar) + 1];
                      if (pInfo->m_pStrToolTip[i] == NULL)
                          continue;
                      lstrcpy( pInfo->m_pStrToolTip[i], strStatusBar );
                      pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
                      pButtons[i].lpButtonText = _T("");
                      pThis->SetToolbarButtonInfo( pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType );
                  }
                  else
                  {
                      pButtons[i].lpTooltipText = _T("");
                      pButtons[i].lpButtonText = _T("");
                      pButtons[i].fsType = TBSTYLE_SEP;
                  }
              }
              
              HRESULT hr = pControlbar->Create( TOOLBAR, pExtendControlbar, reinterpret_cast<LPUNKNOWN*>(&pInfo->m_pToolbar) );
              if (hr != S_OK)
                  continue;
              
              // pData->wHeight is 15, but AddBitmap insists on 16, hard code it.
              hr = pInfo->m_pToolbar->AddBitmap( pData->wItemCount, hBitmap, pData->wWidth, 16, RGB(192, 192, 192) );
              if (hr != S_OK)
              {
                  pInfo->m_pToolbar->Release();
                  pInfo->m_pToolbar = NULL;
                  continue;
              }
              
              hr = pInfo->m_pToolbar->AddButtons( pData->wItemCount, pButtons );
              if (hr != S_OK)
              {
                  pInfo->m_pToolbar->Release();
                  pInfo->m_pToolbar = NULL;
              }
              
              delete [] pButtons;
          }
          return S_OK;
      }
      
      ///////////////////////////////////////////////////////////////////////////
      // IExtendControlbar helpers
      // Non-interface members intended to be overridden by instantiated class.
      STDMETHOD_(void, SetToolbarButtonInfo)( UINT id,        // button ID
          BYTE *fsState,  // return button state here
          BYTE *fsType )  // return button type here
      {
          *fsState = TBSTATE_ENABLED;
          *fsType = TBSTYLE_BUTTON;
      }
      STDMETHOD_(BOOL, UpdateToolbarButton)( UINT id,                 // button ID
          BOOL bSnapObjSelected,   // ==TRUE when result/scope item is selected
          BYTE fsState )           // enable/disable this button state by returning TRUE/FALSE
      {
          return FALSE;
      }
      
      BEGIN_SNAPINTOOLBARID_MAP(CWirelessSnapInDataObjectImpl)
          // Add a line like the following one for each toolbar to be displayed
          // for the derived class.  Since there is no toolbar by default we'll
          // leave the macro out completely.
          //SNAPINTOOLBARID_ENTRY(your_toolbar_resource_id_goes_here, NULL)
          END_SNAPINTOOLBARID_MAP(CWirelessSnapInDataObjectImpl)
          
          ///////////////////////////////////////////////////////////////////////////
          // Interface to handle IComponent and IComponentData
          STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
          LPARAM arg,
          LPARAM param,
          BOOL bComponentData,
          IConsole *pConsole,
          IHeaderCtrl *pHeader )
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::Notify NOT implemented this-%p\n"), this);
          return E_NOTIMPL;
      }
      
      ///////////////////////////////////////////////////////////////////////////
      // IComponent and IComponentData Notify() helpers
      // Non-interface members intended to be overridden by instantiated class.
      STDMETHOD(OnDelete)( LPARAM arg, LPARAM param )
      {
          return S_OK;
      }
      STDMETHOD(OnRename)( LPARAM arg, LPARAM param )
      {
          return S_OK;
      }
      STDMETHOD(OnPropertyChange)( LPARAM lParam, LPCONSOLE pConsole )
      {
          T* pThis = (T*)this;
          
          // we changed, so update the views
          // NOTE: after we do this we are essentially invalid, so make sure we don't
          // touch any members etc on the way back out
          
          return pConsole->UpdateAllViews( pThis, 0, 0 );
          // we don't have a failure case
      }
      STDMETHOD(EnumerateResults)(LPRESULTDATA pResult, int nSortColumn, DWORD dwSortOrder )
      {
          ASSERT (0);
          
          // set the sort parameters
          pResult->Sort( nSortColumn, dwSortOrder, 0 );
          
          return S_OK; //hr;
      }
      
      ///////////////////////////////////////////////////////////////////////////
      // Interface to handle IComponent
      STDMETHOD(GetResultDisplayInfo)( RESULTDATAITEM *pResultDataItem )
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::GetResultDisplayInfo NOT implmented, this-%p\n"), this);
          return E_NOTIMPL;
      }
      
      ///////////////////////////////////////////////////////////////////////////
      // Interface to handle IComponentData
      STDMETHOD(GetScopeDisplayInfo)( SCOPEDATAITEM *pScopeDataItem )
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::GetScopeDisplayInfo NOT implemented, this-%p\n"), this);
          return E_NOTIMPL;
      }
      
      ///////////////////////////////////////////////////////////////////////////
      // Non-interface functions intended to be overridden by instantiated class
      STDMETHOD(DoPropertyChangeHook)( void )
      {
          return S_OK;
      }
      
      ///////////////////////////////////////////////////////////////////////////
      // Other IIWirelessSnapInData interface functions
      STDMETHOD(GetScopeData)( SCOPEDATAITEM **ppScopeDataItem )
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::GetScopeData NOT implemented, this-%p\n"), this);
          return E_NOTIMPL;
      }
      STDMETHOD(GetResultData)( RESULTDATAITEM **ppResultDataItem )
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::GetResultData NOT implemented, this-%p\n"), this);
          return E_NOTIMPL;
      }
      STDMETHOD(GetGuidForCompare)( GUID *pGuid )
      {
          OPT_TRACE(_T("CWirelessSnapInDataObjectImpl::GetGuidForCompare NOT implemented, this-%p\n"), this);
          return E_NOTIMPL;
      }
      STDMETHOD(GetDataObjectType)( DATA_OBJECT_TYPES *ptype )
      {
          ASSERT( NULL != ptype );
          if (NULL == ptype)
              return E_INVALIDARG;
          *ptype = m_DataObjType;
          return S_OK;
      }
      STDMETHOD(SetDataObjectType)( DATA_OBJECT_TYPES type )
      {
          m_DataObjType = type;
          return S_OK;
      }
      STDMETHOD(EnablePropertyChangeHook)( BOOL bEnable )
      {
          m_bEnablePropertyChangeHook = bEnable;
          return S_OK;
      }
      
      BOOL IsPropertyChangeHookEnabled()
      {
          return m_bEnablePropertyChangeHook;
      }
      
protected:
    DATA_OBJECT_TYPES   m_DataObjType;
    CSnapInToolbarInfo *m_aToolbarInfo; // IExtendControlbar impl
    CString m_strName;  // Policy's name, stored on rename, used in GetResultDisplayInfo?
    
    BOOL    m_bEnablePropertyChangeHook;   // if TRUE, call DoPropertyChangeHook on MMCN_PROPERTY_CHANGE
};

#endif  //#ifndef INCLUDE_SNPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\snputils.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       SnpUtils.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "windowsx.h"

DWORD FormatError(HRESULT hr, TCHAR *pszBuffer, UINT cchBuffer)
{
    DWORD dwErr;
    
    // Copy over default message into szBuffer
    _tcscpy(pszBuffer, _T("Error"));
    
    // Ok, we can't get the error info, so try to format it
    // using the FormatMessage
    
    // Ignore the return message, if this call fails then I don't
    // know what to do.
    
    dwErr = FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        hr,
        0,
        pszBuffer,
        cchBuffer,
        NULL);
    pszBuffer[cchBuffer-1] = 0;
    
    return dwErr;
}

///////////////////////////////////////////////////////////////////////////////
// GetErrorMessage
//  Format the error message based on the HRESULT
//
// Note: The caller should NOT try to modify the string returned by this function
//
LPCTSTR GetErrorMessage(HRESULT hr)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    static CString st;
    
    st = _T("");
    
    if (FAILED(hr))
    {
        TCHAR szBuffer[2048];
        
        CString stErrCode;
        
        FormatError(hr, szBuffer, DimensionOf(szBuffer));
        
        stErrCode.Format(_T("%08lx"), hr);
        
        AfxFormatString2(st, IDS_ERROR_SYSTEM_ERROR_FORMAT,
            szBuffer, (LPCTSTR) stErrCode);
    }
    
    return (LPCTSTR)st;
}

void ReportError(UINT uMsgId, HRESULT hr)
{
    CString strMessage;
    CThemeContextActivator activator;
    strMessage.FormatMessage (uMsgId, GetErrorMessage(hr));
    AfxMessageBox (strMessage);
}

//Allocate the data buffer for a new Wireless Policy. Fills in
//default values and the GUID identifier.
//The caller needs to call FreeWirelessPolicyData if the return is
//S_OK
HRESULT CreateWirelessPolicyDataBuffer(
                                    PWIRELESS_POLICY_DATA * ppPolicy
                                    )
{
    ASSERT(ppPolicy);
    
    HRESULT hr = S_OK;
    *ppPolicy = NULL;
    PWIRELESS_POLICY_DATA pPolicy = NULL;
    
    
    pPolicy = (PWIRELESS_POLICY_DATA)AllocPolMem(sizeof(*pPolicy));
    if (NULL == pPolicy)
    {
        return E_OUTOFMEMORY;
    }
    
    CoCreateGuid(&pPolicy->PolicyIdentifier);
    
    pPolicy->dwPollingInterval = 10800;
    pPolicy->dwDisableZeroConf = 0;
    pPolicy->dwNumPreferredSettings = 0;
    pPolicy->dwNetworkToAccess = WIRELESS_ACCESS_NETWORK_ANY;
    pPolicy->dwConnectToNonPreferredNtwks = 0;
    
    
    if (FAILED(hr))
    {
        if (pPolicy)
        {
            FreePolMem(pPolicy);
        }
        
    }
    else
    {
        *ppPolicy = pPolicy;
    }
    
    return hr;
}

void FreeAndThenDupString(LPWSTR * ppwszDest, LPCWSTR pwszSource)
{
    ASSERT(ppwszDest);
    
    if (*ppwszDest)
        FreePolStr(*ppwszDest);
    
    *ppwszDest = AllocPolStr(pwszSource);
}

void SSIDDupString(WCHAR *ppwszDest, LPCWSTR pwszSource)
{
    
    wcsncpy(ppwszDest,pwszSource, 32);
}

BOOL
IsDuplicateSSID(
                CString &NewSSID,
                DWORD dwNetworkType,
                PWIRELESS_POLICY_DATA pWirelessPolicyData,
                DWORD dwId
                )
{
    DWORD dwError = 0;
    DWORD dwNumPreferredSettings = 0;
    PWIRELESS_PS_DATA pWirelessPSData = NULL;
    PWIRELESS_PS_DATA *ppWirelessPSData = NULL;
    DWORD i = 0;
    BOOL bDuplicate = FALSE;
    DWORD dwSSIDLen = 0;
    DWORD dwStart = 0;
    DWORD dwEnd = 0;
    WCHAR pszTempSSID[33];
    
    
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    dwNumPreferredSettings = pWirelessPolicyData->dwNumPreferredSettings;
    
    if (dwNetworkType == WIRELESS_NETWORK_TYPE_AP) {
        dwStart = 0;    
        dwEnd = pWirelessPolicyData->dwNumAPNetworks;
    } else 
    {
        dwStart = pWirelessPolicyData->dwNumAPNetworks;
        dwEnd = pWirelessPolicyData->dwNumPreferredSettings;
    }
    
    for (i = dwStart; i < dwEnd ; i++) {
        
        if (i != dwId) {
            
            pWirelessPSData = *(ppWirelessPSData + i);
            
            dwSSIDLen = pWirelessPSData->dwWirelessSSIDLen;
            // terminate the pszWirelessSSID to correct length or comparision may fail
            // ideally WirelessSSID should be a 33 char unicode string with room for a null
            // char in the end. Since, we didnt start with that to begin with, 
            // As a hack, copy the ssid to a new location with null termination. 

            wcsncpy(pszTempSSID, pWirelessPSData->pszWirelessSSID, 32);
            pszTempSSID[dwSSIDLen] = L'\0';
            
            if (0 == NewSSID.Compare(pszTempSSID)) {

                bDuplicate = TRUE;
                
            }
        }
    }
    
    return (bDuplicate);
    
    
}

HRESULT DeleteWirelessPolicy(HANDLE hPolicyStore,
                          PWIRELESS_POLICY_DATA pPolicy)
{
    ASSERT(pPolicy);
    HRESULT hr = S_OK;
    
    CWRg(WirelessDeletePolicyData(
        hPolicyStore,
        pPolicy
        ));
Error:
    
    return hr;
}



#ifndef PROPSHEETPAGE_LATEST
#ifdef UNICODE
#define PROPSHEETPAGE_LATEST PROPSHEETPAGEW_LATEST
#else
#define PROPSHEETPAGE_LATEST PROPSHEETPAGEA_LATEST
#endif
#endif

HPROPSHEETPAGE MyCreatePropertySheetPage(PROPSHEETPAGE* ppsp)
{
    PROPSHEETPAGE_LATEST pspLatest = {0};
    CopyMemory (&pspLatest, ppsp, ppsp->dwSize);
    pspLatest.dwSize = sizeof(pspLatest);
    
    HPROPSHEETPAGE pProp= ::CreatePropertySheetPage (&pspLatest);
    
    DWORD dwErr = GetLastError();
    
    {
        LPVOID lpMsgBuf;
        FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL
            );
        
        // Free the buffer.
        LocalFree( lpMsgBuf );
        
    }
    
    return pProp;
}

void
InitFonts(
   HWND     hDialog,
   HFONT&   bigBoldFont)
{
   ASSERT(::IsWindow(hDialog));

   do
   {
      NONCLIENTMETRICS ncm;
      memset(&ncm, 0, sizeof(ncm));
      ncm.cbSize = sizeof(ncm);

      if ( FALSE == ::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0))
      {
          break;
      }
      
      LOGFONT bigBoldLogFont = ncm.lfMessageFont;
      bigBoldLogFont.lfWeight = FW_BOLD;

      //localize
      CString fontName;
      fontName.LoadString(IDS_BOLD_FONT_NAME);

      // ensure null termination 260237

      memset(bigBoldLogFont.lfFaceName, 0, LF_FACESIZE * sizeof(TCHAR));
      size_t fnLen = fontName.GetLength();
      lstrcpyn(
         bigBoldLogFont.lfFaceName,  // destination buffer
         (LPCTSTR) fontName,         // string // don't copy over the last null
         min(LF_FACESIZE - 1, fnLen) // number of characters to copy
         );

      //define font size
      CString strTemp;
      strTemp.LoadString(IDS_BOLD_FONT_SIZE);
      unsigned fontSize = _ttoi( (LPCTSTR) strTemp );
      
 
      HDC hdc = 0;
      hdc = ::GetDC(hDialog);
      if ( NULL == hdc )
      {
          break;
      }
      
      bigBoldLogFont.lfHeight =
         - ::MulDiv(
            static_cast<int>(fontSize),
            GetDeviceCaps(hdc, LOGPIXELSY),
            72);

      bigBoldFont = ::CreateFontIndirect( ( CONST LOGFONT* ) &bigBoldLogFont);
      if ( NULL == bigBoldFont )
      {
          break;
      }
      
      ReleaseDC(hDialog, hdc);
   }
   while (0);

}



void
SetControlFont(HWND parentDialog, int controlID, HFONT font)
{
   ASSERT(::IsWindow(parentDialog));
   ASSERT(controlID);
   ASSERT(font);

   HWND control = ::GetDlgItem(parentDialog, controlID);

   if (control)
   {
      SetWindowFont(control, font, TRUE);
   }
}



 

void
SetLargeFont(HWND dialog, int bigBoldResID)
{
   ASSERT(::IsWindow(dialog));
   ASSERT(bigBoldResID);

   static HFONT bigBoldFont = 0;
   if (!bigBoldFont)
   {
      InitFonts(dialog, bigBoldFont);
   }

   SetControlFont(dialog, bigBoldResID, bigBoldFont);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\snppage.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Snppage.h
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#ifndef _SNPPAGE_H
#define _SNPPAGE_H

// CSnapPage.h : header file
//

// PSM_QUERYSIBLING helpers
//
// User defined message IDs, passed in wparam of message PSM_QUERYSIBLING
#define PSM_QUERYSIBLING_ACTIVATED  (WM_USER + 1)

#ifdef WIZ97WIZARDS
class CWiz97Sheet;
#endif

class CPropertySheetManager;

class CSnapPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CSnapPage)
        
        CSnapPage(UINT nIDTemplate, BOOL bWiz97=FALSE, UINT nNextIDD=-1);
    CSnapPage() {ASSERT(0);};
    virtual ~CSnapPage();
    
    virtual HRESULT Initialize( CComObject<CSecPolItem>* pSecPolItem);
    void SetManager(CPropertySheetManager * pManager)
    {
        m_spManager = pManager;
    }
    
    UINT m_nIDD;
    UINT m_nNextIDD;
    BOOL m_bWiz97;
    
#ifdef WIZ97WIZARDS
public:
    virtual BOOL InitWiz97( CComObject<CSecPolItem> *pSecPolItem, DWORD dwFlags,
        DWORD dwWizButtonFlags = 0, UINT nHeaderTitle = 0, UINT nSubTitle = 0);
    virtual BOOL InitWiz97( LPFNPSPCALLBACK pfnCallback, CComObject<CSecPolItem> *pSecPolItem,
        DWORD dwFlags,  DWORD dwWizButtonFlags = 0, UINT nHeaderTitle = 0, UINT nSubTitle = 0,
        STACK_INT *pstackPages=NULL);
    
    // our m_psp
    PROPSHEETPAGE   m_psp;
    
    void Wiz97Sheet (CWiz97Sheet* pWiz97Sheet) {m_pWiz97Sheet = pWiz97Sheet;};
    CWiz97Sheet* Wiz97Sheet () {return m_pWiz97Sheet;};
    
protected:
    void CommonInitWiz97( CComObject<CSecPolItem> *pSecPolItem, DWORD dwFlags,
        DWORD dwWizButtonFlags, UINT nHeaderTitle, UINT nSubTitle );
    void SetCallback( LPFNPSPCALLBACK pfnCallback );
    void SetPostRemoveFocus( int nListSel, UINT nAddId, UINT nRemoveId, CWnd *pwndPrevFocus );
    
    CWiz97Sheet* m_pWiz97Sheet;
    DWORD m_dwWizButtonFlags;
    
    TCHAR* m_pHeaderTitle;
    TCHAR* m_pHeaderSubTitle;
#endif
    
    // Overrides
public:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSnapPage)
public:
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnWizardFinish();
    
#ifdef WIZ97WIZARDS
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardBack();
    virtual LRESULT OnWizardNext();
#endif
    //}}AFX_VIRTUAL
    
    static UINT CALLBACK PropertyPageCallback (HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
    UINT (CALLBACK* m_pDefaultCallback) (HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
    
    // Don't need to save original LPARAM for m_pDefaultCallback.  For some reason it works just
    // fine as is.
    //LPARAM  m_paramDefaultCallback;
    
    void ProtectFromStaleData (BOOL bRefresh = TRUE) {m_bDoRefresh = bRefresh;};
    
    // Implementation
public:
    
    BOOL IsModified() { return m_bModified; }
    
    //This is get called when the CPropertySheetManager notify the page
    //that the apply in the manager is done
    //See also CPropertySheetManager::NotifyManagerApplied
    virtual void OnManagerApplied() {};
    
protected:
    //{{AFX_MSG(CSnapPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
        
        void SetResultObject( CComObject<CSecPolItem>* pSecPolItem ) 
    {
        CComObject<CSecPolItem> * pOldItem = m_pspiResultItem;
        
        m_pspiResultItem = pSecPolItem; 
        if (m_pspiResultItem)
        {
            m_pspiResultItem->AddRef();
        }
        
        if (pOldItem)
        {
            pOldItem->Release();
        }
    }
    
    CComObject<CSecPolItem>* GetResultObject() { ASSERT( NULL != m_pspiResultItem ); return m_pspiResultItem; }
    
    // Want to test validity of m_pspiResultItem without actually getting the ptr.
    // We can keep the ASSERT in the accessor function this way.
    BOOL IsNullResultObject() { return NULL == m_pspiResultItem ? TRUE : FALSE; }
    
    void SetModified( BOOL bChanged = TRUE );
    
    BOOL IsCancelEnabled();
    
    BOOL ActivateThisPage();
    
    int PopWiz97Page ();
    void PushWiz97Page (int nIDD);
    
    virtual void OnFinishInitDialog()
    {
        m_bInitializing = FALSE;
    }
    BOOL HandlingInitDialog() { return m_bInitializing; }
    
    virtual BOOL CancelApply();
    
    CComObject <CSecPolItem>*   m_pspiResultItem;
    
    CComPtr<CPropertySheetManager> m_spManager;
    
private:
    BOOL m_bDoRefresh;
    BOOL m_bModified;
    BOOL m_bInitializing;    // TRUE during OnInitDialog
    
    STACK_INT   *m_pstackWiz97Pages;
    
};

//the class to handle MMC property pages
class CSnapinPropPage : public CSnapPage
{
    DECLARE_DYNCREATE(CSnapinPropPage)
        
public:
    CSnapinPropPage (UINT nIDTemplate, BOOL fNotifyConsole = TRUE) : 
    CSnapPage(nIDTemplate),
        m_fNotifyConsole (fNotifyConsole) 
    {}
    
    CSnapinPropPage() :CSnapPage() {}
    
    virtual ~CSnapinPropPage() {}
    
    virtual BOOL OnApply()
    {
        if (IsModified() && m_pspiResultItem && m_fNotifyConsole)
        {
            LONG_PTR handleNotify = m_pspiResultItem->GetNotifyHandle();   
            
            //We dont use CPropertySheetManager to control the prop sheet if this is
            //a MMC prop sheet. So we should call OnManagerApplied to let the page to 
            //apply the data here
            if (!m_spManager.p)
            {
                OnManagerApplied();
            }
            
            if (handleNotify)
                MMCPropertyChangeNotify(handleNotify, (LPARAM) m_pspiResultItem);
        }
        
        return CSnapPage::OnApply();
    }
protected:
    BOOL m_fNotifyConsole;
};

typedef CList<CSnapPage *, CSnapPage *> CListSnapPages;


class ATL_NO_VTABLE CPropertySheetManager :
public CComObjectRootEx<CComSingleThreadModel>,
public IUnknown
{
    BEGIN_COM_MAP(CPropertySheetManager)
        COM_INTERFACE_ENTRY(IUnknown)
        END_COM_MAP()
        
public:
    CPropertySheetManager() : 
    m_fModified (FALSE),
        m_fCanceled (FALSE),
        m_fDataChangeOnApply (FALSE)
    {}
    
    virtual ~CPropertySheetManager() {};
    
    BOOL IsModified() {
        return m_fModified;
    }
    void SetModified(BOOL fModified) {
        m_fModified = fModified;
    }
    
    BOOL IsCanceled() {
        return m_fCanceled;
    }
    
    BOOL HasEverApplied() {
        return m_fDataChangeOnApply;
    }
    
    CPropertySheet * PropertySheet()
    {
        return &m_Sheet;
    }
    
    virtual void AddPage(CSnapPage * pPage)
    {
        ASSERT(pPage);
        
        m_listPages.AddTail(pPage);
        pPage->SetManager(this);
        
        m_Sheet.AddPage(pPage);
    }
    
    virtual void OnCancel()
    {
        m_fCanceled = TRUE;
    }
    
    virtual BOOL OnApply()
    {
        if (!IsModified()) 
            return TRUE;
        
        BOOL fRet = TRUE;
        
        SetModified(FALSE); // prevent from doing this more than once
        
        CSnapPage * pPage;
        
        POSITION pos = m_listPages.GetHeadPosition();
        while(pos)
        {
            pPage = m_listPages.GetNext(pos);
            if (pPage->IsModified())
            {
                fRet = pPage->OnApply();
                
                //exit if any page says no
                if (!fRet)
                    break;
            }
        }
        
        //OK we update data at least once now
        if (fRet)
            m_fDataChangeOnApply = TRUE;
        
        return fRet;
    }
    
    //the manager should call this method to notify the pages that
    //the apply in the manager is done, so that the page can do their
    //specific data operation
    virtual void NotifyManagerApplied()
    {
        CSnapPage * pPage;
        POSITION pos = m_listPages.GetHeadPosition();
        while(pos)
        {
            pPage = m_listPages.GetNext(pos);
            pPage->OnManagerApplied();
        }
    }
    
    virtual CPropertySheet * GetSheet()
    {
        return &m_Sheet;
    }
    
    virtual int DoModalPropertySheet()
    {
        return m_Sheet.DoModal();
    }
    
protected:
    
    CPropertySheet m_Sheet;
    CListSnapPages m_listPages;
    BOOL m_fModified;
    BOOL m_fCanceled;
    BOOL m_fDataChangeOnApply;
    
};

class CMMCPropSheetManager : public CPropertySheetManager
{
public:
    CMMCPropSheetManager() : 
      CPropertySheetManager(),
          m_fNotifyConsole(FALSE)
      {}
      
      void EnableConsoleNotify(
          LONG_PTR lpNotifyHandle,
          LPARAM lParam = 0
          ) 
      {
          m_fNotifyConsole = TRUE;
          m_lpNotifyHandle = lpNotifyHandle;
          m_lpNotifyParam = lParam;
      }
      
      void NotifyConsole()
      {
          if (m_fNotifyConsole && m_lpNotifyHandle)
          {
              ::MMCPropertyChangeNotify(
                  m_lpNotifyHandle,
                  m_lpNotifyParam
                  );
          }
      }
      
protected:
    LONG_PTR m_lpNotifyHandle;
    LPARAM m_lpNotifyParam;
    BOOL m_fNotifyConsole;
};

//Max number of chars in a name or description
const UINT c_nMaxName = 255;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\snputils.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       SnpUtils.h
//
//--------------------------------------------------------------------------

#pragma once

#define DimensionOf(rgx) (sizeof((rgx)) / sizeof(*(rgx)))

inline BOOL FHrFailed(HRESULT hr)
{
    return FAILED(hr);
}

#define CORg(hResult) \
    do\
{\
    hr = (hResult);\
    if (FHrFailed(hr))\
{\
    goto Error;\
}\
}\
while (FALSE)

#define CWRg(hResult) \
    do\
{\
    hr = (DWORD) hResult;\
    hr = HRESULT_FROM_WIN32(hr);\
    if (FHrFailed(hr))\
{\
    goto Error;\
}\
}\
while (FALSE)

LPCTSTR GetErrorMessage(HRESULT hr);
void ReportError(UINT uMsgId, HRESULT hr);

HRESULT CreateWirelessPolicyDataBuffer(PWIRELESS_POLICY_DATA * ppPolicy);

void FreeAndThenDupString(LPWSTR * ppwszDest, LPCWSTR pwszSource);
void SSIDDupString(WCHAR *ppwszDest, LPCWSTR pwszSource);
BOOL IsDuplicateSSID(CString &, DWORD, PWIRELESS_POLICY_DATA, DWORD);



HRESULT DeleteWirelessPolicy(
                          HANDLE hPolicyStore,
                          PWIRELESS_POLICY_DATA pPolicy
                          );


HPROPSHEETPAGE MyCreatePropertySheetPage(PROPSHEETPAGE* ppsp);

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
    { SHActivateContext (&m_ulActivationCookie); }
    
    ~CThemeContextActivator()
    { SHDeactivateContext (m_ulActivationCookie); }
    
private:
    ULONG_PTR m_ulActivationCookie;
};

void
SetLargeFont(HWND dialog, int bigBoldResID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\spolitem.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       spolitem.cpp
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <htmlhelp.h>

#include "sprpage.h"

#include "new.h"
#include "genpage.h"

#ifdef WIZ97WIZARDS
#include "wiz97run.h"
#endif



const TCHAR c_szPolicyAgentServiceName[] = _T("PolicyAgent");
#define SERVICE_CONTROL_NEW_POLICY  129

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define celems(_x)          (sizeof(_x) / sizeof(_x[0]))

DWORD
ComputePolicyDN(
                LPWSTR pszDirDomainName,
                GUID PolicyIdentifier,
                LPWSTR pszPolicyDN
                );

// Construction/destruction
CSecPolItem::CSecPolItem () :
m_pDisplayInfo( NULL ),
m_nResultSelected( -1 ),
m_bWiz97On( FALSE ),
m_bBlockDSDelete( FALSE ),
m_bItemSelected( FALSE )
{
    m_pPolicy = NULL;
    m_bNewPol = FALSE;
    ZeroMemory( &m_ResultItem, sizeof( RESULTDATAITEM ) );
}

CSecPolItem::~CSecPolItem()
{
    if (m_pDisplayInfo != NULL)
    {
        delete m_pDisplayInfo;
        m_pDisplayInfo = NULL;
    }
    if (m_pPolicy)
    {
        FreeWirelessPolicyData(m_pPolicy);
    }
};

void CSecPolItem::Initialize (WIRELESS_POLICY_DATA *pPolicy, CComponentDataImpl* pComponentDataImpl, CComponentImpl* pComponentImpl, BOOL bTemporaryDSObject)
{
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    HANDLE hLocalPolicyStore = NULL;
    
    // call base class initialize
    CSnapObject::Initialize( pComponentDataImpl, pComponentImpl, bTemporaryDSObject );
    ZeroMemory( &m_ResultItem, sizeof( RESULTDATAITEM ) );
    
    m_bNewPol = bTemporaryDSObject;
    
    if (m_pPolicy)
    {
        FreeWirelessPolicyData(m_pPolicy);
    }
    
    m_pPolicy = pPolicy;
    
    
    if (m_pPolicy) {
        
        m_strName = pPolicy->pszWirelessName;
    }
    
    
    // Set default resultItem settings
    GetResultItem()->mask = RDI_STR | RDI_IMAGE;
    GetResultItem()->str = MMC_CALLBACK;
    
    // Set the image.  Active items get an image to indicate this state.
    BOOL bEnabled = FALSE;
    bEnabled = CheckForEnabled();
    
    GetResultItem()->nImage = bEnabled ? ENABLEDSECPOLICY_IMAGE_IDX : SECPOLICY_IMAGE_IDX;
}

//////////////////////////////////////////////////////////////////////////
// handle IExtendContextMenu
STDMETHODIMP CSecPolItem::AddMenuItems
(
 LPCONTEXTMENUCALLBACK pContextMenuCallback,
 long *pInsertionAllowed
 )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    CONTEXTMENUITEM mItem;
    LONG    lCommandID;
    
    // only add these menu items if we are pointed to the local machine
    if ((m_pComponentDataImpl->EnumLocation()==LOCATION_REMOTE)
        || (m_pComponentDataImpl->EnumLocation()==LOCATION_LOCAL)
        // extension snapin?
        || ((m_pComponentDataImpl->EnumLocation()==LOCATION_GLOBAL) && (NULL != m_pComponentDataImpl->GetStaticScopeObject()->GetExtScopeObject())))
    {
        // getthe active/inactive strings
        CString strMenuText;
        CString strMenuDescription;
        
        /*
        if (CheckForEnabled ())
        {
            strMenuText.LoadString (IDS_MENUTEXT_UNASSIGN);
            strMenuDescription.LoadString (IDS_MENUDESCRIPTION_UNASSIGN);
            lCommandID = IDM_UNASSIGN;
        } else
        {
            strMenuText.LoadString (IDS_MENUTEXT_ASSIGN);
            strMenuDescription.LoadString (IDS_MENUDESCRIPTION_ASSIGN);
            lCommandID = IDM_ASSIGN;
        }
        
        
        // see if we can insert into the top
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            // set active/inactive
            CONFIGUREITEM (mItem, strMenuText, strMenuDescription, lCommandID, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0);
            hr = pContextMenuCallback->AddItem(&mItem);
            ASSERT(hr == S_OK);
        }
        
        // see if we can insert into the tasks
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
        {
            // set active/inactive
            CONFIGUREITEM (mItem, strMenuText, strMenuDescription, lCommandID, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, 0);
            hr = pContextMenuCallback->AddItem(&mItem);
            ASSERT(hr == S_OK);
        }
        */
    }
    
    // we are done
    return hr;
}
 

STDMETHODIMP CSecPolItem::Command
(
 long lCommandID,
 IConsoleNameSpace*  // not used for result items
 )
{
    
    WCHAR szMachinePath[256];
    HRESULT hr = S_OK;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return CWirelessSnapInDataObjectImpl<CSecPolItem>::Command( lCommandID, (IConsoleNameSpace*)NULL );
    
    // we handled it
    return S_OK;
}

HRESULT CSecPolItem::IsPolicyExist()
{
    HRESULT hr = S_OK;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    HANDLE hPolicyStore = NULL;
    PWIRELESS_PS_DATA * ppWirelessPSData = NULL;
    DWORD dwNumPSObjects = 0;
    
    hPolicyStore = m_pComponentDataImpl->GetPolicyStoreHandle();
    pWirelessPolicyData = GetWirelessPolicy();
    
    return hr;
}

// handle IExtendPropertySheet
STDMETHODIMP CSecPolItem::CreatePropertyPages
(
 LPPROPERTYSHEETCALLBACK lpProvider,
 LONG_PTR handle
 )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    ASSERT(lpProvider != NULL);
    
    // save this notification handle
    SetNotificationHandle (handle);
    
    //check if the policy exists before pops up the property page
    //may be deleted by some other instance, if so return FALSE, force the refresh
    if ( !m_bNewPol )
    {
        hr = IsPolicyExist();
        if ( FAILED(hr) )
        {
            ReportError(IDS_LOAD_ERROR, hr);
            // trigger a refresh
            m_pComponentDataImpl->GetConsole()->UpdateAllViews( this, 0,0 );
            return hr;
        }
    }
    
#ifdef WIZ97WIZARDS
    if (m_bWiz97On)
    {
        // We only run the wizard in the case of a new object, if that changes we will need to
        // verify we are doing an 'add' here
        
        // IF the wizard wants to it will associate these two
        
        PWIRELESS_PS_DATA pWirelessPSData = NULL;
        
        ASSERT(GetWirelessPolicy());
        ASSERT(GetWirelessPolicy()->ppWirelessPSData);
        
        /*
        pWirelessPSData = *GetWirelessPolicy()->ppWirelessPSData;
        if (pWirelessPSData)
        {
        */
        HRESULT hr = CreateSecPolItemWiz97PropertyPages(dynamic_cast<CComObject<CSecPolItem>*>(this), pWirelessPSData, lpProvider);
        // the wizard should have done an addref on the pWirelessPSData pointer we just passed into it, so
        // it so we can feel free to releaseref now
        /*
        } else
        {
        // we don't want to save the notification handle after all
        SetNotificationHandle (NULL);
        hr = E_UNEXPECTED;
        }
        */
        
        return hr;
    } else
    {
#endif
        
        CComPtr<CSecPolPropSheetManager> spPropshtManager =
            new CComObject<CSecPolPropSheetManager>;
        
        if (NULL == spPropshtManager.p)
        {
            ReportError(IDS_OPERATION_FAIL, E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }
        
        // Create the property page(s); gets deleted when the window is destroyed
        CGenPage* pGenPage = new CGenPage(IDD_WIRELESSGENPROP);
        CSecPolRulesPage* pRulesPage = new CSecPolRulesPage();
        if ((pRulesPage == NULL) || (pGenPage == NULL))
            return E_UNEXPECTED;
        
        // if the first page can't initialize this probably means that there was a problem
        // talking to the DS, in which case we fail to bring up the propery pages and figure
        // that a refresh will get us back to a valid state
        hr = pGenPage->Initialize (dynamic_cast<CComObject<CSecPolItem>*>(this));
        if (hr != S_OK)
        {
            // since we are not going to display the tab dialog we need to clean up
            delete pGenPage;
            delete pRulesPage;
            
            // we don't want to save the notification handle after all
            SetNotificationHandle (NULL);
            
            // trigger a refresh
            m_pComponentDataImpl->GetConsole()->UpdateAllViews( this, 0,0 );
            
            return hr;
        }
        
        
        // yes, we ignore the return value on these guys, since the only return value that
        // can currently come back would have come back on the first guy anyway
        pRulesPage->Initialize (dynamic_cast<CComObject<CSecPolItem>*>(this));
        
        HPROPSHEETPAGE hGenPage = MyCreatePropertySheetPage(&(pGenPage->m_psp));
        HPROPSHEETPAGE hRulesPage = MyCreatePropertySheetPage(&(pRulesPage->m_psp));
        
        if ((hGenPage == NULL) || (hRulesPage == NULL))
        {
            // we don't want to save the notification handle after all
            SetNotificationHandle (NULL);
            return E_UNEXPECTED;
        }
        lpProvider->AddPage(hGenPage);
        lpProvider->AddPage(hRulesPage);
        
        
        spPropshtManager->Initialize(dynamic_cast<CComObject<CSecPolItem>*>(this));
        spPropshtManager->AddPage(pRulesPage);
        spPropshtManager->AddPage(pGenPage);
        
        
        return S_OK;
        
#ifdef WIZ97WIZARDS
    }
#endif
    
}

STDMETHODIMP CSecPolItem::QueryPagesFor( void )
{
    // display our locations dialog via this
    return S_OK;
}

// Destroy helper
STDMETHODIMP CSecPolItem::Destroy( void )
{
    // just return success
    return S_OK;
}

// handle IComponent and IComponentData
STDMETHODIMP CSecPolItem::Notify
(
 MMC_NOTIFY_TYPE event,
 LPARAM arg,
 LPARAM param,
 BOOL bComponentData,    // TRUE when caller is IComponentData
 IConsole *pConsole,
 IHeaderCtrl *pHeader
 )
{
#ifdef DO_TRACE
    OPT_TRACE(_T("CSecPolItem::Notify this-%p "), this);
    switch (event)
    {
    case MMCN_ACTIVATE:
        OPT_TRACE(_T("MMCN_ACTIVATE\n"));
        break;
    case MMCN_ADD_IMAGES:
        OPT_TRACE(_T("MMCN_ADD_IMAGES\n"));
        break;
    case MMCN_BTN_CLICK:
        OPT_TRACE(_T("MMCN_BTN_CLICK\n"));
        break;
    case MMCN_CLICK:
        OPT_TRACE(_T("MMCN_CLICK\n"));
        break;
    case MMCN_COLUMN_CLICK:
        OPT_TRACE(_T("MMCN_COLUMN_CLICK\n"));
        break;
    case MMCN_CONTEXTMENU:
        OPT_TRACE(_T("MMCN_CONTEXTMENU\n"));
        break;
    case MMCN_CUTORMOVE:
        OPT_TRACE(_T("MMCN_CUTORMOVE\n"));
        break;
    case MMCN_DBLCLICK:
        OPT_TRACE(_T("MMCN_DBLCLICK\n"));
        break;
    case MMCN_DELETE:
        OPT_TRACE(_T("MMCN_DELETE\n"));
        break;
    case MMCN_DESELECT_ALL:
        OPT_TRACE(_T("MMCN_DESELECT_ALL\n"));
        break;
    case MMCN_EXPAND:
        OPT_TRACE(_T("MMCN_EXPAND\n"));
        break;
    case MMCN_HELP:
        OPT_TRACE(_T("MMCN_HELP\n"));
        break;
    case MMCN_MENU_BTNCLICK:
        OPT_TRACE(_T("MMCN_MENU_BTNCLICK\n"));
        break;
    case MMCN_MINIMIZED:
        OPT_TRACE(_T("MMCN_MINIMIZED\n"));
        break;
    case MMCN_PASTE:
        OPT_TRACE(_T("MMCN_PASTE\n"));
        break;
    case MMCN_PROPERTY_CHANGE:
        OPT_TRACE(_T("MMCN_PROPERTY_CHANGE\n"));
        break;
    case MMCN_QUERY_PASTE:
        OPT_TRACE(_T("MMCN_QUERY_PASTE\n"));
        break;
    case MMCN_REFRESH:
        OPT_TRACE(_T("MMCN_REFRESH\n"));
        break;
    case MMCN_REMOVE_CHILDREN:
        OPT_TRACE(_T("MMCN_REMOVE_CHILDREN\n"));
        break;
    case MMCN_RENAME:
        OPT_TRACE(_T("MMCN_RENAME\n"));
        break;
    case MMCN_SELECT:
        OPT_TRACE(_T("MMCN_SELECT\n"));
        break;
    case MMCN_SHOW:
        OPT_TRACE(_T("MMCN_SHOW\n"));
        break;
    case MMCN_VIEW_CHANGE:
        OPT_TRACE(_T("MMCN_VIEW_CHANGE\n"));
        break;
    case MMCN_SNAPINHELP:
        OPT_TRACE(_T("MMCN_SNAPINHELP\n"));
        break;
    case MMCN_CONTEXTHELP:
        OPT_TRACE(_T("MMCN_CONTEXTHELP\n"));
        break;
    case MMCN_INITOCX:
        OPT_TRACE(_T("MMCN_INITOCX\n"));
        break;
    case MMCN_FILTER_CHANGE:
        OPT_TRACE(_T("MMCN_FILTER_CHANGE\n"));
        break;
    default:
        OPT_TRACE(_T("Unknown event\n"));
        break;
    }
#endif   //#ifdef DO_TRACE
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // if didn't handle something... then return FALSE
    HRESULT hr = S_FALSE;
    
    // handle the event
    switch(event)
    {
    case MMCN_CONTEXTHELP:
        {
            CComQIPtr <IDisplayHelp, &IID_IDisplayHelp> pDisplayHelp ( pConsole );
            ASSERT( pDisplayHelp != NULL );
            if (pDisplayHelp)
            {
                // need to form a complete path to the .chm file
                CString s, s2;
                s.LoadString(IDS_HELPCONCEPTSFILE);
                DWORD dw = ExpandEnvironmentStrings (s, s2.GetBuffer (512), 512);
                s2.ReleaseBuffer (-1);
                if ((dw == 0) || (dw > 512))
                {
                    return E_UNEXPECTED;
                }
                pDisplayHelp->ShowTopic(s2.GetBuffer(512));
                s2.ReleaseBuffer (-1);
                hr = S_OK;
            }
            break;
        }
    case MMCN_SELECT:
        {
            // Obtain IConsoleVerb from console
            CComPtr<IConsoleVerb> spVerb;
            pConsole->QueryConsoleVerb( &spVerb );
            
            m_bItemSelected = !!(HIWORD(arg));
            
            // call object to set verb state
            AdjustVerbState( (IConsoleVerb*)spVerb );
            
            // Remember selected result item
            CComQIPtr <IResultData, &IID_IResultData> spResult( pConsole );
            if (spResult == NULL)
            {
                TRACE(_T("CComponentDataImpl::Notify QI for IResultData FAILED\n"));
                break;
            }
            hr = OnSelect( arg, param, (IResultData*)spResult);
            break;
        }
    case MMCN_PROPERTY_CHANGE:
        {
            // the object pointer should be in lParam
            OnPropertyChange( param, pConsole );
            // This message is received whenever the property sheet is dismissed.
            // Now is a good time to make sure the result item which was originally
            // selected remains so.
            CComQIPtr <IResultData, &IID_IResultData> spResult( pConsole );
            if (spResult == NULL)
            {
                TRACE(_T("CComponentDataImpl::Notify QI for IResultData FAILED\n"));
                break;
            }
            SelectResult( (IResultData*)spResult );
            break;
        }
    case MMCN_VIEW_CHANGE:
        {
            // Refresh the entire result pane if view has changed.
            hr = pConsole->UpdateAllViews( m_pComponentDataImpl->GetStaticScopeObject(), 0, 0 );
            break;
        }
    case MMCN_RENAME:
        {
            hr = OnRename( arg, param );
            // even if the rename failed mmc will still display with the
            // new name... thus we have to force a refresh in the failure case
            if (hr != S_OK)
            {
                if (S_FALSE == hr)
                {
                    CThemeContextActivator activator;
                    AfxMessageBox(IDS_ERROR_EMPTY_POL_NAME);
                }
                else
                {
                    ReportError(IDS_SAVE_ERROR, hr);
                    hr = S_FALSE;
                }
            }
            break;
        }
    case MMCN_DELETE:
        {
            CThemeContextActivator activator;
            
            // delete the item
            if (AfxMessageBox (IDS_SUREYESNO, MB_YESNO | MB_DEFBUTTON2) == IDYES)
            {
                // turn on wait cursor
                CWaitCursor waitCursor;
                
                // Obtain IResultData
                CComQIPtr <IResultData, &IID_IResultData> pResultData( pConsole );
                ASSERT( pResultData != NULL );
                
                // param is not used on MMCN_DELETE, replace it with IResultData*
                hr = OnDelete( arg, (LPARAM)(IResultData*)pResultData );
                
                if (hr != S_OK)
                {
                    ReportError(IDS_SAVE_ERROR, hr);
                    hr = S_FALSE;
                }
                
            }
            else
                hr = S_FALSE;   // tell IComponent the delete wasn't done.
            break;
        }
        // we didn't handle it... do default behaviour
    case MMCN_DBLCLICK:
        {
            PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
            pWirelessPolicyData = GetWirelessPolicy();
            break;
        }
        
        
    case MMCN_ACTIVATE:
    case MMCN_MINIMIZED:
    case MMCN_BTN_CLICK:
    default:
        break;
    }
    
    return hr;
}

HRESULT GetGpoDisplayName(WCHAR *szGpoId, WCHAR *pszGpoName, DWORD dwSize )
{
    LPGROUPPOLICYOBJECT pGPO = NULL;   //Group Policy Object
    HRESULT hr = S_OK;         //result returned by functions
    
    //
    // Create an IGroupPolicyObject instance to work with
    //
    hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL, CLSCTX_SERVER, IID_IGroupPolicyObject, (void **)&pGPO);
    if (FAILED(hr))
    {
        return hr;
    }
    
    hr = pGPO->OpenDSGPO((LPOLESTR)szGpoId,GPO_OPEN_READ_ONLY);
    if (FAILED(hr))
    {
        pGPO->Release();
        return hr;
    }
    
    hr = pGPO->GetDisplayName( pszGpoName,
        dwSize
        );
    
    
    if (FAILED(hr))
    {
        pGPO->Release();
        return hr;
    }
    
    pGPO->Release();
    return hr;
}


// handle IComponent
STDMETHODIMP CSecPolItem::GetResultDisplayInfo( RESULTDATAITEM *pResultDataItem )
{
    TCHAR *temp = NULL;
    DWORD dwError = S_OK;
    
    OPT_TRACE(_T("CSecPolItem::GetResultDisplayInfo this-%p\n"), this);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    // are they looking for the image?
    if (pResultDataItem->mask & RDI_IMAGE)
    {
        pResultDataItem->nImage = GetResultItem()->nImage;
        OPT_TRACE(_T("    returning image[%i]\n"), GetResultItem()->nImage);
    }
    
    // are they looking for a string?
    if (pResultDataItem->mask & RDI_STR)
    {
        if (GetWirelessPolicy() != NULL)
        {
            
            switch (pResultDataItem->nCol)
            {
            case COL_NAME:
                {
                    
                    CString str = m_pPolicy->pszWirelessName;
                    
                    temp = (TCHAR*) realloc (m_pDisplayInfo, (str.GetLength()+1)*sizeof(TCHAR));
                    if (temp == NULL)
                    {
                        dwError = GetLastError();
                    } else
                    {
                        m_pDisplayInfo = temp;
                        lstrcpy (m_pDisplayInfo, str.GetBuffer(20));
                    }
                    pResultDataItem->str = m_pDisplayInfo;
                    OPT_TRACE(_T("    returning COL_NAME-%s\n"), m_pDisplayInfo);
                }
                break;
            case COL_DESCRIPTION:
                {
                    CString str = m_pPolicy->pszDescription;
                    temp = (TCHAR*) realloc (m_pDisplayInfo, (str.GetLength()+1)*sizeof(TCHAR));
                    if (temp == NULL)
                    {
                        dwError = GetLastError(); 
                    } else
                    {
                        m_pDisplayInfo = temp;
                        lstrcpy (m_pDisplayInfo, str.GetBuffer(20));
                    }
                    pResultDataItem->str = m_pDisplayInfo;
                    OPT_TRACE(_T("    returning COL_DESCRIPTION-%s\n"), m_pDisplayInfo);
                }
                break;
            default:
                {
                    if ( !m_pComponentDataImpl->IsRsop() )
                    {
                        switch( pResultDataItem->nCol )
                        {
                            
                        case COL_LAST_MODIFIED:
                            {
                                CString strTime;
                                if(SUCCEEDED(FormatTime((time_t)m_pPolicy->dwWhenChanged, strTime)))
                                {
                                    temp = (TCHAR*) realloc (m_pDisplayInfo, (strTime.GetLength()+1)*sizeof(TCHAR));
                                    if (temp != NULL) {
                                        m_pDisplayInfo = temp;
                                        lstrcpy(m_pDisplayInfo, strTime);
                                    } else
                                    {
                                        dwError = GetLastError();
                                    }
                                    pResultDataItem->str = m_pDisplayInfo;
                                    OPT_TRACE(_T("    returning COL_ACTIVE-%s\n"), m_pDisplayInfo);
                                }
                            }
                            break;
                        default:
                            // for debugging
                            ASSERT (0);
                            break;
                        } //inner switch
                    } //if ( !m_pComponentDataImpl->IsRsop() )
                    else
                    {
                        //rsop case
                        switch( pResultDataItem->nCol )
                        {
                        case COL_GPONAME:
                            if ( m_pPolicy->pRsopInfo )
                            {
                                WCHAR szGpoName[512];
                                CString strGpoId;
                                strGpoId.Format(_T("LDAP://%s"),m_pPolicy->pRsopInfo->pszGPOID);
                                HRESULT hr = GetGpoDisplayName( (WCHAR*)(LPCTSTR)strGpoId, szGpoName, 512 );
                                
                                if (S_OK == hr )
                                {
                                    INT iSize = (lstrlen(szGpoName) + 1) * sizeof(WCHAR);
                                    temp = (TCHAR*) realloc (m_pDisplayInfo, iSize);
                                    if (temp!= NULL) 
                                    {
                                        m_pDisplayInfo = temp;
                                        lstrcpy(m_pDisplayInfo, szGpoName);
                                    } else 
                                    {
                                        dwError = GetLastError();
                                    }
                                    pResultDataItem->str = m_pDisplayInfo;
                                    OPT_TRACE(_T("    returning COL_ACTIVE-%s\n"), m_pDisplayInfo);
                                }
                            }
                            break;
                        case COL_PRECEDENCE:
                            if ( m_pPolicy->pRsopInfo )
                            {
                                const int cchMaxDigits = 33;
                                temp = (TCHAR*) realloc (m_pDisplayInfo, cchMaxDigits * sizeof(TCHAR));
                                if (temp!=NULL) {
                                	 m_pDisplayInfo = temp;
                                    wsprintf(m_pDisplayInfo, _T("%d"),m_pPolicy->pRsopInfo->uiPrecedence);
                                } else 
                                {
                                    dwError = GetLastError();
                                }
                                pResultDataItem->str = m_pDisplayInfo;
                                OPT_TRACE(_T("    returning COL_ACTIVE-%s\n"), m_pDisplayInfo);
                            }
                            break;
                        case COL_OU:
                            if ( m_pPolicy->pRsopInfo )
                            {
                                INT iLen = (lstrlen(m_pPolicy->pRsopInfo->pszSOMID) + 1) *sizeof(TCHAR);
                                temp = (TCHAR*) realloc (m_pDisplayInfo, iLen);
                                if (temp!=NULL) {
                                    m_pDisplayInfo = temp;
                                    lstrcpy(m_pDisplayInfo, m_pPolicy->pRsopInfo->pszSOMID);
                                } else
                                {
                                    dwError = GetLastError();
                                }
                                pResultDataItem->str = m_pDisplayInfo;
                                OPT_TRACE(_T("    returning COL_ACTIVE-%s\n"), m_pDisplayInfo);
                            }
                            break;
                        default:
                            // for debugging
                            ASSERT (0);
                            break;
                        }//inner switch
                    }
                }//default case
            } //outer switch
        } //if (GetWirelessPolicy() != NULL)
        
        
        else
        {
            CString str;
            str.LoadString (IDS_COLUMN_INVALID);
            temp = (TCHAR*) realloc (m_pDisplayInfo, (str.GetLength()+1)*sizeof(TCHAR));
            if (temp == NULL)
            {
                dwError = GetLastError();
            } else
            {
                m_pDisplayInfo = temp;
                lstrcpy (m_pDisplayInfo, str.GetBuffer(20));
            }
            pResultDataItem->str = m_pDisplayInfo;
        }
    }
    
    return HRESULT_FROM_WIN32(dwError);
}


//+---------------------------------------------------------------------------
//
//  Member:     CAdvIpcfgDlg::FormatTime
//
//  Purpose:    convert time_t to a string.
//
//  Returns:    error code
//
//  Note:       _wasctime has some localization problems. So we do the formatting ourselves
HRESULT CSecPolItem::FormatTime(time_t t, CString & str)
{
    time_t timeCurrent = time(NULL);
    LONGLONG llTimeDiff = 0;
    FILETIME ftCurrent = {0};
    FILETIME ftLocal = {0};
    SYSTEMTIME SysTime;
    WCHAR szBuff[256] = {0};
    
    
    str = L"";
    
    GetSystemTimeAsFileTime(&ftCurrent);
    
    llTimeDiff = (LONGLONG)t - (LONGLONG)timeCurrent;
    
    llTimeDiff *= 10000000;
    
    *((LONGLONG UNALIGNED64 *)&ftCurrent) += llTimeDiff;
    
    if (!FileTimeToLocalFileTime(&ftCurrent, &ftLocal ))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    if (!FileTimeToSystemTime( &ftLocal, &SysTime ))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    if (0 == GetDateFormat(LOCALE_USER_DEFAULT,
        0,
        &SysTime,
        NULL,
        szBuff,
        celems(szBuff)))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    str = szBuff;
    str += L" ";
    
    ZeroMemory(szBuff, sizeof(szBuff));
    if (0 == GetTimeFormat(LOCALE_USER_DEFAULT,
        0,
        &SysTime,
        NULL,
        szBuff,
        celems(szBuff)))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    str += szBuff;
    
    return S_OK;
}


// IIWirelessSnapInData
STDMETHODIMP CSecPolItem::GetResultData( RESULTDATAITEM **ppResultDataItem )
{
    ASSERT( NULL != ppResultDataItem );
    ASSERT( NULL != GetResultItem() );
    
    if (NULL == ppResultDataItem)
        return E_INVALIDARG;
    *ppResultDataItem = GetResultItem();
    return S_OK;
}

STDMETHODIMP CSecPolItem::GetGuidForCompare( GUID *pGuid )
{
    ASSERT( NULL != pGuid );
    if (NULL == pGuid)
        return E_INVALIDARG;
    CopyMemory( pGuid, &m_pPolicy->PolicyIdentifier, sizeof( GUID ) );
    return S_OK;
}

STDMETHODIMP CSecPolItem::AdjustVerbState (LPCONSOLEVERB pConsoleVerb)
{
    HRESULT hr = S_OK;
    
    // pass to base class
    hr = CWirelessSnapInDataObjectImpl<CSecPolItem>::AdjustVerbState( pConsoleVerb );
    ASSERT (hr == S_OK);
    
    
    MMC_BUTTON_STATE    buttonProperties = (m_bItemSelected) ? ENABLED : HIDDEN;
    
    if ( m_pComponentDataImpl->IsRsop() )
    {
        PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
        pWirelessPolicyData = GetWirelessPolicy();
        
        hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, buttonProperties, TRUE);
        ASSERT (hr == S_OK);
    }
    else
    {
        hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, buttonProperties, TRUE);
        ASSERT (hr == S_OK);
        
        hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);
        ASSERT (hr == S_OK);
        
        hr = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
        ASSERT (hr == S_OK);
    }
    
    
    
    hr = pConsoleVerb->SetDefaultVerb(m_bItemSelected ?
MMC_VERB_PROPERTIES : MMC_VERB_NONE);
    ASSERT (hr == S_OK);
    
    return hr;
}

STDMETHODIMP CSecPolItem::DoPropertyChangeHook( void )
{
    return DisplaySecPolProperties( m_pPolicy->pszWirelessName, FALSE );
}
///////////////////////////////////////////////////////////////////////////



STDMETHODIMP CSecPolItem::DisplaySecPolProperties( CString strTitle, BOOL bWiz97On /*= TRUE*/ )
{
    HRESULT hr;
    
    // Add a ref for the prop sheet/wizard.
    ((CComObject <CSecPolItem>*)this)->AddRef();
    
    // switch from the IComponentDataImpl to pUnk
    LPUNKNOWN pUnk = m_pComponentDataImpl->GetUnknown();
    
    // bring up the sheet
#ifdef WIZ97WIZARDS
    if (bWiz97On)
    {
        // because we are creating a new one we need to turn on the wiz97 wizard
        // unless it has been overridden
        m_bWiz97On = bWiz97On;
        
        hr = m_pComponentDataImpl->m_pPrshtProvider->CreatePropertySheet(
            strTitle, FALSE, (LONG_PTR)this, (LPDATAOBJECT)this,
            MMC_PSO_NOAPPLYNOW | MMC_PSO_NEWWIZARDTYPE );
    } else
    {
#endif
        hr = m_pComponentDataImpl->m_pPrshtProvider->CreatePropertySheet(
            strTitle, TRUE, (LONG_PTR)this, (LPDATAOBJECT)this,
            MMC_PSO_NOAPPLYNOW );
        
#ifdef WIZ97WIZARDS
    }
#endif
    ASSERT (hr == S_OK);
    
    // TODO: get the mmc team to fix this hack, we shouldn't need to do the FindWindow calls
    // NOTE: if there are multiple MDI windows open this will fail
    HWND hWnd = NULL;
    
    //  (nsun) As of 5/21/99, we no longer need to do this
    //  hr = m_pComponentDataImpl->GetConsole()->GetMainWindow(&hWnd);
    //  hWnd = ::FindWindowEx(hWnd, NULL, L"MDIClient", NULL);
    //  hWnd = ::FindWindowEx(hWnd, NULL, L"MMCChildFrm", NULL);
    //  hWnd = ::FindWindowEx(hWnd, NULL, L"MMCView", NULL);
    //  ASSERT(hWnd);
    
    
    // TODO: need to check return value and call AddExtensionPages if it was successful
    hr = m_pComponentDataImpl->m_pPrshtProvider->AddPrimaryPages (pUnk, TRUE, hWnd, TRUE);
    ASSERT (hr == S_OK);
    
    // m_dwRef should be at least 3; 2 from MMC, 1 from this function
    ((CComObject <CSecPolItem>*)this)->Release();
    
    
    hr = m_pComponentDataImpl->GetConsole()->GetMainWindow(&hWnd);
    ASSERT(hWnd);
    
    // Show() returns 1 if wizard is cancelled, 0 if it finished
    hr = m_pComponentDataImpl->m_pPrshtProvider->Show ((LONG_PTR)hWnd, 0);
    
#ifdef WIZ97WIZARDS
    m_bWiz97On = FALSE;
#endif
    
    // Pass prop sheet return code back to caller.
    return hr;
}

STDMETHODIMP CSecPolItem::OnDelete (LPARAM arg, LPARAM param)    // param == IResultData*
{
    HRESULT hr;
    
    // remove the item from the UI
    LPRESULTDATA pResultData = (LPRESULTDATA)param;
    hr = pResultData->DeleteItem( m_ResultItem.itemID, 0 );
    ASSERT(hr == S_OK);
    
    // need to check to see if WE are the current active policy
    
    PWIRELESS_POLICY_DATA pPolicy = GetWirelessPolicy();
    ASSERT(pPolicy);
    
    DWORD dwError = 0;
    
    //for machine policy, unassign the policy if the policy to delete is assigned
    //for domain policy, we cannot do much here because we have no idea about which group
    //units are using the policy
    hr = DeleteWirelessPolicy(m_pComponentDataImpl->GetPolicyStoreHandle(), pPolicy);
    
    if (FAILED(hr))
    {
        return hr;
    }

    GUID guidClientExt = CLSID_WIRELESSClientEx;
    GUID guidSnapin = CLSID_Snapin;

    m_pComponentDataImpl->UseGPEInformationInterface()->PolicyChanged (
        TRUE,
        FALSE,
        &guidClientExt,
        &guidSnapin
        );
    
    // Remove the item from the result list
    //m_pComponentDataImpl->GetStaticScopeObject()->RemoveResultItem( (LPDATAOBJECT)this );
    
    // do a refresh of all views, we pass in the scope item to refresh all
    m_pComponentDataImpl->GetConsole()->UpdateAllViews( m_pComponentDataImpl->GetStaticScopeObject(), 0, 0 );
    
    // TODO: return value from OnDelete is wrong
    return S_OK;
}

STDMETHODIMP CSecPolItem::OnPropertyChange(LPARAM lParam, LPCONSOLE pConsole )
{
    // call base class
    return CWirelessSnapInDataObjectImpl<CSecPolItem>::OnPropertyChange( lParam, pConsole );
}

STDMETHODIMP CSecPolItem::OnRename( LPARAM arg, LPARAM param )
{
    DWORD dwError = 0;
    
    // TODO: what are the valid args for MMCN_RENAME?
    if (arg == 0)
        return S_OK;
    
    LPOLESTR pszNewName = reinterpret_cast<LPOLESTR>(param);
    if (pszNewName == NULL)
        return E_INVALIDARG;
    
    CString strTemp = pszNewName;
    
    strTemp.TrimLeft();
    strTemp.TrimRight();
    
    if (strTemp.IsEmpty())
    {
        return S_FALSE;
    }
    
    
    HRESULT hr = S_FALSE;
    PWIRELESS_POLICY_DATA pPolicy = GetWirelessPolicy();
    
    if (pPolicy)
    {

          if (pPolicy->pszOldWirelessName)
            FreePolStr(pPolicy->pszOldWirelessName);
          
        if (pPolicy->pszWirelessName) {
            pPolicy->pszOldWirelessName = pPolicy->pszWirelessName;
        	}
        pPolicy->pszWirelessName = AllocPolStr(strTemp);
        
        if (NULL == pPolicy->pszWirelessName)
        {
            CThemeContextActivator activator;
            CString strMsg;
            strMsg.LoadString(IDS_ERR_OUTOFMEMORY);
            AfxMessageBox(strMsg);
            return S_FALSE;
        }
        
        dwError = WirelessSetPolicyData(
            m_pComponentDataImpl->GetPolicyStoreHandle(),
            pPolicy
            );
        if (ERROR_SUCCESS != dwError)
        {
            ReportError(IDS_SAVE_ERROR, HRESULT_FROM_WIN32(dwError));
            return S_FALSE;
        }

        GUID guidClientExt = CLSID_WIRELESSClientEx;
        GUID guidSnapin = CLSID_Snapin;
            
        m_pComponentDataImpl->UseGPEInformationInterface()->PolicyChanged (
            TRUE,
            TRUE,
            &guidClientExt,
            &guidSnapin
             );
            
    }
    
    return S_OK;
}
////////////////////////////////////////////////////////////////////////////////
//
// Function: OnSelect
// Description:
//      On MMCN_SELECT determine which result item has been selected and
//      remember it so we can ensure it remains selected when its property
//      sheet (with General and SecPol pages) is dismissed.
//
HRESULT CSecPolItem::OnSelect(LPARAM arg, LPARAM param, IResultData *pResultData )
{
    HRESULT hr = S_OK;
    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelected = (BOOL) HIWORD(arg);
    
    if (!bScope)
    {
        if (bSelected)
        {
            // A result item was selected, save its index.
            RESULTDATAITEM rdi;
            ZeroMemory( &rdi, sizeof( RESULTDATAITEM ) );
            rdi.mask = RDI_STATE | RDI_INDEX;
            m_nResultSelected = -1;
            do
            {
                hr = pResultData->GetItem( &rdi );
                if (hr == S_OK)
                {
                    if (!rdi.bScopeItem &&
                        rdi.nState & LVIS_FOCUSED && rdi.nState & LVIS_SELECTED)
                    {
                        OPT_TRACE( _T("CComponentImpl::OnSelect GetItem index-%i ID-%i\n"), rdi.nIndex, rdi.itemID );
                        m_nResultSelected = rdi.nIndex;
                        ASSERT( -1 != m_nResultSelected );
                        break;
                    }
                    rdi.nIndex++;
                    rdi.nState = 0;
                }
            } while ((S_OK == hr) && (rdi.nIndex >= 0));
        }
    }
    else
        // A scope item was selected
        m_nResultSelected = -1;
    return hr;
}

// Function: SelectResult
// Description:
//      Select the result item indexed by m_nResultSelected when the index
//      is valid (0, or greater)
//
void CSecPolItem::SelectResult( IResultData *pResultData )
{
    if (-1 == m_nResultSelected)
        return;
    
    HRESULT hr = pResultData->ModifyItemState( m_nResultSelected,
        (HRESULTITEM)0, LVIS_FOCUSED | LVIS_SELECTED, 0 );
    // This fails if a property sheet is being displayed.
    //ASSERT( S_OK == hr );
}

// Function: CheckForEnabled
// Description:
//      Checks GetPolicy() policy to see if it is enabled given the current
//      storage location. Returns FALSE if the storage location doesn't support
//      Enabled/Disabled
BOOL CSecPolItem::CheckForEnabled ()
{
    BOOL bRetVal = FALSE;
    HRESULT hr = S_OK;
    WCHAR szMachinePath[256];
    WCHAR szPolicyDN[256];
    BSTR pszCurrentDN = NULL;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    HANDLE hLocalPolicyStore = NULL;
    WCHAR szPathName[MAX_PATH];
    DWORD dwError = 0;
    
    
    // if we are an extension snapin then look to the GPE we are extending, otherwise
    // use the normal storage location
    // NOTE: we also check to make sure we are talking to the global store
    // because we don't want to use the GPO object settings in anything but the
    // DS case
    
    
    
    pWirelessPolicyData = GetWirelessPolicy();
    
    szPolicyDN[0] = L'\0';
    szPathName[0] = L'\0';
    
    if ( m_pComponentDataImpl->IsRsop() )
    {
        if ( pWirelessPolicyData->pRsopInfo && pWirelessPolicyData->pRsopInfo->uiPrecedence == 1 )
        {
            bRetVal = TRUE;
            return bRetVal;
        }
    }
        
        return bRetVal;
}


////////////////////////////////////////////////////////////////////////////////
// IExtendControlbar helpers

STDMETHODIMP_(BOOL) CSecPolItem::UpdateToolbarButton
(
 UINT id,                // button ID
 BOOL bSnapObjSelected,  // ==TRUE when result/scope item is selected
 BYTE fsState    // enable/disable this button state by returning TRUE/FALSE
 )
{
    BOOL bActive = FALSE;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    HANDLE hLocalPolicyStore = NULL;
    STORAGE_LOCATION eStgLocation = m_pComponentDataImpl->EnumLocation();
    
    
    pWirelessPolicyData = GetWirelessPolicy();
    
    bActive = CheckForEnabled();
    
    // Handle only the enable/disable state
    if (ENABLED == fsState)
    {
        // Our toolbar has only two items
        if (IDM_ASSIGN == id || IDM_UNASSIGN == id)
        {
            
            // The toolbar items should be enabled only if we are pointed to the local machine
            if (LOCATION_REMOTE == eStgLocation || LOCATION_LOCAL == eStgLocation
                // extension snapin?
                || (LOCATION_GLOBAL == eStgLocation && (NULL != m_pComponentDataImpl->GetStaticScopeObject()->GetExtScopeObject())))
            {
                // Disable the SetActive button when policy is already active
                if (IDM_ASSIGN == id)
                {
                    if (bActive)
                        return FALSE;
                    else
                        return TRUE;
                }
                // Disable the SetInactive button when policy is already inactive
                else if (IDM_UNASSIGN == id)
                {
                    if (!bActive)
                        return FALSE;
                    else
                        return TRUE;
                }
            }
            else
            {
                // Disable both the SetActive and SetInactive buttons for DS based snap-in
                return FALSE;
            }
        }
    }
    
    return FALSE;
}



DWORD
ComputePolicyDN(
                LPWSTR pszDirDomainName,
                GUID PolicyIdentifier,
                LPWSTR pszPolicyDN
                )
{
    DWORD dwError = 0;
    LPWSTR pszPolicyIdentifier = NULL;
    
    
    if (!pszDirDomainName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    dwError = StringFromCLSID(
        PolicyIdentifier,
        &pszPolicyIdentifier
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    wcscpy(pszPolicyDN,L"cn=msieee80211-Policy");
    wcscat(pszPolicyDN,pszPolicyIdentifier);
    wcscat(pszPolicyDN,L",cn=Wireless Policy,cn=System,");
    wcscat(pszPolicyDN, pszDirDomainName);
    
error:
    
    if (pszPolicyIdentifier) {
        CoTaskMemFree(pszPolicyIdentifier);
    }
    
    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\spolitem.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:      spolitem.h
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#ifndef _SPOLITEM_H
#define _SPOLITEM_H

// generic column headers
#define COL_NAME 0
#define COL_DESCRIPTION 1
#define COL_ACTIVE 2
#define COL_LAST_MODIFIED 3

//for rsop case
#define COL_GPONAME        2
#define COL_PRECEDENCE     3
#define COL_OU             4




class CSecPolItem :
public CWirelessSnapInDataObjectImpl <CSecPolItem>,
public CDataObjectImpl <CSecPolItem>,
public CComObjectRoot,
public CSnapObject
{
    // ATL Maps
    DECLARE_NOT_AGGREGATABLE(CSecPolItem)
        BEGIN_COM_MAP(CSecPolItem)
        COM_INTERFACE_ENTRY(IDataObject)
        COM_INTERFACE_ENTRY(IWirelessSnapInDataObject)
        END_COM_MAP()
        
public:
    CSecPolItem ();
    virtual ~CSecPolItem ();
    
    virtual void Initialize (WIRELESS_POLICY_DATA *pPolicy,CComponentDataImpl* pComponentDataImpl,CComponentImpl* pComponentImpl, BOOL bTemporaryDSObject);
    
public:
    ////////////////////////////////////////////////////////////////
    // IWirelessSnapInDataObject interface
    // handle IExtendContextMenu
    STDMETHOD(AddMenuItems)( LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed );
    STDMETHOD(Command)( long lCommandID,
        IConsoleNameSpace *pNameSpace );
    // handle IExtendPropertySheet
    STDMETHOD(CreatePropertyPages)( LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle );
    STDMETHOD(QueryPagesFor)( void );
    // Notify helper
    STDMETHOD(OnPropertyChange)(LPARAM lParam, LPCONSOLE pConsole );
    STDMETHOD(OnRename)( LPARAM arg, LPARAM param );
    // Destroy helper
    STDMETHOD(Destroy)( void );
    // handle IComponent and IComponentData
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
        BOOL bComponentData,
        IConsole *pConsole,
        IHeaderCtrl *pHeader );
    // IComponent Notify() helpers
    STDMETHOD(OnDelete)(LPARAM arg, LPARAM param );     // param == IResultData*
    // handle IComponent
    STDMETHOD(GetResultDisplayInfo)( RESULTDATAITEM *pResultDataItem );
    // IWirelessSnapInData
    STDMETHOD(GetResultData)( RESULTDATAITEM **ppResultDataItem );
    STDMETHOD(GetGuidForCompare)( GUID *pGuid );
    STDMETHOD(AdjustVerbState)(LPCONSOLEVERB pConsoleVerb);
    STDMETHOD(DoPropertyChangeHook)( void );
    ////////////////////////////////////////////////////////////////
    
public:
    STDMETHOD_(const GUID*, GetDataObjectTypeGuid)() { return &cObjectTypeSecPolRes; }
    STDMETHOD_(const wchar_t*, GetDataStringObjectTypeGuid)() { return cszObjectTypeSecPolRes; }
    BOOL IsSelected() { return -1 != m_nResultSelected ? TRUE : FALSE; }
    
    // Property page helpers
    STDMETHOD(DisplaySecPolProperties)(CString strTitle, BOOL bWiz97On = TRUE);
    
    // IExtendControlbar helpers
public:
    STDMETHOD_(BOOL, UpdateToolbarButton)
        (
        UINT id,        // button ID
        BOOL bSnapObjSelected,  // ==TRUE when result/scope item is selected
        BYTE fsState    // enable/disable this button state by returning TRUE/FALSE
        );
    
    BEGIN_SNAPINTOOLBARID_MAP(CSecPolItem)
        SNAPINTOOLBARID_ENTRY(IDR_TOOLBAR_SECPOL_RESULT)
        END_SNAPINTOOLBARID_MAP(CSecPolItem)
        
        // Note: The following IDM_* have been defined in resource.h because they
        // are potential candidates for toolbar buttons.  The value assigned to
        // each IDM_* is the value of the related IDS_MENUDESCRIPTION_* string ID.
        /*
        enum
        {
        // Identifiers for each of the commands/views to be inserted into the context menu.
        IDM_SETACTIVE,
        IDM_TASKSETACTIVE
        };
        */
        
        // Notify event handlers
        HRESULT OnSelect(LPARAM arg, LPARAM param, IResultData *pResultData);
    BOOL CheckForEnabled ();
    HRESULT FormatTime(time_t t, CString & str);
    
public:
    // accessor functions
    virtual WIRELESS_POLICY_DATA* GetWirelessPolicy () {return m_pPolicy;};
    virtual void SetNewName( LPCTSTR pszName ) { m_strNewName = pszName; }
    virtual LPCTSTR GetNewName() { return (LPCTSTR)m_strNewName; }
    LPRESULTDATAITEM GetResultItem() { return &m_ResultItem; }
    
    STDMETHODIMP VerifyStorageConnection()
    {
        return S_OK;
    }
    
protected:
    // helper functions
    void SelectResult( IResultData *pResultData );
     
    
private:
    TCHAR*  m_pDisplayInfo;
    int m_nResultSelected;  // > -1 when valid index of selected result item
    BOOL    m_bWiz97On;
    // user changed the name, it needs to be displayed, but its not committed yet. store it here.
    CString m_strNewName;
    RESULTDATAITEM m_ResultItem;
    bool    m_bBlockDSDelete;
    
    //Bug297890, this flag is used to AdjustVerbState() to modify the context menu
    BOOL    m_bItemSelected;
    
    PWIRELESS_POLICY_DATA m_pPolicy;
    BOOL m_bNewPol;
    
    HRESULT IsPolicyExist();
};


typedef CComObject<CSecPolItem>* LPCSECPOLITEM;
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\sprpage.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       sprpage.cpp
//
//  Contents:  WiF Policy Snapin: Policy Description/ Manager Page.
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------
#include "stdafx.h"

#include "sprpage.h"
#include "nfaa.h"
#include "ssidpage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef CTypedPtrList<CPtrList, PWIRELESS_PS_DATA> CSNPPSList;

/////////////////////////////////////////////////////////////////////////////
// CSecPolRulesPage property page

const TCHAR CSecPolRulesPage::STICKY_SETTING_USE_SEC_POLICY_WIZARD[] = _T("UseSecPolicyWizard");

IMPLEMENT_DYNCREATE(CSecPolRulesPage, CSnapinPropPage)
//Taroon:: Big change here.. check if it is correct
CSecPolRulesPage::CSecPolRulesPage() : CSnapinPropPage(CSecPolRulesPage::IDD,FALSE)
{
    //{{AFX_DATA_INIT(CSecPolRulesPage)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    
    m_iSortSubItem = 0;
    m_bSortOrder = TRUE;
    m_MMCthreadID = ::GetCurrentThreadId();
    m_pPrpSh = NULL;
    
    m_bHasWarnedPSCorruption = FALSE;
    m_currentWirelessPolicyData = NULL;
    m_bReadOnly = FALSE;
}

CSecPolRulesPage::~CSecPolRulesPage()
{
    
}

void CSecPolRulesPage::DoDataExchange(CDataExchange* pDX)
{
    CSnapinPropPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSecPolRulesPage)
    DDX_Control(pDX, IDC_PS_LIST, m_lstActions);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSecPolRulesPage, CSnapinPropPage)
//{{AFX_MSG_MAP(CSecPolRulesPage)
ON_BN_CLICKED(IDC_ACTION_PS_ADD, OnActionAdd)
ON_BN_CLICKED(IDC_ACTION_PS_EDIT, OnActionEdit)
ON_BN_CLICKED(IDC_ACTION_PS_REMOVE, OnActionRemove)
ON_BN_CLICKED(IDC_PS_UP, OnActionUp)
ON_BN_CLICKED(IDC_PS_DOWN,OnActionDown)
ON_NOTIFY(NM_DBLCLK, IDC_PS_LIST, OnDblclkActionslist)
//ON_NOTIFY(LVN_COLUMNCLICK, IDC_ACTIONSLIST, OnColumnclickActionslist)
//ON_NOTIFY(NM_CLICK, IDC_ACTIONSLIST, OnClickActionslist)
ON_WM_HELPINFO()
ON_NOTIFY(LVN_ITEMCHANGED, IDC_PS_LIST, OnItemchangedActionslist)
ON_NOTIFY(LVN_KEYDOWN, IDC_PS_LIST, OnKeydownActionslist)
ON_WM_DESTROY()
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSecPolRulesPage message handlers

BOOL CSecPolRulesPage::OnApply()
{
    //if there is any sub dialog active, we cannot apply
    if (m_pPrpSh)
    {
        return FALSE;
    }
    
    // the rules page doesn't actually have any data on it that
    // the user might modify and then apply. in fact all changes
    // from this page actually happen directly on the dsObjects
    
    if( ERROR_SUCCESS != UpdateWlstore()) {
        PopulateListControl();
        return FALSE;
    }

    if (!m_bReadOnly) {
    
        PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    
        pWirelessPolicyData = GetResultObject()->GetWirelessPolicy();
    
        UpdateWirelessPolicyDataWithPreferredSettings(
            pWirelessPolicyData,
            m_currentWirelessPolicyData
            );
    }
    
    return CSnapinPropPage::OnApply();
}

HRESULT CSecPolRulesPage::UpdateWlstore()
{
    HRESULT hr = S_OK;
    
    HANDLE hPolicyStore = NULL;
    SNP_PS_LIST::iterator theIterator;
    BOOL dwModified = FALSE;
    CComObject<CSecPolItem>*  pResultItem = NULL;
    PWIRELESS_POLICY_DATA  pWirelessPolicyData;
    
    pResultItem = GetResultObject();
    hPolicyStore = pResultItem->m_pComponentDataImpl->GetPolicyStoreHandle();
    ASSERT(hPolicyStore);
    
    
    pWirelessPolicyData = pResultItem->GetWirelessPolicy();
    
    for(theIterator = m_NfaList.begin(); theIterator != m_NfaList.end(); theIterator++)
    {
        PSNP_PS_DATA pNfaData = (PSNP_PS_DATA) (*theIterator);
        PWIRELESS_PS_DATA pBWirelessPSData = pNfaData->pWirelessPSData;
        
        
        
        switch(pNfaData->status)
        {
        case NEW:
            {
                break;
            }
            
        case MODIFIED:
            {
                break;
            }
            
        case BEREMOVED:
            {
                break;
            }
        }//switch
    }//for
    
    
    
    
    return hr;
}

void CSecPolRulesPage::OnCancel()
{
    //WirelessFreePolicyData(m_currentWirelessPolicyData);
    CSnapinPropPage::OnCancel();
}

BOOL CSecPolRulesPage::OnInitDialog()
{
    CSnapinPropPage::OnInitDialog();
    
    DWORD dwError = 0;
    
    m_pPrpSh = NULL;
    
    // set headers on the list control
    m_lstActions.InsertColumn(0,ResourcedString(IDS_COLUMN_SSIDNAME), LVCFMT_CENTER, 120, 0);
    m_lstActions.InsertColumn(1,ResourcedString(IDS_COLUMN_AUTHMETHOD), LVCFMT_CENTER, 80, 1);
    m_lstActions.InsertColumn(2,ResourcedString(IDS_COLUMN_PRIVACY), LVCFMT_CENTER, 80, 2);
    //m_lstActions.InsertColumn(3,ResourcedString(IDS_COLUMN_ADAPTERTYPE), LVCFMT_LEFT, 90, 3);
    
    // set the image list
    CThemeContextActivator activator;
    m_imagelistChecks.Create(IDB_PSTYPE, 16, 1, RGB(0,255,0));
    // m_lstActions.SetImageList (&m_imagelistChecks, LVSIL_STATE);
    m_lstActions.SetImageList (CImageList::FromHandle(m_imagelistChecks), LVSIL_SMALL);
    
    // turn on entire row selection
    ListView_SetExtendedListViewStyle (m_lstActions.GetSafeHwnd(), LVS_EX_FULLROWSELECT);
    
    // Copy the Policy Data to the m_currentWirelessPolicyData
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    pWirelessPolicyData = GetResultObject()->GetWirelessPolicy();
    
    dwError = CopyWirelessPolicyData(
        pWirelessPolicyData, 
        &m_currentWirelessPolicyData
        );
    if(dwError) {
        ReportError(IDS_DISPLAY_ERROR, 0);
        BAIL_ON_WIN32_ERROR(dwError);
    }
    if (pWirelessPolicyData->dwFlags & WLSTORE_READONLY) {
        m_bReadOnly = TRUE;
    }
    
    if (m_bReadOnly) {
        DisableControls();
    }
    
    //store the rules data in m_NfaList linked list
    InitialzeNfaList();  //taroonm
    
    // fill the list control with the current PSs
    PopulateListControl();  //taroonm
    
    
    // Select the first list item
    if (m_lstActions.GetItemCount())
    {
        m_lstActions.SetItemState( 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
        EnableDisableButtons ();
    }
    
    // OK, we can start paying attention to modifications made via dlg controls now.
    // This should be the last call before returning from OnInitDialog.
    OnFinishInitDialog();
    
    return TRUE;  // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE
    
error:
    return(FALSE);
    
}



void CSecPolRulesPage::InitialzeNfaList()
{
    HRESULT hr;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    PWIRELESS_PS_DATA * ppWirelessPSData = NULL;
    PWIRELESS_PS_DATA pAWirelessPSData = NULL;
    DWORD i = 0;
    HANDLE hPolicyStore = NULL;
    DWORD dwNumPSObjects = 0;
    CComObject<CSecPolItem>*  pResultItem = NULL;
    DWORD dwError = 0;
    
    
    
    SNP_PS_LIST::iterator theIterator;
    PWIRELESS_PS_DATA pWirelessPSData = NULL;
    PSNP_PS_DATA pNfaData = NULL;
    
    // Unselect Everything First
    SELECT_NO_LISTITEM( m_lstActions );
    
    //empty the previous List 
    if (!m_NfaList.empty()) {
        for(theIterator = m_NfaList.begin();theIterator != m_NfaList.end(); ++theIterator) {
            pNfaData =  (PSNP_PS_DATA)(*theIterator);
            pWirelessPSData  = pNfaData->pWirelessPSData;
            FreeWirelessPSData(pWirelessPSData);
            LocalFree(pNfaData);
        }
    }
    m_NfaList.clear();
    
    pWirelessPolicyData = m_currentWirelessPolicyData;
    
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    dwNumPSObjects = pWirelessPolicyData->dwNumPreferredSettings;
    
    
    
    for (i = 0; i < dwNumPSObjects; i++) {
        DWORD dwErrorTmp = ERROR_SUCCESS;
        
        pAWirelessPSData = *(ppWirelessPSData + i);
        
        PSNP_PS_DATA pNfaData = NULL;
        
        pNfaData = (PSNP_PS_DATA) LocalAlloc(LMEM_ZEROINIT, sizeof(SNP_PS_DATA));
        if(pNfaData == NULL) {
            goto error;
        }
        pNfaData->status = NOTMODIFIED; //taroonm
        dwError = CopyWirelessPSData(pAWirelessPSData,&pNfaData->pWirelessPSData);
        BAIL_ON_WIN32_ERROR(dwError);
        
        
        m_NfaList.push_back(pNfaData);
        
    }//for
    
    return;
    
error:
    //
    // BugBug KrishnaG cleanup
    //
    // Taroon:: TODO Deallocate the m_nfa list here and report Error 
    ReportError(IDS_DISPLAY_ERROR, HRESULT_FROM_WIN32(dwError));
    
    return;
    
}


void CSecPolRulesPage::UnPopulateListControl ()
{
    int nIndex=0;
    
    // Make sure no items are selected so EnableDisableButtons doesn't do
    // so much work when its called by the LVN_ITEMCHANGED handler. (_DEBUG only)
    SELECT_NO_LISTITEM( m_lstActions );
    
    m_lstActions.DeleteAllItems();
    
}

CString CSecPolRulesPage::GetColumnStrBuffer (PWIRELESS_PS_DATA pWirelessPSData, int iColumn)
{
    CString strBuffer;
    
    HANDLE hPolicyStore = NULL;
    GUID ZeroGuid;
    DWORD dwError = 0;
    BOOL bInitial = TRUE;
    
    
    CComObject<CSecPolItem>*  pResultItem = NULL;
    
    
    pResultItem = GetResultObject();
    hPolicyStore = pResultItem->m_pComponentDataImpl->GetPolicyStoreHandle();
    
    
    switch (iColumn)
    {
    case 0:
        
        strBuffer = pWirelessPSData->pszWirelessSSID;
        break;
    case 1:
        if (pWirelessPSData->dwEnable8021x) {
            strBuffer.LoadString (IDS_8021X_ENABLED);
        } else {
            strBuffer.LoadString (IDS_8021X_DISABLED);
        }
        break;
        
    case 2:
        if (pWirelessPSData->dwWepEnabled) {
            strBuffer.LoadString (IDS_WEP_ENABLED);
        } else {
            strBuffer.LoadString (IDS_WEP_DISABLED);
        }
        break;
        
        
    default:
        ASSERT (0);
        strBuffer.LoadString (IDS_DATAERROR);
        break;
    }
    
    return strBuffer;
}


void CSecPolRulesPage::PopulateListControl()
{
    HRESULT hr = S_OK;
    PSNP_PS_DATA pNfaData;
    PWIRELESS_PS_DATA pWirelessPSData = NULL;
    
    LV_ITEM item;
    CString strBuffer;
    int nItem = 0;
    int nSubItem = 0;
    
    
    SNP_PS_LIST::reverse_iterator theIterator;
    
    
    // clear out the list control
    UnPopulateListControl();
    
    
    for (theIterator = m_NfaList.rbegin(); theIterator != m_NfaList.rend();
    theIterator++)
    {
        pNfaData =  (PSNP_PS_DATA)(*theIterator);
        pWirelessPSData = pNfaData->pWirelessPSData;
        
        if( pNfaData->status == BEREMOVED || pNfaData->status == REMOVED || pNfaData->status == NEWREMOVED ) {
            continue;
        }
        
        item.mask = LVIF_TEXT | LVIF_IMAGE;
        // item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
        item.iItem = nItem;
        nSubItem = 0;
        
        // Set the Network type
        if (pWirelessPSData->dwNetworkType == WIRELESS_NETWORK_TYPE_ADHOC) {
            item.iImage = 5;
        }
        if (pWirelessPSData->dwNetworkType == WIRELESS_NETWORK_TYPE_AP) {
            item.iImage = 3;
        }
        
        
        // "Wireless SSID"
        item.iSubItem = nSubItem++;
        strBuffer = GetColumnStrBuffer (pWirelessPSData, 0);
        item.pszText = strBuffer.GetBuffer(32);
        item.iItem = m_lstActions.InsertItem (&item);
        
        // "Negotiation Policy
        item.iSubItem = nSubItem++;
        strBuffer = GetColumnStrBuffer (pWirelessPSData, 1);
        item.pszText = strBuffer.GetBuffer(20);
        m_lstActions.SetItem (&item);
        
        // "Authentication Method"
        item.iSubItem = nSubItem++;
        strBuffer = GetColumnStrBuffer (pWirelessPSData, 2);
        item.pszText = strBuffer.GetBuffer(20);
        m_lstActions.SetItem (&item);
        
        
        // store the pWirelessPSData
        ASSERT (pWirelessPSData);
        VERIFY( m_lstActions.SetItemData(item.iItem, (DWORD_PTR)pNfaData) );
    }
    
    
    
    EnableDisableButtons ();
}



void CSecPolRulesPage::HandleSideEffectApply()
{
    // make sure we are marked as modified
    SetModified();
    
    // The Add has been committed, canceling it is no longer possible.
    // Disable the cancel button
    CancelToClose();
}

int CSecPolRulesPage::DisplayPSProperties (
                                           //PWIRELESS_PS_DATA pBWirelessPSData,
                                           PSNP_PS_DATA pNfaData,
                                           CString strTitle,
                                           BOOL bDoingAdd,
                                           BOOL* pbAfterWizardHook
                                           )
{
    HANDLE hPolicyStore = NULL;
    DWORD dwError = 0;
    GUID PolicyIdentifier;
    
    PWIRELESS_PS_DATA pBWirelessPSData = pNfaData->pWirelessPSData;
    CComObject<CSecPolItem>*  pResultItem = NULL;
    
    PWIRELESS_POLICY_DATA pWirelessPolicy = NULL;
    
    int nReturn = 0;
    
    pResultItem = GetResultObject();
    hPolicyStore = pResultItem->m_pComponentDataImpl->GetPolicyStoreHandle();
    
    pWirelessPolicy = m_currentWirelessPolicyData;
    PolicyIdentifier = pWirelessPolicy->PolicyIdentifier;
    
    CSingleLock cLock(&m_csDlg);
    
    
    CComPtr<CPSPropSheetManager> spPropshtManager =
        new CComObject<CPSPropSheetManager>;
    if (NULL == spPropshtManager.p) {
        ReportError(IDS_OPERATION_FAIL, E_OUTOFMEMORY);
        return nReturn;
    }
    
    // load in the property pages
    CPS8021XPropPage     pageAdapter;
    CSSIDPage     pageSSID;
    //
    
    spPropshtManager->SetData(
        GetResultObject(), 
        pBWirelessPSData, 
        bDoingAdd
        );
    // theory is that if one fails, they all fail 
    pageAdapter.Initialize(pBWirelessPSData, GetResultObject()->m_pComponentDataImpl, pWirelessPolicy->dwFlags);
    pageSSID.Initialize(pBWirelessPSData, GetResultObject()->m_pComponentDataImpl, pWirelessPolicy);
    
    spPropshtManager->AddPage (&pageSSID);
    spPropshtManager->AddPage (&pageAdapter);
    
    spPropshtManager->GetSheet()->SetTitle (strTitle, PSH_PROPTITLE);
    
    
    m_pPrpSh = spPropshtManager->GetSheet();
    m_pPrpSh->m_psh.dwFlags |= PSH_NOAPPLYNOW;
    
    
    // display the dialog
    nReturn = spPropshtManager->GetSheet()->DoModal();
    //nReturn = spPropshtManager->GetSheet()->Create();
    
    cLock.Lock();
    m_pPrpSh = NULL;
    cLock.Unlock();
    
    if (m_bReadOnly) {
        return nReturn;
    }
    
    if (spPropshtManager->HasEverApplied())
    {
        nReturn = IDOK;
    }
    return nReturn;
}

void CSecPolRulesPage::OnActionAdd()
{
    // handle the add on a different thread and then continue
    // this is to fix NT bug #203059 per MFC KB article ID Q177101
    GetParent()->EnableWindow (FALSE);
    AfxBeginThread((AFX_THREADPROC)DoThreadActionAdd, this);
}


void CSecPolRulesPage::OnActionUp()
{
    //Taroon: Todo Check this is needed or not and then remvoe
    //GetParent()->EnableWindow (FALSE);
    
    CComObject<CSecPolItem>*  pResultItem = NULL;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    //lower means lower indexed 
    PWIRELESS_PS_DATA pLowerWirelessPSData = NULL;
    PWIRELESS_PS_DATA pUpperWirelessPSData = NULL;
    
    // Only 1 item can be selected for move to be enabled
    ASSERT( m_lstActions.GetSelectedCount() == 1 );
    
    // ok, one of the PSs must be selected
    int nIndex = m_lstActions.GetNextItem(-1,LVNI_SELECTED);
    if (-1 == nIndex)
        return;
    
    PSNP_PS_DATA pUpperNfaData;
    
    
    pUpperNfaData = (PSNP_PS_DATA) m_lstActions.GetItemData(nIndex);
    pUpperWirelessPSData = pUpperNfaData->pWirelessPSData;
    
    
    pWirelessPolicyData = m_currentWirelessPolicyData;
    
    if (pWirelessPolicyData && pUpperWirelessPSData)
    {
        DWORD dwCurrentId;
        
        dwCurrentId = pUpperWirelessPSData->dwId;
        if (dwCurrentId != 0) { 
            
            WirelessPSMoveUp(pWirelessPolicyData,dwCurrentId);
            
            // update the m_nfaList as well.
            
            PSNP_PS_DATA pLowerNfaData = NULL;
            
            pLowerNfaData = m_NfaList[dwCurrentId-1];
            pLowerWirelessPSData = pLowerNfaData->pWirelessPSData;
            
            pLowerWirelessPSData->dwId = dwCurrentId;
            pUpperWirelessPSData->dwId = dwCurrentId-1;
            
            m_NfaList[dwCurrentId-1] = pUpperNfaData;
            m_NfaList[dwCurrentId] = pLowerNfaData;
            PopulateListControl ();
            SetModified();
            
            m_lstActions.SetItemState( dwCurrentId-1, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
            
            
        }
        
        
    }
    
}



void CSecPolRulesPage::OnActionDown()
{
    //Taroon: Todo Check this is needed or not and then remvoe
    //GetParent()->EnableWindow (FALSE);
    
    CComObject<CSecPolItem>*  pResultItem = NULL;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    //lower means lower indexed 
    PWIRELESS_PS_DATA pLowerWirelessPSData = NULL;
    PWIRELESS_PS_DATA pUpperWirelessPSData = NULL;
    DWORD dwTotalItems = 0;
    
    // Only 1 item can be selected for move to be enabled
    ASSERT( m_lstActions.GetSelectedCount() == 1 );
    
    // ok, one of the PSs must be selected
    int nIndex = m_lstActions.GetNextItem(-1,LVNI_SELECTED);
    if (-1 == nIndex)
        return;
    
    PSNP_PS_DATA pLowerNfaData;
    
    
    pLowerNfaData = (PSNP_PS_DATA) m_lstActions.GetItemData(nIndex);
    pLowerWirelessPSData = pLowerNfaData->pWirelessPSData;
    
    pWirelessPolicyData = m_currentWirelessPolicyData;
    
    dwTotalItems = pWirelessPolicyData->dwNumPreferredSettings;
    
    
    if (pWirelessPolicyData && pLowerWirelessPSData)
    {
        DWORD dwCurrentId;
        
        dwCurrentId = pLowerWirelessPSData->dwId;
        if (dwCurrentId <  dwTotalItems -1) { 
            
            WirelessPSMoveDown(pWirelessPolicyData,dwCurrentId);
            
            // update the m_nfaList as well.
            
            PSNP_PS_DATA pUpperNfaData = NULL;
            
            pUpperNfaData = m_NfaList[dwCurrentId + 1];
            pUpperWirelessPSData = pUpperNfaData->pWirelessPSData;
            
            pLowerWirelessPSData->dwId = dwCurrentId +1;
            pUpperWirelessPSData->dwId = dwCurrentId;
            
            m_NfaList[dwCurrentId+1] = pLowerNfaData;
            m_NfaList[dwCurrentId] = pUpperNfaData;
            PopulateListControl ();
            SetModified();
            
            m_lstActions.SetItemState( dwCurrentId+1, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
            
            
        }
        
        
    }
    
}


UINT AFX_CDECL CSecPolRulesPage::DoThreadActionAdd(LPVOID pParam)
{
    CSecPolRulesPage* pObject = (CSecPolRulesPage*)pParam;
    
    if (pObject == NULL ||
        !pObject->IsKindOf(RUNTIME_CLASS(CSecPolRulesPage)))
        return -1;    // illegal parameter
    
    DWORD dwDlgRuleThreadId = GetCurrentThreadId();
    
    AttachThreadInput(dwDlgRuleThreadId, pObject->m_MMCthreadID, TRUE);
    
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;
    
    // call back to the objects ActionAdd handler
    pObject->OnThreadSafeActionAdd();
    pObject->GetParent()->EnableWindow (TRUE);
    
    pObject->GetParent()->SetFocus ();
    
    CoUninitialize();
    
    AttachThreadInput(dwDlgRuleThreadId, pObject->m_MMCthreadID, FALSE);
    
    return 0;
}

void CSecPolRulesPage::OnThreadSafeActionAdd()
{
    DWORD dwError = 0;
    BOOL bDisplayProperties = FALSE;
    PWIRELESS_PS_DATA pWirelessPSData = NULL;
    PSNP_PS_DATA pNfaData = NULL;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    PWIRELESS_PS_DATA pNewWirelessPSData = NULL;
    
    pNfaData = (PSNP_PS_DATA) LocalAlloc(LMEM_ZEROINIT, sizeof(SNP_PS_DATA));
    if(pNfaData == NULL) {
        ReportError(IDS_OPERATION_FAIL, E_OUTOFMEMORY);
        return;
    }
    
    
    //
    // Create the WIRELESS_PS Object
    //
    //
    //
    
    pWirelessPSData = (PWIRELESS_PS_DATA) AllocPolMem(sizeof(WIRELESS_PS_DATA));
    
    if(pWirelessPSData == NULL) {
        ReportError(IDS_OPERATION_FAIL, E_OUTOFMEMORY);
        return;
    }
    
    
    pNfaData->status = NEW;
    pNfaData->pWirelessPSData = pWirelessPSData;
    
    CString pszNewSSID;
    CString pszSampleDescription;

    pszSampleDescription.LoadString(IDS_SAMPLE_DESCRIPTION);
    
    // Initialize the PWIRELESS_PS_DATA 
    //
    //
    GenerateUniquePSName(IDS_NEW_PS_NAME,pszNewSSID);
    SSIDDupString(pWirelessPSData->pszWirelessSSID, pszNewSSID);
    pWirelessPSData->dwWirelessSSIDLen = 
        lstrlenW(pWirelessPSData->pszWirelessSSID);
    pWirelessPSData->dwWepEnabled = 1;
    pWirelessPSData->dwNetworkAuthentication = 0;
    pWirelessPSData->dwAutomaticKeyProvision = 1;
    pWirelessPSData->dwNetworkType = WIRELESS_NETWORK_TYPE_AP;
    pWirelessPSData->dwEnable8021x = 1;
    pWirelessPSData->dw8021xMode = 
        WIRELESS_8021X_MODE_NAS_TRANSMIT_EAPOLSTART_WIRED;
    pWirelessPSData->dwEapType = WIRELESS_EAP_TYPE_TLS;
    pWirelessPSData->dwEAPDataLen = 0;
    pWirelessPSData->pbEAPData = NULL;
    pWirelessPSData->dwMachineAuthentication = 1;
    pWirelessPSData->dwMachineAuthenticationType = WIRELESS_MC_AUTH_TYPE_USER_DONTCARE_MC;
    pWirelessPSData->dwGuestAuthentication = 0;
    pWirelessPSData->dwIEEE8021xMaxStart = 3;
    pWirelessPSData->dwIEEE8021xStartPeriod = 60;
    pWirelessPSData->dwIEEE8021xAuthPeriod = 30;       
    pWirelessPSData->dwIEEE8021xHeldPeriod = 60;
    pWirelessPSData->dwId = -1;
    pWirelessPSData->pszDescription = AllocPolStr(pszSampleDescription);
    pWirelessPSData->dwDescriptionLen = 2*lstrlenW(pWirelessPSData->pszDescription);
    
    UpdateWirelessPSData(pWirelessPSData);
    
    CString szNewPreferredSetting;
    szNewPreferredSetting.LoadString(IDS_NEW_PREFERRED_SETTING);
    
    // display the dialog
    int dlgRetVal = DisplayPSProperties (
        pNfaData,
        szNewPreferredSetting,
        TRUE,
        &bDisplayProperties
        );
    
    // IDOK in case we didn't use the wizard for some reason
    if ((dlgRetVal == ID_WIZFINISH) || (dlgRetVal == IDOK))
    {
        // turn on the wait cursor
        CWaitCursor waitCursor;
        
        //user added new nfa rule, update the m_NfaList
        
        
        UpdateWirelessPSData(pWirelessPSData);
        pWirelessPolicyData = m_currentWirelessPolicyData;
        dwError = CopyWirelessPSData(pWirelessPSData,&pNewWirelessPSData);
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = WirelessAddPSToPolicy(pWirelessPolicyData, pNewWirelessPSData);
        BAIL_ON_WIN32_ERROR(dwError);
        pWirelessPSData->dwId = pNewWirelessPSData->dwId;
        
        
        m_NfaList.push_back(pNfaData);
        
        DWORD dwSelection = -1;
        dwSelection = pWirelessPSData->dwId;
        
        InitialzeNfaList();
        PopulateListControl ();
        // Select the new item only
        SELECT_NO_LISTITEM( m_lstActions );
        
        m_lstActions.SetItemState( dwSelection, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
        
        //HandleSideEffectApply();
        SetModified();
    }
    else
    {
        
        if (pWirelessPSData) {
            FreeWirelessPSData(pWirelessPSData);
        }
        
        if (pNfaData) { 
            LocalFree(pNfaData);
        }
        
    }
    
    return;
    
error:
    ReportError(IDS_ADD_ERROR, HRESULT_FROM_WIN32(dwError));
    return;
}


void CSecPolRulesPage::OnActionEdit()
{
    // handle the add on a different thread and then continue
    // this is to fix NT bug #203059 per MFC KB article ID Q177101
    GetParent()->EnableWindow (FALSE);
    AfxBeginThread((AFX_THREADPROC)DoThreadActionEdit, this);
}

UINT AFX_CDECL CSecPolRulesPage::DoThreadActionEdit(LPVOID pParam)
{
    CSecPolRulesPage* pObject = (CSecPolRulesPage*)pParam;
    
    if (pObject == NULL ||
        !pObject->IsKindOf(RUNTIME_CLASS(CSecPolRulesPage)))
        return -1;    // illegal parameter
    
    DWORD dwDlgRuleThreadId = GetCurrentThreadId();
    
    AttachThreadInput(dwDlgRuleThreadId, pObject->m_MMCthreadID, TRUE);
    
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;
    
    // call back to the objects ActionAdd handler
    pObject->OnThreadSafeActionEdit();
    pObject->GetParent()->EnableWindow (TRUE);
    
    pObject->GetParent()->SetFocus ();
    
    CoUninitialize();
    
    AttachThreadInput(dwDlgRuleThreadId, pObject->m_MMCthreadID, FALSE);
    
    return 0;
}

void CSecPolRulesPage::OnThreadSafeActionEdit()
{
    // Only 1 item can be selected for Edit to be enabled
    ASSERT( m_lstActions.GetSelectedCount() == 1 );
    DWORD dwError = 0;
    
    // ok, one of the PSs must be selected
    int nIndex = m_lstActions.GetNextItem(-1,LVNI_SELECTED);
    if (-1 == nIndex)
        return;
    
    PSNP_PS_DATA pNfaData;
    PWIRELESS_PS_DATA pBWirelessPSData = NULL;
    
    pNfaData = (PSNP_PS_DATA) m_lstActions.GetItemData(nIndex);
    pBWirelessPSData = pNfaData->pWirelessPSData;
    
    // display the dialog
    if (pBWirelessPSData)
    {
        BOOL bHook = FALSE;
        DWORD dwError = 0;
        CString strTitle;
        
        strTitle.FormatMessage(IDS_EDIT_TITLE,pBWirelessPSData->pszWirelessSSID);
        if (DisplayPSProperties (pNfaData,strTitle, FALSE, &bHook) == IDOK)
        {
            if (!m_bReadOnly) {
                if( pNfaData->status != NEW )
                    pNfaData->status = MODIFIED;
                
                
                PWIRELESS_PS_DATA pWirelessPSData = NULL;
                PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
                DWORD dwCurrentId = 0;
                
                pWirelessPSData  = pNfaData->pWirelessPSData;
                /* Taroon:RemoveRight
                pWirelessPolicyData = GetResultObject()->GetWirelessPolicy();
                */
                pWirelessPolicyData = m_currentWirelessPolicyData;
                
                UpdateWirelessPSData(pWirelessPSData);
                
                dwError = WirelessSetPSDataInPolicyId(pWirelessPolicyData, pWirelessPSData);
                BAIL_ON_WIN32_ERROR(dwError);
                
                nIndex = pWirelessPSData->dwId;
                SetModified();
                InitialzeNfaList();
                
            }
            
        }
        
        // PopulateListControl can disable the edit button, save its handle so we
        // can reset the focus if this happens.
        HWND hWndCtrl = ::GetFocus();
        
        
        // always redraw the listbox, they might have managed filters or negpols even in a
        // 'cancel' situation and thus we need to accurately reflect the current state
        PopulateListControl ();
        
        // Select the edited item
        m_lstActions.SetItemState( nIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
        
        
        
        if (::GetFocus() == NULL)
            ::SetFocus( hWndCtrl );
        
    }
    
    return;
error:
    ReportError(IDS_SAVE_ERROR, HRESULT_FROM_WIN32(dwError));
    return;
}

void CSecPolRulesPage::OnActionRemove()
{
    // Something must be selected to do a remove
    if (-1 == m_lstActions.GetNextItem(-1,LVNI_SELECTED))
        return;
    
    // verify that they really want to do this
    if (AfxMessageBox (IDS_SUREYESNO, MB_YESNO | MB_DEFBUTTON2) != IDYES)
        return;
    
    HANDLE hPolicyStore = NULL;
    DWORD dwError = 0;
    
    hPolicyStore = GetResultObject()->m_pComponentDataImpl->GetPolicyStoreHandle();
    ASSERT(hPolicyStore);
    
    
    // need to make sure that none of the selected items are the non-deleteable
    int nIndex = -1;
    DWORD nDeleteIndex = -1;
    DWORD dwNumRemoved = 0;
    while (-1 != (nIndex = m_lstActions.GetNextItem( nIndex, LVNI_SELECTED )))
    {
        PSNP_PS_DATA pNfaData;
        pNfaData = (PSNP_PS_DATA) m_lstActions.GetItemData(nIndex);
        PWIRELESS_PS_DATA pBWirelessPSData = pNfaData->pWirelessPSData;
        
        if (pBWirelessPSData)
        {
            if( pNfaData->status != NEW )
                pNfaData->status = BEREMOVED;
            else
                pNfaData->status = NEWREMOVED;
            nDeleteIndex = nIndex;
        }
        
        PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
        PWIRELESS_PS_DATA pWirelessPSData = NULL;
        
        DWORD dwCurrentId = 0;
        //Remove the items right here from m_nfaList and Policy Object as well
        /* Taroon:RemoveRight 
        pWirelessPolicyData = GetResultObject()->GetWirelessPolicy();
        */
        pWirelessPolicyData = m_currentWirelessPolicyData;
        pWirelessPSData = pNfaData->pWirelessPSData;
        
        dwCurrentId = pWirelessPSData->dwId - dwNumRemoved;
        
        dwError = WirelessRemovePSFromPolicyId(pWirelessPolicyData,dwCurrentId);
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwNumRemoved++;
        
        
    }
    
    SELECT_NO_LISTITEM( m_lstActions );
    
    InitialzeNfaList();
    // Save the currently focused control, PopulateListControl disables some
    // controls so we may have to reset the focus if this happens.
    CWnd *pwndFocus = GetFocus();
    
    PopulateListControl ();
    
    // Select previous item in list only
    SELECT_NO_LISTITEM( m_lstActions );
    int nPrevSel = SELECT_PREV_LISTITEM( m_lstActions, nDeleteIndex );
    
    // Fix up button focus
    EnableDisableButtons();
    SetPostRemoveFocus( nPrevSel, IDC_ACTION_PS_ADD, IDC_ACTION_PS_REMOVE, pwndFocus );
    
    // If the currently selected item is non-deleteable, the Remove button is
    // now disabled.  Move the focus to the Add button for this case.
    if (!GetDlgItem( IDC_ACTION_PS_REMOVE)->IsWindowEnabled())
    {
        GotoDlgCtrl( GetDlgItem( IDC_ACTION_PS_ADD) );
    }
    
    
    SetModified();
    
    return;
    
error:
    ReportError(IDS_REMOVINGERROR, HRESULT_FROM_WIN32(dwError));
    return;
}



void CSecPolRulesPage::OnDblclkActionslist(NMHDR* pNMHDR, LRESULT* pResult)
{
    // ok, sounds like maybe they have clicked something in which case
    // we want to do an add
    switch (pNMHDR->code)
    {
    case NM_DBLCLK:
        {
            // we only want to do the edit if ONE item is selected
            if (m_lstActions.GetSelectedCount() == 1 )
            {
                OnActionEdit();
            }
            break;
        }
    default:
        break;
    }
    
    *pResult = 0;
}

void CSecPolRulesPage::EnableDisableButtons ()
{
    if (m_bReadOnly)
    {
        DisableControls();
        return;
    }
    
    // ok, one of the rules must be selected for the E/R buttons to be enabled
    if (-1 != m_lstActions.GetNextItem(-1,LVNI_SELECTED))
    {
        // Disable Edit button if multiple selection
        int nSelectionCount = m_lstActions.GetSelectedCount();
        
        // Edit is easy
        SAFE_ENABLEWINDOW (IDC_ACTION_PS_EDIT, (1 == nSelectionCount));
        
        // Enable Remove only if it all selected pols are removable type
        SAFE_ENABLEWINDOW (IDC_ACTION_PS_REMOVE, PSsRemovable());
        
        
        if(nSelectionCount == 1 ) {
            
            SAFE_ENABLEWINDOW(IDC_PS_UP, TRUE);
            SAFE_ENABLEWINDOW(IDC_PS_DOWN, TRUE);
            
            // ok, one of the PSs must be selected
            int nIndex = m_lstActions.GetNextItem(-1,LVNI_SELECTED);
            
            PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
            DWORD dwAdhocStart = 0;
            DWORD dwNumPreferredSettings = 0;
            
            /* Taroon:RemoveRight
            pWirelessPolicyData = GetResultObject()->GetWirelessPolicy();
            */
            
            pWirelessPolicyData = m_currentWirelessPolicyData;
            
            dwAdhocStart = pWirelessPolicyData->dwNumAPNetworks;
            dwNumPreferredSettings = pWirelessPolicyData->dwNumPreferredSettings;
            
            if ((dwAdhocStart == nIndex) || (nIndex == 0)) {
                SAFE_ENABLEWINDOW(IDC_PS_UP, FALSE);
            }
            
            if ((dwAdhocStart == (nIndex + 1))||
                (nIndex == (dwNumPreferredSettings - 1))) 
            {
                SAFE_ENABLEWINDOW(IDC_PS_DOWN, FALSE);
            }
        } else { 
            
            SAFE_ENABLEWINDOW(IDC_PS_UP, FALSE);
            SAFE_ENABLEWINDOW(IDC_PS_DOWN, FALSE);
        }
        
    }
    else
    {
        // if nothing was selected this takes care of it
        SAFE_ENABLEWINDOW (IDC_ACTION_PS_EDIT, FALSE);
        SAFE_ENABLEWINDOW (IDC_ACTION_PS_REMOVE, FALSE);
        SAFE_ENABLEWINDOW(IDC_PS_UP, FALSE);
        SAFE_ENABLEWINDOW(IDC_PS_DOWN, FALSE);
    }
    
}

void CSecPolRulesPage::DisableControls ()
{
    SAFE_ENABLEWINDOW (IDC_ACTION_PS_EDIT, FALSE);
    SAFE_ENABLEWINDOW (IDC_ACTION_PS_ADD, FALSE);
    SAFE_ENABLEWINDOW (IDC_ACTION_PS_REMOVE, FALSE);
    SAFE_ENABLEWINDOW(IDC_PS_UP, FALSE);
    SAFE_ENABLEWINDOW(IDC_PS_DOWN, FALSE);
    return;
}
BOOL CSecPolRulesPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DWORD* pdwHelp = (DWORD*) &g_aHelpIDs_IDD_PS_LIST[0];
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
            c_szWlsnpHelpFile,
            HELP_WM_HELP,
            (DWORD_PTR)(LPVOID)pdwHelp);
    }
    
    return CSnapinPropPage::OnHelpInfo(pHelpInfo);
}

void CSecPolRulesPage::OnItemchangedActionslist(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    EnableDisableButtons ();
    
    *pResult = 0;
}

void CSecPolRulesPage::OnKeydownActionslist(NMHDR* pNMHDR, LRESULT* pResult)
{
    // Something must be selected to do process the key opration
    if (-1 == m_lstActions.GetNextItem(-1,LVNI_SELECTED))
        return;
    
    LV_KEYDOWN* pLVKeyDown = (LV_KEYDOWN*)pNMHDR;
    
    
    if (VK_SPACE == pLVKeyDown->wVKey)
    {
        if (m_lstActions.GetSelectedCount() == 1)
        {
            int nItem;
            if (-1 != (nItem = m_lstActions.GetNextItem(-1, LVNI_SELECTED)))
            {
                PWIRELESS_PS_DATA pBWirelessPSData = NULL;
                
                PSNP_PS_DATA pNfaData;
                pNfaData = (PSNP_PS_DATA) m_lstActions.GetItemData(nItem);
                pBWirelessPSData = pNfaData->pWirelessPSData;
                ASSERT(pBWirelessPSData);
                
                
                // Redraw the list
                PopulateListControl ();
                
                // Reselect the toggled item
                DWORD dwSelection = -1;
                dwSelection = pBWirelessPSData->dwId;
                m_lstActions.SetItemState( dwSelection, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
            }
        }
    }
    else if (VK_DELETE == pLVKeyDown->wVKey)
    {
        if (!PSsRemovable())
            return;
        
        OnActionRemove();
    }
    
    *pResult = 0;
}



// Function: ToggleRuleActivation
// Desc: Toggle the activation of the Security Policy Rule in the dlg's
//       list control.
// Args:
//      nItemIndex: the 0-based index of the list item to be toggled
HRESULT CSecPolRulesPage::ToggleRuleActivation( int nItemIndex )
{
    HRESULT hr = S_OK;
    PSNP_PS_DATA pNfaData;
    
    pNfaData = (PSNP_PS_DATA) m_lstActions.GetItemData(nItemIndex);
    PWIRELESS_PS_DATA pBWirelessPSData = pNfaData->pWirelessPSData;
    
    SetModified();
    
    return hr;
}

void CSecPolRulesPage::OnDestroy()
{
    // Note: We never receive a WM_CLOSE, so clean up here.

    SNP_PS_LIST::iterator theIterator;
    PWIRELESS_PS_DATA pWirelessPSData = NULL;
    PSNP_PS_DATA pNfaData = NULL;
    
    FreeWirelessPolicyData(m_currentWirelessPolicyData);
    
    // Free objects associated with list.
    UnPopulateListControl();

    /* Taroon * found this leak from dh.. clearing Nfa List */ 
    //empty the previous List 
    if (!m_NfaList.empty()) {
        for(theIterator = m_NfaList.begin();theIterator != m_NfaList.end(); ++theIterator) {
            pNfaData =  (PSNP_PS_DATA)(*theIterator);
            pWirelessPSData  = pNfaData->pWirelessPSData;
            FreeWirelessPSData(pWirelessPSData);
            LocalFree(pNfaData);
        }
    }
    m_NfaList.clear();
    
    CSnapinPropPage::OnDestroy();
}



BOOL CSecPolRulesPage::PSsRemovable()
{
    if (m_lstActions.GetSelectedCount() == 0)
        return FALSE;
    
    BOOL bRemoveable = TRUE;
    int nIndex = -1;
    while (-1 != (nIndex = m_lstActions.GetNextItem( nIndex, LVNI_SELECTED )))
    {
        PSNP_PS_DATA pNfaData;
        pNfaData = (PSNP_PS_DATA) m_lstActions.GetItemData(nIndex);
        PWIRELESS_PS_DATA pBWirelessPSData = pNfaData->pWirelessPSData;
        
        if (NULL == pBWirelessPSData)
            continue;
        
    }
    
    return bRemoveable;
}


void CSecPolRulesPage::GenerateUniquePSName (UINT nID, CString& strName)
{
    
    BOOL bUnique = TRUE;
    int iUTag = 0;
    CString strUName;
    
    DWORD dwError = 0;
    DWORD i = 0;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    PWIRELESS_PS_DATA *ppWirelessPSData = NULL;
    PWIRELESS_PS_DATA pWirelessPSData = NULL;
    DWORD dwNumPreferredSettings = 0;
    
    // if an nID was passed in then start with that
    if (nID != 0)
    {
        strName.LoadString (nID);
    }
    /* Taroon:RemoveRight
    pWirelessPolicyData = GetResultObject()->GetWirelessPolicy();
    */
    pWirelessPolicyData = m_currentWirelessPolicyData;
    
    // zip through the ps and verify name is unique
    do
    {
        
        // only start tacking numbers on after the first pass
        if (iUTag > 0)
        {
            TCHAR buff[32];
            wsprintf (buff, _T(" (%d)"), iUTag);
            strUName = strName + buff;
            bUnique = TRUE;
        } else
        {
            strUName = strName;
            bUnique = TRUE;
        }
        
        ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
        dwNumPreferredSettings = pWirelessPolicyData->dwNumPreferredSettings;
        
        for (i = 0; i < dwNumPreferredSettings ; i++) {
            
            pWirelessPSData = *(ppWirelessPSData + i);
            if (0 == strUName.CompareNoCase(pWirelessPSData->pszWirelessSSID)) {
                // set bUnique to FALSE
                bUnique = FALSE;
                iUTag++;
                
            }
        }
        
    }
    while (bUnique == FALSE);
    
    // done
    strName = strUName;
}


////////////////////////////////////////////////////////////////////////////////////
// CSecPolPropSheetManager

BOOL CSecPolPropSheetManager::OnApply()
{
    BOOL bRet = TRUE;
    
    //Query each page to apply
    bRet = CMMCPropSheetManager::OnApply();
    
    //if some page refuse to apply, dont do anything
    if (!bRet)
        return bRet;
    
    ASSERT(m_pSecPolItem);
    if (NULL == m_pSecPolItem)
        return bRet;
    
    DWORD dwError = 0;
    
    
    dwError = WirelessSetPolicyData(
        m_pSecPolItem->m_pComponentDataImpl->GetPolicyStoreHandle(),
        m_pSecPolItem->GetWirelessPolicy()
        );
    if (ERROR_SUCCESS != dwError)
    {
        ReportError(IDS_SAVE_ERROR, HRESULT_FROM_WIN32(dwError));
    }
    
    GUID guidClientExt = CLSID_WIRELESSClientEx;
    GUID guidSnapin = CLSID_Snapin;
    
    m_pSecPolItem->m_pComponentDataImpl->UseGPEInformationInterface()->PolicyChanged (
        TRUE,
        TRUE,
        &guidClientExt,
        &guidSnapin
        );
    
    
    NotifyManagerApplied();
    
    NotifyConsole();
    
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\sprpage.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       sprpage.h
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#if !defined(AFX_SPAPAGE_H__6E562BE1_40D6_11D1_89DB_00A024CDD4DE__INCLUDED_)
#define AFX_SPAPAGE_H__6E562BE1_40D6_11D1_89DB_00A024CDD4DE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// sprage.h : header file
//

class CWiz97Sheet;

typedef enum
{
    NOTMODIFIED,
        MODIFIED,
        NEW,
        BEREMOVED,
        REMOVED,
        NEWREMOVED
} PS_STATUS;

//structure which holds all the WIRELESS_SNP_PS_DATA
typedef struct _SNP_PS_DATA
{
    PWIRELESS_PS_DATA pWirelessPSData;
    PS_STATUS status;
} SNP_PS_DATA, *PSNP_PS_DATA;

typedef vector<PSNP_PS_DATA> SNP_PS_LIST;

/////////////////////////////////////////////////////////////////////////////
// CSecPolRulesPage dialog
class CSecPolRulesPage : public CSnapinPropPage
{
    DECLARE_DYNCREATE(CSecPolRulesPage)
        
        // Construction
public:
    CSecPolRulesPage();
    ~CSecPolRulesPage();
    
    // Dialog Data
    //{{AFX_DATA(CSecPolRulesPage)
    enum { IDD = IDD_PS_LIST };
    CListCtrl   m_lstActions;
    PWIRELESS_PS_DATA * _ppWirelessPSData;
    DWORD _dwNumPSObjects;
    
    //}}AFX_DATA
    
    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSecPolRulesPage)
public:
    virtual void OnCancel();
    virtual BOOL OnApply();
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL
    
    UINT static AFX_CDECL DoThreadActionAdd(LPVOID pParam);
    void OnThreadSafeActionAdd();
    
    UINT static AFX_CDECL DoThreadActionEdit(LPVOID pParam);
    void OnThreadSafeActionEdit();
    
    // Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CSecPolRulesPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnActionAdd();
    afx_msg void OnActionEdit();
    afx_msg void OnActionRemove();
    afx_msg void OnDblclkActionslist(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnclickActionslist(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnClickActionslist(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnItemchangedActionslist(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKeydownActionslist(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDestroy();
    afx_msg void OnClickUseWizard();
    afx_msg void OnActionUp();
    afx_msg void OnActionDown();
    
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
        
    CString GetColumnStrBuffer (PWIRELESS_PS_DATA pWirelessPSData, int iColumn);
    int m_iSortSubItem;
    BOOL m_bSortOrder;
    WTL::CImageList m_imagelistChecks;
    
    void PopulateListControl ();
    void UnPopulateListControl ();
    
    int DisplayPSProperties (PSNP_PS_DATA pNfaData, CString strTitle, BOOL bDoingAdd, BOOL* pbAfterWizardHook);
    
    void EnableDisableButtons ();
    void DisableControls();
    HRESULT ToggleRuleActivation( int nItemIndex );
    void GenerateUniquePSName(UINT, CString &);
    
    BOOL PSsRemovable();
    
private:
    
    // when polstore triggers a commit
    void HandleSideEffectApply();
    
    static const TCHAR STICKY_SETTING_USE_SEC_POLICY_WIZARD[];
    DWORD m_MMCthreadID;
    
    CPropertySheet* m_pPrpSh;
    CCriticalSection m_csDlg;
    BOOL    m_bHasWarnedPSCorruption;
    BOOL m_bReadOnly;
    
    //for linked list which stores all the rules
    SNP_PS_LIST m_NfaList;
    PWIRELESS_POLICY_DATA m_currentWirelessPolicyData;
    void InitialzeNfaList();
    HRESULT UpdateWlstore();
};

class CSecPolPropSheetManager : public CMMCPropSheetManager
{
public:
    CSecPolPropSheetManager() :
      CMMCPropSheetManager(),
          m_pSecPolItem(NULL)
      {}
      virtual ~CSecPolPropSheetManager()
      {
          if (m_pSecPolItem)
              m_pSecPolItem->Release();
      }
      
      void Initialize(
          CComObject<CSecPolItem> * pSecPolItem
          )
      {
          CComObject<CSecPolItem> * pOldItem = m_pSecPolItem;
          m_pSecPolItem = pSecPolItem;
          
          if (m_pSecPolItem)
          {
              m_pSecPolItem->AddRef();
              EnableConsoleNotify(
                  pSecPolItem->GetNotifyHandle(),
                  (LPARAM)m_pSecPolItem
                  );
          }
          
          if (pOldItem)
              pOldItem->Release();
      }
      
      virtual BOOL OnApply();
      
protected:
    CComObject<CSecPolItem>* m_pSecPolItem;
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SPAPAGE_H__6E562BE1_40D6_11D1_89DB_00A024CDD4DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\ssidpage.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       ssidpage.cpp
//
//  Contents:  WiF Policy Snapin : General Properties of each PS.(Non 8021x)
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------


#include "stdafx.h"
#include "sprpage.h"
#include "ssidpage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSSIDPage property page

IMPLEMENT_DYNCREATE(CSSIDPage, CWirelessBasePage)

//CSSIDPage::CSSIDPage() : CWirelessBasePage(CSSIDPage::IDD)
CSSIDPage::CSSIDPage(UINT nIDTemplate) : CWirelessBasePage(nIDTemplate)
{
    //{{AFX_DATA_INIT(CSSIDPage)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    
    m_dlgIDD = nIDTemplate;
    m_bNameChanged = FALSE;
    m_bNetworkTypeChanged = FALSE;
    m_bPageInitialized = FALSE;
    m_dwWepEnabled = TRUE;
    m_dwNetworkAuthentication = FALSE;
    m_dwAutomaticKeyProvision = FALSE;
    m_dwNetworkType = FALSE;
    m_pWirelessPolicyData = NULL;
    m_bReadOnly = FALSE;
}

CSSIDPage::~CSSIDPage()
{
}

void CSSIDPage::DoDataExchange(CDataExchange* pDX)
{
    CWirelessBasePage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSSIDPage)
    DDX_Control(pDX, IDC_SSID_NAME, m_edSSID);
    DDX_Control(pDX, IDC_PS_DESCRIPTION, m_edPSDescription);
    DDX_Check(pDX, IDC_WEP_ENABLED, m_dwWepEnabled);
    DDX_Check(pDX, IDC_NETWORK_AUTHENTICATION, m_dwNetworkAuthentication);
    DDX_Check(pDX, IDC_AUTOMATIC_KEY_PROVISION, m_dwAutomaticKeyProvision);
    DDX_Check(pDX, IDC_NETWORK_TYPE, m_dwNetworkType);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSSIDPage, CWirelessBasePage)
//{{AFX_MSG_MAP(CSSIDPage)
ON_WM_HELPINFO()
ON_EN_CHANGE(IDC_SSID_NAME, OnChangedSSID)
ON_EN_CHANGE(IDC_PS_DESCRIPTION, OnChangedPSDescription)
ON_BN_CLICKED(IDC_WEP_ENABLED, OnChangedOtherParams)
ON_BN_CLICKED(IDC_NETWORK_AUTHENTICATION, OnChangedOtherParams)
ON_BN_CLICKED(IDC_AUTOMATIC_KEY_PROVISION, OnChangedOtherParams)
ON_BN_CLICKED(IDC_NETWORK_TYPE, OnChangedOtherParams)
ON_BN_CLICKED(IDC_NETWORK_TYPE, OnChangedNetworkType)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSSIDPage message handlers
BOOL CSSIDPage::OnInitDialog()
{
    PWIRELESS_PS_DATA pWirelessPSData = NULL;
    
    if (m_pWirelessPolicyData->dwFlags & WLSTORE_READONLY) {
        
        m_bReadOnly = TRUE;     
    }
    
    
    
    // call base class init
    CWirelessBasePage::OnInitDialog();
    
    m_bPageInitialized = TRUE;
    
    // show the wait cursor in case there is a huge description being accessed
    CWaitCursor waitCursor;
    
    
    pWirelessPSData = WirelessPS();
    
    
    m_edSSID.SetLimitText(c_nMaxSSIDLen);
    m_edPSDescription.SetLimitText(c_nMaxDescriptionLen);
    
    // initialize our edit controls
    
    
    ASSERT(pWirelessPSData);
    
    m_edSSID.SetWindowText(pWirelessPSData->pszWirelessSSID);
    
    m_oldSSIDName = CString(pWirelessPSData->pszWirelessSSID,pWirelessPSData->dwWirelessSSIDLen);
    
    
    if (pWirelessPSData->pszDescription) {
        
        m_edPSDescription.SetWindowText (pWirelessPSData->pszDescription);
        
    }
    m_dwWepEnabled = 
        (pWirelessPSData->dwWepEnabled) ? TRUE : FALSE;
    m_dwNetworkAuthentication = 
        (pWirelessPSData->dwNetworkAuthentication) ? TRUE : FALSE;
    m_dwAutomaticKeyProvision = 
        (pWirelessPSData->dwAutomaticKeyProvision) ? TRUE : FALSE;
    m_dwNetworkType = 
        (pWirelessPSData->dwNetworkType == WIRELESS_NETWORK_TYPE_ADHOC) ? TRUE : FALSE;
    
    if (m_bReadOnly) {
        DisableControls();
    }
    
    UpdateData (FALSE);
    
    // OK, we can start paying attention to modifications made via dlg controls now.
    // This should be the last call before returning from OnInitDialog.
    OnFinishInitDialog();
    
    return TRUE;  // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CSSIDPage::OnApply()
{
    CString strName;
    CString strDescription;
    LPWSTR SSID = NULL;
    LPWSTR pszDescription = NULL;
    PWIRELESS_PS_DATA pWirelessPSData = NULL;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    
    pWirelessPSData = WirelessPS();
    
    // pull our data out of the controls and into the object
    
    if (!UpdateData (TRUE))
        // Data was not valid, return for user to correct it.
        return CancelApply();
    
    
    ASSERT(pWirelessPSData);
    
    pWirelessPolicyData = m_pWirelessPolicyData;
    ASSERT(pWirelessPolicyData);
    
    DWORD dwNetworkType = 0;
    
    if (m_dwNetworkType)
        dwNetworkType = WIRELESS_NETWORK_TYPE_ADHOC; 
    else 
        dwNetworkType = WIRELESS_NETWORK_TYPE_AP; 
    
    m_edSSID.GetWindowText (strName);
    if(m_bNameChanged || m_bNetworkTypeChanged) 
    {
        if (m_bNameChanged) {
            if (strName.IsEmpty()) {
        	    ReportError(IDS_OPERATION_FAILED_NULL_SSID, 0);
        	    m_edSSID.SetWindowText(pWirelessPSData->pszWirelessSSID);
        	    return CancelApply();
            }
        }
        
        DWORD dwId = pWirelessPSData->dwId;
        
        if(IsDuplicateSSID(strName, dwNetworkType, pWirelessPolicyData, dwId)) {
            ReportError(IDS_OPERATION_FAILED_DUP_SSID,0);
            m_edSSID.SetWindowText(pWirelessPSData->pszWirelessSSID);
            return CancelApply();
        }  
    }
    m_bNameChanged = FALSE;
    m_bNetworkTypeChanged = FALSE;
    
    
    
    if (m_dwWepEnabled)  
        pWirelessPSData->dwWepEnabled = 1;
    else 
        pWirelessPSData->dwWepEnabled = 0;
    
    if (m_dwNetworkAuthentication) 
        pWirelessPSData->dwNetworkAuthentication = 1;
    else
        pWirelessPSData->dwNetworkAuthentication = 0;
    
    
    if (m_dwAutomaticKeyProvision)  
        pWirelessPSData->dwAutomaticKeyProvision = 1;
    else  
        pWirelessPSData->dwAutomaticKeyProvision = 0;
    
    if (m_dwNetworkType)
        pWirelessPSData->dwNetworkType = WIRELESS_NETWORK_TYPE_ADHOC; 
    else 
        pWirelessPSData->dwNetworkType = WIRELESS_NETWORK_TYPE_AP; 
    
    
    SSIDDupString(pWirelessPSData->pszWirelessSSID, strName);
    
    m_edPSDescription.GetWindowText (strDescription);
    FreeAndThenDupString(&pWirelessPSData->pszDescription, strDescription);
    UpdateWirelessPSData(pWirelessPSData);
    
    return CWirelessBasePage::OnApply();
}

void 
CSSIDPage::Initialize (
                       PWIRELESS_PS_DATA pWirelessPSData, 
                       CComponentDataImpl* pComponentDataImpl,
                       PWIRELESS_POLICY_DATA pWirelessPolicyData
                       )
{
    m_pWirelessPolicyData = pWirelessPolicyData;
    CWirelessBasePage::Initialize(pWirelessPSData, pComponentDataImpl);
}


BOOL CSSIDPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DWORD* pdwHelp = (DWORD*) &g_aHelpIDs_IDD_SSID[0];
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
            c_szWlsnpHelpFile,
            HELP_WM_HELP,
            (DWORD_PTR)(LPVOID)pdwHelp);
    }
    
    return CWirelessBasePage::OnHelpInfo(pHelpInfo);
}

void CSSIDPage::OnChangedSSID()
{
    m_bNameChanged = TRUE;
    SetModified();
}

void CSSIDPage::OnChangedPSDescription()
{
    SetModified();
}

void CSSIDPage::OnChangedNetworkType()
{
    m_bNetworkTypeChanged = TRUE;
    SetModified();
}

void CSSIDPage::OnChangedOtherParams()
{
    SetModified();
}

void CSSIDPage::DisableControls()
{
    SAFE_ENABLEWINDOW(IDC_SSID_NAME, FALSE);
    SAFE_ENABLEWINDOW(IDC_PS_DESCRIPTION, FALSE);
    SAFE_ENABLEWINDOW(IDC_WEP_ENABLED, FALSE);
    SAFE_ENABLEWINDOW(IDC_NETWORK_AUTHENTICATION, FALSE);
    SAFE_ENABLEWINDOW(IDC_AUTOMATIC_KEY_PROVISION, FALSE);
    SAFE_ENABLEWINDOW(IDC_NETWORK_TYPE, FALSE);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\warndlg.h ===
#if !defined(AFX_WARNINGDLG_H__92693AEA_E38D_11D1_8424_006008960A34__INCLUDED_)
#define AFX_WARNINGDLG_H__92693AEA_E38D_11D1_8424_006008960A34__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WarningDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWarningDlg dialog

class CWarningDlg : public CDialog
{
    // Construction
public:
    CWarningDlg(UINT nWarningIds, UINT nTitleIds = 0, CWnd* pParent = NULL);   // standard constructor
    CWarningDlg::CWarningDlg(LPCTSTR szWarningMessage, UINT nTitleIds = 0, CWnd* pParent =NULL);
    
    // Dialog Data
    //{{AFX_DATA(CWarningDlg)
    enum { IDD = IDD_WARNINGQUERY };
    CEdit   m_editWarning;
    //}}AFX_DATA
    
    
    // Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWarningDlg)
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL
    
    // Operations
public:
    void EnableDoNotShowAgainCheck( BOOL bEnable = TRUE );   // call before DoModal
    BOOL GetDoNotShowAgainCheck();   // call after DoModal
    
    // Implementation
protected:
    
    // Generated message map functions
    //{{AFX_MSG(CWarningDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnYes();
    afx_msg void OnNo();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
        
        UINT m_nWarningIds;
    UINT m_nTitleIds;
    CString m_sTitle;
    CString m_sWarning;
    BOOL    m_bEnableShowAgainCheckbox;
    BOOL    m_bDoNotShowAgainCheck;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WARNINGDLG_H__92693AEA_E38D_11D1_8424_006008960A34__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\ssidpage.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       ssidpage.h
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#if !defined(AFX_GENPAGE_H__FBD58E78_E2B5_11D0_B859_00A024CDD4DE__INCLUDED_)
#define AFX_GENPAGE_H__FBD58E78_E2B5_11D0_B859_00A024CDD4DE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// GenPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSSIDPage dialog

class CSSIDPage : public CWirelessBasePage
{
    DECLARE_DYNCREATE(CSSIDPage)
        
        // Construction
public:
    CSSIDPage(UINT nIDTemplate = IDD_SSID);
    ~CSSIDPage();
    
    // Dialog Data
  
    UINT m_dlgIDD;
    
    //{{AFX_DATA(CSSIDPage)
    CEdit   m_edSSID;
    CEdit   m_edPSDescription;
    BOOL     m_dwWepEnabled;
    BOOL     m_dwNetworkAuthentication;
    BOOL     m_dwAutomaticKeyProvision;
    BOOL     m_dwNetworkType;
    CString m_oldSSIDName;
    //}}AFX_DATA
    
    
    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSSIDPage)
public:
    virtual BOOL OnApply();
    
    void Initialize (
        PWIRELESS_PS_DATA pWirelessPSData, 
        CComponentDataImpl* pComponentDataImpl,
        PWIRELESS_POLICY_DATA pWirelessPolicyData
        );
    
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL
    
    // Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CSSIDPage)
    virtual BOOL OnInitDialog();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnChangedSSID();
    afx_msg void OnChangedPSDescription();
    afx_msg void OnChangedOtherParams();
    afx_msg void OnChangedNetworkType();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
        
        
        CString m_strOldName;
    
    BOOL m_bNameChanged;    // TRUE if IDC_EDNAME's contents changed
    BOOL m_bNetworkTypeChanged; 
    
    BOOL m_bPageInitialized;
    PWIRELESS_POLICY_DATA m_pWirelessPolicyData;
    
private:
    BOOL m_bReadOnly;
    void DisableControls();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GENPAGE_H__FBD58E78_E2B5_11D0_B859_00A024CDD4DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\stdafx.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       stdafx.cpp
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "stdafx.h"

// wifi snapin guids:
// {2DA6AA7F-8C88-4194-A558-0D36E7FD3E64}
const CLSID CLSID_Snapin =  { 0x2da6aa7f, 0x8c88, 0x4194, { 0xa5, 0x58, 0xd, 0x36, 0xe7, 0xfd, 0x3e, 0x64 } };
const wchar_t* cszSnapin = L"{2DA6AA7F-8C88-4194-A558-0D36E7FD3E64}";

// {DEA8AFA1-CC85-11d0-9CE2-0080C7221EBD}
const wchar_t *cszSnapin_ext = L"{827CE1A1-8255-4165-8C83-8379F8C127AE}";
const CLSID CLSID_Extension = { 0x827ce1a1, 0x8255, 0x4165, { 0x8c, 0x83, 0x83, 0x79, 0xf8, 0xc1, 0x27, 0xae } };


// {DD468E14-AF42-4d63-8908-EDAC4A9E67AE}
const wchar_t *cszAbout = L"{DD468E14-AF42-4d63-8908-EDAC4A9E67AE}";
const CLSID CLSID_About = { 0xdd468e14, 0xaf42, 0x4d63, { 0x89, 0x8, 0xed, 0xac, 0x4a, 0x9e, 0x67, 0xae } };



const CLSID CLSID_WIRELESSClientEx = {0x0acdd40c, 0x75ac, 0x47ab, {0xba, 0xa0, 0xbf, 0x6d, 0xe7, 0xe7, 0xfe, 0x63 } };




// TODO: object types should be defined in the derived object class headers?

// OBJECT TYPE for Scope Nodes.

// "Wireless Network Policy Management" static folder NodeType GUID in numeric & string formats.
const GUID cNodeTypeWirelessMan = { 0x36d6ca65, 0x3367, 0x49de, { 0xbb, 0x22, 0x19, 0x7, 0x55, 0x4f, 0x60, 0x75 } };
const wchar_t*  cszNodeTypeWirelessMan = L"{36D6CA65-3367-49de-BB22-1907554F6075}";




// OBJECT TYPE for result items.

// "Security Policy" result NodeType GUID in numeric & string formats.
const GUID cObjectTypeSecPolRes = { 0xd92e13c0, 0x3ab0, 0x11d1, { 0x89, 0xdb, 0x0, 0xa0, 0x24, 0xcd, 0xd4, 0xde } };
const wchar_t* cszObjectTypeSecPolRes = L"{D92E13C0-3AB0-11d1-89DB-00A024CDD4DE}";


// GPE guid
const GUID cGPEguid =   { 0x8fc0b735, 0xa0e1, 0x11d1, { 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3} };


// Published formats
const wchar_t* SNAPIN_WORKSTATION = L"SNAPIN_WORKSTATION"; // Extension
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\stdafx.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       stdafx.h
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxdlgs.h>
#include <afxmt.h>
#include <shfusion.h>

#include <atlbase.h>

//#include <atlwin.h>

// We depend on this pretty heavily for cross module communication
#include <shlobj.h>
#include <dsclient.h>
#include <windns.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>

#pragma comment(lib, "mmc")
#include <mmc.h>
#include "afxtempl.h"


/*
* Define/include the stuff we need for WTL::CImageList.  We need prototypes
* for IsolationAwareImageList_Read and IsolationAwareImageList_Write here
* because commctrl.h only declares them if __IStream_INTERFACE_DEFINED__
* is defined.  __IStream_INTERFACE_DEFINED__ is defined by objidl.h, which
* we can't include before including afx.h because it ends up including
* windows.h, which afx.h expects to include itself.  Ugh.
*/
HIMAGELIST WINAPI IsolationAwareImageList_Read(LPSTREAM pstm);
BOOL WINAPI IsolationAwareImageList_Write(HIMAGELIST himl,LPSTREAM pstm);
#define _WTL_NO_AUTOMATIC_NAMESPACE
#include <atlwin.h>
#include "atlapp.h"
#include "atlctrls.h"

#include <vector>



#include "resource.h"

#include "winsock2.h"

#include "helpids.h"
#include "helparr.h"

extern "C" {
    
#include "wlstore2.h"
    
};

#include <initguid.h>
#include "gpedit.h"         // gpe interface for extending GPO
//for wmi stuff begin
#include <wbemidl.h>
#include <oleauto.h>
#include <objbase.h>
#include <iads.h>
#include <adshlp.h>
#include <adserr.h>
#include <userenv.h>
#include <prsht.h>
//for wmi stuff end


#define SECURITY_WIN32
#include <Security.h>

#include "policycf.h"

#include "snputils.h"

/////////////////////////////////////////////////////////////////////////////
// Helper functions
template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        TRACE(_T("Release called on NULL interface ptr\n"));
    }
}

// TODO: remove CLSID_Extension code -- as we are not an extenstion
extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const wchar_t* cszSnapin;

extern const CLSID CLSID_Extension; // In-Proc server GUID
extern const wchar_t* cszSnapin_ext; 
extern const CLSID CLSID_WIRELESSClientEx;

extern const CLSID CLSID_About;
extern const wchar_t *cszAbout;

// OBJECT TYPE for Scope Nodes.

// "IP Security Management" static folder NodeType GUID in numeric & string formats.
extern const GUID cNodeTypeWirelessMan;
extern const wchar_t*  cszNodeTypeWirelessMan;



// OBJECT TYPE for result items.

// "Negotiation Policy" result NodeType GUID in numeric & string formats.
extern const GUID cObjectTypeSecPolRes;
extern const wchar_t*  cszObjectTypeSecPolRes;



// GPT guid
extern const GUID cGPEguid;

// Published context information for extensions to extend
extern const wchar_t* SNAPIN_WORKSTATION;

// the default folder images location in IDB_16x16 and IDB_32x32
#define FOLDER_IMAGE_IDX 0
#define OPEN_FOLDER_IMAGE_IDX 1

#define SECPOLICY_IMAGE_IDX 7
#define ENABLEDSECPOLICY_IMAGE_IDX 9
#define OPENSECPOLICY_IMAGE_IDX 8

#define NEGOTIATION_IMAGE_IDX 4
#define NEGOTIATIONLINK_IMAGE_IDX 5
#define NEGOTIATIONLINKOPEN_IMAGE_IDX 6

#define FILTER_IMAGE_IDX 2
#define FILTERLINK_IMAGE_IDX 3

// some helper defines
#define SAFE_ENABLEWINDOW(dlgID, bEnable) \
{ \
    CWnd* pWnd = 0; \
    pWnd = GetDlgItem (dlgID); \
    ASSERT (pWnd); \
    if (pWnd) \
{ \
    pWnd->EnableWindow (bEnable); \
} \
}

#define SAFE_SHOWWINDOW(dlgID, nCmdShow ) \
{ \
    CWnd* pWnd = 0; \
    pWnd = GetDlgItem (dlgID); \
    ASSERT (pWnd); \
    if (pWnd) \
{ \
    pWnd->ShowWindow (nCmdShow ); \
} \
}

inline CString ResourcedString (UINT nStringID)
{
    CString strTemp;
    strTemp.LoadString (nStringID);
    return strTemp;
}

// helper functions and macros shared between directories wlsnp.
#include "ipsutil.h"

#define CONFIGUREITEM(TmItem, TstrName, TstrStatusBarText, TlCommandID, TlInsertionPointID, TfFlags, TfSpecialFlags) \
{ \
    TmItem.strName = TstrName.GetBuffer(20); \
    TmItem.strStatusBarText = TstrStatusBarText.GetBuffer(20); \
    TmItem.lCommandID = TlCommandID; \
    TmItem.lInsertionPointID = TlInsertionPointID; \
    TmItem.fFlags = TfFlags; \
    TmItem.fSpecialFlags = TfSpecialFlags; \
}

// Debug instance counter
#ifdef _DEBUG
inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "WIRELESS: Memory Leak!!!", MB_OK);
}
#define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
#define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
#define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
#define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
    extern int s_cInst_##cls; \
if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#ifdef DO_TRACE
#define OPT_TRACE   TRACE   // optional trace on
#else
#define OPT_TRACE
#endif  //#ifdef DO_TRACE
#else
#define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
#define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
#define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
#define DEBUG_VERIFY_INSTANCE_COUNT(cls)
#define OPT_TRACE
#endif


#include "ccompdta.h"
#include "ccomp.h"
#include "DataObj.h"
#include "snapin.h"
#include "snpobj.h"
#include "snpdata.h"
#include "spolitem.h"
#include "mngrfldr.h"
#include "snppage.h"
#include "wiz97pg.h"
#include "nfabpage.h"
//#include "warnDlg.h"



#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) {\
    goto error; \
    }


#define BAIL_ON_FAILURE(hr) \
    if (FAILED(hr)) {\
    goto error; \
    }




#define DELETE_OBJECT(pObject)      \
    if (pObject)               \
{                          \
    delete(pObject);        \
    pObject=NULL;        \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\warndlg.cpp ===
// WarningDlg.cpp : implementation file
//

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWarningDlg dialog

CWarningDlg::CWarningDlg(UINT nWarningIds, UINT nTitleIds /*= 0*/, CWnd* pParent /*=NULL*/)
: CDialog(CWarningDlg::IDD, pParent),
m_nWarningIds( nWarningIds ),
m_nTitleIds( nTitleIds )
{
    //{{AFX_DATA_INIT(CWarningDlg)
    //}}AFX_DATA_INIT
    m_sWarning = _T("");
    m_bEnableShowAgainCheckbox = FALSE;  // default is hide checkbox
    m_bDoNotShowAgainCheck = FALSE; // default is show checkbox again
}

CWarningDlg::CWarningDlg(LPCTSTR szWarningMessage, UINT nTitleIds /*= 0*/, CWnd* pParent /*=NULL*/)
: CDialog(CWarningDlg::IDD, pParent),
m_nWarningIds( 0 ),
m_nTitleIds( nTitleIds )
{
    //{{AFX_DATA_INIT(CWarningDlg)
    m_sWarning = _T("");
    //}}AFX_DATA_INIT
    m_bEnableShowAgainCheckbox = FALSE;  // default is hide checkbox
    m_bDoNotShowAgainCheck = FALSE; // default is show checkbox again
    m_sWarning = szWarningMessage;
}

void CWarningDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWarningDlg)
    DDX_Control(pDX, IDC_EDIT_EXPLANATION, m_editWarning);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWarningDlg, CDialog)
//{{AFX_MSG_MAP(CWarningDlg)
ON_BN_CLICKED(IDYES, OnYes)
ON_BN_CLICKED(IDNO, OnNo)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWarningDlg Operations

void CWarningDlg::EnableDoNotShowAgainCheck( BOOL bEnable )
{
    m_bEnableShowAgainCheckbox = bEnable;
}

BOOL CWarningDlg::GetDoNotShowAgainCheck()
{
    if (m_bEnableShowAgainCheckbox)
        return m_bDoNotShowAgainCheck;
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CWarningDlg message handlers

BOOL CWarningDlg::OnInitDialog() 
{
    // Load the warning string for display in the dialog
    // if m_nWarningIds == 0, that means we already load 
    // the message string in constructor
    if (m_nWarningIds)
    {
        m_sWarning.FormatMessage( m_nWarningIds ); 
    }
    
    GetDlgItem(IDC_EDIT_EXPLANATION)->SetWindowText(m_sWarning);
    
    // Load the title, if any
    if (m_nTitleIds)
    {
        try { m_sTitle.LoadString( m_nTitleIds ); }
        catch( CMemoryException *pe )
        {
            ASSERT( FALSE );
            pe->Delete();
            m_sTitle.Empty();
        }
        if (!m_sTitle.IsEmpty())
        {
            SetWindowText( m_sTitle );
        }
    }
    
    // Determine whether the "Do not show this again" checkbox should be displayed.
    SAFE_SHOWWINDOW( IDC_CHECKNOTAGAIN, m_bEnableShowAgainCheckbox ? SW_SHOW : SW_HIDE );
    
    CDialog::OnInitDialog();
    // default to NO since user is doing something questionable
    // which requires us to ask if its really OK.
    GetDlgItem(IDNO)->SetFocus();
    SetDefID( IDNO );
    
    return 0;  // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE
}

void CWarningDlg::OnYes() 
{
    if (m_bEnableShowAgainCheckbox)
    {
        if (1 == ((CButton*)GetDlgItem( IDC_CHECKNOTAGAIN ))->GetCheck())
            m_bDoNotShowAgainCheck = TRUE;
        else
            m_bDoNotShowAgainCheck = FALSE;
    }
    
    EndDialog( IDYES ); 
}

void CWarningDlg::OnNo() 
{
    if (m_bEnableShowAgainCheckbox)
    {
        if (1 == ((CButton*)GetDlgItem( IDC_CHECKNOTAGAIN ))->GetCheck())
            m_bDoNotShowAgainCheck = TRUE;
        else
            m_bDoNotShowAgainCheck = FALSE;
    }
    
    EndDialog( IDNO );  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\tls.cpp ===
// tls.cpp : implementation file
//

#include "stdafx.h"
#include "nfaa.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTLSSetting dialog

CTLSSetting::CTLSSetting(CWnd* pParent /*=NULL*/)
	: CDialog(CTLSSetting::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTLSSetting)
	//m_dwValidateServerCertificate = FALSE;
	//}}AFX_DATA_INIT
	m_bReadOnly = FALSE;

}

void CTLSSetting::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTLSSetting)
       DDX_Control(pDX, IDC_COMBO_TLS_CERT_TYPE, m_cbCertificateType);
       DDX_Check(pDX, IDC_TLS_VALIDATE_SERVER_CERT, m_dwValidateServerCertificate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTLSSetting, CDialog)
	//{{AFX_MSG_MAP(CTLSSetting)
	ON_WM_HELPINFO()
       ON_CBN_SELENDOK(IDC_COMBO_TLS_CERT_TYPE, OnSelCertType)
       ON_BN_CLICKED(IDC_TLS_VALIDATE_SERVER_CERT, OnCheckValidateServerCert)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTLSSetting message handlers

BOOL CTLSSetting::OnInitDialog()
{
	CDialog::OnInitDialog();
	CString pszTemp;
	DWORD dwCertTypeIndex = 0;

	if (!pTLSProperties) {
		return FALSE;
		}

	pszTemp.LoadString(IDS_CERT_TYPE_SMARTCARD);
       m_cbCertificateType.AddString(pszTemp);
    
       pszTemp.LoadString(IDS_CERT_TYPE_MC_CERT);
       m_cbCertificateType.AddString(pszTemp);
    
    
       switch (pTLSProperties->dwCertType)
      {
           case WIRELESS_CERT_TYPE_SMARTCARD: 
             dwCertTypeIndex = 0;
           break;
           case WIRELESS_CERT_TYPE_MC_CERT:
             dwCertTypeIndex = 1;
            break;
           default:
              dwCertTypeIndex = 0;
           break;
     }
    
       m_cbCertificateType.SetCurSel(dwCertTypeIndex);
    
       m_dwValidateServerCertificate = 
        pTLSProperties->dwValidateServerCert ? TRUE : FALSE;

       if (m_bReadOnly) {
       	SAFE_ENABLEWINDOW(IDC_TLS_VALIDATE_SERVER_CERT, FALSE);
       	SAFE_ENABLEWINDOW(IDC_COMBO_TLS_CERT_TYPE, FALSE);
       	SAFE_ENABLEWINDOW(IDC_STATIC_CERT_TYPE, FALSE);
       	}

       UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CTLSSetting::ControlsValuesToSM (PTLS_PROPERTIES pTLSProperties)
{
	// pull all our data from the controls
       UpdateData(TRUE);	

	DWORD dwCertificateTypeIndex = 0;
	DWORD dwCertificateType = 0;
	DWORD dwValidateServerCertificate = 0;

	dwCertificateTypeIndex = m_cbCertificateType.GetCurSel();
    
    
       switch (dwCertificateTypeIndex) {
        case 0 :
            dwCertificateType = 
                WIRELESS_CERT_TYPE_SMARTCARD; 
            break;
        
    case 1 : 
        dwCertificateType = 
            WIRELESS_CERT_TYPE_MC_CERT;
        break;
    }
    
    dwValidateServerCertificate = 
        m_dwValidateServerCertificate ? 1 : 0;

    pTLSProperties->dwCertType = dwCertificateType;
    pTLSProperties->dwValidateServerCert = dwValidateServerCertificate;
    
}

void CTLSSetting::OnOK()
{
	UpdateData (TRUE);
	ControlsValuesToSM(pTLSProperties);
	CDialog::OnOK();
}

BOOL CTLSSetting::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DWORD* pdwHelp = (DWORD*) &g_aHelpIDs_IDD_TLS_SETTINGS[0];
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
            c_szWlsnpHelpFile,
            HELP_WM_HELP,
            (DWORD_PTR)(LPVOID)pdwHelp);
    }
    
    return TRUE;
}

void CTLSSetting::OnSelCertType()
{
    UpdateData(TRUE);
}

void CTLSSetting::OnCheckValidateServerCert()
{
    UpdateData(TRUE);
}

BOOL CTLSSetting::Initialize(
	PTLS_PROPERTIES paTLSProperties,
	BOOL bReadOnly
	)
{
    pTLSProperties = paTLSProperties;
    m_bReadOnly = bReadOnly;
    if (!pTLSProperties) {
    	return(FALSE);
    	}
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\tls.h ===
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// tls.h : header file
//

typedef struct _TLS_PROPERTIES {
    DWORD dwCertType;
    DWORD dwValidateServerCert;
} TLS_PROPERTIES, *PTLS_PROPERTIES;

/////////////////////////////////////////////////////////////////////////////
// CTLSSetting dialog

class CTLSSetting : public CDialog
{
// Construction
public:
	CTLSSetting(CWnd* pParent = NULL);   // standard constructor
	BOOL  Initialize ( PTLS_PROPERTIES pTLSProperties, BOOL bReadOnly = FALSE);

// Dialog Data
	//{{AFX_DATA(CTLSSetting)
	enum { IDD = IDD_TLS_SETTINGS};
       CComboBox m_cbCertificateType;
       BOOL   m_dwValidateServerCertificate;
	//}}AFX_DATA



// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTLSSetting)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
       	PTLS_PROPERTIES pTLSProperties;
       	BOOL m_bReadOnly;

	// Generated message map functions
	//{{AFX_MSG(CTLSSetting)
	virtual BOOL OnInitDialog();
	virtual void OnOK();

	
	afx_msg void OnCheckValidateServerCert();
	afx_msg void OnSelCertType();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void ControlsValuesToSM (PTLS_PROPERTIES pTLSProperties);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\wiz97pg.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Wiz97pg.cpp
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------
#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Base classes for Wiz97 dialogs
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CWiz97BasePage base class
//
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CWiz97BasePage, CSnapPage)

BOOL CWiz97BasePage::m_static_bFinish = FALSE;
BOOL CWiz97BasePage::m_static_bOnCancelCalled = FALSE;

CWiz97BasePage::CWiz97BasePage( UINT nIDD, BOOL bWiz97 /*= TRUE*/, BOOL bFinishPage /*= FALSE*/ ) :
CSnapPage( nIDD, bWiz97 ),
m_bSetActive( FALSE ),
m_bFinishPage( bFinishPage ),
m_pbDoAfterWizardHook( NULL ),
m_bReset( FALSE )
{
    CWiz97BasePage::m_static_bFinish = FALSE;
    CWiz97BasePage::m_static_bOnCancelCalled = FALSE;
}

CWiz97BasePage::~CWiz97BasePage()
{
    // Clean up
    m_psp.dwFlags = 0;
    m_psp.pfnCallback = NULL;
    m_psp.lParam = (LPARAM)NULL;
}

BOOL CWiz97BasePage::OnInitDialog()
{
    CSnapPage::OnInitDialog();

    if ( IDD_PROPPAGE_P_WELCOME == m_nIDD )
    {
        SetLargeFont(m_hWnd, IDC_POLICY_WIZARD_TITLE );
    }

    
    if ( IDD_PROPPAGE_N_DONE == m_nIDD )
    {
        SetLargeFont(m_hWnd, IDC_POLICY_WIZARD_DONE );
    }
    
    OnFinishInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE

}

BOOL CWiz97BasePage::InitWiz97
(
 DWORD   dwFlags,
 DWORD   dwWizButtonFlags /*= 0*/,
 UINT    nHeaderTitle /*= 0*/,
 UINT    nSubTitle /*= 0*/,
 STACK_INT   *pstackPages /*= NULL*/
 )
{
    // NOTE: we wouldn't ever get here except when win97 wizards are running
    // but we have to compile this in because its a base class, EVEN WHEN
    // NOT DOING WIZ97 WIZARDS. To maintain the compile we have to ifdef
    // out this call to the base class
    
#ifdef WIZ97WIZARDS
    
    // Hook up our callback function
    return CSnapPage::InitWiz97( &CWiz97BasePage::PropSheetPageCallback,
        NULL, dwFlags, dwWizButtonFlags, nHeaderTitle, nSubTitle, pstackPages );
#else
    return FALSE;
#endif
}

BOOL CWiz97BasePage::InitWiz97
(
 CComObject<CSecPolItem> *pSecPolItem,
 DWORD   dwFlags,
 DWORD   dwWizButtonFlags /*= 0*/,
 UINT    nHeaderTitle /*= 0*/,
 UINT    nSubTitle /*= 0*/
 )
{
    // Hook up our callback function
    return CSnapPage::InitWiz97( &CWiz97BasePage::PropSheetPageCallback,
        pSecPolItem, dwFlags, dwWizButtonFlags, nHeaderTitle, nSubTitle );
}

// static member
UINT CALLBACK CWiz97BasePage::PropSheetPageCallback( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp )
{
    if (PSPCB_RELEASE == uMsg)
    {
        ASSERT( NULL != ppsp && NULL != ppsp->lParam );
        CWiz97BasePage *pThis = reinterpret_cast<CWiz97BasePage*>(ppsp->lParam);
        
        // Wiz97BasePage callback handling is for wizards only.
        if (pThis->m_bWiz97)
        {
            if (m_static_bFinish)  // Sheet is finishing
            {
                // Call OnWizardRelease for each page in the sheet giving each page
                // the opportunity to clean up anything left over after the finish
                // page's OnWizardFinish.
                pThis->OnWizardRelease();
                
                // If an access violation occurs here its because OnWizardRelease()
                // is not a member of the base class.  See the implementation note
                // in wiz97run.cpp.
            }
            else    // Sheet is cancelling
            {
                // Call OnCancel when it hasn't been called yet.  OnCancel was already
                // called by OnReset for pages which were activated, don't call it again.
                if (!pThis->m_bReset)
                    pThis->OnCancel();
                if (!CWiz97BasePage::m_static_bOnCancelCalled)
                {
                    // Make sure base class OnCancel is called exactly once because
                    // there is only one object for the propsheet, and OnCancel
                    // refreshes it, throwing away changes.  All proppages have
                    // a ptr to the same object.
                    CWiz97BasePage::m_static_bOnCancelCalled = TRUE;
                    pThis->CSnapPage::OnCancel();
                }
            }
        }
    }
    return CSnapPage::PropertyPageCallback( hwnd, uMsg, ppsp );
}

void CWiz97BasePage::ConnectAfterWizardHook( BOOL *pbDoHook )
{
    ASSERT( NULL != pbDoHook );
    m_pbDoAfterWizardHook = pbDoHook;
    *m_pbDoAfterWizardHook = FALSE;  // initialize
}

void CWiz97BasePage::SetAfterWizardHook( BOOL bDoHook )
{
    ASSERT( NULL != m_pbDoAfterWizardHook );
    *m_pbDoAfterWizardHook = bDoHook;
}

/////////////////////////////////////////////////////////////////////////////
// CWiz97BasePage message handlers

BOOL CWiz97BasePage::OnSetActive()
{
    m_bSetActive = TRUE;
    return CSnapPage::OnSetActive();
}

BOOL CWiz97BasePage::OnWizardFinish()
{
    // Let other wizard pages know they should finish, instead of cancel.
    SetFinished();
    
    // If m_pbDoAfterWizardHook is valid, caller expects it to be set.
    // Derive this function in your class.
    
    return CSnapPage::OnWizardFinish();
}

void CWiz97BasePage::OnCancel()
{
    // Make sure we don't call OnCancel again for this page
    m_bReset = TRUE;
    
    // Note: OnCancel is ALWAYS called, even when the page has not been
    // activated.  Override this class to clean up anything that was done
    // in InitWiz97.  CSnapPage::OnCancel will be called exactly once for
    // the Sheet by the Page callback function.
}

//////////////////////////////////////////////////////////////////////
// CWiz97PSBasePage Class
//////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// General Name/Properties Wiz97 dialog(s)
//
/////////////////////////////////////////////////////////////////////////////

CWiz97WirelessPolGenPage::CWiz97WirelessPolGenPage(UINT nIDD, UINT nInformativeText, BOOL bWiz97) :
CWiz97BasePage(nIDD, bWiz97)
{
    m_nInformativeText = nInformativeText;
    m_pPolicy = NULL;
}

CWiz97WirelessPolGenPage::~CWiz97WirelessPolGenPage()
{
    
}

void CWiz97WirelessPolGenPage::DoDataExchange(CDataExchange* pDX)
{
    CWiz97BasePage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWiz97WirelessPolGenPage)
    // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    if (IDD_WIFIGEN_WIZBASE == m_nIDD)
    {
        DDX_Control(pDX, IDC_EDNAME, m_edName);
        DDX_Control(pDX, IDC_EDDESCRIPTION, m_edDescription);
    }
}

BEGIN_MESSAGE_MAP(CWiz97WirelessPolGenPage, CWiz97BasePage)
//{{AFX_MSG_MAP(CWiz97WirelessPolGenPage)
ON_EN_CHANGE(IDC_EDNAME, OnChangedName)
ON_EN_CHANGE(IDC_EDDESCRIPTION, OnChangedDescription)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CWiz97WirelessPolGenPage::OnInitDialog()
{
    // call base class init
    CWiz97BasePage::OnInitDialog();
    
    m_pPolicy = m_pspiResultItem->GetWirelessPolicy();
    
    if (IDD_WIFIGEN_WIZBASE == m_nIDD)
    {
        // show the wait cursor in case there is a huge description being accessed
        CWaitCursor waitCursor;
        
        m_edName.SetLimitText(c_nMaxName);
        m_edDescription.SetLimitText(c_nMaxName);
        
        // initialize our edit controls
        m_edName.SetWindowText (m_pPolicy->pszWirelessName);
        m_edDescription.SetWindowText (m_pPolicy->pszDescription);
        
        // add context help to the style bits
        if (GetParent())
        {
            GetParent()->ModifyStyleEx (0, WS_EX_CONTEXTHELP, 0);
        }
        
        UpdateData (FALSE);
    }
    else if (IDD_PROPPAGE_G_NAMEDESCRIPTION == m_nIDD)
    {
        SendDlgItemMessage(IDC_NEW_POLICY_NAME, EM_LIMITTEXT, c_nMaxName, 0);
        SendDlgItemMessage(IDC_NEW_POLICY_DESCRIPTION, EM_LIMITTEXT, c_nMaxName, 0);
    }
    
    // OK, we can start paying attention to modifications made via dlg controls now.
    // This should be the last call before returning from OnInitDialog.
    OnFinishInitDialog();
    
    return TRUE;  // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CWiz97WirelessPolGenPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DWORD* pdwHelp = (DWORD*) &g_aHelpIDs_IDD_PROPPAGE_G_NAMEDESCRIPTION[0];
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
            c_szWlsnpHelpFile,
            HELP_WM_HELP,
            (DWORD_PTR)(LPVOID)pdwHelp);
    }
    
    return CWiz97BasePage::OnHelpInfo(pHelpInfo);
}

void CWiz97WirelessPolGenPage::OnChangedName()
{
    ASSERT( IDD_WIFIGEN_WIZBASE == m_nIDD );
    SetModified();
}

void CWiz97WirelessPolGenPage::OnChangedDescription()
{
    ASSERT( IDD_WIFIGEN_WIZBASE == m_nIDD );
    SetModified();
}

BOOL CWiz97WirelessPolGenPage::OnSetActive()
{
    if (IDD_WIFIGEN_WIZBASE != m_nIDD)
    {
        // show the wait cursor in case there is a huge description being accessed
        CWaitCursor waitCursor;
        
        // initialize our name/description controls with the correct name/description
        GetDlgItem(IDC_NEW_POLICY_NAME)->SetWindowText (m_pPolicy->pszWirelessName);
        GetDlgItem(IDC_NEW_POLICY_DESCRIPTION)->SetWindowText (m_pPolicy->pszDescription);
        
        // set the informative text correctly
        if (m_nInformativeText != 0)
        {
            // NOTE: currently the IDC_INFORMATIVETEXT control is disabled and
            // readonly. Need to change the resource if this functionality is to
            // be used.
            ASSERT (0);
            
            CString strInformativeText;
            strInformativeText.LoadString (m_nInformativeText);
            GetDlgItem(IDC_INFORMATIVETEXT)->SetWindowText (strInformativeText);
        }
    }
    
    return CWiz97BasePage::OnSetActive();
}

LRESULT CWiz97WirelessPolGenPage::OnWizardBack()
{
    ASSERT( IDD_WIFIGEN_WIZBASE != m_nIDD );
    
    // skip going to the prev page if they selected 'cancel' on a data error dialog
    return CWiz97BasePage::OnWizardBack();
}

LRESULT CWiz97WirelessPolGenPage::OnWizardNext()
{
    ASSERT( IDD_WIFIGEN_WIZBASE != m_nIDD );
    
    // TODO: enable this when we are sure update stuff is working
    // refresh the display
    // GetResultObject()->m_pComponentDataImpl->GetConsole()->UpdateAllViews (0, 0,0);
    
    // skip going to the next page if they selected 'cancel' on a data error dialog
    return SaveControlData() ? CWiz97BasePage::OnWizardNext() : -1;
}

BOOL CWiz97WirelessPolGenPage::OnApply()
{
    ASSERT( IDD_WIFIGEN_WIZBASE == m_nIDD );
    
    // pull our data out of the controls and into the object
    CString strName;
    CString strDescription;
    
    if (!UpdateData (TRUE))
        // Data was not valid, return for user to correct it.
        return CancelApply();
    
    m_edName.GetWindowText (strName);
    m_edDescription.GetWindowText (strDescription);
    
    // verify that the name is not empty
    CString strNameNoBlank = strName;
    strNameNoBlank.TrimLeft();
    if (strNameNoBlank.GetLength() == 0)
    {
        AfxMessageBox (IDS_WARNNONAME, MB_ICONSTOP);
        return CancelApply();
    }
    
    SaveControlData();
    
    return CWiz97BasePage::OnApply();
}

BOOL CWiz97WirelessPolGenPage::SaveControlData()
{
    ASSERT( IDD_WIFIGEN_WIZBASE != m_nIDD );
    
    BOOL bSaved = TRUE;
    
    // set the wait cursor
    CWaitCursor waitCursor;
    
    // set the new name and description
    CString strName, strDesc;
    GetDlgItem(IDC_NEW_POLICY_NAME)->GetWindowText (strName);
    GetDlgItem(IDC_NEW_POLICY_DESCRIPTION)->GetWindowText (strDesc);
    
    // verify that the name is not empty
    CString strNameNoBlank = strName;
    strNameNoBlank.TrimLeft();
    if (strNameNoBlank.GetLength() == 0)
    {
        AfxMessageBox (IDS_WARNNONAME, MB_ICONSTOP);
        return FALSE;
    }
    
    if (m_pPolicy->pszWirelessName)
        FreePolStr(m_pPolicy->pszWirelessName);
    
    m_pPolicy->pszWirelessName = AllocPolStr(strName);
    
    if (m_pPolicy->pszDescription)
        FreePolStr(m_pPolicy->pszDescription);
    
    m_pPolicy->pszDescription = AllocPolStr(strDesc);
    
    
    return bSaved;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\wiz97run.h ===
// Wiz97run.h: declaration of the wiz97 helper/runner functions
//
//////////////////////////////////////////////////////////////////////

#pragma once

// since different modules will include this for only one of the following functions
// we declare all the classes in case that particular module isn't interested
class CSecPolItem;

// these function display the appropriate property sheet
HRESULT CreateSecPolItemWiz97PropertyPages(CComObject<CSecPolItem> *pSecPolItem, PWIRELESS_PS_DATA pWirelessPSData, LPPROPERTYSHEETCALLBACK lpProvider);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\wiz97pg.h ===
#if !defined(AFX_WIZPAGE_H__61D37A46_D552_11D1_9BCC_006008947035__INCLUDED_)
#define AFX_WIZPAGE_H__61D37A46_D552_11D1_9BCC_006008947035__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Wiz97Pg.h : header file
//

// forward declaration
class CWiz97Sheet;

/////////////////////////////////////////////////////////////////////////////
//
// Base classes for Wiz97 dialogs
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CWiz97BasePage base class
//  This class is intended to be used for wizard pages.  Either OnCanel() or
//  OnWizardFinish() is called for every page derived from this class whether
//  or not the Finish button is displayed.  The default versions of these functions
//  provided here do nothing.  This means the finishing page should implement
//  OnCancel() to call CSnapPage::OnCancel() otherwise it will not get called.

class CWiz97BasePage : public CSnapPage
{
    DECLARE_DYNCREATE(CWiz97BasePage)
        // Construction
public:
    CWiz97BasePage(UINT nIDD, BOOL bWiz97 = TRUE, BOOL bFinishPage = FALSE );
    CWiz97BasePage() { ASSERT( FALSE ); }
    virtual ~CWiz97BasePage();
    
    // Can initialize the page with either a DSObject OR a SecPolItem, but not
    // both because the DSObject() accessor gets confused.
    virtual BOOL InitWiz97
        (
        DWORD   dwFlags,
        DWORD   dwWizButtonFlags = 0,
        UINT    nHeaderTitle = 0,
        UINT    nSubTitle = 0,
        STACK_INT   *pstackPages = NULL
        );
    virtual BOOL InitWiz97
        (
        CComObject<CSecPolItem> *pSecPolItem,
        DWORD   dwFlags,
        DWORD   dwWizButtonFlags /*= 0*/,
        UINT    nHeaderTitle /*= 0*/,
        UINT    nSubTitle /*= 0*/
        );
    // *pbDoHook set upon exit from PropSheet in derived OnWizardFinish()
    void ConnectAfterWizardHook( BOOL *pbDoHook );
    
public:
    virtual BOOL OnSetActive();
    // Default handlers since our callback needs something to call.
    virtual BOOL OnWizardFinish();
    virtual void OnCancel();
    // OnWizardRelease is called for each page after the finish page's OnWizardFinish has been called.
    virtual void OnWizardRelease() {};
    
    static UINT CALLBACK PropSheetPageCallback( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    
protected:

    virtual BOOL OnInitDialog();
    void SetAfterWizardHook( BOOL bDoHook );
    BOOL WasActivated() { return m_bSetActive; }
    void SetFinished( BOOL bFinished = TRUE ) { m_static_bFinish = bFinished; }
    
private:
    static BOOL m_static_bFinish;  // TRUE if Finish button pressed on last page
    static BOOL m_static_bOnCancelCalled;  // TRUE if CSnapPage::OnCancel called. Call 1 time only.
    
    BOOL    *m_pbDoAfterWizardHook;
    BOOL    m_bFinishPage;  // TRUE if this is the finishing page
    BOOL    m_bSetActive;   // TRUE if this page was ever displayed
    BOOL    m_bReset;   // TRUE if OnCancel was called due to a reset for this page
};


/////////////////////////////////////////////////////////////////////////////
//
// General Name/Properties Wiz97 dialog(s)
//
/////////////////////////////////////////////////////////////////////////////

class CWiz97WirelessPolGenPage : public CWiz97BasePage
{
public:
    CWiz97WirelessPolGenPage(UINT nIDD, UINT nInformativeText, BOOL bWiz97 = TRUE);
    virtual ~CWiz97WirelessPolGenPage();
    
    // Dialog Data
    //{{AFX_DATA(CWiz97WirelessPolGenPage)
    enum { IDD = IDD_PROPPAGE_G_NAMEDESCRIPTION};
    CEdit m_edName;
    CEdit m_edDescription;
    //}}AFX_DATA
    
    
    virtual void Initialize (PWIRELESS_POLICY_DATA pWirelessPolicyData)
    {
        ASSERT( NULL != pWirelessPolicyData );
        
        m_pPolicy = pWirelessPolicyData;
        
        // let base class continue initialization
        CWiz97BasePage::Initialize( NULL);
    }
    
    
    
    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWiz97WirelessPolGenPage)
public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardBack();
    virtual LRESULT OnWizardNext();
    virtual BOOL OnApply();
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL
    
    // Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CWiz97WirelessPolGenPage)
    virtual BOOL OnInitDialog();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnChangedName();
    afx_msg void OnChangedDescription();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
        
        BOOL SaveControlData();
    
    UINT m_nInformativeText;
    
    LPWSTR * m_ppwszName;
    LPWSTR * m_ppwszDescription;
    
    PWIRELESS_POLICY_DATA m_pPolicy;
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZPAGE_H__61D37A46_D552_11D1_9BCC_006008947035__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\wiz97run.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:      Wiz97run.cpp
//
//  Contents:  WiF Policy Snapin - implementation of the wiz97 helper/runner functions
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include "Wiz97run.h"
//#include "Wiz97sht.h"
#include "Wiz97Pol.h"
//#include "Wiz97rul.h"

// Rule pages includes (not in Wiz97pg.h)
//#include "nfaam.h"
//#include "nfaf.h"
//#include "nfanp.h"
#include "nfaa.h"
//#include "nfatep.h"

// NegPol pages
//#include "negpage.h"
//#include "smSimple.h"

// Filter pages
//#include "fnpage.h"
//#include "fppage.h"
//#include "fdmpage.h"

//**
//** Read this!!!! Wizard implementation note:
//**    When implementing wizards you MUST insure that ALL the pages in the
//**    wizard derive exclusively from either CWiz97BasePage or CSnapPage.
//**    This is a requirement because all pages must have the same callback
//**    function when MMCPropPageCallback is used.
//**
//**    If you mix classes derived from CWiz97BasePage and CSnapPage an access
//**    violation will probably occur in the callback when it tries to call
//**    CWiz97BasePage::OnWizardRelease, but the class isn't derived from
//**    CWiz97BasePage.
//**

#ifdef WIZ97WIZARDS
HRESULT CreateSecPolItemWiz97PropertyPages(CComObject<CSecPolItem> *pSecPolItem, PWIRELESS_PS_DATA pWirelessPSData, LPPROPERTYSHEETCALLBACK lpProvider)
{ 
    
    // Create the property page(s); gets deleted when the window is destroyed
    CWiz97BasePage* pPolicyWelcome = new CWiz97BasePage(IDD_PROPPAGE_P_WELCOME, TRUE);
    CWiz97WirelessPolGenPage* pGeneralNameDescription = new CWiz97WirelessPolGenPage(IDD_PROPPAGE_G_NAMEDESCRIPTION, 0, TRUE);
    CWiz97PolicyDonePage* pPolicyDone = new CWiz97PolicyDonePage(IDD_PROPPAGE_N_DONE, TRUE); 
    
    if ((pPolicyWelcome == NULL) ||
        (pGeneralNameDescription == NULL) ||
        (pPolicyDone == NULL)) 
    {
        // must be a memory condition
        return E_UNEXPECTED;
    }
    
    
    pPolicyWelcome->InitWiz97 (pSecPolItem, PSP_DEFAULT | PSP_HIDEHEADER, PSWIZB_NEXT, 0, 0); 
    pGeneralNameDescription->InitWiz97 (pSecPolItem, PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE, PSWIZB_BACK | PSWIZB_NEXT,IDS_WIRELESS_PROPPAGE_PI_T_NAME, IDS_WIRELESS_PROPPAGE_PI_ST_NAME);
    
    pPolicyDone->InitWiz97 (pSecPolItem, PSP_DEFAULT | PSP_HIDEHEADER, PSWIZB_BACK | PSWIZB_FINISH,0,0);
    
    HPROPSHEETPAGE hPolicyWelcome = MyCreatePropertySheetPage(&(pPolicyWelcome->m_psp));
    HPROPSHEETPAGE hGeneralNameDescription = MyCreatePropertySheetPage(&(pGeneralNameDescription->m_psp));
    HPROPSHEETPAGE hPolicyDone = MyCreatePropertySheetPage(&(pPolicyDone->m_psp));
    
    
    if ((hPolicyWelcome == NULL) ||
        (hGeneralNameDescription == NULL) ||
        (hPolicyDone == NULL))
    {
        // TODO: we are leaking all these pages by bailing now
        return E_UNEXPECTED;
    }
    
    // add all the pages
    lpProvider->AddPage(hPolicyWelcome);
    lpProvider->AddPage(hGeneralNameDescription);
    lpProvider->AddPage(hPolicyDone);
    
    // the base class CSnapPage deletes these pages in its PropertyPageCallback
    return S_OK;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\wiz97pol.h ===
#if !defined(AFX_WIZPOLICY_H__61D37A46_D552_11D1_9BCC_006008947035__INCLUDED_)
#define AFX_WIZPOLICY_H__61D37A46_D552_11D1_9BCC_006008947035__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Wiz97Pol.h : header file
//

#ifdef WIZ97WIZARDS


/*
class CWiz97DefaultResponse : public CWiz97BasePage
{
public:
CWiz97DefaultResponse(UINT nIDD, BOOL bWiz97 = TRUE);
virtual ~CWiz97DefaultResponse();

  // Dialog Data
  //{{AFX_DATA(CWiz97DefaultResponse)
  enum { IDD = IDD_PROPPAGE_PI_DEFAULTRESPONSE };
  BOOL m_bDefaultResponse;
  //}}AFX_DATA
  
    
      // Overrides
      // ClassWizard generate virtual function overrides
      //{{AFX_VIRTUAL(CWiz97ChainFilterSpecPage)
      public:
      virtual LRESULT OnWizardNext();
      protected:
      virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
      //}}AFX_VIRTUAL
      
        // Implementation
        protected:
        // Generated message map functions
        //{{AFX_MSG(CWiz97DefaultResponse)
        // NOTE: the ClassWizard will add member functions here
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
        };
*/

class CWiz97PolicyDonePage : public CWiz97BasePage  
{
public:
    CWiz97PolicyDonePage (UINT nIDD, BOOL bWiz97 = TRUE);
    virtual ~CWiz97PolicyDonePage ();
    
    // Dialog Data
    //{{AFX_DATA(CWiz97PolicyDonePage)
    //enum { IDD = IDD_PROPPAGE_P_DONE };
    BOOL m_bCheckProperties;
    //}}AFX_DATA
    
    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWiz97PolicyDonePage)
public:
    virtual BOOL OnWizardFinish();
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL
    
    // Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CWiz97PolicyDonePage)
    // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // #ifdef WIZ97WIZARDS

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZPOLICY_H__61D37A46_D552_11D1_9BCC_006008947035__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\api.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       api.c
//
//  Contents:   APIs exported to snapin to manage WIFI policy objects on AD
//
//
//  History:    TaroonM
//              10/30/01
//  
//  Remarks: Wireless Network Policy Management Currently doesnt support Registry based(local) policies. However we are 
//  keeping the Registry based code, for possible use later.
//----------------------------------------------------------------------------

#include "precomp.h"


DWORD
WirelessEnumPolicyData(
                       HANDLE hPolicyStore,
                       PWIRELESS_POLICY_DATA ** pppWirelessPolicyData,
                       PDWORD pdwNumPolicyObjects
                       )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PWIRELESS_POLICY_STORE pPolicyStore = NULL;
    IWbemServices *pWbemServices = NULL;
    
    pPolicyStore = (PWIRELESS_POLICY_STORE)hPolicyStore;
    
    switch (pPolicyStore->dwProvider) {
        
    case WIRELESS_REGISTRY_PROVIDER:
         break;
        
    case WIRELESS_DIRECTORY_PROVIDER:
        dwError = DirEnumWirelessPolicyData(
            (pPolicyStore->hLdapBindHandle),
            pPolicyStore->pszWirelessRootContainer,
            pppWirelessPolicyData,
            pdwNumPolicyObjects
            );
        break;
        
        
    case WIRELESS_WMI_PROVIDER:
        dwError = CreateIWbemServices(
            pPolicyStore->pszLocationName,
            &pWbemServices
            );
        
        if(dwError == ERROR_SUCCESS) {
            dwError = WMIEnumPolicyDataEx(
                pWbemServices,
                pppWirelessPolicyData,
                pdwNumPolicyObjects
                );
            
            IWbemServices_Release(pWbemServices);
        }
        break;
        
        
    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;
        
        
    }
    
    return(dwError);
}



DWORD
WirelessSetPolicyData(
                      HANDLE hPolicyStore,
                      PWIRELESS_POLICY_DATA pWirelessPolicyData
                      )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PWIRELESS_POLICY_STORE pPolicyStore = NULL;
    
    
    dwError = ValidateWirelessPolicyData(
        pWirelessPolicyData
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    pPolicyStore = (PWIRELESS_POLICY_STORE)hPolicyStore;
    
    switch (pPolicyStore->dwProvider) {
    case WIRELESS_REGISTRY_PROVIDER:
        break;
        
    case WIRELESS_DIRECTORY_PROVIDER:
        dwError = DirSetWirelessPolicyData(
            (pPolicyStore->hLdapBindHandle),
            pPolicyStore->pszWirelessRootContainer,
            pWirelessPolicyData
            );
        break;
        
        
    case WIRELESS_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;
        
    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;
        
    }

error:
   	
    return(dwError);
}



DWORD
WirelessCreatePolicyData(
                         HANDLE hPolicyStore,
                         PWIRELESS_POLICY_DATA pWirelessPolicyData
                         )
{
    
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PWIRELESS_POLICY_STORE pPolicyStore = NULL;
    
    dwError = ValidateWirelessPolicyData(
        pWirelessPolicyData
    );
    
    BAIL_ON_WIN32_ERROR(dwError);
    
    pPolicyStore = (PWIRELESS_POLICY_STORE)hPolicyStore;
    
    switch (pPolicyStore->dwProvider) {
    case WIRELESS_REGISTRY_PROVIDER:
    /*
    dwError = RegCreatePolicyData(
    (pPolicyStore->hRegistryKey),
    pPolicyStore->pszWirelessRootContainer,
    pWirelessPolicyData
    );
        */
        break;
        
    case WIRELESS_DIRECTORY_PROVIDER:
        dwError = DirCreateWirelessPolicyData(
            (pPolicyStore->hLdapBindHandle),
            pPolicyStore->pszWirelessRootContainer,
            pWirelessPolicyData
            );
        break;
        
        
    case WIRELESS_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;
        
        
    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;
        
    }
    
error:
    
    return(dwError);
}


DWORD
WirelessDeletePolicyData(
                         HANDLE hPolicyStore,
                         PWIRELESS_POLICY_DATA pWirelessPolicyData
                         )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PWIRELESS_POLICY_STORE pPolicyStore = NULL;
    
    pPolicyStore = (PWIRELESS_POLICY_STORE)hPolicyStore;
    
    switch (pPolicyStore->dwProvider) {
    case WIRELESS_REGISTRY_PROVIDER:
        break;

    case WIRELESS_DIRECTORY_PROVIDER:
        dwError = DirDeleteWirelessPolicyData(
            (pPolicyStore->hLdapBindHandle),
            pPolicyStore->pszWirelessRootContainer,
            pWirelessPolicyData
            );
        break;
        
        
    case WIRELESS_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;
        
        
    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;
        
    }
    
    return(dwError);
}
/*

pszGPO name contains the LDAP path of the GPO whose extesnion 
snapin is making this call.

*/



DWORD
WirelessGPOOpenPolicyStore(
                        LPWSTR pszMachineName,
                        DWORD dwTypeOfStore,
                        LPWSTR pszGPOName,
                        LPWSTR pszFileName,
                        HANDLE * phPolicyStore
                        )
{
    DWORD dwError = 0;
    
    
    switch (dwTypeOfStore) {
        
    case WIRELESS_REGISTRY_PROVIDER:
        break;
        
    case WIRELESS_DIRECTORY_PROVIDER:
        
        dwError = DirGPOOpenPolicyStore(
            pszMachineName,
            pszGPOName,
            phPolicyStore
            );
        break;
        
    case WIRELESS_FILE_PROVIDER:
        break;
        
        
        
    case WIRELESS_WMI_PROVIDER:
        
        dwError = WMIOpenPolicyStore(
            pszMachineName,
            phPolicyStore
            );
        break;
        
        
        
    default:
        
        dwError = ERROR_INVALID_PARAMETER;
        break;
        
    }
    
    return (dwError);
}


DWORD
DirGPOOpenPolicyStore(
                   LPWSTR pszMachineName,
                   LPWSTR pszGPOName,
                   HANDLE * phPolicyStore
                   )
{
    PWIRELESS_POLICY_STORE pPolicyStore = NULL;
    DWORD dwError = 0;
    LPWSTR pszWirelessRootContainer = NULL;
    HLDAP hLdapBindHandle = NULL;
    LPWSTR pszDefaultDirectory = NULL;
    
    
    if (!pszMachineName || !*pszMachineName) {
        
        dwError = ComputeDefaultDirectory(
            &pszDefaultDirectory
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = OpenDirectoryServerHandle(
            pszDefaultDirectory,
            389,
            &hLdapBindHandle
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = ComputeGPODirLocationName(
            pszGPOName,
            &pszWirelessRootContainer
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
    }
    else {
        
        dwError = OpenDirectoryServerHandle(
            pszMachineName,
            389,
            &hLdapBindHandle
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = ComputeGPODirLocationName(
            pszGPOName,
            &pszWirelessRootContainer
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
    }
    
    pPolicyStore = (PWIRELESS_POLICY_STORE)AllocPolMem(
        sizeof(WIRELESS_POLICY_STORE)
        );
    if (!pPolicyStore) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pPolicyStore->dwProvider = WIRELESS_DIRECTORY_PROVIDER;
    pPolicyStore->hParentRegistryKey = NULL;
    pPolicyStore->hRegistryKey = NULL;
    pPolicyStore->pszLocationName = NULL;
    pPolicyStore->hLdapBindHandle = hLdapBindHandle;
    pPolicyStore->pszWirelessRootContainer = pszWirelessRootContainer;
    pPolicyStore->pszFileName = NULL;
    
    *phPolicyStore = pPolicyStore;
    
cleanup:
    
    if (pszDefaultDirectory) {
        FreePolStr(pszDefaultDirectory);
    }
    
    return(dwError);
    
error:
    
    if (hLdapBindHandle) {
        CloseDirectoryServerHandle(hLdapBindHandle);
    }
    
    if (pszWirelessRootContainer) {
        FreePolStr(pszWirelessRootContainer);
    }
    
    if (pPolicyStore) {
        FreePolMem(pPolicyStore);
    }
    
    *phPolicyStore = NULL;
    
    goto cleanup;
}

DWORD
WirelessClosePolicyStore(
                         HANDLE hPolicyStore
                         )
{
    DWORD dwError = 0;
    PWIRELESS_POLICY_STORE pPolicyStore = NULL;
    
    
    pPolicyStore = (PWIRELESS_POLICY_STORE)hPolicyStore;
    
    switch (pPolicyStore->dwProvider) {
        
    case WIRELESS_REGISTRY_PROVIDER:
        
        break;
        
    case WIRELESS_DIRECTORY_PROVIDER:
        
        if (pPolicyStore->hLdapBindHandle) {
            CloseDirectoryServerHandle(
                pPolicyStore->hLdapBindHandle
                );
        }
        
        if (pPolicyStore->pszWirelessRootContainer) {
            FreePolStr(pPolicyStore->pszWirelessRootContainer);
        }
        
        break;
        
    case WIRELESS_FILE_PROVIDER:
        
        break;
        
    default:
        
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;
        
    }
    
    if (pPolicyStore) {
        FreePolMem(pPolicyStore);
    }
    
error:
    
    return(dwError);
}

                                                                

                                                        
DWORD
ComputeGPODirLocationName(
                       LPWSTR pszDirDomainName,
                       LPWSTR * ppszDirFQPathName
                       )
{
    DWORD dwError = 0;
    WCHAR szName[MAX_PATH];
    LPWSTR pszDirFQPathName = NULL;
    DWORD dwDirDomainNameLen = 0;
    DWORD dwDirLocationNameLen = 0;
    DWORD dwTotalLen = 0;
    
    szName[0] = L'\0';
    wcscpy(szName, L"CN=Wireless, CN=Windows,CN=Microsoft,");

    dwDirDomainNameLen = wcslen(pszDirDomainName);
    dwDirLocationNameLen = wcslen(szName);
    dwTotalLen = dwDirDomainNameLen+dwDirLocationNameLen;
    
    pszDirFQPathName = AllocPolMem((dwTotalLen+1) * sizeof(WCHAR));
    if (!pszDirFQPathName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    wcsncpy(pszDirFQPathName, szName, dwDirLocationNameLen);
    wcsncat(pszDirFQPathName, pszDirDomainName, dwDirDomainNameLen);
    pszDirFQPathName[dwTotalLen] = L'\0';
    
    *ppszDirFQPathName = pszDirFQPathName;
    
    return (dwError);
    
error:
    
    *ppszDirFQPathName = NULL;
    return(dwError);

}

/*
Helper Function: Set PS in a Policy Structure
*/
                                                        
DWORD
WirelessSetPSDataInPolicy(
                          PWIRELESS_POLICY_DATA pWirelessPolicyData,
                          PWIRELESS_PS_DATA pWirelessPSData
                          )
{
    DWORD dwError = 0;
    DWORD dwPSId = -1;
    
    WirelessPolicyPSId(pWirelessPolicyData,
        pWirelessPSData->pszWirelessSSID,
        &dwPSId
        );
    
    if (dwPSId == -1) {
        dwError = ERROR_PS_NOT_PRESENT;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    dwError = ModifyWirelessPSData(
        pWirelessPolicyData->ppWirelessPSData[dwPSId],
        pWirelessPSData
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ERROR_SUCCESS;
    return(dwError);
    
error:
    return(dwError);
}


DWORD
WirelessAddPSToPolicy(
                      PWIRELESS_POLICY_DATA pWirelessPolicyData,
                      PWIRELESS_PS_DATA pWirelessPSData
                      )
{
    DWORD dwNumPreferredSettings = 0;
    DWORD dwError = 0;
    PWIRELESS_PS_DATA *ppWirelessPSData=NULL;
    PWIRELESS_PS_DATA *ppNewWirelessPSData=NULL;
    DWORD i = 0;
    DWORD dwInsertIndex = 0;
    DWORD dwNumAPNetworks = 0;
    
    dwNumPreferredSettings = pWirelessPolicyData->dwNumPreferredSettings;
    dwNumAPNetworks = pWirelessPolicyData->dwNumAPNetworks;
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    
    ppNewWirelessPSData = (PWIRELESS_PS_DATA *)
        AllocPolMem(sizeof(PWIRELESS_PS_DATA)*(dwNumPreferredSettings+1));
    
    if(!ppNewWirelessPSData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if(pWirelessPSData->dwNetworkType == WIRELESS_NETWORK_TYPE_ADHOC) {
        dwInsertIndex = dwNumPreferredSettings;
    } else
    {
        dwInsertIndex = dwNumAPNetworks;
        pWirelessPolicyData->dwNumAPNetworks = dwNumAPNetworks+1;
    }
    
    
    for (i = 0; i < dwInsertIndex; ++i)
    {
        ppNewWirelessPSData[i] = ppWirelessPSData[i];
    }
    
    ppNewWirelessPSData[dwInsertIndex] = pWirelessPSData;
    pWirelessPSData->dwId = dwInsertIndex;
    
    for (i = dwInsertIndex; i < dwNumPreferredSettings; ++i) {
        ppNewWirelessPSData[i+1] = ppWirelessPSData[i];
        ppNewWirelessPSData[i+1]->dwId = i+1;
    }
    
    
    pWirelessPolicyData->dwNumPreferredSettings = dwNumPreferredSettings+1;
    pWirelessPolicyData->ppWirelessPSData = ppNewWirelessPSData;
    
    FreePolMem(ppWirelessPSData);
    
    return(0);
    
error:
    return(dwError);
    
}

DWORD
WirelessRemovePSFromPolicy(
                           PWIRELESS_POLICY_DATA pWirelessPolicyData,
                           LPCWSTR pszSSID
                           )
{
    DWORD dwNumPreferredSettings = 0;
    DWORD dwError = 0;
    PWIRELESS_PS_DATA *ppWirelessPSData;
    PWIRELESS_PS_DATA *ppNewWirelessPSData;
    DWORD i = 0;
    DWORD dwPSId;
    
    dwNumPreferredSettings = pWirelessPolicyData->dwNumPreferredSettings;
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    
    WirelessPolicyPSId(pWirelessPolicyData,pszSSID,&dwPSId);
    
    if(dwPSId == -1)
    {
        dwError = ERROR_PS_NOT_PRESENT;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    ppNewWirelessPSData = (PWIRELESS_PS_DATA *)
        AllocPolMem(sizeof(PWIRELESS_PS_DATA)*(dwNumPreferredSettings-1));
    
    if(!ppNewWirelessPSData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    
    for(i = 0; i < dwPSId; ++i)
    {
        ppNewWirelessPSData[i] = ppWirelessPSData[i];
    }
    
    for(i = dwPSId; i < dwNumPreferredSettings-1; ++i)
    {
        ppNewWirelessPSData[i] = ppWirelessPSData[i+1];
    }
    
    pWirelessPolicyData->dwNumPreferredSettings = dwNumPreferredSettings-1;
    pWirelessPolicyData->ppWirelessPSData = ppNewWirelessPSData;
    
    FreePolMem(ppWirelessPSData);
    
    return(0);
    
error:
    return(dwError);
    
}

DWORD
WirelessRemovePSFromPolicyId(
                             PWIRELESS_POLICY_DATA pWirelessPolicyData,
                             DWORD dwId
                             )
{
    DWORD dwNumPreferredSettings = 0;
    DWORD dwError = 0;
    PWIRELESS_PS_DATA *ppWirelessPSData;
    PWIRELESS_PS_DATA *ppNewWirelessPSData;
    DWORD i = 0;
    DWORD dwPSId;
    
    dwNumPreferredSettings = pWirelessPolicyData->dwNumPreferredSettings;
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    
    
    if(dwId >= dwNumPreferredSettings )
    {
        dwError = ERROR_PS_NOT_PRESENT;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    ppNewWirelessPSData = (PWIRELESS_PS_DATA *)
        AllocPolMem(sizeof(PWIRELESS_PS_DATA)*(dwNumPreferredSettings-1));
    
    if(!ppNewWirelessPSData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    
    for(i = 0; i < dwId; ++i)
    {
        ppNewWirelessPSData[i] = ppWirelessPSData[i];
    }
    
    if (ppWirelessPSData[dwId]->dwNetworkType == WIRELESS_NETWORK_TYPE_AP) {
        pWirelessPolicyData->dwNumAPNetworks--;
    }
    
    for(i = dwId; i < dwNumPreferredSettings-1; ++i)
    {
        ppNewWirelessPSData[i] = ppWirelessPSData[i+1];
        ppNewWirelessPSData[i]->dwId = i;
    }
    
    pWirelessPolicyData->dwNumPreferredSettings = dwNumPreferredSettings-1;
    pWirelessPolicyData->ppWirelessPSData = ppNewWirelessPSData;
    
    FreePolMem(ppWirelessPSData);
    
    return(0);
    
error:
    return(dwError);
    
}

void
WirelessPolicyPSId(PWIRELESS_POLICY_DATA pWirelessPolicyData, LPCWSTR pszSSID, DWORD *dwId)
{
    
    DWORD dwError=0;
    DWORD dwNumPreferredSettings;
    DWORD dwSSIDLen = 0;
    DWORD i = 0;
    DWORD dwCompare = 1;
    DWORD dwPId = -1;
    PWIRELESS_PS_DATA *ppWirelessPSData;
    PWIRELESS_PS_DATA pWirelessPSData;
    
    
    dwSSIDLen = lstrlenW(pszSSID);
    dwNumPreferredSettings = pWirelessPolicyData->dwNumPreferredSettings;
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    
    for(i = 0; i < dwNumPreferredSettings; ++i) {
        pWirelessPSData = ppWirelessPSData[i];
        if(pWirelessPSData->dwWirelessSSIDLen == dwSSIDLen)
        {
            dwCompare = memcmp(pWirelessPSData->pszWirelessSSID,pszSSID,dwSSIDLen*2);
        }
        if (dwCompare == 0) {
            dwPId = i;
            break;
        }
    }
    *dwId = dwPId;
    return;
    
}

void
UpdateWirelessPSData(
                     PWIRELESS_PS_DATA pWirelessPSData
                     )
{
    DWORD dwDescriptionLen = 0;
    DWORD dwEAPDataLen = 0;
    DWORD dwWirelessSSIDLen = 0;
    DWORD dwPSLen = 0;
    
    // may be replace it with actual counting.
    
    dwWirelessSSIDLen  = lstrlenW(pWirelessPSData->pszWirelessSSID);
    dwDescriptionLen = lstrlenW(pWirelessPSData->pszDescription);
    //dwPSLen = 20 * sizeof(DWORD) + 32*2 + 2 * dwDescriptionLen;
    dwEAPDataLen = pWirelessPSData->dwEAPDataLen;
    dwPSLen = (sizeof(WIRELESS_PS_DATA) - sizeof(DWORD) - sizeof(LPWSTR)) + sizeof(WCHAR) * dwDescriptionLen
        - sizeof(LPBYTE) + dwEAPDataLen;
    pWirelessPSData->dwPSLen = dwPSLen;
    pWirelessPSData->dwWirelessSSIDLen = 
        (dwWirelessSSIDLen < 32) ? dwWirelessSSIDLen : 32;
    pWirelessPSData->dwDescriptionLen = dwDescriptionLen;
}





DWORD
WMIOpenPolicyStore(
                   LPWSTR pszMachineName,
                   HANDLE * phPolicyStore
                   )
{
    PWIRELESS_POLICY_STORE pPolicyStore = NULL;
    DWORD dwError = 0;
    
    pPolicyStore = (PWIRELESS_POLICY_STORE)AllocPolMem(
        sizeof(WIRELESS_POLICY_STORE)
        );
    if (!pPolicyStore) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pPolicyStore->dwProvider = WIRELESS_WMI_PROVIDER;
    pPolicyStore->hParentRegistryKey = NULL;
    pPolicyStore->hRegistryKey = NULL;
    pPolicyStore->pszLocationName = pszMachineName;
    pPolicyStore->hLdapBindHandle = NULL;
    pPolicyStore->pszWirelessRootContainer = NULL;
    pPolicyStore->pszFileName = NULL;
    
    *phPolicyStore = pPolicyStore;
    
cleanup:
    
    return(dwError);
    
error:
    
    if (pPolicyStore) {
        FreePolMem(pPolicyStore);
    }
    
    *phPolicyStore = NULL;
    
    goto cleanup;
}


HRESULT
WirelessWriteDirectoryPolicyToWMI(
                          LPWSTR pszMachineName,
                          LPWSTR pszPolicyDN,
                          PGPO_INFO pGPOInfo,
                          IWbemServices *pWbemServices
                          )
{
    DWORD dwError = 0;
    HRESULT hr = S_OK;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    BOOL bDeepRead = FALSE;

    if (!pWbemServices
    	|| !pszPolicyDN
    	|| !pGPOInfo
    	)
    {
        hr = E_INVALIDARG;
        BAIL_ON_HRESULT_ERROR(hr);
    }

    
    bDeepRead = (pGPOInfo->uiPrecedence == 1);
    
    hr = ReadPolicyObjectFromDirectoryEx(
        pszMachineName,
        pszPolicyDN,
        bDeepRead,
        &pWirelessPolicyObject
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    hr = WritePolicyObjectDirectoryToWMI(
        pWbemServices,
        pWirelessPolicyObject,
        pGPOInfo
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
error:

    if (pWirelessPolicyObject) {
    	FreeWirelessPolicyObject(pWirelessPolicyObject);
    	}
    
    return(hr);
}


HRESULT
WirelessClearWMIStore(
    IWbemServices *pWbemServices
    )
{
    HRESULT hr = S_OK;
    
    if (!pWbemServices) {
        hr = E_INVALIDARG;
        BAIL_ON_HRESULT_ERROR(hr);
    }

    hr = DeleteWMIClassObject(
        pWbemServices,
        WIRELESS_RSOP_CLASSNAME
        );
    BAIL_ON_HRESULT_ERROR(hr);

 error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\connui.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Connui.c
//
//  Contents:   Wifi Policy management Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//   This file is not used in the wireless snapin. However, these calls may be useful.
//
//----------------------------------------------------------------------------
#include "precomp.h"



LPWSTR gpszWirelessDSPolicyKey = L"SOFTWARE\\Policies\\Microsoft\\Windows\\WiFi\\GPTWiFiPolicy";

DWORD
WirelessIsDomainPolicyAssigned(
    PBOOL pbIsDomainPolicyAssigned
    )
{
    DWORD dwError = 0;
    BOOL bIsDomainPolicyAssigned = FALSE;
    HKEY hRegistryKey = NULL;
    DWORD dwType = 0;
    DWORD dwDSPolicyPathLength = 0;


    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  (LPCWSTR) gpszWirelessDSPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegQueryValueExW(
                  hRegistryKey,
                  L"DSWiFiPolicyPath",
                  NULL,
                  &dwType,
                  NULL,
                  &dwDSPolicyPathLength
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwDSPolicyPathLength > 0) {
        bIsDomainPolicyAssigned = TRUE;
    }

    *pbIsDomainPolicyAssigned = bIsDomainPolicyAssigned;

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    *pbIsDomainPolicyAssigned = FALSE;
 
    goto cleanup;
}


DWORD
WirelessGetAssignedDomainPolicyName(
    LPWSTR * ppszAssignedDomainPolicyName
    )
{
    DWORD dwError = 0;
    LPWSTR pszAssignedDomainPolicyName = NULL;
    HKEY hRegistryKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;


    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  (LPCWSTR) gpszWirelessDSPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegistryKey,
                  L"DSWiFiPolicyName",
                  REG_SZ,
                  (LPBYTE *)&pszAssignedDomainPolicyName,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppszAssignedDomainPolicyName = pszAssignedDomainPolicyName;

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    *ppszAssignedDomainPolicyName = NULL;
 
    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlsnp\wiz97pol.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       wiz97pol.cpp
//
//  Contents:  WiF Policy Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include "Wiz97Pol.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef WIZ97WIZARDS

/////////////////////////////////////////////////////////////////////////////
//
// Wiz97 dialogs for the Create New Policy wizard
//  CWiz97PolicyWelcomePage NOTE: not yet implemeneted
//  uses CWiz97GenPage
//  CWiz97DefaultResponse
//  CWiz97PolicyDonePage
//
/////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////
// CWiz97PolicyDonePage Class
//////////////////////////////////////////////////////////////////////

CWiz97PolicyDonePage::CWiz97PolicyDonePage (UINT nIDD, BOOL bWiz97) :
CWiz97BasePage(nIDD, bWiz97, TRUE)
{
    //{{AFX_DATA_INIT(CWiz97PolicyDonePage)
    m_bCheckProperties = TRUE;
    //}}AFX_DATA_INIT
}

CWiz97PolicyDonePage::~CWiz97PolicyDonePage()
{
    
}

void CWiz97PolicyDonePage::DoDataExchange(CDataExchange* pDX)
{
    CWiz97BasePage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWiz97PolicyDonePage)
    DDX_Check(pDX, IDC_CHECKPROPERTIES, m_bCheckProperties);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWiz97PolicyDonePage, CWiz97BasePage)
//{{AFX_MSG_MAP(CWiz97PolicyDonePage)
// NOTE: the ClassWizard will add message map macros here
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CWiz97PolicyDonePage::OnWizardFinish ()
{
    // check the settings
    UpdateData (TRUE);
    
    if (m_bCheckProperties)
    {
        // Force property page to be displayed, when we get back from the wizard
        GetResultObject()->EnablePropertyChangeHook( TRUE );
    }
    
    // Base class will let the other pages know the wizard finished by
    // calling SetFinished().
    return CWiz97BasePage::OnWizardFinish();
}

#endif // #ifdef WIZ97WIZARDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\connui.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Connui.h
//
//  Contents:   Wifi Policy management Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

DWORD
WirelessIsDomainPolicyAssigned(
                               PBOOL pbIsDomainPolicyAssigned
                               );


DWORD
WirelessGetAssignedDomainPolicyName(
                                    LPWSTR * ppszAssignedDomainPolicyName
                                    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\dllsvr.c ===
#include "precomp.h"

#define COUNTOF(x) (sizeof x/sizeof *x)

//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Dllsvr.c
//
//  Contents:   Wifi Policy management Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

DWORD
DllRegisterServer()
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    HKEY hOakleyKey = NULL;
    DWORD dwDisposition = 0;
    DWORD dwTypesSupported = 7;
    HKEY hPolicyLocationKey = NULL;
    HANDLE hPolicyStore = NULL;
    
    return (dwError);
}
                  

DWORD
DllUnregisterServer()
{
    return (ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\ldaputils.h ===
DWORD
AllocateLDAPStringValue(
                        LPWSTR pszString,
                        PLDAPOBJECT * ppLdapObject
                        );

DWORD
AllocateLDAPBinaryValue(
                        LPBYTE pByte,
                        DWORD dwNumBytes,
                        PLDAPOBJECT * ppLdapObject
                        );

void
FreeLDAPModWs(
              LDAPModW ** ppLDAPModW
              );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\memory.c ===
#include "precomp.h"


LPVOID
WirelessAllocPolMem(
                 DWORD cb
                 )
{
    return AllocPolMem(cb);
}


BOOL
WirelessFreePolMem(
                LPVOID pMem
                )
{
    return FreePolMem(pMem);
}


LPWSTR
WirelessAllocPolStr(
                 LPCWSTR pStr
                 )
{
    return AllocPolStr(pStr);
}


BOOL
WirelessFreePolStr(
                LPWSTR pStr
                )
{
    return FreePolStr(pStr);
}


DWORD
WirelessReallocatePolMem(
                      LPVOID * ppOldMem,
                      DWORD cbOld,
                      DWORD cbNew
                      )
{
    return ReallocatePolMem(ppOldMem, cbOld, cbNew);
}


BOOL
WirelessReallocatePolStr(
                      LPWSTR *ppStr,
                      LPWSTR pStr
                      )
{
    return ReallocPolStr(ppStr, pStr);
}

void
WirelessFreePolicyData(
                       PWIRELESS_POLICY_DATA pWirelessPolicyData
                       )
{
    FreeWirelessPolicyData(pWirelessPolicyData);
}



DWORD
WirelessCopyPolicyData(
                       PWIRELESS_POLICY_DATA pWirelessPolicyData,
                       PWIRELESS_POLICY_DATA * ppWirelessPolicyData
                       )
{
    return CopyWirelessPolicyData(pWirelessPolicyData, ppWirelessPolicyData);
}


void
WirelessFreeMulPolicyData(
                          PWIRELESS_POLICY_DATA * ppWirelessPolicyData,
                          DWORD dwNumPolicyObjects
                          )
{
    FreeMulWirelessPolicyData(ppWirelessPolicyData, dwNumPolicyObjects);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\ldaputils.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       ldaputils.c
//
//  Contents:   Utilities for LDAP.
//
//
//  History:    KrishnaG
//              AbhisheV
//
//----------------------------------------------------------------------------


#include "precomp.h"


void
FreeLDAPModWs(
              struct ldapmodW ** AttributeList
              )
{
    DWORD i = 0;
    PLDAPModW attr = NULL;
    DWORD dwValCount = 0;
    PLDAP_BERVAL berValue = NULL;
    PWCHAR strValue = NULL;
    
    
    if (AttributeList == NULL) {
        return;
    }
    
    while (AttributeList[i] != NULL) {
        
        attr = AttributeList[i++];
        
        if (attr->mod_type != NULL) {
            FreePolStr(attr->mod_type);
        }
        
        if (attr->mod_op & LDAP_MOD_BVALUES) {
            
            if (attr->mod_vals.modv_bvals != NULL) {
                
                dwValCount = 0;
                
                while (attr->mod_vals.modv_bvals[dwValCount]) {
                    
                    berValue = attr->mod_vals.modv_bvals[dwValCount++];
                    FreePolMem(berValue);
                    
                }
                
                FreePolMem(attr->mod_vals.modv_bvals);
                
            }
            
        } else {
            
            if (attr->mod_vals.modv_strvals != NULL) {
                
                dwValCount = 0;
                
                while (attr->mod_vals.modv_strvals[dwValCount]) {
                    
                    strValue = attr->mod_vals.modv_strvals[dwValCount];
                    FreePolMem(strValue);
                    dwValCount++;
                    
                }
                
                FreePolMem(attr->mod_vals.modv_strvals);
                
            }
            
        }
        
    }
    
    FreePolMem(AttributeList[0]);
    
    FreePolMem(AttributeList);
    
    return;
}


DWORD
AllocateLDAPStringValue(
                        LPWSTR pszString,
                        PLDAPOBJECT * ppLdapObject
                        )
{
    PLDAPOBJECT pLdapObject = NULL;
    DWORD dwError = 0;
    LPWSTR pszNewString = NULL;
    
    pLdapObject = (PLDAPOBJECT)AllocPolMem(
        (1 + 1)*sizeof(LDAPOBJECT)
        );
    if (!pLdapObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    dwError = AllocatePolString(
        pszString,
        &pszNewString
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    LDAPOBJECT_STRING(pLdapObject) = pszNewString;
    
    *ppLdapObject = pLdapObject;
    
    return(dwError);
    
error:
    
    *ppLdapObject = NULL;
    if (pLdapObject) {
        FreePolMem(
            pLdapObject
            );
    }
    
    return(dwError);
}


DWORD
AllocateLDAPBinaryValue(
                        LPBYTE pByte,
                        DWORD dwNumBytes,
                        PLDAPOBJECT * ppLdapObject
                        )
{
    PLDAPOBJECT pLdapObject = NULL;
    DWORD dwError = 0;
    LPBYTE pNewMem = NULL;
    
    pLdapObject = (PLDAPOBJECT)AllocPolMem(
        (1 + 1)*sizeof(LDAPOBJECT)
        );
    if (!pLdapObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    
    LDAPOBJECT_BERVAL(pLdapObject) =
        (struct berval *) AllocPolMem( sizeof(struct berval) + dwNumBytes );
    
    if (!LDAPOBJECT_BERVAL(pLdapObject)) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    
    LDAPOBJECT_BERVAL_LEN(pLdapObject) = dwNumBytes;
    LDAPOBJECT_BERVAL_VAL(pLdapObject) = (CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapObject) + sizeof(struct berval));
    
    memcpy( LDAPOBJECT_BERVAL_VAL(pLdapObject),
        pByte,
        dwNumBytes );
    
    *ppLdapObject = pLdapObject;
    
    return(dwError);
    
error:
    
    *ppLdapObject = NULL;
    if (pLdapObject) {
        FreePolMem(
            pLdapObject
            );
    }
    
    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\init.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       init.c
//
//  Contents:  Holds initialization code for wlstore.dll
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

#include "precomp.h"

HANDLE hInst;


BOOL
InitializeDll(
              IN PVOID hmod,
              IN DWORD Reason,
              IN PCONTEXT pctx OPTIONAL)
{
    DBG_UNREFERENCED_PARAMETER(pctx);
    
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        
        DisableThreadLibraryCalls((HMODULE)hmod);
        hInst = hmod;
        break;
        
    case DLL_PROCESS_DETACH:
        break;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\policy-d.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       policy-d.c
//
//  Contents:  Policy management for directory.
//
//
//  History:    TaroonM (10/30/01)
//              AbhisheV (05/11/00)
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR PolicyDNAttributes[];

DWORD
DirEnumWirelessPolicyData(
                          HLDAP hLdapBindHandle,
                          LPWSTR pszWirelessRootContainer,
                          PWIRELESS_POLICY_DATA ** pppWirelessPolicyData,
                          PDWORD pdwNumPolicyObjects
                          )
{
    DWORD dwError = 0;
    PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObjects = NULL;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    PWIRELESS_POLICY_DATA * ppWirelessPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD i = 0;
    DWORD j = 0;
    
    
    dwError = DirEnumPolicyObjects(
        hLdapBindHandle,
        pszWirelessRootContainer,
        &ppWirelessPolicyObjects,
        &dwNumPolicyObjects
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    if (dwNumPolicyObjects) {
        ppWirelessPolicyData = (PWIRELESS_POLICY_DATA *) AllocPolMem(
            dwNumPolicyObjects*sizeof(PWIRELESS_POLICY_DATA));
        if (!ppWirelessPolicyData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    for (i = 0; i < dwNumPolicyObjects; i++) {
        
        dwError = DirUnmarshallWirelessPolicyData(
            *(ppWirelessPolicyObjects + i),
            &pWirelessPolicyData
            );
        if (!dwError) {
            *(ppWirelessPolicyData + j) = pWirelessPolicyData;
            j++;
        }
    }
    
    if (j == 0) {
        if (ppWirelessPolicyData) {
            FreePolMem(ppWirelessPolicyData);
            ppWirelessPolicyData = NULL;
        }
    }
    
    *pppWirelessPolicyData = ppWirelessPolicyData;
    *pdwNumPolicyObjects = j;
    
    dwError = ERROR_SUCCESS;
    
cleanup:
    
    if (ppWirelessPolicyObjects) {
        FreeWirelessPolicyObjects(
            ppWirelessPolicyObjects,
            dwNumPolicyObjects
            );
    }
    
    return(dwError);
    
error:
    
    if (ppWirelessPolicyData) {
        FreeMulWirelessPolicyData(
            ppWirelessPolicyData,
            i
            );
    }
    
    *pppWirelessPolicyData = NULL;
    *pdwNumPolicyObjects = 0;
    
    goto cleanup;
}

DWORD
DirEnumPolicyObjects(
                     HLDAP hLdapBindHandle,
                     LPWSTR pszWirelessRootContainer,
                     PWIRELESS_POLICY_OBJECT ** pppWirelessPolicyObjects,
                     PDWORD pdwNumPolicyObjects
                     )
{
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszPolicyString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject =  NULL;
    PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObjects = NULL;
    
    DWORD dwNumPolicyObjectsReturned = 0;
    
    dwError = GenerateAllPolicyQuery(
        &pszPolicyString
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = LdapSearchST(
        hLdapBindHandle,
        pszWirelessRootContainer,
        LDAP_SCOPE_ONELEVEL,
        pszPolicyString,
        PolicyDNAttributes,
        0,
        NULL,
        &res
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwCount = LdapCountEntries(
        hLdapBindHandle,
        res
        );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    ppWirelessPolicyObjects  = (PWIRELESS_POLICY_OBJECT *)AllocPolMem(
        sizeof(PWIRELESS_POLICY_OBJECT)*dwCount
        );
    
    if (!ppWirelessPolicyObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    
    for (i = 0; i < dwCount; i++) {
        
        if (i == 0) {
            
            dwError = LdapFirstEntry(
                hLdapBindHandle,
                res,
                &e
                );
            BAIL_ON_WIN32_ERROR(dwError);
            
        } else {
            
            dwError = LdapNextEntry(
                hLdapBindHandle,
                e,
                &e
                );
            BAIL_ON_WIN32_ERROR(dwError);
            
        }
        
        dwError = UnMarshallPolicyObject2(
            hLdapBindHandle,
            e,
            &pWirelessPolicyObject
            );
        if (dwError == ERROR_SUCCESS) {
            *(ppWirelessPolicyObjects + dwNumPolicyObjectsReturned) = pWirelessPolicyObject;
            dwNumPolicyObjectsReturned++;
        }
        
    }
    
    *pppWirelessPolicyObjects = ppWirelessPolicyObjects;
    *pdwNumPolicyObjects = dwNumPolicyObjectsReturned;
    
    dwError = ERROR_SUCCESS;
    
cleanup:
    
    if (pszPolicyString) {
        FreePolMem(pszPolicyString);
    }
    
    if (res) {
        LdapMsgFree(res);
    }
    
    return(dwError);
    
error:
    
    if (ppWirelessPolicyObjects) {
        FreeWirelessPolicyObjects(
            ppWirelessPolicyObjects,
            dwNumPolicyObjectsReturned
            );
    }
    
    *pppWirelessPolicyObjects = NULL;
    *pdwNumPolicyObjects = 0;
    
    goto cleanup;
}


DWORD
GenerateAllPolicyQuery(
                       LPWSTR * ppszPolicyString
                       )
{
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszPolicyString = NULL;
    
    
    //
    // Compute Length of Buffer to be allocated
    //
    
    dwLength = wcslen(L"(objectclass=msieee80211-Policy)");
    
    pszPolicyString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));
    
    if (!pszPolicyString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    //
    // Now fill in the buffer
    //
    
    wcscpy(pszPolicyString, L"(objectclass=msieee80211-Policy)");
    
    *ppszPolicyString = pszPolicyString;
    
    return(0);
    
error:
    
    if (pszPolicyString) {
        FreePolMem(pszPolicyString);
    }
    
    *ppszPolicyString = NULL;
    
    return(dwError);
}


DWORD
UnMarshallPolicyObject2(
                        HLDAP hLdapBindHandle,
                        LDAPMessage *e,
                        PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
                        )
{
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszTemp = NULL;
    
    
    pWirelessPolicyObject = (PWIRELESS_POLICY_OBJECT)AllocPolMem(
        sizeof(WIRELESS_POLICY_OBJECT)
        );
    if (!pWirelessPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    
    strvalues = NULL;
    dwError = LdapGetValues(
        hLdapBindHandle,
        e,
        L"distinguishedName",
        (WCHAR ***)&strvalues,
        (int *)&dwCount
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pWirelessPolicyObject->pszWirelessOwnersReference = AllocPolStr(
        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
        );
    if (!pWirelessPolicyObject->pszWirelessOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);
    
    
    strvalues = NULL;
    dwError = LdapGetValues(
        hLdapBindHandle,
        e,
        L"cn",
        (WCHAR ***)&strvalues,
        (int *)&dwCount
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pWirelessPolicyObject->pszWirelessName = AllocPolStr(
        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
        );
    if (!pWirelessPolicyObject->pszWirelessName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);
    
    
    strvalues = NULL;
    dwError = LdapGetValues(
        hLdapBindHandle,
        e,
        L"description",
        (WCHAR ***)&strvalues,
        (int *)&dwCount
        );
    // BAIL_ON_WIN32_ERROR(dwError);
    
    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {
        
        pWirelessPolicyObject->pszDescription = AllocPolStr(
            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
            );
        if (!pWirelessPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);
        
    } else {
        pWirelessPolicyObject->pszDescription = NULL;
    }
    
    
    strvalues = NULL;
    dwError = LdapGetValues(
        hLdapBindHandle,
        e,
        L"msieee80211-ID",
        (WCHAR ***)&strvalues,
        (int *)&dwCount
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pWirelessPolicyObject->pszWirelessID = AllocPolStr(
        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
        );
    if (!pWirelessPolicyObject->pszWirelessID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);
    
    
    strvalues = NULL;
    dwError = LdapGetValues(
        hLdapBindHandle,
        e,
        L"msieee80211-DataType",
        (WCHAR ***)&strvalues,
        (int *)&dwCount
        );
    BAIL_ON_WIN32_ERROR(dwError);
    pWirelessPolicyObject->dwWirelessDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);
    
    
    strvalues = NULL;
    dwError = LdapGetValues(
        hLdapBindHandle,
        e,
        L"whenChanged",
        (WCHAR ***)&strvalues,
        (int *)&dwCount
        );
    BAIL_ON_WIN32_ERROR(dwError);
    pWirelessPolicyObject->dwWhenChanged = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);
    
    
    //
    // unmarshall the msieee80211-Data blob
    //
    
    dwError = LdapGetValuesLen(
        hLdapBindHandle,
        e,
        L"msieee80211-Data",
        (struct berval ***)&bvalues,
        (int *)&dwCount
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pWirelessPolicyObject->pWirelessData = pBuffer;
    pWirelessPolicyObject->dwWirelessDataLen = dwLen;
    LdapValueFreeLen(bvalues);
    
    
    *ppWirelessPolicyObject = pWirelessPolicyObject;
    
    return(dwError);
    
error:
    
    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyObject);
    }
    
    *ppWirelessPolicyObject = NULL;
    
    return(dwError);
}



DWORD
DirUnmarshallWirelessPolicyData(
                                PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                                PWIRELESS_POLICY_DATA * ppWirelessPolicyData
                                )
{
    DWORD dwError = 0;
    
    dwError = UnmarshallWirelessPolicyObject(
        pWirelessPolicyObject,
        WIRELESS_DIRECTORY_PROVIDER,
        ppWirelessPolicyData
        );
    
    return(dwError);
}


DWORD
DirCreateWirelessPolicyData(
                            HLDAP hLdapBindHandle,
                            LPWSTR pszWirelessRootContainer,
                            PWIRELESS_POLICY_DATA pWirelessPolicyData
                            )
{
    DWORD dwError = 0;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    
    dwError = DirMarshallWirelessPolicyObject(
        pWirelessPolicyData,
        pszWirelessRootContainer,
        &pWirelessPolicyObject
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = DirCreatePolicyObject(
        hLdapBindHandle,
        pszWirelessRootContainer,
        pWirelessPolicyObject
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
error:
    
    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(
            pWirelessPolicyObject
            );
    }
    
    return(dwError);
}



DWORD
DirMarshallWirelessPolicyObject(
                                PWIRELESS_POLICY_DATA pWirelessPolicyData,
                                LPWSTR pszWirelessRootContainer,
                                PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
                                )
{
    DWORD dwError = 0;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    WCHAR szGuid[MAX_PATH];
    LPWSTR pszDistinguishedName = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    DWORD dwCNLen = 0;
    DWORD dwContainerLen = 0;
    DWORD dwTotalLen = 0;
    LPWSTR pszWirelessOwnersReference = NULL;
    LPWSTR pszOldWirelessOwnersReference = NULL;
    
    
    szGuid[0] = L'\0';
    pWirelessPolicyObject = (PWIRELESS_POLICY_OBJECT)AllocPolMem(
        sizeof(WIRELESS_POLICY_OBJECT)
        );
    if (!pWirelessPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pWirelessPolicyObject->pszOldWirelessOwnersReferenceName = NULL;
    
    dwError = UuidToString(
        &pWirelessPolicyData->PolicyIdentifier,
        &pszStringUuid
        );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");
    
    //
    // Fill in the distinguishedName
    //

    dwCNLen = wcslen(L"CN=") + wcslen(pWirelessPolicyData->pszWirelessName) + wcslen(L",");
    dwContainerLen = wcslen(pszWirelessRootContainer);
    dwTotalLen = dwCNLen + dwContainerLen;

    pszWirelessOwnersReference = AllocPolMem(
    	(dwTotalLen + 1) * sizeof(WCHAR)
    	);
    if (!pszWirelessOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    wcsncpy(pszWirelessOwnersReference, L"CN=", wcslen(L"CN="));
    wcscat(pszWirelessOwnersReference,pWirelessPolicyData->pszWirelessName);
    wcscat(pszWirelessOwnersReference, L",");
    wcscat(pszWirelessOwnersReference, pszWirelessRootContainer);

    pszWirelessOwnersReference[dwTotalLen] = L'\0';
    
    pWirelessPolicyObject->pszWirelessOwnersReference = pszWirelessOwnersReference;

    if (pWirelessPolicyData->pszOldWirelessName) {

       dwCNLen = wcslen(L"CN=") + wcslen(pWirelessPolicyData->pszOldWirelessName) + wcslen(L",");
       // we already have the container len;
       dwTotalLen = dwCNLen + dwContainerLen;

       pszOldWirelessOwnersReference = (LPWSTR) AllocPolMem(
       	(dwTotalLen +1) * sizeof(WCHAR)
       	);

       if (!pszOldWirelessOwnersReference) {
       	dwError = ERROR_OUTOFMEMORY;
       	}
       BAIL_ON_WIN32_ERROR(dwError);
       
    	wcsncpy(pszOldWirelessOwnersReference,L"CN=", wcslen(L"CN="));
       wcscat(pszOldWirelessOwnersReference, pWirelessPolicyData->pszOldWirelessName);
       wcscat(pszOldWirelessOwnersReference, L",");
       wcscat(pszOldWirelessOwnersReference, pszWirelessRootContainer);

       pszOldWirelessOwnersReference[dwTotalLen] = L'\0';
    
       pWirelessPolicyObject->pszOldWirelessOwnersReferenceName = 
       	pszOldWirelessOwnersReference;
    
    }
    
    //
    // Fill in the msieee80211-Name
    //
    
    if (pWirelessPolicyData->pszWirelessName &&
        *pWirelessPolicyData->pszWirelessName) {
        
        pWirelessPolicyObject->pszWirelessName = AllocPolStr(
            pWirelessPolicyData->pszWirelessName
            );
        if (!pWirelessPolicyObject->pszWirelessName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    if (pWirelessPolicyData->pszDescription &&
        *pWirelessPolicyData->pszDescription) {
        
        pWirelessPolicyObject->pszDescription = AllocPolStr(
            pWirelessPolicyData->pszDescription
            );
        if (!pWirelessPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    //
    // Fill in the msieee80211-ID
    //
    
    pWirelessPolicyObject->pszWirelessID = AllocPolStr(
        szGuid
        );
    if (!pWirelessPolicyObject->pszWirelessID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    //
    // Fill in the msieee80211-DataType
    //
    
    pWirelessPolicyObject->dwWirelessDataType = 0x100;
    
    
    //
    // Marshall the pWirelessDataBuffer and the Length
    //
    
    dwError = MarshallWirelessPolicyBuffer(
        pWirelessPolicyData,
        &pBuffer,
        &dwBufferLen
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pWirelessPolicyObject->pWirelessData  = pBuffer;
    pWirelessPolicyObject->dwWirelessDataLen = dwBufferLen;
    
    
    pWirelessPolicyObject->dwWhenChanged = 0;
    
    *ppWirelessPolicyObject = pWirelessPolicyObject;
    
cleanup:
    
    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }
    
    return(dwError);
    
error:
    
    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(
            pWirelessPolicyObject
            );
    }
    
    *ppWirelessPolicyObject = NULL;
    goto cleanup;
}


DWORD
DirCreatePolicyObject(
                      HLDAP hLdapBindHandle,
                      LPWSTR pszWirelessRootContainer,
                      PWIRELESS_POLICY_OBJECT pWirelessPolicyObject
                      )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;
    
    
    dwError = DirMarshallAddPolicyObject(
        hLdapBindHandle,
        pszWirelessRootContainer,
        pWirelessPolicyObject,
        &ppLDAPModW
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = LdapAddS(
        hLdapBindHandle,
        pWirelessPolicyObject->pszWirelessOwnersReference,
        ppLDAPModW
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
error:
    
    //
    // Free the amods structures.
    //
    
    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }
    
    return(dwError);
}


DWORD
DirMarshallAddPolicyObject(
                           HLDAP hLdapBindHandle,
                           LPWSTR pszWirelessRootContainer,
                           PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                           LDAPModW *** pppLDAPModW
                           )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 5;
    DWORD dwError = 0;
    WCHAR Buffer[64];
    
    
    if (!pWirelessPolicyObject->pszWirelessName ||
        !*pWirelessPolicyObject->pszWirelessName) {
        dwNumAttributes--;
    }
    
    if (!pWirelessPolicyObject->pszDescription ||
        !*pWirelessPolicyObject->pszDescription) {
        dwNumAttributes--;
    }
    
    ppLDAPModW = (LDAPModW **) AllocPolMem(
        (dwNumAttributes+1) * sizeof(LDAPModW*)
        );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pLDAPModW = (LDAPModW *) AllocPolMem(
        dwNumAttributes * sizeof(LDAPModW)
        );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    //
    // 0. objectClass
    //
    
    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
        L"objectClass",
        &(pLDAPModW +i)->mod_type
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = AllocateLDAPStringValue(
        L"msieee80211-Policy",
        (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;
    
    i++;
    
    //
    // 2. msieee80211-ID
    //
    
    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
        L"msieee80211-ID",
        &(pLDAPModW +i)->mod_type
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = AllocateLDAPStringValue(
        pWirelessPolicyObject->pszWirelessID,
        (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;
    
    i++;
    
    //
    // 3. msieee80211-DataType
    //
    
    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
        L"msieee80211-DataType",
        &(pLDAPModW +i)->mod_type
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    _itow( pWirelessPolicyObject->dwWirelessDataType, Buffer, 10 );
    
    dwError = AllocateLDAPStringValue(
        Buffer,
        (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;
    
    i++;
    
    //
    // 4. msieee80211-Data
    //
    
    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
        L"msieee80211-Data",
        &(pLDAPModW +i)->mod_type
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = AllocateLDAPBinaryValue(
        pWirelessPolicyObject->pWirelessData,
        pWirelessPolicyObject->dwWirelessDataLen,
        (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    
    i++;
    
    //
    // 5. description
    //
    
    if (pWirelessPolicyObject->pszDescription &&
        *pWirelessPolicyObject->pszDescription) {
        
        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
            L"description",
            &(pLDAPModW +i)->mod_type
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = AllocateLDAPStringValue(
            pWirelessPolicyObject->pszDescription,
            (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;
        
        i++;
        
    }
    
    *pppLDAPModW = ppLDAPModW;
    
    return(dwError);
    
error:
    
    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }
    
    *pppLDAPModW = NULL;
    
    return(dwError);
}



DWORD
DirSetWirelessPolicyData(
                         HLDAP hLdapBindHandle,
                         LPWSTR pszWirelessRootContainer,
                         PWIRELESS_POLICY_DATA pWirelessPolicyData
                         )
{
    DWORD dwError = 0;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    
    
    dwError = DirMarshallWirelessPolicyObject(
        pWirelessPolicyData,
        pszWirelessRootContainer,
        &pWirelessPolicyObject
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    dwError = DirSetPolicyObject(
        hLdapBindHandle,
        pszWirelessRootContainer,
        pWirelessPolicyObject
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
error:
    
    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyObject);
    }
    
    return(dwError);
}


DWORD
DirSetPolicyObject(
                   HLDAP hLdapBindHandle,
                   LPWSTR pszWirelessRootContainer,
                   PWIRELESS_POLICY_OBJECT pWirelessPolicyObject
                   )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;
    
    dwError = DirMarshallSetPolicyObject(
        hLdapBindHandle,
        pszWirelessRootContainer,
        pWirelessPolicyObject,
        &ppLDAPModW
        );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pWirelessPolicyObject->pszOldWirelessOwnersReferenceName) {
        dwError = LdapRename(hLdapBindHandle,
    	     pWirelessPolicyObject->pszOldWirelessOwnersReferenceName,
    	     pWirelessPolicyObject->pszWirelessOwnersReference
    	     );
        
         BAIL_ON_WIN32_ERROR(dwError);

    	}
    
    dwError = LdapModifyS(
        hLdapBindHandle,
        pWirelessPolicyObject->pszWirelessOwnersReference,
        ppLDAPModW
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
error:
    
    //
    // Free the amods structures.
    //
    
    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }
    
    
    return(dwError);
}


DWORD
DirMarshallSetPolicyObject(
                           HLDAP hLdapBindHandle,
                           LPWSTR pszWirelessRootContainer,
                           PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                           LDAPModW *** pppLDAPModW
                           )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 4;
    DWORD dwError = 0;
    WCHAR Buffer[64];
    
    
    if (!pWirelessPolicyObject->pszWirelessName ||
        !*pWirelessPolicyObject->pszWirelessName) {
        dwNumAttributes--;
    }
    
    if (!pWirelessPolicyObject->pszDescription ||
        !*pWirelessPolicyObject->pszDescription) {
        dwNumAttributes--;
    }
    
    ppLDAPModW = (LDAPModW **) AllocPolMem(
        (dwNumAttributes+1) * sizeof(LDAPModW*)
        );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pLDAPModW = (LDAPModW *) AllocPolMem(
        dwNumAttributes * sizeof(LDAPModW)
        );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    //
    // 2. msieee80211-ID
    //
    
    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
        L"msieee80211-ID",
        &(pLDAPModW +i)->mod_type
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = AllocateLDAPStringValue(
        pWirelessPolicyObject->pszWirelessID,
        (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;
    
    i++;
    
    //
    // 3. msieee80211-DataType
    //
    
    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
        L"msieee80211-DataType",
        &(pLDAPModW +i)->mod_type
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    _itow( pWirelessPolicyObject->dwWirelessDataType, Buffer, 10 );
    
    dwError = AllocateLDAPStringValue(
        Buffer,
        (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;
    
    i++;
    
    //
    // 4. msieee80211-Data
    //
    
    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
        L"msieee80211-Data",
        &(pLDAPModW +i)->mod_type
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = AllocateLDAPBinaryValue(
        pWirelessPolicyObject->pWirelessData,
        pWirelessPolicyObject->dwWirelessDataLen,
        (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    
    i++;
    
    //
    // 5. description
    //
    
    if (pWirelessPolicyObject->pszDescription &&
        *pWirelessPolicyObject->pszDescription) {
        
        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
            L"description",
            &(pLDAPModW +i)->mod_type
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = AllocateLDAPStringValue(
            pWirelessPolicyObject->pszDescription,
            (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;
        
        i++;
        
    }
    
    *pppLDAPModW = ppLDAPModW;
    
    return(dwError);
    
error:
    
    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }
    
    *pppLDAPModW = NULL;
    
    return(dwError);
}


DWORD
GenerateSpecificPolicyQuery(
                            GUID PolicyIdentifier,
                            LPWSTR * ppszPolicyString
                            )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    DWORD dwLength = 0;
    LPWSTR pszPolicyString = NULL;
    
    
    szGuid[0] = L'\0';
    szCommonName[0] = L'\0';
    
    dwError = UuidToString(
        &PolicyIdentifier,
        &pszStringUuid
        );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");
    
    wcscpy(szCommonName, L"cn=msieee80211-Policy");
    wcscat(szCommonName, szGuid);
    
    //
    // Compute Length of Buffer to be allocated
    //
    
    dwLength = wcslen(L"(&(objectclass=msieee80211-Policy)");
    dwLength += wcslen(L"(");
    dwLength += wcslen(szCommonName);
    dwLength += wcslen(L"))");
    
    pszPolicyString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));
    
    if (!pszPolicyString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    wcscpy(pszPolicyString, L"(&(objectclass=msieee80211-Policy)");
    wcscat(pszPolicyString, L"(");
    wcscat(pszPolicyString, szCommonName);
    wcscat(pszPolicyString, L"))");
    
    *ppszPolicyString = pszPolicyString;
    
cleanup:
    
    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }
    
    return(dwError);
    
error:
    
    if (pszPolicyString) {
        FreePolMem(pszPolicyString);
    }
    
    *ppszPolicyString = NULL;
    
    goto cleanup;
}



DWORD
DirDeleteWirelessPolicyData(
                            HLDAP hLdapBindHandle,
                            LPWSTR pszWirelessRootContainer,
                            PWIRELESS_POLICY_DATA pWirelessPolicyData
                            )
{
    DWORD dwError = 0;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject = NULL;
    
    
    dwError = DirMarshallWirelessPolicyObject(
        pWirelessPolicyData,
        pszWirelessRootContainer,
        &pWirelessPolicyObject
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    
    dwError = LdapDeleteS(
        hLdapBindHandle,
        pWirelessPolicyObject->pszWirelessOwnersReference
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
error:
    
    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyObject);
    }
    
    return(dwError);
}


DWORD
ConvertGuidToDirPolicyString(
                             GUID PolicyIdentifier,
                             LPWSTR pszWirelessRootContainer,
                             LPWSTR * ppszWirelessPolicyReference
                             )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szGuidString[MAX_PATH];
    WCHAR szPolicyReference[MAX_PATH];
    LPWSTR pszWirelessPolicyReference = NULL;
    
    
    dwError = UuidToString(
        &PolicyIdentifier,
        &pszStringUuid
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");
    
    szPolicyReference[0] = L'\0';
    wcscpy(szPolicyReference,L"CN=msieee80211-Policy");
    wcscat(szPolicyReference, szGuidString);
    wcscat(szPolicyReference, L",");
    wcscat(szPolicyReference, pszWirelessRootContainer);
    
    pszWirelessPolicyReference = AllocPolStr(
        szPolicyReference
        );
    if (!pszWirelessPolicyReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszWirelessPolicyReference = pszWirelessPolicyReference;
    
cleanup:
    
    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }
    
    return(dwError);
    
error:
    
    *ppszWirelessPolicyReference = NULL;
    
    goto cleanup;
}




DWORD
DirGetWirelessPolicyData(
                         HLDAP hLdapBindHandle,
                         LPWSTR pszWirelessRootContainer,
                         GUID PolicyIdentifier,
                         PWIRELESS_POLICY_DATA * ppWirelessPolicyData
                         )
{
    DWORD dwError = 0;
    LPWSTR pszPolicyString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject =  NULL;
    
    
    *ppWirelessPolicyData = NULL;
    
    dwError = GenerateSpecificPolicyQuery(
        PolicyIdentifier,
        &pszPolicyString
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = LdapSearchST(
        hLdapBindHandle,
        pszWirelessRootContainer,
        LDAP_SCOPE_ONELEVEL,
        pszPolicyString,
        PolicyDNAttributes,
        0,
        NULL,
        &res
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwCount = LdapCountEntries(
        hLdapBindHandle,
        res
        );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    dwError = LdapFirstEntry(
        hLdapBindHandle,
        res,
        &e
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = UnMarshallPolicyObject2(
        hLdapBindHandle,
        e,
        &pWirelessPolicyObject
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = DirUnmarshallWirelessPolicyData(
        pWirelessPolicyObject,
        ppWirelessPolicyData
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
error:
    
    if (pszPolicyString) {
        FreePolStr(pszPolicyString);
    }
    
    if (res) {
        LdapMsgFree(res);
    }
    
    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(pWirelessPolicyObject);
    }
    
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\dllsvr.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       Dllsvr.h
//
//  Contents:   Wifi Policy management Snapin
//
//
//  History:    TaroonM
//              10/30/01
//
//----------------------------------------------------------------------------

DWORD
DllRegisterServer(
    );

DWORD
DllUnregisterServer(
    );

BOOL
IsCleanInstall(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\policy-d.h ===
DWORD
DirEnumWirelessPolicyData(
                          HLDAP hLdapBindHandle,
                          LPWSTR pszWirelessRootContainer,
                          PWIRELESS_POLICY_DATA ** pppWirelessPolicyData,
                          PDWORD pdwNumPolicyObjects
                          );

DWORD
DirEnumPolicyObjects(
                     HLDAP hLdapBindHandle,
                     LPWSTR pszWirelessRootContainer,
                     PWIRELESS_POLICY_OBJECT ** pppWirelessPolicyObjects,
                     PDWORD pdwNumPolicyObjects
                     );

DWORD
GenerateAllPolicyQuery(
                       LPWSTR * ppszPolicyString
                       );

DWORD
UnMarshallPolicyObject2(
                        HLDAP hLdapBindHandle,
                        LDAPMessage *e,
                        PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
                        );

DWORD
DirCreateWirelessPolicyData(
                            HLDAP hLdapBindHandle,
                            LPWSTR pszWirelessRootContainer,
                            PWIRELESS_POLICY_DATA pWirelessPolicyData
                            );

DWORD
DirMarshallWirelessPolicyObject(
                                PWIRELESS_POLICY_DATA pWirelessPolicyData,
                                LPWSTR pszWirelessRootContainer,
                                PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObject
                                );


DWORD
DirCreatePolicyObject(
                      HLDAP hLdapBindHandle,
                      LPWSTR pszWirelessRootContainer,
                      PWIRELESS_POLICY_OBJECT pWirelessPolicyObject
                      );

DWORD
DirMarshallAddPolicyObject(
                           HLDAP hLdapBindHandle,
                           LPWSTR pszWirelessRootContainer,
                           PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                           LDAPModW *** pppLDAPModW
                           );

DWORD
DirSetWirelessPolicyData(
                         HLDAP hLdapBindHandle,
                         LPWSTR pszWirelessRootContainer,
                         PWIRELESS_POLICY_DATA pWirelessPolicyData
                         );

DWORD
DirSetPolicyObject(
                   HLDAP hLdapBindHandle,
                   LPWSTR pszWirelessRootContainer,
                   PWIRELESS_POLICY_OBJECT pWirelessPolicyObject
                   );

DWORD
DirMarshallSetPolicyObject(
                           HLDAP hLdapBindHandle,
                           LPWSTR pszWirelessRootContainer,
                           PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                           LDAPModW *** pppLDAPModW
                           );

DWORD
GenerateSpecificPolicyQuery(
                            GUID PolicyIdentifier,
                            LPWSTR * ppszPolicyString
                            );

DWORD
DirDeleteWirelessPolicyData(
                            HLDAP hLdapBindHandle,
                            LPWSTR pszWirelessRootContainer,
                            PWIRELESS_POLICY_DATA pWirelessPolicyData
                            );

DWORD
ConvertGuidToDirPolicyString(
                             GUID PolicyIdentifier,
                             LPWSTR pszWirelessRootContainer,
                             LPWSTR * ppszWirelessPolicyReference
                             );

DWORD
DirGetWirelessPolicyData(
                         HLDAP hLdapBindHandle,
                         LPWSTR pszWirelessRootContainer,
                         GUID PolicyIdentifier,
                         PWIRELESS_POLICY_DATA * ppWirelessPolicyData
                         );

DWORD
DirUnmarshallWirelessPolicyData(
                                PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                                PWIRELESS_POLICY_DATA * ppWirelessPolicyData
                                );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\policy-r.h ===
DWORD
MarshallWirelessPolicyBuffer(
                             PWIRELESS_POLICY_DATA pWirelessPolicyData,
                             LPBYTE * ppBuffer,
                             DWORD * pdwBufferLen
                             );

DWORD
MarshallWirelessPSBuffer(
                         PWIRELESS_PS_DATA pWirelessPSData,
                         LPBYTE  pBuffer,
                         DWORD * pdwBufferLen
                         );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\policy-w.h ===
DWORD
WMIEnumPolicyDataEx(
                    IWbemServices *pWbemServices,
                    PWIRELESS_POLICY_DATA ** pppWirelessPolicyData,
                    PDWORD pdwNumPolicyObjects
                    );

DWORD
WMIEnumPolicyObjectsEx(
                       IWbemServices *pWbemServices,
                       PWIRELESS_POLICY_OBJECT ** pppWirelessPolicyObjects,
                       PDWORD pdwNumPolicyObjects
                       );

DWORD
WMIUnmarshallPolicyData(
                        PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                        PWIRELESS_POLICY_DATA * ppWirelessPolicyData
                        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\policy-r.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       policy-r.c
//
//  Contents:   Policy management for registry.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------

#include "precomp.h"



DWORD
MarshallWirelessPSBuffer(
                         PWIRELESS_PS_DATA pWirelessPSData,
                         LPBYTE  pBuffer,
                         DWORD * pdwBufferLen
                         )
{
    DWORD dwSize = 0;
    DWORD dwError = 0;
    LPBYTE pCurrentPos = NULL;
    DWORD dwPSSize = 0;
    LPWSTR SSID = NULL;
    DWORD dwWepEnabled = 0;
    DWORD dwId = 0;
    DWORD dwNetworkAuthentication = 0;
    DWORD dwAutomaticKeyProvision = 0;
    DWORD dwNetworkType = 0;
    DWORD dwEnable8021x = 0;
    DWORD dw8021xMode = 0;
    DWORD dwEAPType = 0;
    DWORD dwCertificateType = 0;
    DWORD dwValidateServerCertificate = 0;
    DWORD dwMachineAuthentication = 0;
    DWORD dwMachineAuthenticationType = 0;
    DWORD dwGuestAuthentication = 0;
    DWORD dwIEEE8021xMaxStart = 0;
    DWORD dwIEEE8021xStartPeriod = 0;
    DWORD dwIEEE8021xAuthPeriod = 0;
    DWORD dwIEEE8021xHeldPeriod = 0;
    DWORD dwDescriptionLen  = 0;
    DWORD dwEAPDataLen = 0;
    DWORD dwSSIDLen = 0;
    
    pCurrentPos = pBuffer;
    
    dwPSSize = pWirelessPSData->dwPSLen;
    memcpy(pCurrentPos, &dwPSSize, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    SSID = pWirelessPSData->pszWirelessSSID;
    memcpy(pCurrentPos, SSID, 32*2);
    pCurrentPos += 32*2;
    
    dwSSIDLen = pWirelessPSData->dwWirelessSSIDLen;
    memcpy(pCurrentPos, &dwSSIDLen, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwWepEnabled = pWirelessPSData->dwWepEnabled;
    memcpy(pCurrentPos, &dwWepEnabled, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwId = pWirelessPSData->dwId;
    memcpy(pCurrentPos, &dwId, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwNetworkAuthentication = pWirelessPSData->dwNetworkAuthentication;
    memcpy(pCurrentPos, &dwNetworkAuthentication, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwAutomaticKeyProvision = pWirelessPSData->dwAutomaticKeyProvision;
    memcpy(pCurrentPos, &dwAutomaticKeyProvision, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwNetworkType = pWirelessPSData->dwNetworkType;
    memcpy(pCurrentPos, &dwNetworkType, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwEnable8021x = pWirelessPSData->dwEnable8021x;
    memcpy(pCurrentPos, &dwEnable8021x, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dw8021xMode = pWirelessPSData->dw8021xMode;
    memcpy(pCurrentPos, &dw8021xMode, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwEAPType = pWirelessPSData->dwEapType;
    memcpy(pCurrentPos, &dwEAPType, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwEAPDataLen = pWirelessPSData->dwEAPDataLen;
    memcpy(pCurrentPos, &dwEAPDataLen, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD); 
    
    memcpy(pCurrentPos,
        pWirelessPSData->pbEAPData, 
        dwEAPDataLen);
    pCurrentPos += dwEAPDataLen;
    
    dwMachineAuthentication = pWirelessPSData->dwMachineAuthentication;
    memcpy(pCurrentPos, &dwMachineAuthentication, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwMachineAuthenticationType = pWirelessPSData->dwMachineAuthenticationType;
    memcpy(pCurrentPos, &dwMachineAuthenticationType, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwGuestAuthentication = pWirelessPSData->dwGuestAuthentication;
    memcpy(pCurrentPos, &dwGuestAuthentication, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwIEEE8021xMaxStart = pWirelessPSData->dwIEEE8021xMaxStart;
    memcpy(pCurrentPos, &dwIEEE8021xMaxStart, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwIEEE8021xStartPeriod = pWirelessPSData->dwIEEE8021xStartPeriod;
    memcpy(pCurrentPos, &dwIEEE8021xStartPeriod, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD); 
    
    dwIEEE8021xAuthPeriod = pWirelessPSData->dwIEEE8021xAuthPeriod;
    memcpy(pCurrentPos, &dwIEEE8021xAuthPeriod, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD); 
    
    dwIEEE8021xHeldPeriod = pWirelessPSData->dwIEEE8021xHeldPeriod;
    memcpy(pCurrentPos, &dwIEEE8021xHeldPeriod, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD); 
    
    dwDescriptionLen = pWirelessPSData->dwDescriptionLen;
    memcpy(pCurrentPos, &dwDescriptionLen, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD); 
    
    memcpy(pCurrentPos,
        pWirelessPSData->pszDescription, 
        dwDescriptionLen*2);
    
    *pdwBufferLen = dwPSSize;
    return(dwError);
    
}


DWORD
MarshallWirelessPolicyBuffer(
                             PWIRELESS_POLICY_DATA pWirelessPolicyData,
                             LPBYTE * ppBuffer,
                             DWORD * pdwBufferLen
                             )
{
    LPBYTE pBuffer = NULL;
    DWORD dwSize = 0;
    DWORD dwError = 0;
    DWORD dwPollingInterval = 0;
    LPBYTE pCurrentPos = NULL;
    DWORD dwEffectiveSize = 0;
    PWIRELESS_PS_DATA *ppWirelessPSData = NULL;
    DWORD dwNumPreferredSettings = 0;
    DWORD dwPSSize = 0;
    DWORD i = 0;
    DWORD dwDisableZeroConf = 0;
    DWORD dwNetworkToAccess = 0;
    DWORD dwConnectToNonPreferredNtwks = 0;

    DWORD dwWlBlobLen = 0;
    WORD wMajorVersion = 0;
    WORD wMinorVersion = 0;
    
    
    wMajorVersion = WL_BLOB_MAJOR_VERSION;
    wMinorVersion = WL_BLOB_MINOR_VERSION;
    
    
    
    // first estimate the total size 
    dwSize += sizeof(WORD);    // Major Version
    dwSize += sizeof(WORD);    // Minor Version
    dwSize += sizeof(DWORD);  // Length of the Wl_Blob

    dwWlBlobLen += sizeof(DWORD);  // dwPollingInterval
    dwWlBlobLen += sizeof(DWORD);  // dwDisableZeroConf
    dwWlBlobLen += sizeof(DWORD);  // dwNetworkToAccess
    dwWlBlobLen += sizeof(DWORD);  // dwConnectToNonPreferredNetworks
    dwWlBlobLen += sizeof(DWORD);  // dwNumPreferredSettings
    
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    
    dwNumPreferredSettings = 
        pWirelessPolicyData->dwNumPreferredSettings;
    
    for (i=0; i<dwNumPreferredSettings;++i) {
        dwWlBlobLen += (*ppWirelessPSData)->dwPSLen;
        ppWirelessPSData++;
    }
    
    //dwSize++;   //Taroon Dont know why this for. 
    dwSize += dwWlBlobLen;

    
    
    pBuffer = AllocPolMem(dwSize);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pCurrentPos = pBuffer;

    memcpy(pCurrentPos, &wMajorVersion, sizeof(WORD));
    pCurrentPos += sizeof(WORD);

    memcpy(pCurrentPos, &wMinorVersion, sizeof(WORD));
    pCurrentPos += sizeof(WORD);

    memcpy(pCurrentPos, &dwWlBlobLen, sizeof(DWORD));

    pCurrentPos += sizeof(DWORD);
    
    dwPollingInterval = pWirelessPolicyData->dwPollingInterval;
    memcpy(pCurrentPos, &dwPollingInterval, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwDisableZeroConf = pWirelessPolicyData->dwDisableZeroConf;
    memcpy(pCurrentPos, &dwDisableZeroConf, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwNetworkToAccess = pWirelessPolicyData->dwNetworkToAccess;
    memcpy(pCurrentPos, &dwNetworkToAccess, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwConnectToNonPreferredNtwks = pWirelessPolicyData->dwConnectToNonPreferredNtwks;
    memcpy(pCurrentPos, &dwConnectToNonPreferredNtwks, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    dwNumPreferredSettings = pWirelessPolicyData->dwNumPreferredSettings;
    memcpy(pCurrentPos, &dwNumPreferredSettings, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    // Write each Preferred Setting data here 
    
    ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
    
    for(i=0; i<dwNumPreferredSettings;++i) {
        
        dwError = MarshallWirelessPSBuffer(
            *(ppWirelessPSData+i),
            pCurrentPos,
            &dwPSSize);
        BAIL_ON_WIN32_ERROR(dwError);
        
        pCurrentPos += dwPSSize;
    }
    
    
    *ppBuffer = pBuffer;
    *pdwBufferLen = dwSize;
    return(dwError);
    
error:
    
    if (pBuffer) {
        FreePolMem(pBuffer);
    }
    
    *ppBuffer = NULL;
    *pdwBufferLen = 0;
    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\policy-w.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       policy-w.c
//
//  Contents:   Policy management for WMI.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//              t-hhsu
//
//----------------------------------------------------------------------------

#include "precomp.h"

//extern LPWSTR PolicyDNAttributes[];


DWORD
WMIEnumPolicyDataEx(
                    IWbemServices *pWbemServices,
                    PWIRELESS_POLICY_DATA ** pppWirelessPolicyData,
                    PDWORD pdwNumPolicyObjects
                    )
{
    DWORD dwError = 0;
    PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObjects = NULL;
    PWIRELESS_POLICY_DATA pWirelessPolicyData = NULL;
    PWIRELESS_POLICY_DATA * ppWirelessPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD i = 0;
    DWORD j = 0;
    
    
    
    dwError = WMIEnumPolicyObjectsEx(
        pWbemServices,
        &ppWirelessPolicyObjects,
        &dwNumPolicyObjects
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    if (dwNumPolicyObjects) {
        ppWirelessPolicyData = (PWIRELESS_POLICY_DATA *) AllocPolMem(
            dwNumPolicyObjects*sizeof(PWIRELESS_POLICY_DATA));
        if (!ppWirelessPolicyData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    for (i = 0; i < dwNumPolicyObjects; i++) {
        dwError = WMIUnmarshallPolicyData(
            *(ppWirelessPolicyObjects + i),
            &pWirelessPolicyData
            );
        if (!dwError) {
            *(ppWirelessPolicyData + j) = pWirelessPolicyData;
            j++;
        }
    }
    
    if (j == 0) {
        if (ppWirelessPolicyData) {
            FreePolMem(ppWirelessPolicyData);
            ppWirelessPolicyData = NULL;
        }
    }
    
    *pppWirelessPolicyData = ppWirelessPolicyData;
    *pdwNumPolicyObjects = j;
    
    dwError = ERROR_SUCCESS;
    
cleanup:
    
    if (ppWirelessPolicyObjects) {
        FreeWirelessPolicyObjects(
            ppWirelessPolicyObjects,
            dwNumPolicyObjects
            );
    }
    
    return(dwError);
    
error:
    
    if (ppWirelessPolicyData) {
        FreeMulWirelessPolicyData(
            ppWirelessPolicyData,
            i
            );
    }
    
    *pppWirelessPolicyData = NULL;
    *pdwNumPolicyObjects = 0;
    
    goto cleanup;
    
}


DWORD
WMIEnumPolicyObjectsEx(
                       IWbemServices *pWbemServices,
                       PWIRELESS_POLICY_OBJECT ** pppWirelessPolicyObjects,
                       PDWORD pdwNumPolicyObjects
                       )
{
    
    DWORD dwError = 0;
    HRESULT hr = S_OK;
    DWORD dwNumPolicyObjectsReturned = 0;
    PWIRELESS_POLICY_OBJECT pWirelessPolicyObject =  NULL;
    PWIRELESS_POLICY_OBJECT * ppWirelessPolicyObjects = NULL;
    
    ///wbem
    IEnumWbemClassObject *pEnum = NULL;
    IWbemClassObject *pObj = NULL;
    ULONG uReturned = 0;
    VARIANT var;
    LPWSTR tmpStr = NULL;
    BSTR bstrTmp = NULL;
    
    
    
    *pppWirelessPolicyObjects = NULL;
    *pdwNumPolicyObjects = 0;
    
    VariantInit(&var);
    
    bstrTmp = SysAllocString(L"RSOP_IEEE80211PolicySetting");
    if(!bstrTmp) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    //get enum
    hr = IWbemServices_CreateInstanceEnum(
        pWbemServices,
        bstrTmp, //L"RSOP_IEEE80211PolicySetting"
        WBEM_FLAG_FORWARD_ONLY,
        0,
        &pEnum
        );
    SysFreeString(bstrTmp);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    //process
    while (1)
    {
        hr = IEnumWbemClassObject_Next(pEnum, WBEM_INFINITE, 1, &pObj, &uReturned);
        
        if (hr == WBEM_S_NO_ERROR)
        {
            hr = IWbemClassObject_Get(
                pObj,
                L"id",
                0,
                &var,
                0,
                0
                );
            BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
            
            tmpStr = var.bstrVal;
            
            if (!wcsstr(tmpStr, L"msieee80211-Policy")) {
                IWbemClassObject_Release(pObj);
                VariantClear(&var);
                continue;
            }
            
            pWirelessPolicyObject = NULL;
            
            dwError = UnMarshallWMIPolicyObject(
                pObj,
                &pWirelessPolicyObject
                );
            
            if (dwError == ERROR_SUCCESS) {
                
                dwError = ReallocatePolMem(
                    (LPVOID *) &ppWirelessPolicyObjects,
                    sizeof(PWIRELESS_POLICY_OBJECT)*(dwNumPolicyObjectsReturned),
                    sizeof(PWIRELESS_POLICY_OBJECT)*(dwNumPolicyObjectsReturned + 1)
                    );
                BAIL_ON_WIN32_ERROR(dwError);
                
                *(ppWirelessPolicyObjects + dwNumPolicyObjectsReturned) = pWirelessPolicyObject;
                dwNumPolicyObjectsReturned++;
            }
            
            //free
            IWbemClassObject_Release(pObj);
            VariantClear(&var);
        } else {
            if(hr == WBEM_S_FALSE) {
                break;
            } else {
                BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
            }
        }
    }
    
    *pppWirelessPolicyObjects = ppWirelessPolicyObjects;
    *pdwNumPolicyObjects = dwNumPolicyObjectsReturned;
    
    dwError = ERROR_SUCCESS;
    
cleanup:
    
    if(pEnum)
        IEnumWbemClassObject_Release(pEnum);
    
    return(dwError);
    
error:

    if (pObj) {
        IWbemClassObject_Release(pObj);
        pObj = NULL;
     }
     VariantClear(&var);

    
    if (ppWirelessPolicyObjects) {
        FreeWirelessPolicyObjects(
            ppWirelessPolicyObjects,
            dwNumPolicyObjectsReturned
            );
    }
    
    if (pWirelessPolicyObject) {
        FreeWirelessPolicyObject(
            pWirelessPolicyObject
            );
    }
    
    *pppWirelessPolicyObjects = NULL;
    *pdwNumPolicyObjects = 0;
    
    goto cleanup;
    
}


DWORD
WMIUnmarshallPolicyData(
                        PWIRELESS_POLICY_OBJECT pWirelessPolicyObject,
                        PWIRELESS_POLICY_DATA * ppWirelessPolicyData
                        )
{
    DWORD dwError = 0;
    
    dwError = UnmarshallWirelessPolicyObject(
        pWirelessPolicyObject,
        WIRELESS_WMI_PROVIDER, //(procrule.h)
        ppWirelessPolicyData
        );
    BAIL_ON_WIN32_ERROR(dwError);
    if (*ppWirelessPolicyData) {
        (*ppWirelessPolicyData)->dwFlags |= WLSTORE_READONLY;
    }
    
error:
    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\validate.h ===
DWORD
ValidateWirelessPolicyData(
    PWIRELESS_POLICY_DATA pWirelessPolicyData
    );

DWORD
ValidateWirelessPSData(
    PWIRELESS_PS_DATA pWirelessPSData, 
    DWORD dwNetworkType
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\precomp.h ===
//
// System Includes
//

#include <windows.h>

//
// CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <wchar.h>

#include <dsgetdc.h>
#include <lm.h>

#define UNICODE
#define COBJMACROS

#include <rpc.h>
#include <winldap.h>
#include <time.h>
#include <wbemidl.h>
#include <oleauto.h>
#include <objbase.h>


#include "wlstore2.h"

#include "ldaputil.h"
#include "memory.h"
#include "structs.h"
#include "dsstore.h"
#include "regstore.h"
#include "wmistore.h"
#include "persist.h"
#include "persist-w.h"
#include "procrule.h"
#include "utils.h"

#include "policy-d.h"
#include "policy-r.h"
#include "policy-w.h"

#include "ldaputils.h"

#include "connui.h"
#include "dllsvr.h"

//#include "wlstmsg.h"



typedef struct _WIRELESS_POLICY_STORE {
    DWORD dwProvider;
    HKEY  hParentRegistryKey;
    HKEY  hRegistryKey;
    LPWSTR pszLocationName;
    HLDAP hLdapBindHandle;
    LPWSTR pszWirelessRootContainer;
    LPWSTR pszFileName;
    IWbemServices *pWbemServices;
}WIRELESS_POLICY_STORE, *PWIRELESS_POLICY_STORE;

#include "validate.h"

#define SZAPPNAME L"wlstore.dll"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\wlstore\validate.c ===
#include "precomp.h"

extern LPWSTR PolicyDNAttributes[];

DWORD
ValidateWirelessPSData(
    PWIRELESS_PS_DATA pWirelessPSData,
    DWORD dwNetworkType
    )
{
    DWORD dwError = 0;
    DWORD dwSSIDLen = 0;
    DWORD dwPSLen = 0;
    DWORD dwDescriptionLen = 0;
    DWORD dwEAPDataLen = 0;
    
    if (!pWirelessPSData) {
        dwError = ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);
    
    if (pWirelessPSData->dwNetworkType != dwNetworkType) {
    	  dwError = ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwSSIDLen = wcslen(pWirelessPSData->pszWirelessSSID);
    if (dwSSIDLen == 0) {
        dwError = ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);
    
    if (dwSSIDLen < pWirelessPSData->dwWirelessSSIDLen) {
        dwError = ERROR_INVALID_PARAMETER;
    }    
    BAIL_ON_WIN32_ERROR(dwError);

    if (pWirelessPSData->pszDescription) {
        dwDescriptionLen = wcslen(pWirelessPSData->pszDescription);
    }

    dwEAPDataLen = pWirelessPSData->dwEAPDataLen;
    if (dwEAPDataLen) {
    	if (!(pWirelessPSData->pbEAPData)) {
    		dwError = ERROR_INVALID_PARAMETER;
    	}
    }
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwPSLen = (sizeof(WIRELESS_PS_DATA) - sizeof(DWORD) -sizeof(LPWSTR)) + sizeof(WCHAR) * dwDescriptionLen
    	- sizeof(LPWSTR) + dwEAPDataLen;

    if (dwPSLen != pWirelessPSData->dwPSLen) {
        dwError = ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:
    	
    return(dwError);
}


DWORD
ValidateWirelessPolicyData(
    PWIRELESS_POLICY_DATA pWirelessPolicyData
    )
{
    PWIRELESS_PS_DATA *ppWirelessPSData = NULL;
    PWIRELESS_PS_DATA pWirelessPSData = NULL;
    DWORD dwError = 0;
    DWORD dwNumPreferredSettings = 0;
    DWORD dwNumAPNetworks = 0;
    DWORD dwSSIDLen = 0;
    DWORD dwPSLen = 0;
    DWORD i=0;
    
    if (!pWirelessPolicyData) {
    	dwError = ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pWirelessPolicyData->pszWirelessName) {
    	dwError = ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    dwNumPreferredSettings = pWirelessPolicyData->dwNumPreferredSettings;
    dwNumAPNetworks = pWirelessPolicyData->dwNumAPNetworks;

    if (dwNumPreferredSettings) {

        ppWirelessPSData = pWirelessPolicyData->ppWirelessPSData;
        if (!ppWirelessPSData) {
        	dwError = ERROR_INVALID_PARAMETER;
        }
        BAIL_ON_WIN32_ERROR(dwError);

        
        if (dwNumPreferredSettings < dwNumAPNetworks) {
        	dwError = ERROR_INVALID_PARAMETER;
        }
        BAIL_ON_WIN32_ERROR(dwError);
        
        for (i=0; i < dwNumAPNetworks ; ++i) {
            pWirelessPSData = ppWirelessPSData[i];

            dwError = ValidateWirelessPSData(pWirelessPSData, WIRELESS_NETWORK_TYPE_AP);
            BAIL_ON_WIN32_ERROR(dwError);
        }

        
        for (i=dwNumAPNetworks; i < dwNumPreferredSettings; ++i) {

            pWirelessPSData = ppWirelessPSData[i];

            dwError = ValidateWirelessPSData(pWirelessPSData, WIRELESS_NETWORK_TYPE_ADHOC);
            BAIL_ON_WIN32_ERROR(dwError);
        }
    	}

error:
	
	return(dwError);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\client\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#

!INCLUDE $(NTMAKEENV)\makefile.plt

CLIENT_IDL = ..\idl\wzc.idl
CLIENT_ACF = ..\idl\wzccli.acf
IMPORT     = import
UNICODE    = 1

INCS  = -I. -I..\idl -I$(SDK_INC_PATH)  -I$(CRT_INC_PATH) -I$(PROJECT_ROOT)\inc -I$(NET_INC_PATH)
CPP = -cpp_cmd "$(MIDL_CPP)" -DNO_STRICT $(MIDL_FLAGS)

#
# MIDL COMPILE
#

MIDL_OPTIMIZATION_NT5=-Oicf -no_format_opt -robust -error all -out .\$(O)

$(O)\wzc_c.c $(O)\wzc_c.h : $(CLIENT_IDL) $(CLIENT_ACF)
    midl $(MIDL_OPTIMIZATION_NT5) -acf $(CLIENT_ACF) -server none -oldnames -ms_ext -c_ext $(CPP) $(INCS) $(CLIENT_IDL) -header wzc_c.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\client\midluser.c ===
#include <precomp.h>

//------------------------------------
// Allocates storage for RPC transactions. The RPC stubs will either call
// MIDL_user_allocate when it needs to un-marshall data into a buffer
// that the user must free.  RPC servers will use MIDL_user_allocate to
// allocate storage that the RPC server stub will free after marshalling
// the data.
PVOID
MIDL_user_allocate(IN size_t NumBytes)
{
    PVOID pMem;

    pMem = (NumBytes > 0) ? LocalAlloc(LMEM_ZEROINIT,NumBytes) : NULL;
    return pMem;
}

//------------------------------------
// Frees storage used in RPC transactions. The RPC client can call this
// function to free buffer space that was allocated by the RPC client
// stub when un-marshalling data that is to be returned to the client.
// The Client calls MIDL_user_free when it is finished with the data and
// desires to free up the storage.
// The RPC server stub calls MIDL_user_free when it has completed
// marshalling server data that is to be passed back to the client.
VOID
MIDL_user_free(IN LPVOID MemPointer)
{
    if (MemPointer != NULL)
        LocalFree(MemPointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\client\util.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       U T I L. H
//
//  Contents:   Utility functions
//
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma once

//
// EAPOL related funtions
//

DTLNODE* DtlCreateSizedNode( LONG, LONG_PTR );
VOID     DtlDestroyNode( DTLNODE* );
DTLNODE* DtlAddNodeLast( DTLLIST*, DTLNODE* );
DTLNODE* DtlRemoveNode( DTLLIST*, DTLNODE* );
DTLLIST* DtlCreateList( LONG );

VOID
GetRegBinary(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT BYTE** ppbResult,
    OUT DWORD* pcbResult);

VOID
GetRegDword(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT DWORD* pdwResult);

DWORD
GetRegExpandSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult);

DWORD
GetRegSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult);

DWORD
WZCGetEapUserInfo (
        IN  WCHAR           *pwszGUID,
        IN  DWORD           dwEapTypeId,
        IN  DWORD           dwSizeOfSSID,
        IN  BYTE            *pbSSID,
        IN  OUT PBYTE       pbUserInfo,
        IN  OUT DWORD       *pdwInfoSize
        );

DWORD
WZCGetEapData (
        IN  DWORD   dwEapType,
        IN  DWORD   dwSizeOfIn,
        IN  BYTE    *pbBufferIn,
        IN  DWORD   dwOffset,
        IN  DWORD   *pdwSizeOfOut,
        IN  PBYTE   *ppbBufferOut
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\client\wzcsapi.c ===
#include <precomp.h>

BOOL
WZCSvcMain(
    IN PVOID    hmod,
    IN DWORD    dwReason,
    IN PCONTEXT pctx OPTIONAL)
{
    DBG_UNREFERENCED_PARAMETER(pctx);

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls((HMODULE) hmod);
        break;
    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}

//---------------------------------------
// WZCDeleteIntfObj: cleans an INTF_ENTRY object that is
// allocated within any RPC call.
VOID
WZCDeleteIntfObj(
    PINTF_ENTRY     pIntf)
{
    if (pIntf != NULL)
    {
        RpcFree(pIntf->wszGuid);
        RpcFree(pIntf->wszDescr);
        RpcFree(pIntf->rdSSID.pData);
        RpcFree(pIntf->rdBSSID.pData);
        RpcFree(pIntf->rdBSSIDList.pData);
        RpcFree(pIntf->rdStSSIDList.pData);
        RpcFree(pIntf->rdCtrlData.pData);
    }
}

//---------------------------------------
// WZCEnumInterfaces: provides the table of key
// information for all the interfaces that are managed.
// For all subsequent calls the clients need to identify
// the Interface it operates on by providing the respective
// key info.
//
// Parameters:
//   pSrvAddr
//     [in] WZC Server to contact
//   pIntf
//     [out] table of key info for all interfaces
// Returned value:
//     Win32 error code 
DWORD
WZCEnumInterfaces(
    LPWSTR              pSrvAddr,
    PINTFS_KEY_TABLE    pIntfs)
{
    DWORD rpcStatus = RPC_S_OK;

    RpcTryExcept 
    {
        rpcStatus = RpcEnumInterfaces(pSrvAddr, pIntfs);
    }
    RpcExcept(TRUE)
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return rpcStatus;
}

//---------------------------------------
// WZCQueryIterface: provides detailed information for a
// given interface.
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be queried (bitmask of INTF_*)
//   pIntf:
//     [in]  Key of the interface to query
//     [out] Requested data from the interface.
//   pdwOutFlags
//     [out] Fields successfully retrieved (bitmask of INTF_*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCQueryInterface(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PINTF_ENTRY         pIntf,
    LPDWORD             pdwOutFlags)
{
    DWORD rpcStatus = RPC_S_OK;

    if (pIntf == NULL || pIntf->wszGuid == NULL)
    {
        rpcStatus = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    RpcTryExcept 
    {
        DWORD dwOutFlags;

        rpcStatus = RpcQueryInterface(
                        pSrvAddr, 
                        dwInFlags, 
                        pIntf,
                        &dwOutFlags);

        if ((dwInFlags & INTF_PREFLIST) && 
            (dwOutFlags & INTF_PREFLIST) &&
            pIntf->rdStSSIDList.dwDataLen != 0) 
        {
            PWZC_802_11_CONFIG_LIST pwzcPList;
            UINT nIdx;
            
            pwzcPList = (PWZC_802_11_CONFIG_LIST)(pIntf->rdStSSIDList.pData);
            for (nIdx = 0; nIdx < pwzcPList->NumberOfItems; nIdx++)
            {
                PWZC_WLAN_CONFIG pwzcConfig = &(pwzcPList->Config[nIdx]);
                BYTE chFakeKeyMaterial[] = {0x56, 0x09, 0x08, 0x98, 0x4D, 0x08, 0x11, 0x66, 0x42, 0x03, 0x01, 0x67, 0x66};
                UINT i;

                for (i = 0; i < WZCCTL_MAX_WEPK_MATERIAL; i++)
                    pwzcConfig->KeyMaterial[i] ^= chFakeKeyMaterial[(7*i)%13];
            }
        }

        if (pdwOutFlags != NULL)
            *pdwOutFlags = dwOutFlags;
    }
    RpcExcept(TRUE)
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

exit:
    return rpcStatus;
}

//---------------------------------------
// WZCSetIterface: sets specific information on the interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be set (bitmask of INTF_*)
//   pIntf:
//     [in]  Key of the interface to query and data to be set
//   pdwOutFlags:
//     [out] Fields successfully set (bitmask of INTF_*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCSetInterface(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PINTF_ENTRY         pIntf,
    LPDWORD             pdwOutFlags)
{
    DWORD rpcStatus = RPC_S_OK;

    if (pIntf == NULL)
    {
        rpcStatus = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    RpcTryExcept 
    {
        if (dwInFlags & INTF_PREFLIST &&
            pIntf->rdStSSIDList.dwDataLen != 0)
        {
            PWZC_802_11_CONFIG_LIST pwzcPList;
            UINT nIdx;
            
            pwzcPList = (PWZC_802_11_CONFIG_LIST)(pIntf->rdStSSIDList.pData);
            for (nIdx = 0; nIdx < pwzcPList->NumberOfItems; nIdx++)
            {
                PWZC_WLAN_CONFIG pwzcConfig = &(pwzcPList->Config[nIdx]);
                BYTE chFakeKeyMaterial[] = {0x56, 0x09, 0x08, 0x98, 0x4D, 0x08, 0x11, 0x66, 0x42, 0x03, 0x01, 0x67, 0x66};
                UINT i;

                for (i = 0; i < WZCCTL_MAX_WEPK_MATERIAL; i++)
                    pwzcConfig->KeyMaterial[i] ^= chFakeKeyMaterial[(7*i)%13];
            }
        }

        rpcStatus = RpcSetInterface(
                        pSrvAddr, 
                        dwInFlags, 
                        pIntf,
                        pdwOutFlags);
    }
    RpcExcept(TRUE)
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

exit:
    return rpcStatus;
}

//---------------------------------------
// WZCRefreshInterface: refreshes specific information for the interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be refreshed and specific refresh actions to be
//           taken (bitmask of INTF_* and INTF_RFSH_*)
//   pIntf:
//     [in]  Key of the interface to be refreshed
//   pdwOutFlags:
//     [out] Fields successfully refreshed (bitmask of INTF_* and INTF_RFSH_*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCRefreshInterface(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PINTF_ENTRY         pIntf,
    LPDWORD             pdwOutFlags)
{
    DWORD rpcStatus = RPC_S_OK;

    if (pIntf == NULL || pIntf->wszGuid == NULL)
    {
        rpcStatus = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    RpcTryExcept 
    {
        rpcStatus = RpcRefreshInterface(
                        pSrvAddr, 
                        dwInFlags, 
                        pIntf,
                        pdwOutFlags);
    }
    RpcExcept(TRUE)
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

exit:
    return rpcStatus;
}

//---------------------------------------
// WZCQueryContext: retrieves the WZC service parameters
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be retrieved (bitmask of WZC_CONTEXT_CTL*)
//   pContext:
//     [in]  Placeholder for the service parameters
//   pdwOutFlags:
//     [out] Fields successfully retrieved (bitmask of WZC_CONTEXT_CTL*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCQueryContext(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PWZC_CONTEXT        pContext,
    LPDWORD             pdwOutFlags)
{
    DWORD rpcStatus = RPC_S_OK;

    RpcTryExcept 
    {
        rpcStatus = RpcQueryContext(
                        pSrvAddr, 
                        dwInFlags, 
                        pContext,
                        pdwOutFlags);
    }
    RpcExcept(TRUE)
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return rpcStatus;
}


//---------------------------------------
// WZCSetContext: sets specific WZC service parameters
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be set (bitmask of WZC_CONTEXT_CTL*)
//   pContext:
//     [in]  Context buffer containing the specific parameters to be set
//   pdwOutFlags:
//     [out] Fields successfully set (bitmask of WZC_CONTEXT_CTL*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCSetContext(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PWZC_CONTEXT        pContext,
    LPDWORD             pdwOutFlags)
{
    DWORD rpcStatus = RPC_S_OK;

    RpcTryExcept 
    {
        rpcStatus = RpcSetContext(
                        pSrvAddr, 
                        dwInFlags, 
                        pContext,
                        pdwOutFlags);
    }
    RpcExcept(TRUE)
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return rpcStatus;
}


//---------------------------------------
// WZCEapolGetCustomAuthData: Get EAP-specific configuration data for interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   dwEapTypeId:
//     [in]  EAP type Id
//   SSID:
//     [in]  SSID for which data is to be stored
//   pbConnInfo:
//     [in out]  Connection EAP info
//   pdwInfoSize:
//     [in out]  Size of pbConnInfo
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolGetCustomAuthData (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid,
    IN  DWORD         dwEapTypeId,
    IN  DWORD         dwSizeOfSSID,
    IN  BYTE          *pbSSID,
    IN OUT PBYTE      pbConnInfo,
    IN OUT PDWORD     pdwInfoSize
    )
{
    RAW_DATA    rdConnInfo;
    RAW_DATA    rdSSID;
    DWORD rpcStatus = RPC_S_OK;

    if ((pwszGuid == NULL) || (pdwInfoSize == NULL)) 
    {
        rpcStatus = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if ((*pdwInfoSize != 0) && (pbConnInfo == NULL)) 
    {
        rpcStatus = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    rdConnInfo.pData = pbConnInfo;
    rdConnInfo.dwDataLen = *pdwInfoSize;

    rdSSID.pData = pbSSID;
    rdSSID.dwDataLen = dwSizeOfSSID;

    RpcTryExcept 
    {
        rpcStatus = RpcEapolGetCustomAuthData (
                        pSrvAddr, 
                        pwszGuid,
                        dwEapTypeId,
                        rdSSID,
                        &rdConnInfo
                        );

        *pdwInfoSize = rdConnInfo.dwDataLen;
    }
    RpcExcept(TRUE)
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

exit:
    return rpcStatus;
}

//---------------------------------------
// WZCEapolSetCustomAuthData: Set EAP-specific configuration data for interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   dwEapTypeId:
//     [in]  EAP type Id
//   SSID:
//     [in]  SSID for which data is to be stored
//   pbConnInfo:
//     [in]  Connection EAP info
//   pdwInfoSize:
//     [in]  Size of pbConnInfo
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolSetCustomAuthData (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid,
    IN  DWORD         dwEapTypeId,
    IN  DWORD         dwSizeOfSSID,
    IN  BYTE          *pbSSID,
    IN  PBYTE         pbConnInfo,
    IN  DWORD         dwInfoSize
    )
{
    RAW_DATA    rdConnInfo;
    RAW_DATA    rdSSID;
    DWORD rpcStatus = RPC_S_OK;

    if (pwszGuid == NULL)
    {
        rpcStatus = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    rdConnInfo.pData = pbConnInfo;
    rdConnInfo.dwDataLen = dwInfoSize;

    rdSSID.pData = pbSSID;
    rdSSID.dwDataLen = dwSizeOfSSID;

    RpcTryExcept 
    {
        rpcStatus = RpcEapolSetCustomAuthData (
                        pSrvAddr, 
                        pwszGuid,
                        dwEapTypeId,
                        rdSSID,
                        &rdConnInfo
                        );
    }
    RpcExcept(TRUE)
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

exit:
    return rpcStatus;
}

//---------------------------------------
// WZCEapolGetInterfaceParams: Get configuration parameters for interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   pIntfParams:
//     [in out]  Interface Parameters
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolGetInterfaceParams (
    IN  LPWSTR              pSrvAddr,
    IN  PWCHAR              pwszGuid,
    IN OUT EAPOL_INTF_PARAMS   *pIntfParams
    )
{
    DWORD rpcStatus = RPC_S_OK;

    if ((pwszGuid == NULL) || (pIntfParams == NULL))
    {
        rpcStatus = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    RpcTryExcept 
    {
        rpcStatus = RpcEapolGetInterfaceParams (
                        pSrvAddr, 
                        pwszGuid,
                        pIntfParams
                        );
    }
    RpcExcept(TRUE)
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

exit:
    return rpcStatus;
}

//---------------------------------------
// WZCEapolSetInterfaceParams: Set configuration parameters for interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   pIntfParams:
//     [in]  Interface Parameters
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolSetInterfaceParams (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid,
    IN  EAPOL_INTF_PARAMS   *pIntfParams
    )
{
    DWORD rpcStatus = RPC_S_OK;

    if ((pwszGuid == NULL) || (pIntfParams == NULL))
    {
        rpcStatus = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    RpcTryExcept 
    {
        rpcStatus = RpcEapolSetInterfaceParams (
                        pSrvAddr, 
                        pwszGuid,
                        pIntfParams
                        );
    }
    RpcExcept(TRUE)
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

exit:
    return rpcStatus;
}


//---------------------------------------
// WZCEapolReAuthenticate: Restart 802.1X authenticaiton on an 
//                                      interface 
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolReAuthenticate (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid
    )
{
    DWORD rpcStatus = RPC_S_OK;

    if (pwszGuid == NULL)
    {
        rpcStatus = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    RpcTryExcept 
    {
        rpcStatus = RpcEapolReAuthenticateInterface (
                        pSrvAddr, 
                        pwszGuid
                        );
    }
    RpcExcept(TRUE)
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

exit:
    return rpcStatus;
}


//---------------------------------------
// WZCEapolQueryState: Query EAPOL interface state
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   pIntfState:
//      [in, out] EAPOL State
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolQueryState (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid,
    IN OUT  PEAPOL_INTF_STATE   pIntfState
    )
{
    DWORD rpcStatus = RPC_S_OK;

    if (pwszGuid == NULL)
    {
        rpcStatus = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    RpcTryExcept 
    {
        rpcStatus = RpcEapolQueryInterfaceState (
                        pSrvAddr, 
                        pwszGuid,
                        pIntfState
                        );
    }
    RpcExcept(TRUE)
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

exit:
    return rpcStatus;
}


//---------------------------------------
// WZCEapolUIResponse: Send Dlg response to Service
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   EapolUIContext:
//     [in]  EAPOLUI Context data
//   EapolUI:
//     [in]  EAPOLUI response data
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolUIResponse (
    LPWSTR                  pSrvAddr,
    EAPOL_EAP_UI_CONTEXT    EapolUIContext,
    EAPOLUI_RESP            EapolUIResp
    )
{
    DWORD rpcStatus = RPC_S_OK;

    RpcTryExcept 
    {
        rpcStatus = RpcEapolUIResponse (
                        pSrvAddr, 
                        EapolUIContext,
                        EapolUIResp
                        );
    }
    RpcExcept(TRUE)
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return rpcStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\client\precomp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    precomp.h

Abstract:

    Precompiled header for winipsec.dll.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <rpc.h>
#include <windows.h>
#include <regstr.h>
#include <setupapi.h>
#include <wchar.h>
#include <raseapif.h>
#include <wzcsapi.h>

#include "wzc_c.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\client\wzcdbapi.c ===
#include "precomp.h"

const ULONG guFatalExceptions[] =
    {
    STATUS_ACCESS_VIOLATION,
    STATUS_POSSIBLE_DEADLOCK,
    STATUS_INSTRUCTION_MISALIGNMENT,
    STATUS_DATATYPE_MISALIGNMENT,
    STATUS_PRIVILEGED_INSTRUCTION,
    STATUS_ILLEGAL_INSTRUCTION,
    STATUS_BREAKPOINT,
    STATUS_STACK_OVERFLOW
    };


const int FATAL_EXCEPTIONS_ARRAY_SIZE =
    sizeof(guFatalExceptions) / sizeof(guFatalExceptions[0]);


#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) {                   \
        goto error;                  \
    }

DWORD
TranslateExceptionCode(
    DWORD dwExceptionCode
    )
{
    return (dwExceptionCode);
}


int
RPC_ENTRY
I_RpcExceptionFilter(
    unsigned long uExceptionCode
    )
{
    int i = 0;


    for (i = 0; i < FATAL_EXCEPTIONS_ARRAY_SIZE; i ++) {

        if (uExceptionCode == guFatalExceptions[i]) {
            return EXCEPTION_CONTINUE_SEARCH;
        }

    }

    return EXCEPTION_EXECUTE_HANDLER;
}


DWORD
WZCDestroyClientContextHandle(
    DWORD dwStatus,
    HANDLE hFilter
    )
{
    DWORD dwError = 0;


    switch (dwStatus) {

    case RPC_S_SERVER_UNAVAILABLE:
    case RPC_S_CALL_FAILED:
    case RPC_S_CALL_FAILED_DNE:
    case RPC_S_UNKNOWN_IF:

        RpcTryExcept {

            RpcSsDestroyClientContext(&hFilter);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwError = TranslateExceptionCode(RpcExceptionCode());
            BAIL_ON_WIN32_ERROR(dwError);

        } RpcEndExcept

        break;

    default:

        dwError = dwStatus;
        break;

    }

error:

    return (dwError);
}


DWORD
OpenWZCDbLogSession(
    LPWSTR pServerName,
    DWORD dwVersion,
    PHANDLE phSession
    )
{
    DWORD dwError = 0;


    if (dwVersion) {
        return (ERROR_INVALID_LEVEL);
    }

    if (!phSession) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcOpenWZCDbLogSession(
                      pServerName,
                      phSession
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
CloseWZCDbLogSession(
    HANDLE hSession
    )
{
    DWORD dwError = 0;


    if (!hSession) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcCloseWZCDbLogSession(
                      &hSession
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    if (dwError) {
        dwError = WZCDestroyClientContextHandle(
                      dwError,
                      hSession
                      );
    }

    return (dwError);
}


DWORD
EnumWZCDbLogRecords(
    HANDLE hSession,
    PWZC_DB_RECORD pTemplateRecord,
    PBOOL pbEnumFromStart,
    DWORD dwPreferredNumEntries,
    PWZC_DB_RECORD * ppWZCRecords,
    LPDWORD pdwNumRecords,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    WZC_DB_RECORD_CONTAINER RecordContainer;
    PWZC_DB_RECORD_CONTAINER pRecordContainer = &RecordContainer;
    WZC_DB_RECORD_CONTAINER TemplateRecordContainer;
    PWZC_DB_RECORD_CONTAINER pTemplateRecordContainer = &TemplateRecordContainer;


    if (pvReserved != NULL) {
        return (ERROR_INVALID_LEVEL);
    }

    memset(pRecordContainer, 0, sizeof(WZC_DB_RECORD_CONTAINER));

    memset(pTemplateRecordContainer, 0, sizeof(WZC_DB_RECORD_CONTAINER));

    if (!hSession || !pbEnumFromStart) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (!ppWZCRecords || !pdwNumRecords) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pTemplateRecord) {
        pTemplateRecordContainer->dwNumRecords = 1;
        pTemplateRecordContainer->pWZCRecords = pTemplateRecord;
    }

    RpcTryExcept {

        dwError = RpcEnumWZCDbLogRecords(
                      hSession,
                      pTemplateRecordContainer,
                      pbEnumFromStart,
                      dwPreferredNumEntries,
                      &pRecordContainer
                      );
        if (dwError != ERROR_NO_MORE_ITEMS) {
            BAIL_ON_WIN32_ERROR(dwError);
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppWZCRecords = pRecordContainer->pWZCRecords;
    *pdwNumRecords = pRecordContainer->dwNumRecords;

    return (dwError);

error:

    *ppWZCRecords = NULL;
    *pdwNumRecords = 0;

    return (dwError);
}


DWORD
FlushWZCDbLog(
    HANDLE hSession
    )
{
    DWORD dwError = 0;


    if (!hSession) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcFlushWZCDbLog(
                      hSession
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}

/*
  GetSpecificLogRecord: Wrapper for the RPC call to get a specific record
  
  Arguments:
  [in] hSession - Handle to the database session
  [in] pwzcTemplate - Type of record to locate
  [out] ppWZCRecords - List of records retrieved
  pvReserved - Reserved

  Returns:
  ERROR_SUCCESS on success
*/

DWORD GetSpecificLogRecord(HANDLE hSession,
                           PWZC_DB_RECORD pTemplateRecord,
                           PWZC_DB_RECORD *ppWZCRecords,
                           LPDWORD        pdwNumRecords,
                           LPVOID         pvReserved)
{
    DWORD dwError = 0;
    WZC_DB_RECORD_CONTAINER RecordContainer;
    PWZC_DB_RECORD_CONTAINER pRecordContainer = &RecordContainer;
    WZC_DB_RECORD_CONTAINER TemplateRecordContainer;
    PWZC_DB_RECORD_CONTAINER pTemplateRecordContainer=&TemplateRecordContainer;

    if (pvReserved != NULL) 
    {
        return (ERROR_INVALID_LEVEL);
    }

    memset(pRecordContainer, 0, sizeof(WZC_DB_RECORD_CONTAINER));

    memset(pTemplateRecordContainer, 0, sizeof(WZC_DB_RECORD_CONTAINER));

    if (!hSession) 
    {
        return (ERROR_INVALID_PARAMETER);
    }

    if (!ppWZCRecords || !pdwNumRecords) 
    {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pTemplateRecord) 
    {
        pTemplateRecordContainer->dwNumRecords = 1;
        pTemplateRecordContainer->pWZCRecords = pTemplateRecord;
    }

    RpcTryExcept 
    {
        dwError = RpcGetWZCDbLogRecord(hSession,
                                       pTemplateRecordContainer,
                                       &pRecordContainer);
        if (dwError != ERROR_NO_MORE_ITEMS) 
        {
            BAIL_ON_WIN32_ERROR(dwError);
        }

    } 
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
    {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);
        
    } RpcEndExcept

    *ppWZCRecords = pRecordContainer->pWZCRecords;
    *pdwNumRecords = pRecordContainer->dwNumRecords;

    return (dwError);

error:

    *ppWZCRecords = NULL;
    *pdwNumRecords = 0;

    return (dwError);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\client\rpcbind.c ===
#include <precomp.h>

LPWSTR pszStrBindingOptions = L"Security=Impersonation Dynamic False";

handle_t
STRING_HANDLE_bind(
    STRING_HANDLE lpStr)
{
    RPC_STATUS RpcStatus = RPC_S_OK;
    LPWSTR     strSrv;
    LPWSTR     pszStringBinding = NULL;
    handle_t   hBinding = NULL;
    LPWSTR     pszServerPrincipalName = NULL;
    BOOL       bBound = FALSE;

    strSrv = (!lpStr || !*lpStr || !lstrcmp(L"127.0.0.1", lpStr)) ? NULL : lpStr;
    RpcStatus = RpcStringBindingComposeW(
                    0,
                    (strSrv==NULL) ? L"ncalrpc" : L"ncacn_np",
                    strSrv,
                    (strSrv==NULL) ? L"wzcsvc" : L"\\pipe\\wzcsvc",
                    pszStrBindingOptions,
                    &pszStringBinding);

    if (RpcStatus == RPC_S_OK)
    {
        RpcStatus = RpcBindingFromStringBindingW(
                        pszStringBinding,
                        &hBinding);
        RpcStringFreeW(&pszStringBinding);
        bBound = (RpcStatus == RPC_S_OK);
    }

    if (RpcStatus == RPC_S_OK)
    {
        RpcStatus = RpcBindingSetOption(
                        hBinding,
                        RPC_C_OPT_UNIQUE_BINDING,
                        (ULONG_PTR) 1);
    }

    if (RpcStatus == RPC_S_OK)
    {
        RpcStatus = RpcMgmtInqServerPrincName(
                        hBinding,
                        RPC_C_AUTHN_WINNT,
                        &pszServerPrincipalName);
    }

    if (RpcStatus == RPC_S_OK)
    {
        RpcStatus = RpcBindingSetAuthInfoW(
                        hBinding,
                        pszServerPrincipalName,
                        RPC_C_PROTECT_LEVEL_PKT_PRIVACY,
                        (strSrv==NULL) ? RPC_C_AUTHN_WINNT : RPC_C_AUTHN_GSS_NEGOTIATE,
                        NULL,
                        RPC_C_AUTHZ_NONE);
    }

    if (pszServerPrincipalName)
        RpcStringFree(&pszServerPrincipalName);

    if ( bBound && RpcStatus != RPC_S_OK)
    {
        STRING_HANDLE_unbind(lpStr, hBinding);
        hBinding = NULL;
    }

    return (hBinding);
}


VOID
STRING_HANDLE_unbind(
    STRING_HANDLE lpStr,
    handle_t      hBinding)
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);
}


handle_t
WZC_DBLOG_SESSION_HANDLE_bind(
    WZC_DBLOG_SESSION_HANDLE hSession,
    STRING_HANDLE lpStr
    )
{
    RPC_STATUS RpcStatus = 0;
    LPWSTR     strSrv = NULL;
    LPWSTR     pszStringBinding = NULL;
    handle_t   hBinding = NULL;


    strSrv = (!lpStr || !*lpStr || !lstrcmp(L"127.0.0.1", lpStr)) ? NULL : lpStr;
    RpcStatus = RpcStringBindingComposeW(
                    0,
                    (strSrv==NULL) ? L"ncalrpc" : L"ncacn_np",
                    strSrv,
                    (strSrv==NULL) ? L"wzcsvc" : L"\\pipe\\wzcsvc",
                    pszStrBindingOptions,
                    &pszStringBinding
                    );

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                     pszStringBinding,
                     &hBinding
                     );
    RpcStringFreeW(&pszStringBinding);

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    return (hBinding);
}


VOID
WZC_DBLOG_SESSION_HANDLE_unbind(
    WZC_DBLOG_SESSION_HANDLE hSession,
    handle_t hBinding
    )
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);

    ASSERT(RpcStatus == RPC_S_OK);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\client\util.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       U T I L. C
//
//  Contents:   Utility functions 
//
//
//----------------------------------------------------------------------------

#include "util.h"

//+---------------------------------------------------------------------------
//
// EAPOL related util functions
//
//+---------------------------------------------------------------------------

// EAP configuration registry definitions.

static WCHAR REGKEY_Eap[] = L"System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP";
static WCHAR REGVAL_szFriendlyName[] = L"FriendlyName";
static WCHAR REGVAL_szConfigDll[] = L"ConfigUIPath";
static WCHAR REGVAL_szIdentityDll[] = L"IdentityPath";
static WCHAR REGVAL_fRequirePwd[] = L"InvokePasswordDialog";
static WCHAR REGVAL_fRequireUser[] = L"InvokeUsernameDialog";
static WCHAR REGVAL_pData[] = L"ConfigData";
static WCHAR REGVAL_fForceConfig[] = L"RequireConfigUI";
static WCHAR REGVAL_fMppeSupported[] = L"MPPEEncryptionSupported";

// Location of User blob
#define cwszEapKeyEapolUser     L"Software\\Microsoft\\EAPOL\\UserEapInfo"
#define cwszDefault             L"Default"

BYTE    g_bDefaultSSID[MAX_SSID_LEN]={0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22, 0x33, 0x11, 0x22};

//
// EAP configuration manipulation routines 
//

//+---------------------------------------------------------------------------
//
// Returns a created, empty EAPCFG descriptor node, or NULL on error.
//

DTLNODE*
CreateEapcfgNode (
    void 
    )
{
    DTLNODE*    pNode = NULL;
    EAPCFG*     pEapcfg = NULL;

    pNode = DtlCreateSizedNode( sizeof(EAPCFG), 0L );
    if (pNode)
    {
        pEapcfg = (EAPCFG* )DtlGetData( pNode );
        
        if (pEapcfg)
        {
            pEapcfg->dwKey = (DWORD )-1;
            pEapcfg->pszConfigDll = NULL;
            pEapcfg->pszIdentityDll = NULL;
            pEapcfg->dwStdCredentialFlags = 0;
            pEapcfg->fProvidesMppeKeys = FALSE;
            pEapcfg->fForceConfig = FALSE;
            pEapcfg->pData = NULL;
            pEapcfg->cbData = 0;
            pEapcfg->fConfigDllCalled = FALSE;
        }
    }

    return pNode;
}


//+---------------------------------------------------------------------------
//
// Release resources associated with EAPCFG node 'pNode'.  See
// DtlDestroyList.
//

VOID
DestroyEapcfgNode (
    IN OUT DTLNODE* pNode 
    )
{
    EAPCFG* pEapcfg = NULL;

    pEapcfg = (EAPCFG* )DtlGetData( pNode );

    if (pEapcfg)
    {
        if (pEapcfg->pszConfigDll)
            FREE ( pEapcfg->pszConfigDll );
        if (pEapcfg->pszIdentityDll)
            FREE ( pEapcfg->pszIdentityDll );
        if (pEapcfg->pData)
            FREE ( pEapcfg->pData );
        if (pEapcfg->pszFriendlyName)
            FREE ( pEapcfg->pszFriendlyName );
    }

    DtlDestroyNode( pNode );
}

    
//+---------------------------------------------------------------------------
//
// Returns the EAPCFG node in list 'pList' with EAP key value of 'dwKey'
// or NULL if not found.
//

DTLNODE*
EapcfgNodeFromKey(
    IN  DTLLIST*    pList,
    IN  DWORD       dwKey 
    )
{
    DTLNODE* pNode = NULL;

    for (pNode = DtlGetFirstNode( pList );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        EAPCFG* pEapcfg = (EAPCFG* )DtlGetData( pNode );

        if (pEapcfg)
        {
            if (pEapcfg->dwKey == dwKey)
            {
                return pNode;
            }
        }
    }

    return NULL;
}


//+---------------------------------------------------------------------------
//
// Returns the address of a created list of installed custom
// authentication packages or NULL if none could be read.  On success, it
// is caller's responsibility to eventually call DtlDestroyList on the
// returned list.
//

DTLLIST*
ReadEapcfgList (
        IN  DWORD   dwFlags
        )
{

    DWORD       dwErr = 0;
    BOOL        fOk = FALSE;
    DTLLIST*    pList = NULL;
    DTLNODE*    pNode = NULL;
    EAPCFG*     pEapcfg = NULL;
    HKEY        hkeyLM = NULL;
    HKEY        hkeyEap = NULL;
    HKEY        hkeyPackage = NULL;
    CHAR        szEapType[ 11 + 1 ];
    DWORD       dwEapType = 0;
    TCHAR*      psz = NULL;
    DWORD       dw;
    DWORD       cb;
    INT         i;
    TCHAR*      szCLSID = NULL;
    DWORD       dwHidePEAPMSCHAPv2 = 0;
    HRESULT     hr = S_OK;

    pList = DtlCreateList( 0L );
    if (!pList)
    {
        return NULL;
    }

    // Open the EAP key which contains a sub-key for each installed package.
   
    dwErr = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, (LPCTSTR)REGKEY_Eap, 0, KEY_READ, &hkeyEap );

    if (dwErr != NO_ERROR)
    {
        return pList;
    }

    // Display EAP-MSCHAPv2 as an EAP method?
    GetRegDword( hkeyEap, RAS_EAP_VALUENAME_HIDEPEAPMSCHAPv2, &dwHidePEAPMSCHAPv2 );

    // Open each sub-key and extract the package definition from it's values.
    // Problems with opening individual sub-keys result in that node only
    // being discarded.
    
    for (i = 0; TRUE; ++i)
    {
        cb = sizeof(szEapType);
        dwErr = RegEnumKeyExA(
            hkeyEap, i, szEapType, &cb, NULL, NULL, NULL, NULL );
        if (dwErr != 0)
        {
            // Includes "out of items", the normal loop termination.
           
            break;
        }

        dwEapType = atol (szEapType);
        if (dwHidePEAPMSCHAPv2 != 0)
        {
            if (dwEapType == EAP_TYPE_MSCHAPv2)
            {
                // ignore EAP-MSCHAPv2
                continue;
            }
        }

        // Ignored non-mutual-auth DLLs like EAP
        if (dwFlags & EAPOL_MUTUAL_AUTH_EAP_ONLY)
        {
            if (dwEapType == EAP_TYPE_MD5)
            {
                continue;
            }
        }

        dwErr = RegOpenKeyExA(
            hkeyEap, szEapType, 0, KEY_READ, &hkeyPackage );
        if (dwErr != 0)
        {
            continue;
        }

        do
        {

            // Roles Supported

            dw = RAS_EAP_ROLE_AUTHENTICATEE;
            GetRegDword( hkeyPackage, RAS_EAP_VALUENAME_ROLES_SUPPORTED, &dw );

            if (!(dw & RAS_EAP_ROLE_AUTHENTICATEE))
            {
                break;
            }

            if (dw & RAS_EAP_ROLE_EXCLUDE_IN_EAP)
            {
                break;
            }

            pNode = CreateEapcfgNode();
            if (!pNode)
            {
                break;
            }

            pEapcfg = (EAPCFG* )DtlGetData( pNode );

            if (!pEapcfg)
            {
                break;
            }

            // EAP type ID.
            
            pEapcfg->dwKey = (LONG )atol( szEapType );

            // Friendly display name.
            
            psz = NULL;
            dwErr = GetRegSz( hkeyPackage, REGVAL_szFriendlyName, &psz );
            if (dwErr != 0)
            {
                break;
            }
            pEapcfg->pszFriendlyName = psz;

            // Configuration DLL path.
            
            psz = NULL;
            dwErr = GetRegExpandSz( hkeyPackage, REGVAL_szConfigDll, &psz );
            if (dwErr != 0)
            {
                break;
            }
            if (*psz)
            {
                pEapcfg->pszConfigDll = psz;
            }
            else
            {
                FREE ( psz );
            }

            // Identity DLL path.
            
            psz = NULL;
            dwErr = GetRegExpandSz( hkeyPackage, REGVAL_szIdentityDll, &psz );
            if (dwErr != 0)
            {
                break;
            }
            if (*psz)
            {
                pEapcfg->pszIdentityDll = psz;
            }
            else
            {
                FREE ( psz );
            }

            // Prompt user name
            
            dw = 1;
            GetRegDword( hkeyPackage, REGVAL_fRequireUser, &dw );
            if (dw)
                pEapcfg->dwStdCredentialFlags |= EAPCFG_FLAG_RequireUsername;

            // Prompt password
            
            dw = 0;
            GetRegDword( hkeyPackage, REGVAL_fRequirePwd, &dw );
            if (dw)
                pEapcfg->dwStdCredentialFlags |= EAPCFG_FLAG_RequirePassword;

            // MPPE encryption keys flag.
            
            dw = 0;
            GetRegDword( hkeyPackage, REGVAL_fMppeSupported, &dw );
            pEapcfg->fProvidesMppeKeys = !!dw;

            // Force configuration API to run at least once.
            
            dw = FALSE;
            GetRegDword( hkeyPackage, REGVAL_fForceConfig, &dw );
            pEapcfg->fForceConfig = !!dw;

            // Configuration blob.
            
            GetRegBinary(
                hkeyPackage, REGVAL_pData,
                &pEapcfg->pData, &pEapcfg->cbData );

            // ConfigCLSID
           
            dwErr = GetRegSz( hkeyPackage, RAS_EAP_VALUENAME_CONFIG_CLSID,
                        &szCLSID );
            if (dwErr != 0)
            {
                break;
            }

            // Ignore errors. Eg. EAP MD5-Challenge does not have a ConfigCLSID.
            //
            // hr = CLSIDFromString( szCLSID, &( pEapcfg->guidConfigCLSID ) );

            FREE ( szCLSID );

            // Add the completed node to the list.
            
            DtlAddNodeLast( pList, pNode );

            fOk = TRUE;

        } while (FALSE);

        if (!fOk && pNode)
        {
            DestroyEapcfgNode( pNode );
        }

        RegCloseKey( hkeyPackage );
    }

    RegCloseKey( hkeyEap );

    return pList;
}


//+---------------------------------------------------------------------------
//
// Allocates a sized node with space for 'lDataBytes' bytes of user data
// built-in.  The node is initialized to contain the address of the
// built-in user data block (or NULL if of zero length) and the
// user-defined node identification code 'lNodeId'.  The user data block
// is zeroed.
// 
// Returns the address of the new node or NULL if out of memory.
//

DTLNODE*
DtlCreateSizedNode (
    IN LONG lDataBytes,
    IN LONG_PTR lNodeId 
    )
{
    DTLNODE* pdtlnode = (DTLNODE *) MALLOC ( sizeof(DTLNODE) + lDataBytes );

    if (pdtlnode)
    {
        ZeroMemory( pdtlnode, sizeof(DTLNODE) + lDataBytes );

        if (lDataBytes)
            pdtlnode->pData = pdtlnode + 1;

        pdtlnode->lNodeId = lNodeId;
    }

    return pdtlnode;
}


//+---------------------------------------------------------------------------
//
// Deallocates node 'pdtlnode'.  It is the caller's responsibility to free
// the entry in an unsized node, if necessary.
//

VOID
DtlDestroyNode (
    IN OUT DTLNODE* pdtlnode 
    )
{
    if (pdtlnode != NULL)
    {
        FREE ( pdtlnode );
    }
}


//+---------------------------------------------------------------------------
//
// Adds 'pdtlnode' at the end of list 'pdtllist'.
// 
// Returns the address of the added node, i.e. 'pdtlnode'.
//

DTLNODE*
DtlAddNodeLast (
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnode 
    )
{
    if (pdtllist->lNodes)
    {
        pdtlnode->pdtlnodePrev = pdtllist->pdtlnodeLast;
        pdtllist->pdtlnodeLast->pdtlnodeNext = pdtlnode;
    }
    else
    {
        pdtlnode->pdtlnodePrev = NULL;
        pdtllist->pdtlnodeFirst = pdtlnode;
    }

    pdtllist->pdtlnodeLast = pdtlnode;
    pdtlnode->pdtlnodeNext = NULL;

    ++pdtllist->lNodes;
    return pdtlnode;
}


//+---------------------------------------------------------------------------
//
// Removes node 'pdtlnodeInList' from list 'pdtllist'.
//
// Returns the address of the removed node, i.e. 'pdtlnodeInList'.
//

DTLNODE*
DtlRemoveNode (
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnodeInList 
    )
{
    if (pdtlnodeInList->pdtlnodePrev)
        pdtlnodeInList->pdtlnodePrev->pdtlnodeNext = pdtlnodeInList->pdtlnodeNext;
    else
        pdtllist->pdtlnodeFirst = pdtlnodeInList->pdtlnodeNext;

    if (pdtlnodeInList->pdtlnodeNext)
        pdtlnodeInList->pdtlnodeNext->pdtlnodePrev = pdtlnodeInList->pdtlnodePrev;
    else
        pdtllist->pdtlnodeLast = pdtlnodeInList->pdtlnodePrev;

    --pdtllist->lNodes;
    return pdtlnodeInList;
}


//+---------------------------------------------------------------------------
//
// Allocates a list and initializes it to empty.  The list is marked with
// the user-defined list identification code 'lListId'.
//
// Returns the address of the list control block or NULL if out of memory.
//

DTLLIST*
DtlCreateList (
    IN LONG lListId 
    )
{
    DTLLIST* pdtllist = MALLOC (sizeof(DTLLIST));

    if (pdtllist)
    {
        pdtllist->pdtlnodeFirst = NULL;
        pdtllist->pdtlnodeLast = NULL;
        pdtllist->lNodes = 0;
        pdtllist->lListId = lListId;
    }

    return pdtllist;
}


//+---------------------------------------------------------------------------
//
// Deallocates all nodes in list 'pdtllist' using the node deallocation
// function 'pfuncDestroyNode' if non-NULL or DtlDestroyNode otherwise.
// Won't GP-fault if passed a NULL list, e.g. if 'pdtllist', was never
// allocated.
//

VOID
DtlDestroyList (
    IN OUT DTLLIST*     pdtllist,
    IN     PDESTROYNODE pfuncDestroyNode 
    )
{
    if (pdtllist)
    {
        DTLNODE* pdtlnode;

        while (pdtlnode = DtlGetFirstNode( pdtllist ))
        {
            DtlRemoveNode( pdtllist, pdtlnode );
            if (pfuncDestroyNode)
                pfuncDestroyNode( pdtlnode );
            else
                DtlDestroyNode( pdtlnode );
        }

        FREE ( pdtllist );
    }
}


//+---------------------------------------------------------------------------
//
// Set '*ppbResult' to the BINARY registry value 'pszName' under key
// 'hkey'.  If the value does not exist *ppbResult' is set to NULL.
// '*PcbResult' is the number of bytes in the returned '*ppbResult'.  It
// is caller's responsibility to Free the returned block.
//

VOID
GetRegBinary (
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT BYTE** ppbResult,
    OUT DWORD* pcbResult 
    )
{
    DWORD       dwErr;
    DWORD       dwType;
    BYTE*       pb;
    DWORD       cb;

    *ppbResult = NULL;
    *pcbResult = 0;

    // Get result buffer size required.
    
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, NULL, &cb );
    if (dwErr != NO_ERROR)
    {
        return;
    }

    // Allocate result buffer.
    
    pb = MALLOC (cb);
    if (!pb)
    {
        return;
    }

    // Get the result block.
   
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, (LPBYTE )pb, &cb );
    if (dwErr == NO_ERROR)
    {
        *ppbResult = pb;
        *pcbResult = cb;
    }
}


//+---------------------------------------------------------------------------
//
// Set '*pdwResult' to the DWORD registry value 'pszName' under key
// 'hkey'.  If the value does not exist '*pdwResult' is unchanged.
//

VOID
GetRegDword (
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT DWORD* pdwResult 
    )
{
    DWORD       dwErr;
    DWORD       dwType;
    DWORD       dwResult;
    DWORD       cb;

    cb = sizeof(DWORD);
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, (LPBYTE )&dwResult, &cb );

    if ((dwErr == NO_ERROR) && dwType == REG_DWORD && cb == sizeof(DWORD))
    {
        *pdwResult = dwResult;
    }
}


//+---------------------------------------------------------------------------
//
// Set '*ppszResult' to the fully expanded EXPAND_SZ registry value
// 'pszName' under key 'hkey'.  If the value does not exist *ppszResult'
// is set to empty string.
//
// Returns 0 if successful or an error code.  It is caller's
// responsibility to Free the returned string.
//

DWORD
GetRegExpandSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult )

{
    DWORD dwErr;
    DWORD cb;
    TCHAR* pszResult;

    // Get the unexpanded result string.
    //
    dwErr = GetRegSz( hkey, pszName, ppszResult );
    if (dwErr != 0)
    {
        return dwErr;
    }

    // Find out how big the expanded string will be.
    //
    cb = ExpandEnvironmentStrings( *ppszResult, NULL, 0 );
    if (cb == 0)
    {
        dwErr = GetLastError();
        FREE ( *ppszResult );
        return dwErr;
    }

    // Allocate a buffer for the expanded string.
    //
    pszResult = MALLOC ((cb + 1) * sizeof(TCHAR));
    if (!pszResult)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Expand the environmant variables in the string, storing the result in
    // the allocated buffer.
    //
    cb = ExpandEnvironmentStrings( *ppszResult, pszResult, cb + 1 );
    if (cb == 0)
    {
        dwErr = GetLastError();
        if (*ppszResult != NULL)
        {
            FREE ( *ppszResult );
        }
        if (pszResult != NULL)
        {
            FREE ( pszResult );
        }
        return dwErr;
    }

    FREE ( *ppszResult );
    *ppszResult = pszResult;
    return 0;
}


//+---------------------------------------------------------------------------
//
// Set '*ppszResult' to the SZ registry value 'pszName' under key 'hkey'.
// If the value does not exist *ppszResult' is set to empty string.
//
// Returns 0 if successful or an error code.  It is caller's
// responsibility to Free the returned string.
//

DWORD
GetRegSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult )

{
    DWORD       dwErr = NO_ERROR;
    DWORD       dwType;
    DWORD       cb;
    TCHAR*      pszResult;

    // Get result buffer size required.
    
    dwErr = RegQueryValueEx(
            hkey, pszName, NULL, &dwType, NULL, &cb );
    if (dwErr != NO_ERROR)
    {
        cb = sizeof(TCHAR);
    }

    // Allocate result buffer.
    
    pszResult = MALLOC (cb * sizeof(TCHAR));
    if (!pszResult)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *pszResult = TEXT('\0');
    *ppszResult = pszResult;

    // Get the result string.  It's not an error if we can't get it.
    
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, (LPBYTE )pszResult, &cb );

    return NO_ERROR;
}


//
// WZCGetEapUserInfo
//
// Description:
//
// Function called to retrieve the user data for an interface for a 
// specific EAP type and SSID (if any). Data is retrieved from the HKCU hive
//
// Arguments:
//  pwszGUID - pointer to GUID string for the interface
//  dwEapTypeId - EAP type for which user data is to be stored
//  dwSizeOfSSID - Size of Special identifier if any for the EAP user blob
//  pbSSID - Special identifier if any for the EAP user blob
//  pbUserInfo - output: pointer to EAP user data blob
//  dwInfoSize - output: pointer to size of EAP user blob
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
WZCGetEapUserInfo (
        IN  WCHAR           *pwszGUID,
        IN  DWORD           dwEapTypeId,
        IN  DWORD           dwSizeOfSSID,
        IN  BYTE            *pbSSID,
        IN  OUT PBYTE       pbUserInfo,
        IN  OUT DWORD       *pdwInfoSize
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    HKEY        hkey2 = NULL;
    DWORD       dwNumValues = 0, dwMaxValueNameLen = 0, dwTempValueNameLen = 0, dwMaxValueLen = 0;
    DWORD       dwIndex = 0, dwMaxValueName = 0;
    WCHAR       *pwszValueName = NULL;
    BYTE        *pbValueBuf = NULL;
    DWORD       dwValueData = 0;
    BYTE        *pbDefaultValue = NULL;
    DWORD       dwDefaultValueLen = 0;
    BYTE        *pbEapBlob = NULL;
    DWORD       dwEapBlob = 0;
    BYTE        *pbAuthData = NULL;
    DWORD       dwAuthData = 0;
    BOOLEAN     fFoundValue = FALSE;
    EAPOL_INTF_PARAMS   *pRegParams = NULL;
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = ERROR_SUCCESS;

    do
    {
        // Validate input params

        if (pwszGUID == NULL)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        if (dwEapTypeId == 0)
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Get handle to HKCU\Software\...\UserEapInfo

        if ((lError = RegOpenKeyEx (
                        HKEY_CURRENT_USER,
                        cwszEapKeyEapolUser,
                        0,
                        KEY_READ,
                        &hkey1
                        )) != ERROR_SUCCESS)
        {
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKCU\Software\...\UserEapInfo\<GUID>

        if ((lError = RegOpenKeyEx (
                        hkey1,
                        pwszGUID,
                        0,
                        KEY_READ,
                        &hkey2
                        )) != ERROR_SUCCESS)
        {
            dwRetCode = (DWORD)lError;
            break;
        }

        // Set correct SSID
        if (dwSizeOfSSID == 0)
        {
            pbSSID = g_bDefaultSSID;
            dwSizeOfSSID = MAX_SSID_LEN;
        }

        if ((lError = RegQueryInfoKey (
                        hkey2,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &dwNumValues,
                        &dwMaxValueNameLen,
                        &dwMaxValueLen,
                        NULL,
                        NULL
                )) != NO_ERROR)
        {
            dwRetCode = (DWORD)lError;
            break;
        }

        if ((pwszValueName = MALLOC ((dwMaxValueNameLen + 1) * sizeof (WCHAR))) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        dwMaxValueNameLen++;
        if ((pbValueBuf = MALLOC (dwMaxValueLen)) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        for (dwIndex = 0; dwIndex < dwNumValues; dwIndex++)
        {
            dwValueData = dwMaxValueLen;
            dwTempValueNameLen = dwMaxValueNameLen;
            if ((lError = RegEnumValue (
                            hkey2,
                            dwIndex,
                            pwszValueName,
                            &dwTempValueNameLen,
                            NULL,
                            NULL,
                            pbValueBuf,
                            &dwValueData
                            )) != ERROR_SUCCESS)
            {
                if (lError != ERROR_MORE_DATA)
                {
                    break;
                }
                lError = ERROR_SUCCESS;
            }

            if (dwValueData < sizeof (EAPOL_INTF_PARAMS))
            {
                lError = ERROR_INVALID_DATA;
                break;
            }
            pRegParams = (EAPOL_INTF_PARAMS *)pbValueBuf;

            if (((DWORD)_wtol(pwszValueName)) > dwMaxValueName)
            {
                dwMaxValueName = _wtol (pwszValueName);
            }

            if (!memcmp (pRegParams->bSSID, pbSSID, dwSizeOfSSID))
            {
                fFoundValue = TRUE;
                break;
            }
        }
        if ((lError != ERROR_SUCCESS) && (lError != ERROR_NO_MORE_ITEMS))
        {
            dwRetCode = (DWORD)lError;
            break;
        }
        else
        {
            lError = ERROR_SUCCESS;
        }

        if (!fFoundValue)
        {
            pbEapBlob = NULL;
            dwEapBlob = 0;
        }
        else
        {
            // Use pbValueBuf & dwValueData
            pbEapBlob = pbValueBuf;
            dwEapBlob = dwValueData;
        }

        // If default blob is not present, exit
        if ((pbEapBlob == NULL) && (dwEapBlob == 0))
        {
            *pdwInfoSize = 0;
            break;
        }

        if ((dwRetCode = WZCGetEapData (
                dwEapTypeId,
                dwEapBlob,
                pbEapBlob,
                sizeof (EAPOL_INTF_PARAMS),
                &dwAuthData,
                &pbAuthData
                )) != NO_ERROR)
        {
            break;
        }

        // Return the data if sufficient space allocated

        if ((pbUserInfo != NULL) && (*pdwInfoSize >= dwAuthData))
        {
            memcpy (pbUserInfo, pbAuthData, dwAuthData);
        }
        else
        {
            dwRetCode = ERROR_INSUFFICIENT_BUFFER;
        }
        *pdwInfoSize = dwAuthData;

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (hkey2 != NULL)
    {
        RegCloseKey (hkey2);
    }
    if (pbValueBuf != NULL)
    {
        FREE (pbValueBuf);
    }
    if (pbDefaultValue != NULL)
    {
        FREE (pbDefaultValue);
    }
    if (pwszValueName != NULL)
    {
        FREE (pwszValueName);
    }

    return dwRetCode;
}


//
// WZCGetEapData
//
// Description:
//
// Function to extract Eap Data out of a blob containing many EAP data
// 
// Arguments:
//      dwEapType -
//      dwSizeOfIn -
//      pbBufferIn -
//      dwOffset -
//      pdwSizeOfOut -
//      ppbBufferOut -
//
// Return values:
//
//

DWORD
WZCGetEapData (
        IN  DWORD   dwEapType,
        IN  DWORD   dwSizeOfIn,
        IN  BYTE    *pbBufferIn,
        IN  DWORD   dwOffset,
        IN  DWORD   *pdwSizeOfOut,
        IN  PBYTE   *ppbBufferOut
        )
{
    DWORD   dwRetCode = NO_ERROR;
    DWORD   cbOffset = 0;
    EAPOL_AUTH_DATA   *pCustomData = NULL;

    do
    {
        *pdwSizeOfOut = 0;
        *ppbBufferOut = NULL;

        if (pbBufferIn == NULL)
        {
            break;
        }

        // Align to start of EAP blob
        cbOffset = dwOffset;

        while (cbOffset < dwSizeOfIn)
        {
            pCustomData = (EAPOL_AUTH_DATA *) 
                ((PBYTE) pbBufferIn + cbOffset);

            if (pCustomData->dwEapType == dwEapType)
            {
                break;
            }
            cbOffset += sizeof (EAPOL_AUTH_DATA) + pCustomData->dwSize;
        }

        if (cbOffset < dwSizeOfIn)
        {
            *pdwSizeOfOut = pCustomData->dwSize;
            *ppbBufferOut = pCustomData->bData;
        }
    }
    while (FALSE);

    return dwRetCode;
}


//
// WZCEapolFreeState
//
// Description:
//
// Function to free EAPOL interface state information on the client side 
// obtained via RPC query
// 
// Arguments:
//      pIntfState -
//
// Return values:
//
//

DWORD
WZCEapolFreeState (
        IN  EAPOL_INTF_STATE    *pIntfState
        )
{
    DWORD   dwRetCode = NO_ERROR;

    do
    {
        RpcFree(pIntfState->pwszLocalMACAddr);
        RpcFree(pIntfState->pwszRemoteMACAddr);
        RpcFree(pIntfState->pszEapIdentity);
    }
    while (FALSE);

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\idl\import.h ===
#pragma once

#ifdef MIDL_PASS
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define BOOL DWORD
#endif

#include <wzcsapi.h>
#include <wzcmon.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\deviceio.c ===
#include <precomp.h>
#include "tracing.h"
#include "utils.h"
#include "intflist.h"
#include "deviceio.h"
#include "intfhdl.h"

//------------------------------------------------------
// Open a handle to Ndisuio and returns it to the caller
DWORD
DevioGetNdisuioHandle (
    PHANDLE  pHandle)   // OUT opened handle to Ndisuio
{
    DWORD   dwErr = ERROR_SUCCESS;
    HANDLE  hHandle;
    DWORD   dwOutSize;

    DbgAssert((pHandle != NULL, "NULL pointer to output handle?"));

    hHandle = CreateFileA(
                "\\\\.\\\\Ndisuio",
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL);
    if (hHandle == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        DbgPrint((TRC_ERR,"Err: Open Ndisuio->%d", dwErr));
        goto exit;
    }

    // make sure NDISUIO binds to all relevant interfaces
    if (!DeviceIoControl(
                hHandle,
                IOCTL_NDISUIO_BIND_WAIT,
                NULL,
                0,
                NULL,
                0,
                &dwOutSize,
                NULL))
    {
        dwErr = GetLastError();
        DbgPrint((TRC_ERR,"Err: IOCTL_NDISUIO_BIND_WAIT->%d", dwErr));
        goto exit;
    }

    *pHandle = hHandle;

exit:
    return dwErr;
}

//------------------------------------------------------
// Checks the NDISUIO_QUERY_BINDING object for consistency
// against the length for this binding as returned by NDISUIO.
DWORD
DevioCheckNdisBinding(
    PNDISUIO_QUERY_BINDING pndBinding,
    ULONG    nBindingLen)
{
    DWORD dwErr = ERROR_SUCCESS;

    // check for the data to contain at least the NDISUIO_QUERY_BINDING
    // header (that is offsets & lengths fields should be there)
    if (nBindingLen < sizeof(NDISUIO_QUERY_BINDING))
        dwErr = ERROR_INVALID_DATA;

    // check the offsets are correctly set over the NDISUIO_QUERY_BINDING header
    // and within the length indicated by nBindingLen
    if (dwErr == ERROR_SUCCESS &&
        ((pndBinding->DeviceNameOffset < sizeof(NDISUIO_QUERY_BINDING)) ||
         (pndBinding->DeviceNameOffset > nBindingLen) ||
         (pndBinding->DeviceDescrOffset < sizeof(NDISUIO_QUERY_BINDING)) ||
         (pndBinding->DeviceDescrOffset > nBindingLen)
        )
       )
        dwErr = ERROR_INVALID_DATA;

    // check whether the lengths are correctly set within the limits 
    if (dwErr == ERROR_SUCCESS &&
        ((pndBinding->DeviceNameLength > nBindingLen - pndBinding->DeviceNameOffset) ||
         (pndBinding->DeviceDescrLength > nBindingLen - pndBinding->DeviceDescrOffset)
        )
       )
        dwErr = ERROR_INVALID_DATA;

    return dwErr;
}

//------------------------------------------------------
// Get the NDISUIO_QUERY_BINDING for the interface index nIntfIndex.
// If hNdisuio is valid, this handle is used, otherwise a local handle
// is opened, used and closed before returning.
DWORD
DevioGetIntfBindingByIndex(
    HANDLE      hNdisuio,   // IN opened handle to NDISUIO. If INVALID_HANDLE_VALUE, open one locally
    UINT        nIntfIndex, // IN interface index to look for
    PRAW_DATA   prdOutput)  // OUT result of the IOCTL
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    bLocalHandle = FALSE;

    DbgPrint((TRC_TRACK,"[DevioGetIntfBindingByIndex(%d..)", nIntfIndex));

    // assert what are the expected valid parameters
    DbgAssert((prdOutput != NULL && 
               prdOutput->dwDataLen > sizeof(NDISUIO_QUERY_BINDING),
              "Invalid input parameters"));

    // see if Ndisuio should be opened locally
    if (hNdisuio == INVALID_HANDLE_VALUE)
    {
        dwErr = DevioGetNdisuioHandle(&hNdisuio);
        bLocalHandle = (dwErr == ERROR_SUCCESS);
    }

    // if everything went well, go query the driver for the Binding structure
    if (dwErr == ERROR_SUCCESS)
    {
        PNDISUIO_QUERY_BINDING pndBinding;
        DWORD dwOutSize;

        ZeroMemory(prdOutput->pData, prdOutput->dwDataLen);
        pndBinding = (PNDISUIO_QUERY_BINDING)prdOutput->pData;
        pndBinding->BindingIndex = nIntfIndex;
        if (!DeviceIoControl(
                hNdisuio,
                IOCTL_NDISUIO_QUERY_BINDING,
                prdOutput->pData,
                prdOutput->dwDataLen,
                prdOutput->pData,
                prdOutput->dwDataLen,
                &dwOutSize,
                NULL))
        {
            // if the index is over the number of interfaces
            // we'll have here ERROR_NO_MORE_ITEMS which will be carried out
            // to the caller
            dwErr = GetLastError();
            DbgPrint((TRC_ERR,"Err: IOCTL_NDISUIO_QUERY_BINDING->%d", dwErr));
        }
        else
        {
            dwErr = DevioCheckNdisBinding(pndBinding, dwOutSize);
        }
    }

    // close the handle if it was opened locally
    if (bLocalHandle)
        CloseHandle(hNdisuio);

    DbgPrint((TRC_TRACK,"DevioGetIntfBindingByIndex]=%d", dwErr));
    return dwErr;
}

//------------------------------------------------------
// Get the NDISUIO_QUERY_BINDING for the interface having
// the GUID wszGuid. If hNdisuio is INVALID_HANDLE_VALUE
// a local handle is opened, used and closed at the end
DWORD
DevioGetInterfaceBindingByGuid(
    HANDLE      hNdisuio,   // IN opened handle to NDISUIO
    LPWSTR      wszGuid,    // IN interface GUID as "{guid}"
    PRAW_DATA   prdOutput)  // OUT result of the IOCTL
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    bLocalHandle = FALSE;
    INT     i;

    // assert what are the expected valid parameters
    DbgAssert((wszGuid != NULL &&
               prdOutput != NULL &&
               prdOutput->dwDataLen > sizeof(NDISUIO_QUERY_BINDING),
               "Invalid input parameter"));

    DbgPrint((TRC_TRACK,"[DevioGetInterfaceBindingByGuid(%S..)", wszGuid));

    // see if Ndisuio should be opened locally
    if (hNdisuio == INVALID_HANDLE_VALUE)
    {
        dwErr = DevioGetNdisuioHandle(&hNdisuio);
        bLocalHandle = (dwErr == ERROR_SUCCESS);
    }

    // iterate through all the interfaces, one by one!! No other better way to do this
    for (i = 0; dwErr == ERROR_SUCCESS; i++)
    {
        PNDISUIO_QUERY_BINDING  pndBinding;
        DWORD                   dwOutSize;
        LPWSTR                  wsName;

        ZeroMemory(prdOutput->pData, prdOutput->dwDataLen);
        pndBinding = (PNDISUIO_QUERY_BINDING)prdOutput->pData;
        pndBinding->BindingIndex = i;
        if (!DeviceIoControl(
                hNdisuio,
                IOCTL_NDISUIO_QUERY_BINDING,
                prdOutput->pData,
                prdOutput->dwDataLen,
                prdOutput->pData,
                prdOutput->dwDataLen,
                &dwOutSize,
                NULL))
        {
            // if the IOCTL failed, get the error code
            dwErr = GetLastError();
            // translate the NO_MORE_ITEMS error in FILE_NOT_FOUND
            // since the caller is not iterating, is searching for a specific adapter
            if (dwErr == ERROR_NO_MORE_ITEMS)
                dwErr = ERROR_FILE_NOT_FOUND;
        }
        else
        {
            dwErr = DevioCheckNdisBinding(pndBinding, dwOutSize);
        }

        if (dwErr == ERROR_SUCCESS)
        {
            // Device name is "\DEVICE\{guid}" and is L'\0' terminated
            // wszGuid is "{guid}"
            wsName = (LPWSTR)((LPBYTE)pndBinding + pndBinding->DeviceNameOffset);
            // if the GUID matches, this is the adapter we were looking for
            if (wcsstr(wsName, wszGuid) != NULL)
            {
                // the adapter's BINDING record is already filled in
                // prdOutput - so just get out of here.
                dwErr = ERROR_SUCCESS;
                break;
            }
        }
    }

    // if handle was opened locally, close it here
    if (bLocalHandle)
        CloseHandle(hNdisuio);

    DbgPrint((TRC_TRACK,"DevioGetInterfaceBindingByGuid]=%d", dwErr));
    return dwErr;
}

DWORD
DevioGetIntfStats(PINTF_CONTEXT pIntf)
{
    DWORD           dwErr = ERROR_SUCCESS;
    WCHAR           ndisDeviceString[128];
    NIC_STATISTICS  ndisStats;
    UNICODE_STRING  uniIntfGuid;

    DbgPrint((TRC_TRACK,"[DevioGetIntfStats(0x%p)", pIntf));

    wcscpy(ndisDeviceString, L"\\DEVICE\\");
    wcscat(ndisDeviceString, pIntf->wszGuid);
    RtlInitUnicodeString(&uniIntfGuid, ndisDeviceString);
    ZeroMemory(&ndisStats, sizeof(NIC_STATISTICS));
    ndisStats.Size = sizeof(NIC_STATISTICS);

    if (!NdisQueryStatistics(&uniIntfGuid, &ndisStats))
    {
        dwErr = GetLastError();
    }
    else
    {
        pIntf->ulMediaState = ndisStats.MediaState;
        pIntf->ulMediaType = ndisStats.MediaType;
        pIntf->ulPhysicalMediaType = ndisStats.PhysicalMediaType;
    }

    DbgPrint((TRC_TRACK,"DevioGetIntfStats]=%d", dwErr));
    return dwErr;
}

DWORD
DevioGetIntfMac(PINTF_CONTEXT pIntf)
{
    DWORD       dwErr = ERROR_SUCCESS;
    RAW_DATA    rdBuffer = {0, NULL};

    DbgPrint((TRC_TRACK,"[DevioGetIntfMac(0x%p)", pIntf));

    dwErr = DevioRefreshIntfOIDs(
                pIntf,
                INTF_HANDLE,
                NULL);
    
    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = DevioQueryBinaryOID(
                    pIntf->hIntf,
                    OID_802_3_CURRENT_ADDRESS,
                    &rdBuffer,
                    sizeof(NDIS_802_11_MAC_ADDRESS));
    }

    if (dwErr == ERROR_SUCCESS)
    {
        if (rdBuffer.dwDataLen == sizeof(NDIS_802_11_MAC_ADDRESS))
        {
            memcpy(&(pIntf->ndLocalMac), rdBuffer.pData, sizeof(NDIS_802_11_MAC_ADDRESS));
        }
        else
        {
            dwErr = ERROR_INVALID_DATA;
        }

        MemFree(rdBuffer.pData);
    }

    DbgPrint((TRC_TRACK,"DevioGetIntfMac]=%d", dwErr));
    return dwErr;
}


//------------------------------------------------------
// Notify dependent components the wireless configuration has failed.
// Specifically this notification goes to TCP allowing TCP to generate
// the NetReady notification asap (instead of waiting for an IP address
// to be plumbed down, which might never happen anyhow).
DWORD
DevioNotifyFailure(
    LPWSTR wszIntfGuid)
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR   ndisDeviceString[128];
    UNICODE_STRING UpperComponent;
    UNICODE_STRING LowerComponent;
    UNICODE_STRING BindList;
    struct
    {
        IP_PNP_RECONFIG_REQUEST Reconfig;
        IP_PNP_INIT_COMPLETE InitComplete;
    } Request;

    DbgPrint((TRC_TRACK,"[DevioNotifyFailure(%S)", wszIntfGuid));

    wcscpy(ndisDeviceString, L"\\DEVICE\\");
    wcscat(ndisDeviceString, wszIntfGuid);
    RtlInitUnicodeString(&UpperComponent, L"Tcpip");
    RtlInitUnicodeString(&LowerComponent, ndisDeviceString);
    RtlInitUnicodeString(&BindList, NULL);

    ZeroMemory(&Request, sizeof(Request));
    Request.Reconfig.version = IP_PNP_RECONFIG_VERSION;
    Request.Reconfig.NextEntryOffset = (USHORT)((PUCHAR)&Request.InitComplete - (PUCHAR)&Request.Reconfig);
    Request.InitComplete.Header.EntryType = IPPnPInitCompleteEntryType;

    dwErr = NdisHandlePnPEvent(
                NDIS,
                RECONFIGURE,
                &LowerComponent,
                &UpperComponent,
                &BindList,
                &Request,
                sizeof(Request));

    DbgPrint((TRC_TRACK,"DevioNotifyFailure]=%d", dwErr));
    return dwErr;
}

DWORD
DevioOpenIntfHandle(LPWSTR wszIntfGuid, PHANDLE phIntf)
{
    DWORD   dwErr = ERROR_SUCCESS;
    WCHAR   ndisDeviceString[128];

    DbgPrint((TRC_TRACK,"[DevioOpenIntfHandle(%S)", wszIntfGuid));
    DbgAssert((phIntf!=NULL, "Invalid out param in DevioOpenIntfHandle"));

    wcscpy(ndisDeviceString, L"\\DEVICE\\");
    wcscat(ndisDeviceString, wszIntfGuid);

    dwErr = OpenIntfHandle(ndisDeviceString, phIntf);

    DbgPrint((TRC_TRACK,"DevioOpenIntfHandle]=%d", dwErr));
    return dwErr;
}

DWORD
DevioCloseIntfHandle(PINTF_CONTEXT pIntf)
{
    DWORD           dwErr = ERROR_SUCCESS;

    DbgPrint((TRC_TRACK,"[DevioCloseIntfHandle(0x%p)", pIntf));

    // destroy the handle only if we did have one in the first instance. Otherwise
    // based only on the GUID we might mess the ref counter on a handle opened by
    // some other app (i.e. 802.1x)
    if (pIntf != NULL && pIntf->hIntf != INVALID_HANDLE_VALUE)
    {
        WCHAR   ndisDeviceString[128];

        wcscpy(ndisDeviceString, L"\\DEVICE\\");
        wcscat(ndisDeviceString, pIntf->wszGuid);

        dwErr = CloseIntfHandle(ndisDeviceString);
        pIntf->hIntf = INVALID_HANDLE_VALUE;
    }

    DbgPrint((TRC_TRACK,"DevioCloseIntfHandle]=%d", dwErr));
    return dwErr;
}

DWORD
DevioSetIntfOIDs(
    PINTF_CONTEXT pIntfContext,
    PINTF_ENTRY   pIntfEntry,
    DWORD         dwInFlags,
    PDWORD        pdwOutFlags)
{
    DWORD       dwErr = ERROR_SUCCESS;
    DWORD       dwLErr = ERROR_SUCCESS;
    DWORD       dwOutFlags = 0;

    DbgPrint((TRC_TRACK,"[DevioSetIntfOIDs(0x%p, 0x%p)", pIntfContext, pIntfEntry));

    if (pIntfContext == NULL || pIntfEntry == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // Set the Infrastructure Mode, if requested
    if (dwInFlags & INTF_INFRAMODE)
    {
        dwLErr = DevioSetEnumOID(
                    pIntfContext->hIntf,
                    OID_802_11_INFRASTRUCTURE_MODE,
                    pIntfEntry->nInfraMode);
        if (dwLErr != ERROR_SUCCESS)
        {
            // set the mode in the client's structure to what it
            // is currently set in the driver
            pIntfEntry->nInfraMode = pIntfContext->wzcCurrent.InfrastructureMode;
        }
        else
        {
            pIntfContext->wzcCurrent.InfrastructureMode = pIntfEntry->nInfraMode;
            dwOutFlags |= INTF_INFRAMODE;
        }

        if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    // Set the Authentication mode if requested
    if (dwInFlags & INTF_AUTHMODE)
    {
        dwLErr = DevioSetEnumOID(
                    pIntfContext->hIntf,
                    OID_802_11_AUTHENTICATION_MODE,
                    pIntfEntry->nAuthMode);
        if (dwLErr != ERROR_SUCCESS)
        {
            // set the mode in the client's structure to what it
            // is currently set in the driver
            pIntfEntry->nAuthMode = pIntfContext->wzcCurrent.AuthenticationMode;
        }
        else
        {
            pIntfContext->wzcCurrent.AuthenticationMode = pIntfEntry->nAuthMode;
            dwOutFlags |= INTF_AUTHMODE;
        }

        if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    // Ask the driver to reload the default WEP key if requested
    if (dwInFlags & INTF_LDDEFWKEY)
    {
        dwLErr = DevioSetEnumOID(
                    pIntfContext->hIntf,
                    OID_802_11_RELOAD_DEFAULTS,
                    (DWORD)Ndis802_11ReloadWEPKeys);
        if (dwLErr == ERROR_SUCCESS)
            dwOutFlags |= INTF_LDDEFWKEY;

        if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    // Add the WEP key if requested
    if (dwInFlags & INTF_ADDWEPKEY)
    { 
        // the call below takes care of the case rdCtrlData is bogus
        dwLErr = DevioSetBinaryOID(
                    pIntfContext->hIntf,
                    OID_802_11_ADD_WEP,
                    &pIntfEntry->rdCtrlData);

        if (dwLErr == ERROR_SUCCESS)
            dwOutFlags |= INTF_ADDWEPKEY;

        if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    // Remove the WEP key if requested
    if (dwInFlags & INTF_REMWEPKEY)
    {
	    if (pIntfEntry->rdCtrlData.dwDataLen >= sizeof(NDIS_802_11_WEP) &&
            pIntfEntry->rdCtrlData.pData != NULL)
	    {
            PNDIS_802_11_WEP pndWepKey = (PNDIS_802_11_WEP)pIntfEntry->rdCtrlData.pData;

            dwLErr = DevioSetEnumOID(
                        pIntfContext->hIntf,
                        OID_802_11_REMOVE_WEP,
                        pndWepKey->KeyIndex);
            if (dwLErr == ERROR_SUCCESS)
                dwOutFlags |= INTF_REMWEPKEY;
        }
        else
        {
            dwLErr = ERROR_INVALID_PARAMETER;
        }

        if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    // Set the WEP Status if requested
    if (dwInFlags & INTF_WEPSTATUS)
    {
        dwLErr = DevioSetEnumOID(
                    pIntfContext->hIntf,
                    OID_802_11_WEP_STATUS,
                    pIntfEntry->nWepStatus);
        if (dwLErr != ERROR_SUCCESS)
        {
            // set the mode in the client's structure to what it
            // is currently set in the driver
            pIntfEntry->nWepStatus = pIntfContext->wzcCurrent.Privacy;
        }
        else
        {
            pIntfContext->wzcCurrent.Privacy = pIntfEntry->nWepStatus;
            dwOutFlags |= INTF_WEPSTATUS;
        }

        if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    // Plumb the new SSID down to the driver. If success, copy this new
    // SSID into the interface's context
    if (dwInFlags & INTF_SSID)
    {
        // ntddndis.h defines NDIS_802_11_SSID with a maximum of 
        // 32 UCHARs for the SSID name
        if (pIntfEntry->rdSSID.dwDataLen > 32)
        {
            dwLErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            NDIS_802_11_SSID   ndSSID = {0};
            RAW_DATA           rdBuffer;

            ndSSID.SsidLength = pIntfEntry->rdSSID.dwDataLen;
            memcpy(&ndSSID.Ssid, pIntfEntry->rdSSID.pData, ndSSID.SsidLength);
            rdBuffer.dwDataLen = sizeof(NDIS_802_11_SSID);
            rdBuffer.pData = (LPBYTE)&ndSSID;
                
            dwLErr = DevioSetBinaryOID(
                        pIntfContext->hIntf,
                        OID_802_11_SSID,
                        &rdBuffer);

            if (dwLErr == ERROR_SUCCESS)
            {
                // copy over the new SSID into the interface's context
                CopyMemory(&pIntfContext->wzcCurrent.Ssid, &ndSSID, sizeof(NDIS_802_11_SSID));
                dwOutFlags |= INTF_SSID;
                // on the same time, if a new SSID has been set, it means we broke whatever association
                // we had before, hence the BSSID field can no longer be correct:
                ZeroMemory(&pIntfContext->wzcCurrent.MacAddress, sizeof(NDIS_802_11_MAC_ADDRESS));
            }
        }

        if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    // set the new BSSID to the driver. If this succeeds, copy
    // the data that was passed down to the interface's context (allocate
    // space for it if not already allocated).
    if (dwInFlags & INTF_BSSID)
    {
        dwLErr = DevioSetBinaryOID(
                    pIntfContext->hIntf,
                    OID_802_11_BSSID,
                    &pIntfEntry->rdBSSID);
        // if the BSSID is not a MAC address, the call above should fail!
        if (dwLErr == ERROR_SUCCESS)
        {
            DbgAssert((pIntfEntry->rdBSSID.dwDataLen == sizeof(NDIS_802_11_MAC_ADDRESS),
                       "Data to be set is %d bytes, which is not a MAC address!",
                       pIntfEntry->rdBSSID.dwDataLen));

            memcpy(&pIntfContext->wzcCurrent.MacAddress, pIntfEntry->rdBSSID.pData, sizeof(NDIS_802_11_MAC_ADDRESS));
            dwOutFlags |= INTF_BSSID;
        }

        if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

exit:
    if (pdwOutFlags != NULL)
        *pdwOutFlags = dwOutFlags;

    DbgPrint((TRC_TRACK,"DevioSetIntfOIDs]=%d", dwErr));
    return dwErr;
}

DWORD
DevioRefreshIntfOIDs(
    PINTF_CONTEXT pIntf,
    DWORD         dwInFlags,
    PDWORD        pdwOutFlags)
{
    DWORD       dwErr = ERROR_SUCCESS;
    DWORD       dwLErr = ERROR_SUCCESS;
    DWORD       dwOutFlags = 0;
    RAW_DATA    rdBuffer;

    DbgPrint((TRC_TRACK,"[DevioRefreshIntfOIDs(0x%p)", pIntf));

    if (pIntf == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // if the interface handle is invalid or there is an explicit requested 
    // to reopen the interface's handle do it as the first thing
    if (pIntf->hIntf == INVALID_HANDLE_VALUE || dwInFlags & INTF_HANDLE)
    {
        if (pIntf->hIntf != INVALID_HANDLE_VALUE)
        {
            dwErr = DevioCloseIntfHandle(pIntf);
            DbgAssert((dwErr == ERROR_SUCCESS,
                       "Couldn't close handle for Intf %S",
                       pIntf->wszGuid));
        }
        dwErr = DevioOpenIntfHandle(pIntf->wszGuid, &pIntf->hIntf);
        DbgAssert((dwErr == ERROR_SUCCESS,
                   "DevioOpenIntfHandle failed for Intf context 0x%p",
                   pIntf));
        if (dwErr == ERROR_SUCCESS && (dwInFlags & INTF_HANDLE))
            dwOutFlags |= INTF_HANDLE;
    }
    
    // if failed to refresh the interface's handle (this is the only way
    // dwErr could not be success) then we already have a closed handle
    // so there's no point in going further
    if (dwErr != ERROR_SUCCESS)
        goto exit;

    // if requested to scan the interface's BSSID list, do it as
    // the next thing. Note however that rescanning is asynchronous.
    // Querying for the BSSID_LIST in the same shot with forcing a rescan
    // might not result in getting the most up to date list.
    if (dwInFlags & INTF_LIST_SCAN)
    {
        // indicate to the driver to rescan the BSSID_LIST for this adapter
        dwLErr = DevioSetEnumOID(
                    pIntf->hIntf,
                    OID_802_11_BSSID_LIST_SCAN,
                    0);
        DbgAssert((dwLErr == ERROR_SUCCESS,
                   "DevioSetEnumOID(BSSID_LIST_SCAN) failed for Intf hdl 0x%x",
                   pIntf->hIntf));

        if (dwLErr == ERROR_SUCCESS)
            dwOutFlags |= INTF_LIST_SCAN;
        else if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    if (dwInFlags & INTF_AUTHMODE)
    {
        // query the authentication mode for the interface
        dwLErr = DevioQueryEnumOID(
                    pIntf->hIntf,
                    OID_802_11_AUTHENTICATION_MODE,
                    (LPDWORD)&pIntf->wzcCurrent.AuthenticationMode);
        DbgAssert((dwLErr == ERROR_SUCCESS,
                    "DevioQueryEnumOID(AUTH_MODE) failed for Intf hdl 0x%x",
                    pIntf->hIntf));
        if (dwLErr == ERROR_SUCCESS)
            dwOutFlags |= INTF_AUTHMODE;
        else if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    if (dwInFlags & INTF_INFRAMODE)
    {
        // query the infrastructure mode for the interface
        dwLErr = DevioQueryEnumOID(
                    pIntf->hIntf,
                    OID_802_11_INFRASTRUCTURE_MODE,
                    (LPDWORD)&pIntf->wzcCurrent.InfrastructureMode);
        DbgAssert((dwLErr == ERROR_SUCCESS,
                    "DevioQueryEnumOID(INFRA_MODE) failed for Intf hdl 0x%x",
                    pIntf->hIntf));
        if (dwLErr == ERROR_SUCCESS)
            dwOutFlags |= INTF_INFRAMODE;
        else if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    if (dwInFlags & INTF_WEPSTATUS)
    {
        // query the WEP_STATUS for the interface
        dwLErr = DevioQueryEnumOID(
                    pIntf->hIntf,
                    OID_802_11_WEP_STATUS,
                    (LPDWORD)&pIntf->wzcCurrent.Privacy);
        DbgAssert((dwLErr == ERROR_SUCCESS,
                    "DevioQueryEnumOID(WEP_STATUS) failed for Intf hdl 0x%x",
                    pIntf->hIntf));
        if (dwLErr == ERROR_SUCCESS)
            dwOutFlags |= INTF_WEPSTATUS;
        else if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    if (dwInFlags & INTF_BSSID)
    {
        // query the BSSID (MAC address) for the interface
        rdBuffer.dwDataLen = 0;
        rdBuffer.pData = NULL;
        dwLErr = DevioQueryBinaryOID(
                    pIntf->hIntf,
                    OID_802_11_BSSID,
                    &rdBuffer,
                    6);
        DbgAssert((dwLErr == ERROR_SUCCESS,
                    "DevioQueryBinaryOID(BSSID) failed for Intf hdl 0x%x",
                    pIntf->hIntf));

        // if the call above succeeded...
        if (dwLErr == ERROR_SUCCESS)
        {
            DbgAssert((rdBuffer.dwDataLen == 6, "BSSID len %d is not a MAC address len??", rdBuffer.dwDataLen));

            // ...and returned correctly a MAC address
            if (rdBuffer.dwDataLen == sizeof(NDIS_802_11_MAC_ADDRESS))
            {
                // copy it in the interface's context
                memcpy(&pIntf->wzcCurrent.MacAddress, rdBuffer.pData, rdBuffer.dwDataLen);
            }
            else
            {
                ZeroMemory(&pIntf->wzcCurrent.MacAddress, sizeof(NDIS_802_11_MAC_ADDRESS));
                dwLErr = ERROR_INVALID_DATA;
            }
        }

        // free whatever might have had been allocated in DevioQueryBinaryOID
        MemFree(rdBuffer.pData);

        if (dwLErr == ERROR_SUCCESS)
            dwOutFlags |= INTF_BSSID;
        else if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    if (dwInFlags & INTF_SSID)
    {
        PNDIS_802_11_SSID pndSSID;
        // query the SSID for the interface
        rdBuffer.dwDataLen = 0;
        rdBuffer.pData = NULL;
        dwLErr = DevioQueryBinaryOID(
                    pIntf->hIntf,
                    OID_802_11_SSID,
                    &rdBuffer,
                    sizeof(NDIS_802_11_SSID));
        DbgAssert((dwLErr == ERROR_SUCCESS,
                    "DevioQueryBinaryOID(SSID) failed for Intf hdl 0x%x",
                    pIntf->hIntf));
        // if we succeeded up to here then we can't fail further for this OID
        if (dwLErr == ERROR_SUCCESS)
            dwOutFlags |= INTF_SSID;
        else if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;

        // copy the pointer to the buffer that was allocated in Query call
        pndSSID = (PNDIS_802_11_SSID)rdBuffer.pData;

        if (pndSSID != NULL)
        {
            // HACK - if the driver doesn't return the NDIS_802_11_SSID structure but just
            // the SSID itself, correct this!
            if (pndSSID->SsidLength > 32)
            {
                DbgAssert((FALSE,"Driver returns SSID instead of NDIS_802_11_SSID structure"));
                // we have enough space in the buffer to slide the data up (it was shifted down
                // in DevioQueryBinaryOID.
                MoveMemory(pndSSID->Ssid, pndSSID, rdBuffer.dwDataLen);
                pndSSID->SsidLength = rdBuffer.dwDataLen;
            }
            // copy over the current SSID into the interface's context if there was no error
            CopyMemory(&pIntf->wzcCurrent.Ssid, pndSSID, sizeof(NDIS_802_11_SSID));
        }

        // free whatever might have been allocated in DevioQueryBinaryOID
        MemFree(pndSSID);
    }

    if (dwInFlags & INTF_BSSIDLIST)
    {
        rdBuffer.dwDataLen = 0;
        rdBuffer.pData = NULL;
        // estimate a buffer large enough for 20 SSIDs.
        dwLErr = DevioQueryBinaryOID(
                    pIntf->hIntf,
                    OID_802_11_BSSID_LIST,
                    &rdBuffer,
                    sizeof(NDIS_802_11_BSSID_LIST) + 19*sizeof(NDIS_WLAN_BSSID));
        DbgAssert((dwLErr == ERROR_SUCCESS,
                    "DevioQueryBinaryOID(BSSID_LIST) failed for Intf hdl 0x%x",
                    pIntf->hIntf));
        // if we succeeded getting the visible list we should have a valid
        // rdBuffer.pData, even if it shows '0 entries'
        if (dwLErr == ERROR_SUCCESS)
        {
            PWZC_802_11_CONFIG_LIST pNewVList;
            
            pNewVList = WzcNdisToWzc((PNDIS_802_11_BSSID_LIST)rdBuffer.pData);
            if (rdBuffer.pData == NULL || pNewVList != NULL)
            {
                // cleanup whatever we might have had before
                MemFree(pIntf->pwzcVList);
                // copy the new visible list we got
                pIntf->pwzcVList = pNewVList;
                dwOutFlags |= INTF_BSSIDLIST;
            }
            else
                dwLErr = GetLastError();

            // whatever the outcome is, free the buffer returned from the driver
            MemFree(rdBuffer.pData);
        }
        // if any error happened here, save it unless some other error has already
        // been saved
        if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

exit:
    if (pdwOutFlags != NULL)
        *pdwOutFlags = dwOutFlags;

    DbgPrint((TRC_TRACK,"DevioRefreshIntfOIDs]=%d", dwErr));
    return dwErr;
}

DWORD
DevioQueryEnumOID(
    HANDLE      hIntf,
    NDIS_OID    Oid,
    DWORD       *pdwEnumValue)
{
    DWORD               dwErr = ERROR_SUCCESS;
    NDISUIO_QUERY_OID   QueryOid;
    DWORD               dwBytesReturned = 0;

    DbgPrint((TRC_TRACK,"[DevioQueryEnumOID(0x%x, 0x%x)", hIntf, Oid));
    DbgAssert((pdwEnumValue != NULL, "Invalid out param in DevioQueryEnumOID"));

    if (hIntf == INVALID_HANDLE_VALUE || pdwEnumValue == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // the NDISUIO_QUERY_OID includes data for 1 dword, sufficient for getting
    // an enumerative value from the driver. This spares us of an additional
    // allocation.
    ZeroMemory(&QueryOid, sizeof(NDISUIO_QUERY_OID));
    QueryOid.Oid = Oid;
    if (!DeviceIoControl (
            hIntf, 
            IOCTL_NDISUIO_QUERY_OID_VALUE,
            (LPVOID)&QueryOid,
            sizeof(NDISUIO_QUERY_OID),
            (LPVOID)&QueryOid,
            sizeof(NDISUIO_QUERY_OID),
            &dwBytesReturned,
            NULL))                          // no overlapping routine
    {
        dwErr = GetLastError();
        DbgPrint((TRC_ERR, "Err: IOCTL_NDISUIO_QUERY_OID_VALUE->%d", dwErr));
        goto exit;
    }
    //dwErr = GetLastError();
    //DbgAssert((dwErr == ERROR_SUCCESS, "DeviceIoControl suceeded, but GetLastError() is =0x%x", dwErr));
    dwErr = ERROR_SUCCESS;

    *pdwEnumValue = *(LPDWORD)QueryOid.Data;

exit:
    DbgPrint((TRC_TRACK,"DevioQueryEnumOID]=%d", dwErr));
    return dwErr;
}

DWORD
DevioSetEnumOID(
    HANDLE      hIntf,
    NDIS_OID    Oid,
    DWORD       dwEnumValue)
{
    DWORD           dwErr = ERROR_SUCCESS;
    NDISUIO_SET_OID SetOid;
    DWORD           dwBytesReturned = 0;

    DbgPrint((TRC_TRACK,"[DevioSetEnumOID(0x%x, 0x%x, %d)", hIntf, Oid, dwEnumValue));

    if (hIntf == INVALID_HANDLE_VALUE)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // the NDISUIO_SET_OID includes data for 1 dword, sufficient for setting
    // an enumerative value from the driver. This spares us of an additional
    // allocation.
    SetOid.Oid = Oid;
    *(LPDWORD)SetOid.Data = dwEnumValue;
    if (!DeviceIoControl (
            hIntf, 
            IOCTL_NDISUIO_SET_OID_VALUE,
            (LPVOID)&SetOid,
            sizeof(NDISUIO_SET_OID),
            NULL,
            0,
            &dwBytesReturned,
            NULL))                          // no overlapping routine
    {
        dwErr = GetLastError();
        DbgPrint((TRC_ERR, "Err: IOCTL_NDISUIO_SET_OID_VALUE->%d", dwErr));
        goto exit;
    }
    //dwErr = GetLastError();
    //DbgAssert((dwErr == ERROR_SUCCESS, "DeviceIoControl suceeded, but GetLastError() is =0x%x", dwErr));
    dwErr = ERROR_SUCCESS;

exit:
    DbgPrint((TRC_TRACK,"DevioSetEnumOID]=%d", dwErr));
    return dwErr;
}

#define     DATA_MEM_MIN        32      // the minimum mem block to be sent out to the ioctl
#define     DATA_MEM_MAX        65536   // the maximum mem block that will be sent out to the ioctl (64K)
#define     DATA_MEM_INC        512     // increment the existent block in 512 bytes increment
DWORD
DevioQueryBinaryOID(
    HANDLE      hIntf,
    NDIS_OID    Oid,
    PRAW_DATA   pRawData,         // buffer is internally allocated
    DWORD       dwMemEstimate)    // how much memory is estimated the result needs 
{
    DWORD dwErr = ERROR_SUCCESS;
    PNDISUIO_QUERY_OID  pQueryOid=NULL;

    DbgPrint((TRC_TRACK, "[DevioQueryBinaryOID(0x%x, 0x%x)", hIntf, Oid));

    if (hIntf == INVALID_HANDLE_VALUE ||
        pRawData == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if (dwMemEstimate < DATA_MEM_MIN)
        dwMemEstimate = DATA_MEM_MIN;
    do
    {
        DWORD dwBuffSize;
        DWORD dwBytesReturned;

        MemFree(pQueryOid);

        if (dwMemEstimate > DATA_MEM_MAX)
            dwMemEstimate = DATA_MEM_MAX;
        dwBuffSize = FIELD_OFFSET(NDISUIO_QUERY_OID, Data) + dwMemEstimate;
        pQueryOid = (PNDISUIO_QUERY_OID) MemCAlloc(dwBuffSize);
        if (pQueryOid == NULL)
        {
            dwErr = GetLastError();
            break;
        }

        pQueryOid->Oid = Oid;
        if (DeviceIoControl (
                hIntf, 
                IOCTL_NDISUIO_QUERY_OID_VALUE,
                (LPVOID)pQueryOid,
                dwBuffSize,
                (LPVOID)pQueryOid,
                dwBuffSize,
                &dwBytesReturned,
                NULL))
        {
            DbgAssert((
                dwBytesReturned <= dwBuffSize,
                "DeviceIoControl returned %d > %d that was passed down!",
                dwBytesReturned,
                dwBuffSize));

            pRawData->pData = (LPBYTE)pQueryOid;
            pRawData->dwDataLen = dwBytesReturned - FIELD_OFFSET(NDISUIO_QUERY_OID, Data);

            if (pRawData->dwDataLen != 0)
            {
                MoveMemory(pQueryOid, pQueryOid->Data, pRawData->dwDataLen);
            }
            else
            {
                pRawData->pData = NULL;
                MemFree(pQueryOid);
                pQueryOid = NULL;
            }

            dwErr = ERROR_SUCCESS;
            break;
        }

        dwErr = GetLastError();

        if (((dwErr == ERROR_INSUFFICIENT_BUFFER) || (dwErr == ERROR_INVALID_USER_BUFFER)) &&
            (dwMemEstimate < DATA_MEM_MAX))
        {
            dwMemEstimate += DATA_MEM_INC;
            dwErr = ERROR_SUCCESS;
        }

    } while (dwErr == ERROR_SUCCESS);

exit:
    if (dwErr != ERROR_SUCCESS)
    {
        MemFree(pQueryOid);
        pRawData->pData= NULL;
        pRawData->dwDataLen = 0;
    }

    DbgPrint((TRC_TRACK, "DevioQueryBinaryOID]=%d", dwErr));
    return dwErr;
}

DWORD
DevioSetBinaryOID(
    HANDLE      hIntf,
    NDIS_OID    Oid,
    PRAW_DATA   pRawData)
{
    DWORD               dwErr = ERROR_SUCCESS;
    PNDISUIO_SET_OID    pSetOid = NULL;
    DWORD               dwBytesReturned = 0;
    DWORD               dwBufferSize;

    DbgPrint((TRC_TRACK,"[DevioSetBinaryOID(0x%x,0x%x,...)", hIntf, Oid));

    if (hIntf == INVALID_HANDLE_VALUE ||
        pRawData == NULL ||
        pRawData->dwDataLen == 0 ||
        pRawData->pData == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    dwBufferSize = FIELD_OFFSET(NDISUIO_QUERY_OID, Data) + pRawData->dwDataLen;
    pSetOid = (PNDISUIO_SET_OID) MemCAlloc(dwBufferSize);
    if (pSetOid == NULL)
    {
        dwErr = GetLastError();
        goto exit;
    }
    pSetOid->Oid = Oid;
    CopyMemory(pSetOid->Data, pRawData->pData, pRawData->dwDataLen);

    if (!DeviceIoControl (
            hIntf, 
            IOCTL_NDISUIO_SET_OID_VALUE,
            (LPVOID)pSetOid,
            dwBufferSize,
            NULL,
            0,
            &dwBytesReturned,
            NULL))                          // no overlapping routine
    {
        dwErr = GetLastError();
        DbgPrint((TRC_ERR, "Err: IOCTL_NDISUIO_SET_OID_VALUE->%d", dwErr));
        goto exit;
    }
    //dwErr = GetLastError();
    //DbgAssert((dwErr == ERROR_SUCCESS, "DeviceIoControl suceeded, but GetLastError() is 0x%x", dwErr));
    dwErr = ERROR_SUCCESS;

exit:
    MemFree(pSetOid);
    DbgPrint((TRC_TRACK,"DevioSetBinaryOID]=%d", dwErr));
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\dialog.h ===
#pragma once
#include "intflist.h"

//-----------------------------------------------------------------
// Signaling function to be called from within WZC when a significant
// event happens (i.e. going into the failed state)
DWORD
WzcDlgNotify(
    PINTF_CONTEXT   pIntfContext,
    PWZCDLG_DATA    pDlgData);

//-----------------------------------------------------------------
// Called from within WZC when the internal association state changes
WzcNetmanNotify(
    PINTF_CONTEXT pIntfContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\deviceio.h ===
#pragma once

// size of the buffer to use when querying an interface
// binding from NDIS (IOCTL_NDISUIO_QUERY_BINDING)
#define QUERY_BUFFER_SIZE   1024
#define QUERY_BUFFER_MAX    65536  // 64K should be more than enough for an interface binding structure

DWORD
DevioGetNdisuioHandle(
    PHANDLE pHandle);

DWORD
DevioCheckNdisBinding(
    PNDISUIO_QUERY_BINDING pndBinding,
    ULONG                  nBindingLen);

DWORD
DevioGetIntfBindingByIndex(
    HANDLE      hNdisuio,           // IN opened handle to NDISUIO. If INVALID_HANDLE_VALUE, open one locally
    UINT        nIntfIndex,         // IN interface index to look for
    PRAW_DATA   prdOutput);         // OUT result of the IOCTL

DWORD
DevioGetInterfaceBindingByGuid(
    HANDLE      hNdisuio,           // IN opened handle to NDISUIO. If INVALID_HANDLE_VALUE, open one locally
    LPWSTR      wszGuid,            // IN interface GUID as "{guid}"
    PRAW_DATA   prdOutput);         // OUT result of the IOCTL

DWORD
DevioGetIntfStats(
    PINTF_CONTEXT pIntf);

DWORD
DevioGetIntfMac(
    PINTF_CONTEXT pIntf);

DWORD
DevioNotifyFailure(
    LPWSTR wszIntfGuid);

DWORD
DevioOpenIntfHandle(
    LPWSTR wszIntfGuid,
    PHANDLE phIntf);

DWORD
DevioCloseIntfHandle(
    PINTF_CONTEXT pIntf);

DWORD
DevioSetIntfOIDs(
    PINTF_CONTEXT pIntfContext,
    PINTF_ENTRY   pIntfEntry,
    DWORD         dwInFlags,
    PDWORD        pdwOutFlags);

DWORD
DevioRefreshIntfOIDs(
    PINTF_CONTEXT pIntf,
    DWORD         dwInFlags,
    PDWORD        pdwOutFlags);

DWORD
DevioQueryEnumOID(
    HANDLE      hIntf,
    NDIS_OID    Oid,
    DWORD       *pdwEnumValue);

DWORD
DevioSetEnumOID(
    HANDLE      hIntf,
    NDIS_OID    Oid,
    DWORD       dwEnumValue);

DWORD
DevioQueryBinaryOID(
    HANDLE      hIntf,
    NDIS_OID    Oid,
    PRAW_DATA   pRawData,
    DWORD       dwMemEstimate);


DWORD
DevioSetBinaryOID(
    HANDLE      hIntf,
    NDIS_OID    Oid,
    PRAW_DATA   pRawData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\hash.h ===
#pragma once

typedef struct _HASH_NODE
{
    // hash structural links
    struct _HASH_NODE   *pUpLink;   // up level link to the "parent" node
    LIST_ENTRY          lstHoriz;   // horizontal links to "brother" nodes
    LIST_ENTRY          lstDown;    // down level links to "child" nodes
    // hash node data
    LPWSTR              wszKey;     // partial key info
    LPVOID              pObject;    // pointer to data opaque object
} HASH_NODE, *PHASH_NODE;

typedef struct _HASH
{
    BOOL                bValid;      // boolean telling whether the HASH is a valid object
    CRITICAL_SECTION    csMutex;
    PHASH_NODE          pRoot;
} HASH, *PHASH;

//--------- Private calls ------------------------------------------------
// Matches the keys one against the other.
UINT                            // [RET] number of matching chars
HshPrvMatchKeys(
    LPWSTR      wszKey1,        // [IN]  key 1
    LPWSTR      wszKey2);       // [IN]  key 2

// deletes all the pHash tree - doesn't touch the pObjects from within
// (if any)
VOID
HshDestructor(
    PHASH_NODE  pHash);         // [IN]  hash tree to delete

//--------- Public calls -------------------------------------------------
//
// Initializes a HASH structure
DWORD
HshInitialize(PHASH pHash);

// Cleans all resources referenced by a HASH structures
VOID
HshDestroy(PHASH pHash);

// Inserts an opaque object into the cache. The object is keyed on a wstring
// The call could alter the structure of the hash, hence it returns the reference
// to the updated hash.
DWORD                           // [RET] win32 error code
HshInsertObjectRef(
    PHASH_NODE  pHash,          // [IN]  hash to operate on
    LPWSTR      wszKey,         // [IN]  key of the object to insert
    LPVOID      pObject,        // [IN]  object itself to insert in the cache
    PHASH_NODE  *ppOutHash);    // [OUT] pointer to the updated hash

// Retrieves an object from the hash. The hash structure is not touched in
// any manner.
DWORD                           // [RET] win32 error code
HshQueryObjectRef(
    PHASH_NODE  pHash,          // [IN]  hash to operate on
    LPWSTR      wszKey,         // [IN]  key of the object to retrieve
    PHASH_NODE  *ppHashNode);   // [OUT] hash node referencing the queried object

// Removes the object referenced by the pHash node. This could lead to one or 
// more hash node removals (if a leaf node on an isolated branch) but it could
// also let the hash node untouched (i.e. internal node). 
// It is the caller's responsibility to clean up the object pointed by ppObject
DWORD                           // [RET] win32 error code
HshRemoveObjectRef(
    PHASH_NODE  pHash,          // [IN]  hash to operate on
    PHASH_NODE  pRemoveNode,    // [IN]  hash node to clear the reference to pObject
    LPVOID      *ppObject,      // [OUT] pointer to the object whose reference has been cleared
    PHASH_NODE  *ppOutHash);    // [OUT] pointer to the updated hash


// Test routine for tracing out the whole hash layout
VOID
HshDbgPrintHash (
    PHASH_NODE  pHash,
    UINT        nLevel);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\dialog.c ===
#include <precomp.h>
#include "intflist.h"
#include "tracing.h"
#include "dialog.h"

//-----------------------------------------------------------------
// Dialog function to be called from within WZC when a significant
// event happens (i.e. going into the failed state)
DWORD
WzcDlgNotify(
    PINTF_CONTEXT   pIntfContext,
    PWZCDLG_DATA    pDlgData)
{
    DWORD dwErr = ERROR_SUCCESS;
    BSTR  bsDlgData;
    GUID  guidIntf;

    DbgPrint((TRC_TRACK, "[WzcDlgNotify(0x%p, 0x%p:%d)", pIntfContext, pDlgData, pDlgData->dwCode));

    // prepare the BSTR data that goes with this dialog notification
    bsDlgData = SysAllocStringByteLen ((LPCSTR)pDlgData, sizeof(WZCDLG_DATA));
    if (bsDlgData == NULL)
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

    // send everything down the COM pipe now..
    if (dwErr == ERROR_SUCCESS && 
        SUCCEEDED(CLSIDFromString(pIntfContext->wszGuid, &guidIntf)) &&
        SUCCEEDED(CoInitializeEx (NULL, COINIT_MULTITHREADED)))
    {
        INetConnectionRefresh  *pNetman;

        if(SUCCEEDED(CoCreateInstance (
                        &CLSID_ConnectionManager, 
                        NULL,
                        CLSCTX_ALL,
                        &IID_INetConnectionRefresh, 
                        (LPVOID *)&pNetman)))
        {
            pNetman->lpVtbl->ShowBalloon(pNetman, &guidIntf, bsDlgData, NULL); // no message text
            pNetman->lpVtbl->Release(pNetman);
        }

        CoUninitialize ();
    }

    if (bsDlgData != NULL)
        SysFreeString (bsDlgData);

    DbgPrint((TRC_TRACK, "WzcDlgNotify]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------------
// Called from within WZC when the internal association state changes
WzcNetmanNotify(
    PINTF_CONTEXT pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;
    GUID  guidIntf;

    DbgPrint((TRC_TRACK, "[WzcNetmanNotify(0x%p)", pIntfContext));

    // For now (WinXP client RTM), Zero Config should report to NETMAN only the
    // disconnected state. This is to fix bug #401130 which is NETSHELL displaying
    // the bogus SSID from the {SF} state, while the IP address is lost and until
    // the media disconnect is received (10 seconds later).
    //
    // Do notify NETMAN only in the case when the device is under WZC control, that is
    // when it supports the OIDs and WZC is acting on it.
    if ((pIntfContext->dwCtlFlags & INTFCTL_OIDSSUPP) &&
        (pIntfContext->ncStatus == NCS_MEDIA_DISCONNECTED))
    {
        // send everything down the COM pipe now..
        if (SUCCEEDED(CLSIDFromString(pIntfContext->wszGuid, &guidIntf)) &&
            SUCCEEDED(CoInitializeEx (NULL, COINIT_MULTITHREADED)))
        {
            INetConnectionRefresh  *pNetman;

            if(SUCCEEDED(CoCreateInstance (
                            &CLSID_ConnectionManager, 
                            NULL,
                            CLSCTX_ALL,
                            &IID_INetConnectionRefresh, 
                            (LPVOID *)&pNetman)))
            {
                pNetman->lpVtbl->ConnectionStatusChanged(pNetman, &guidIntf, pIntfContext->ncStatus);
                pNetman->lpVtbl->Release(pNetman);
            }

            CoUninitialize ();
        }
        else
        {
            DbgAssert((FALSE,"Failed initializing COM pipe to NETMAN!"));
            dwErr = ERROR_GEN_FAILURE;
        }
    }

    DbgPrint((TRC_TRACK, "WzcNetmanNotify]=%d", dwErr));
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\hash.c ===
#include <precomp.h>
#include "tracing.h"
#include "utils.h"
#include "hash.h"

//~~~~~~~~~~~~~~~~~~~~~~~~ PRIVATE HASH FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Matches the keys one against the other.
UINT                            // [RET] number of matching chars
HshPrvMatchKeys(
    LPWSTR      wszKey1,        // [IN]  key 1
    LPWSTR      wszKey2)        // [IN]  key 2
{
    UINT i = 0;
    while (*wszKey1 != L'\0' && *wszKey1 == *wszKey2)
    {
        wszKey1++; wszKey2++;
        i++;
    }
    return i;
}

// deletes all the pHash tree - doesn't touch the pObjects from
// within (if any)
VOID
HshDestructor(
    PHASH_NODE  pHash)         // [IN]  hash tree to delete
{
    // pHash should not be NULL -- but who knows what the caller is doing!
    if (pHash != NULL)
    {
        while(!IsListEmpty(&(pHash->lstDown)))
        {
            PHASH_NODE pChild;
            pChild = CONTAINING_RECORD(pHash->lstDown.Flink, HASH_NODE, lstHoriz);

            HshDestructor(pChild);
        }
        RemoveEntryList(&(pHash->lstHoriz));
        MemFree(pHash->wszKey);
        MemFree(pHash);
    }
}

//~~~~~~~~~~~~~~~~~~~~~~~~ PUBLIC HASH FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Initializes a HASH structure
DWORD
HshInitialize(PHASH pHash)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (pHash != NULL)
    {
        __try 
        {
            InitializeCriticalSection(&(pHash->csMutex));
            pHash->bValid = TRUE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            dwErr = GetExceptionCode();
        }
        pHash->pRoot = NULL;
    }
    else
        dwErr = ERROR_INVALID_PARAMETER;

    return dwErr;
}

// Cleans all resources referenced by a HASH structures
VOID
HshDestroy(PHASH pHash)
{
    HshDestructor(pHash->pRoot);
    if (pHash->bValid)
    {
        DeleteCriticalSection(&(pHash->csMutex));
        pHash->bValid = FALSE;
    }
}

// Inserts an opaque object into the cache. The object is keyed on a wstring
// The call could alter the structure of the hash, hence it returns the reference
// to the updated hash.
DWORD                           // [RET] win32 error code
HshInsertObjectRef(
    PHASH_NODE  pHash,          // [IN]  hash to operate on
    LPWSTR      wszKey,         // [IN]  key of the object to insert
    LPVOID      pObject,        // [IN]  object itself to insert in the cache
    PHASH_NODE  *ppOutHash)     // [OUT] pointer to the updated hash
{
    DWORD dwErr = ERROR_SUCCESS;

    DbgPrint((TRC_HASH,"[HshInsertObject(%S)", wszKey));
    DbgAssert((ppOutHash != NULL, "No output hash expected??"));
    DbgAssert((wszKey != NULL, "Key info should not be NULL"));

    // if the node passed in is NULL this means a new node
    // has to be created
    if (pHash == NULL)
    {
        // this node is definitely not in the hash
        // allocate the new node
        pHash = MemCAlloc(sizeof(HASH_NODE));
        if (pHash == NULL)
        {
            dwErr = GetLastError();
            goto exit;
        }
        // allocate mem for the new key
        pHash->wszKey = MemCAlloc(sizeof(WCHAR)*(wcslen(wszKey)+1));
        if (pHash->wszKey == NULL)
        {
            dwErr = GetLastError();
            MemFree(pHash);
            goto exit;
        }
        // copy the new key
        wcscpy(pHash->wszKey, wszKey);
        // initialize the horizontal and down lists
        InitializeListHead(&(pHash->lstHoriz));
        InitializeListHead(&(pHash->lstDown));
        // copy the reference to the object associated with the key
        pHash->pObject = pObject;
        // at this point we have a standalone newly created node:
        // no links are defined either on the horizontal, downwards or upwards
        // these will be set up (if needed) by the caller.
        *ppOutHash = pHash;
    }
    // if the node passed in is not NULL, we need to match as many
    // characters between wszKey and the node's key. Based on who's shorter
    // we decide to either set the reference (if keys identical) or 
    // break the branch (if wszKey is shorter than the current one) or
    // to recurse down the insertion.
    else
    {
        UINT        nMatch;
        PHASH_NODE  pChild;
        enum { MATCH, SUBSET, SUPERSET, UNDECIDED, RECURSE} nAnalysis;

        nMatch = HshPrvMatchKeys(wszKey, pHash->wszKey);

        // analyze the given key with respect to the current node;
        if (wszKey[nMatch] == L'\0' && pHash->wszKey[nMatch] == L'\0')
            // the key matches the current node
            nAnalysis = MATCH;
        else if (wszKey[nMatch] == L'\0')
            // the key is a subset of the current node
            nAnalysis = SUBSET;
        else 
        {
            // so far undecided - further see if this translates to SUPERSET
            // or even better, if SUPERSET can be handled by a child, hence
            // RECURSE.
            nAnalysis = UNDECIDED;

            if (pHash->wszKey[nMatch] == L'\0')
            {
                PLIST_ENTRY pEntry;

                // the new key is a superset of the current nod
                nAnalysis = SUPERSET;

                // the new key could be covered by one of the existent children.
                // check then if it is the case to send the work down to some child
                for (pEntry = pHash->lstDown.Flink;
                     pEntry != &(pHash->lstDown);
                     pEntry = pEntry->Flink)
                {
                    pChild = CONTAINING_RECORD(pEntry, HASH_NODE, lstHoriz);
                    if (wszKey[nMatch] == pChild->wszKey[0])
                    {
                        // the child to follow up has been located and saved
                        // in pChild. Set nAnalysis to UNDECIDED and break;
                        nAnalysis = RECURSE;
                        break;
                    }
                }
            }
        }

        // if the key matches exactly the current node
        // then is only a matter of setting the object's reference
        if (nAnalysis == MATCH)
        {
            // if the node is already referencing an object..
            if (pHash->pObject != NULL)
            {
                // signal out ERROR_DUPLICATE_TAG
                dwErr = ERROR_DUPLICATE_TAG;
            }
            else
            {
                // just insert the reference and get out with success.
                pHash->pObject = pObject;
                // save the Out hash pointer
                *ppOutHash = pHash;
            }
        }
        // if a child has been identified, let pChild (saved previously)
        // to follow up
        else if (nAnalysis == RECURSE)
        {
            dwErr = HshInsertObjectRef(
                        pChild,
                        wszKey+nMatch,
                        pObject,
                        ppOutHash);
            if (dwErr == ERROR_SUCCESS)
                *ppOutHash = pHash;
        }
        // if any of SUBSET, SUPERSET or UNDECIDED
        else
        {
            PHASH_NODE  pParent = NULL;
            LPWSTR      wszTrailKey = NULL;
            UINT        nTrailLen = 0;

            // [C = common part; c = current key; n = new key]
            // (SUBSET)               (UNDECIDED)
            // current: CCCCCccc  or  current: CCCCCccc
            // new:     CCCCC         new:     CCCCCnnnnn
            // 
            // In both cases, the current node splits.
            // Create first a new node, containing just CCCCC
            if (nAnalysis != SUPERSET)
            {
                // get the number of chars in pHash's key that are not matching 
                nTrailLen = wcslen(pHash->wszKey) - nMatch;

                // create first the trailing part of the key (allocate the number of
                // chars from the current node that didn't match)
                wszTrailKey = MemCAlloc(sizeof(WCHAR)*(nTrailLen+1));
                if (wszTrailKey == NULL)
                {
                    // if anything went wrong, just go out with the error.
                    // hash hasn't been modified.
                    dwErr = GetLastError();
                    goto exit;
                }
                // wcsncpy doesn't append the null terminator but the string
                // is already nulled out and it has the right size
                wcsncpy(wszTrailKey, pHash->wszKey+nMatch, nTrailLen);

                // create then the node that will act as the common parent
                pHash->wszKey[nMatch] = L'\0';
                dwErr = HshInsertObjectRef(
                    NULL,               // request a new node to be created
                    pHash->wszKey,      // common part of the current keys
                    NULL,               // this node is not referencing any object
                    &pParent);          // get back the newly created pointer.
                pHash->wszKey[nMatch] = wszTrailKey[0];

                // in case anything went wrong, the hash has not been altered,
                // we just need to bubble up the error.
                if (dwErr != ERROR_SUCCESS)
                {
                    MemFree(wszTrailKey);
                    goto exit;
                }

                // set the new parent up link
                pParent->pUpLink = pHash->pUpLink;
            }
            // (SUPERSET)              (UNDECIDED)
            // current: CCCCC      or  current: CCCCCccccc
            // new:     CCCCCnnn       new:     CCCCCnnn
            // In both cases a new node has to be created for the "nnn" part.
            if (nAnalysis != SUBSET)
            {
                dwErr = HshInsertObjectRef(
                            NULL,
                            wszKey + nMatch,
                            pObject,
                            &pChild);
                if (dwErr != ERROR_SUCCESS)
                {
                    // second creation failed, clean up everything and bail out
                    MemFree(wszTrailKey);
                    if (pParent != NULL)
                    {
                        MemFree(pParent->wszKey);
                        MemFree(pParent);
                    }
                    // hash structure is not altered at this point.
                    goto exit;
                }
                // link it up to the corresponding parent.
                pChild->pUpLink = (nAnalysis == SUPERSET) ? pHash : pParent;
            }

            // NO WAY BACK FROM NOW ON - hash is about to be altered
            // success is guaranteed
            // at this point, pChild is a non null pointer, with all the
            // LIST_ENTRIES from within the HASH_NODE initialized correctly.

            // (SUBSET)                 (UNDECIDED)
            // current: CCCCCccccc  or  current: CCCCCccccc
            // new:     CCCCC           new:     CCCCCnnn
            // if the node has split, put the new parent in its place
            if (nAnalysis != SUPERSET)
            {
                // set the current key to the shrinked unmatched trailing part
                MemFree(pHash->wszKey);
                pHash->wszKey = wszTrailKey;
                // set the current upLink to the new pParent node
                pHash->pUpLink = pParent;
                // insert the new parent into its place
                InsertHeadList(&(pHash->lstHoriz), &(pParent->lstHoriz));
                // remove the node from its previous parent
                RemoveEntryList(&(pHash->lstHoriz));
                // reset the current node's list
                InitializeListHead(&(pHash->lstHoriz));
                // insert the node to its new parent down list.
                InsertHeadList(&(pParent->lstDown), &(pHash->lstHoriz));
            }

            // (SUPERSET)              (UNDECIDED)
            // current: CCCCC      or  current: CCCCCccccc
            // new:     CCCCCnnn       new:     CCCCCnnn
            // if a new child node has been created, link it in the hash
            if (nAnalysis != SUBSET)
            {
                // if the given key was either a superset of the
                // current key or derived from the current key,
                // there is a separated node for it. Insert it in the down list
                if (nAnalysis == SUPERSET)
                {
                    InsertTailList(&(pHash->lstDown), &(pChild->lstHoriz));
                }
                else
                {
                    InsertTailList(&(pParent->lstDown), &(pChild->lstHoriz));
                }
            }
            else
            {
                // set the new parent's reference to this data.
                pParent->pObject = pObject;
            }
            *ppOutHash = (nAnalysis == SUPERSET) ? pHash : pParent;
            // and that's all - we're done successfully!
        }
    }

exit:
    DbgPrint((TRC_HASH,"HshInsertObject]=%d", dwErr));
    return dwErr;
}

// Retrieves an object from the hash. The hash structure is not touched in
// any manner.
DWORD                           // [RET] win32 error code
HshQueryObjectRef(
    PHASH_NODE  pHash,          // [IN]  hash to operate on
    LPWSTR      wszKey,         // [IN]  key of the object to retrieve
    PHASH_NODE  *ppHashNode)    // [OUT] hash node referencing the queried object
{
    DWORD dwErr = ERROR_FILE_NOT_FOUND;
    INT   nDiff;

    DbgPrint((TRC_HASH,"[HshQueryObjectRef(0x%p)", wszKey));

    if (wszKey == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if (pHash == NULL)
    {
        dwErr = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    nDiff = wcscmp(wszKey, pHash->wszKey);

    if (nDiff == 0)
    {
        // The key is identical with the one in this node
        if (pHash->pObject != NULL)
        {
            if (ppHashNode != NULL)
            {
                *ppHashNode = pHash;
            }
            dwErr = ERROR_SUCCESS;
        }
        // If there is no object in this node, this means
        // the query failed with FILE_NOT_FOUND
    }
    else if (nDiff > 0)
    {
        // The key is larger than the current node's key
        UINT nTrail = wcslen(pHash->wszKey);
        PLIST_ENTRY pEntry;

        // The trailing part of the key could be covered by one of 
        // the children nodes. Scan then the Down list.
        for (pEntry = pHash->lstDown.Flink;
             pEntry != &(pHash->lstDown);
             pEntry = pEntry->Flink)
        {
            PHASH_NODE pChild;
            pChild = CONTAINING_RECORD(pEntry, HASH_NODE, lstHoriz);
            if (wszKey[nTrail] == pChild->wszKey[0])
            {
                // the child to follow up has been located and saved
                // in pChild. Try to match the trailing key against this node
                dwErr = HshQueryObjectRef(pChild, wszKey+nTrail, ppHashNode);
                break;
            }
        }
        // if no child has been located, dwErr is the default FILE_NOT_FOUND
    }
    // if nDiff < 0 - meaning key is included in the current node's key then
    // dwErr is the default FILE_NOT_FOUND which is good.

exit:
    DbgPrint((TRC_HASH,"HshQueryObjectRef]=%d", dwErr));
    return dwErr;
}

// Removes the object referenced by the pHash node. This could lead to one or 
// more hash node removals (if a leaf node on an isolated branch) but it could
// also let the hash node untouched (i.e. internal node). 
// It is the caller's responsibility to clean up the object pointed by ppObject
DWORD                           // [RET] win32 error code
HshRemoveObjectRef(
    PHASH_NODE  pHash,          // [IN]  hash to operate on
    PHASH_NODE  pRemoveNode,    // [IN]  hash node to clear the reference to pObject
    LPVOID      *ppObject,      // [OUT] pointer to the object whose reference has been cleared
    PHASH_NODE  *ppOutHash)     // [OUT] pointer to the updated hash
{
    DWORD       dwErr = ERROR_SUCCESS;
    PHASH_NODE  pNewRoot = NULL;

    DbgPrint((TRC_HASH,"[HshRemoveObjectRef(%p)", pHash));
    DbgAssert((ppObject != NULL, "No output object expected??"));
    DbgAssert((ppOutHash != NULL, "No output hash expected??"));
    DbgAssert((pRemoveNode != NULL, "No node to remove??"));

    // if the node contains no reference, return FILE_NOT_FOUND
    if (pRemoveNode->pObject == NULL)
    {
        dwErr = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // remove the reference to the object at this moment
    *ppObject = pRemoveNode->pObject;
    pRemoveNode->pObject = NULL;

    // now climb the tree up to the root (!! - well it's a reversed tree) and merge
    // whatever nodes can be merged.
    // Merging: A node not referencing any object and having 0 or at most 1
    // successor can be deleted from the hash tree structure. 
    while ((pRemoveNode != NULL) &&
           (pRemoveNode->pObject == NULL) &&
           (pRemoveNode->lstDown.Flink->Flink == &(pRemoveNode->lstDown)))
    {
        PHASH_NODE  pUp = pRemoveNode->pUpLink;

        // if there is exactly 1 successor, its key needs to be prefixed with
        // the key of the node that is about to be removed. The successor also
        // needs to replace its parent in the hash tree structure.
        if (!IsListEmpty(&(pRemoveNode->lstDown)))
        {
            PHASH_NODE pDown;
            LPWSTR     wszNewKey;
            
            pDown = CONTAINING_RECORD(pRemoveNode->lstDown.Flink, HASH_NODE, lstHoriz);
            wszNewKey = MemCAlloc(sizeof(WCHAR)*(wcslen(pRemoveNode->wszKey)+wcslen(pDown->wszKey)+1));
            if (wszNewKey == NULL)
            {
                // if the allocation failed, bail out with the error code.
                // the reference had already been removed, the hash might
                // not be compacted but it is still valid!
                dwErr = GetLastError();
                goto exit;
            }
            wcscpy(wszNewKey, pRemoveNode->wszKey);
            wcscat(wszNewKey, pDown->wszKey);
            MemFree(pDown->wszKey);
            pDown->wszKey = wszNewKey;
            // now raise the child node as a replacement of its parent
            pDown->pUpLink = pRemoveNode->pUpLink;
            InsertHeadList(&(pRemoveNode->lstHoriz), &(pDown->lstHoriz));
            pNewRoot = pDown;
        }

        // remove the current node
        RemoveEntryList(&(pRemoveNode->lstHoriz));
        // cleanup all its memory
        MemFree(pRemoveNode->wszKey);
        MemFree(pRemoveNode);
        // finally go and check the upper level node (if there is any)
        pRemoveNode = pUp;
    }

    // if pRemoveNode ended up to be NULL, this means either the whole hash has been cleared
    // or a "brother" took the role of the root. pNewRoot has the right value in both cases
    // if pRemoveNode is not NULL, since it walked up the chain constantly it means pHash (the
    // original root) was not affected. Hence, return it out.
    *ppOutHash = (pRemoveNode == NULL) ? pNewRoot : pHash;

exit:
    DbgPrint((TRC_HASH,"HshRemoveObjectRef]=%d", dwErr));
    return dwErr;
}

CHAR szBlanks[256];

VOID
HshDbgPrintHash (
    PHASH_NODE  pHash,
    UINT        nLevel)
{
    memset(szBlanks,' ', sizeof(szBlanks));
    
    if (pHash == NULL)
    {
        sprintf(szBlanks+nLevel,"(null)");
        DbgPrint((TRC_GENERIC,"%s", szBlanks));
    }
    else
    {
        PLIST_ENTRY pEntry;

        sprintf(szBlanks+nLevel,"%p:\"%S~[%p]\", up:%p",
            pHash,
            pHash->wszKey,
            pHash->pObject,
            pHash->pUpLink);

        DbgPrint((TRC_GENERIC,"%s", szBlanks));

        for (pEntry = pHash->lstDown.Flink;
             pEntry != &(pHash->lstDown);
             pEntry = pEntry->Flink)
        {
            PHASH_NODE pChild;
            pChild = CONTAINING_RECORD(pEntry, HASH_NODE, lstHoriz);

            HshDbgPrintHash(pChild, nLevel+1);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\intfhdl.c ===
#include <precomp.h>
#include "tracing.h"
#include "utils.h"
#include "intflist.h"
#include "intfhdl.h"

DWORD 
OpenIntfHandle(
    LPWSTR wszGuid,
    PHANDLE pIntfHdl)
{
    DWORD       dwErr;
    PHASH_NODE  pNode;
    PHSH_HANDLE pHshHandle;

    DbgPrint((TRC_TRACK,"[OpenIntfHandle(%S)", wszGuid));

    // the caller is supposed to expect the handle in return
    // if he doesn't, return with INVALID_PARAMETER.
    if (pIntfHdl == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // lock the hash, to mutual exclude concurrent calls
    EnterCriticalSection(&g_hshHandles.csMutex);

    // query the hash for the guid.
    dwErr = HshQueryObjectRef(
                g_hshHandles.pRoot,
                wszGuid,
                &pNode);

    // if the guid in the hash, we already have the handle opened..
    if (dwErr == ERROR_SUCCESS)
    {
        // return it to the caller and bump up the reference counter.
        // the caller is still supposed to close this handle when it is
        // no longer needed
        pHshHandle = (PHSH_HANDLE)pNode->pObject;
        pHshHandle->nRefCount++;
        *pIntfHdl = pHshHandle->hdlInterf;
        DbgPrint((TRC_GENERIC, "OpenIntfHandle -> 0x%x (cached)", *pIntfHdl));
    }
    // if the guid is not in the hash, we need to open a new handle for
    // this guid.
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        HANDLE      IntfHdl = INVALID_HANDLE_VALUE;
        DWORD       dwDummy;

        dwErr = ERROR_SUCCESS;

        // first allocate memory for the HSH_HANDLE object.
        // if this fails no need to go further to ndisuio
        pHshHandle = MemCAlloc(sizeof(HSH_HANDLE));
        if (pHshHandle == NULL)
            dwErr = GetLastError();

        // if everything looks fine so far
        if (dwErr == ERROR_SUCCESS)
        {
            // create the handle
            IntfHdl = CreateFileA(
                        "\\\\.\\\\Ndisuio",
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                        INVALID_HANDLE_VALUE);
            if (IntfHdl == INVALID_HANDLE_VALUE)
            {
                dwErr = GetLastError();
                DbgPrint((TRC_ERR,"CreateFileA failed with %d", dwErr));
            }
        }

        // if still fine so far
        if (dwErr == ERROR_SUCCESS)
        {
            // attempt to open the handle
            if (!DeviceIoControl(
                    IntfHdl,
                    IOCTL_NDISUIO_OPEN_DEVICE,
                    (LPVOID)wszGuid,
                    wcslen(wszGuid)*sizeof(WCHAR),
                    NULL,
                    0,
                    &dwDummy,
                    NULL))
            {
                dwErr = GetLastError();
                DbgPrint((TRC_ERR,"IOCTL_NDISUIO_OPEN_DEVICE failed with %d", dwErr));
            }
        }

        // if finally we're ok here, 
        if (dwErr == ERROR_SUCCESS)
        {
            // set up the HSH_HANDLE structure and insert it in the hash
            pHshHandle->hdlInterf = IntfHdl;
            pHshHandle->nRefCount = 1;

            dwErr = HshInsertObjectRef(
                        g_hshHandles.pRoot,
                        wszGuid,
                        pHshHandle,
                        &g_hshHandles.pRoot);
        }

        // if ok at the end, return the handle to the caller
        if (dwErr == ERROR_SUCCESS)
        {
            DbgPrint((TRC_GENERIC, "OpenIntfHandle -> 0x%x (new)", IntfHdl));
            *pIntfHdl = IntfHdl;   
        }
        // otherwise clear up all resources
        else
        {
            if (IntfHdl != INVALID_HANDLE_VALUE)
                CloseHandle(IntfHdl);
            MemFree(pHshHandle);
        }
    }
    // out of critical section
    LeaveCriticalSection(&g_hshHandles.csMutex);

exit:
    DbgPrint((TRC_TRACK,"OpenIntfHandle]=%d", dwErr));
    return dwErr;
}

DWORD
CloseIntfHandle(
    LPWSTR wszGuid)
{
    DWORD       dwErr;
    PHASH_NODE  pNode;

    DbgPrint((TRC_TRACK,"[CloseIntfHandle(%S)", wszGuid));

    // lock the hash
    EnterCriticalSection(&g_hshHandles.csMutex);

    // query the hash for the guid.
    dwErr = HshQueryObjectRef(
                g_hshHandles.pRoot,
                wszGuid,
                &pNode);
    // the object should be found.. but who knows
    if (dwErr == ERROR_SUCCESS)
    {
        PHSH_HANDLE pHshHandle;

        // the hash refuses to hash in NULL pObjects, so pHshHandle is guaranteed to be not NULL
        pHshHandle = (PHSH_HANDLE)pNode->pObject;
        // HshHandles are hashed in with a refCount of 1, and whenever we remove a handle
        // if the ref count reaches 0 we delete it entirely.
        // Having here a <=0 ref count is completely wrong.
        DbgAssert((pHshHandle->nRefCount > 0, "Corrupted nRefCount %d", pHshHandle->nRefCount));
        pHshHandle->nRefCount--;

        // if the ref count reached 0, remove the HSH_HANDLE from the hash..
        if (pHshHandle->nRefCount == 0)
        {
            dwErr = HshRemoveObjectRef(
                        g_hshHandles.pRoot,
                        pNode,
                        &pHshHandle,
                        &g_hshHandles.pRoot);
            if (dwErr == ERROR_SUCCESS)
            {
                // .. and clear all associated resources
                DbgPrint((TRC_GENERIC,"CloseIntfHandle -> 0x%x (closed)", pHshHandle->hdlInterf));
                CloseHandle(pHshHandle->hdlInterf);
                MemFree(pHshHandle);
            }
        }
        else
        {
                DbgPrint((TRC_GENERIC,"CloseIntfHandle -> 0x%x (deref)", pHshHandle->hdlInterf));
        }
    }

    LeaveCriticalSection(&g_hshHandles.csMutex);
    
    DbgPrint((TRC_TRACK,"CloseIntfHandle]=%d", dwErr));

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#

!INCLUDE $(NTMAKEENV)\makefile.plt

SERVER_IDL = ..\idl\wzc.idl
SERVER_ACF = ..\idl\wzcsrv.acf
IMPORT     = import
UNICODE    = 1

INCS  = -I. -I..\idl -I$(SDK_INC_PATH)  -I$(CRT_INC_PATH) -I$(PROJECT_ROOT)\inc -I$(NET_INC_PATH)
CPP = -cpp_cmd "$(MIDL_CPP)" -DNO_STRICT $(MIDL_FLAGS)

#
# MIDL COMPILE
#

MIDL_OPTIMIZATION_NT5=-Oicf -no_format_opt -robust -error all -out .\$(O)

$(O)\wzc_s.c $(O)\wzc_s.h : $(SERVER_IDL) $(SERVER_ACF)
    midl $(MIDL_OPTIMIZATION_NT5) -acf $(SERVER_ACF) -client none -oldnames -ms_ext -c_ext $(CPP) $(INCS) $(SERVER_IDL) -header wzc_s.h

$(O)\eapolmsg.mc: resources\eapollog.h resources\zcdblog.h
    mapmsg EAPOL EAPOL_LOG_BASE resources\eapollog.h > $(O)\eapolmsg.mc
    mapmsg ZCDB  ZCDB_LOG_BASE resources\zcdblog.h >> $(O)\eapolmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\precomp.h ===
#pragma once

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rpc.h>
#include <windows.h>
#include <rtutils.h>

#include <ntddndis.h>
#include <ntddip.h>
typedef NDIS_802_11_MAC_ADDRESS *PNDIS_802_11_MAC_ADDRESS;

#include <ndisguid.h>
#include <ndispnp.h>
#include <nuiouser.h>
#include <dbt.h>
#include <wmistr.h>
#include <wmium.h>
#include <netconp.h>
#include <dhcpcapi.h>
#include <wincrypt.h>
#include  <lmerr.h>
#include  <lmcons.h>
#include <secobj.h>
#include <esent.h>

#include "wzc_s.h"
#include "eapolext.h"
#include "database.h"

#define BAIL_ON_WIN32_ERROR(dwError)    \
    if (dwError) {                      \
        goto error;                     \
    }

#define BAIL_ON_LOCK_ERROR(dwError)     \
    if (dwError) {                      \
        goto lock;                      \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\rpcsrv.c ===
#include <precomp.h>
#include "wzcsvc.h"
#include "tracing.h"
#include "utils.h"
#include "intflist.h"
#include "rpcsrv.h"
#include "database.h"

extern HASH sessionHash;

//-------------------------------------------------
// Globals used for the RPC interface
BOOL g_bRpcStarted = FALSE;
PSECURITY_DESCRIPTOR g_pSecurityDescr = NULL;
GENERIC_MAPPING g_Mapping = {
    WZC_READ,
    WZC_WRITE,
    WZC_EXECUTE,
    WZC_ALL_ACCESS};

//-------------------------------------------------
// Initialize the security settings for the RPC API
DWORD
WZCSvcInitRPCSecurity()
{
    DWORD    dwErr = ERROR_SUCCESS;
    NTSTATUS ntStatus;
    ACE_DATA AceData[6] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, WZC_ACCESS_SET|WZC_ACCESS_QUERY, &LocalSystemSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, WZC_ACCESS_SET|WZC_ACCESS_QUERY, &AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, WZC_ACCESS_SET|WZC_ACCESS_QUERY, &AliasAccountOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, WZC_ACCESS_SET|WZC_ACCESS_QUERY, &AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, WZC_ACCESS_SET|WZC_ACCESS_QUERY, &AliasUsersSid},
        // for now (WinXP Client RTM) the decision was made to let everybody party, but based on 
        // the acl below. Later, the security schema won't change by default, but support will be
        // added allowing admins to tighten up the access to the service RPC APIs.
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, WZC_ACCESS_SET|WZC_ACCESS_QUERY, &WorldSid}};

    DbgPrint((TRC_TRACK, "[WZCSvcInitRPCSecurity"));

    // create the well known SIDs;
    dwErr = RtlNtStatusToDosError(
                NetpCreateWellKnownSids(NULL)
            );
    DbgAssert((dwErr == ERROR_SUCCESS, "Error %d creating the well known Sids!", dwErr));

    // create the security object.
    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = RtlNtStatusToDosError(
                    NetpCreateSecurityObject(
                        AceData,
                        sizeof(AceData)/sizeof(ACE_DATA),
                        NULL,
                        NULL,
                        &g_Mapping,
                        &g_pSecurityDescr)
                );
        DbgAssert((dwErr == ERROR_SUCCESS, "Error %d creating the global security object!", dwErr));
    }

    DbgPrint((TRC_TRACK, "WZCSvcInitRPCSecurity]=%d", dwErr));
    return dwErr;
}

//-------------------------------------------------
// Check the access for the particular access mask provided
DWORD
WZCSvcCheckRPCAccess(DWORD dwAccess)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (g_pSecurityDescr != NULL)
    {
        dwErr = NetpAccessCheckAndAudit(
                    _T("WZCSVC"),
                    _T("WZCSVC"),
                    g_pSecurityDescr,
                    dwAccess,
                    &g_Mapping);

        DbgPrint((TRC_GENERIC, ">>> Security check reports err=%d.", dwErr));
    }

    return dwErr;
}

//-------------------------------------------------
// Check the validity of a RAW_DATA pointer
DWORD
WZCSvcCheckParamRawData(PRAW_DATA prd)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (prd != NULL)
    {
        if (prd->dwDataLen != 0 && prd->pData == NULL)
            dwErr = ERROR_INVALID_PARAMETER;
    }

    return dwErr;
}

//-------------------------------------------------
// Check the validity of an SSID embedded in a RAW_DATA pointer
DWORD
WZCSvcCheckSSID(PNDIS_802_11_SSID pndSSID, UINT nBytes)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (pndSSID != NULL)
    {
        if (nBytes < FIELD_OFFSET(NDIS_802_11_SSID, Ssid) ||
            pndSSID->SsidLength > nBytes - FIELD_OFFSET(NDIS_802_11_SSID, Ssid))
            dwErr = ERROR_INVALID_PARAMETER;
    }

    return dwErr;
}

//-------------------------------------------------
// Check the validity of a list of configurations embedded in a RAW_DATA pointer
DWORD
WZCSvcCheckConfig(PWZC_WLAN_CONFIG pwzcConfig, UINT nBytes)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (pwzcConfig != NULL)
    {
        if (pwzcConfig->Length > nBytes ||
            pwzcConfig->Length != sizeof(WZC_WLAN_CONFIG))
            dwErr = ERROR_INVALID_PARAMETER;

        if (dwErr == ERROR_SUCCESS)
            dwErr = WZCSvcCheckSSID(&pwzcConfig->Ssid, sizeof(NDIS_802_11_SSID));

        if (dwErr == ERROR_SUCCESS &&
            pwzcConfig->KeyLength > WZCCTL_MAX_WEPK_MATERIAL)
            dwErr = ERROR_INVALID_PARAMETER;
    }
    
    return dwErr;
}

//-------------------------------------------------
// Check the validity of a list of configurations embedded in a RAW_DATA pointer
DWORD
WZCSvcCheckConfigList(PWZC_802_11_CONFIG_LIST pwzcList, UINT nBytes)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (pwzcList != NULL)
    {
        UINT i;

        if (nBytes < FIELD_OFFSET(WZC_802_11_CONFIG_LIST, Config))
            dwErr = ERROR_INVALID_PARAMETER;

        nBytes -= FIELD_OFFSET(WZC_802_11_CONFIG_LIST, Config);

        if (dwErr == ERROR_SUCCESS &&
            ((pwzcList->NumberOfItems * sizeof(WZC_WLAN_CONFIG) > nBytes) ||
             (pwzcList->Index > pwzcList->NumberOfItems)
            )
           )
            dwErr = ERROR_INVALID_PARAMETER;

        for (i = 0; i < pwzcList->NumberOfItems && dwErr == ERROR_SUCCESS; i++)
            dwErr = WZCSvcCheckConfig(&(pwzcList->Config[i]), sizeof(WZC_WLAN_CONFIG));
    }

    return dwErr;
}

//-------------------------------------------------
// Check the validity of the "input" fields from the INTF_ENTRY.
DWORD
WZCSvcCheckParamIntfEntry(PINTF_ENTRY pIntfEntry)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (pIntfEntry != NULL)
    {
        if (dwErr == ERROR_SUCCESS)
            dwErr = WZCSvcCheckParamRawData(&pIntfEntry->rdSSID);
        if (dwErr == ERROR_SUCCESS)
            dwErr = WZCSvcCheckParamRawData(&pIntfEntry->rdBSSID);
        if (dwErr == ERROR_SUCCESS)
            dwErr = WZCSvcCheckParamRawData(&pIntfEntry->rdStSSIDList);
        if (dwErr == ERROR_SUCCESS)
            dwErr = WZCSvcCheckConfigList(
                        (PWZC_802_11_CONFIG_LIST)pIntfEntry->rdStSSIDList.pData,
                        pIntfEntry->rdStSSIDList.dwDataLen);
        if (dwErr == ERROR_SUCCESS)
            dwErr = WZCSvcCheckParamRawData(&pIntfEntry->rdCtrlData);
    }

    return dwErr;
}


//-------------------------------------------------
// Cleanup whatever data was used for RPC security settings
DWORD
WZCSvcTermRPCSecurity()
{
    DWORD dwErr = ERROR_SUCCESS;

    DbgPrint((TRC_TRACK, "[WZCSvcTermRPCSecurity"));

    dwErr = RtlNtStatusToDosError(NetpDeleteSecurityObject(&g_pSecurityDescr));
    DbgAssert((dwErr == ERROR_SUCCESS, "Failed to delete the global security descriptor!"));
    g_pSecurityDescr = NULL;

    NetpFreeWellKnownSids();

    DbgPrint((TRC_TRACK, "WZCSvcTermRPCSecurity]=%d", dwErr));
    return dwErr;
}

RPC_STATUS CallbackCheckLocal(
  IN RPC_IF_HANDLE *Interface,
  IN void *Context)
{
    RPC_STATUS rpcStat = RPC_S_OK;
    LPTSTR pBinding = NULL;
    LPTSTR pProtSeq = NULL;


    rpcStat = RpcBindingToStringBinding(Context, &pBinding);
    if (rpcStat == RPC_S_OK)
    {
        rpcStat = RpcStringBindingParse(
                    pBinding,
                    NULL,
                    &pProtSeq,
                    NULL,
                    NULL,
                    NULL);
    }

    if (rpcStat == RPC_S_OK)
    {
        if (_tcsicmp((LPCTSTR)pProtSeq, _T("ncalrpc")) != 0)
            rpcStat = RPC_S_ACCESS_DENIED;
    }

    if (pBinding != NULL)
        RpcStringFree(&pBinding);
    if (pProtSeq != NULL)
        RpcStringFree(&pProtSeq);

    return rpcStat;
}

DWORD
WZCSvcStartRPCServer()
{
    DWORD dwStatus = RPC_S_OK;

    DbgPrint((TRC_TRACK, "[WZCSvcStartRPCServer"));

    if (dwStatus == RPC_S_OK)
    {
        dwStatus = RpcServerUseProtseqEp(
                        L"ncalrpc",
                        10,
                        L"wzcsvc",
                        NULL);
        if (dwStatus == RPC_S_DUPLICATE_ENDPOINT)
            dwStatus = RPC_S_OK;
    }

    if (dwStatus == RPC_S_OK)
    {
        dwStatus = RpcServerRegisterIfEx(
                        winwzc_ServerIfHandle,
                        0,
                        0,
                        RPC_IF_ALLOW_SECURE_ONLY,  // WZCSAPI is using RPC_C_PROTECT_LEVEL_PKT_PRIVACY
                        0,  // ignored for non auto-listen interfaces
                        CallbackCheckLocal); 
    }

    if (dwStatus == RPC_S_OK)
    {
        dwStatus = RpcServerRegisterAuthInfo(
                        0,
                        RPC_C_AUTHN_WINNT,
                        0,
                        0);
    }

    if (dwStatus == RPC_S_OK)
    {
        dwStatus = RpcServerRegisterAuthInfo(
                       0,
                       RPC_C_AUTHN_GSS_KERBEROS,
                       0,
                       0);
    }

    if (dwStatus == RPC_S_OK)
    {
        dwStatus = RpcServerRegisterAuthInfo(
                       0,
                       RPC_C_AUTHN_GSS_NEGOTIATE,
                       0,
                       0);
    }

    if (dwStatus == RPC_S_OK)
    {
        dwStatus = RpcServerListen(
                        3,
                        RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                        TRUE);
        if (dwStatus == RPC_S_ALREADY_LISTENING)
            dwStatus = RPC_S_OK;
    }

    if (dwStatus != RPC_S_OK)
    {
        RpcServerUnregisterIfEx(
            winwzc_ServerIfHandle,
            0,
            0);
    }

    g_bRpcStarted = (dwStatus == RPC_S_OK);

    WZCSvcInitRPCSecurity();

    DbgPrint((TRC_TRACK, "WZCSvcStartRPCServer]=%d", dwStatus));
    return (dwStatus);
}

DWORD
WZCSvcStopRPCServer()
{
    DWORD dwStatus = RPC_S_OK;
    DbgPrint((TRC_TRACK, "[WZCSvcStopRPCServer"));

    if (g_bRpcStarted)
    {
        g_bRpcStarted = FALSE;

        WZCSvcTermRPCSecurity();

        dwStatus = RpcServerUnregisterIfEx(
                       winwzc_ServerIfHandle,
                       0,
                       0);

        // don't stop RPC from listening - other services could rely on this
        //RpcMgmtStopServerListening(0);
    }

    DbgPrint((TRC_TRACK, "WZCSvcStopRPCServer]=%d", dwStatus));
    return (dwStatus);
}

DWORD
RpcEnumInterfaces(
	STRING_HANDLE     pSrvAddr,
	PINTFS_KEY_TABLE  pIntfsTable)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwNumIntfs;

    InterlockedIncrement(&g_nThreads);

    DbgPrint((TRC_TRACK, "[RpcEnumInterfaces"));
    dwErr = WZCSvcCheckRPCAccess(WZC_ACCESS_QUERY);
    if (dwErr == ERROR_SUCCESS)
    {
        dwNumIntfs = LstNumInterfaces();

        DbgPrint((TRC_GENERIC,
            "Num interfaces = %d",
            dwNumIntfs));

        if (dwNumIntfs == 0)
            goto exit;

        pIntfsTable->pIntfs = RpcCAlloc(dwNumIntfs*sizeof(INTF_KEY_ENTRY));
        if (pIntfsTable->pIntfs == NULL)
        {
            dwErr = GetLastError();
            goto exit;
        }
    
        dwErr = LstGetIntfsKeyInfo(pIntfsTable->pIntfs, &dwNumIntfs);

        if (dwErr != ERROR_SUCCESS || dwNumIntfs == 0)
        {
            RpcFree(pIntfsTable->pIntfs);
            pIntfsTable->pIntfs = NULL;
            goto exit;
        }

        pIntfsTable->dwNumIntfs = dwNumIntfs;
    
        for (dwNumIntfs = 0; dwNumIntfs < pIntfsTable->dwNumIntfs; dwNumIntfs++)
        {
            DbgPrint((TRC_GENERIC,
                "Intf %d:\t%S",
                dwNumIntfs,
                pIntfsTable->pIntfs[dwNumIntfs].wszGuid == NULL ? 
                    L"(null)" :
                    pIntfsTable->pIntfs[dwNumIntfs].wszGuid));
        }
    }
exit:
    DbgPrint((TRC_TRACK, "RpcEnumInterfaces]=%d", dwErr));

    InterlockedDecrement(&g_nThreads);
    return dwErr;
}

DWORD
RpcQueryInterface(
    STRING_HANDLE pSrvAddr,
    DWORD         dwInFlags,
    PINTF_ENTRY   pIntfEntry,
    LPDWORD       pdwOutFlags)
{
    DWORD dwErr = ERROR_SUCCESS;

    InterlockedIncrement(&g_nThreads);

    DbgPrint((TRC_TRACK, "[RpcQueryInterface(0x%x,%S)", dwInFlags, pIntfEntry->wszGuid));
    dwErr = WZCSvcCheckRPCAccess(WZC_ACCESS_QUERY);
    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = LstQueryInterface(dwInFlags, pIntfEntry, pdwOutFlags);
    }
    DbgPrint((TRC_TRACK, "RpcQueryInterface]=%d", dwErr));

    InterlockedDecrement(&g_nThreads);
    return dwErr;
}

DWORD
RpcSetInterface(
    STRING_HANDLE pSrvAddr,
    DWORD         dwInFlags,
    PINTF_ENTRY   pIntfEntry,
    LPDWORD       pdwOutFlags)
{
    DWORD dwErr = ERROR_SUCCESS;

    InterlockedIncrement(&g_nThreads);

    DbgPrint((TRC_TRACK, "[RpcSetInterface(0x%x,%S)", dwInFlags, pIntfEntry->wszGuid));
    dwErr = WZCSvcCheckRPCAccess(WZC_ACCESS_SET);

    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = WZCSvcCheckParamIntfEntry(pIntfEntry);
    }

    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = LstSetInterface(dwInFlags, pIntfEntry, pdwOutFlags);
    }
    DbgPrint((TRC_TRACK, "RpcSetInterface]=%d", dwErr));

    InterlockedDecrement(&g_nThreads);
    return dwErr;
}

DWORD
RpcRefreshInterface(
    STRING_HANDLE pSrvAddr,
    DWORD         dwInFlags,
    PINTF_ENTRY   pIntfEntry,
    LPDWORD       pdwOutFlags)
{
    DWORD dwErr = ERROR_SUCCESS;

    InterlockedIncrement(&g_nThreads);

    DbgPrint((TRC_TRACK, "[RpcRefreshInterface(0x%x,%S)", dwInFlags, pIntfEntry->wszGuid));
    dwErr = WZCSvcCheckRPCAccess(WZC_ACCESS_SET);
    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = LstRefreshInterface(dwInFlags, pIntfEntry, pdwOutFlags);
    }
    DbgPrint((TRC_TRACK, "RpcRefreshInterface]=%d", dwErr));

    InterlockedDecrement(&g_nThreads);
    return dwErr;
}

DWORD
RpcQueryContext(
    STRING_HANDLE pSrvAddr,
    DWORD         dwInFlags,
    PWZC_CONTEXT  pContext,
    LPDWORD       pdwOutFlags)
{
    DWORD dwErr = ERROR_SUCCESS;

    InterlockedIncrement(&g_nThreads);

    DbgPrint((TRC_TRACK, "[RpcQueryContext(0x%x)", dwInFlags));
    dwErr = WZCSvcCheckRPCAccess(WZC_ACCESS_QUERY);
    if (dwErr == ERROR_SUCCESS)
    {
      dwErr = WzcContextQuery(dwInFlags, pContext, pdwOutFlags);
    }
    DbgPrint((TRC_TRACK, "RpcQueryContext]=%d", dwErr));

    InterlockedDecrement(&g_nThreads);
    return dwErr;

}

DWORD
RpcSetContext(
    STRING_HANDLE pSrvAddr,
    DWORD         dwInFlags,
    PWZC_CONTEXT  pContext,
    LPDWORD       pdwOutFlags)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  bLogEnabled = FALSE;

    InterlockedIncrement(&g_nThreads);

    DbgPrint((TRC_TRACK, "[RpcSetContext(0x%x)", dwInFlags));
    dwErr = WZCSvcCheckRPCAccess(WZC_ACCESS_SET);
    if (dwErr == ERROR_SUCCESS)
    {
      dwErr = WzcContextSet(dwInFlags, pContext, pdwOutFlags);
    }
    DbgPrint((TRC_TRACK, "RpcSetContext]=%d", dwErr));
    BAIL_ON_WIN32_ERROR(dwErr);

    EnterCriticalSection(&g_wzcInternalCtxt.csContext);

    bLogEnabled = ((g_wzcInternalCtxt.wzcContext.dwFlags & WZC_CTXT_LOGGING_ON) != 0);

    dwErr = WZCSetLoggingState(bLogEnabled);
    BAIL_ON_LOCK_ERROR(dwErr);

lock:
    LeaveCriticalSection(&g_wzcInternalCtxt.csContext);

error:

    InterlockedDecrement(&g_nThreads);
    return dwErr;

}

extern SERVICE_STATUS g_WZCSvcStatus;
DWORD
RpcCmdInterface(
    IN DWORD        dwHandle,
    IN DWORD        dwCmdCode,
    IN LPWSTR       wszIntfGuid,
    IN PRAW_DATA    prdUserData)
{
    DWORD dwErr = ERROR_SUCCESS;

    InterlockedIncrement(&g_nThreads);
    // We need to avoid processing this command if the service is not currently running
    // We need this protection only for this call because other than for the other calls,
    // RpcCmdInterface is called from 802.1x which runs within the same service. For all
    // the other Rpc stubs, the RPC server is shut down prior to destroying the global data
    // hence there is guaranteed no other calls will be made afterwards.
    if (g_WZCSvcStatus.dwCurrentState == SERVICE_RUNNING)
    {
        DbgPrint((TRC_TRACK, "[RpcCmdInterface(0x%x,%S)", dwCmdCode, wszIntfGuid));

        dwErr = WZCSvcCheckRPCAccess(WZC_ACCESS_SET);

        // currently this is not an RPC call! This is called directly from 802.1x. Consequently,
        // WZCSvcCheckRPCAccess will return RPC_S_NO_CALL_ACTIVE. We could either remove the
        // RPC check for now, or pass through the RPC_S_NO_CALL_ACTIVE (since later this could
        // become an RPC call). We do the latter!
        if (dwErr == ERROR_SUCCESS || dwErr == RPC_S_NO_CALL_ACTIVE)
        {
            dwErr = LstCmdInterface(dwHandle, dwCmdCode, wszIntfGuid, prdUserData);
        }
        DbgPrint((TRC_TRACK, "RpcCmdInterface]=%d", dwErr));
    }
    InterlockedDecrement(&g_nThreads);
    return dwErr;
}


VOID
WZC_DBLOG_SESSION_HANDLE_rundown(
    WZC_DBLOG_SESSION_HANDLE hSession
    )
{
    if (!g_bRpcStarted) {
        return;
    }
    if (!IsDBOpened()) {
	return;
    }


    if (hSession) {
        (VOID) CloseWZCDbLogSession(
                   hSession
                   );
    }

    return;
}


DWORD
RpcOpenWZCDbLogSession(
    STRING_HANDLE pServerName,
    WZC_DBLOG_SESSION_HANDLE * phSession
    )
{
    DWORD dwError = 0;

    InterlockedIncrement(&g_nThreads);
  
    dwError = WZCSvcCheckRPCAccess(WZC_ACCESS_QUERY);
    BAIL_ON_WIN32_ERROR(dwError);

    if (!phSession) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = OpenWZCDbLogSession(
                  pServerName,
                  0,
                  phSession
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:
    InterlockedDecrement(&g_nThreads);
    return (dwError);
}


DWORD
RpcCloseWZCDbLogSession(
    WZC_DBLOG_SESSION_HANDLE * phSession
    )
{
    DWORD dwError = 0;

    InterlockedIncrement(&g_nThreads);

    dwError = WZCSvcCheckRPCAccess(WZC_ACCESS_QUERY);
    BAIL_ON_WIN32_ERROR(dwError);

    if (!IsDBOpened()) {
        dwError = ERROR_SERVICE_DISABLED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!phSession) {
        InterlockedDecrement(&g_nThreads);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = CloseWZCDbLogSession(
                  *phSession
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phSession = NULL;

error:

    InterlockedDecrement(&g_nThreads);
    return (dwError);
}


DWORD
RpcEnumWZCDbLogRecords(
    WZC_DBLOG_SESSION_HANDLE hSession,
    PWZC_DB_RECORD_CONTAINER pTemplateRecordContainer,
    PBOOL pbEnumFromStart,
    DWORD dwPreferredNumEntries,
    PWZC_DB_RECORD_CONTAINER * ppRecordContainer
    )
{
    DWORD dwError = 0;
    PWZC_DB_RECORD pWZCRecords = NULL;
    DWORD dwNumRecords = 0;
    PWZC_DB_RECORD pTemplateRecord = NULL;

    InterlockedIncrement(&g_nThreads);

    dwError = WZCSvcCheckRPCAccess(WZC_ACCESS_QUERY);
    BAIL_ON_WIN32_ERROR(dwError);

    if (!IsDBOpened()) {
        dwError = ERROR_SERVICE_DISABLED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!hSession || !pbEnumFromStart) {
        InterlockedDecrement(&g_nThreads);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pTemplateRecordContainer || !ppRecordContainer ||
        !*ppRecordContainer) {  
        InterlockedDecrement(&g_nThreads);
        return (ERROR_INVALID_PARAMETER);
    }

    if (pTemplateRecordContainer->pWZCRecords) {
        if (pTemplateRecordContainer->dwNumRecords != 1) {  
            InterlockedDecrement(&g_nThreads);
            return (ERROR_INVALID_PARAMETER);
        }
        pTemplateRecord = pTemplateRecordContainer->pWZCRecords;
    }

    dwError = EnumWZCDbLogRecordsSummary(
                  hSession,
                  pTemplateRecord,
                  pbEnumFromStart,
                  dwPreferredNumEntries,
                  &pWZCRecords,
                  &dwNumRecords,
                  NULL
                  );
    if (dwError != ERROR_NO_MORE_ITEMS) {
        BAIL_ON_WIN32_ERROR(dwError);
    }

    (*ppRecordContainer)->pWZCRecords = pWZCRecords;
    (*ppRecordContainer)->dwNumRecords = dwNumRecords;

    InterlockedDecrement(&g_nThreads);
    return (dwError);

error:

    (*ppRecordContainer)->pWZCRecords = NULL;
    (*ppRecordContainer)->dwNumRecords = 0; 
    InterlockedDecrement(&g_nThreads);
    return (dwError);
}


DWORD
RpcFlushWZCDbLog(
    WZC_DBLOG_SESSION_HANDLE hSession
    )
{
    DWORD dwError = 0;

    InterlockedIncrement(&g_nThreads);
    
    dwError = WZCSvcCheckRPCAccess(WZC_ACCESS_SET);
    BAIL_ON_WIN32_ERROR(dwError);

    if (!IsDBOpened()) {
        dwError = ERROR_SERVICE_DISABLED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!hSession){
        InterlockedDecrement(&g_nThreads);
        return(ERROR_INVALID_PARAMETER);
    }

    dwError = FlushWZCDbLog(
                  hSession
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:
    InterlockedDecrement(&g_nThreads);
    return (dwError);
}

DWORD
RpcGetWZCDbLogRecord(
    WZC_DBLOG_SESSION_HANDLE hSession,
    PWZC_DB_RECORD_CONTAINER pTemplateRecordContainer,
    PWZC_DB_RECORD_CONTAINER * ppRecordContainer
    )
{
    DWORD dwError = 0;
    PWZC_DB_RECORD pWZCRecords = NULL;
    DWORD dwNumRecords = 0;
    PWZC_DB_RECORD pTemplateRecord = NULL;

    InterlockedIncrement(&g_nThreads);

    dwError = WZCSvcCheckRPCAccess(WZC_ACCESS_QUERY);
    BAIL_ON_WIN32_ERROR(dwError);

    if (!IsDBOpened()) {
        dwError = ERROR_SERVICE_DISABLED;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if(!hSession){
        InterlockedDecrement(&g_nThreads);
        return(ERROR_NOT_SUPPORTED);
    }

    if (!pTemplateRecordContainer || !ppRecordContainer ||
        !*ppRecordContainer) {  
        InterlockedDecrement(&g_nThreads);
        return (ERROR_INVALID_PARAMETER);
    }

    if (pTemplateRecordContainer->pWZCRecords) {
        if (pTemplateRecordContainer->dwNumRecords != 1) {  
            InterlockedDecrement(&g_nThreads);
            return (ERROR_INVALID_PARAMETER);
        }
        pTemplateRecord = pTemplateRecordContainer->pWZCRecords;
    }

    dwError = GetWZCDbLogRecord(
                  hSession,
                  pTemplateRecord,
                  &pWZCRecords,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppRecordContainer)->pWZCRecords = pWZCRecords;
    (*ppRecordContainer)->dwNumRecords = 1;

    InterlockedDecrement(&g_nThreads);
    return (dwError);

error:

    (*ppRecordContainer)->pWZCRecords = NULL;
    (*ppRecordContainer)->dwNumRecords = 0; 
    InterlockedDecrement(&g_nThreads);
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\intflist.c ===
#include <precomp.h>
#include "wzcsvc.h"
#include "notify.h"
#include "intflist.h"
#include "tracing.h"
#include "utils.h"
#include "deviceio.h"
#include "storage.h"
#include "zcdblog.h"

// global interfaces list. It has to be initialized to {NULL, NULL} just
// to differentiate the case when the list head was never initialized.
HASH        g_hshHandles = {0};     // HASH handing GUID<->Handle mapping; Key = "\DEVICE\{guid}"
INTF_HASHES g_lstIntfHashes = {0};  // set of hashes for all INTF_CONTEXTs
HANDLE      g_htmQueue = NULL;      // global timer queue

//-----------------------------------------------------------
// Synchronization routines
DWORD
LstRccsReference(PINTF_CONTEXT pIntfContext)
{
    DWORD dwErr = ERROR_INVALID_PARAMETER;
    DbgPrint((TRC_TRACK,"[LstRccsReference(0x%p)", pIntfContext));
    if (pIntfContext)
    {
        DbgPrint((TRC_SYNC," LstRccsReference 0x%p.refCount=%d", pIntfContext, pIntfContext->rccs.nRefCount));
        InterlockedIncrement(&(pIntfContext->rccs.nRefCount));
        dwErr = ERROR_SUCCESS;
    }
    DbgPrint((TRC_TRACK,"LstRccsReference]=%d", dwErr));
    return dwErr;
}

DWORD
LstRccsLock(PINTF_CONTEXT pIntfContext)
{
    DWORD dwErr = ERROR_INVALID_PARAMETER;
    DbgPrint((TRC_TRACK,"[LstRccsLock(0x%p)", pIntfContext));
    if (pIntfContext)
    {
        EnterCriticalSection(&(pIntfContext->rccs.csMutex));
        dwErr = ERROR_SUCCESS;
    }
    DbgPrint((TRC_TRACK,"LstRccsLock]=%d", dwErr));
    return dwErr;
}

DWORD
LstRccsUnlockUnref(PINTF_CONTEXT pIntfContext)
{
    DWORD dwErr = ERROR_INVALID_PARAMETER;
    DbgPrint((TRC_TRACK,"[LstRccsUnlockUnref(0x%p)", pIntfContext));
    if (pIntfContext)
    {
        UINT nLastCount;

        // before doing anything, while we're still in the critical section,
        // decrement the ref counter and store the result in a local variable
        nLastCount = InterlockedDecrement(&(pIntfContext->rccs.nRefCount));
        LeaveCriticalSection(&(pIntfContext->rccs.csMutex));

        // if we were the last to use this context, efectively destroy it.
        DbgPrint((TRC_SYNC," LstRccsUnlockUnref 0x%p.refCount=%d", pIntfContext, nLastCount));

        if (nLastCount == 0)
            LstDestroyIntfContext(pIntfContext);

        dwErr = ERROR_SUCCESS;
    }
    DbgPrint((TRC_TRACK,"LstRccsUnlockUnref]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Intializes all the internal interfaces hashes
DWORD
LstInitIntfHashes()
{
    DWORD dwErr = ERROR_SUCCESS;

    __try 
    {
        InitializeCriticalSection(&g_lstIntfHashes.csMutex);
        g_lstIntfHashes.bValid = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = GetExceptionCode();
    }

    g_lstIntfHashes.pHnGUID = NULL;
    InitializeListHead(&g_lstIntfHashes.lstIntfs);
    g_lstIntfHashes.nNumIntfs = 0;

    return dwErr;
}

//-----------------------------------------------------------
// Destructs all the internal data structures - hash & lists
// This call is done after all the threads confirmed they're done.
DWORD
LstDestroyIntfHashes()
{
    DWORD dwErr = ERROR_SUCCESS;

    DbgPrint((TRC_TRACK,"[LstDestroyIntfHashes"));

    // destruct whatever hashes we have
    HshDestructor(g_lstIntfHashes.pHnGUID);

    while (!IsListEmpty(&g_lstIntfHashes.lstIntfs))
    {
        PLIST_ENTRY     pEntry;
        PINTF_CONTEXT   pIntfContext;

        pEntry = RemoveHeadList(&g_lstIntfHashes.lstIntfs);
        pIntfContext = CONTAINING_RECORD(pEntry, INTF_CONTEXT, Link);
        // DevioCloseIntfHandle closes the handle only if it is valid.
        // Otherwise noop. pIntfContext is created in LstAddIntfToList
        // and there, the handle is initialized to HANDLE_INVALID_VALUE.
        // So .. attempting to close the handle here is safe.
        // also, this call is done after all the threads are terminated
        // meaning that all the ref counts should be already balanced (set
        // to 1)
        LstDestroyIntfContext(pIntfContext);
    }
    if (g_lstIntfHashes.bValid)
    {
        g_lstIntfHashes.bValid = FALSE;
        DeleteCriticalSection(&g_lstIntfHashes.csMutex);
    }

    DbgPrint((TRC_TRACK,"LstDestroyIntfHashes]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Intializes the global timer queue
DWORD
LstInitTimerQueue()
{
    g_htmQueue = CreateTimerQueue();
    return (g_htmQueue == NULL) ? GetLastError() : ERROR_SUCCESS;
}

//-----------------------------------------------------------
// Destructs the global timer queue
DWORD
LstDestroyTimerQueue()
{

    DbgPrint((TRC_TRACK|TRC_SYNC,"[LstDestroyTimerQueue"));
    if (g_htmQueue != NULL)
    {
        DeleteTimerQueueEx(g_htmQueue, INVALID_HANDLE_VALUE);
        g_htmQueue = NULL;
    }
    DbgPrint((TRC_TRACK|TRC_SYNC,"LstDestroyTimerQueue]"));
    return ERROR_SUCCESS;
}

//-----------------------------------------------------------
// Intializes all the internal data structures. Reads the list of interfaces from
// Ndisuio and gets all the parameters & OIDS.
DWORD
LstLoadInterfaces()
{
    DWORD           dwErr = ERROR_SUCCESS;
    HANDLE          hNdisuio = INVALID_HANDLE_VALUE;
    INT             i;
    RAW_DATA        rdBuffer;
    UINT            nRequired = QUERY_BUFFER_SIZE;

    rdBuffer.dwDataLen = 0;
    rdBuffer.pData = NULL;

    DbgPrint((TRC_TRACK,"[LstLoadInterfaces"));

    // open the handle to Ndisuio. It should be used throughout
    // the adapters iteration
    dwErr = DevioGetNdisuioHandle(&hNdisuio);

    // since we're going to add a bunch of interface contexts,
    // lock the hashes first thing to do
    EnterCriticalSection(&g_lstIntfHashes.csMutex);

    for (i = 0; dwErr == ERROR_SUCCESS; i++)
    {
        PNDISUIO_QUERY_BINDING  pQueryBinding;
        PINTF_CONTEXT           pIntfContext = NULL;

        // allocate as much buffer as needed by DevioGetIntfBindingByIndex
        if (rdBuffer.dwDataLen < nRequired)
        {
            MemFree(rdBuffer.pData);
            rdBuffer.pData = MemCAlloc(nRequired);
            if (rdBuffer.pData == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            rdBuffer.dwDataLen = nRequired;
        }

        pQueryBinding = (PNDISUIO_QUERY_BINDING)rdBuffer.pData;

        // go get the binding structure for this adapter's index
        dwErr = DevioGetIntfBindingByIndex(
                    hNdisuio,
                    i,
                    &rdBuffer);
        // if Ndisuio says the buffer is not large enough, increase it with 1K
        if (dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            // increase the buffer only if it is not obscenely large already
            // otherwise just skip this index and move to the next.
            if (nRequired < QUERY_BUFFER_MAX)
            {
                nRequired += QUERY_BUFFER_SIZE;
                i--;
            }
            dwErr = ERROR_SUCCESS;
            continue;
        }

        // if we got back NO_MORE_ITEMS then we did our job successfully
        if (dwErr == ERROR_NO_MORE_ITEMS)
        {
            // translate this error to success and break out
            dwErr = ERROR_SUCCESS;
            break;
        }

        // in case any other failure was returned from NDISUIO, just break out
        // this SHOULDN'T HAPPEN
        if (dwErr != ERROR_SUCCESS)
        {
            DbgAssert((FALSE,
                      "DevioGetIntfBindingByIndex failed for interface %d with err=%d", i, dwErr));
            break;
        }

        // go build the INTF_CONTEXT structure, based on 
        // the binding information (key info for the adapter)
        dwErr = LstConstructIntfContext(
                    pQueryBinding,
                    &pIntfContext);

        if (dwErr == ERROR_SUCCESS)
        {
            // reference and lock this brand new context
            LstRccsReference(pIntfContext);
            LstRccsLock(pIntfContext);

            // add it to the hashes
            dwErr = LstAddIntfToHashes(pIntfContext);
            if (dwErr == ERROR_SUCCESS)
            {
                // and dispatch the eEventAdd
                dwErr = StateDispatchEvent(
                            eEventAdd,
                            pIntfContext,
                            NULL);

                // clear up the INTFCTL_INTERNAL_BLK_MEDIACONN bit since this is not a media sense handler
                pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_BLK_MEDIACONN;
            }
            // if for any reason hashing or dispatching failed, cleanup the context here
            if (dwErr != ERROR_SUCCESS)
                LstRemoveIntfContext(pIntfContext);

            // we're done with this context, unlock & unref it here.
            LstRccsUnlockUnref(pIntfContext);
        }

        // error happened at this point, recover and go to the next interface
        dwErr = ERROR_SUCCESS;
    }

    // unlock the hashes here
    LeaveCriticalSection(&g_lstIntfHashes.csMutex);

    // close the handle to Ndisuio - if it was opened successfully.
    if (hNdisuio != INVALID_HANDLE_VALUE)
        CloseHandle(hNdisuio);

    // free memory (it handles the case when the pointer is NULL)
    MemFree(rdBuffer.pData);

    DbgPrint((TRC_TRACK,"LstLoadInterfaces]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Constructor for the INTF_CONTEXT. Takes as parameter the binding information.
// Interface's GUID constitutes the context's key info.
// This call doesn't insert the new context in any hash or list
DWORD
LstConstructIntfContext(
    PNDISUIO_QUERY_BINDING  pBinding,
    PINTF_CONTEXT *ppIntfContext)
{
    DWORD           dwErr = ERROR_SUCCESS;
    PINTF_CONTEXT   pIntfContext;
    LPWSTR          wszName;
    DWORD           dwNameLen;

    DbgPrint((TRC_TRACK,"[LstConstructIntfContext(0x%p)", pBinding));
    DbgAssert((ppIntfContext != NULL, "Invalid in/out parameter"));

    // zero the output param
    *ppIntfContext = NULL;

    // pIntfContext is allocated with zero_init meaning
    // all internal pointers are set to null
    pIntfContext = MemCAlloc(sizeof(INTF_CONTEXT));
    if (pIntfContext == NULL)
    {
        dwErr = GetLastError();
        goto exit;
    }

    // initialize context's fields, in their definition order..
    // Initialize the context specific fields (links, sync, control flags, state)
    InitializeListHead(&pIntfContext->Link);
    dwErr = RccsInit(&(pIntfContext->rccs));    // reference counter is initially set to 1
    if (dwErr != ERROR_SUCCESS)
        goto exit;
    pIntfContext->dwCtlFlags = (INTFCTL_ENABLED | Ndis802_11AutoUnknown);
    // initially, the ncstatus is "DISCONNECTED" (until wzc plumbs it down)
    pIntfContext->ncStatus = NCS_MEDIA_DISCONNECTED;
    // the state handler is initially set to NULL - it will be set to the
    // appropriate state when the context will be added to the state machine through
    // dispatching an eEventAdd event.
    pIntfContext->pfnStateHandler = NULL;
    // init the timer
    pIntfContext->hTimer = INVALID_HANDLE_VALUE;

    // if we do have a valid NDIS binding for this interface
    // otherwise, the following fields gets initialized as below:
    //     hTimer <- INVALID_HANDLE_VALUE
    //     dwIndex <- 0
    //     wszGuid <- NULL
    //     wszDescr <- NULL
    if (pBinding != NULL)
    {
        // create an inactive timer for this interface.
        if (!CreateTimerQueueTimer(
                &(pIntfContext->hTimer),
                g_htmQueue,
                (WAITORTIMERCALLBACK)WZCTimeoutCallback,
                pIntfContext,
                TMMS_INFINITE,
                TMMS_INFINITE,
                WT_EXECUTEDEFAULT))
        {
            dwErr = GetLastError();
            goto exit;
        }

        // initialize the ndis specific fields
        pIntfContext->dwIndex = pBinding->BindingIndex;
        // Copy the interface's device name.
        // Device name is "\DEVICE\{guid}". We keep only the guid
        wszName = (LPWSTR)((LPBYTE)pBinding + pBinding->DeviceNameOffset);
        // the DeviceNameLength is in bytes and includes the null terminator
        dwNameLen = pBinding->DeviceNameLength / sizeof(WCHAR);
        if (dwNameLen >= 8 && !_wcsnicmp(wszName, L"\\DEVICE\\", 8)) // 8 is the # of chars in "\\DEVICE\\"
        {
            wszName += 8;
            dwNameLen -= 8;
        }
        if (dwNameLen > 0)
        {
            pIntfContext->wszGuid = MemCAlloc(sizeof(WCHAR)*dwNameLen);
            if (pIntfContext->wszGuid == NULL)
            {
                dwErr = GetLastError();
                goto exit;
            }
            wcscpy(pIntfContext->wszGuid, wszName);
        }
        // Copy the interface's description.name
        wszName = (LPWSTR)((LPBYTE)pBinding + pBinding->DeviceDescrOffset);
        // the DeviceDescrLength is in bytes and includes the null terminator
        dwNameLen = pBinding->DeviceDescrLength;
        if (dwNameLen > 0)
        {
            pIntfContext->wszDescr = MemCAlloc(dwNameLen);
            if (pIntfContext->wszDescr == NULL)
            {
                dwErr = GetLastError();
                goto exit;
            }
            wcscpy(pIntfContext->wszDescr, wszName);
        }
    }

    // ulMediaState, ulMediaType, ulPhysicalMediaType defaults to 0
    pIntfContext->hIntf = INVALID_HANDLE_VALUE;

    // initialize the 802.11 specific fields
    pIntfContext->wzcCurrent.Length = sizeof(WZC_WLAN_CONFIG);
    pIntfContext->wzcCurrent.InfrastructureMode = -1;
    pIntfContext->wzcCurrent.AuthenticationMode = -1;
    pIntfContext->wzcCurrent.Privacy = -1;
    // wzcCurrent is all zero-ed out because of how the allocation was done
    // pwzcVList, pwzcPList, pwzcSList, pwzcBList all default to NULL

    DbgPrint((TRC_GENERIC,
        "Intf [%d] %S - %S",
        pIntfContext->dwIndex,
        pIntfContext->wszGuid,
        pIntfContext->wszDescr));
exit:
    // if there was any error hit, clear up all resources allocated so far
    if (dwErr != ERROR_SUCCESS)
    {
        if (pIntfContext != NULL)
        {
            // this was a brand new context so there should be no timer queued for it
            if (pIntfContext->hTimer != NULL)
                DeleteTimerQueueTimer(g_htmQueue, pIntfContext->hTimer, INVALID_HANDLE_VALUE);

            MemFree(pIntfContext->wszDescr);
            MemFree(pIntfContext->wszGuid);
        }
        MemFree(pIntfContext);
    }
    else
    {
        // if success, copy out the new context
        *ppIntfContext = pIntfContext;
    }

    DbgPrint((TRC_TRACK,"LstConstructIntfContext(->0x%p)]=%d", *ppIntfContext, dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Prepares a context for the destruction:
// - Deletes any attached timer, making sure no other timer routines will be fired.
// - Removes the context from any hash, making sure no one else will find the context
// - Decrements the reference counter such that the context will be destroyed when unrefed.
// This function is called while holding the critical section on the interface.
DWORD
LstRemoveIntfContext(
    PINTF_CONTEXT pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;
    PINTF_CONTEXT pRemovedIntfContext = NULL;

    DbgPrint((TRC_TRACK,"[LstRemoveIntfContext(0x%p)", pIntfContext));

    // synchronously delete any timer associated with the context.
    // Since the timer routine is lightweight there is no risk of deadlock
    pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_TM_ON;
    if (pIntfContext->hTimer != INVALID_HANDLE_VALUE)
    {
        HANDLE  hTimer = pIntfContext->hTimer;
        pIntfContext->hTimer = INVALID_HANDLE_VALUE;
        DeleteTimerQueueTimer(g_htmQueue, hTimer, INVALID_HANDLE_VALUE);
    }

    // do the removal by passing down the guid formatted as "{guid}"
    // and expecting back the interface context in pIntfContext
    dwErr = LstRemIntfFromHashes(pIntfContext->wszGuid, &pRemovedIntfContext);
    DbgAssert((pIntfContext == pRemovedIntfContext, "The context removed from hashes doesn't match!"));

    // decrement the reference counter of the interface. This is what will make the context to be
    // effectively destroyed when the last thread unreference it.
    if (pIntfContext->rccs.nRefCount != 0)
        InterlockedDecrement(&(pIntfContext->rccs.nRefCount));

    DbgPrint((TRC_TRACK,"LstRemoveIntfContext]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Destructs the INTF_CONTEXT clearing all the resources allocated for it
// This call doesn't remove this context from any hash or list
DWORD
LstDestroyIntfContext(PINTF_CONTEXT pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;;
    DbgPrint((TRC_TRACK,"[LstDestroyIntfContext(0x%p)", pIntfContext));

    if (pIntfContext == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // the destroy call is made when it is sure thing the context needs to be
    // deleted (either something wrong happened while loading the context or its
    // ref counter reached 0). There is no point in testing the ref counter again.
    if (pIntfContext->hTimer != INVALID_HANDLE_VALUE)
        DeleteTimerQueueTimer(g_htmQueue, pIntfContext->hTimer, NULL);

    dwErr = DevioCloseIntfHandle(pIntfContext);

    MemFree(pIntfContext->wszGuid);
    MemFree(pIntfContext->wszDescr);
    MemFree(pIntfContext->pwzcVList);
    MemFree(pIntfContext->pwzcPList);
    WzcCleanupWzcList(pIntfContext->pwzcSList);
    WzcSSKFree(pIntfContext->pSecSessionKeys);
    WzcCleanupWzcList(pIntfContext->pwzcBList);

    // since rccs.nRefCount reached 0, this means there is absolutely
    // no other thread referencing this object and that no one will 
    // ever be able to reference it again. Getting to 0 means at least
    // one thread explicitly called LstDestroyIntfContext after removed
    // the object from the internal hashes.
    RccsDestroy(&pIntfContext->rccs);

    // at the end clear the interface context entirely
    MemFree(pIntfContext);

exit:
    DbgPrint((TRC_TRACK,"LstDestroyIntfContext]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Returns the number of contexts enlisted in the service
DWORD
LstNumInterfaces()
{
    return g_lstIntfHashes.nNumIntfs;
}

//-----------------------------------------------------------
// Inserts the given context in all the internal hashes
// This call assumes the hashes are locked by the caller
DWORD
LstAddIntfToHashes(PINTF_CONTEXT pIntf)
{
    DWORD dwErr = ERROR_SUCCESS;

    DbgPrint((TRC_TRACK,"[LstAddIntfToHashes(0x%p)", pIntf));
    DbgAssert((pIntf != NULL, "Cannot insert NULL context into hashes!"))

    // Insert this interface in the GUID hash
    dwErr = HshInsertObjectRef(
                g_lstIntfHashes.pHnGUID,
                pIntf->wszGuid,
                pIntf,
                &g_lstIntfHashes.pHnGUID);
    if (dwErr == ERROR_SUCCESS)
    {
        // inserting to tail insures an ascending ordered list on dwIndex
        // not that it matters :o)
        InsertTailList(&g_lstIntfHashes.lstIntfs, &(pIntf->Link));

        // everything went out successfully, so increment the global number
        // of interfaces.
        g_lstIntfHashes.nNumIntfs++;
    }

    DbgPrint((TRC_TRACK,"LstAddIntfToHashes]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Removes the context referenced by GUID from all the internal hashes.
// The GUID is expected to be in the format "{guid}"
// Returns in ppIntfContext the object that was removed from all hashes.
// This call assumes the hashes are locked already
DWORD
LstRemIntfFromHashes(LPWSTR wszGuid, PINTF_CONTEXT *ppIntfContext)
{
    DWORD           dwErr;
    PHASH_NODE      pNode;
    PINTF_CONTEXT   pIntfContext = NULL;

    DbgPrint((TRC_TRACK,"[LstRemIntfFromHashes(%S)", wszGuid == NULL? L"(null)" : wszGuid));
    DbgAssert((wszGuid != NULL, "Cannot clear NULL GUID from hashes!"));
    DbgAssert((ppIntfContext != NULL, "Invalid in/out parameter"));

    // get to the hash node
    dwErr = HshQueryObjectRef(
                g_lstIntfHashes.pHnGUID,
                wszGuid,
                &pNode);
    // if there is such a context
    // in the current hash, it needs to go away
    if (dwErr == ERROR_SUCCESS)
    {
        // remove this node from the Guid hash. We are already in its critical section
        dwErr = HshRemoveObjectRef(
                    g_lstIntfHashes.pHnGUID,
                    pNode,
                    &pIntfContext,
                    &g_lstIntfHashes.pHnGUID);
        // this is expected to succeed
        DbgAssert((dwErr == ERROR_SUCCESS,
                   "Error %d while removing node 0x%p from GUID hash!!",
                   dwErr,
                   pNode));
    }

    // if the context is not in the Guids hash, it is nowhere else
    // so go next only in case of success.
    if (dwErr == ERROR_SUCCESS)
    {
        PINTF_CONTEXT pIntfContextDup;

        // remove the context from the linked list
        RemoveEntryList(&pIntfContext->Link);
        // and initialize the pointer.
        InitializeListHead(&pIntfContext->Link);
        // decrement the global interfaces count
        g_lstIntfHashes.nNumIntfs--;
    }
    *ppIntfContext = pIntfContext;

    DbgPrint((TRC_TRACK,"LstRemIntfFromHashes(->0x%p)]=%d", 
              *ppIntfContext,
              dwErr));

    return dwErr;
}

//-----------------------------------------------------------
// Returns an array of *pdwNumIntfs INTF_KEY_ENTRY elements.
// The INTF_KEY_ENTRY contains whatever information identifies
// uniquely an adapter. Currently it includes just the GUID in
// the format "{guid}"
DWORD
LstGetIntfsKeyInfo(PINTF_KEY_ENTRY pIntfs, LPDWORD pdwNumIntfs)
{
    DWORD        dwErr = ERROR_SUCCESS;
    UINT         nIntfIdx;
    PLIST_ENTRY  pEntry;

    DbgPrint((TRC_TRACK,"[LstGetIntfsKeyInfo(0x%p,%d)", pIntfs, *pdwNumIntfs));

    // lock the hash during enumeration
    EnterCriticalSection(&g_lstIntfHashes.csMutex);

    for (pEntry = g_lstIntfHashes.lstIntfs.Flink, nIntfIdx = 0;
         pEntry != &g_lstIntfHashes.lstIntfs && nIntfIdx < *pdwNumIntfs;
         pEntry = pEntry->Flink, nIntfIdx++)
    {
        PINTF_CONTEXT   pIntfContext;

        // no need to lock this context since we're already holding the hashes.
        // no one can destroy the interface context now
        pIntfContext = CONTAINING_RECORD(pEntry, INTF_CONTEXT, Link);
        if (pIntfContext->wszGuid != NULL)
        {
            pIntfs[nIntfIdx].wszGuid = RpcCAlloc((wcslen(pIntfContext->wszGuid)+1)*sizeof(WCHAR));
            if (pIntfs[nIntfIdx].wszGuid == NULL)
            {
                dwErr = GetLastError();
                goto exit;
            }
            wcscpy(pIntfs[nIntfIdx].wszGuid, pIntfContext->wszGuid);
        }
        else
        {
            pIntfs[nIntfIdx].wszGuid = NULL;
        }
    }
    
exit:
    // unlock the hash now
    LeaveCriticalSection(&g_lstIntfHashes.csMutex);

    if (dwErr != ERROR_SUCCESS)
    {
        UINT i;
        // if an error occured, rollback whatever we already did
        for (i = 0; i<nIntfIdx; i++)
        {
            // nIntfIdx points to the entry that couldn't be allocated
            if (pIntfs[i].wszGuid != NULL)
            {
                RpcFree(pIntfs[i].wszGuid);
                pIntfs[i].wszGuid = NULL;
            }
        }
    }
    else
    {
        // in case of success, update pdwNumIntfs with the actual
        // number we could retrieve (it can be only less or equal)
        *pdwNumIntfs = nIntfIdx;
    }
    DbgPrint((TRC_TRACK, "LstGetIntfsKeyInfo]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Returns requested information on the specified adapter.
// [in] dwInFlags specifies the information requested. (see
//      bitmasks INTF_*
// [in] pIntfEntry should contain the GUID of the adapter
// [out] pIntfEntry contains all the requested information that
//      could be successfully retrieved.
// [out] pdwOutFlags provides an indication on the info that
//       was successfully retrieved
DWORD
LstQueryInterface(
    DWORD dwInFlags,
    PINTF_ENTRY pIntfEntry,
    LPDWORD pdwOutFlags)
{
    DWORD           dwErr = ERROR_FILE_NOT_FOUND;

    PHASH_NODE      pNode = NULL;
    PINTF_CONTEXT   pIntfContext;
    DWORD           dwOutFlags = 0;

    DbgPrint((TRC_TRACK, "[LstQueryInterface"));

    if (g_lstIntfHashes.bValid)
    {
        EnterCriticalSection(&g_lstIntfHashes.csMutex);
        dwErr = HshQueryObjectRef(
                    g_lstIntfHashes.pHnGUID,
                    pIntfEntry->wszGuid,
                    &pNode);
        if (dwErr == ERROR_SUCCESS)
        {
            pIntfContext = pNode->pObject;
            // bump up the reference counter since we're going
            // to work with this object
            LstRccsReference(pIntfContext);
        }
        LeaveCriticalSection(&g_lstIntfHashes.csMutex);
    }
    else
        dwErr = ERROR_ARENA_TRASHED;

    // a failure at this point, means there was no context
    // to lock so we can safely go to 'exit'
    if (dwErr != ERROR_SUCCESS)
        goto exit;

    // Lock the context now
    LstRccsLock(pIntfContext);

    // we can safely assume any living INTF_CONTEXT will have the correct
    // information for all the NDIS parameters below. So return them
    // unconditionally to the caller
    if ((dwInFlags & INTF_DESCR) &&
        (pIntfContext->wszDescr) != NULL)
    {
        pIntfEntry->wszDescr = RpcCAlloc(sizeof(WCHAR)*(wcslen(pIntfContext->wszDescr)+1));
        if (pIntfEntry->wszDescr != NULL)
        {
            wcscpy(pIntfEntry->wszDescr, pIntfContext->wszDescr);
            dwOutFlags |= INTF_DESCR;
        }
        else
            dwErr = GetLastError();
    }
    if (dwInFlags & INTF_NDISMEDIA)
    {
        pIntfEntry->ulMediaState = pIntfContext->ulMediaState;
        pIntfEntry->ulMediaType = pIntfContext->ulMediaType;
        pIntfEntry->ulPhysicalMediaType = pIntfContext->ulPhysicalMediaType;
        dwOutFlags |= INTF_NDISMEDIA;
    }
    if (dwInFlags & INTF_ALL_FLAGS)
    {
        DWORD dwActualFlags = dwInFlags & INTF_ALL_FLAGS;
        pIntfEntry->dwCtlFlags = pIntfContext->dwCtlFlags & dwActualFlags;
        dwOutFlags |= dwActualFlags;
    }
    // copy out the StSSIDList if requested
    if (dwInFlags & INTF_PREFLIST)
    {
        pIntfEntry->rdStSSIDList.dwDataLen = 0;
        pIntfEntry->rdStSSIDList.pData = NULL;
        // it could happen we don't have any static entry. If so, dwOutFlags
        // needs to be set correctly saying "success"
        if (pIntfContext->pwzcPList != NULL)
        {
            UINT nBytes;
            // see how much memory is needed to store all the static SSIDs
            nBytes = FIELD_OFFSET(WZC_802_11_CONFIG_LIST, Config) +
                     pIntfContext->pwzcPList->NumberOfItems * sizeof(WZC_WLAN_CONFIG);
            // allocate buffer large enough for all static SSIDs
            pIntfEntry->rdStSSIDList.pData = RpcCAlloc(nBytes);
            if (pIntfEntry->rdStSSIDList.pData != NULL)
            {
                // set the memory size in this RAW_DATA
                pIntfEntry->rdStSSIDList.dwDataLen = nBytes;
                // copy the whole WZC_802_11_CONFIG_LIST of static SSIDs
                CopyMemory(
                    pIntfEntry->rdStSSIDList.pData,
                    pIntfContext->pwzcPList,
                    nBytes);
                // mark "success"
                dwOutFlags |= INTF_PREFLIST;
            }
            else if (dwErr == ERROR_SUCCESS)
                dwErr = GetLastError();
        }
        else
        {
            // still, if no static SSID defined, this is seen as "success"
            dwOutFlags |= INTF_PREFLIST;
        }
    }

    // the 802.11 parameters are valid only if the context's state is not {SSr}
    if (pIntfContext->pfnStateHandler != StateSoftResetFn)
    {
        if (dwInFlags & INTF_INFRAMODE)
        {
            pIntfEntry->nInfraMode = pIntfContext->wzcCurrent.InfrastructureMode;
            dwOutFlags |= INTF_INFRAMODE;
        }
        if (dwInFlags & INTF_AUTHMODE)
        {
            pIntfEntry->nAuthMode = pIntfContext->wzcCurrent.AuthenticationMode;
            dwOutFlags |= INTF_AUTHMODE;
        }
        if (dwInFlags & INTF_WEPSTATUS)
        {
            pIntfEntry->nWepStatus = pIntfContext->wzcCurrent.Privacy;
            dwOutFlags |= INTF_WEPSTATUS;
        }

        // copy out the BSSID if requested
        if (dwInFlags & INTF_BSSID)
        {
            pIntfEntry->rdBSSID.dwDataLen = 0;
            pIntfEntry->rdBSSID.pData = RpcCAlloc(sizeof(NDIS_802_11_MAC_ADDRESS));
            if (pIntfEntry->rdBSSID.pData != NULL)
            {
                pIntfEntry->rdBSSID.dwDataLen = sizeof(NDIS_802_11_MAC_ADDRESS);
                CopyMemory(
                    pIntfEntry->rdBSSID.pData,
                    &pIntfContext->wzcCurrent.MacAddress,
                    pIntfEntry->rdBSSID.dwDataLen);
                dwOutFlags |= INTF_BSSID;
            }
            else if (dwErr == ERROR_SUCCESS)
                dwErr = GetLastError();
        }

        // copy out the SSID if requested
        if (dwInFlags & INTF_SSID)
        {
            pIntfEntry->rdSSID.dwDataLen = 0;
            pIntfEntry->rdSSID.pData = NULL;
            // normally there should be an SSID so set the dwOutFlags
            // for this field only if it exists
            if (pIntfContext->wzcCurrent.Ssid.SsidLength != 0)
            {
                pIntfEntry->rdSSID.pData = RpcCAlloc(pIntfContext->wzcCurrent.Ssid.SsidLength);
                if (pIntfEntry->rdSSID.pData != NULL)
                {
                    pIntfEntry->rdSSID.dwDataLen = pIntfContext->wzcCurrent.Ssid.SsidLength;
                    CopyMemory(
                        pIntfEntry->rdSSID.pData,
                        pIntfContext->wzcCurrent.Ssid.Ssid,
                        pIntfContext->wzcCurrent.Ssid.SsidLength);
                    dwOutFlags |= INTF_SSID;
                }
                else if (dwErr == ERROR_SUCCESS)
                    dwErr = GetLastError();
            }
        }

        // copy out the BSSIDList if requested
        if (dwInFlags & INTF_BSSIDLIST)
        {
            pIntfEntry->rdBSSIDList.dwDataLen = 0;
            pIntfEntry->rdBSSIDList.pData = NULL;
            // normally there should be a visible list so set the dwOutFlags
            // for this field only if it exists
            if (pIntfContext->pwzcVList != NULL)
            {
                UINT nBytes;

                // see how much memory is needed to store all the configurations
                nBytes = FIELD_OFFSET(WZC_802_11_CONFIG_LIST, Config) +
                         pIntfContext->pwzcVList->NumberOfItems * sizeof(WZC_WLAN_CONFIG);
                // allocate buffer large enough to hold all the configurations
                pIntfEntry->rdBSSIDList.pData = RpcCAlloc(nBytes);
                if (pIntfEntry->rdBSSIDList.pData != NULL)
                {
                    // set the memory size in this RAW_DATA
                    pIntfEntry->rdBSSIDList.dwDataLen = nBytes;
                    // copy the whole WZC_802_11_CONFIG_LIST
                    CopyMemory(
                        pIntfEntry->rdBSSIDList.pData,
                        pIntfContext->pwzcVList,
                        nBytes);
                    dwOutFlags |= INTF_BSSIDLIST;
                }
                else if (dwErr == ERROR_SUCCESS)
                    dwErr = GetLastError();
            }
        }
    }
    // if the context's state is {SSr} and some OIDs are requested, don't fail, but the bits
    // corresponding to the OIDs will all be nulled out. This is the indication of "pending"

    LstRccsUnlockUnref(pIntfContext);

exit:
    if (pdwOutFlags != NULL)
    {
        *pdwOutFlags = dwOutFlags;
        DbgPrint((TRC_GENERIC,"Sending OutFlags = 0x%x", *pdwOutFlags));
    }

    DbgPrint((TRC_TRACK, "LstQueryInterface]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Sets the specified parameters on the specified adapter.
// [in] dwInFlags specifies the parameters to be set. (see
//      bitmasks INTF_*
// [in] pIntfEntry should contain the GUID of the adapter and
//      all the additional parameters to be set as specified
//      in dwInFlags
// [out] pdwOutFlags provides an indication on the params that
//       were successfully set to the adapter
// Each parameter for which the driver says that was set successfully
// is copied into the interface's context.
DWORD
LstSetInterface(
    DWORD dwInFlags,
    PINTF_ENTRY pIntfEntry,
    LPDWORD pdwOutFlags)
{
    DWORD               dwErr = ERROR_SUCCESS;
    DWORD               dwLErr;
    PHASH_NODE          pNode = NULL;
    PINTF_CONTEXT       pIntfContext;
    DWORD               dwOutFlags = 0;

    DbgPrint((TRC_TRACK, "[LstSetInterface"));

    if (pIntfEntry->wszGuid == NULL)
    {
        if (g_wzcInternalCtxt.bValid)
        {
            EnterCriticalSection(&g_wzcInternalCtxt.csContext);
            pIntfContext = g_wzcInternalCtxt.pIntfTemplate;
            LstRccsReference(pIntfContext);
            LeaveCriticalSection(&g_wzcInternalCtxt.csContext);
        }
        else
            dwErr = ERROR_ARENA_TRASHED;
    }
    else
    {
        if (g_lstIntfHashes.bValid)
        {
            EnterCriticalSection(&g_lstIntfHashes.csMutex);
            dwErr = HshQueryObjectRef(
                        g_lstIntfHashes.pHnGUID,
                        pIntfEntry->wszGuid,
                        &pNode);
            if (dwErr == ERROR_SUCCESS)
            {
                pIntfContext = pNode->pObject;
                LstRccsReference(pIntfContext);
            }
            LeaveCriticalSection(&g_lstIntfHashes.csMutex);
        }
        else
            dwErr = ERROR_ARENA_TRASHED;
    }

    // a failure at this point, means there was no context
    // to lock so we can safely go to 'exit'
    if (dwErr != ERROR_SUCCESS)
        goto exit;

    LstRccsLock(pIntfContext);

    // 1) Set the new public Control flags, if specified
    if (dwInFlags & INTF_ALL_FLAGS)
    {
        DWORD dwActualFlags = dwInFlags & INTF_ALL_FLAGS;
        DWORD dwSupp = (pIntfContext->dwCtlFlags & INTFCTL_OIDSSUPP);

        pIntfContext->dwCtlFlags &= ~dwActualFlags;
        pIntfContext->dwCtlFlags |= pIntfEntry->dwCtlFlags & dwActualFlags;
        // retain the original INTFCTL_OIDSSUPP bit
        pIntfContext->dwCtlFlags |= dwSupp;
        dwOutFlags |= dwActualFlags;
    }

    // 2) copy the list of Static SSID (if requested to be set) as below:
    // Allocate the memory needed for the new static SSIDs list (if needed)
    // If successful, copy in the new buffer the new list of static SSIDs, clear up
    // whatever old list we had and put the new one in the interface's context
    if (dwInFlags & INTF_PREFLIST)
    {
        PWZC_802_11_CONFIG_LIST pNewPList;

        // MemCAlloc handles the case when size is 0 (returns NULL)
        pNewPList = (PWZC_802_11_CONFIG_LIST)MemCAlloc(pIntfEntry->rdStSSIDList.dwDataLen);
        if (pIntfEntry->rdStSSIDList.dwDataLen != 0 && pNewPList == NULL)
        {
            dwLErr = GetLastError();
        }
        else
        {
            // .. copy the data in the new buffer if there is any
            if (pNewPList != NULL)
            {
                CopyMemory(
                    pNewPList,
                    pIntfEntry->rdStSSIDList.pData,
                    pIntfEntry->rdStSSIDList.dwDataLen);
            }
            // set the data in the Interface's context
            MemFree(pIntfContext->pwzcPList);
            pIntfContext->pwzcPList = pNewPList;

            // if this is not referring to the template object..
            if (pIntfContext->wszGuid != NULL)
            {
                //..let 802.1X know about the change. (don't care about the return value)
                ElWZCCfgChangeHandler(
                    pIntfContext->wszGuid,
                    pIntfContext->pwzcPList);
            }

            dwOutFlags |= INTF_PREFLIST;
            dwLErr = ERROR_SUCCESS;
        }

        if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    // if there is anything more to set to this interface
    if (dwInFlags & ~(INTF_PREFLIST|INTF_ALL_FLAGS))
    {
        // and the control flag INTFCTL_ENABLED doesn't allow this
        if (!(pIntfContext->dwCtlFlags & INTFCTL_ENABLED))
        {
            // signal "request refused" error
            dwLErr = ERROR_REQUEST_REFUSED;
        }
        else
        {
            DWORD dwLOutFlags;

            // else go and set the oids
            dwLErr = DevioSetIntfOIDs(
                        pIntfContext,
                        pIntfEntry,
                        dwInFlags,
                        &dwLOutFlags);

            dwOutFlags |= dwLOutFlags;
        }

        if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    // log the user preference
    DbLogWzcInfo(WZCSVC_USR_CFGCHANGE, pIntfContext);

    // act on the changes..
    dwLErr = LstActOnChanges(dwOutFlags, pIntfContext);
    if (dwErr == ERROR_SUCCESS)
        dwErr = dwLErr;

    LstRccsUnlockUnref(pIntfContext);

exit:
    if (pdwOutFlags != NULL)
        *pdwOutFlags = dwOutFlags;

    DbgPrint((TRC_TRACK, "LstSetInterface]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Checks whether interface changes should cause the interface to be 
// reinserted in the state machine and it does so if needed.
// [in] dwChangedFlags indicates what the changes are. (see
//      bitmasks INTF_*)
// [in] pIntfContext context of the interface being changed.
DWORD
LstActOnChanges(
    DWORD       dwChangedFlags,
    PINTF_CONTEXT pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwLFlags = INTF_LIST_SCAN;
    BOOL  bAltered = FALSE;

    DbgPrint((TRC_TRACK, "[LstActOnChanges(0x08x, %p)", dwChangedFlags, pIntfContext));
    
    // if the changes involve the list of preferred networks or the control flags
    // then we should act on these changes..
    if (dwChangedFlags & (INTF_PREFLIST|INTF_ALL_FLAGS))
    {
        // if this is not the interface template object then just reset this interface
        if (pIntfContext->wszGuid != NULL)
        {
            // some interface changed, apply the template again on top of it
            if (g_wzcInternalCtxt.bValid)
            {
                PINTF_CONTEXT pIntfTContext;
                EnterCriticalSection(&g_wzcInternalCtxt.csContext);
                pIntfTContext = g_wzcInternalCtxt.pIntfTemplate;
                LstRccsReference(pIntfTContext);
                LeaveCriticalSection(&g_wzcInternalCtxt.csContext);

                LstRccsLock(pIntfTContext);
                dwErr = LstApplyTemplate(
                            pIntfTContext,
                            pIntfContext,
                            &bAltered);
                LstRccsUnlockUnref(pIntfTContext);
            }

            // if any of the control flags or the static list changed,
            // these settings should go into the registry now
            StoSaveIntfConfig(NULL, pIntfContext);

            // since we're resetting the state machine, turn back on the "signal" flag
            pIntfContext->dwCtlFlags |= INTFCTL_INTERNAL_SIGNAL;

            dwErr = StateDispatchEvent(
                        eEventCmdRefresh,
                        pIntfContext,
                        &dwLFlags);

            // clear up the INTFCTL_INTERNAL_BLK_MEDIACONN bit since this is not a media sense handler
            pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_BLK_MEDIACONN;
        }
        // if this is the interface template, then...
        else
        {
            PLIST_ENTRY  pEntry;

            // since the template changed, save it to the registry here
            dwErr = StoSaveIntfConfig(NULL, pIntfContext);
            DbgAssert((dwErr == ERROR_SUCCESS,
                       "Error %d while storing the template to registry"));

            // iterate through all the interfaces, apply the changes from the interface template
            // and reset each of them
            EnterCriticalSection(&g_lstIntfHashes.csMutex);

            for (pEntry = g_lstIntfHashes.lstIntfs.Flink;
                 pEntry != &g_lstIntfHashes.lstIntfs;
                 pEntry = pEntry->Flink)
            {
                PINTF_CONTEXT   pIntfLContext = CONTAINING_RECORD(pEntry, INTF_CONTEXT, Link);
                LstRccsReference(pIntfLContext);
                LstRccsLock(pIntfLContext);

                // Merge the template settings into the interface's context
                dwErr = LstApplyTemplate(
                           pIntfContext,
                           pIntfLContext,
                           NULL);
                DbgAssert((dwErr == ERROR_SUCCESS,
                           "Error %d while applying template to interface %S",
                           dwErr, pIntfLContext->wszGuid));

                // if any of the control flags or the static list changed,
                // these settings should go into the registry now
                StoSaveIntfConfig(NULL, pIntfLContext);

                // since we're resetting the state machine, turn back on the "signal" flag
                pIntfLContext->dwCtlFlags |= INTFCTL_INTERNAL_SIGNAL;

                dwErr = StateDispatchEvent(
                            eEventCmdRefresh,
                            pIntfLContext,
                            &dwLFlags);
                DbgAssert((dwErr == ERROR_SUCCESS,
                           "Error %d while resetting interface %S",
                           dwErr, pIntfLContext->wszGuid));

                // clear up the INTFCTL_INTERNAL_BLK_MEDIACONN bit since this is not a media sense handler
                pIntfLContext->dwCtlFlags &= ~INTFCTL_INTERNAL_BLK_MEDIACONN;

                LstRccsUnlockUnref(pIntfLContext);
            }

            LeaveCriticalSection(&g_lstIntfHashes.csMutex);
        }
    }

    if (dwErr == ERROR_SUCCESS && bAltered)
        dwErr = ERROR_PARTIAL_COPY;

    DbgPrint((TRC_TRACK, "LstActOnChanges]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Applies settings from the template context to the given interface context
// [in]  dwChanges: flags indicating settings that should be applied.
// [in]  pIntfTemplate: Interface template to pick settings from
// [in]  pIntfContext: Interface context to apply template to.
DWORD
LstApplyTemplate(
    PINTF_CONTEXT   pIntfTemplate,
    PINTF_CONTEXT   pIntfContext,
    LPBOOL          pbAltered)
{
    DWORD dwErr = ERROR_SUCCESS;
    PWZC_802_11_CONFIG_LIST pwzcTList = pIntfTemplate->pwzcPList;
    PWZC_802_11_CONFIG_LIST pwzcPList = pIntfContext->pwzcPList;
    PWZC_802_11_CONFIG_LIST pwzcRList = NULL; // resulting list
    ENUM_SELCATEG iCtg;
    UINT i, n, nCnt[7] = {0};
    BOOL bAltered = FALSE;
    PWZC_WLAN_CONFIG pTHInfra = NULL, pTHAdhoc = NULL; // head of Infra/Adhoc groups in the template list
    PWZC_WLAN_CONFIG pPHInfra = NULL, pPHAdhoc = NULL; // head of Infra/Adhoc groups in the preferred list
    PWZC_WLAN_CONFIG pOneTime = NULL; // pointer to the "one time configuration" if any

    DbgPrint((TRC_TRACK,"[LstApplyTemplate(%p->%p)", pIntfTemplate, pIntfContext));

    // apply the flags, if there are any provided
    if (pIntfTemplate->dwCtlFlags & INTF_POLICY)
    {
        DWORD dwPFlags = (pIntfContext->dwCtlFlags & INTF_ALL_FLAGS) & ~(INTF_OIDSSUPP);
        DWORD dwTFlags = (pIntfTemplate->dwCtlFlags & INTF_ALL_FLAGS) & ~(INTF_OIDSSUPP);

        if (dwPFlags != dwTFlags)
        {
            // if the policy flags are different from the interface's flags then
            // copy over just the "user" flag but don't overwrite the OIDSSUPP bit.
            dwPFlags = (pIntfContext->dwCtlFlags & ~INTF_ALL_FLAGS) |
                       (pIntfTemplate->dwCtlFlags & INTF_ALL_FLAGS);
            if (pIntfContext->dwCtlFlags & INTF_OIDSSUPP)
                dwPFlags |= INTF_OIDSSUPP;
            else
                dwPFlags &= ~INTF_OIDSSUPP;
            pIntfContext->dwCtlFlags = dwPFlags;

            bAltered = TRUE;
        }
    }
    else
    {
        // currently policy could come only through the template. Consequently,
        // if the template is not policy, local setting should not be policy either.
        // Also, whatever the policy plumbs last, should be persisted.
        pIntfContext->dwCtlFlags &= ~(INTF_POLICY|INTF_VOLATILE);
    }

    // check the interface's list of preferred networks
    if (pwzcPList != NULL)
    {
        for (i = 0; i < pwzcPList->NumberOfItems; i++)
        {
            PWZC_WLAN_CONFIG pPConfig = &(pwzcPList->Config[i]);

            // keep a pointer to the "one time config" if there is one.
            if (i == pwzcPList->Index)
                pOneTime = pPConfig;

            // tag each entry in the preferred list with its respective category
            if (pPConfig->InfrastructureMode == Ndis802_11Infrastructure)
            {
                if (pPHInfra == NULL)
                    pPHInfra = pPConfig;
                iCtg = ePI;
            }
            else if (pPConfig->InfrastructureMode == Ndis802_11IBSS)
            {
                if (pPHAdhoc == NULL)
                    pPHAdhoc = pPConfig;
                iCtg = ePA;
            }
            else
                iCtg = eN;

            // regardless the above logic, exclude this configuration from the result list in
            // either of the two cases:
            // - the config is marked "shadow": that is, it is irrelevant without a matching template
            //   configuration.
            // - the config is marked "volatile": that is, it has to go away unless the template is saying
            //   otherwise.
            // This test needs to be done here and not earlier, because we do need pPHInfra and pPHAdhoc
            // to be set up correctly, taking into account all the configurations.
            if (pPConfig->dwCtlFlags & (WZCCTL_INTERNAL_SHADOW|WZCCTL_VOLATILE))
                iCtg = eN;

            NWB_SET_SELCATEG(pPConfig, iCtg);
            nCnt[iCtg]++;
        }
    }

    // check the list of networks enforced by the template
    if (pwzcTList != NULL)
    {
        for (i = 0; i < pwzcTList->NumberOfItems; i++)
        {
            PWZC_WLAN_CONFIG pTConfig = &(pwzcTList->Config[i]);
            PWZC_WLAN_CONFIG pPConfig;

            if (pTConfig->InfrastructureMode == Ndis802_11Infrastructure)
            {
                if (pTHInfra == NULL)
                    pTHInfra = pTConfig;
                iCtg = eVPI;
            }
            else if (pTConfig->InfrastructureMode == Ndis802_11IBSS)
            {
                if (pTHAdhoc == NULL)
                    pTHAdhoc = pTConfig;
                iCtg = eVPA;
            }
            else
            {
                iCtg = eN;
                continue;
            }

            pPConfig = WzcFindConfig(pwzcPList, pTConfig, 0);

            // if there is an equivalent preference for the given template...
            if (pPConfig != NULL)
            {
                // if the template is policy, it should stomp over the preference
                if (pTConfig->dwCtlFlags & WZCCTL_POLICY)
                {
                    BOOL bWepOnlyDiff;
                    // if the configurations contents don't match ...
                    if (!WzcMatchConfig(pTConfig, pPConfig, &bWepOnlyDiff))
                    {
                        // even if the configs don't match, we need to pick up the
                        // WEP key from the one provided by the user and mark the template
                        // configuration as "shadow"-ed.
                        pTConfig->KeyIndex = pPConfig->KeyIndex;
                        pTConfig->KeyLength = pPConfig->KeyLength;
                        // the key length has already been checked!
                        DbgAssert((pTConfig->KeyLength <= WZCCTL_MAX_WEPK_MATERIAL, "WEP Key too large!!!"));
                        memcpy(pTConfig->KeyMaterial, pPConfig->KeyMaterial, pTConfig->KeyLength);
                        pTConfig->dwCtlFlags |= WZCCTL_INTERNAL_SHADOW;

                        // signal the user illegally attempted to alter the policy if these
                        // changes include more than just the WEP key.
                        if (!bWepOnlyDiff)
                            bAltered = TRUE;
                    }
                    // if the configurations do match check the order.
                    else
                    {
                        // if the offsets of the template & preferred in their respective
                        // groups are different, then it means the policy configuration have
                        // been reordered - not allowed, hence set the "Altered" bit.
                        if ((pTConfig->InfrastructureMode == Ndis802_11Infrastructure &&
                             (pTConfig - pTHInfra) != (pPConfig - pPHInfra)
                            ) ||
                            (pTConfig->InfrastructureMode == Ndis802_11IBSS &&
                             (pTConfig - pTHAdhoc) != (pPConfig - pPHAdhoc)
                            )
                           )
                        {
                            bAltered = TRUE;
                        }
                    }

                    // also, if the policy is substituting the "one time config",
                    // make the "one time config" to become the policy config.
                    if (pOneTime == pPConfig)
                        pOneTime = pTConfig;

                    // push the template
                    NWB_SET_SELCATEG(pTConfig, iCtg);
                    nCnt[iCtg]++;
                    // and take out the conflicting preference
                    iCtg = NWB_GET_SELCATEG(pPConfig);
                    nCnt[iCtg]--;
                    NWB_SET_SELCATEG(pPConfig, eN);
                    nCnt[eN]++;
                }
                // this non-policy template and already has an equivalent preference.
                // take it out then
                else
                {
                    iCtg = eN;
                    NWB_SET_SELCATEG(pTConfig, iCtg);
                    nCnt[iCtg]++;
                }
            }
            // there is no equivalent preference for the given template...
            else
            {
                // we don't have any preference for this template, so the template
                // is just pumped into the preference list.

                // if the template is a policy, it means the user deleted it and
                // he shouldn't have done so. Set the "Altered" bit then.
                if (pTConfig->dwCtlFlags & WZCCTL_POLICY)
                    bAltered = TRUE;

                // just push the template no matter what.
                NWB_SET_SELCATEG(pTConfig, iCtg);
                nCnt[iCtg]++;
            }
        }
    }

    // calculate the number of entries in the resulting list
    n = 0;
    for (iCtg=eVPI; iCtg < eN; iCtg++)
        n += nCnt[iCtg];

    // if there is not a single entry in the resulting list,
    // get out now. pwzcRList is already NULL.
    if (n == 0)
        goto exit;

    // ..allocate the new preferred list
    pwzcRList = (PWZC_802_11_CONFIG_LIST)
                MemCAlloc(FIELD_OFFSET(WZC_802_11_CONFIG_LIST, Config) + n * sizeof(WZC_WLAN_CONFIG));
    if (pwzcRList == NULL)
    {
        dwErr = GetLastError();
        goto exit;
    }
    // list is successfully allocated
    pwzcRList->NumberOfItems = n;
    pwzcRList->Index = n;

    // now change the semantic of all counters to mean "indices in the selection list"
    // for their respective group of entries
    for (iCtg = eN-1; iCtg >= eVPI; iCtg--)
    {
        n -= nCnt[iCtg];
        nCnt[iCtg] = n;
    }

    // copy over in the new list the entries enforced by the template
    if (pwzcTList != NULL)
    {
        for (i = 0; i < pwzcTList->NumberOfItems; i++)
        {
            PWZC_WLAN_CONFIG pTConfig = &(pwzcTList->Config[i]);

            iCtg = NWB_GET_SELCATEG(pTConfig);
            if (iCtg != eN)
            {
                PWZC_WLAN_CONFIG pRConfig = &(pwzcRList->Config[nCnt[iCtg]]);
                // copy the whole template configuration to the result list
                memcpy(pRConfig, pTConfig, sizeof(WZC_WLAN_CONFIG));
                // just for making sure, reset the 'deleted' flag as this is a brand new
                // config that was never attempted.
                pRConfig->dwCtlFlags &= ~WZCCTL_INTERNAL_DELETED;

                // if the template configuration is marked as being shadowed..
                if (pTConfig->dwCtlFlags & WZCCTL_INTERNAL_SHADOW)
                {
                    // ..set it to the preferred configuration also..
                    pRConfig->dwCtlFlags |= WZCCTL_INTERNAL_SHADOW;
                    // ..and make sure the preferred configuration gets persisted
                    // since it contains user information..
                    pRConfig->dwCtlFlags &= ~WZCCTL_VOLATILE;
                    // leave the template configuration with the bit "shadow" since
                    // it has been altered. This way, if the template is subsequently
                    // "applied" the user config won't get the "volatile" bit set back
                    // and it will still be marked "shadow".
                }

                // if this is the "one time" config, adjust the Index to point to this entry's index
                if (pOneTime == pTConfig)
                    pwzcRList->Index = nCnt[iCtg];

                nCnt[iCtg]++;
            }
            // reset the selection category we have used for this resulting entry
            NWB_SET_SELCATEG(pTConfig, 0);
        }
    }

    // copy over in the new list the entries from the original list
    if (pwzcPList != NULL)
    {
        for (i = 0; i < pwzcPList->NumberOfItems; i++)
        {
            PWZC_WLAN_CONFIG pPConfig = &(pwzcPList->Config[i]);

            iCtg = NWB_GET_SELCATEG(pPConfig);
            if (iCtg != eN)
            {
                PWZC_WLAN_CONFIG pRConfig = &(pwzcRList->Config[nCnt[iCtg]]);
                // copy the whole preferred configuration to the result list
                memcpy(pRConfig, pPConfig, sizeof(WZC_WLAN_CONFIG));
                // just for making sure, reset the 'deleted' flag as this is a brand new
                // config that was never attempted.
                pRConfig->dwCtlFlags &= ~WZCCTL_INTERNAL_DELETED;

                // if this is the "one time" config, adjust the Index to point to this entry's index
                if (pOneTime == pPConfig)
                    pwzcRList->Index = nCnt[iCtg];

                nCnt[iCtg]++;
            }
            // reset the selection category we have used for this preferred entry
            NWB_SET_SELCATEG(pPConfig, 0);
        }
    }

exit:

    if (dwErr == ERROR_SUCCESS)
    {
        // cleanup the original list and put in the new one
        WzcCleanupWzcList(pIntfContext->pwzcPList);
        pIntfContext->pwzcPList = pwzcRList;
    }

    if (pbAltered != NULL)
        *pbAltered = bAltered;

    DbgPrint((TRC_TRACK,"LstApplyTemplate]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Refreshes the specified parameters on the specified adapter.
// [in] dwInFlags specifies the parameters to be set. (see
//      bitmasks INTF_* and INTF_RFSH_*)
// [in] pIntfEntry should contain the GUID of the adapter 
// [out] pdwOutFlags provides an indication on the params that
//       were successfully refreshed to the adapter
// Each parameter for which the driver says that was refreshed 
// successfully is copied into the interface's context.
DWORD
LstRefreshInterface(
    DWORD dwInFlags,
    PINTF_ENTRY pIntfEntry,
    LPDWORD pdwOutFlags)
{
    DWORD           dwErr, dwLErr;
    PHASH_NODE      pNode = NULL;
    DWORD           dwOutFlags = 0;
    PINTF_CONTEXT   pIntfContext;

    DbgPrint((TRC_TRACK, "[LstRefreshInterface"));

    if (g_lstIntfHashes.bValid)
    {
        EnterCriticalSection(&g_lstIntfHashes.csMutex);
        dwErr = HshQueryObjectRef(
                    g_lstIntfHashes.pHnGUID,
                    pIntfEntry->wszGuid,
                    &pNode);
        if (dwErr == ERROR_SUCCESS)
        {
            pIntfContext = pNode->pObject;
            LstRccsReference(pIntfContext);
        }
        LeaveCriticalSection(&g_lstIntfHashes.csMutex);
    }
    else
        dwErr = ERROR_ARENA_TRASHED;

    // the interface needs to exist in order to refresh it
    if (dwErr == ERROR_SUCCESS)
    {
        LstRccsLock(pIntfContext);

        // if description is requested to be refreshed, do it now
        if (dwInFlags & INTF_DESCR)
        {
            CHAR                    QueryBuffer[QUERY_BUFFER_SIZE];
            PNDISUIO_QUERY_BINDING  pBinding;
            RAW_DATA                rdBuffer;

            // get first the binding structure for this interface
            rdBuffer.dwDataLen = sizeof(QueryBuffer);
            rdBuffer.pData = QueryBuffer;
            pBinding = (PNDISUIO_QUERY_BINDING)rdBuffer.pData;

            dwLErr = DevioGetInterfaceBindingByGuid(
                        INVALID_HANDLE_VALUE,  // the call will open Ndisuio locally
                        pIntfContext->wszGuid, // interface GUID as "{guid}"
                        &rdBuffer);
            // regardless of success, lets clean the current description
            MemFree(pIntfContext->wszDescr);
            pIntfContext->wszDescr = NULL;

            // if everything went fine
            if (dwLErr == ERROR_SUCCESS)
            {
                LPWSTR wszName;
                DWORD dwNameLen;

                // Copy the interface's description.name
                wszName = (LPWSTR)((LPBYTE)pBinding + pBinding->DeviceDescrOffset);
                // the DeviceDescrLength is in bytes and includes the null terminator
                dwNameLen = pBinding->DeviceDescrLength;
                if (dwNameLen > 0)
                {
                    pIntfContext->wszDescr = MemCAlloc(dwNameLen);
                    if (pIntfContext->wszGuid == NULL)
                        dwErr = GetLastError();
                    else
                        wcscpy(pIntfContext->wszDescr, wszName);
                }
            }
            // if all went fine, mark it out
            if (dwLErr == ERROR_SUCCESS)
                dwOutFlags |= INTF_DESCR;

            if (dwErr == ERROR_SUCCESS)
                dwErr = dwLErr;
        }

        // refresh any ndis settings if requested
        if (dwInFlags & INTF_NDISMEDIA)
        {
            dwLErr = DevioGetIntfStats(pIntfContext);
            if (dwLErr == ERROR_SUCCESS)
                dwOutFlags |= INTF_NDISMEDIA;

            if (dwErr == ERROR_SUCCESS)
                dwErr = dwLErr;
        }

        if (dwInFlags & INTF_ALL_OIDS)
        {
            DWORD dwLFlags = dwInFlags;

            // feed the state machine with the "refresh command" for this context
            dwLErr = StateDispatchEvent(eEventCmdRefresh, pIntfContext, &dwLFlags);

            // clear up the INTFCTL_INTERNAL_BLK_MEDIACONN bit since this is not a media sense handler
            pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_BLK_MEDIACONN;

            if (dwLErr == ERROR_SUCCESS)
                dwOutFlags |= dwLFlags;
            if (dwErr == ERROR_SUCCESS)
                dwErr = dwLErr;
        }

        LstRccsUnlockUnref(pIntfContext);
    }

    if (pdwOutFlags != NULL)
        *pdwOutFlags = dwOutFlags;

    DbgPrint((TRC_TRACK, "LstRefreshInterface]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Builds the list of configurations to be tried from the list of visible
// configurations, the list of preferred configurations and based on the
// interface's mode (Auto/Infra/Adhoc) and flags (is the service enabled?,
// fallback to visible?). 
// [in]  pIntfContext: Interface for which is done the selection
// [out] ppwzcSList: pointer to the list of selected configurations
//-----------------------------------------------------------
// Builds the list of configurations to be tried from the list of visible
// configurations, the list of preferred configurations and based on the
// interface's mode (Auto/Infra/Adhoc) and flags (is the service enabled?,
// fallback to visible?). 
// [in]  pIntfContext: Interface for which is done the selection
// [out] ppwzcSList: pointer to the list of selected configurations
DWORD
LstBuildSelectList(
    PINTF_CONTEXT           pIntfContext,
    PWZC_802_11_CONFIG_LIST *ppwzcSList)
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT i, n;
    UINT nCnt[7] = {0};
    ENUM_SELCATEG iVCtg, iPCtg, iCtg;
    PWZC_WLAN_CONFIG pCrtSConfig = NULL;

    DbgPrint((TRC_TRACK,"[LstBuildSelectList(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL, "(null) Interface context in LstBuildSelectList"));
    DbgAssert((ppwzcSList != NULL, "invalid (null) out param"));

    // set the pointer to the selection list to NULL
    (*ppwzcSList) = NULL;

    // for each entry in the visible list (if any), if the entry is probable to be included
    // in the selection set (either as Visible Infra or Visible Adhoc) set the category
    // attribute to point to the corresponding set and ++ the corresponding counter.
    // if the entry is not going to be included, set the same byte to eN (neutral)
    if (pIntfContext->pwzcVList)
    {
        for (i=0; i < pIntfContext->pwzcVList->NumberOfItems; i++)
        {
            PWZC_WLAN_CONFIG pVConfig = &(pIntfContext->pwzcVList->Config[i]);
            // the visible list might contain several APs for the same network.
            // Make sure we exclude the duplicates from the selection list.
            PWZC_WLAN_CONFIG pVDup = WzcFindConfig(pIntfContext->pwzcVList, pVConfig, i+1);

            // don't even consider this visible network if:
            // - another duplicate exists further in the list, or
            // - "automatically connect to non-preferred network" is not selected or
            // - its network type (infra / ad hoc) doesn't match the type selected in the intf config or
            // - the entry is blocked in the "blocked configurations" list (pwzcBList)
            if ((pVDup != NULL) ||
                !(pIntfContext->dwCtlFlags & INTFCTL_FALLBACK) ||
                (((pIntfContext->dwCtlFlags & INTFCTL_CM_MASK) != Ndis802_11AutoUnknown) &&
                 ((pIntfContext->dwCtlFlags & INTFCTL_CM_MASK) != pVConfig->InfrastructureMode)) ||
                WzcFindConfig(pIntfContext->pwzcBList, pVConfig, 0) != NULL)
                iVCtg = eN;
            else if (pVConfig->InfrastructureMode == Ndis802_11Infrastructure)
                iVCtg = eVI;
            else if (pVConfig->InfrastructureMode == Ndis802_11IBSS)
                iVCtg = eVA;
            else
                iVCtg = eN;

            NWB_SET_SELCATEG(pVConfig, iVCtg);
            nCnt[iVCtg]++;
        }
    }

    // Locate the current successful configuration (if any) in the preferred list. This config
    // should be marked Visible, regardless it is or not present in the visible list.
    if (pIntfContext->pwzcSList != NULL &&
        pIntfContext->pwzcSList->Index < pIntfContext->pwzcSList->NumberOfItems)
    {
        PWZC_WLAN_CONFIG pCrtConfig;
        
        pCrtConfig = &(pIntfContext->pwzcSList->Config[pIntfContext->pwzcSList->Index]);

        if (!(pCrtConfig->dwCtlFlags & WZCCTL_INTERNAL_DELETED))
            pCrtSConfig = WzcFindConfig(pIntfContext->pwzcPList, pCrtConfig, 0);
    }

    // for each entry in the preferred list (if any), if the entry matches the interface's mode
    // and is a "visible" one, put it in either eVPI or eVPA category and pull out the corresponding
    // visible entry from eVI or eVA or eN (if that entry was not supposed to be included in the selection).
    // If the entry is not "visible" put it either in ePI (only if the interface doesn't fallback to 
    // visible) or in ePA category.
    if (pIntfContext->pwzcPList != NULL)
    {
        for (i=0; i < pIntfContext->pwzcPList->NumberOfItems; i++)
        {
            PWZC_WLAN_CONFIG pPConfig = &(pIntfContext->pwzcPList->Config[i]);

            // don't even consider this preferred network if:
            // - its network type (infra / ad hoc) doesn't match the type selected in the intf config or
            // - the entry is blocked in the "blocked configurations" list (pwzcBList)
            if ((((pIntfContext->dwCtlFlags & INTFCTL_CM_MASK) != Ndis802_11AutoUnknown) &&
                 ((pIntfContext->dwCtlFlags & INTFCTL_CM_MASK) != pPConfig->InfrastructureMode)) ||
                WzcFindConfig(pIntfContext->pwzcBList, pPConfig, 0) != NULL)
            {
                iPCtg = eN;
            }
            else
            {
                PWZC_WLAN_CONFIG pVConfig = WzcFindConfig(pIntfContext->pwzcVList, pPConfig, 0);

                if (pPConfig == pCrtSConfig || pVConfig != NULL)
                {
                    // this preferred entry is either the current one or visible, 
                    // so point it either to eVPI or eVPA
                    if (pPConfig->InfrastructureMode == Ndis802_11Infrastructure)
                        iPCtg = eVPI;
                    else if (pPConfig->InfrastructureMode == Ndis802_11IBSS)
                        iPCtg = eVPA;
                    else
                        iPCtg = eN;

                    if (pVConfig != NULL)
                    {
                        // the corresponding visible entry (if any) has to be pulled out from whichever
                        // category it was in and has to be put in eN (neutral)
                        nCnt[NWB_GET_SELCATEG(pVConfig)]--;
                        iVCtg = eN;
                        NWB_SET_SELCATEG(pVConfig, iVCtg);
                        nCnt[iVCtg]++;
                    }
                    else
                    {
                        DbgPrint((TRC_TRACK, "Non-visible crt config raised to visible categ %d.", iPCtg));
                    }
                }
                else
                {
                    // this preferred entry is not visible, so either point it to ePI or to ePA.
                    if (pPConfig->InfrastructureMode == Ndis802_11Infrastructure)
                        iPCtg = ePI;
                    else if (pPConfig->InfrastructureMode == Ndis802_11IBSS)
                        iPCtg = ePA;
                    else
                        iPCtg = eN;
                }
            }
            NWB_SET_SELCATEG(pPConfig, iPCtg);
            nCnt[iPCtg]++;
        }
    }

    // calculate the number of entries in the selection list
    n = 0;
    for (iCtg=eVPI; iCtg < eN; iCtg++)
        n += nCnt[iCtg];

    // if there are any entries to copy afterall..
    if (n != 0)
    {
        // ..allocate the selection list
        (*ppwzcSList) = (PWZC_802_11_CONFIG_LIST)
                        MemCAlloc(FIELD_OFFSET(WZC_802_11_CONFIG_LIST, Config) + n * sizeof(WZC_WLAN_CONFIG));
        if ((*ppwzcSList) == NULL)
        {
            dwErr = GetLastError();
            goto exit;
        }
        (*ppwzcSList)->NumberOfItems = n;
        (*ppwzcSList)->Index = n;

        // now change the semantic of all counters to mean "indices in the selection list"
        // for their respective group of entries
        for (iCtg = eN-1; iCtg >= eVPI; iCtg--)
        {
            n -= nCnt[iCtg];
            nCnt[iCtg] = n;
        }
    }

exit:
    // copy first the entries from the preferred list into the selection list, 
    // at the index corresponding to their categories.
    if (pIntfContext->pwzcPList != NULL)
    {
        for (i=0; i < pIntfContext->pwzcPList->NumberOfItems; i++)
        {
            PWZC_WLAN_CONFIG pPConfig = &(pIntfContext->pwzcPList->Config[i]);

            // get the category for this preferred configuration
            iCtg = NWB_GET_SELCATEG(pPConfig);
            // if we have a selection list to copy into, and the entry is supposed
            // to be copied (not neutral) do it here
            if ((*ppwzcSList) != NULL && iCtg != eN)
            {
                PWZC_WLAN_CONFIG pSConfig = &((*ppwzcSList)->Config[nCnt[iCtg]]);
                // copy the whole preferred configuration (including the selection category 
                // & authentication mode) to the selection list
                memcpy(pSConfig, pPConfig, sizeof(WZC_WLAN_CONFIG));
                // just for making sure, reset the 'deleted' flag as this is a brand new
                // config that was never attempted.
                pSConfig->dwCtlFlags &= ~WZCCTL_INTERNAL_DELETED;
                // the remaining attributes (selection category, authentication mode) should be
                // left untouched.

                // make sure we propagate the 'start from index' if the preferred list shows like
                // a one time connect is requested
                if (i == pIntfContext->pwzcPList->Index)
                    (*ppwzcSList)->Index = nCnt[iCtg];

                nCnt[iCtg]++;
            }
            // reset the selection category we have used for this preferred entry
            NWB_SET_SELCATEG(pPConfig, 0);
        }
    }

    // next, copy the entries from the visible list into the selection list,
    // at the index corresponding to their categories.
    if (pIntfContext->pwzcVList != NULL)
    {
        for (i=0; i < pIntfContext->pwzcVList->NumberOfItems; i++)
        {
            PWZC_WLAN_CONFIG pVConfig = &(pIntfContext->pwzcVList->Config[i]);

            iCtg = NWB_GET_SELCATEG(pVConfig);
            // if we have a selection list to copy into, and the entry is supposed
            // to be copied (not neutral) do it here
            if ((*ppwzcSList) != NULL && iCtg != eN)
            {
                PWZC_WLAN_CONFIG pSConfig = &((*ppwzcSList)->Config[nCnt[iCtg]]);

                // copy the whole visible configuration (including its selection category)
                // to the selection set (for visible entries, authentication mode is 0 by default
                // since this information is not provided by the nic/driver)
                memcpy(pSConfig, pVConfig, sizeof(WZC_WLAN_CONFIG));
                // just for making sure, reset the 'deleted' flag as this is a brand new
                // config that was never attempted.
                pSConfig->dwCtlFlags &= ~WZCCTL_INTERNAL_DELETED;
                // bump up the index for this entry's category
                nCnt[iCtg]++;
            }
            // reset the selection category we have used for this visible entry
            NWB_SET_SELCATEG(pVConfig, 0);
        }
    }

    DbgPrint((TRC_TRACK,"LstBuildSelectList]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Checks whether the list of selected configurations has changed such
// that it is required to replumb the selection.
// [in]  pIntfContext: Interface for which is done the selection
// [in]  pwzcSList: new selection list to check the configuration against
// [out] pnSelIdx: if selection changed, provides the index where to start iterate from
// Returns: TRUE if replumbing is required. In this case, pnSelIdx is
// set to the configuration to start iterate from.
BOOL
LstChangedSelectList(
    PINTF_CONTEXT           pIntfContext,
    PWZC_802_11_CONFIG_LIST pwzcNSList,
    LPUINT                  pnSelIdx)
{
    BOOL bRet = FALSE;

    DbgPrint((TRC_TRACK,"[LstChangedSelectList(0x%p)", pIntfContext));
    DbgAssert((pnSelIdx != NULL,"invalid (null) pointer to out param"));

    // before anything, zero out the index for the current selected network
    *pnSelIdx = 0;

    // if there is no configuration the current selected list,
    // it means either we're just initializing the context or we failed all the
    // other configs. Either way, we need to replumb the card according to the
    // new selection list (if that one is also empty, we will follow the path
    // {SQ}->{SIter}->{SF})
    if (pIntfContext->pwzcSList == NULL || 
        pIntfContext->pwzcSList->NumberOfItems == 0 ||
        pwzcNSList == NULL ||
        pwzcNSList->NumberOfItems == 0)
    {
        DbgPrint((TRC_STATE, "SelList changed? YES; the current/new selection list is empty"));

        // since we're starting fresh, make sure to propagate the "one time connect" index, if any
        if (pwzcNSList != NULL && pwzcNSList->Index < pwzcNSList->NumberOfItems)
            *pnSelIdx = pwzcNSList->Index;

        bRet = TRUE;
    }
    else // we do have an old SList we need to look at
    {
        PWZC_WLAN_CONFIG    pSConfig;   // current sucessful configuration
        PWZC_WLAN_CONFIG    pNSConfig;  // successful configuration in the new selection list

        DbgAssert((pIntfContext->pwzcSList->Index < pIntfContext->pwzcSList->NumberOfItems,
                   "Selection index %d points outside SList[0..%d]",
                   pIntfContext->pwzcSList->Index,
                   pIntfContext->pwzcSList->NumberOfItems));

        // get a pointer to the current successful configuration
        pSConfig = &(pIntfContext->pwzcSList->Config[pIntfContext->pwzcSList->Index]);

        // as the first thing, let's check for the "one time connect". If this is requested,
        // the one time config has to match with the current selected config. Otherwise this 
        // is a change already.
        if (pwzcNSList->Index < pwzcNSList->NumberOfItems)
        {
            DbgPrint((TRC_STATE, "SList changed? Yes, \"one time connect\" is requested."));
            // in this case, we do mark this as a "change". Otherwise it is difficult to keep
            // the association to the "one time" connect for more than a scan cycle (other changes
            // will take precedence to the next round, when "one time" connect flag won't be there
            // anymore
            *pnSelIdx = pwzcNSList->Index;
            bRet = TRUE;
        }

        // if it is not decided yet whether it is a change (that is this is not a "one time connect")...
        if (!bRet)
        {
            // search for the crt successful config into the new selection list.
            pNSConfig = WzcFindConfig(pwzcNSList, pSConfig, 0);
            if (pNSConfig == NULL)
            {
                UINT i;
                ENUM_SELCATEG iSCtg;

                DbgPrint((TRC_STATE, "SList changed? Don't know yet. The current config is not in the NSList"));

                // the crt successful config is not in the new selection list. If the crt selection is
                // marked as being of the "preferred" kind, there is no other way it could disappear
                // other than being explicitly removed from the preferred list. In this case, yes,
                // this is a change.
                iSCtg = NWB_GET_SELCATEG(pSConfig);
                if (iSCtg != eVI && iSCtg != eVA)
                {
                    DbgPrint((TRC_STATE, "SList changed? Yes. The current preferred network has been removed."));
                    bRet = TRUE;
                    *pnSelIdx = 0; // iterate from the very beginning.
                }

                // In all the remaining cases (VI or VA), we need to check each of the new selected configurations
                // if it doesn't prevail the current successful one.
                for (i = 0; !bRet && i < pwzcNSList->NumberOfItems; i++)
                {
                    PWZC_WLAN_CONFIG pNConfig, pConfig;

                    // get the new configuration and search it into the current selection list
                    pNConfig = &(pwzcNSList->Config[i]);
                    pConfig = WzcFindConfig(pIntfContext->pwzcSList, pNConfig, 0);

                    // if the new selected configuration was not tried before either because
                    // it just showed up or because we didn't get to try it previously,
                    // then it is a potential better candidate
                    if (pConfig == NULL || pSConfig < pConfig)
                    {
                        ENUM_SELCATEG iNSCtg;

                        // get the category for the new config
                        iNSCtg = NWB_GET_SELCATEG(pNConfig);

                        // if the new configuration has a prevailing category, we should
                        // definitely replumb starting from here
                        if (iNSCtg < iSCtg)
                        {
                            DbgPrint((TRC_STATE,"SList changed? YES; a config with a better category has been detected."));
                            bRet = TRUE;
                            *pnSelIdx = i;
                        }
                        // remember: here, the current selected config can only be VI or VA. That is, if the category of 
                        // any newcomer in the selection list is even equal or greater that the current category, there
                        // is absolutely no point in moving out of here.
                    }
                    // there is a matching config which we tried before. We do acknowledge
                    // a change if the the two configs actually don't have matching content!
                    else if (!WzcMatchConfig(pNConfig, pConfig, NULL))
                    {
                        DbgPrint((TRC_STATE,"SList changed? YES; a better config failed before but it has been altered."));
                        bRet = TRUE;
                        *pnSelIdx = i;
                    }
                }
            }
            else // the current selected network is still in the new selection list (pNSConfig)
            {
                UINT i;

                // for each config in the new selection list, try to match it with an existent
                // configuration in the crt selection list
                for (i = 0; !bRet && i < pwzcNSList->NumberOfItems; i++)
                {
                    PWZC_WLAN_CONFIG pNConfig, pConfig;
                    ENUM_SELCATEG iNSCtg, iSCtg;

                    // if we are already at the current successful configuration this means
                    // we didn't find any new config to justify replumbing the interface
                    pNConfig = &(pwzcNSList->Config[i]);
                    if (pNConfig == pNSConfig)
                    {
                        bRet = !WzcMatchConfig(pNConfig, pSConfig, NULL);
                        if (bRet)
                            DbgPrint((TRC_STATE,"SList changed? YES; no better config found, but the current one has been altered."));
                        else
                            DbgPrint((TRC_STATE, "SList changed? NO; there is no new config that was not tried yet"));
                        break;
                    }

                    // get the category for the config in the new list
                    iNSCtg = NWB_GET_SELCATEG(pNConfig);
                    // search the configuration from the new selection list into the old selection list
                    pConfig = WzcFindConfig(pIntfContext->pwzcSList, pNConfig, 0);

                    // if this is either a brand new config, or one that has
                    // been raised in front of the current selection...
                    if (pConfig == NULL || pSConfig < pConfig)
                    {
                        // ...if the category is different, or is the same as the one of the successful config
                        // but is of a "preferred" kind, then it means the list has changed.
                        if (iNSCtg != NWB_GET_SELCATEG(pNSConfig) || (iNSCtg != eVI && iNSCtg != eVA))
                        {
                            DbgPrint((TRC_STATE,"SList changed? YES: there is a new config of a different or preferred category"));
                            bRet = TRUE;
                            *pnSelIdx = i;
                        }
                    }
                    else
                    {
                        // there is a matching entry in the old selection list, in front of the current
                        // successful configuration. This means the configuration has been tried before and
                        // failed. However, it could happen that the configuration was tried when it was
                        // not visible and now it is visible. In such a case, we should attempt replumbing
                        iSCtg = NWB_GET_SELCATEG(pConfig);
                        if (iNSCtg != iSCtg && (iSCtg == ePI || iSCtg == ePA))
                        {
                            DbgPrint((TRC_STATE,"SList changed? YES: a better config failed before but its categ changed from %d to %d",
                                       iSCtg, iNSCtg));
                            bRet = TRUE;
                            *pnSelIdx = i;
                        }
                        else if (!WzcMatchConfig(pNConfig, pConfig, NULL))
                        {
                            DbgPrint((TRC_STATE,"SList changed? YES; a better config failed before but it has been altered."));
                            bRet = TRUE;
                            *pnSelIdx = i;
                        }
                    }
                }
            }
        }
    }

    DbgPrint((TRC_TRACK,"LstChangedSelectList]=%s", bRet ? "TRUE" : "FALSE"));
    return bRet;
}

// fake WEP key to be used if there is no key set (and obviously web = disabled)
// and the remote guy requires privacy. This is a 104bit key.
BYTE  g_chFakeKeyMaterial[] = {0x56, 0x09, 0x08, 0x98, 0x4D, 0x08, 0x11, 0x66, 0x42, 0x03, 0x01, 0x67, 0x66};

//-----------------------------------------------------------
// Plumbs the interface with the selected configuration as it is pointed
// out by pwzcSList fields in the pIntfContext. Optional, it can
// return in ppSelSSID the configuration that was plumbed down
// [in]  pIntfContext: Interface context identifying ctl flags & the selected SSID
// [out] ppndSelSSID: pointer to the SSID that is being plumbed down.
DWORD
LstSetSelectedConfig(
    PINTF_CONTEXT       pIntfContext, 
    PWZC_WLAN_CONFIG    *ppndSelSSID)
{
    DWORD            dwErr = ERROR_SUCCESS;
    PWZC_WLAN_CONFIG pSConfig;
    INTF_ENTRY       IntfEntry = {0};
    DWORD            dwInFlags, dwOutFlags;
    BYTE  chBuffer[sizeof(NDIS_802_11_WEP) + WZCCTL_MAX_WEPK_MATERIAL - 1];
    BOOL  bFakeWKey = FALSE;     // flag indicating whether the fake WEP key is needed

    DbgPrint((TRC_TRACK, "[LstSetSelectedConfig(0x%p..)", pIntfContext));
    DbgAssert((pIntfContext != NULL, "(null) interface context in LstSetSelectedConfig"));

    if (pIntfContext->pwzcSList == NULL ||
        pIntfContext->pwzcSList->Index >= pIntfContext->pwzcSList->NumberOfItems)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }
    // get a pointer to the configuration to set down to the card.
    pSConfig = &(pIntfContext->pwzcSList->Config[pIntfContext->pwzcSList->Index]);

    // build the IntfEntry object that will specify what exactly goes down to the card
    dwInFlags = INTF_AUTHMODE | INTF_INFRAMODE | INTF_SSID;
    // authentication mode
    //IntfEntry.nAuthMode = NWB_GET_AUTHMODE(pSConfig);
    IntfEntry.nAuthMode = pSConfig->AuthenticationMode;
    // infrastructure mode
    IntfEntry.nInfraMode = pSConfig->InfrastructureMode;
    // SSID
    IntfEntry.rdSSID.dwDataLen = pSConfig->Ssid.SsidLength;
    IntfEntry.rdSSID.pData = pSConfig->Ssid.Ssid;

    // if the configuration to be plumbed down requires the presence of a WEP Key...
    if (pSConfig->Privacy || IntfEntry.nAuthMode != Ndis802_11AuthModeOpen)
    {
        // if there is a WEP key provided in this configuration plumb it down
        if (pSConfig->dwCtlFlags & WZCCTL_WEPK_PRESENT)
        {
            PNDIS_802_11_WEP pndUserWKey = (PNDIS_802_11_WEP)chBuffer;

            // build the ndis WEP key structure from the user's key
            // the key is a "transmit" key, regardless the index
            pndUserWKey->KeyIndex = 0x80000000 | pSConfig->KeyIndex;
            pndUserWKey->KeyLength = pSConfig->KeyLength;
            memcpy(pndUserWKey->KeyMaterial, pSConfig->KeyMaterial, WZCCTL_MAX_WEPK_MATERIAL);
            pndUserWKey->Length = sizeof(NDIS_802_11_WEP) + pndUserWKey->KeyLength - 1;

            // TODO: here is where we should decrypt inplace the WEP key
            {
                UINT i;
                for (i = 0; i < WZCCTL_MAX_WEPK_MATERIAL; i++)
                    pndUserWKey->KeyMaterial[i] ^= g_chFakeKeyMaterial[(7*i)%13];
            }

            // and ask for it to be set down
            IntfEntry.rdCtrlData.dwDataLen = pndUserWKey->Length;
            IntfEntry.rdCtrlData.pData = (LPBYTE)pndUserWKey;
            dwInFlags |= INTF_ADDWEPKEY;

            DbgPrint((TRC_GENERIC,"Plumbing down the User WEP txKey [idx:%d,len:%d]",
                      pSConfig->KeyIndex,
                      pSConfig->KeyLength));
        }
        // if a WEP Key is needed but none is provided for this configuration...
        else
        {
            // ...first thing to do is to ask the driver to reload its defaults.
            dwErr = DevioSetEnumOID(
                        pIntfContext->hIntf,
                        OID_802_11_RELOAD_DEFAULTS,
                        (DWORD)Ndis802_11ReloadWEPKeys);
            DbgAssert((dwErr == ERROR_SUCCESS, "Failed setting OID_802_11_RELOAD_DEFAULTS"));
            // need to check if reloading the defaults fixed the issue (not having a key)
            dwErr = DevioRefreshIntfOIDs(
                        pIntfContext,
                        INTF_WEPSTATUS,
                        NULL);
            DbgAssert((dwErr == ERROR_SUCCESS, "Failed refreshing OID_802_11_WEP_STATUS"));

            // if even after reloading the defaults, a key is still absent, then
            // set down the hardcoded key.
            if (dwErr == ERROR_SUCCESS &&
                pIntfContext->wzcCurrent.Privacy == Ndis802_11WEPKeyAbsent)
            {
                PNDIS_802_11_WEP pndFakeWKey = (PNDIS_802_11_WEP)chBuffer;

                // we should set the hardcoded WEP key
                pndFakeWKey->KeyIndex = 0x80000000;
                pndFakeWKey->KeyLength = 5; // the fake key has to be the smallest possible (40bit)
                dwErr = WzcRndGenBuffer(pndFakeWKey->KeyMaterial, pndFakeWKey->KeyLength, 0, 255);
                DbgAssert((dwErr == ERROR_SUCCESS, "Failed to generate the random fake wep key"));
                pndFakeWKey->Length = sizeof(NDIS_802_11_WEP) + pndFakeWKey->KeyLength - 1;

                // and ask for it to be set down
                IntfEntry.rdCtrlData.dwDataLen = pndFakeWKey->Length;
                IntfEntry.rdCtrlData.pData = (LPBYTE)pndFakeWKey;
                dwInFlags |= INTF_ADDWEPKEY;
                bFakeWKey = TRUE;
                DbgPrint((TRC_GENERIC,"Plumbing down the Fake WEP txKey [len:%d]",
                          IntfEntry.rdCtrlData.dwDataLen));
            }
        }

        // now enable WEP only if privacy is required and the current settings
        // show the WEP is not enabled
        if (pSConfig->Privacy && pIntfContext->wzcCurrent.Privacy != Ndis802_11WEPEnabled)
        {
            // and also we should enable WEP if it shows as not being
            // already enabled
            IntfEntry.nWepStatus = Ndis802_11WEPEnabled;
            dwInFlags |= INTF_WEPSTATUS;
        }
    }

    // if the configuration to be plumbed doesn't require privacy but currently
    // WEP is enabled, disable it.
    if (!pSConfig->Privacy && pIntfContext->wzcCurrent.Privacy == Ndis802_11WEPEnabled)
    {
        IntfEntry.nWepStatus = Ndis802_11WEPDisabled;
        dwInFlags |= INTF_WEPSTATUS;
    }

    // if everything is fine so far...
    if (dwErr == ERROR_SUCCESS)
    {
        // ...go and plumb the card with the settings below
        dwErr = DevioSetIntfOIDs(
                    pIntfContext,
                    &IntfEntry,
                    dwInFlags,
                    &dwOutFlags);
        // if we attempted to change the WEP Key...
        if (dwInFlags & INTF_ADDWEPKEY)
        {
            //.. and the operation succeeded..
            if (dwOutFlags & INTF_ADDWEPKEY)
            {
                // then either set the "fake key" flag - if it was a fake key..
                if (bFakeWKey)
                    pIntfContext->dwCtlFlags |= INTFCTL_INTERNAL_FAKE_WKEY;
                //..or reset it if we put a "real" key
                else
                    pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_FAKE_WKEY;
            }
            // if plumbing down the key failed, leave the "fake key" flag as
            // it is since there were no changes made.
        }
        // ...or if we didn't need to plumb a WEP key, reset the flag
        else
        {
            pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_FAKE_WKEY;
        }
    }

    if (dwErr != ERROR_SUCCESS)
        DbLogWzcError(WZCSVC_ERR_CFG_PLUMB, 
                      pIntfContext,
                      DbLogFmtSSID(0, &(pSConfig->Ssid)),
                      dwErr);

exit:
    DbgPrint((TRC_TRACK, "LstSetSelectedConfig]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// PnP notification handler
// [in/out]  ppIntfContext: Pointer to the Interface context for which
//       the notification was received
// [in]  dwNotifCode: Notification code (WZCNOTIF_*)
// [in]  wszDeviceKey: Key info on the device for which the notification
//       was received
DWORD
LstNotificationHandler(
    PINTF_CONTEXT   *ppIntfContext,
    DWORD           dwNotifCode,
    LPWSTR          wszDeviceKey)
{
    DWORD           dwErr = ERROR_SUCCESS;
    PINTF_CONTEXT   pIntfContext = *ppIntfContext;

    DbgPrint((TRC_TRACK,"[LstNotificationHandler(0x%p, %d, %S)",
                        pIntfContext,
                        dwNotifCode,
                        wszDeviceKey));

    if ((dwNotifCode == WZCNOTIF_DEVICE_ARRIVAL || dwNotifCode == WZCNOTIF_ADAPTER_BIND) && 
        pIntfContext == NULL)
    {
        CHAR                    QueryBuffer[QUERY_BUFFER_SIZE];
        PNDISUIO_QUERY_BINDING  pQueryBinding;
        RAW_DATA                rdBuffer;

        // get first the binding structure for this interface
        rdBuffer.dwDataLen = sizeof(QueryBuffer);
        rdBuffer.pData = QueryBuffer;
        pQueryBinding = (PNDISUIO_QUERY_BINDING)rdBuffer.pData;

        dwErr = DevioGetInterfaceBindingByGuid(
                    INVALID_HANDLE_VALUE,   // the call will open Ndisuio locally
                    wszDeviceKey,           // interface GUID as "{guid}"
                    &rdBuffer);
        // if everything went fine
        if (dwErr != ERROR_SUCCESS)
            goto exit;

        // go build the INTF_CONTEXT structure, based on 
        // the binding information (key info for the adapter)
        dwErr = LstConstructIntfContext(
                    pQueryBinding,
                    &pIntfContext);

        if (dwErr == ERROR_SUCCESS)
        {
            // increase its ref count and lock it up here
            LstRccsReference(pIntfContext);
            LstRccsLock(pIntfContext);

            // add it to the hashes
            dwErr = LstAddIntfToHashes(pIntfContext);
            if (dwErr == ERROR_SUCCESS)
            {
                dwErr = StateDispatchEvent(
                            eEventAdd,
                            pIntfContext,
                            NULL);
            }
            // if for any reason hashing or dispatching failed, cleanup the context here
            if (dwErr != ERROR_SUCCESS)
                LstRemoveIntfContext(pIntfContext);

            // release the context here
            LstRccsUnlockUnref(pIntfContext);
        }

        // it could happen that a context was created but it turned out to be a non-wireless
        // adapter. In this case all memory has been freed up, but pIntfContext remained
        // non-null. We need to set this pointer back to null as it will be passed up.
        if (dwErr != ERROR_SUCCESS)
            pIntfContext = NULL;
    }

    // either for arrival or removal, we attempt to remove any identical context
    // If it is about an arrival, we shouldn't have any duplicate but who knows
    if ((dwNotifCode == WZCNOTIF_DEVICE_REMOVAL || dwNotifCode == WZCNOTIF_ADAPTER_UNBIND) &&
        pIntfContext != NULL)
    {
        // increase its ref count and lock it up here
        LstRccsReference(pIntfContext);
        LstRccsLock(pIntfContext);

        DbLogWzcInfo(WZCSVC_EVENT_REMOVE, pIntfContext, 
                     pIntfContext->wszDescr);

        // save the interface's settings to the registry
        dwErr = StoSaveIntfConfig(NULL, pIntfContext);
        DbgAssert((dwErr == ERROR_SUCCESS,
                   "StoSaveIntfConfig failed for Intf context 0x%p",
                   pIntfContext));

        // prepare this context for destruction
        LstRemoveIntfContext(pIntfContext);

        // at this point, there are no other timer routines that are going to be fired. Whatever
        // has been already fired ++ed the reference counter already so there is no risk to delete
        // the data prematurely (when unref-ing this context). Also the timer has been deleted, but
        // before doing so the timer handle has been set to INVALID_HANDLE_VALUE so there is no risk
        // some other thread is trying to set a deleted timer (besides, we're still holding the 
        // context's critical section hence there can be no such other thread competing here).

        // release the context here
        LstRccsUnlockUnref(pIntfContext);

        // since the resulting IntfContext is passed back to the caller,
        // make the local pointer NULL (it will be returned later in the out param)
        pIntfContext = NULL;
    }

    // for media connect & disconnect..
    if (dwNotifCode == WZCNOTIF_MEDIA_CONNECT || dwNotifCode == WZCNOTIF_MEDIA_DISCONNECT)
    {
        // NOTE: keep in mind, pIntfContext is valid because we're in the critical section
        // for the hashes.
        // 
        // if there is a context under Zero Conf control, dispatch the event to the 
        // state machine
        if (pIntfContext != NULL)
        {
            // first lock the context since the state machine deals only with locked contexts
            LstRccsReference(pIntfContext);
            LstRccsLock(pIntfContext);

            dwErr = StateDispatchEvent(
                        dwNotifCode == WZCNOTIF_MEDIA_CONNECT ? eEventConnect : eEventDisconnect,
                        pIntfContext,
                        NULL);

            LstRccsUnlockUnref(pIntfContext);
        }
        else
        {
            dwErr = ERROR_FILE_NOT_FOUND;
        }
    }

exit:
    *ppIntfContext = pIntfContext;
    DbgPrint((TRC_TRACK,"LstNotificationHandler]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Application Command call.
// [in]  dwHandle: key for identifying the context (state) to which this cmd is referring
// [in]  dwCmdCode: Command code (one of the WZCCMD_* contants)
// [in]  wszIntfGuid: the guid of the interface to which this cmd is addressed
// [in]  prdUserData: Application data associated to this command
DWORD
LstCmdInterface(
    DWORD           dwHandle,
    DWORD           dwCmdCode,
    LPWSTR          wszIntfGuid,
    PRAW_DATA       prdUserData)
{
    DWORD           dwErr = ERROR_FILE_NOT_FOUND;
    PHASH_NODE      pNode = NULL;
    PINTF_CONTEXT   pIntfContext;

    DbgPrint((TRC_TRACK, "[LstCmdInterface(hdl=0x%x, cmd=0x%x,...)", dwHandle, dwCmdCode));

    if (g_lstIntfHashes.bValid)
    {
        EnterCriticalSection(&g_lstIntfHashes.csMutex);
        dwErr = HshQueryObjectRef(
                    g_lstIntfHashes.pHnGUID,
                    wszIntfGuid,
                    &pNode);
        if (dwErr == ERROR_SUCCESS)
        {
            pIntfContext = pNode->pObject;
            // bump up the reference counter since we're going
            // to work with this object
            LstRccsReference(pIntfContext);
        }
        LeaveCriticalSection(&g_lstIntfHashes.csMutex);
    }
    else
        dwErr = ERROR_ARENA_TRASHED;

    // a failure at this point, means there was no context
    // to lock so we can safely go to 'exit'
    if (dwErr != ERROR_SUCCESS)
        goto exit;

    // Lock the context now
    LstRccsLock(pIntfContext);
    
    // don't do any processing if the handle passed down with the
    // command doesn't match the session handle (meaning the command
    // refers to the right iteration loop).
    if (dwCmdCode == WZCCMD_HARD_RESET ||
        dwHandle == pIntfContext->dwSessionHandle)
    {
        ESTATE_EVENT        StateEvent;
        BOOL                bIgnore = FALSE;    // tells whether the state machine needs to be kicked
                                                // for this command.
        BOOL                bCopy = TRUE;       // tells whether the user data needs to be copied
                                                // in the successful config context.
        DWORD               dwRefreshOIDs = 0;
        LPVOID              pEventData = NULL;
        PWZC_WLAN_CONFIG    pSConfig = NULL;

        // translate the command code to the internal event
        switch (dwCmdCode)
        {
        case WZCCMD_HARD_RESET:
            bCopy = FALSE; // no need to copy anything on hard reset!
            StateEvent = eEventCmdReset;
            break;
        case WZCCMD_SOFT_RESET:
            StateEvent = eEventCmdRefresh;
            dwRefreshOIDs = INTF_LIST_SCAN;
            pEventData = &dwRefreshOIDs;
            break;
        case WZCCMD_CFG_NEXT:
            StateEvent = eEventCmdCfgNext;
            break;
        case WZCCMD_CFG_DELETE:
            StateEvent = eEventCmdCfgDelete;
            break;
        case WZCCMD_CFG_NOOP:
            StateEvent = eEventCmdCfgNoop;
            break;
        case WZCCMD_CFG_SETDATA:
            bIgnore = TRUE;
            break;
        case WZCCMD_SKEY_QUERY:
            bIgnore = TRUE; bCopy = FALSE;
            dwErr = ERROR_SUCCESS;
            if (prdUserData == NULL)
            {
                dwErr = ERROR_INVALID_PARAMETER;
            }
            else
            {
                if (pIntfContext->pSecSessionKeys == NULL)
                {
                    prdUserData->dwDataLen = 0;
                }
                else if (prdUserData->dwDataLen < sizeof(SESSION_KEYS))
                {
                    prdUserData->dwDataLen = sizeof(SESSION_KEYS);
                    dwErr = ERROR_MORE_DATA;
                }
                else
                {
                    PSESSION_KEYS pSK = (PSESSION_KEYS) prdUserData->pData;
                    dwErr = WzcSSKDecrypt(pIntfContext->pSecSessionKeys, pSK);
                }
            }
            break;
        case WZCCMD_SKEY_SET:
            bIgnore = TRUE; bCopy = FALSE;
            dwErr = ERROR_SUCCESS;
            if (prdUserData == NULL)
            {
                WzcSSKFree(pIntfContext->pSecSessionKeys);
                pIntfContext->pSecSessionKeys = NULL;
            }
            else if (prdUserData->dwDataLen != sizeof(SESSION_KEYS))
            {
                dwErr = ERROR_INVALID_PARAMETER;
            }
            else
            {
                if (pIntfContext->pSecSessionKeys == NULL)
                {
                    pIntfContext->pSecSessionKeys = MemCAlloc(sizeof(SEC_SESSION_KEYS));
                    if (pIntfContext->pSecSessionKeys == NULL)
                        dwErr = GetLastError();
                }

                if (dwErr == ERROR_SUCCESS)
                {
                    PSESSION_KEYS pSK = (PSESSION_KEYS) prdUserData->pData;
                    WzcSSKClean(pIntfContext->pSecSessionKeys);
                    dwErr = WzcSSKEncrypt(pIntfContext->pSecSessionKeys, pSK);
                }
            }
            break;
        default:
            // just in case we were just asked to set the BLOB (and we did this already)
            // or some bogus code came in, no event will be dispatched to the state machine
            bIgnore = TRUE;
            break;
        }

        // copy down the user data to the config currently selected
        if (bCopy && pIntfContext->pwzcSList != NULL &&
            pIntfContext->pwzcSList->Index < pIntfContext->pwzcSList->NumberOfItems)
        {
            pSConfig = &(pIntfContext->pwzcSList->Config[pIntfContext->pwzcSList->Index]);

            // if whatever buffer we already have is not large enough, clean it out
            if (prdUserData == NULL || pSConfig->rdUserData.dwDataLen < prdUserData->dwDataLen)
            {
                MemFree(pSConfig->rdUserData.pData);
                pSConfig->rdUserData.pData = NULL;
                pSConfig->rdUserData.dwDataLen = 0;
            }

            // if a new buffer will be needed, allocate it here.
            if (prdUserData != NULL && prdUserData->dwDataLen > pSConfig->rdUserData.dwDataLen)
            {
                pSConfig->rdUserData.pData = MemCAlloc(prdUserData->dwDataLen);
                if (pSConfig->rdUserData.pData == NULL)
                {
                    dwErr = GetLastError();
                    goto exit;
                }
                pSConfig->rdUserData.dwDataLen = prdUserData->dwDataLen;
            }

            // if there is any user data to store, do it here
            if (prdUserData != NULL && prdUserData->dwDataLen > 0)
                memcpy(pSConfig->rdUserData.pData, prdUserData->pData, prdUserData->dwDataLen);
        }


        // if this command is not to be ignored, dispatch the 
        // corresponding state event to the state machine dispatcher.
        if (!bIgnore)
        {
            dwErr = StateDispatchEvent(
                        StateEvent,
                        pIntfContext,
                        pEventData);

            // clear up the INTFCTL_INTERNAL_BLK_MEDIACONN bit since this is not a media sense handler
            pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_BLK_MEDIACONN;
        }
    }

    // Unlock the context now
    LstRccsUnlockUnref(pIntfContext);

exit:
    DbgPrint((TRC_TRACK, "LstCmdInterface]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Network Connection's status query
// [in]  wszIntfGuid: the guid of the interface to which this cmd is addressed
// [out]  pncs: network connection status, if controlled by WZC.
HRESULT
LstQueryGUIDNCStatus(
    LPWSTR  wszIntfGuid,
    NETCON_STATUS  *pncs)
{
    DWORD           dwErr = ERROR_FILE_NOT_FOUND;
    HRESULT         hr = S_FALSE;
    PHASH_NODE      pNode = NULL;
    PINTF_CONTEXT   pIntfContext;

    DbgPrint((TRC_TRACK, "[LstQueryGUIDNCStatus(%S)", wszIntfGuid));

    if (g_lstIntfHashes.bValid)
    {
        EnterCriticalSection(&g_lstIntfHashes.csMutex);
        dwErr = HshQueryObjectRef(
                    g_lstIntfHashes.pHnGUID,
                    wszIntfGuid,
                    &pNode);
        if (dwErr == ERROR_SUCCESS)
        {
            pIntfContext = pNode->pObject;
            // bump up the reference counter since we're going
            // to work with this object
            LstRccsReference(pIntfContext);
        }
        LeaveCriticalSection(&g_lstIntfHashes.csMutex);
    }
    else
        dwErr = ERROR_ARENA_TRASHED;

    // a failure at this point, means there was no context
    // to lock so we can safely go to 'exit'
    if (dwErr != ERROR_SUCCESS)
        goto exit;

    // Lock the context now
    LstRccsLock(pIntfContext);
    
    // we control the state only if WZC is enabled and the adapter is
    // anything else but connected. Otherwise the upper layer protocols
    // are in control.
    //
    // For now (WinXP client RTM), Zero Config should report to NETMAN only the
    // disconnected state. This is to fix bug #401130 which is NETSHELL displaying
    // the bogus SSID from the {SF} state, while the IP address is lost and until
    // the media disconnect is received (10 seconds later).
    if (pIntfContext->dwCtlFlags & INTFCTL_ENABLED &&
        pIntfContext->dwCtlFlags & INTFCTL_OIDSSUPP &&
        pIntfContext->ncStatus != NCS_CONNECTED)
    {
        *pncs = NCS_MEDIA_DISCONNECTED;
        hr = S_OK;
    }

    // Unlock the context now
    LstRccsUnlockUnref(pIntfContext);

exit:
    DbgPrint((TRC_TRACK, "LstQueryGUIDNCStatus]=%d", dwErr));
    return hr;
}

//-----------------------------------------------------------
// Generate the initial dynamic session keys.
// [in]  pIntfContext: Interface context containing the material for initial key generation.
DWORD
LstGenInitialSessionKeys(
    PINTF_CONTEXT pIntfContext)
{
    DWORD                   dwErr = ERROR_SUCCESS;
    PWZC_WLAN_CONFIG        pSConfig = NULL;
    NDIS_802_11_MAC_ADDRESS ndMAC[2] = {0};
    SESSION_KEYS            SessionKeys;
    UCHAR                   KeyMaterial[WZCCTL_MAX_WEPK_MATERIAL];

    if (pIntfContext->pwzcSList != NULL &&
        pIntfContext->pwzcSList->Index < pIntfContext->pwzcSList->NumberOfItems)
    {
        pSConfig = &(pIntfContext->pwzcSList->Config[pIntfContext->pwzcSList->Index]);
    }

    if (pSConfig != NULL && pSConfig->dwCtlFlags & WZCCTL_WEPK_PRESENT)
    {
        // get the random info needed for the key generation (RemoteMAC | LocalMAC ).
        pSConfig = &(pIntfContext->pwzcSList->Config[pIntfContext->pwzcSList->Index]);
        memcpy(&ndMAC[0], &pSConfig->MacAddress, sizeof(NDIS_802_11_MAC_ADDRESS));
        memcpy(&ndMAC[1], &pIntfContext->ndLocalMac, sizeof(NDIS_802_11_MAC_ADDRESS));

        // generate dynamic keys starting from unscrambled WEP
        {
            UINT i;
            for (i = 0; i < WZCCTL_MAX_WEPK_MATERIAL; i++)
                KeyMaterial[i] = pSConfig->KeyMaterial[i] ^ g_chFakeKeyMaterial[(7*i)%13];
        }

        dwErr = GenerateDynamicKeys(
                    KeyMaterial,
                    pSConfig->KeyLength,
                    (LPBYTE)&ndMAC[0],
                    sizeof(ndMAC),
                    pSConfig->KeyLength,
                    &SessionKeys);

        if (dwErr == ERROR_SUCCESS)
        {
            WzcSSKFree(pIntfContext->pSecSessionKeys);
            pIntfContext->pSecSessionKeys = MemCAlloc(sizeof(SEC_SESSION_KEYS));
            if (pIntfContext->pSecSessionKeys == NULL)
            {
                dwErr = GetLastError();
            }
            else
            {
                dwErr = WzcSSKEncrypt(pIntfContext->pSecSessionKeys, &SessionKeys);
            }
        }
    }

    return dwErr;
}

//-----------------------------------------------------------
// Updates the list of blocked configurations with the selected configurations
// that were blocked at this round by the upper layer (marked with WZCCTL_INTERNAL_BLOCKED
// in the list of selected configurations)
// [in]  pIntfContext: Interface context containing the configurations lists
DWORD
LstUpdateBlockedList(
    PINTF_CONTEXT pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT i, nBlocked = 0;
    PWZC_802_11_CONFIG_LIST pNewBList = NULL;
    PWZC_WLAN_CONFIG pConfig;
    BOOL bChanged = FALSE;

    DbgPrint((TRC_TRACK, "[LstUpdateBlockedList(0x%p)", pIntfContext));

    // the first thing is to count how many blocked configurations we have
    // check first the current blocked list for blocked configs still "alive"
    if (pIntfContext->pwzcBList != NULL)
    {
        for (i=0; i < pIntfContext->pwzcBList->NumberOfItems; i++)
        {
            if (pIntfContext->pwzcBList->Config[i].Reserved[0] > 0)
                nBlocked++;
            else
                bChanged = TRUE; // this entry is going to be removed!
        }
    }

    // check now how many configs are going to be blocked from the current selection list
    // NOTE: the entries from the SList are guaranteed not to duplicate entries in the BList
    // If an entry is in the BList it means it was excluded from being added to the SList
    // when the SList was created.
    if (pIntfContext->pwzcSList != NULL)
    {
        for (i=0; i < pIntfContext->pwzcSList->NumberOfItems; i++)
        {
            if (pIntfContext->pwzcSList->Config[i].dwCtlFlags & WZCCTL_INTERNAL_BLOCKED)
            {
                nBlocked++;
                bChanged = TRUE; // a new entry becomes blocked
            }
        }
    }

    // if we found there are no blocked entries, nor in the original list not in the current
    // (failed) selection list, just go out successfully - it means the original pwzcBList
    // is already NULL and it should remain this way
    if (nBlocked == 0)
        goto exit;

    pNewBList = (PWZC_802_11_CONFIG_LIST)
                MemCAlloc(FIELD_OFFSET(WZC_802_11_CONFIG_LIST, Config) + nBlocked * sizeof(WZC_WLAN_CONFIG));

    // on memory allocation error, get out with the error code
    if (pNewBList == NULL)
    {
        dwErr = GetLastError();
        goto exit;
    }

    // if originally there were some alive blocked entries, copy them over to the new list
    if (pIntfContext->pwzcBList != NULL)
    {
        for (i=0; i < pIntfContext->pwzcBList->NumberOfItems && nBlocked > 0; i++)
        {
            pConfig = &(pIntfContext->pwzcBList->Config[i]);

            if (pConfig->Reserved[0] > 0)
            {
                memcpy(&(pNewBList->Config[pNewBList->NumberOfItems]), 
                       pConfig, 
                       sizeof(WZC_WLAN_CONFIG));
                // make sure the copy doesn't include any "user" data:
                pConfig->rdUserData.pData = NULL;
                pConfig->rdUserData.dwDataLen = 0;
                // don't touch anything from this blocked configuration. TTL goes down
                // by itself with each scan (if network is not available)
                pNewBList->NumberOfItems++;
                // make sure we are breaking the loop if we have no storage for any potential
                // blocked configuration. This shouldn't happen since we were counting these first
                // and the whole context is locked, but ... it doesn't hurt
                nBlocked--;
            }
        }
    }

    // now copy over the new blocked entries, if any
    if (pIntfContext->pwzcSList != NULL)
    {
        for (i=0; i < pIntfContext->pwzcSList->NumberOfItems && nBlocked > 0; i++)
        {
            pConfig = &(pIntfContext->pwzcSList->Config[i]);

            if (pConfig->dwCtlFlags & WZCCTL_INTERNAL_BLOCKED)
            {
                memcpy(&(pNewBList->Config[pNewBList->NumberOfItems]), 
                       pConfig, 
                       sizeof(WZC_WLAN_CONFIG));
                // make sure the copy doesn't include any "user" data:
                pConfig->rdUserData.pData = NULL;
                pConfig->rdUserData.dwDataLen = 0;
                // make sure to set the initial TTL for the new blocked configuration
                pNewBList->Config[pNewBList->NumberOfItems].Reserved[0] = WZC_INTERNAL_BLOCKED_TTL;
                pNewBList->NumberOfItems++;
                // make sure we are breaking the loop if we have no storage for any potential
                // blocked configuration. This shouldn't happen since we were counting these first
                // and the whole context is locked, but ... it doesn't hurt
                nBlocked--;
            }
        }
    }

    // everything is ok - nothing can fail further, so make pNewBList the official pBList
    WzcCleanupWzcList(pIntfContext->pwzcBList);
    pIntfContext->pwzcBList = pNewBList;

    if (bChanged)
    {
        DbLogWzcInfo(WZCSVC_BLIST_CHANGED, 
                     pIntfContext, 
                     pIntfContext->pwzcBList != NULL ? pIntfContext->pwzcBList->NumberOfItems : 0);
    }

exit:
    DbgPrint((TRC_TRACK, "LstUpdateBlockedList]=%d", dwErr));

    return dwErr;
}

//-----------------------------------------------------------
// Checks each of the entries in the locked list against the visible list. If the
// entry is visible, its TTL is reset. If it is not, its TTL is decremented. If the
// TTL becomes 0, the entry is taken out of the list.
// [in]  pIntfContext: Interface context containing the configurations lists
DWORD
LstDeprecateBlockedList(
    PINTF_CONTEXT pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT i;
    PWZC_WLAN_CONFIG pConfig, pVConfig;
    BOOL bChanged = FALSE;

    DbgPrint((TRC_TRACK, "[LstDeprecateBlockedList(0x%p)", pIntfContext));

    // nothing to do if there is no list of blocked entries
    if (pIntfContext->pwzcBList == NULL)
        goto exit;

    for (i=0; i < pIntfContext->pwzcBList->NumberOfItems; i++)
    {
        pConfig = &(pIntfContext->pwzcBList->Config[i]);

        // if the blocked entry appears to be visible, reset its TTL
        if (WzcFindConfig(pIntfContext->pwzcVList, pConfig, 0) != NULL)
            pConfig->Reserved[0] = WZC_INTERNAL_BLOCKED_TTL;
        else // else decrement its TTL
            pConfig->Reserved[0]--;

        // if the TTL got to 0, the entry needs to be removed from the list
        // (exchange with the very last one and the list is made 1 entry shorted)
        if (pConfig->Reserved[0] == 0)
        {
            UINT nLastIdx = pIntfContext->pwzcBList->NumberOfItems - 1;
            // if this is not the very last entry, exchange it with the last one
            // but first clean it out since it will be unreachable for WzcCleanupWzcList()
            MemFree(pConfig->rdUserData.pData);

            if (i != nLastIdx)
            {
                memcpy(pConfig, &(pIntfContext->pwzcBList->Config[nLastIdx]), sizeof(WZC_WLAN_CONFIG));
            }
            // make the list one entry shorter since the removed entry is now at the end
            pIntfContext->pwzcBList->NumberOfItems--;
            // next time stay on the same index as at this iteration.
            i--;
            // now since this went away, note the change
            bChanged = TRUE;
        }
    }

    if (bChanged)
    {
        DbLogWzcInfo(WZCSVC_BLIST_CHANGED, 
                     pIntfContext, 
                     pIntfContext->pwzcBList->NumberOfItems);
    }

exit:
    DbgPrint((TRC_TRACK, "LstDeprecateBlockedList]=%d", dwErr));

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\rpcsrv.h ===
#pragma once

#define WZC_ACCESS_SET      0x00000001
#define WZC_ACCESS_QUERY    0x00000002
#define WZC_READ        (STANDARD_RIGHTS_READ    | WZC_ACCESS_QUERY)
#define WZC_WRITE       (STANDARD_RIGHTS_WRITE   | WZC_ACCESS_QUERY | WZC_ACCESS_SET)
#define WZC_EXECUTE     (STANDARD_RIGHTS_EXECUTE | WZC_ACCESS_QUERY)
#define WZC_ALL_ACCESS  (STANDARD_RIGHTS_REQUIRED| WZC_ACCESS_QUERY | WZC_ACCESS_SET)

DWORD
WZCSvcCheckConfig(PWZC_WLAN_CONFIG pwzcConfig, UINT nBytes);

DWORD
WZCSvcStartRPCServer();

DWORD
WZCSvcStopRPCServer();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\intflist.h ===
#pragma once
#include "utils.h"
#include "hash.h"
#include "state.h"
#include "wzccrypt.h"

// internal control flags - they mix with INTFCTL_* public flags, so
// the values need to be in the highest 2 bytes of the dword
//
// the public mask can contain as many as 16 bits (0xffff). Currently it masks
// - whether the service is enabled or not (INTFCTL_ENABLED)
// - what is the configuration mode (INTFCTL_CM_MASK): adhoc/infra/auto
// - whether should fallback to visible non preferred configs or not (INTFCTL_FALLBACK)
// the default value for the public mask is for now just the bits we care about
#define INTFCTL_PUBLIC_MASK             0x0000ffff
#define INTFCTL_INTERNAL_MASK           0xffff0000
#define INTFCTL_INTERNAL_TM_ON          0x00010000 // some timer is active for this context
#define INTFCTL_INTERNAL_FAKE_WKEY      0x00020000 // a fake wep key has been set for this context
#define INTFCTL_INTERNAL_FORCE_CFGREM   0x00040000 // force the removal of the selected config (bypass media state check)
#define INTFCTL_INTERNAL_NO_DELAY       0x00080000 // a delayed execution of {SSr} is forbidden
#define INTFCTL_INTERNAL_SIGNAL         0x00100000 // signal (UI) next time when entering the {SF} state
#define INTFCTL_INTERNAL_BLK_MEDIACONN  0x00200000 // Block passing through for Media connects
#define INTFCTL_INTERNAL_ONE_TIME       0x00400000 // the current config is a "one time configuration"
#define INTFCTL_INTERNAL_INITFAILNOTIF  0x00800000 // the initial failure stack notification has been sent down already!

// the public mask for a WZC configuration can contain as many as 16 bits (0xffff). Currently it masks
// - whether a WEP key is provided (enabled) for this configuration WZCCTL_WEPK_PRESENT
// - the format in which the key has been entered WZCCTL_WEPK_XFORMAT
#define WZCCTL_INTERNAL_MASK            0xffff0000
#define WZCCTL_INTERNAL_DELETED         0x00010000 // this configuration has been tried and failed
#define WZCCTL_INTERNAL_FORCE_CONNECT   0x00020000 // this is adhoc config and failed. Keep it for a second forced plumbing
#define WZCCTL_INTERNAL_BLOCKED         0x00040000 // this configuration was failed by the upper layer. Block it for the future.
#define WZCCTL_INTERNAL_SHADOW          0x00080000 // this is a user-configuration shadowing a policy (read-only) configuration.

// Time To Live for a blocked configuration in the pwzcBList. This TTL gets decremented
// each time a "scan" shows the configuration being not visible. Generally if three successive
// scans (at 1min) do not show the blocked config, we can safely assume the network is not
// available hence next time we'll get into its area we are going to retry it, hence there is
// no need to block it anymore.
#define WZC_INTERNAL_BLOCKED_TTL        3

//-----------------------------------------------------------
// Type definitions
typedef enum
{
    eVPI=0,	// visible, preferred infrastructure index
    eVI,	// visible, non-preferred infrastructure index
    ePI,	// non-visible, preferred infrastructure index
    eVPA,	// visible, preferred adhoc index
    eVA,	// visible, non-preferred adhoc index
    ePA,	// non-visible, preferred adhoc index
    eN		// invalid index
} ENUM_SELCATEG;

typedef struct _INTF_CONTEXT
{
    // link for the linear hash
    LIST_ENTRY          Link;
    // used for synchronizing the access to this structure
    RCCS_SYNC           rccs;
    // control flags for this interface (see INTFCTL* constants)
    DWORD               dwCtlFlags;
    // state handler for this interface context current state
    PFN_STATE_HANDLER   pfnStateHandler;
    // NETman CONnection Status
    NETCON_STATUS       ncStatus;
    // timer handle
    HANDLE              hTimer;

    // ndis index of the interface
    DWORD       dwIndex;
    // ndis "{guid}"
    LPWSTR      wszGuid;
    // ndis interface description
    LPWSTR      wszDescr;
    // local MAC address
    NDIS_802_11_MAC_ADDRESS ndLocalMac;
    // ndis media state
    ULONG       ulMediaState;
    // ndis media type
    ULONG       ulMediaType;
    // ndis physical media type
    ULONG       ulPhysicalMediaType;
    // ndis opened handle to the interface
    HANDLE      hIntf;

    // Current OID settings on the interface
    WZC_WLAN_CONFIG     wzcCurrent;

    // list of visible configurations
    PWZC_802_11_CONFIG_LIST             pwzcVList;
    // list of preferred configurations
    PWZC_802_11_CONFIG_LIST             pwzcPList;
    // list of selected configurations
    PWZC_802_11_CONFIG_LIST             pwzcSList;
    // list of configurations blocked from the upper layers
    PWZC_802_11_CONFIG_LIST             pwzcBList;

    // dynamic session keys to be used in pre-shared re-keying scenario
    PSEC_SESSION_KEYS       pSecSessionKeys;

    // session handler to be passed up on notification and checked down when
    // processing commands. In order to accept a command, the session handler
    // passed down with the command should match the session handler from the
    // context to which the command is addressed.
    DWORD   dwSessionHandle;

} INTF_CONTEXT, *PINTF_CONTEXT;

typedef struct _INTF_HASHES
{
    BOOL                bValid;     // tells whether the object has been initialized or not
    CRITICAL_SECTION    csMutex;    // Critical section protecting all hashes together
    PHASH_NODE          pHnGUID;    // pointer to the root Hash node for Intf GUIDs
    LIST_ENTRY          lstIntfs;   // linear list of all interfaces
    UINT                nNumIntfs;  // number of interfaces accross all hashes
} INTF_HASHES, *PINTF_HASHES;

extern HASH         g_hshHandles;    // HASH handing GUID<->Handle mapping
extern INTF_HASHES  g_lstIntfHashes; // set of hashes for all INTF_CONTEXTs
extern HANDLE       g_htmQueue;      // global timer queue

//-----------------------------------------------------------
// Synchronization routines
DWORD
LstRccsReference(PINTF_CONTEXT pIntf);
DWORD
LstRccsLock(PINTF_CONTEXT pIntf);
DWORD
LstRccsUnlockUnref(PINTF_CONTEXT);

//-----------------------------------------------------------
// Intilializes all the internal interfaces hashes
DWORD
LstInitIntfHashes();

//-----------------------------------------------------------
// Destructs all the internal data structures - hash & lists
DWORD
LstDestroyIntfHashes();

//-----------------------------------------------------------
// Intializes the global timer queue
DWORD
LstInitTimerQueue();

//-----------------------------------------------------------
// Destructs the global timer queue
DWORD
LstDestroyTimerQueue();

//-----------------------------------------------------------
// Intilializes all the internal data structures. Reads the list of interfaces from
// Ndisuio and gets all the parameters & OIDS.
DWORD
LstLoadInterfaces();

//-----------------------------------------------------------
// Constructor for the INTF_CONTEXT. Takes as parameter the binding information.
// Interface's GUID constitutes the context's key info.
// This call doesn't insert the new context in any hash or list
DWORD
LstConstructIntfContext(
    PNDISUIO_QUERY_BINDING  pBinding,
    PINTF_CONTEXT           *ppIntfContext);

//-----------------------------------------------------------
// Prepares a context for the destruction:
// - Deletes any attached timer, making sure no other timer routines will be fired.
// - Removes the context from any hash, making sure no one else will find the context
// - Decrements the reference counter such that the context will be destroyed when unrefed.
DWORD
LstRemoveIntfContext(
    PINTF_CONTEXT pIntfContext);

//-----------------------------------------------------------
// Finally destructs the INTF_CONTEXT clearing all the resources allocated for it
// This call doesn't remove this context from any hash or list
DWORD
LstDestroyIntfContext(
    PINTF_CONTEXT pIntfContext);

//-----------------------------------------------------------
// Returns the number of contexts enlisted in the service
DWORD
LstNumInterfaces();

//-----------------------------------------------------------
// Inserts the given context in all the internal hashes
DWORD
LstAddIntfToHashes(PINTF_CONTEXT pIntf);

//-----------------------------------------------------------
// Removes the context referenced by GUID from all the internal hashes.
// The GUID is expected to be in the format "{guid}"
// Returns in ppIntfContext the object that was removed from all hashes.
DWORD
LstRemIntfFromHashes(LPWSTR wszGuid, PINTF_CONTEXT *ppIntfContext);

//-----------------------------------------------------------
// Returns an array of *pdwNumIntfs INTF_KEY_ENTRY elements.
// The INTF_KEY_ENTRY contains whatever information identifies
// uniquely an adapter. Currently it includes just the GUID in
// the format "{guid}"
DWORD
LstGetIntfsKeyInfo(
    PINTF_KEY_ENTRY pIntfs,
    LPDWORD         pdwNumIntfs);

//-----------------------------------------------------------
// Returns requested information on the specified adapter.
// [in] dwInFlags specifies the information requested. (see
//      bitmasks INTF_*)
// [in] pIntfEntry should contain the GUID of the adapter
// [out] pIntfEntry contains all the requested information that
//      could be successfully retrieved.
// [out] pdwOutFlags provides an indication on the info that
//       was successfully retrieved
DWORD
LstQueryInterface(
    DWORD       dwInFlags,
    PINTF_ENTRY pIntfEntry,
    LPDWORD     pdwOutFlags);

//-----------------------------------------------------------
// Sets the specified parameters on the specified adapter.
// [in] dwInFlags specifies the parameters to be set. (see
//      bitmasks INTF_*)
// [in] pIntfEntry should contain the GUID of the adapter and
//      all the additional parameters to be set as specified
//      in dwInFlags
// [out] pdwOutFlags provides an indication on the params that
//       were successfully set to the adapter
// Each parameter for which the driver says that was set successfully
// is copied into the interface's context.
DWORD
LstSetInterface(
    DWORD       dwInFlags,
    PINTF_ENTRY pIntfEntry,
    LPDWORD     pdwOutFlags);

//-----------------------------------------------------------
// Checks whether interface changes should cause the interface to be 
// reinserted in the state machine and it does so if needed.
// [in] dwChangedFlags indicates what the changes are. (see
//      bitmasks INTF_*)
// [in] pIntfContext context of the interface being changed.
DWORD
LstActOnChanges(
    DWORD       dwChangedFlags,
    PINTF_CONTEXT pIntfContext);

//-----------------------------------------------------------
// Applies settings from the template context to the given interface context
// [in]  pIntfTemplate: Interface template to pick settings from
// [in]  pIntfContext: Interface context to apply template to.
// [out] pbAltered: Tells whether the local interface context has been altered by the template
DWORD
LstApplyTemplate(
    PINTF_CONTEXT   pIntfTemplate,
    PINTF_CONTEXT   pIntfContext,
    LPBOOL          pbAltered);

//-----------------------------------------------------------
// Refreshes the specified parameters on the specified adapter.
// [in] dwInFlags specifies the parameters to be set. (see
//      bitmasks INTF_* and INTF_RFSH_*)
// [in] pIntfEntry should contain the GUID of the adapter 
// [out] pdwOutFlags provides an indication on the params that
//       were successfully refreshed to the adapter
// Each parameter for which the driver says that was refreshed 
// successfully is copied into the interface's context.
DWORD
LstRefreshInterface(
    DWORD       dwInFlags,
    PINTF_ENTRY pIntfEntry,
    LPDWORD     pdwOutFlags);

//-----------------------------------------------------------
// Builds the list of configurations to be tried from the list of visible
// configurations, the list of preferred configurations and based on the
// interface's mode (Auto/Infra/Adhoc) and flags (is the service enabled?,
// fallback to visible?). 
// [in]  pIntfContext: Interface for which is done the selection
// [out] ppwzcSList: pointer to the list of selected configurations
DWORD
LstBuildSelectList(
    PINTF_CONTEXT           pIntfContext,
    PWZC_802_11_CONFIG_LIST *ppwzcSList);

//-----------------------------------------------------------
// Checks whether the list of selected configurations has changed such
// that it is required to replumb the selection.
// [in]  pIntfContext: Interface for which is done the selection
// [in]  pwzcNSList: new selection list to check the configuration against
// [out] pnSelIdx: if selection changed, provides the index where to start iterate from
// Returns: TRUE if replumbing is required. In this case, pnSelIdx is
// set to the configuration to start iterate from.
BOOL
LstChangedSelectList(
    PINTF_CONTEXT           pIntfContext,
    PWZC_802_11_CONFIG_LIST pwzcNSList,
    LPUINT                  pnSelIdx);

//-----------------------------------------------------------
// Plumbs the interface with the selected configuration as it is pointed
// out by pwzcSList fields in the pIntfContext. Optional,
// it can return in ppSelSSID the configuration that was plumbed down
// [in]  pIntfContext: Interface context identifying ctl flags & the selected SSID
// [out] ppndSelSSID: pointer to the SSID that is being plumbed down.
DWORD
LstSetSelectedConfig(
    PINTF_CONTEXT       pIntfContext, 
    PWZC_WLAN_CONFIG    *ppndSelSSID);

//-----------------------------------------------------------
// PnP notification handler
// [in/out]  ppIntfContext: Pointer to the Interface context for which
//       the notification was received
// [in]  dwNotifCode: Notification code (WZCNOTIF_*)
// [in]  wszDeviceKey: Key info on the device for which the notification
//       was received
DWORD
LstNotificationHandler(
    PINTF_CONTEXT   *ppIntfContext,
    DWORD           dwNotifCode,
    LPWSTR          wszDeviceKey);

//-----------------------------------------------------------
// Application Command call.
// [in]  dwHandle: key for identifying the context (state) to which this cmd is referring
// [in]  dwCmdCode: Command code (one of the WZCCMD_* contants)
// [in]  wszIntfGuid: the guid of the interface to which this cmd is addressed
// [in]  prdUserData: Application data associated to this command
DWORD
LstCmdInterface(
    DWORD           dwHandle,
    DWORD           dwCmdCode,
    LPWSTR          wszIntfGuid,
    PRAW_DATA       prdUserData);

//-----------------------------------------------------------
// Network Connection's status query
// [in]  wszIntfGuid: the guid of the interface to which this cmd is addressed
// [out]  pncs: network connection status, if controlled by WZC.
HRESULT
LstQueryGUIDNCStatus(
    LPWSTR  wszIntfGuid,
    NETCON_STATUS  *pncs);

//-----------------------------------------------------------
// Generate the initial dynamic session keys.
// [in]  pIntfContext: Interface context containing the material for initial key generation.
DWORD
LstGenInitialSessionKeys(
    PINTF_CONTEXT pIntfContext);

//-----------------------------------------------------------
// Updates the list of blocked configurations with the selected configurations
// that were blocked at this round by the upper layer (marked with WZCCTL_INTERNAL_BLOCKED
// in the list of selected configurations)
// [in]  pIntfContext: Interface context containing the configurations lists
DWORD
LstUpdateBlockedList(
    PINTF_CONTEXT pIntfContext);

//-----------------------------------------------------------
// Checks each of the entries in the locked list against the visible list. If the
// entry is visible, its TTL is reset. If it is not, its TTL is decremented. If the
// TTL becomes 0, the entry is taken out of the list.
// [in]  pIntfContext: Interface context containing the configurations lists
DWORD
LstDeprecateBlockedList(
    PINTF_CONTEXT pIntfContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\state.c ===
#include <precomp.h>
#include "wzcsvc.h"
#include "intflist.h"
#include "utils.h"
#include "deviceio.h"
#include "storage.h"
#include "state.h"
#include "notify.h"
#include "dialog.h"
#include "zcdblog.h"
#include "tracing.h"

//-----------------------------------------------------------
// StateTmSetOneTimeTimer: Sets a one time timer for the given context with the 
// hardcoded callback WZCTimeoutCallback() and with the parameter the interface
// context itself.
// Parameters:
// [in/out] pIntfContext: identifies the context for which is set the timer.
// [in]     dwMSeconds: miliseconds interval when the timer is due to fire
DWORD
StateTmSetOneTimeTimer(
    PINTF_CONTEXT   pIntfContext,
    DWORD           dwMSeconds)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (pIntfContext->hTimer == INVALID_HANDLE_VALUE)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else if (ChangeTimerQueueTimer(
                g_htmQueue,
                pIntfContext->hTimer,
                dwMSeconds,
                TMMS_INFINITE))
    {
        if (dwMSeconds == TMMS_INFINITE)
            pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_TM_ON;
        else
            pIntfContext->dwCtlFlags |= INTFCTL_INTERNAL_TM_ON;
    }
    else
    {
        DbgPrint((TRC_SYNC, "Failed setting the context 0x%p timer to %dms", pIntfContext, dwMSeconds));
        dwErr = GetLastError();
    }

    return dwErr;
}

//-----------------------------------------------------------
// StateDispatchEvent: processes an event that will cause the state machine to transition
// through one or more states.
// Parameters:
// [in] StateEvent: identifies the event that triggers the transition(s)
// [in] pIntfContext: points to the interface that is subject for the transition(s)
// [in] pvEventData: any data related to the event
// NOTE: The caller of this function should already take care of locking the pIntfContext
// in its critical section. The assumption is the Interface Context is already locked.
DWORD
StateDispatchEvent(
    ESTATE_EVENT    StateEvent,
    PINTF_CONTEXT   pIntfContext,
    PVOID           pvEventData)
{
    DWORD dwErr = ERROR_SUCCESS;
    
    DbgPrint((TRC_TRACK|TRC_STATE,"[StateDispatchEvent(%d,0x%p,0x%p)", StateEvent, pIntfContext, pvEventData));
    DbgAssert((pIntfContext != NULL, "Can't dispatch event for NULL context!"));

    // determine the state to transition to, based on the event that is to be dispatched
    // whatever the current state is, if the event is eEventAdd, move the context to SI
    switch(StateEvent)
    {
    case eEventAdd:
    	//Record Event into logging DB
    	DbLogWzcInfo(WZCSVC_EVENT_ADD, pIntfContext, 
                     pIntfContext->wszDescr);
        // on interface addition, no matter what, go straight to {SI}
        pIntfContext->pfnStateHandler = StateInitFn;
        dwErr = ERROR_CONTINUE;
        break;
    case eEventTimeout:
        // if timeout in {SSr}, transition to {SQ}
        if (pIntfContext->pfnStateHandler == StateSoftResetFn)
        {
            pIntfContext->pfnStateHandler = StateQueryFn;
            dwErr = ERROR_CONTINUE;
        }
        // if timeout in {SDSr}, transition back to {SSr}
        else if (pIntfContext->pfnStateHandler == StateDelaySoftResetFn)
        {
            pIntfContext->pfnStateHandler = StateSoftResetFn;
            dwErr = ERROR_CONTINUE;
        }
        // if timeout in {SF}, transition to {SHr}
        else if (pIntfContext->pfnStateHandler == StateFailedFn)
        {
            pIntfContext->pfnStateHandler = StateHardResetFn;
            dwErr = ERROR_CONTINUE;
        }
        // if timeout in {SIter}, transition to {SRs}
        else if (pIntfContext->pfnStateHandler == StateIterateFn)
        {
            pIntfContext->pfnStateHandler = StateCfgRemoveFn;
            dwErr = ERROR_CONTINUE;
        }
        // if timeout in {SC} or {SCk}, transition to {SSr}
        else if (pIntfContext->pfnStateHandler == StateConfiguredFn ||
                 pIntfContext->pfnStateHandler == StateCfgHardKeyFn)
        {
            pIntfContext->pfnStateHandler = StateSoftResetFn;
            dwErr = ERROR_CONTINUE;
        }
    	// Record Event into logging DB
      	DbLogWzcInfo(WZCSVC_EVENT_TIMEOUT, pIntfContext);
        break;
    case eEventConnect:
        // for each media connect notification, read the BSSID
        // Don't care if it fails (it might in certain cases)
        dwErr = DevioRefreshIntfOIDs(pIntfContext, INTF_BSSID, NULL);

    	// Record Event into logging DB - this should be the first log showing up
      	DbLogWzcInfo(WZCSVC_EVENT_CONNECT, pIntfContext);

        // if there was any error getting the BSSID, log the error here
        if (dwErr != ERROR_SUCCESS)
            DbLogWzcError(WZCSVC_ERR_QUERRY_BSSID, pIntfContext, dwErr);

        // if there is a chance the association is alredy successful
        // reset the session keys - if applicable
        if (dwErr == ERROR_SUCCESS &&
            (pIntfContext->pfnStateHandler == StateConfiguredFn ||
             pIntfContext->pfnStateHandler == StateCfgHardKeyFn ||
             pIntfContext->pfnStateHandler == StateSoftResetFn ||
             pIntfContext->pfnStateHandler == StateQueryFn
            )
           )
        {
            dwErr = LstGenInitialSessionKeys(pIntfContext);

            // if there was any error setting the initial session keys, log it here
            if (dwErr != ERROR_SUCCESS)
                DbLogWzcError(WZCSVC_ERR_GEN_SESSION_KEYS, pIntfContext, dwErr);
        }

        // reset the error id since nothing that happens so far
        // is critical enough to stop the state machine.
        dwErr = ERROR_SUCCESS;

        // if connect in {SIter}, transition to {SN}
        if (pIntfContext->pfnStateHandler == StateIterateFn)
        {
            pIntfContext->pfnStateHandler = StateNotifyFn;
            dwErr = ERROR_CONTINUE;
        }
        break;
    case eEventDisconnect:
    	//Record Event into logging DB
      	DbLogWzcInfo(WZCSVC_EVENT_DISCONNECT, pIntfContext);
        if (pIntfContext->pfnStateHandler == StateSoftResetFn ||
            pIntfContext->pfnStateHandler == StateConfiguredFn ||
            pIntfContext->pfnStateHandler == StateCfgHardKeyFn)
        {
            pIntfContext->pfnStateHandler = StateHardResetFn;
            dwErr = ERROR_CONTINUE;
        }
        break;
    case eEventCmdRefresh:
    	//Record Event into logging DB
      	DbLogWzcInfo(WZCSVC_EVENT_CMDREFRESH, pIntfContext);
        if (pvEventData == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            DWORD dwFlags = *(LPDWORD)pvEventData;

            // no matter the state this context is in, if it is not configured
            // successfully or during a scan cycle, it will be transitioned to {SHr}
            // (need to clear the  bvsList, otherwise it could mistakenly land in {SC}, on the
            // path {SSr}->{SQ}->{SC}.
            if (pIntfContext->pfnStateHandler != StateConfiguredFn &&
                pIntfContext->pfnStateHandler != StateCfgHardKeyFn &&
                pIntfContext->pfnStateHandler != StateSoftResetFn &&
                pIntfContext->pfnStateHandler != StateDelaySoftResetFn)
            {
                pIntfContext->pfnStateHandler = StateHardResetFn;
                dwErr = ERROR_CONTINUE;
            }
            // if the context is already configured, then we need to either go directly to
            // {SSr} if a scan is requested or just to {SQ} if no scan is needed. In the latter
            // case, the OIDs will be loaded, and because of the visible list which most probably
            // won't be changed (no new scanned happening in between) the context will be
            // transitioned instantly back to {SC}
            else if (pIntfContext->pfnStateHandler == StateConfiguredFn ||
                     pIntfContext->pfnStateHandler == StateCfgHardKeyFn)
            {
                // the refresh command caught the context in {SC} state
                // if a scan is requested, transition to {SSr} or
                pIntfContext->pfnStateHandler = (dwFlags & INTF_LIST_SCAN) ? StateSoftResetFn : StateQueryFn;
                dwErr = ERROR_CONTINUE;
            }
            // if the context is already in {SSr} or {SDSr} then a scan & full query will
            // happen in a matter of seconds. So just return SUCCESS to the call with no other
            // action to take.
        }
        break;
    case eEventCmdReset:
    	//Record Event into logging DB
      	DbLogWzcInfo(WZCSVC_EVENT_CMDRESET, pIntfContext);
        // When this happens, also clean up the blocked list. Any user configuration change should give
        // another chance to configurations previously blocked.
        WzcCleanupWzcList(pIntfContext->pwzcBList);
        pIntfContext->pwzcBList = NULL;
        // if reset is requested, no matter what, transition to {SHr}
        pIntfContext->pfnStateHandler = StateHardResetFn;
        dwErr = ERROR_CONTINUE;
        break;
    case eEventCmdCfgDelete:
    case eEventCmdCfgNext:
    	//Record Event into logging DB
      	DbLogWzcInfo((StateEvent == eEventCmdCfgDelete? WZCSVC_EVENT_CMDCFGDELETE : WZCSVC_EVENT_CMDCFGNEXT), pIntfContext);
        if (pIntfContext->pfnStateHandler == StateConfiguredFn ||
            pIntfContext->pfnStateHandler == StateCfgHardKeyFn ||
            pIntfContext->pfnStateHandler == StateSoftResetFn)
        {
            if (StateEvent == eEventCmdCfgDelete)
            {
                // mark in the control bits that this removal is forced
                pIntfContext->dwCtlFlags |= INTFCTL_INTERNAL_FORCE_CFGREM;
                pIntfContext->pfnStateHandler = StateCfgRemoveFn;
            }
            else
                pIntfContext->pfnStateHandler = StateCfgPreserveFn;

            dwErr = ERROR_CONTINUE;
        }
        break;
    case eEventCmdCfgNoop:
    	//Record Event into logging DB
      	DbLogWzcInfo(WZCSVC_EVENT_CMDCFGNOOP, pIntfContext);
        if (pIntfContext->pfnStateHandler == StateCfgHardKeyFn)
        {
            // mark in the control bits that this removal is forced
            pIntfContext->dwCtlFlags |= INTFCTL_INTERNAL_FORCE_CFGREM;
            pIntfContext->pfnStateHandler = StateCfgRemoveFn;
            dwErr = ERROR_CONTINUE;
        }
        break;
    }

    // if this event is not going to be ignored, dwErr is ERROR_CONTINUE at this point.
    // otherwise is ERROR_SUCCESS.
    // So, if this event is NOT going to be ignored, reset whatever timer
    // might have had for the related context. Keep in mind this call is already locking
    // the context so if the timer fired already, there is no sync problem
    if (dwErr == ERROR_CONTINUE)
    {
        TIMER_RESET(pIntfContext, dwErr);

        // restore the "continue" in case of success
        if (dwErr == ERROR_SUCCESS)
            dwErr = ERROR_CONTINUE;
    }

    // if the event is to be processed, dwErr is ERROR_CONTINUE.
    // In order to handle the automatic transitions, each State Handler function should set
    // the pfnStateHandler field to the state handler where the automatic transition goes and
    // also it should return ERROR_CONTINUE. Any other error code means the current
    // processing stops. Future transitions will be triggered by future event/timer timeout.
    while (dwErr == ERROR_CONTINUE)
    {
        dwErr = (*(pIntfContext->pfnStateHandler))(pIntfContext);
    }

    DbgPrint((TRC_TRACK|TRC_STATE,"StateDispatchEvent]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// StateInitFn: Handler for the Init State.
// This function runs in the context's critical section
DWORD
StateInitFn(PINTF_CONTEXT pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;
    
    DbgPrint((TRC_TRACK|TRC_STATE,"[StateInitFn(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL,"Invalid NULL context in {SI} state"));
    
    //Record current state into logging DB
    DbLogWzcInfo(WZCSVC_SM_STATE_INIT, pIntfContext, pIntfContext->wszDescr);
    // for this new interface, load its settings from the registry
    dwErr = StoLoadIntfConfig(NULL, pIntfContext);
    DbgAssert((dwErr == ERROR_SUCCESS,
               "StoLoadIntfConfig failed for Intf context 0x%p",
               pIntfContext));

    if (dwErr == ERROR_SUCCESS && g_wzcInternalCtxt.bValid)
    {
        PINTF_CONTEXT pIntfTContext;
        // apply the global template to this newly created interface
        EnterCriticalSection(&g_wzcInternalCtxt.csContext);
        pIntfTContext = g_wzcInternalCtxt.pIntfTemplate;
        LstRccsReference(pIntfTContext);
        LeaveCriticalSection(&g_wzcInternalCtxt.csContext);

        LstRccsLock(pIntfTContext);
        dwErr = LstApplyTemplate(
                    pIntfTContext,
                    pIntfContext,
                    NULL);
        LstRccsUnlockUnref(pIntfTContext);
    }

    if (dwErr == ERROR_SUCCESS)
    {
        // getting the interface status (media type & media state)
        dwErr = DevioGetIntfStats(pIntfContext);
        DbgAssert((dwErr == ERROR_SUCCESS,
                   "DevioGetIntfStats failed for Intf context 0x%p",
                   pIntfContext));

        // getting the interface MAC address
        dwErr = DevioGetIntfMac(pIntfContext);
        DbgAssert((dwErr == ERROR_SUCCESS,
                   "DevioGetIntfMac failed for Intf context 0x%p",
                   pIntfContext));
        DbgBinPrint((TRC_TRACK, "Local Mac address :", 
                    pIntfContext->ndLocalMac, sizeof(NDIS_802_11_MAC_ADDRESS)));
    }

    // fail initialization if the interface is not a wireless adapter
    if (dwErr == ERROR_SUCCESS && 
        pIntfContext->ulPhysicalMediaType != NdisPhysicalMediumWirelessLan)
        dwErr =  ERROR_MEDIA_INCOMPATIBLE;

    // do a preliminary check on the OIDs
    if (dwErr == ERROR_SUCCESS)
    {
        DWORD dwLErr;

        dwLErr = DevioRefreshIntfOIDs(
                    pIntfContext,
                    INTF_INFRAMODE|INTF_AUTHMODE|INTF_WEPSTATUS|INTF_SSID|INTF_BSSIDLIST,
                    NULL);
        // if the query succeeded, then assume the NIC supports the OIDs needed for Zero Config
        if (dwLErr == ERROR_SUCCESS)
        {
            pIntfContext->dwCtlFlags |= INTFCTL_OIDSSUPP;
        }
        // otherwise don't make this determination now - it could be a failure caused by the
        // device booting up.
    }

    // if all went well, prepare an automatic transition to {SHr}
    if (dwErr == ERROR_SUCCESS)
    {
        // set the "signal" control bit
        pIntfContext->dwCtlFlags |= INTFCTL_INTERNAL_SIGNAL;
        pIntfContext->pfnStateHandler = StateHardResetFn;

        // at this point, if the service is not enabled on this wireless interface
        // Notify the stack (TCP) of the failure in order to unblock the NetReady notification.
        if (!(pIntfContext->dwCtlFlags & INTFCTL_ENABLED) &&
            !(pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_INITFAILNOTIF))
        {
            // call into the stack - don't care about the return code.
            DevioNotifyFailure(pIntfContext->wszGuid);
            // make sure this call is never done twice for this adapter
            pIntfContext->dwCtlFlags |= INTFCTL_INTERNAL_INITFAILNOTIF;
        }

        dwErr = ERROR_CONTINUE;
    }

    DbgPrint((TRC_TRACK|TRC_STATE,"StateInitFn]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// StateHardResetFn: Handler for the {SHr} state
DWORD
StateHardResetFn(PINTF_CONTEXT pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;

    DbgPrint((TRC_TRACK|TRC_STATE,"[StateHardResetFn(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL,"Invalid NULL context in {SHr} state"));

    // in this state we are surely not associated.
    ZeroMemory(pIntfContext->wzcCurrent.MacAddress, sizeof(NDIS_802_11_MAC_ADDRESS));
    // Record current state into logging DB
    DbLogWzcInfo(WZCSVC_SM_STATE_HARDRESET, pIntfContext);
    // once in this state, the ncstatus should report "connecting"
    pIntfContext->ncStatus = NCS_CONNECTING;
    // if the service is enabled, notify netman about the current ncstatus
    if (pIntfContext->dwCtlFlags & INTFCTL_ENABLED)
        WzcNetmanNotify(pIntfContext);

    // Bump up the session handler for this intf context,
    // since it starts plumbing new configs. No commands from older
    // iterations should be accepted from now on.
    pIntfContext->dwSessionHandle++;

    // on hard reset, reopen NDISUIO handle and get the current SSID
    dwErr = DevioRefreshIntfOIDs(
                pIntfContext,
                INTF_HANDLE|INTF_SSID,
                NULL);
    // ignore whatever error is encountered here..
    // If there is an error, then the interface handle will be invalid
    // and it will be internally reopened in the {SSr} state

    // at this point make sure the card won't get randomly associate
    // during the subsequent network scan. We make this happen by plumbing
    // down a random non-visible SSID but only in the following cases:
    // - the service is enabled (otherwise no config change is allowed)
    // - the current SSID was retrieved successfully
    // - there is an SSID returned by the driver
    // - the current SSID shows as being NULL (all filled with 0 chars)
    if (pIntfContext->dwCtlFlags & INTFCTL_ENABLED &&
        dwErr == ERROR_SUCCESS && 
        WzcIsNullBuffer(pIntfContext->wzcCurrent.Ssid.Ssid, pIntfContext->wzcCurrent.Ssid.SsidLength))
    {
        BYTE chSSID[32];

        DbgPrint((TRC_STATE,"Overwriting null SSID before scan"));

        ZeroMemory(&chSSID, sizeof(chSSID));
        if (WzcRndGenBuffer(chSSID, 32, 1, 31) == ERROR_SUCCESS)
        {
            INTF_ENTRY IntfEntry;

            ZeroMemory(&IntfEntry, sizeof(INTF_ENTRY));
            IntfEntry.rdSSID.pData = chSSID;
            IntfEntry.rdSSID.dwDataLen = 32;
            IntfEntry.nInfraMode = Ndis802_11Infrastructure;

            DevioSetIntfOIDs(
                pIntfContext,
                &IntfEntry,
                INTF_SSID | INTF_INFRAMODE,
                NULL);

            // this is not an SSID we need to remember (being a random one)
            ZeroMemory(&(pIntfContext->wzcCurrent.Ssid), sizeof(NDIS_802_11_SSID));
        }
    }

    // on hard reset, free the current selection list. This way,
    // whatever new selection list we build later will have all
    // new networks and a configuration will be forcefully plumbed
    WzcCleanupWzcList(pIntfContext->pwzcSList);
    pIntfContext->pwzcSList = NULL;

    // automatic transition to {SSr} state
    pIntfContext->pfnStateHandler = StateSoftResetFn;
    dwErr = ERROR_CONTINUE;

    DbgPrint((TRC_TRACK|TRC_STATE,"StateHardResetFn]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// StateSoftResetFn: Handler for the {SSr} state
DWORD
StateSoftResetFn(PINTF_CONTEXT pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;

    DbgPrint((TRC_TRACK|TRC_STATE,"[StateSoftResetFn(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL,"Invalid NULL context in {SSr} state"));

    //Record current state into logging DB
    DbLogWzcInfo(WZCSVC_SM_STATE_SOFTRESET, pIntfContext);

    DbgPrint((TRC_STATE,"Delay {SSr} on failure? %s",
              (pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_NO_DELAY) ? "No" : "Yes"));

    // indicate to the driver to rescan the BSSID_LIST for this adapter
    dwErr = DevioRefreshIntfOIDs(
                pIntfContext,
                INTF_LIST_SCAN,
                NULL);
    if (dwErr == ERROR_SUCCESS)
    {
        // once we passed through this state, allow again delayed 
        // execution of {SSr} in future loops.
        pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_NO_DELAY;
        // set the rescan timer
        TIMER_SET(pIntfContext, TMMS_Tr, dwErr);
        // when the timer will be fired off, the dispatcher will
        // take care to transit this context into the {SQ} state.
    }
    else
    {
        // it happens that after resume from standby WZC is waken up before the
        // adapter being bound correctly to NDISUIO in which case, scanning the networks
        // return ERROR_NOT_SUPPORTED. So, just to play safe, in case of any error just give
        // it another try in a couple of seconds.
        if (!(pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_NO_DELAY))
        {
            // once we passed through this state, don't allow further delayed execution
            pIntfContext->dwCtlFlags |= INTFCTL_INTERNAL_NO_DELAY;
            pIntfContext->pfnStateHandler = StateDelaySoftResetFn;
        }
        else
        {
            // once we passed through this state, allow again delayed 
            // execution of {SSr} in future loops
            // also, if the OIDs are failing, don't pop up any balloon.
            pIntfContext->dwCtlFlags &= ~(INTFCTL_INTERNAL_NO_DELAY|INTFCTL_INTERNAL_SIGNAL);
            // regardless the error, just go over it and assume the driver has already the list
            // of SSIDs and all the other OIDs we need. Will use that one hence we have to go on to {SQ}.
            pIntfContext->pfnStateHandler = StateQueryFn;
        }
        dwErr = ERROR_CONTINUE;
    }

    DbgPrint((TRC_TRACK|TRC_STATE,"StateSoftResetFn]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// StateDelaySoftResetFn: Handler for the {SDSr} state
DWORD
StateDelaySoftResetFn(
    PINTF_CONTEXT   pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;

    DbgPrint((TRC_TRACK|TRC_STATE,"[StateDelaySoftResetFn(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL,"Invalid NULL context in {SDSr} state"));

    DbLogWzcInfo(WZCSVC_SM_STATE_DELAY_SR, pIntfContext);
    // if there was a failure in {SSr} such that we had to delay and retry that state
    // then refresh the interface handle in an attempt to recover from the error
    DevioRefreshIntfOIDs(
        pIntfContext,
        INTF_HANDLE,
        NULL);

    // set the timer to retry the {SSr} state
    TIMER_SET(pIntfContext, TMMS_Td, dwErr);

    DbgPrint((TRC_TRACK|TRC_STATE,"StateDelaySoftResetFn]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// StateQueryFn: Handler for the {SQ} state
DWORD
StateQueryFn(PINTF_CONTEXT pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;
    
    DbgPrint((TRC_TRACK|TRC_STATE,"[StateQueryFn(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL,"Invalid NULL context in {SQ} state"));
    DbgAssert((pIntfContext->hIntf != INVALID_HANDLE_VALUE,"Invalid Ndisuio handle in {SQ} state"));
    //Record current state into logging DB
    DbLogWzcInfo(WZCSVC_SM_STATE_QUERY, pIntfContext);

    dwErr = DevioGetIntfStats(pIntfContext);
    // don't care much about the result of this call..
    DbgAssert((dwErr == ERROR_SUCCESS, "Getting NDIS statistics failed in state {SQ}"));
    // check the media state (just for debugging)
    DbgPrint((TRC_GENERIC, "Media State (%d) is %s", 
        pIntfContext->ulMediaState,
        pIntfContext->ulMediaState == MEDIA_STATE_CONNECTED ? "Connected" : "Not Connected"));

    dwErr = DevioRefreshIntfOIDs(
                pIntfContext,
                INTF_INFRAMODE|INTF_AUTHMODE|INTF_WEPSTATUS|INTF_SSID|INTF_BSSIDLIST,
                NULL);

    // dwErr is success only in the case all the queries above succeeded
    if (dwErr == ERROR_SUCCESS)
    {
        PWZC_802_11_CONFIG_LIST pwzcSList = NULL;

        pIntfContext->dwCtlFlags |= INTFCTL_OIDSSUPP;

        // deprecate entries in the blocked list according to the new visible list.
        // Entries in the BList which are not seen as "visible" for WZC_INTERNAL_BLOCKED_TTL
        // number of times are taken out of that list.
        // this function can't fail, this is why we don't check its return value.
        LstDeprecateBlockedList(pIntfContext);

        // build the pwzcSList out of pwzcVList and pwzcPList and
        // taking into consideration the fallback flag
        dwErr = LstBuildSelectList(pIntfContext, &pwzcSList);

        if (dwErr == ERROR_SUCCESS)
        {
            UINT nSelIdx = 0;

            // check the new selection list against the previous one and see
            // if a new plumbing is required or not.
            if (LstChangedSelectList(pIntfContext, pwzcSList, &nSelIdx))
            {
                // if a new plumbing is required, get rid of the old selection
                // list and put the new one in the interface context.
                WzcCleanupWzcList(pIntfContext->pwzcSList);
                pIntfContext->pwzcSList = pwzcSList;
                // Make sure we default clear this flag - it will be set a bit down if
                // indeed this turns out to be a "one time" deal.
                pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_ONE_TIME;
                // if the preferred list also includes a starting index, then this
                // is a request for a "one time configuration"
                if (pIntfContext->pwzcPList != NULL &&
                    pIntfContext->pwzcPList->Index < pIntfContext->pwzcPList->NumberOfItems)
                {
                    // reset the "start from" index in the preferred list as this is intended
                    // for "one time configuration" mostly.
                    pIntfContext->pwzcPList->Index = pIntfContext->pwzcPList->NumberOfItems;
                    // but keep in mind this is a one time configuration
                    pIntfContext->dwCtlFlags |= INTFCTL_INTERNAL_ONE_TIME;
                }

                // set the starting index in the selection list, if there is one
                if (pIntfContext->pwzcSList != NULL)
                    pIntfContext->pwzcSList->Index = nSelIdx;

                // then go to the {SIter}
                pIntfContext->pfnStateHandler = StateIterateFn;
            }
            else
            {
                PWZC_WLAN_CONFIG pConfig;

                pConfig = &(pIntfContext->pwzcSList->Config[pIntfContext->pwzcSList->Index]);
                DbLogWzcInfo(WZCSVC_SM_STATE_QUERY_NOCHANGE, pIntfContext,
                             DbLogFmtSSID(0, &(pConfig->Ssid)));
                                
                // if no new plumbing is required clean the new selection list
                WzcCleanupWzcList(pwzcSList);
                // then go to {SC} or {SCk} (depending the WEP key) since the interface context 
                // has not changed a bit. The selection list & the selection index were not 
                // touched in this cycle
                if (pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_FAKE_WKEY)
                    pIntfContext->pfnStateHandler = StateCfgHardKeyFn;
                else
                    pIntfContext->pfnStateHandler = StateConfiguredFn;
            }
        }
    }
    else
    {
        // since the oids failed, suppress any subsequent balloon:
        pIntfContext->dwCtlFlags &= ~(INTFCTL_OIDSSUPP|INTFCTL_INTERNAL_SIGNAL);
        pIntfContext->pfnStateHandler = StateFailedFn;
    }

    // in both cases, this is an automatic transition
    dwErr = ERROR_CONTINUE;

    DbgPrint((TRC_TRACK|TRC_STATE,"StateQueryFn]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// StateIterateFn: Handler for the {SIter} state
DWORD
StateIterateFn(
    PINTF_CONTEXT   pIntfContext)
{
    DWORD 	dwErr = ERROR_SUCCESS;
    PWZC_WLAN_CONFIG pConfig;

    DbgPrint((TRC_TRACK|TRC_STATE,"[StateIterateFn(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL,"Invalid NULL context in {SIter} state"));
    DbgAssert((pIntfContext->hIntf != INVALID_HANDLE_VALUE,"Invalid Ndisuio handle in {SIter} state"));

    // Bump up the session handler for this intf context,
    // since it starts plumbing new configs. No commands from older
    // iterations should be accepted from now on.
    pIntfContext->dwSessionHandle++;

    // if either zero conf service is disabled for this context or there are no more configurations
    // to try, transit to {SF} directly
    if (!(pIntfContext->dwCtlFlags & INTFCTL_ENABLED) || 
        pIntfContext->pwzcSList == NULL ||
        pIntfContext->pwzcSList->NumberOfItems <= pIntfContext->pwzcSList->Index)
    {
        dwErr = ERROR_CONTINUE;
    }
    // check if the current config is marked "deleted". If this is the case, it means the {SRs} state
    // exhausted all configurations. We should move to the failure state {SF}. The list of selected networks
    // remains untouched - it is used in {SF} to update the blocked list. It is cleaned up in {SHr}.
    else
    {
        pConfig = &(pIntfContext->pwzcSList->Config[pIntfContext->pwzcSList->Index]);

        if (pConfig->dwCtlFlags & WZCCTL_INTERNAL_DELETED)
        {
            dwErr = ERROR_CONTINUE;
        }
    }

    if (dwErr == ERROR_SUCCESS)
    {
        DbgPrint((TRC_STATE,"Plumbing config %d", pIntfContext->pwzcSList->Index));
	    //Record current state into logging DB
        DbLogWzcInfo(WZCSVC_SM_STATE_ITERATE, pIntfContext,
                     DbLogFmtSSID(0, &(pConfig->Ssid)), pConfig->InfrastructureMode);
        // in this state we need to mark ncstatus = "connecting" again. We do it because we could
        // come from a connected state, from {SRs} and {SPs}.
        pIntfContext->ncStatus = NCS_CONNECTING;
        // notify netman about the ncstatus change.
        WzcNetmanNotify(pIntfContext);

        // here we're about to plumb down a possibly new network. If it is indeed an SSID different from
        // the one we have, we'll release the IP address (to force a Discover in the new net). Note that
        // in {SIter}->{SRs}->{SIter} loops, no Release happens since the SSID should always coincide.
        // Release might happen only on Hard resets when the SSID looks to be different from what is 
        // about to be plumbed down.
        if (pConfig->Ssid.SsidLength != pIntfContext->wzcCurrent.Ssid.SsidLength ||
            memcmp(pConfig->Ssid.Ssid, pIntfContext->wzcCurrent.Ssid.Ssid, pConfig->Ssid.SsidLength))
        {
            DbgPrint((TRC_STATE,"Requesting the release of the DHCP lease"));
            // since Zero Configuration is the only one knowing that we are roaming to a new network
            // it is up to Zero Configuration to trigger DHCP client lease refreshing. Otherwise DHCP
            // client will act only on the Media Connect hence it will try to renew its old lease and 
            // being on the wrong network this will take a minute. Too long to wait.
            DhcpReleaseParameters(pIntfContext->wszGuid);
        }
        else
            DbgPrint((TRC_STATE,"Plumbing down the current SSID => skip the DHCP lease releasing"));

        // we do have some entries in the selected configuration list (pwzcSList), and we
        // do expect to have a valid index pointing in the list to the selected config
        dwErr = LstSetSelectedConfig(pIntfContext, NULL);

        if (dwErr == ERROR_SUCCESS)
        {
            // if everything went ok, we'll expect a media connect event in TMMS_Tp time.
            // set this timer to fire up if the event doesn't come in.
            TIMER_SET(pIntfContext, TMMS_Tp, dwErr);
        }
        else
        {
            DbgPrint((TRC_STATE,"Remove the selected config since the driver failed setting it"));
            // if anything went wrong on setting the selected config, don't bail out. Just remove
            // this selected config and move to the next one
            pIntfContext->dwCtlFlags |= INTFCTL_INTERNAL_FORCE_CFGREM;
            pIntfContext->pfnStateHandler = StateCfgRemoveFn;
            dwErr = ERROR_CONTINUE;
        }
    }
    else // dwErr can't be anything else bug ERROR_CONTINUE in the 'else' branch
    {
        DbgPrint((TRC_STATE,"No configurations left in the selection list"));
	    //Record current state into logging DB
	    DbLogWzcInfo(WZCSVC_SM_STATE_ITERATE_NONET, pIntfContext);
        pIntfContext->pfnStateHandler = StateFailedFn;
    }

    DbgPrint((TRC_TRACK|TRC_STATE,"StateIterateFn]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// StateConfiguredFn: Handler for the {SC} state
DWORD
StateConfiguredFn(
    PINTF_CONTEXT   pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;
    
    DbgPrint((TRC_TRACK|TRC_STATE,"[StateConfiguredFn(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL,"Invalid NULL context in {SQ} state"));

    // since we're in {SC}, it means we cannot have a fake WEP Key, no matter what.
    // hence, reset the INTFCTL_INTERNAL_FAKE_WKEY flag
    pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_FAKE_WKEY;

    // set the timer for the "configured" state life time
    TIMER_SET(pIntfContext, TMMS_Tc, dwErr);

    DbgPrint((TRC_TRACK|TRC_STATE,"StateConfiguredFn]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// StateFailedFn: Handler for the {SF} state
DWORD
StateFailedFn(
    PINTF_CONTEXT   pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;
    
    DbgPrint((TRC_TRACK|TRC_STATE,"[StateFailedFn(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL,"Invalid NULL context in {SF} state"));
    // Record current state into logging DB
    DbLogWzcInfo(WZCSVC_SM_STATE_FAILED, pIntfContext);
    //
    // a couple of things need to be done if the service is enabled and
    // the driver supports all the needed OIDs
    if (pIntfContext->dwCtlFlags & INTFCTL_OIDSSUPP &&
        pIntfContext->dwCtlFlags & INTFCTL_ENABLED)
    {
        BYTE chSSID[32];

        // send the failure notification down to TCP. This will cause TCP to
        // generate the NetReady notification asap.
        if (!(pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_INITFAILNOTIF))
        {
            // call into the stack
            DevioNotifyFailure(pIntfContext->wszGuid);
            // make sure this call is never done twice for this adapter
            pIntfContext->dwCtlFlags |= INTFCTL_INTERNAL_INITFAILNOTIF;
        }

        // whatever brought us here, the ncstatus should be "disconnected"
        pIntfContext->ncStatus = NCS_MEDIA_DISCONNECTED;
        // since the service is enabled, notify netman about the status change
        WzcNetmanNotify(pIntfContext);

        // this is when we should signal the failure if the signal is
        // not to be suppressed and the service is enabled
        if (pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_SIGNAL)
        {
            WZCDLG_DATA dialogData = {0};

            // bring up the "Failure" balloon
            dialogData.dwCode = WZCDLG_FAILED;
            dialogData.lParam = 0;
            // count exactly how many visible configs we have (don't count
            // SSIDs coming from APs that don't respond to broadcast SSID)
            if (pIntfContext->pwzcVList != NULL)
            {
                UINT i;

                for (i = 0; i < pIntfContext->pwzcVList->NumberOfItems; i++)
                {
                    PNDIS_802_11_SSID pndSSID = &(pIntfContext->pwzcVList->Config[i].Ssid);

                    if (!WzcIsNullBuffer(pndSSID->Ssid, pndSSID->SsidLength))
                        dialogData.lParam++;
                }
            }

            // there is no point in even notifying netman..netshell..wzcdlg if there are no
            // visible networks and no balloon is going to be displayed anyway.
            if (dialogData.lParam > 0)
            {
                DbgPrint((TRC_STATE,"Generating balloon notification for %d visible networks", dialogData.lParam));
                WzcDlgNotify(pIntfContext, &dialogData);
                // once a signal has been generated, suppress further signals
                // until passing through a successful configuration
                pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_SIGNAL;
            }
        }

        // just break the association here by plumbing down a hard coded SSID
        // don't care about the return value.
        ZeroMemory(&chSSID, sizeof(chSSID));
        if (WzcRndGenBuffer(chSSID, 32, 1, 31) == ERROR_SUCCESS)
        {
            INTF_ENTRY IntfEntry;

            ZeroMemory(&IntfEntry, sizeof(INTF_ENTRY));
            IntfEntry.rdSSID.pData = chSSID;
            IntfEntry.rdSSID.dwDataLen = 32;
            IntfEntry.nInfraMode = Ndis802_11Infrastructure;

            DevioSetIntfOIDs(
                pIntfContext,
                &IntfEntry,
                INTF_SSID | INTF_INFRAMODE,
                NULL);

            // this is not an SSID we need to remember (being a random one)
            ZeroMemory(&(pIntfContext->wzcCurrent.Ssid), sizeof(NDIS_802_11_SSID));
        }

        // regardless the above, update the "blocked" list
        dwErr = LstUpdateBlockedList(pIntfContext);
        DbgAssert((dwErr == ERROR_SUCCESS, "Failed with err %d updating the list of blocked configs!", dwErr));
    }


    // Bump up the session handler for this intf context,
    // since it starts plumbing new configs. No commands from older
    // iterations should be accepted from now on.
    pIntfContext->dwSessionHandle++;

    // If the card is courteous enough and talks to us, set a timer
    // for 1 minute such that after this time we're getting an updated
    // picture of what networks are around - at least that should be presented
    // to the user.
    if (pIntfContext->dwCtlFlags & INTFCTL_OIDSSUPP)
    {
        // Remain in {SF} one minute and scan again after that. It might look meaningless to do so
        // in case the service is disabled, but keep in mind "disabled" means only "don't change
        // anything on the card" (aside from the scan). That is, the view of what networks are
        // available needs to be kept updated.
        TIMER_SET(pIntfContext, TMMS_Tf, dwErr);
    }

    DbgPrint((TRC_TRACK|TRC_STATE,"StateFailedFn]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// StateCfgRemoveFn: Handler for the {SRs} state
DWORD
StateCfgRemoveFn(
    PINTF_CONTEXT   pIntfContext)
{
    DWORD            dwErr = ERROR_SUCCESS;
    BOOL             bConnectOK = FALSE;
    PWZC_WLAN_CONFIG pConfig = &(pIntfContext->pwzcSList->Config[pIntfContext->pwzcSList->Index]);    

    DbgPrint((TRC_TRACK|TRC_STATE,"[StateCfgRemoveFn(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL,"Invalid NULL context in {SRs} state"));
    DbgAssert((pIntfContext->pwzcSList != NULL, "Invalid null selection list in {SRs} state"));
    DbgAssert((pIntfContext->pwzcSList->Index < pIntfContext->pwzcSList->NumberOfItems, "Invalid selection index in {SRs} state"));

    dwErr = DevioGetIntfStats(pIntfContext);

    // debug print
    DbgPrint((TRC_GENERIC, "Media State (%d) is %s", 
        pIntfContext->ulMediaState,
        pIntfContext->ulMediaState == MEDIA_STATE_CONNECTED ? "Connected" : "Not Connected"));

    // if we were explicitly requested to delete this configuration, do it so no matter what
    if (pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_FORCE_CFGREM)
    {
        DbgPrint((TRC_STATE,"The upper layer directs this config to be deleted => obey"));
        bConnectOK = FALSE;
    }
    // .. but if the configuration we just plumbed is saying we need to consider this a success
    // no matter what, do it so undoubtely
    else if (pConfig->dwCtlFlags & WZCCTL_INTERNAL_FORCE_CONNECT)
    {
        DbgPrint((TRC_STATE,"This config requests forced connect => obey (transition to {SN})"));
        bConnectOK = TRUE;
    }
    // if there is no special request and we were able to get the media status and we see the 
    // media being connected, this means the configuration is successful.
    else if ((dwErr == ERROR_SUCCESS) && (pIntfContext->ulMediaState == MEDIA_STATE_CONNECTED))
    {
        DbgPrint((TRC_STATE,"Media is being connected in {SRs} =?=> transition to {SN}"));
        bConnectOK = TRUE;
    }
    // in all other cases the configuration is going to be deleted

    // go to the {SN} and {SC/SCk} based on the decision we took in bConnectOK
    if (bConnectOK)
    {
        // ...assume the configuration was successful (although we didn't get
        // the media connect event) and transition to {SN}
        pIntfContext->pfnStateHandler = StateNotifyFn;
    }
    else
    {
        UINT nFirstSelIdx; // first selection index following
        UINT nNSelIdx;  // new selection index to use

        // if this is a forced delete, make sure we are not messing with old
        // WZCCTL_INTERNAL_FORCE_CONNECT flags - they could cause such a configuration to
        // be revived
        if (pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_FORCE_CFGREM)
        {
            pConfig->dwCtlFlags &= ~WZCCTL_INTERNAL_FORCE_CONNECT;
            // since the upper layer is rejecting this configuration, make sure that 
            // future iterations won't try it again, This bit helps to build/update
            // the BList (blocked list) when/if the state machine eventually gets
            // into the failed state {SF}.
            pConfig->dwCtlFlags |= WZCCTL_INTERNAL_BLOCKED;
        }

        // if this is an Adhoc network that just happened to fail, keep it in the list
        // such that it will be retried one more time and when this happens it shall
        // be considered successful no matter what.
        // However this is to be done only if the upper layer is not asking explicitly for
        // this config to be deleted
        if (pConfig->InfrastructureMode == Ndis802_11IBSS &&
            !(pConfig->dwCtlFlags & WZCCTL_INTERNAL_FORCE_CONNECT) &&
            !(pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_FORCE_CFGREM))
        {
            //Record current state into logging DB
            DbLogWzcInfo(WZCSVC_SM_STATE_CFGSKIP, pIntfContext,
                         DbLogFmtSSID(0, &(pConfig->Ssid)));

            pConfig->dwCtlFlags |= WZCCTL_INTERNAL_FORCE_CONNECT;
        }
        else
        {
            //Record current state into logging DB
            DbLogWzcInfo(WZCSVC_SM_STATE_CFGREMOVE, pIntfContext,
                         DbLogFmtSSID(0, &(pConfig->Ssid)));
        }

        // mark this configuration as "bad"
        pConfig->dwCtlFlags |= WZCCTL_INTERNAL_DELETED;

        // regardless this was a forced or non-forced removal, reset the "force" control bit
        pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_FORCE_CFGREM;

        // if we just fail a "one time configuration", force a fresh beginning.
        // and remove the "one time" flag as we're getting out of this mode
        if (pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_ONE_TIME)
        {
            DbgPrint((TRC_STATE,"Dropping a \"one time\" configuration"));
            pIntfContext->pwzcSList->Index = (pIntfContext->pwzcSList->NumberOfItems - 1);
            pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_ONE_TIME;
        }

        // scan for the next configuration that has not been marked "bad" yet
        for (nNSelIdx = (pIntfContext->pwzcSList->Index + 1) % pIntfContext->pwzcSList->NumberOfItems;
             nNSelIdx != pIntfContext->pwzcSList->Index;
             nNSelIdx = (nNSelIdx + 1) % pIntfContext->pwzcSList->NumberOfItems)
        {
            pConfig = &(pIntfContext->pwzcSList->Config[nNSelIdx]);
            if (!(pConfig->dwCtlFlags & WZCCTL_INTERNAL_DELETED))
                break;
        }

        // if we couldn't find any better candidate ...
        if (pConfig->dwCtlFlags & WZCCTL_INTERNAL_DELETED)
        {
            BOOL bFoundCandidate = FALSE;

            DbgPrint((TRC_STATE,"Went through all configs. Reviving now failed Adhocs."));

            // revive the adhocs that failed previously
            // This means that we reset the WZCCTL_INTERNAL_DELETED flag from all the configurations
            // having the WZCCTL_INTERNAL_FORCE_CONNECT flag set, and we let the latter untouched.
            // Because of this flag we'll actually consider the configuration to be successful when 
            // it will be plumbed again. From that point on, it will be only the upper layer who will
            // be able to delete it again, and it is then when the WZCCTL_INTERNAL_FORCE_CONNECT
            // gets reset.
            for (nNSelIdx = 0; nNSelIdx < pIntfContext->pwzcSList->NumberOfItems; nNSelIdx++)
            {
                pConfig = &(pIntfContext->pwzcSList->Config[nNSelIdx]);
                if (pConfig->dwCtlFlags & WZCCTL_INTERNAL_FORCE_CONNECT)
                {
                    DbgPrint((TRC_STATE,"Reviving configuration %d.", nNSelIdx));

                    pConfig->dwCtlFlags &= ~WZCCTL_INTERNAL_DELETED;
                    // the first configuration in this position is the candidate we were looking for
                    if (!bFoundCandidate)
                    {
                        pIntfContext->pwzcSList->Index = nNSelIdx;
                        bFoundCandidate = TRUE;
                    }
                }
            }

            // if !bFoundCandidate, the configuration currently pointed by the pwzcSList->Index has
            // the "deleted" bit on. This will make {SIter} to jump directly to {SF}.
        }
        else
        {
            // if we could find another candidate, set the index to point it
            pIntfContext->pwzcSList->Index = nNSelIdx;
        }

        // transition automatically to {SIter} state
        pIntfContext->pfnStateHandler = StateIterateFn;
    }

    dwErr = ERROR_CONTINUE;

    DbgPrint((TRC_TRACK|TRC_STATE,"StateCfgRemoveFn]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// StateCfgPreserveFn: Handler for the {SPs} state
DWORD
StateCfgPreserveFn(
    PINTF_CONTEXT   pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;
    PWZC_WLAN_CONFIG pConfig;
    UINT nNSelIdx;
    UINT i;
    
    DbgPrint((TRC_TRACK|TRC_STATE,"[StateCfgPreserveFn(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL,"Invalid NULL context in {SPs} state"));
    DbgAssert((pIntfContext->pwzcSList != NULL, "Invalid null selection list in {SPs} state"));
    DbgAssert((pIntfContext->pwzcSList->Index < pIntfContext->pwzcSList->NumberOfItems, "Invalid selection index in {SPs} state"));

    pConfig = &(pIntfContext->pwzcSList->Config[pIntfContext->pwzcSList->Index]);
    //Record current state into logging DB
    DbLogWzcInfo(WZCSVC_SM_STATE_CFGPRESERVE, pIntfContext,
                 DbLogFmtSSID(0, &(pConfig->Ssid)));

    // if we just skip a "one time configuration", then don't move the pointer out of it.
    // Basically we'll retry the same configuration over and over again until (if it completly
    // fails) it is removed from the selection list by the upper layer (802.1x).
    if (!(pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_ONE_TIME))
    {
        // scan for the next configuration which has not been marked "bad" yet
        for (i = 0, nNSelIdx = (pIntfContext->pwzcSList->Index + 1) % pIntfContext->pwzcSList->NumberOfItems;
             i < pIntfContext->pwzcSList->NumberOfItems;
             i++, nNSelIdx = (nNSelIdx + 1) % pIntfContext->pwzcSList->NumberOfItems)
        {
            pConfig = &(pIntfContext->pwzcSList->Config[nNSelIdx]);
            if (!(pConfig->dwCtlFlags & WZCCTL_INTERNAL_DELETED))
                break;
        }
        // if we couldn't find any, clear the selection list and go back to
        // {SIter}. It will transition consequently to {SF}
        if (i == pIntfContext->pwzcSList->NumberOfItems)
        {
            WzcCleanupWzcList(pIntfContext->pwzcSList);
            pIntfContext->pwzcSList = NULL;
        }
        else
        {
            // if we could find another candidate, set the index to point it
            pIntfContext->pwzcSList->Index = nNSelIdx;
        }
    }

    pIntfContext->pfnStateHandler = StateIterateFn;
    dwErr = ERROR_CONTINUE;

    DbgPrint((TRC_TRACK|TRC_STATE,"StateCfgPreserveFn]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// StateCfgHardKeyFn: Handler for the {SCk} state
DWORD
StateCfgHardKeyFn(
    PINTF_CONTEXT   pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;
    PWZC_WLAN_CONFIG    pSConfig;
    
    DbgPrint((TRC_TRACK|TRC_STATE,"[StateCfgHardKeyFn(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL,"Invalid NULL context in {SCk} state"));

    // get a pointer to the currently selected configuration
    pSConfig = &(pIntfContext->pwzcSList->Config[pIntfContext->pwzcSList->Index]);

    //Record current state into logging DB
    DbLogWzcInfo(WZCSVC_SM_STATE_CFGHDKEY, pIntfContext, 
                 DbLogFmtSSID(0, &(pSConfig->Ssid)));

    TIMER_SET(pIntfContext, TMMS_Tc, dwErr);

    DbgPrint((TRC_TRACK|TRC_STATE,"StateCfgHardKeyFn]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// StateNotifyFn: Handler for the {SN} state
DWORD
StateNotifyFn(
    PINTF_CONTEXT   pIntfContext)
{
    DWORD dwErr = ERROR_SUCCESS;
    PWZC_WLAN_CONFIG    pSConfig;
    PWZC_DEVICE_NOTIF   pwzcNotif;
    DWORD 	i;

    DbgPrint((TRC_TRACK|TRC_STATE,"[StateNotifyFn(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL,"Invalid NULL context in {SN} state"));
    DbgAssert((pIntfContext->pwzcSList != NULL, "Invalid null selection list in {SN} state"));
    DbgAssert((pIntfContext->pwzcSList->Index < pIntfContext->pwzcSList->NumberOfItems, "Invalid selection index in {SN} state"));

    // we have a valid 802.11 config, so the ncstatus should read "connected"
    pIntfContext->ncStatus = NCS_CONNECTED;
    // notify netman about the ncstatus change (no need to check whether the
    // service is enabled or not - it is enabled, otherwise we won't be in this state)
    WzcNetmanNotify(pIntfContext);

    // get a pointer to the currently selected configuration
    pSConfig = &(pIntfContext->pwzcSList->Config[pIntfContext->pwzcSList->Index]);

    // get the BSSID to which we're associated.
    // if the BSSID was successfully retrieved then use this to generate the initial
    // dynamic session keys. LstGenInitialSessionKeys is successfull only if the current
    // configuration allows (association is successful and there is a user-provided wep key)
    dwErr = DevioRefreshIntfOIDs(pIntfContext, INTF_BSSID, NULL);

    //Record current state into logging DB as the first thing.
    DbLogWzcInfo(WZCSVC_SM_STATE_NOTIFY, pIntfContext, 
                 DbLogFmtSSID(0, &(pSConfig->Ssid)), 
                 DbLogFmtBSSID(1, pIntfContext->wzcCurrent.MacAddress));

    // now check if there was any error getting the BSSID - if it was, log it.
    // otherwise go on and generate the initial session keys.
    if (dwErr != ERROR_SUCCESS)
    {
        // if there was any error getting the BSSID, log the error here
        DbLogWzcError(WZCSVC_ERR_QUERRY_BSSID, pIntfContext, dwErr);
    }
    else
    {
        dwErr = LstGenInitialSessionKeys(pIntfContext);
        // if there was any error setting the initial session keys, log it here
        if (dwErr != ERROR_SUCCESS)
            DbLogWzcError(WZCSVC_ERR_GEN_SESSION_KEYS, pIntfContext, dwErr);
    }
    // no error is critical enough so far to justify stopping the state machine.
    // .. so reset it to "success"
    dwErr = ERROR_SUCCESS;

    // allocate memory for a WZC_CONFIG_NOTIF object large enough to include the interface's GUID
    pwzcNotif = MemCAlloc(sizeof(WZC_DEVICE_NOTIF) + wcslen(pIntfContext->wszGuid)*sizeof(WCHAR));
    if (pwzcNotif == NULL)
    {
        DbgAssert((FALSE, "Out of memory on allocating the WZC_DEVICE_NOTIF object"));
        dwErr = GetLastError();
        goto exit;
    }

    // initialize the WZC_CONFIG_NOTIF
    // this is a WZCNOTIF_WZC_CONNECT event that is going up
    pwzcNotif->dwEventType = WZCNOTIF_WZC_CONNECT;
    pwzcNotif->wzcConfig.dwSessionHdl = pIntfContext->dwSessionHandle;
    wcscpy(pwzcNotif->wzcConfig.wszGuid, pIntfContext->wszGuid);
    memcpy(&pwzcNotif->wzcConfig.ndSSID, &pSConfig->Ssid, sizeof(NDIS_802_11_SSID));
    // copy into the notification the user data associated with the current config
    pwzcNotif->wzcConfig.rdEventData.dwDataLen = pSConfig->rdUserData.dwDataLen;
    if (pwzcNotif->wzcConfig.rdEventData.dwDataLen > 0)
    {
        pwzcNotif->wzcConfig.rdEventData.pData = MemCAlloc(pSConfig->rdUserData.dwDataLen);
        if (pwzcNotif->wzcConfig.rdEventData.pData == NULL)
        {
            DbgAssert((FALSE, "Out of memory on allocating the WZC_CONFIG_NOTIF user data"));
            dwErr = GetLastError();
            MemFree(pwzcNotif);
            goto exit;
        }

        memcpy(pwzcNotif->wzcConfig.rdEventData.pData,
               pSConfig->rdUserData.pData,
               pSConfig->rdUserData.dwDataLen);
    }

    // Asynchronously call into the upper level app (802.1x) 
    // notifying that the selected 802.11 configuration is successful.
    DbgPrint((TRC_NOTIF, "Sending WZCNOTIF_WZC_CONNECT notification (SessHdl %d)", 
              pIntfContext->dwSessionHandle));

    InterlockedIncrement(&g_nThreads);
    if (!QueueUserWorkItem((LPTHREAD_START_ROUTINE)WZCWrkWzcSendNotif,
                          (LPVOID)pwzcNotif,
                          WT_EXECUTELONGFUNCTION))
    {
        DbgAssert((FALSE, "Can't create WZCWrkWzcSendNotif worker thread"));
        dwErr = GetLastError();
        InterlockedDecrement(&g_nThreads);
        MemFree(pwzcNotif->wzcConfig.rdEventData.pData);
        MemFree(pwzcNotif);
        goto exit;
    }

    DbgPrint((TRC_STATE,"Requesting the refresh of the DHCP lease"));
    // once the configuration has been set up correctly, Zero Conf needs to trigger 
    // DHCP client one more time asking for the lease to be refreshed. It needs to do so 
    // because it is not guaranteed that a media connect notification will be generated
    // and hence DHCP client might have no knowledge about the network being brought up
    // back. Note also the call below is (and should be) asynchronous
    DhcpStaticRefreshParams(pIntfContext->wszGuid);

    // at this point, set back the "signal" control bit since right now we're in the
    // successful case! On next failure (whenever that might be) the signal must not
    // be suppressed.
    pIntfContext->dwCtlFlags |= INTFCTL_INTERNAL_SIGNAL;

    // also, mark this context has been sent up the notification to 802.1x.
    // If we're here because of a PnP event, then this will tell to the notification
    // handler to not forward the notification up since it would be totally redundant.
    // If this is not PnP event, this bit will be cleaned up by whoever called StateDispatchEvent.
    pIntfContext->dwCtlFlags |= INTFCTL_INTERNAL_BLK_MEDIACONN;

    // automatic transition to either {SCk} or {SC} depending whether the remote guy
    // is requiring privacy and we rely the privacy on a faked key
    if (pSConfig->Privacy && pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_FAKE_WKEY)
        pIntfContext->pfnStateHandler = StateCfgHardKeyFn;
    else
        pIntfContext->pfnStateHandler = StateConfiguredFn;
    dwErr = ERROR_CONTINUE;

exit:
    DbgPrint((TRC_TRACK|TRC_STATE,"StateNotifyFn]=%d", dwErr));
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\storage.h ===
#pragma once

//-----------------------------------------------------------
// registry related defines
#define REG_LAYOUT_VERSION  0x00000004
#define REG_LAYOUT_LEGACY_3 0x00000003
#define REG_LAYOUT_LEGACY_2 0x00000002
#define REG_LAYOUT_LEGACY_1 0x00000001

#define REG_STSET_MAX   0xffff  // sets a limit to a maximum of 0xffff static configurations
                                // (should be more than reasonable)
#define REG_STSET_DELIM L'-'    // this is where the number of the static config is coded in the 
                                // registry value's name

//-----------------------------------------------------------
// Registry key names.
// Naming: WZCREGK_* denotes a registry key name
//         WZCREGV_* denotes a registry value name
//         WZCREGK_ABS_* denotes an absolute registry path
//         WZCREGK_REL_* denotes a relative registry path
#define WZCREGK_ABS_PARAMS    L"Software\\Microsoft\\WZCSVC\\Parameters"
#define WZCREGK_REL_INTF      L"Interfaces"     // relative to WZCREG_ABS_ROOT
#define WZCREGV_VERSION       L"LayoutVersion"  // in [WZCREGK_REL_INTF] (REG_DWORD) registry layout version
#define WZCREGV_CTLFLAGS      L"ControlFlags"   // in [WZCREGK_REL_INTF] (REG_DWORD) interface's control flags
#define WZCREGV_INTFSETTINGS  L"ActiveSettings" // in [WZCREGK_REL_INTF] (REG_BINARY=WZC_WLAN_CONFIG) last active settings
#define WZCREGV_STSETTINGS    L"Static#----"    // in [WZCREGK_REL_INTF] (REG_BINARY=WZC_WLAN_CONFIG) static configuration#
                                                // (NOTE: the number of '-' in the string should at least match the number
                                                // of digits in the REG_MAX_STSETTINGS constant!!)
#define WZCREGV_CONTEXT       L"ContextSettings"// registry name for all service specific parameters (service's context)

//-----------------------------------------------------------
// Loads per interface configuration parameters to the persistent
// storage.
// Parameters:
//   hkRoot
//     [in] Opened registry key to the "...WZCSVC\Parameters" location
//   pIntf
//     [in] Interface context to load from the registry
// Returned value:
//     Win32 error code 
DWORD
StoLoadIntfConfig(
    HKEY          hkRoot,
    PINTF_CONTEXT pIntfContext);

//-----------------------------------------------------------
// Loads the list of the static configurations from the registry
// Parameters:
//   hkRoot
//     [in] Opened registry key to the "...WZCSVC\Parameters\Interfaces\{guid}" location
//   nEntries
//     [in] Number of registry entries in the above reg key
//   pIntf
//     [in] Interface context to load the static list into
//   dwRegLayoutVer
//     [in] the version of the registry layout
//   prdBuffer
//     [in] assumed large enough for getting any static config
// Returned value:
//     Win32 error code 
DWORD
StoLoadStaticConfigs(
    HKEY          hkIntf,
    UINT          nEntries,
    PINTF_CONTEXT pIntfContext,
    DWORD         dwRegLayoutVer,
    PRAW_DATA     prdBuffer);

//-----------------------------------------------------------
// Saves all the configuration parameters to the persistent
// storage (registry in our case).
// Uses the global external g_lstIntfHashes.
// Returned value:
//     Win32 error code 
DWORD
StoSaveConfig();

//-----------------------------------------------------------
// Saves the current configuration of the interface to the persistent
// storage.
// Parameters:
//   hkRoot
//     [in] Opened registry key to the "...WZCSVC\Parameters\Interfaces\{guid}" location
//   pIntf
//     [in] Interface context to save to the registry
// Returned value:
//     Win32 error code 
DWORD
StoSaveIntfConfig(
    HKEY          hkIntf,
    PINTF_CONTEXT pIntfContext);

//-----------------------------------------------------------
// Updates the list of static configurations for the given interface in the 
// persistant storage. The new list is saved, whatever configuration was removed
// is taken out of the persistant storage.
// Parameters:
//   hkRoot
//     [in] Opened registry key to the "...WZCSVC\Parameters\Interfaces\{guid}" location
//   pIntf
//     [in] Interface context to take the static list from
//   prdBuffer
//     [in/out] buffer to be used for preparing the registry blobs
// Returned value:
//     Win32 error code 
DWORD
StoUpdateStaticConfigs(
    HKEY          hkIntf,
    PINTF_CONTEXT pIntfContext,
    PRAW_DATA     prdBuffer);


//-----------------------------------------------------------
// Loads from the registry a WZC Configuration, un-protects the WEP key field
// and stores the result in the output param pWzcCfg.
// Parameters:
//   hkCfg
//     [in] Opened registry key to load the WZC configuration from
//   dwRegLayoutVer,
//     [in] registry layout version
//   wszCfgName
//     [in] registry entry name for the WZC configuration
//   pWzcCfg
//     [out] pointer to a WZC_WLAN_CONFIG object that receives the registry data
//   prdBuffer
//     [in] allocated buffer, assumed large enough for getting the registry data!
DWORD
StoLoadWZCConfig(
    HKEY             hkCfg,
    LPWSTR           wszGuid,
    DWORD            dwRegLayoutVer,
    LPWSTR           wszCfgName,
    PWZC_WLAN_CONFIG pWzcCfg,
    PRAW_DATA        prdBuffer);
    
//-----------------------------------------------------------
// Takes the input param pWzcCfg, protects the WEP key field and stores the
// resulting BLOB into the registry.
// Parameters:
//   hkCfg
//     [in] Opened registry key to load the WZC configuration from
//   wszCfgName
//     [in] registry entry name for the WZC configuration
//   pWzcCfg
//     [in] WZC_WLAN_CONFIG object that is written to the registry
//   prdBuffer
//     [in/out] allocated buffer, assumed large enough for getting the registry data!
DWORD
StoSaveWZCConfig(
    HKEY             hkCfg,
    LPWSTR           wszCfgName,
    PWZC_WLAN_CONFIG pWzcCfg,
    PRAW_DATA        prdBuffer);

// StoLoadWZCContext:
// Description: Loads a context from the registry
// Parameters: 
// [out] pwzvCtxt: pointer to a WZC_CONTEXT allocated by user, initialised
// with WZCContextInit. On  success, contains values from registry.  
// [in]  hkRoot, a handle to "...WZCSVC\Parameters"
// Returns: win32 error
DWORD StoLoadWZCContext(HKEY hkRoot, PWZC_CONTEXT pwzcCtxt);

// StoSaveWZCContext:
// Description: Saves a context to the registry. Does not check values. If 
// the registry key dosent exist, it is created.
// Parameters: [in] pwzcCtxt, pointer to a valid WZC_CONTEXT
//             [in] hkRoot,a handle to "...WZCSVC\Parameters"
// Returns: win32 error
DWORD StoSaveWZCContext(HKEY hkRoot, PWZC_CONTEXT pwzcCtxt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\tracing.h ===
#pragma once


#define TRC_NAME        TEXT("WZCTrace")


#ifdef DBG
extern  UINT  g_nLineNo;
extern  LPSTR g_szFileName;
#define DbgPrint(params)     _DebugPrint params
#define DbgAssert(params)       \
{   g_nLineNo = __LINE__;       \
    g_szFileName = __FILE__;    \
    _DebugAssert params;        \
}

#define DbgBinPrint(params)  _DebugBinary params
#else
#define DbgPrint(params)
#define DbgAssert(params)
#define DbgBinPrint(params)
#endif

#define TRC_GENERIC     0x00010000      // logs generic events that did not fit in any other category
#define TRC_TRACK       0x00020000      // logs the code path
#define TRC_MEM         0x00040000      // logs the memory allocations / releases
#define TRC_ERR         0x00080000      // logs error conditions
#define TRC_HASH        0x00100000      // logs hash related stuff
#define TRC_NOTIF       0x00200000      // logs notifications
#define TRC_STORAGE     0x00400000      // logs storage related stuff
#define TRC_SYNC        0x00800000      // logs synchronization related stuff
#define TRC_STATE       0x01000000      // logs state machine related stuff
#define TRC_DATABASE    0x02000000      // logs for database logging
                                        // new log types to be added here.
#define TRC_ASSERT      0x80000000      // logs failed assert conditions

// trace identifier
extern DWORD            g_TraceLog;
extern HANDLE           g_hWzcEventLog;

// debug utility calls
VOID _DebugPrint(DWORD dwFlags, LPCSTR lpFormat, ...);

VOID _DebugAssert(BOOL bChecked, LPCSTR lpFormat, ...);

VOID _DebugBinary(DWORD dwFlags, LPCSTR lpMessage, LPBYTE pBuffer, UINT nBuffLen);

VOID TrcInitialize();

VOID TrcTerminate();

// event logging utility calls
VOID EvtInitialize();

VOID EvtTerminate();

VOID EvtLogWzcError(DWORD dwMsgId, DWORD dwErrCode);

//---------------------------------------------
// Database logging functions
//
#define WZCSVC_DLL "wzcsvc.dll"

typedef struct _Wzc_Db_Record *PWZC_DB_RECORD;

DWORD _DBRecord (
    	DWORD eventID,
        PWZC_DB_RECORD  pDbRecord,
        va_list *pvaList);

typedef struct _INTF_CONTEXT *PINTF_CONTEXT;

DWORD DbLogWzcError (
	DWORD           eventID,
    PINTF_CONTEXT   pIntfContext,
	...
 	);

DWORD DbLogWzcInfo (
	DWORD eventID,
    PINTF_CONTEXT   pIntfContext,
	...
 	);

// number of buffers available for log params formatting
#define DBLOG_SZFMT_BUFFS   10
// lenght of each buffer used to format log params
#define DBLOG_SZFMT_SIZE    256

// utility macro to convert a hexa digit into its value
#define HEX2WCHAR(c)         ((c)<=9 ? L'0'+ (c) : L'A' + (c) - 10)
// separator char to be used when formatting a MAC address
#define MAC_SEPARATOR        L'-'

// Initializes the WZC_DB_RECORD
DWORD DbLogInitDbRecord(
    DWORD dwCategory,
    PINTF_CONTEXT pIntfContext,
    PWZC_DB_RECORD pDbRecord
);

// Formats an SSID in the given formatting buffer
LPWSTR DbLogFmtSSID(
    UINT                nBuff,  // index of the format buffer to use (0 .. DBLOG_SZFMT_BUFFS)
    PNDIS_802_11_SSID   pndSSid);

// Formats a BSSID (MAC address) in the given formatting buffer
LPWSTR DbLogFmtBSSID(
    UINT                     nBuff,
    NDIS_802_11_MAC_ADDRESS  ndBSSID);

// Formats the INTF_CONTEXT::dwCtlFlags field for logging
DWORD DbLogFmtFlags(
        LPWSTR  wszBuffer,      // buffer to place the result into
        LPDWORD pnchBuffer,     // in: num of chars in the buffer; out: number of chars written to the buffer
        DWORD   dwFlags);       // interface flags to log

// Formats a WZC_WLAN_CONFIG structure for logging
DWORD DbLogFmtWConfig(
        LPWSTR wszBuffer,           // buffer to place the result into
        LPDWORD pnchBuffer,         // in: num of chars in the buffer; out: number of chars written to the buffer
        PWZC_WLAN_CONFIG pWzcCfg);  // WZC_WLAN_CONFIG object to log
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\tracing.c ===
#include <precomp.h>
#include "zcdblog.h"
#include "wzcsvc.h"
#include "intflist.h"
#include "tracing.h"

// internal-use tracing variables
UINT  g_nLineNo;
LPSTR g_szFileName;

// handles for database usage
extern JET_SESID 		serverSession;
extern JET_DBID  		databasehandle;
extern JET_TABLEID 	tablehandle;
extern SESSION_CONTAINER sesscon;

// global buffers to be used when formatting database
// logging message parameters
WCHAR g_wszDbLogBuffer[DBLOG_SZFMT_BUFFS][DBLOG_SZFMT_SIZE];

// global tracing variables
DWORD g_TraceLog = 0;

// global handle to the event log
HANDLE g_hWzcEventLog = NULL;

// debug utility calls
VOID _DebugPrint(DWORD dwFlags, LPCSTR lpFormat, ...)
{
    va_list arglist;
    va_start(arglist, lpFormat);

    TraceVprintfExA(
        g_TraceLog,
        dwFlags | TRACE_USE_MASK,
        lpFormat,
        arglist);
}

// if bCheck is not true, print out the assert message & user defined string.
VOID _DebugAssert(BOOL bChecked, LPCSTR lpFormat, ...)
{
    if (!bChecked)
    {
        va_list arglist;
        CHAR    pBuffer[500];
        LPSTR   pFileName;
    
        pFileName = strrchr(g_szFileName, '\\');
        if (pFileName == NULL)
            pFileName = g_szFileName;
        else
            pFileName++;
        sprintf(pBuffer,"##Assert %s:%d## ", pFileName, g_nLineNo);
        strcat(pBuffer, lpFormat);

        va_start(arglist, lpFormat); 
        TraceVprintfExA(
            g_TraceLog,
            TRC_ASSERT | TRACE_USE_MASK,
            pBuffer,
            arglist);
    }
}

VOID _DebugBinary(DWORD dwFlags, LPCSTR lpMessage, LPBYTE pBuffer, UINT nBuffLen)
{
    CHAR strHex[128];
    UINT nMsgLen = strlen(lpMessage);

    if (3*nBuffLen >= 120)
    {
        strcpy(strHex, "##Binary data too large##");
    }
    else
    {
        LPSTR pHexDigit = strHex;
        UINT i = nBuffLen;

        while(i > 0)
        {
            sprintf(pHexDigit, "%02x ", *pBuffer);
            pHexDigit += 3;
            pBuffer++;
            i--;
        }
        *pHexDigit = '\0';
    }

    TracePrintfExA(
        g_TraceLog,
        dwFlags | TRACE_USE_MASK,
        "%s [%d]:{%s}", lpMessage, nBuffLen, strHex);
}

VOID TrcInitialize()
{
#ifdef DBG
    g_TraceLog = TraceRegister(TRC_NAME);
#endif
}

VOID TrcTerminate()
{
#ifdef DBG
    TraceDeregister(g_TraceLog);
#endif
}

//------------- Event Logging functions -------------------
VOID EvtInitialize()
{
    g_hWzcEventLog = RouterLogRegisterW(L"WZCSVC");
}

VOID EvtTerminate()
{
    if (g_hWzcEventLog != NULL)
    {
        RouterLogDeregisterW(g_hWzcEventLog);
        g_hWzcEventLog = NULL;
    }
}

VOID EvtLogWzcError(DWORD dwMsgId, DWORD dwErrCode)
{
    if (g_hWzcEventLog != NULL)
    {
        RouterLogErrorW(
            g_hWzcEventLog,
            dwMsgId,
            0,              // 0 insertion strings
            NULL,           // no insertion strings
            dwErrCode);
    }
}

//------------- Database Logging functions -------------------
DWORD _DBRecord (
    	DWORD eventID,
        PWZC_DB_RECORD  pDbRecord,
        va_list *pvaList)
{
    DWORD   dwErr = ERROR_SUCCESS;
    WCHAR   wchBuffer[MAX_RAW_DATA_SIZE/sizeof(WCHAR)];

    if (g_hInstance == NULL)
        dwErr = ERROR_DLL_INIT_FAILED;

    if (dwErr == ERROR_SUCCESS)
    {
    	// format the message
    	if (FormatMessageW( 
    	        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK,
    		    g_hInstance,
    		    eventID,
    		    0, // Default language
    		    wchBuffer,
    		    sizeof(wchBuffer)/sizeof(WCHAR),
    		    pvaList) == 0)
        {
            dwErr = GetLastError();
        }
    }

    if (dwErr == ERROR_SUCCESS)
    {
        pDbRecord->message.pData = (LPBYTE)wchBuffer;
        pDbRecord->message.dwDataLen = sizeof(WCHAR)*(wcslen(wchBuffer) + 1);
    
        //make a insertion
        dwErr = AddWZCDbLogRecord(NULL, 0, pDbRecord, NULL);
    }

    return dwErr;
}

DWORD DbLogWzcError (
	DWORD           eventID,
    PINTF_CONTEXT   pIntfContext,
	...
 	)
{
    DWORD           dwErr = ERROR_SUCCESS;
    va_list         argList;
    WZC_DB_RECORD   DbRecord = {0};
    BOOL            bLogEnabled;

    if (!g_wzcInternalCtxt.bValid)
    {
        dwErr = ERROR_ARENA_TRASHED;
        goto exit;
    }

    va_start(argList, pIntfContext);

    EnterCriticalSection(&g_wzcInternalCtxt.csContext);
    bLogEnabled = ((g_wzcInternalCtxt.wzcContext.dwFlags & WZC_CTXT_LOGGING_ON) != 0);
    LeaveCriticalSection(&g_wzcInternalCtxt.csContext);

    // If the database is not opened or the logging functionality is disabled,
    // do not record any thing
    if (!bLogEnabled || !IsDBOpened())
    	goto exit;

    // prepare the info that is about to be logged.
    // get the service specific info first (i.e WZC specific part)
    // then build up the message.
    DbLogInitDbRecord(DBLOG_CATEG_ERR, pIntfContext, &DbRecord);

    dwErr = _DBRecord(
                eventID,
                &DbRecord,
                &argList);
exit:
    return dwErr;
}

DWORD DbLogWzcInfo (
	DWORD           eventID,
    PINTF_CONTEXT   pIntfContext,
	...
 	)
{
    DWORD           dwErr = ERROR_SUCCESS;
    va_list         argList;
    WZC_DB_RECORD   DbRecord = {0};
    BOOL            bLogEnabled;
    LPWSTR          wszContext = NULL;
    DWORD           nchContext = 0;

    if (!g_wzcInternalCtxt.bValid)
    {
        dwErr = ERROR_ARENA_TRASHED;
        goto exit;
    }

    va_start(argList, pIntfContext);

    EnterCriticalSection(&g_wzcInternalCtxt.csContext);
    bLogEnabled = ((g_wzcInternalCtxt.wzcContext.dwFlags & WZC_CTXT_LOGGING_ON) != 0);
    LeaveCriticalSection(&g_wzcInternalCtxt.csContext);

    // If the database is not opened or the logging functionality is disabled,
    // do not record any thing
    if (!bLogEnabled || !IsDBOpened())
    	goto exit;

    // prepare the info that is about to be logged.
    // get the service specific info first (i.e WZC specific part)
    // then build up the message.
    DbLogInitDbRecord(DBLOG_CATEG_INFO, pIntfContext, &DbRecord);

    // if WZCSVC_USR_CFGCHANGE, build the context string
    if (eventID == WZCSVC_USR_CFGCHANGE &&
        pIntfContext != NULL)
    {
        DWORD nOffset = 0;
        DWORD nchWritten = 0;
        nchContext = 64; // large enough for "Flags = 0x00000000"

        if (pIntfContext->pwzcPList != NULL)
        {
            // large enough for "{SSID, Infrastructure, Flags}"
            nchContext += pIntfContext->pwzcPList->NumberOfItems * 128;
        }
        wszContext = (LPWSTR)MemCAlloc(nchContext * sizeof(WCHAR));
        if (wszContext == NULL)
            dwErr = GetLastError();

        if (dwErr == ERROR_SUCCESS)
        {
            nchWritten = nchContext;
            dwErr = DbLogFmtFlags(
                        wszContext, 
                        &nchWritten,
                        pIntfContext->dwCtlFlags);
            if (dwErr == ERROR_SUCCESS)
                nOffset += nchWritten;
        }
        
        if (dwErr == ERROR_SUCCESS && pIntfContext->pwzcPList != NULL)
        {
            UINT i;

            for (i = 0; i < pIntfContext->pwzcPList->NumberOfItems; i++)
            {
                nchWritten = nchContext - nOffset;
                dwErr = DbLogFmtWConfig(
                            wszContext + nOffset,
                            &nchWritten,
                            &(pIntfContext->pwzcPList->Config[i]));
                if (dwErr != ERROR_SUCCESS)
                    break;
                nOffset += nchWritten;
            }
        }

        if (dwErr == ERROR_SUCCESS)
        {
            DbRecord.context.pData = (LPBYTE)wszContext;
            DbRecord.context.dwDataLen = (wcslen(wszContext) + 1) * sizeof(WCHAR);
        }
    }
    else if (eventID == WZCSVC_BLIST_CHANGED &&
        pIntfContext != NULL &&
        pIntfContext->pwzcBList != NULL &&
        pIntfContext->pwzcBList->NumberOfItems != 0)
    {
        DWORD nOffset = 0;
        DWORD nchWritten = 0;

        nchContext = pIntfContext->pwzcBList->NumberOfItems * 128;
        wszContext = (LPWSTR)MemCAlloc(nchContext * sizeof(WCHAR));
        if (wszContext == NULL)
            dwErr = GetLastError();

        if (dwErr == ERROR_SUCCESS)
        {
            UINT i;

            for (i = 0; i < pIntfContext->pwzcBList->NumberOfItems; i++)
            {
                nchWritten = nchContext - nOffset;
                dwErr = DbLogFmtWConfig(
                            wszContext + nOffset,
                            &nchWritten,
                            &(pIntfContext->pwzcBList->Config[i]));
                if (dwErr != ERROR_SUCCESS)
                    break;
                nOffset += nchWritten;
            }
        }

        if (dwErr == ERROR_SUCCESS)
        {
            DbRecord.context.pData = (LPBYTE)wszContext;
            DbRecord.context.dwDataLen = (wcslen(wszContext) + 1) * sizeof(WCHAR);
        }
    }

    dwErr = _DBRecord(
                eventID,
                &DbRecord,
                &argList);
exit:

    MemFree(wszContext);
    return dwErr;
}

// Initializes the WZC_DB_RECORD
DWORD DbLogInitDbRecord(
    DWORD dwCategory,
    PINTF_CONTEXT pIntfContext,
    PWZC_DB_RECORD pDbRecord)
{
    DWORD dwErr = ERROR_SUCCESS;
    if (pDbRecord == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        ZeroMemory(pDbRecord, sizeof(WZC_DB_RECORD));
        pDbRecord->componentid = DBLOG_COMPID_WZCSVC;
        pDbRecord->category    = dwCategory;
        if (pIntfContext != NULL)
        {
            pDbRecord->ssid.pData = (LPBYTE)DbLogFmtSSID(5,&(pIntfContext->wzcCurrent.Ssid));
            pDbRecord->ssid.dwDataLen = sizeof(WCHAR)*(wcslen((LPWSTR)pDbRecord->ssid.pData) + 1);

            pDbRecord->localmac.pData = (LPBYTE)DbLogFmtBSSID(6, pIntfContext->ndLocalMac);
            pDbRecord->localmac.dwDataLen = sizeof(WCHAR)*(wcslen((LPWSTR)pDbRecord->localmac.pData) + 1);

            pDbRecord->remotemac.pData = (LPBYTE)DbLogFmtBSSID(7, pIntfContext->wzcCurrent.MacAddress);
            pDbRecord->remotemac.dwDataLen = sizeof(WCHAR)*(wcslen((LPWSTR)pDbRecord->remotemac.pData) + 1);
        }
    }

    return dwErr;
}

// Formats an SSID in the given formatting buffer
LPWSTR DbLogFmtSSID(
    UINT                nBuff,  // index of the format buffer to use (0 .. DBLOG_SZFMT_BUFFS)
    PNDIS_802_11_SSID   pndSSid)
{
    UINT nFmtLen;

    DbgAssert((nBuff < DBLOG_SZFMT_SIZE, "Illegal buffer index in DbLogFmtSSID"));

    nFmtLen = MultiByteToWideChar(
                CP_ACP,
                0,
                pndSSid->Ssid,
                min (pndSSid->SsidLength, DBLOG_SZFMT_SIZE-1),
                g_wszDbLogBuffer[nBuff],
                DBLOG_SZFMT_SIZE-1);

    if (nFmtLen == DBLOG_SZFMT_SIZE-1)
        wcscpy(&(g_wszDbLogBuffer[nBuff][DBLOG_SZFMT_SIZE-3]), L"..");
    else
        g_wszDbLogBuffer[nBuff][nFmtLen] = '\0';

    return g_wszDbLogBuffer[nBuff];
}

// Formats a BSSID (MAC address) in the given formatting buffer
LPWSTR DbLogFmtBSSID(
    UINT                     nBuff,
    NDIS_802_11_MAC_ADDRESS  ndBSSID)
{
    UINT i, j;
    BOOL bAllZero = TRUE;

    DbgAssert((nBuff < DBLOG_SZFMT_SIZE, "Illegal buffer index in DbLogFmtSSID"));

    g_wszDbLogBuffer[nBuff][0] = L'\0';
    for (j = 0, i = 0; i < sizeof(NDIS_802_11_MAC_ADDRESS); i++)
    {
        BYTE nHex;

        if (ndBSSID[i] != 0)
            bAllZero = FALSE;

        nHex = (ndBSSID[i] & 0xf0) >> 4;
        g_wszDbLogBuffer[nBuff][j++] = HEX2WCHAR(nHex);
        nHex = (ndBSSID[i] & 0x0f);
        g_wszDbLogBuffer[nBuff][j++] = HEX2WCHAR(nHex);
        g_wszDbLogBuffer[nBuff][j++] = MAC_SEPARATOR;
    }

    if (bAllZero)
        g_wszDbLogBuffer[nBuff][0] = L'\0';
    else if (j > 0)
        g_wszDbLogBuffer[nBuff][j-1] = L'\0';

    return g_wszDbLogBuffer[nBuff];
}

// Formats the INTF_CONTEXT::dwCtlFlags field for logging
DWORD DbLogFmtFlags(
        LPWSTR  wszBuffer,      // buffer to place the result into
        LPDWORD pnchBuffer,     // in: num of chars in the buffer; out: number of chars written to the buffer
        DWORD   dwFlags)        // interface flags to log
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT nchBuffer;
    LPVOID pvArgs[5];
    WCHAR wszArgs[5][33];

    if (pnchBuffer == NULL || *pnchBuffer == 0)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }
    nchBuffer = (*pnchBuffer);
    *pnchBuffer = 0;

    if (g_hInstance == NULL)
    {
        dwErr = ERROR_DLL_INIT_FAILED;
        goto exit;
    }

    pvArgs[0] = _itow((dwFlags & INTFCTL_ENABLED) != 0, wszArgs[0], 10);
    pvArgs[1] = _itow((dwFlags & INTFCTL_FALLBACK) != 0, wszArgs[1], 10);
    pvArgs[2] = _itow((dwFlags & INTFCTL_CM_MASK), wszArgs[2], 10);
    pvArgs[3] = _itow((dwFlags & INTFCTL_VOLATILE) != 0, wszArgs[3], 10);
    pvArgs[4] = _itow((dwFlags & INTFCTL_POLICY) != 0, wszArgs[4], 10);

    // format the message
    *pnchBuffer = FormatMessageW( 
    	            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK | FORMAT_MESSAGE_ARGUMENT_ARRAY,
    		        g_hInstance,
    		        WZCSVC_DETAILS_FLAGS,
    		        0, // Default language
    		        wszBuffer,
    		        nchBuffer,
    		        (va_list*)pvArgs);

    if (*pnchBuffer == 0)
        dwErr = GetLastError();

exit:
    return dwErr;
}

// Formats a WZC_WLAN_CONFIG structure for logging
DWORD DbLogFmtWConfig(
        LPWSTR wszBuffer,           // buffer to place the result into
        LPDWORD pnchBuffer,         // in: num of chars in the buffer; out: number of chars written to the buffer
        PWZC_WLAN_CONFIG pWzcCfg)   // WZC_WLAN_CONFIG object to log
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT nchBuffer;
    LPVOID pvArgs[5];
    WCHAR wszArgs[4][33];

    if (pnchBuffer == NULL || *pnchBuffer == 0)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }
    nchBuffer = (*pnchBuffer);
    *pnchBuffer = 0;

    if (g_hInstance == NULL)
    {
        dwErr = ERROR_DLL_INIT_FAILED;
        goto exit;
    }

    pvArgs[0] = (LPVOID)DbLogFmtSSID(8, &(pWzcCfg->Ssid));
    pvArgs[1] = _itow(pWzcCfg->InfrastructureMode, wszArgs[0], 10);
    pvArgs[2] = _itow(pWzcCfg->Privacy, wszArgs[1], 10);
    pvArgs[3] = _itow((pWzcCfg->dwCtlFlags & WZCCTL_VOLATILE) != 0, wszArgs[2], 10);
    pvArgs[4] = _itow((pWzcCfg->dwCtlFlags & WZCCTL_POLICY) != 0, wszArgs[3], 10);

    // format the message
    *pnchBuffer = FormatMessageW( 
    	            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK | FORMAT_MESSAGE_ARGUMENT_ARRAY,
    		        g_hInstance,
    		        WZCSVC_DETAILS_WCONFIG,
    		        0, // Default language
    		        wszBuffer,
    		        nchBuffer,
    		        (va_list*)pvArgs);

    if (*pnchBuffer == 0)
        dwErr = GetLastError();

exit:
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\storage.c ===
#include <precomp.h>
#include "tracing.h"
#include "utils.h"
#include "intflist.h"
#include "hash.h"
#include "storage.h"
#include "rpcsrv.h"
#include "wzcsvc.h"

//-----------------------------------------------------------
// Loads per interface configuration parameters to the persistent
// storage.
// Parameters:
//   hkRoot
//     [in] Opened registry key to the "...WZCSVC\Parameters" location
//   pIntf
//     [in] Interface context to load from the registry
// Returned value:
//     Win32 error code 
DWORD
StoLoadIntfConfig(
    HKEY          hkRoot,
    PINTF_CONTEXT pIntfContext)
{
    DWORD           dwErr = ERROR_SUCCESS;
    HKEY            hkIntf = NULL;
    LPWSTR          pKeyName = NULL;
    UINT            nLength;
    UINT            nType;
    DWORD           dwData;
    DWORD           dwVersion;
    UINT            nEntries;
    RAW_DATA        rdBuffer = {0, NULL};
    DWORD           dwGuidLen = 0;

    DbgPrint((TRC_TRACK|TRC_STORAGE,"[StoLoadIntfConfig(%S)", 
             (pIntfContext->wszGuid == NULL)? L"Global" : pIntfContext->wszGuid));

    if (pIntfContext->wszGuid != NULL)
        dwGuidLen = wcslen(pIntfContext->wszGuid) + 1;

    if (hkRoot == NULL)
    {
        // if no root has been provided allocate space for the absolute path to WZC params,
        // the relative path to the interfaces location, the guid plus 2 '\' and one null terminator
        pKeyName = MemCAlloc((
                       wcslen(WZCREGK_ABS_PARAMS) + 
                       dwGuidLen + 
                       wcslen(WZCREGK_REL_INTF) + 
                       2)*sizeof(WCHAR));
        if (pKeyName == 0)
        {
            dwErr = GetLastError();
            goto exit;
        }
        if (dwGuidLen != 0)
            wsprintf(pKeyName,L"%s\\%s\\%s", WZCREGK_ABS_PARAMS, WZCREGK_REL_INTF, pIntfContext->wszGuid);
        else
            wsprintf(pKeyName,L"%s\\%s", WZCREGK_ABS_PARAMS, WZCREGK_REL_INTF);

        hkRoot = HKEY_LOCAL_MACHINE;
    }
    else
    {
        // if a root has been provided, allocate space just for the "Interfaces\{guid}"
        // add 2 wchars: one for the '\' after 'Interfaces' and one for the null terminator
        pKeyName = MemCAlloc((wcslen(WZCREGK_REL_INTF) + dwGuidLen + 1)*sizeof(WCHAR));
        if (pKeyName == NULL)
        {
            dwErr = GetLastError();
            goto exit;
        }
        // create the local key name
        if (dwGuidLen != 0)
            wsprintf(pKeyName,L"%s\\%s", WZCREGK_REL_INTF, pIntfContext->wszGuid);
        else
            wsprintf(pKeyName,L"%s", WZCREGK_REL_INTF);
    }

    // open the interface's key first
    dwErr = RegOpenKeyEx(
                hkRoot,
                pKeyName,
                0,
                KEY_READ,
                &hkIntf);

    // break out if not successful
    if (dwErr != ERROR_SUCCESS)
    {
        // if the key is not there, no harm, go on with the defaults
        if (dwErr == ERROR_FILE_NOT_FOUND)
            dwErr = ERROR_SUCCESS;
        goto exit;
    }

    // get first the whole number of values in this key and the size of the largest data
    dwErr = RegQueryInfoKey(
                hkIntf,               // handle to key
                NULL,                 // class buffer
                NULL,                 // size of class buffer
                NULL,                 // reserved
                NULL,                 // number of subkeys
                NULL,                 // longest subkey name
                NULL,                 // longest class string
                &nEntries,            // number of value entries
                NULL,                 // longest value name
                &rdBuffer.dwDataLen,  // longest value data
                NULL,                 // descriptor length
                NULL);                // last write time
    // this call should better be not failing
    if (dwErr != ERROR_SUCCESS)
        goto exit;
    // if there are no keys at all, exit now.
    if (rdBuffer.dwDataLen == 0)
        goto exit;

    // prepare the receiving buffer for the size of the largest data
    // this will be used when reading in the active settings and each
    // of the static configurations
    rdBuffer.pData = MemCAlloc(rdBuffer.dwDataLen);
    if (rdBuffer.pData == NULL)
    {
        dwErr = GetLastError();
        goto exit;
    }

    // load the registry layout version information
    // don't worry about the return code. In case of any error,
    // we'll assume we deal with the latest registry layout
    nLength = sizeof(DWORD);
    dwVersion = REG_LAYOUT_VERSION;
    dwErr = RegQueryValueEx(
                hkIntf,
                WZCREGV_VERSION,
                0,
                &nType,
                (LPBYTE)&dwVersion,
                &nLength);

    // load the interface's control flags
    nLength = sizeof(DWORD);
    dwData = 0;
    dwErr = RegQueryValueEx(
                hkIntf,
                WZCREGV_CTLFLAGS,
                0,
                &nType,
                (LPBYTE)&dwData,
                &nLength);
    // if this entry is not there, no harm, rely on defaults
    // break out only in case of any other error
    if (dwErr != ERROR_SUCCESS && dwErr != ERROR_FILE_NOT_FOUND)
        goto exit;

    // copy the control flags to the INTF_CONTEXT only in the case the registry entry
    // has the REG_DWORD type and the right length
    if (dwErr == ERROR_SUCCESS &&
        nType == REG_DWORD &&
        nLength == sizeof(REG_DWORD))
    {
        pIntfContext->dwCtlFlags = dwData & INTFCTL_PUBLIC_MASK;
    }

    // load the last active settings
    //
    // NOTE: loading the whole set of parameters from below (excluding here the static list)
    // could be useless since these params should come directly from querying the driver. However
    // we load them here in the attemt to restore a previously saved state - at some point this
    // information could be useful in the configuration selection logic.
    //
    ZeroMemory(&pIntfContext->wzcCurrent, sizeof(WZC_WLAN_CONFIG));
    pIntfContext->wzcCurrent.Length = sizeof(WZC_WLAN_CONFIG);
    dwErr = StoLoadWZCConfig(
                hkIntf,
                NULL,   // not passing a GUID here means don't mess with 802.1X setting!
                dwVersion,
                WZCREGV_INTFSETTINGS,
                &pIntfContext->wzcCurrent,
                &rdBuffer);
    // if this entry is not there, no harm, rely on defaults
    // break out in case of any other error
    if (dwErr != ERROR_SUCCESS && dwErr != ERROR_FILE_NOT_FOUND)
        goto exit;

    // load the static configurations for this interface
    dwErr = StoLoadStaticConfigs(
                hkIntf,
                nEntries,
                pIntfContext,
                dwVersion,
                &rdBuffer);
    DbgAssert((dwErr == ERROR_SUCCESS, "Failed to load the static configurations"));

exit:
    if (hkIntf != NULL)
        RegCloseKey(hkIntf);

    MemFree(pKeyName);
    MemFree(rdBuffer.pData);

    DbgPrint((TRC_TRACK|TRC_STORAGE,"StoLoadIntfConfig]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Loads the list of the static configurations from the registry
// Parameters:
//   hkRoot
//     [in] Opened registry key to the "...WZCSVC\Parameters\Interfaces\{guid}" location
//   nEntries
//     [in] Number of registry entries in the above reg key
//   pIntf
//     [in] Interface context to load the static list into
//   dwRegLayoutVer
//     [in] the version of the registry layout
//   prdBuffer
//     [in] assumed large enough for getting any static config
// Returned value:
//     Win32 error code 
DWORD
StoLoadStaticConfigs(
    HKEY          hkIntf,
    UINT          nEntries,
    PINTF_CONTEXT pIntfContext,
    DWORD         dwRegLayoutVer,
    PRAW_DATA     prdBuffer)
{
    DWORD               dwErr = ERROR_SUCCESS;
    UINT                nPrefrd, nIdx;
    WCHAR               wszStConfigName[sizeof(WZCREGV_STSETTINGS)/sizeof(WCHAR)];
    LPWSTR              pwszStConfigNum;
    PWZC_WLAN_CONFIG    pwzcPArray = NULL;
    UINT                nStructSize = (dwRegLayoutVer == REG_LAYOUT_VERSION) ? 
                            sizeof(WZC_WLAN_CONFIG) : 
                            FIELD_OFFSET(WZC_WLAN_CONFIG, rdUserData);

    DbgPrint((TRC_TRACK|TRC_STORAGE,"[StoLoadStaticConfigs"));

    // we need to scan all the entries named "Static#0001, Static#0002, etc". We could assume 
    // they are numbered sequentially, but if we want to be smart we can't rely on this assumption.
    // There could be a user intervention there (i.e deleting by hand some of the configs directly
    // from the registry hence breaking the sequence).
    // So, what we'll do is:
    // 1. allocate a buffer large enough to hold so many static configs.
    // 2. iterate through all the values - if a value is Static#** and has the right length, type,
    //    and value, copy it in the buffer and keep a count of them.
    // 3. copy the exact number of static configs to the INTF_CONTEXT allocating as much memory
    //    as needed.

    // get the estimated memory for all the static entries.
    pwzcPArray = (PWZC_WLAN_CONFIG) MemCAlloc(nEntries * sizeof(WZC_WLAN_CONFIG));
    if (pwzcPArray == NULL)
    {
        dwErr = GetLastError();
        goto exit;
    }

    // build the prefix for the static configuration's name
    wcscpy(wszStConfigName, WZCREGV_STSETTINGS);
    pwszStConfigNum = wcschr(wszStConfigName, REG_STSET_DELIM);

    // iterate through the whole set of entries in this key
    for (nIdx = 0, nPrefrd = 0;
         nIdx < nEntries && nPrefrd < nEntries;
         nIdx++)
    {
        // complete the configuration's name
        wsprintf(pwszStConfigNum, L"%04x", nIdx);

        dwErr = StoLoadWZCConfig(
                    hkIntf,
                    pIntfContext->wszGuid,
                    dwRegLayoutVer,
                    wszStConfigName,
                    &(pwzcPArray[nPrefrd]),
                    prdBuffer);

        if (dwErr == ERROR_SUCCESS)
            nPrefrd++;
    }

    DbgPrint((TRC_STORAGE,"Uploading %d static configurations", nPrefrd));

    // no matter what error we might have had till now, we can safely reset it.
    dwErr = ERROR_SUCCESS;

    // here, pwzcPArray has nPrefrd static configurations, in the correct order
    if (pIntfContext->pwzcPList != NULL)
        MemFree(pIntfContext->pwzcPList);

    // if there is anything to upload into the INTF_CONTEXT, do it now
    if (nPrefrd > 0)
    {
        pIntfContext->pwzcPList = (PWZC_802_11_CONFIG_LIST)
                                   MemCAlloc(sizeof(WZC_802_11_CONFIG_LIST) + (nPrefrd-1)*sizeof(WZC_WLAN_CONFIG));

        if (pIntfContext->pwzcPList == NULL)
        {
            dwErr = GetLastError();
            goto exit;
        }

        pIntfContext->pwzcPList->NumberOfItems = nPrefrd;
        pIntfContext->pwzcPList->Index = nPrefrd;
        memcpy(&(pIntfContext->pwzcPList->Config), pwzcPArray, nPrefrd*sizeof(WZC_WLAN_CONFIG));
    }

exit:
    if (pwzcPArray != NULL)
        MemFree(pwzcPArray);

    DbgPrint((TRC_TRACK|TRC_STORAGE,"StoLoadStaticConfigs]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Saves all the configuration parameters to the persistant
// storage (registry in our case).
// Uses the global external g_lstIntfHashes.
// Returned value:
//     Win32 error code 
DWORD
StoSaveConfig()
{
    DWORD       dwErr = ERROR_SUCCESS;
    HKEY        hkRoot = NULL;
    PLIST_ENTRY pEntry;

    DbgPrint((TRC_TRACK|TRC_STORAGE,"[StoSaveConfig"));

    // open the root key first
    dwErr = RegCreateKeyExW(
                HKEY_LOCAL_MACHINE,
                WZCREGK_ABS_PARAMS,
                0,
                NULL,
                0,
                KEY_WRITE,
                NULL,
                &hkRoot,
                NULL);

    // failure at this point breaks the function
    if (dwErr != ERROR_SUCCESS)
        goto exit;

    if (g_lstIntfHashes.bValid)
    {
        // lock the hashes since we're iterating through all
        // the interfaces contexts
        EnterCriticalSection(&g_lstIntfHashes.csMutex);

        for (pEntry = g_lstIntfHashes.lstIntfs.Flink;
             pEntry != &g_lstIntfHashes.lstIntfs;
             pEntry = pEntry->Flink)
        {
            PINTF_CONTEXT pIntfContext;

            pIntfContext = CONTAINING_RECORD(pEntry, INTF_CONTEXT, Link);

            // save per interface configuration settings
            dwErr = StoSaveIntfConfig(hkRoot, pIntfContext);
            if (dwErr != ERROR_SUCCESS)
            {
                // some event logging should be added here in the future
                DbgAssert((FALSE, "Couldn't save interface configuration. Ignore and go on!"));
                dwErr = ERROR_SUCCESS;
            }
        }

        LeaveCriticalSection(&g_lstIntfHashes.csMutex);
    }

    if (g_wzcInternalCtxt.bValid)
    {
        //Save users preferences
        EnterCriticalSection(&g_wzcInternalCtxt.csContext);
        dwErr = StoSaveWZCContext(hkRoot, &g_wzcInternalCtxt.wzcContext);
        DbgAssert((dwErr == ERROR_SUCCESS, "Couldn't save service context. Ignore and go on!"));

        // save the global interface template
        dwErr = StoSaveIntfConfig(NULL, g_wzcInternalCtxt.pIntfTemplate);
        DbgAssert((dwErr == ERROR_SUCCESS, "Couldn't save the global interface template. Ignore and go on!"));

        dwErr = ERROR_SUCCESS;
        LeaveCriticalSection(&g_wzcInternalCtxt.csContext);
    }

exit:
    if (hkRoot != NULL)
        RegCloseKey(hkRoot);

    DbgPrint((TRC_TRACK|TRC_STORAGE,"StoSaveConfig]=%d", dwErr));
    return dwErr;
}


//-----------------------------------------------------------
// Saves per interface configuration parameters to the persistant
// storage.
// Parameters:
//   hkRoot
//     [in] Opened registry key to the "...WZCSVC\Parameters" location
//   pIntf
//     [in] Interface context to save to the registry
// Returned value:
//     Win32 error code 
DWORD
StoSaveIntfConfig(
    HKEY          hkRoot,
    PINTF_CONTEXT pIntfContext)
{
    DWORD           dwErr = ERROR_SUCCESS;
    HKEY            hkIntf = NULL;
    LPWSTR          pKeyName = NULL;
    DWORD           dwLayoutVer = REG_LAYOUT_VERSION;
    DWORD           dwCtlFlags;
    RAW_DATA        rdBuffer = {0, NULL};
    DWORD           dwGuidLen = 0;

    DbgPrint((TRC_TRACK|TRC_STORAGE,"[StoSaveIntfConfig(%S)", 
             (pIntfContext->wszGuid == NULL) ? L"Global" : pIntfContext->wszGuid));

    if (pIntfContext == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if (pIntfContext->wszGuid != NULL)
        dwGuidLen = wcslen(pIntfContext->wszGuid) + 1;

    if (hkRoot == NULL)
    {
        // if no root has been provided allocate space for the absolute path to WZC params,
        // the relative path to the interfaces location, the guid plus 2 '\' and one null terminator
        pKeyName = MemCAlloc((
                       wcslen(WZCREGK_ABS_PARAMS) + 
                       dwGuidLen + 
                       wcslen(WZCREGK_REL_INTF) + 
                       2)*sizeof(WCHAR));
        if (pKeyName == 0)
        {
            dwErr = GetLastError();
            goto exit;
        }

        if (dwGuidLen != 0)
            wsprintf(pKeyName,L"%s\\%s\\%s", WZCREGK_ABS_PARAMS, WZCREGK_REL_INTF, pIntfContext->wszGuid);
        else
            wsprintf(pKeyName,L"%s\\%s", WZCREGK_ABS_PARAMS, WZCREGK_REL_INTF);

        hkRoot = HKEY_LOCAL_MACHINE;
    }
    else
    {
        // if a root has been provided, allocate space just for the "Interfaces\{guid}"
        // add 2 wchars: one for the '\' after 'Interfaces' and one for the null terminator
        pKeyName = MemCAlloc((dwGuidLen + wcslen(WZCREGK_REL_INTF) + 1)*sizeof(WCHAR));
        if (pKeyName == NULL)
        {
            dwErr = GetLastError();
            goto exit;
        }
        // create the local key name
        if (dwGuidLen != 0)
            wsprintf(pKeyName,L"%s\\%s", WZCREGK_REL_INTF, pIntfContext->wszGuid);
        else
            wsprintf(pKeyName,L"%s", WZCREGK_REL_INTF);
    }

    // open the interface's key first
    dwErr = RegCreateKeyExW(
                hkRoot,
                pKeyName,
                0,
                NULL,
                0,
                KEY_QUERY_VALUE | KEY_WRITE,
                NULL,
                &hkIntf,
                NULL);
    // failure at this point breaks the function
    if (dwErr != ERROR_SUCCESS)
        goto exit;

    // set the registry layout version value
    dwErr = RegSetValueEx(
                hkIntf,
                WZCREGV_VERSION,
                0,
                REG_DWORD,
                (LPBYTE)&dwLayoutVer,
                sizeof(DWORD));
    DbgAssert((dwErr == ERROR_SUCCESS, "Can't write %S=%d to the registry", WZCREGV_VERSION, dwLayoutVer));

    // set the interface's control flags only if they are not volatile
    dwCtlFlags = pIntfContext->dwCtlFlags;
    if (!(dwCtlFlags & INTFCTL_VOLATILE))
    {
        dwCtlFlags &= ~INTFCTL_OIDSSUPP;
        dwErr = RegSetValueEx(
                    hkIntf,
                    WZCREGV_CTLFLAGS,
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwCtlFlags,
                    sizeof(DWORD));
        DbgAssert((dwErr == ERROR_SUCCESS, "Can't write %S=0x%08x to the registry", WZCREGV_CTLFLAGS, pIntfContext->dwCtlFlags));
    }

    // we're done here, write the current WZC configuration to the registry
    dwErr = StoSaveWZCConfig(
                hkIntf,
                WZCREGV_INTFSETTINGS,
                &pIntfContext->wzcCurrent,
                &rdBuffer);
    DbgAssert((dwErr == ERROR_SUCCESS, "Can't save active settings"));

    // update the list of static configurations
    dwErr = StoUpdateStaticConfigs(
                hkIntf,
                pIntfContext,
                &rdBuffer);
    DbgAssert((dwErr == ERROR_SUCCESS, "Can't update the list of static configurations"));


exit:
    if (hkIntf != NULL)
        RegCloseKey(hkIntf);
    MemFree(pKeyName);
    MemFree(rdBuffer.pData);

    DbgPrint((TRC_TRACK|TRC_STORAGE,"StoSaveIntfConfig]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// Updates the list of static configurations for the given interface in the 
// persistant storage. The new list is saved, whatever configuration was removed
// is taken out of the persistant storage.
// Parameters:
//   hkRoot
//     [in] Opened registry key to the "...WZCSVC\Parameters\Interfaces\{guid}" location
//   pIntf
//     [in] Interface context to take the static list from
//   prdBuffer
//     [in/out] buffer to be used for preparing the registry blobs
// Returned value:
//     Win32 error code 
DWORD
StoUpdateStaticConfigs(
    HKEY          hkIntf,
    PINTF_CONTEXT pIntfContext,
    PRAW_DATA     prdBuffer)
{
    DWORD   dwErr = ERROR_SUCCESS;
    DWORD   dwLocalErr = ERROR_SUCCESS;
    UINT    nEntries, nIdx;
    WCHAR   wszStConfigName[sizeof(WZCREGV_STSETTINGS)/sizeof(WCHAR)];
    LPWSTR  pwszStConfigNum;

    DbgPrint((TRC_TRACK|TRC_STORAGE,"[StoUpdateStaticConfigs"));

    // get the initial number of values in this registry key
    dwErr = RegQueryInfoKey(
                hkIntf,     // handle to key
                NULL,       // class buffer
                NULL,       // size of class buffer
                NULL,       // reserved
                NULL,       // number of subkeys
                NULL,       // longest subkey name
                NULL,       // longest class string
                &nEntries,  // number of value entries
                NULL,       // longest value name
                NULL,       // longest value data
                NULL,       // descriptor length
                NULL);      // last write time
    if (dwErr != ERROR_SUCCESS)
        goto exit;

    // build the prefix for the static configuration's name
    wcscpy(wszStConfigName, WZCREGV_STSETTINGS);
    pwszStConfigNum = wcschr(wszStConfigName, REG_STSET_DELIM);
    nIdx = 0;

    if (pIntfContext->pwzcPList != NULL)
    {
        UINT i;
        for (i = 0;
             i < pIntfContext->pwzcPList->NumberOfItems && i < REG_STSET_MAX;
             i++)
        {
            if (pIntfContext->pwzcPList->Config[i].dwCtlFlags & WZCCTL_VOLATILE)
                continue;

            // complete the configuration's name
            wsprintf(pwszStConfigNum, L"%04x", nIdx++);
            // save the configuration to the registry
            dwLocalErr = StoSaveWZCConfig(
                            hkIntf,
                            wszStConfigName,
                            &(pIntfContext->pwzcPList->Config[i]),
                            prdBuffer);

            DbgAssert((dwLocalErr == ERROR_SUCCESS,
                       "Failed to save static configuration 0x%x. err=%d",
                       i, dwLocalErr));
            if (dwErr == ERROR_SUCCESS && dwLocalErr != ERROR_SUCCESS)
                dwErr = dwLocalErr;
        }
    }

    // delete now whatever remaining static
    // configurations might still be in the registry
    do
    {
        // complete the configuration's name
        wsprintf(pwszStConfigNum, L"%04x", nIdx);
        // and attempt to delete it - at some point
        // we should get back ERROR_FILE_NOT_FOUND
        dwLocalErr = RegDeleteValue(
                        hkIntf,
                        wszStConfigName);
        nIdx++;
    } while (nIdx < nEntries);

exit:
    DbgPrint((TRC_TRACK|TRC_STORAGE,"StoUpdateStaticConfigs]=%d", dwErr));

    return dwErr;
}

// externalities from 802.1X
DWORD
ElSetInterfaceParams (
        IN  WCHAR           *pwszGUID,
        IN  EAPOL_INTF_PARAMS  *pIntfParams
        );

DWORD
ElGetInterfaceParams (
        IN  WCHAR           *pwszGUID,
        IN  OUT EAPOL_INTF_PARAMS  *pIntfParams
        );


//-----------------------------------------------------------
// Loads from the registry a WZC Configuration, un-protects the WEP key field
// and stores the result in the output param pWzcCfg.
// Parameters:
//   hkCfg
//     [in] Opened registry key to load the WZC configuration from
//   dwRegLayoutVer,
//     [in] registry layout version
//   wszCfgName
//     [in] registry entry name for the WZC configuration
//   pWzcCfg
//     [out] pointer to a WZC_WLAN_CONFIG object that receives the registry data
//   prdBuffer
//     [in] allocated buffer, assumed large enough for getting the registry data!
DWORD
StoLoadWZCConfig(
    HKEY             hkCfg,
    LPWSTR           wszGuid,
    DWORD            dwRegLayoutVer,
    LPWSTR           wszCfgName,
    PWZC_WLAN_CONFIG pWzcCfg,
    PRAW_DATA        prdBuffer)
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT  nType, nLength;

    DbgPrint((TRC_TRACK|TRC_STORAGE,"[StoLoadWZCConfig(\"%S\")", wszCfgName));
    DbgAssert((prdBuffer != NULL, "No buffer provided for loading the registry blob!"));

    // zero out the buffer and get the value from the registry
    ZeroMemory(prdBuffer->pData, prdBuffer->dwDataLen);
    nLength = prdBuffer->dwDataLen;
    dwErr = RegQueryValueEx(
                hkCfg,
                wszCfgName,
                0,
                &nType,
                prdBuffer->pData,
                &nLength);

    if (dwErr == ERROR_SUCCESS)
    {
        switch(dwRegLayoutVer)
	    {
        case REG_LAYOUT_LEGACY_1:
            // first legacy code (WinXP Beta2)
            if (nType == REG_BINARY && nLength == FIELD_OFFSET(WZC_WLAN_CONFIG, rdUserData))
            {
                memcpy(pWzcCfg, prdBuffer->pData, nLength);
                if (pWzcCfg->Length == nLength)
                {
                    pWzcCfg->Length = sizeof(WZC_WLAN_CONFIG);
                    pWzcCfg->AuthenticationMode = NWB_GET_AUTHMODE(pWzcCfg);
                    pWzcCfg->Reserved[0] = pWzcCfg->Reserved[1] = 0;
                }
                else
                    dwErr = ERROR_INVALID_DATA;
            }
            else
                dwErr = ERROR_INVALID_DATA;
            break;
        case REG_LAYOUT_LEGACY_2:
            // second legacy code (WinXP 2473)
            if (nType == REG_BINARY && nLength == sizeof(WZC_WLAN_CONFIG))
            {
                memcpy(pWzcCfg, prdBuffer->pData, nLength);
                if (pWzcCfg->Length != nLength)
                    dwErr = ERROR_INVALID_DATA;
            }
            break;
        case REG_LAYOUT_LEGACY_3:
        case REG_LAYOUT_VERSION:
            // revert the logic: assume failure (ERROR_INVALID_DATA) and
            // explictly set success if the case is
            dwErr = ERROR_INVALID_DATA;

            if (nType == REG_BINARY && nLength > sizeof(WZC_WLAN_CONFIG))
            {
                memcpy(pWzcCfg, prdBuffer->pData, sizeof(WZC_WLAN_CONFIG));
                if (pWzcCfg->Length == sizeof(WZC_WLAN_CONFIG))
                {
                    DATA_BLOB blobIn, blobOut;

                    blobIn.cbData = nLength - sizeof(WZC_WLAN_CONFIG);
                    blobIn.pbData = prdBuffer->pData + sizeof(WZC_WLAN_CONFIG);
                    blobOut.cbData = 0;
                    blobOut.pbData = NULL;
                    if (CryptUnprotectData(
                            &blobIn,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            0,
                            &blobOut) &&
                        blobOut.cbData == WZCCTL_MAX_WEPK_MATERIAL)
                    {
                        memcpy(pWzcCfg->KeyMaterial, blobOut.pbData, blobOut.cbData);
                        // now this is success
                        dwErr = ERROR_SUCCESS;
                    }

                    if (blobOut.pbData != NULL)
                    {
                        RtlSecureZeroMemory(blobOut.pbData, blobOut.cbData);
                        LocalFree(blobOut.pbData);
                    }
                }
            }
            // for now don't read anything - rely on defaults;
            break;
        default:
            dwErr = ERROR_BAD_FORMAT;
        }
    }

    // if everything went up fine and this is an infrastructure network and
    // we're in some legacy registry layout.. make sure to disable 802.1X in
    // the following cases:
    if (dwErr == ERROR_SUCCESS && 
        dwRegLayoutVer <= REG_LAYOUT_LEGACY_3 &&
        pWzcCfg->InfrastructureMode != Ndis802_11IBSS &&
        wszGuid != NULL)
    {
        BOOL                bDisableOneX = FALSE;

        // the Infrastructure network being loaded doesn't require privacy
        bDisableOneX = bDisableOneX || (pWzcCfg->Privacy == 0);
        // it is Infrastructure with privacy, but some explicit key is also provided..
        bDisableOneX = bDisableOneX || (pWzcCfg->dwCtlFlags & WZCCTL_WEPK_PRESENT);
        if (bDisableOneX == TRUE)
        {
            EAPOL_INTF_PARAMS   elIntfParams = {0};
            elIntfParams.dwSizeOfSSID = pWzcCfg->Ssid.SsidLength;
            memcpy(&elIntfParams.bSSID, &pWzcCfg->Ssid.Ssid, pWzcCfg->Ssid.SsidLength);
            dwErr = ElGetInterfaceParams (
                        wszGuid,   // wsz GUID
                        &elIntfParams);

            if (dwErr == ERROR_SUCCESS)
            {
                elIntfParams.dwEapFlags &= ~EAPOL_ENABLED;
                dwErr = ElSetInterfaceParams (
                        wszGuid,   // wsz GUID
                        &elIntfParams);
            }
        }
    }

    // if everything went ok so far it means we have loaded pWzcCfg with
    // data from the registry.
    // Lets check this data is consistent!
    if (dwErr == ERROR_SUCCESS)
    {
        // as the first thing - make sure the configuration's control
        // flags don't show it as "Volatile" - such a configuration shouldn't be
        // in the registry in the first instance. On upgrade, it might happen to
        // have this bit set since once it had a different meaning (the config contains
        // a 40bit WEP key) which is now obsolete.
        pWzcCfg->dwCtlFlags &= ~WZCCTL_VOLATILE;

        // since dwErr is ERROR_SUCCESS, it is guaranteed pWzcCfg
        // points to at least the Length field.
        dwErr = WZCSvcCheckConfig(pWzcCfg, pWzcCfg->Length);
    }

    DbgPrint((TRC_TRACK|TRC_STORAGE,"StoLoadWZCConfig]=%d", dwErr));
    return dwErr;
}
    
//-----------------------------------------------------------
// Takes the input param pWzcCfg, protects the WEP key field and stores the
// resulting BLOB into the registry.
// Parameters:
//   hkCfg
//     [in] Opened registry key to load the WZC configuration from
//   wszCfgName
//     [in] registry entry name for the WZC configuration
//   pWzcCfg
//     [in] WZC_WLAN_CONFIG object that is written to the registry
//   prdBuffer
//     [in/out] allocated buffer, assumed large enough for getting the registry data!
DWORD
StoSaveWZCConfig(
    HKEY             hkCfg,
    LPWSTR           wszCfgName,
    PWZC_WLAN_CONFIG pWzcCfg,
    PRAW_DATA        prdBuffer)
{
    DWORD       dwErr = ERROR_SUCCESS;
    DATA_BLOB   blobIn, blobOut;

    DbgPrint((TRC_TRACK|TRC_STORAGE,"[StoSaveWZCConfig(\"%S\")", wszCfgName));
    DbgAssert((prdBuffer != NULL, "No buffer provided for creating the registry blob!"));

    blobIn.cbData = WZCCTL_MAX_WEPK_MATERIAL;
    blobIn.pbData = &(pWzcCfg->KeyMaterial[0]);
    blobOut.cbData = 0;
    blobOut.pbData = NULL;
    if (!CryptProtectData(
            &blobIn,        // DATA_BLOB *pDataIn,
            L"",            // LPCWSTR szDataDescr,
            NULL,           // DATA_BLOB *pOptionalEntropy,
            NULL,           // PVOID pvReserved,
            NULL,           // CRYPTPROTECT_PROMPTSTRUCT *pPromptStrct,
            0,              // DWORD dwFlags,
            &blobOut))      // DATA_BLOB *pDataOut
        dwErr = GetLastError();

    DbgAssert((dwErr == ERROR_SUCCESS, "CryptProtectData failed with err=%d", dwErr));

    // if crypting the wep key went fine, check if we have enough storage to prepare
    // the blob for the registry. If not, allocate as much as needed.
    if (dwErr == ERROR_SUCCESS && 
        prdBuffer->dwDataLen < sizeof(WZC_WLAN_CONFIG) + blobOut.cbData)
    {
        MemFree(prdBuffer->pData);
        prdBuffer->dwDataLen = 0;
        prdBuffer->pData = NULL;
        prdBuffer->pData = MemCAlloc(sizeof(WZC_WLAN_CONFIG) + blobOut.cbData);
        if (prdBuffer->pData == NULL)
            dwErr = GetLastError();
        else
            prdBuffer->dwDataLen = sizeof(WZC_WLAN_CONFIG) + blobOut.cbData;
    }

    // now we have the buffer, all what remains is to:
    // - copy the WZC_WLAN_CONFIG object into the blob that goes into the registry
    // - clean the "clear" WEP key from that blob
    // - append the encrypted WEP key to the blob going into the registry
    // - write the blob to the registry
    if (dwErr == ERROR_SUCCESS)
    {
        PWZC_WLAN_CONFIG pRegCfg;

        memcpy(prdBuffer->pData, pWzcCfg, sizeof(WZC_WLAN_CONFIG));
        pRegCfg = (PWZC_WLAN_CONFIG)prdBuffer->pData;
        ZeroMemory(pRegCfg->KeyMaterial, WZCCTL_MAX_WEPK_MATERIAL);
        memcpy(prdBuffer->pData+sizeof(WZC_WLAN_CONFIG), blobOut.pbData, blobOut.cbData);
        dwErr = RegSetValueEx(
                    hkCfg,
                    wszCfgName,
                    0,
                    REG_BINARY,
                    prdBuffer->pData,
                    prdBuffer->dwDataLen);
    }

    // cleanup whatever CryptProtectData might have allocated.
    if (blobOut.pbData != NULL)
        LocalFree(blobOut.pbData);

    DbgPrint((TRC_TRACK|TRC_STORAGE,"StoSaveWZCConfig]=%d", dwErr));
    return dwErr;
}

// StoLoadWZCContext:
// Description: Loads a context from the registry
// Parameters: 
// [out] pwzvCtxt: pointer to a WZC_CONTEXT allocated by user, initialised
// with WZCContextInit. On  success, contains values from registry.  
// [in]  hkRoot, a handle to "...WZCSVC\Parameters"
// Returns: win32 error
DWORD StoLoadWZCContext(HKEY hkRoot, PWZC_CONTEXT pwzcCtxt)
{
    BOOL        bCloseKey = FALSE;
    DWORD       dwErr = ERROR_SUCCESS;
    DWORD       dwcbSize = sizeof(WZC_CONTEXT);
    DWORD       dwType = REG_BINARY;
    WZC_CONTEXT wzcTempCtxt;

    DbgPrint((TRC_TRACK|TRC_STORAGE, "[StoLoadWZCContext"));

    if (pwzcCtxt == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if (hkRoot == NULL)
    {
        // open the root key first
        dwErr = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    WZCREGK_ABS_PARAMS,
                    0,
                    KEY_READ,
                    &hkRoot);
        // if we couldn't find the WZC key, no problem, this is not
        // a failure - we'll just have to rely on the default values
        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            dwErr = ERROR_SUCCESS;
            goto exit;
        }

        // failure at this point breaks the function
        if (dwErr != ERROR_SUCCESS)
            goto exit;

	    bCloseKey = TRUE;
    }

    dwErr = RegQueryValueEx(
                hkRoot,
                WZCREGV_CONTEXT,
                NULL,
                &dwType,
			    (LPBYTE)&wzcTempCtxt,
                &dwcbSize);
    switch(dwErr)
    {
    case ERROR_FILE_NOT_FOUND:
      /* If there is no registry entry, this is not an error - we rely
       * on the defaults. Translate this case to ERROR_SUCCESS.
       */
        DbgPrint((TRC_STORAGE, "No service context present in the registry!"));
        dwErr = ERROR_SUCCESS;
        break;
    case ERROR_SUCCESS:
        // we got our registry values, copy them in the running memory.
	    memcpy(pwzcCtxt, &wzcTempCtxt, sizeof(WZC_CONTEXT));
        break;
    default:
        // for any other error, it will be bubbled up
        DbgAssert((FALSE,"Error %d loading the service's context.", dwErr));
    }

exit:
    if (TRUE == bCloseKey)
        RegCloseKey(hkRoot);

    DbgPrint((TRC_TRACK|TRC_STORAGE,"StoLoadWZCContext]=%d", dwErr));
    return dwErr;
}

// StoSaveWZCContext:
// Description: Saves a context to the registry. Does not check values. If 
// the registry key dosent exist, it is created.
// Parameters: [in] pwzcCtxt, pointer to a valid WZC_CONTEXT
//             [in]  hkRoot, a handle to "...WZCSVC\Parameters"
// Returns: win32 error
DWORD StoSaveWZCContext(HKEY hkRoot, PWZC_CONTEXT pwzcCtxt)
{
    BOOL  bCloseKey = FALSE;
    DWORD dwErr = ERROR_SUCCESS;

    DbgPrint((TRC_TRACK|TRC_STORAGE, "[StoSaveWZCContext"));

    if (pwzcCtxt == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if (NULL == hkRoot)
	{
        // open the root key first
        dwErr = RegOpenKeyEx(
		           HKEY_LOCAL_MACHINE,
		           WZCREGK_ABS_PARAMS,
		           0,
		           KEY_READ|KEY_SET_VALUE,
		           &hkRoot);
        // if we couldn't find the WZC key, no problem, this is not
        // a failure - we'll just have to rely on the default values
        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            dwErr = ERROR_SUCCESS;
            goto exit;
        }
	  
        // failure at this point breaks the function
        if (dwErr != ERROR_SUCCESS)
            goto exit;
	  
        bCloseKey = TRUE;
    }

    dwErr = RegSetValueEx(
                hkRoot,
                WZCREGV_CONTEXT,
                0,
                REG_BINARY,
                (LPBYTE) pwzcCtxt,
                sizeof(WZC_CONTEXT));

    DbgAssert((dwErr == ERROR_SUCCESS, "Error %d saving the service's context.", dwErr));

 exit:
    if (TRUE == bCloseKey)
      RegCloseKey(hkRoot);

    DbgPrint((TRC_TRACK|TRC_STORAGE,"StoSaveWZCContext]=%d", dwErr));
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\utils.h ===
#include "wzccrypt.h"

#pragma once

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// MEMORY ALLOCATION UTILITIES (defines, structs, funcs)
#define MemCAlloc(nBytes)   Process_user_allocate(nBytes)
#define MemFree(pMem)       Process_user_free(pMem)

PVOID
Process_user_allocate(size_t NumBytes);

VOID
Process_user_free(LPVOID pMem);


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// NDIS UTILITIES (defines, structs, funcs)
//-----------------------------------------------------------
// Searches pwzcConfig in the list pwzcVList. The entries are
// matched exclusively based on the matching SSIDs and on 
// matching Infrastructure Mode.
// [in]  pwzcVList: Set of WZC_WLAN_CONFIGs to search in 
// [in]  pwzcConfig: WZC_WLAN_CONFIG to look for
// [in]  nIdx: index in pwzcVList to start searching from
// Returns: Pointer to the entry that matches pwzcConfig or NULL
//          if none matches
PWZC_WLAN_CONFIG
WzcFindConfig(
    PWZC_802_11_CONFIG_LIST pwzcList,
    PWZC_WLAN_CONFIG        pwzcConfig,
    ULONG                   nIdx);

// Matches the content of the two configurations one against the other.
// [in]  pwzcConfigA: | configs to match
// [in]  pwzcConfigB: |
// [in/out] pbWepDiffOnly: TRUE if there is a difference and the difference is exclusively
//                         in the WEP Key index or in WEP Key Material. Otherwise is false.
// Returns: TRUE if the configs match, FALSE otherwise;
BOOL
WzcMatchConfig(
    PWZC_WLAN_CONFIG        pwzcConfigA,
    PWZC_WLAN_CONFIG        pwzcConfigB,
    PBOOL                   pbWepDiffOnly);

// Converts an NDIS_802_11_BSSID_LIST object to an equivalent
// (imaged) WZC_802_11_CONFIG_LIST
// [in]  pndList: NDIS BSSID list to convert
// Returns: Pointer to the list of copied WZC configurations
PWZC_802_11_CONFIG_LIST
WzcNdisToWzc(
    PNDIS_802_11_BSSID_LIST pndList);

// WzcCleanupList: Cleanup a list of WZC_WLAN_CONFIG objects
VOID
WzcCleanupWzcList(
    PWZC_802_11_CONFIG_LIST pwzcList);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// SYNCHRONIZATION UTILITIES 
//-----------------------------------------------------------
// Datastructures
// RCCS_SYNC encapsulates a critical section and a reference counter.
typedef struct _RCCS_SYNC
{
    CRITICAL_SECTION    csMutex;
    UINT                nRefCount;
} RCCS_SYNC, *PRCCS_SYNC;

//-----------------------------------------------------------
// RccsInit: Initializes an RCCS structure
DWORD
RccsInit(PRCCS_SYNC pRccs);

//-----------------------------------------------------------
// RccsInit: Deletes an RCCS structure
DWORD
RccsDestroy(PRCCS_SYNC pRccs);

//-----------------------------------------------------------
// WzcCryptBuffer: Randomly generates a nBufLen bytes in the range
// [loByte hiByte], all stored in pBuffer (buffer assumed preallocated)
// Returns a win32 error code.
DWORD
WzcRndGenBuffer(LPBYTE pBuffer, UINT nBufLen, BYTE loByte, BYTE hiByte);

//-----------------------------------------------------------
// WzcIsNullBuffer: Checks whether a buffer of nBufLen characters
// is all filled with null characters.
BOOL
WzcIsNullBuffer(LPBYTE pBuffer, UINT nBufLen);

//-----------------------------------------------------------
// WzcSSKClean: Cleans up the PSEC_SESSION_KEYS object given as parameter
VOID
WzcSSKClean(PSEC_SESSION_KEYS pSSK);

//-----------------------------------------------------------
// WzcSSKFree: Frees up the memory used by the PSEC_SESSION_KEYS parameter
VOID
WzcSSKFree(PSEC_SESSION_KEYS pSSK);

//-----------------------------------------------------------
// WzcSSKEncrypt: Creates/Allocates a SEC_SESSION_KEYS object
// by encrypting the SESSION_KEYS object provided as parameter.
DWORD
WzcSSKEncrypt(PSEC_SESSION_KEYS pSSK, PSESSION_KEYS pSK);

//-----------------------------------------------------------
// WzcSSKDecrypt: Creates/Allocates a SESSION_KEYS object
// by dencrypting the SEC_SESSION_KEYS object provided as parameter.
DWORD
WzcSSKDecrypt(PSEC_SESSION_KEYS pSSK, PSESSION_KEYS pSK);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\state.h ===
#pragma once

//-----------------------------------------------------------
// Constants / macros
#define TMMS_INFINITE     0x7fffffff
#define TMMS_Tr           0x00000bb8 // Timeout until a rescan completes: ms(3sec)
#define TMMS_Tc           0x0000ea60 // Timeout to retry a valid configuration: ms(1min)
#define TMMS_Tp           0x000007d0 // Timeout to expect a media connect for a selected config: ms(2sec)
#define TMMS_Tf           0x0000ea60 // Timeout to recover from a failed configuration: ms(1min)
#define TMMS_Td           0x00001388 // Timeout to delay the {SSr} processing: ms(5sec)

#define TIMER_SET(pIntf, tm, Err)   Err=StateTmSetOneTimeTimer((pIntf), (tm))
#define TIMER_RESET(pIntf, Err)     Err=StateTmSetOneTimeTimer((pIntf), TMMS_INFINITE)

extern DWORD DhcpStaticRefreshParams(IN LPWSTR Adapter);

//-----------------------------------------------------------
// Type definitions
//
// Defines the state handler function. The interface context contains
// a pointer to one State Handler function. Based on the function it points
// to, this pointer identifies the state where the context is in. There should
// be one function call having this prototype for each possible state:
//    x StateInitFn             {SI}
//    x StateHardResetFn,       {SHr}
//    x StateSoftResetFn,       {SSr}
//    x StateDelaySoftResetFn,  {SDSr}
//    x StateQueryFn,           {SQ}
//    x StateIterateFn,         {SIter}
//    x StateNotifyFn,          {SN}
//    x StateCfgHardKeyFn,      {SCk}
//    x StateConfiguredFn,      {SC}
//    x StateCfgRemoveFn,       {SRs}
//    x StateCfgPreserveFn,     {SPs}
//    x StateFailedFn,          {SF}
typedef struct _INTF_CONTEXT *PINTF_CONTEXT;
typedef DWORD(*PFN_STATE_HANDLER)(PINTF_CONTEXT pIntfContext);

// Enumeration for state transition events
typedef enum
{
    // a new interface has been added to the system (either device arrival or adapter bind)
    eEventAdd=0,
    // the interface has been removed from the system (either device removal or adapter unbind)
    eEventRemove,
    // media connect has been received for the interface
    eEventConnect,
    // media disconnect has been received for the interface
    eEventDisconnect,
    // a timeout occured for the interface
    eEventTimeout,
    // a refresh command has been issued
    eEventCmdRefresh,
    // a reset command has been issued
    eEventCmdReset,
    // a WZCCMD_CFG_NEXT command has been issued
    eEventCmdCfgNext,
    // a WZCCMD_CFG_DELETE command has been issued
    eEventCmdCfgDelete,
    // a WZCCMD_CFG_NOOP command has been issued
    eEventCmdCfgNoop
} ESTATE_EVENT;

//-----------------------------------------------------------
// Function declarations

//-----------------------------------------------------------
// StateTmSetOneTimeTimer: Sets a one time timer for the given context with the 
// hardcoded callback WZCTimeoutCallback() and with the parameter the interface
// context itself.
// Parameters:
// [in/out] pIntfContext: identifies the context for which is set the timer.
// [in]     dwMSeconds: miliseconds interval when the timer is due to fire
DWORD
StateTmSetOneTimeTimer(
    PINTF_CONTEXT   pIntfContext,
    DWORD           dwMSeconds);

//-----------------------------------------------------------
// StateDispatchEvent: processes an event that will cause the state machine to transition
// through one or more states.
// Parameters:
// [in] StateEvent: identifies the event that triggers the transition(s)
// [in] pIntfContext: points to the interface that is subject for the transition(s)
// [in] pvEventData: any data related to the event
DWORD
StateDispatchEvent(
    ESTATE_EVENT    StateEvent,
    PINTF_CONTEXT   pIntfContext,
    PVOID           pvEventData);


//-----------------------------------------------------------
// State Handler functions:
//-----------------------------------------------------------
// StateInitFn: Handler for the {SI} state.
DWORD
StateInitFn(
    PINTF_CONTEXT   pIntfContext);

//-----------------------------------------------------------
// StateHardResetFn: Handler for the {SHr} state
DWORD
StateHardResetFn(
    PINTF_CONTEXT   pIntfContext);

//-----------------------------------------------------------
// StateSoftResetFn: Handler for the {SSr} state
DWORD
StateSoftResetFn(
    PINTF_CONTEXT   pIntfContext);

//-----------------------------------------------------------
// StateDelaySoftResetFn: Handler for the {SDSr} state
DWORD
StateDelaySoftResetFn(
    PINTF_CONTEXT   pIntfContext);

//-----------------------------------------------------------
// StateQueryFn: Handler for the {SQ} state
DWORD
StateQueryFn(
    PINTF_CONTEXT   pIntfContext);

//-----------------------------------------------------------
// StateIterateFn: Handler for the {SIter} state
DWORD
StateIterateFn(
    PINTF_CONTEXT   pIntfContext);

//-----------------------------------------------------------
// StateConfiguredFn: Handler for the {SC} state
DWORD
StateConfiguredFn(
    PINTF_CONTEXT   pIntfContext);

//-----------------------------------------------------------
// StateFailedFn: Handler for the {SF} state
DWORD
StateFailedFn(
    PINTF_CONTEXT   pIntfContext);

//-----------------------------------------------------------
// StateCfgRemoveFn: Handler for the {SRs} state
DWORD
StateCfgRemoveFn(
    PINTF_CONTEXT   pIntfContext);

//-----------------------------------------------------------
// StateCfgPreserveFn: Handler for the {SPs} state
DWORD
StateCfgPreserveFn(
    PINTF_CONTEXT   pIntfContext);

//-----------------------------------------------------------
// StateCfgHardKeyFn: Handler for the {SCk} state
DWORD
StateCfgHardKeyFn(
    PINTF_CONTEXT   pIntfContext);

//-----------------------------------------------------------
// StateNotifyFn: Handler for the {SN} state
DWORD
StateNotifyFn(
    PINTF_CONTEXT   pIntfContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\wzcsvc.c ===
#include <precomp.h>
#include "rpcsrv.h"
#include "utils.h"
#include "intflist.h"
#include "deviceio.h"
#include "wzcsvc.h"
#include "notify.h"
#include "storage.h"
#include "zcdblog.h"
#include "tracing.h"

//taroonm
#include <wifipol.h>

#define WZEROCONF_SERVICE       TEXT("wzcsvc")
#define EAPOL_LINKED

SERVICE_STATUS           g_WZCSvcStatus;
SERVICE_STATUS_HANDLE    g_WZCSvcStatusHandle = NULL;
HDEVNOTIFY               g_WZCSvcDeviceNotif = NULL;
UINT                     g_nThreads = 0;
HINSTANCE                g_hInstance = NULL;

//context of users preferences
WZC_INTERNAL_CONTEXT    g_wzcInternalCtxt = {0};

BOOL WINAPI DllMain(
  HINSTANCE hinstDLL,  // handle to the DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved   // reserved
)
{
    if (g_hInstance == NULL)
        g_hInstance = hinstDLL;
    return TRUE;
}


//-----------------------------------------------------------
VOID WINAPI
WZCSvcMain(
    IN DWORD    dwArgc,
    IN LPWSTR   *lpwszArgv)
{
    DWORD      dwError = ERROR_SUCCESS;
    DEV_BROADCAST_DEVICEINTERFACE   PnPFilter;
    BOOL       bLogEnabled = FALSE;

    // Initialize the workstation to receive service requests
    // by registering the service control handler.
    g_WZCSvcStatusHandle = RegisterServiceCtrlHandlerEx(
                                WZEROCONF_SERVICE,
                                WZCSvcControlHandler,
                                NULL);
    if (g_WZCSvcStatusHandle == (SERVICE_STATUS_HANDLE)NULL)
        return;

    // this is the first thread to run
    InterlockedIncrement(&g_nThreads);

    // Initialize Tracing
    TrcInitialize();
    // Initialize the Event logging
    EvtInitialize();
    DbgPrint((TRC_TRACK,"**** [WZCSvcMain - Service Start Pending"));

    // Initialize all the status fields so that the subsequent calls
    // to SetServiceStatus need to only update fields that changed.
    g_WZCSvcStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    g_WZCSvcStatus.dwCurrentState = SERVICE_START_PENDING;
    g_WZCSvcStatus.dwControlsAccepted = 0;
    g_WZCSvcStatus.dwCheckPoint = 1;
    g_WZCSvcStatus.dwWaitHint = 4000;
    g_WZCSvcStatus.dwWin32ExitCode = ERROR_SUCCESS;
    g_WZCSvcStatus.dwServiceSpecificExitCode = 0;
    // update status to START_PENDING
    WZCSvcUpdateStatus();

    // Initialize global hashes. If this fails it means the most important
    // critical section failed to initialize - no point in going further.
    dwError = HshInitialize(&g_hshHandles);
    if (dwError != ERROR_SUCCESS)
        goto exit;
    dwError = LstInitIntfHashes();
    if (dwError != ERROR_SUCCESS)
        goto exit;
    //Initialize the service's context
    dwError = WZCContextInit(&g_wzcInternalCtxt);
    if (dwError != ERROR_SUCCESS)
        goto exit;

    // TODO: the block below should be moved to a function responsible for
    // loading the whole g_wzcInternalCtxt from the persistent storage
    {
        // load the service's context from the registry
        dwError = StoLoadWZCContext(NULL, &(g_wzcInternalCtxt.wzcContext));
        if (ERROR_SUCCESS != dwError)
            goto exit;

        // load the global interface template from the registry.
        dwError = StoLoadIntfConfig(NULL, g_wzcInternalCtxt.pIntfTemplate);
        DbgAssert((dwError == ERROR_SUCCESS,"Err %d loading the template interface from the registry"));
    }

    // Open log database if logging enabled
    EnterCriticalSection(&g_wzcInternalCtxt.csContext);
    bLogEnabled = ((g_wzcInternalCtxt.wzcContext.dwFlags & WZC_CTXT_LOGGING_ON) != 0);
    LeaveCriticalSection(&g_wzcInternalCtxt.csContext);

    dwError = InitWZCDbGlobals(bLogEnabled);
    if ((INT)dwError < 0) {
        EvtLogWzcError(WZCSVC_SERVICE_FAILED, dwError);
        dwError = ERROR_DATABASE_FAILURE;
    }

    if (ERROR_SUCCESS != dwError)
        goto exit;

    dwError = LstInitTimerQueue();
    if (dwError != ERROR_SUCCESS)
        goto exit;

#ifdef EAPOL_LINKED
    // Start EAPOL/802.1X
    EAPOLServiceMain (dwArgc, NULL);
#endif

    // load the interfaces list
    dwError = LstLoadInterfaces();
    DbgAssert((dwError == ERROR_SUCCESS,"LstLoadInterfaces failed with error %d", dwError));

    // register for service control notifications
    ZeroMemory (&PnPFilter, sizeof(PnPFilter));
    PnPFilter.dbcc_size = sizeof(PnPFilter);
    PnPFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    PnPFilter.dbcc_classguid = GUID_NDIS_LAN_CLASS;
    // NOTE: EAPOL service is only working with ANSI strings, hence the ANSI calls
    g_WZCSvcDeviceNotif = RegisterDeviceNotificationA(
                                (HANDLE)g_WZCSvcStatusHandle,
                                &PnPFilter,
                                DEVICE_NOTIFY_SERVICE_HANDLE );
    DbgAssert((g_WZCSvcDeviceNotif != (HDEVNOTIFY) NULL,
               "Registering for device notifications failed with error %d", GetLastError));

    // register with WMI for device notifications
    dwError = WZCSvcWMINotification(TRUE);
    DbgAssert((dwError == ERROR_SUCCESS,"WZCSvcRegisterWMINotif failed with error %d", dwError));


    // Start the RPC Server.
    dwError = WZCSvcStartRPCServer();
    DbgAssert((dwError == ERROR_SUCCESS,"WZCStartRPCServer failed with error %d", dwError));

    //taroonM: Policy Engine Init
    dwError = InitPolicyEngine(dwPolicyEngineParam, &hPolicyEngineThread);
    DbgAssert((dwError == ERROR_SUCCESS,"InitPolicyEngine failed with error %d", dwError));
exit:

    if (dwError == ERROR_SUCCESS)
    {
        g_WZCSvcStatus.dwCurrentState = SERVICE_RUNNING;
        g_WZCSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN | SERVICE_ACCEPT_SESSIONCHANGE;
        g_WZCSvcStatus.dwCheckPoint = 0;
        g_WZCSvcStatus.dwWaitHint = 0;
        // update status to RUNNING
        WZCSvcUpdateStatus();
        DbgPrint((TRC_TRACK,"****  WZCSvcMain - Service Running"));
	    DbLogWzcInfo(WZCSVC_SERVICE_STARTED, NULL);
    }
    else
    {
        DbgPrint((TRC_TRACK,"****  WZCSvcMain - Service Failed to start"));

        // stop the WZC engine
        WZCSvcShutdown(dwError);

        // stop the EAP engine
        EAPOLCleanUp (dwError);

        // destroy the handles hash
        HshDestroy(&g_hshHandles);

        // if database has been opened, close it here since there is no one else using it
        DeInitWZCDbGlobals();

        // finaly destroy the WZC context
        WZCContextDestroy(&g_wzcInternalCtxt);

        // if we did successfully register with SCM, then indicate the service has stopped
        if (g_WZCSvcStatusHandle != (SERVICE_STATUS_HANDLE)NULL)
        {
            g_WZCSvcStatus.dwCurrentState = SERVICE_STOPPED;
            g_WZCSvcStatus.dwControlsAccepted = 0;
            g_WZCSvcStatus.dwCheckPoint = 0;
            g_WZCSvcStatus.dwWaitHint = 0;
            g_WZCSvcStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
            g_WZCSvcStatus.dwServiceSpecificExitCode = dwError;
            WZCSvcUpdateStatus();
        }

        EvtTerminate();
        TrcTerminate();
    }

    InterlockedDecrement(&g_nThreads);
    return;
}

// global array for the GUIDs for the WMI notifications
LPGUID  g_lpGuidWmiNotif[] = {
        (LPGUID)&GUID_NDIS_NOTIFY_BIND,
        (LPGUID)&GUID_NDIS_NOTIFY_UNBIND,
        (LPGUID)&GUID_NDIS_STATUS_MEDIA_CONNECT,
        (LPGUID)&GUID_NDIS_STATUS_MEDIA_DISCONNECT
        };

//-----------------------------------------------------------
// Handles all WMI registration and de-registration
DWORD
WZCSvcWMINotification(BOOL bRegister)
{
    DWORD	      dwErr = ERROR_SUCCESS;
    INT           nIdx;

    DbgPrint((TRC_TRACK,"[WZCSvcWMINotification(%d)", bRegister));

    // do the requested action - registration / deregistration
    // if registering for notifications, break the loop first time a registration failed
    // if de-registering, ignore the errors and go on deregistering the remaining notifications
    for (nIdx = 0;
         nIdx < sizeof(g_lpGuidWmiNotif)/sizeof(LPGUID) && (!bRegister || dwErr == ERROR_SUCCESS);
         nIdx++)
    {
        dwErr = WmiNotificationRegistrationW(
                    g_lpGuidWmiNotif[nIdx],
                    (BOOLEAN)bRegister,    
                    (PVOID)WZCSvcWMINotificationHandler,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT);
        DbgAssert((dwErr == 0, "Failed to %s notif index %d",
            bRegister ? "register" : "de-register",
            nIdx));
    }

    // in case a registration was requested and one of the Wmi calls above failed,
    // rollback the action by deregistering for whatever was registered successfully
    if (bRegister && dwErr != ERROR_SUCCESS)
    {
        DbgPrint((TRC_GENERIC,"Rollback WmiNotif for %d Guids", nIdx));
        for(nIdx--; nIdx>=0; nIdx--)
        {
            WmiNotificationRegistrationW(
                g_lpGuidWmiNotif[nIdx],
                (BOOLEAN)FALSE,    
                (PVOID)WZCSvcWMINotificationHandler,
                (ULONG_PTR)NULL,
                NOTIFICATION_CALLBACK_DIRECT);
        }
    }

    DbgPrint((TRC_TRACK, "WZCSvcWMINotification]=%d", dwErr));
	return dwErr;
}

//-----------------------------------------------------------
DWORD
WZCSvcUpdateStatus()
{
    DbgPrint((TRC_TRACK,"[WZCSvcUpdateStatus(%d)]", g_WZCSvcStatus.dwCurrentState));
    return SetServiceStatus(g_WZCSvcStatusHandle, &g_WZCSvcStatus) ? 
           ERROR_SUCCESS : GetLastError();
}

//-----------------------------------------------------------
DWORD
WZCSvcControlHandler(
    IN DWORD dwControl,
    IN DWORD dwEventType,
    IN PVOID pEventData,
    IN PVOID pContext)
{
    DWORD dwRetCode = NO_ERROR;
    BOOL  bDecrement = TRUE;

    InterlockedIncrement(&g_nThreads);

    DbgPrint((TRC_TRACK|TRC_NOTIF,"[WZCSvcControlHandler(%d,%d,..)", dwControl, dwEventType));
    DbgPrint((TRC_NOTIF,"SCM Notification: Control=0x%x; EventType=0x%04x", dwControl, dwEventType));

    switch (dwControl)
    {

    case SERVICE_CONTROL_DEVICEEVENT:
        if (g_WZCSvcStatus.dwCurrentState == SERVICE_RUNNING &&
            pEventData != NULL)
        {
            PDEV_BROADCAST_DEVICEINTERFACE pInfo = (DEV_BROADCAST_DEVICEINTERFACE *)pEventData;

            if (pInfo->dbcc_devicetype == DBT_DEVTYP_DEVICEINTERFACE)
            {
                PWZC_DEVICE_NOTIF pDevNotif;

                pDevNotif = MemCAlloc(FIELD_OFFSET(WZC_DEVICE_NOTIF, dbDeviceIntf) + pInfo->dbcc_size);
                DbgAssert((pDevNotif != NULL, "Not enough memory?"));
                if (pDevNotif != NULL)
                {
                    // build up the notification information
                    switch(dwEventType)
                    {
                    case DBT_DEVICEARRIVAL:
                        pDevNotif->dwEventType = WZCNOTIF_DEVICE_ARRIVAL;
                        break;
                    case DBT_DEVICEREMOVECOMPLETE:
                        pDevNotif->dwEventType = WZCNOTIF_DEVICE_REMOVAL;
                        break;
                    default:
                        pDevNotif->dwEventType = WZCNOTIF_UNKNOWN;
                        DbgPrint((TRC_ERR,"SCM Notification %d is not recognized", dwEventType));
                        break;
                    }

                    // pass down notification only if it is recognized at this level
                    if (pDevNotif->dwEventType != WZCNOTIF_UNKNOWN)
                    {
                        memcpy(&(pDevNotif->dbDeviceIntf), pInfo, pInfo->dbcc_size);

                        // pDevNotif will be MemFree-ed by the worker thread
                        if (QueueUserWorkItem(
                                (LPTHREAD_START_ROUTINE)WZCWrkDeviceNotifHandler,
                                (LPVOID)pDevNotif,
                                WT_EXECUTELONGFUNCTION))
                        {
                            bDecrement = FALSE;
                        }
                    }
                    else
                    {
                        MemFree(pDevNotif);
                    }
                }
            }
        }
        
        break;

    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:
        // make sure the control is not sent twice forcing the service to lock 
        // a critical section already destroyed! (see WZCSvcShutdown->StoSaveConfig)
        if (g_WZCSvcStatus.dwCurrentState != SERVICE_STOPPED)
        {
            g_WZCSvcStatus.dwCurrentState = SERVICE_STOP_PENDING;
            g_WZCSvcStatus.dwCheckPoint = 1;
            g_WZCSvcStatus.dwWaitHint = 60000;        
            WZCSvcUpdateStatus();

            // Shutdown Zero Conf
            WZCSvcShutdown(ERROR_SUCCESS);

            // Shutdown EAPOL/802.1X
            EAPOLCleanUp (NO_ERROR);
            DbgPrint((TRC_TRACK,"EAPOLCleanUp done!"));

            // destroy the handles hash
            HshDestroy(&g_hshHandles);

            DbgPrint((TRC_TRACK,"Hashes Destroyed!"));

            DeInitWZCDbGlobals();

            // clean up the service's context
            WZCContextDestroy(&g_wzcInternalCtxt);

            //WZCSvcUpdateStatus();
            g_WZCSvcStatus.dwCurrentState = SERVICE_STOPPED;
            g_WZCSvcStatus.dwControlsAccepted = 0;
            g_WZCSvcStatus.dwCheckPoint = 0;
            g_WZCSvcStatus.dwWaitHint = 0;
            g_WZCSvcStatus.dwWin32ExitCode = ERROR_SUCCESS;
            g_WZCSvcStatus.dwServiceSpecificExitCode = 0;
            WZCSvcUpdateStatus();

            // this is the last thread of the service (guaranteed by WZCSvcShutdown)
            // all datastructures have been closed, tracing has been disabled. No need
            // to decrement the thread counter since no one uses it anymore.
            // just set it to 0 to play safe

            bDecrement = FALSE;
            g_nThreads = 0;

            EvtTerminate();
            TrcTerminate();
        }

        break;

    case SERVICE_CONTROL_SESSIONCHANGE:
        // 802.1X session change handler
        ElSessionChangeHandler (
                pEventData,
                dwEventType
                );
        break;
    }

    if (bDecrement)
    {
        DbgPrint((TRC_TRACK|TRC_NOTIF,"WZCSvcControlHandler]"));
        InterlockedDecrement(&g_nThreads);
    }

    return ERROR_SUCCESS;
}

//-----------------------------------------------------------
// WZCSvcWMINotificationHandler: Callback function called by WMI on any registered
// notification (as of 01/19/01: bind/unbind/connect/disconnect)
VOID CALLBACK
WZCSvcWMINotificationHandler(
    IN PWNODE_HEADER    pWnodeHdr,
    IN UINT_PTR         uiNotificationContext)
{
    DWORD                   dwErr = ERROR_SUCCESS;
    PWZC_DEVICE_NOTIF       pDevNotif = NULL;
    PWNODE_SINGLE_INSTANCE  pWnode = (PWNODE_SINGLE_INSTANCE)pWnodeHdr;
	LPWSTR                  wszTransport;
    BOOL                    bDecrement = TRUE;

    // increment the thread counter
    InterlockedIncrement(&g_nThreads);

    DbgPrint((TRC_TRACK|TRC_NOTIF, "[WZCSvcWMIHandler(0x%p)", pWnodeHdr));

    // check if the service is still running, otherwise ignore
    // the notification
    if (g_WZCSvcStatus.dwCurrentState != SERVICE_RUNNING)
        goto exit;

    // check if we have valid notification data from WMI
    if (pWnodeHdr == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // allocate memory for the WZC Notification Structure.
    pDevNotif = MemCAlloc(FIELD_OFFSET(WZC_DEVICE_NOTIF, wmiNodeHdr) + pWnodeHdr->BufferSize);
    if (pDevNotif == NULL)
    {
        dwErr = GetLastError();
        goto exit;
    }

    // translate the specific WMI notification code to WZC notification
    else if (!memcmp( &(pWnodeHdr->Guid), &GUID_NDIS_STATUS_MEDIA_CONNECT, sizeof(GUID)))
        pDevNotif->dwEventType = WZCNOTIF_MEDIA_CONNECT;
    else if (!memcmp( &(pWnodeHdr->Guid), &GUID_NDIS_STATUS_MEDIA_DISCONNECT, sizeof(GUID)))
        pDevNotif->dwEventType = WZCNOTIF_MEDIA_DISCONNECT;
    else if (!memcmp( &(pWnodeHdr->Guid), &GUID_NDIS_NOTIFY_BIND, sizeof(GUID)))
        pDevNotif->dwEventType = WZCNOTIF_ADAPTER_BIND;
    else if (!memcmp( &(pWnodeHdr->Guid), &GUID_NDIS_NOTIFY_UNBIND, sizeof(GUID)))
        pDevNotif->dwEventType = WZCNOTIF_ADAPTER_UNBIND;
    else
    {
        pDevNotif->dwEventType = WZCNOTIF_UNKNOWN;
        DbgPrint((TRC_ERR,"WMI Notification GUID is not recognized"));
        goto exit;
    }

    // copy the WMI notification data into the local buffer
    memcpy(&(pDevNotif->wmiNodeHdr), pWnodeHdr, pWnodeHdr->BufferSize);

    // pDevNotif will be MemFree-ed by the worker thread
    if (!QueueUserWorkItem(
            (LPTHREAD_START_ROUTINE)WZCWrkDeviceNotifHandler,
            (LPVOID)pDevNotif,
            WT_EXECUTELONGFUNCTION))
    {
        dwErr = GetLastError();
        goto exit;
    }

    bDecrement = FALSE;

    // since the working thread has been created successfully, the notification
    // structure allocated above will be free-ed by the thread. Set the local
    // pointer to NULL to prevent the memory from being free-ed prematurely
    // (MemFree does nothing when pointer is NULL)
    pDevNotif = NULL;

exit:
    MemFree(pDevNotif);

    DbgPrint((TRC_TRACK|TRC_NOTIF, "WZCSvcWMIHandler=%d]", dwErr));

    if (bDecrement)
        InterlockedDecrement(&g_nThreads);
}

//-----------------------------------------------------------
VOID
WZCSvcShutdown(IN DWORD dwErrorCode)
{
    DbgPrint((TRC_TRACK,"[WZCSvcShutdown(%d)", dwErrorCode));


    //taroonm:
    TerminatePolicyEngine(hPolicyEngineThread);

    if (g_WZCSvcDeviceNotif != NULL && !UnregisterDeviceNotification(g_WZCSvcDeviceNotif))
    {
        DbgPrint((TRC_ERR,"Err: UnregisterDeviceNotification->%d", GetLastError()));
    }
    // reset the notification handler since it has already been unregistered
    g_WZCSvcDeviceNotif = NULL;

    // unregister from WMI
    WZCSvcWMINotification(FALSE);
    // stop first the RPC server
    WZCSvcStopRPCServer();

    // all the notification registrations have been removed.
    // Block here until all worker/rpc threads terminate.
    DbgPrint((TRC_SYNC,"Waiting for %d thread(s) to terminate", g_nThreads));
    while(g_nThreads != 1)
    {
        Sleep(1000);
        DbgPrint((TRC_SYNC,"Waiting for %d more thread(s).", g_nThreads));
    }

    // save the configuration to the registry
    StoSaveConfig();

    // destroy all the hashes related to the list of interfaces
    // (included the list itself)
    LstDestroyIntfHashes();
    // destroy the timer queue. At this point there should be no timer queued so
    // there is no point in waiting for any completion
    LstDestroyTimerQueue();

    DbgPrint((TRC_TRACK,"WZCSvcShutdown]"));
}

//-----------------------------------------------------------
VOID
WZCWrkDeviceNotifHandler(
    IN  LPVOID pvData)
{
    DWORD                   dwErr = ERROR_SUCCESS;
    PWZC_DEVICE_NOTIF       pDevNotif = (PWZC_DEVICE_NOTIF)pvData;
    PWNODE_SINGLE_INSTANCE  pWnode = (PWNODE_SINGLE_INSTANCE)&(pDevNotif->wmiNodeHdr);
    LPBYTE                  pbDeviceKey = NULL; // pointer in the notification data where the dev key is
    UINT                    nDeviceKeyLen;      // number of bytes for the dev key
    LPWSTR                  pwszDeviceKey = NULL;
    PINTF_CONTEXT           pIntfContext = NULL;
    PHASH_NODE              *ppHash = NULL;     // reference to the hash to use for getting the INTF_CONTEXT
    PHASH_NODE              pHashNode = NULL;   // interface's node in the hash
    BOOL                    bForwardUp = FALSE; // specifies whether the notification needs to passed to the upper layers

    DbgPrint((TRC_TRACK,"[WZCWrkDeviceNotifHandler(wzcnotif %d)", pDevNotif->dwEventType));
    DbgAssert((pDevNotif != NULL, "(null) device notification info!"));

    // don't do one single bit of work if the service is not in the running state
    if (g_WZCSvcStatus.dwCurrentState != SERVICE_RUNNING)
        goto exit;

    // get the Device Key information for the event (either the GUID or the Description)
    switch(pDevNotif->dwEventType)
    {
    case WZCNOTIF_DEVICE_REMOVAL:
    case WZCNOTIF_ADAPTER_UNBIND:
        // do forward up device removal or unbind no matter what
        bForwardUp = TRUE;
        // no break.
    case WZCNOTIF_DEVICE_ARRIVAL:
    case WZCNOTIF_ADAPTER_BIND:
        {
            LPBYTE  pbDeviceKeyEnd = NULL;

            if (pDevNotif->dwEventType == WZCNOTIF_DEVICE_ARRIVAL ||
                pDevNotif->dwEventType == WZCNOTIF_DEVICE_REMOVAL)
            {
                // if the notification comes from SCM, get the pointer to the "\device\{guid}"
                // string from the dbcc_name field
                pbDeviceKey = (LPBYTE)(pDevNotif->dbDeviceIntf.dbcc_name);
            }
            else
            {
	            // check if the notification refers to the NDISUIO transport
                pbDeviceKey = RtlOffsetToPointer(pWnode, pWnode->DataBlockOffset);
                // if this is not a notification for the NDISUIO transport, ignore it.
                if (wcsncmp ((LPWSTR)pbDeviceKey, L"NDISUIO", 7))
                {
                    DbgPrint((TRC_NOTIF,"Ignore WMI Notif %d for Transport %S", 
                                        pDevNotif->dwEventType,
                                        pbDeviceKey));
                    goto exit;
                }
                // get first the pointer to the Transport Name
                pbDeviceKey = RtlOffsetToPointer(pWnode, pWnode->DataBlockOffset);
                // skip to the "\device\{guid}" string
                pbDeviceKey += (wcslen((LPWSTR)pbDeviceKey) + 1) * sizeof(WCHAR);
            }
            // build now the actual "{guid}" string from the L"\DEVICE\{guid}" string
            // pointed by wszGuid
            pbDeviceKey  = (LPBYTE)wcsrchr( (LPWSTR)pbDeviceKey, L'{' );
            if (pbDeviceKey != NULL)
                pbDeviceKeyEnd = (LPBYTE)wcsrchr( (LPWSTR)pbDeviceKey, L'}' );

            if (pbDeviceKey == NULL || pbDeviceKeyEnd == NULL)
            {
                DbgPrint((TRC_ERR,"Err: Mal-formed dbcc_name"));
                goto exit;
            }
            // include the closing curved bracket in the GUID string
            pbDeviceKeyEnd += sizeof(WCHAR);
            nDeviceKeyLen = (UINT)(pbDeviceKeyEnd - pbDeviceKey);
            // get the reference to the GUID hash. This will be used in order to locate 
            // the interface context. This reference is guaranteed to exist since it is a static 
            // global variable.
            ppHash = &g_lstIntfHashes.pHnGUID;
            break;
        }

    case WZCNOTIF_MEDIA_DISCONNECT:
    case WZCNOTIF_MEDIA_CONNECT:
        {
            LPBYTE pbDeviceKeyEnd = NULL;

            // disconnect should be forwarded up no matter what
            // for connects, we assume we'll forward it up. After dispatching the event
            // to the state machine, if this resulted in a WZC notification we'll block
            // the forwarding.
            bForwardUp = TRUE;

            // for MEDIA_CONNECT / DISCONNECT events, we also get the adapter's GUID
            pbDeviceKey = RtlOffsetToPointer(pWnode, pWnode->DataBlockOffset);
            // build now the actual "{guid}" string from the L"\DEVICE\{guid}" string
            // pointed by wszGuid
            pbDeviceKey = (LPBYTE)wcsrchr( (LPWSTR)pbDeviceKey, L'{' );
            if (pbDeviceKey != NULL)
                pbDeviceKeyEnd = (LPBYTE)wcsrchr( (LPWSTR)pbDeviceKey,L'}' );

            if (pbDeviceKey == NULL || pbDeviceKeyEnd == NULL)
            {
                DbgPrint((TRC_ERR,"Err: Mal-formed device name"));
                goto exit;
            }
            pbDeviceKeyEnd += sizeof(WCHAR);
            nDeviceKeyLen = (UINT)(pbDeviceKeyEnd - pbDeviceKey);
            // get the reference to the GUID hash. This will be used in order to locate 
            // the interface context. This reference is guaranteed to exist since it is a static 
            // global variable.
            ppHash = &g_lstIntfHashes.pHnGUID;
            break;
        }
        // no need to specify "default:" as the event type has been already filtered
        // out to one of the valid events
    }

    // get memory for GUID (add space for the null terminator)
    pwszDeviceKey = (LPWSTR)MemCAlloc(nDeviceKeyLen + sizeof(WCHAR));
    if (pwszDeviceKey == NULL)
    {
        dwErr = GetLastError();
        goto exit;
    }
    // copy the GUID string in the key (because of the CAlloc, the '\0' is already there)
    memcpy(pwszDeviceKey, pbDeviceKey, nDeviceKeyLen);

    // locate now the INTF_CONTEXT structure related to this notification
    // and keep the lock on the hashes all the time (since the PnP event mostly sure
    // results in removing / adding an interface context which means altering the
    // hash)
    EnterCriticalSection(&(g_lstIntfHashes.csMutex));
    dwErr = HshQueryObjectRef(
                *ppHash,
                pwszDeviceKey,
                &pHashNode);
    if (dwErr == ERROR_SUCCESS)
    {
        pIntfContext = (PINTF_CONTEXT)pHashNode->pObject;

        // at this point we know the notification type, the key info and
        // the INTERFACE_CONTEXT object (if any) for the device.
        DbgPrint((TRC_NOTIF,"WZCNotif %d for Device Key \"%S\". Context=0x%p",
            pDevNotif->dwEventType,
            pwszDeviceKey,
            pIntfContext));
    }

    // forward now the notification for processing
    dwErr = LstNotificationHandler(&pIntfContext, pDevNotif->dwEventType, pwszDeviceKey);

    // At this point, bForwardUp is FALSE only for ADAPTER_BIND or DEVICE_ARRIVAL
    // If this is a new adapter, but not a wireless one, pass up the notification.
    if (pDevNotif->dwEventType == WZCNOTIF_ADAPTER_BIND || pDevNotif->dwEventType == WZCNOTIF_DEVICE_ARRIVAL)
        bForwardUp = bForwardUp || (dwErr == ERROR_MEDIA_INCOMPATIBLE);

    // At this point, bForwardUp is FALSE only for ADAPTER_BIND or DEVICE_ARRIVAL for a wireless adapter
    // If WZC doesn't seem to be enabled for this adapter, pass up the notification
    if (dwErr == ERROR_SUCCESS && pIntfContext != NULL)
        bForwardUp = bForwardUp || ((pIntfContext->dwCtlFlags & INTFCTL_ENABLED) == 0);

    // At this point, bForwardUp is FALSE only for ADAPTER_BIND or DEVICE_ARRIVAL for a wireless adapter
    // on which WZC is enabled. For all the other cases, notification is passed through.

    // All that remains is to block the pass-through of the notification if we deal with a valid context
    // for which INTFCTL_INTERNAL_BLK_MEDIACONN bit is set. This bit is being set in StateNotifyFn
    // and it is reset after processing each event / command so it is only a narrow case where we really 
    // need to block. We do block it because one WZC notification must have already been sent up so
    // there is totally redundant to pass another one up.
    if (pIntfContext != NULL)
    {
        bForwardUp = bForwardUp && !(pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_BLK_MEDIACONN);

        // now, since we determined whether we need or not to pass up the PnP notification
        // we can (and must) clear up the INTFCTL_INTERNAL_BLK_MEDIACONN bit.
        pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_BLK_MEDIACONN;
    }

    // for all the remaining cases, the notification is going to be substituted 
    // later (in {SN} state) with a "WZCNOTIF_WZC_CONNECT" notification. Assume something goes wrong 
    // and the interface never gets to {SN}, it means there is no reason for the upper layer to act
    // on an interface for which the underlying layer (Zero Conf) failed.

    // unlock the hashes at the end
    LeaveCriticalSection(&(g_lstIntfHashes.csMutex));

    if (bForwardUp)
    {
        // Notify upper level app (802.1x) that the selected
        // 802.11 configuration is successful.
        DbgPrint((TRC_NOTIF, "Passing through notification %d",pDevNotif->dwEventType));
        dwErr = ElMediaEventsHandler(pDevNotif);
        DbgAssert((dwErr == ERROR_SUCCESS, "Error or Exception 0x%x when passing through notification", dwErr));
    }

exit:
    MemFree(pwszDeviceKey);
    MemFree(pDevNotif);

    DbgPrint((TRC_TRACK,"WZCWrkDeviceNotifHandler=%d]", dwErr));

    // decrement the thread counter
    InterlockedDecrement(&g_nThreads);
}

//-----------------------------------------------------------
// WZCTimeoutCallback: timer callback routine. It should not lock any cs, but just spawn
// the timer handler routine after referencing the context (to avoid premature deletion)
VOID WINAPI
WZCTimeoutCallback(
    IN PVOID pvData,
    IN BOOL  fTimerOrWaitFired)
{
    DWORD         dwErr = ERROR_SUCCESS;
    PINTF_CONTEXT pIntfContext = (PINTF_CONTEXT)pvData;
    BOOL          bDecrement = TRUE;

    // increment the thread counter the first thing!
    InterlockedIncrement(&g_nThreads);

    DbgPrint((TRC_TRACK|TRC_NOTIF, "[WZCTimeoutCallback(0x%p)", pIntfContext));
    DbgAssert((pIntfContext != NULL, "Invalid (null) context in timer callback!"));

    // reference the context to make sure no one will delete it unexpectedly.
    LstRccsReference(pIntfContext);

    if (!QueueUserWorkItem(
            (LPTHREAD_START_ROUTINE)WZCSvcTimeoutHandler,
            (LPVOID)pIntfContext,
            WT_EXECUTELONGFUNCTION))
    {
        dwErr = GetLastError();
        goto exit;
    }

    bDecrement = FALSE;

exit:
    DbgPrint((TRC_TRACK|TRC_NOTIF, "WZCTimeoutCallback=%d]", dwErr));

    if (bDecrement)
    {
        // getting here would be really bad - it would mean we failed to spawn the
        // timer handler. We need to make sure we not unbalance the reference counter
        // on the context. The counter can't get to 0 since the device notification thread
        // is waiting for all the timer routines to complete.
        InterlockedDecrement(&(pIntfContext->rccs.nRefCount));
        InterlockedDecrement(&g_nThreads);
    }
}

//-----------------------------------------------------------
VOID
WZCSvcTimeoutHandler(
    IN PVOID pvData)
{
    DWORD         dwErr = ERROR_SUCCESS;
    PINTF_CONTEXT pIntfContext = (PINTF_CONTEXT)pvData;

    DbgPrint((TRC_TRACK,"[WZCSvcTimeoutHandler(0x%p)", pIntfContext));

    // lock the context here (it has been referenced in the timer callback!)
    LstRccsLock(pIntfContext);

    // the timer handler should be a noop in all the following cases:
    // - the service doesn't look to be either starting or running
    // - the timer handler is invalid. This is an indication the context is being destroyed
    // - the timer flag is not set! Same indication the context is being destroyed.
    if ((g_WZCSvcStatus.dwCurrentState == SERVICE_RUNNING || g_WZCSvcStatus.dwCurrentState == SERVICE_START_PENDING) &&
        (pIntfContext->hTimer != INVALID_HANDLE_VALUE) && 
        (pIntfContext->dwCtlFlags & INTFCTL_INTERNAL_TM_ON))
    {
        // since the timer fired already for this event and we only deal with
        // one time timers, reset the TIMER_ON flag for this context:
        pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_TM_ON;

        // dispatch the timeout event
        dwErr = StateDispatchEvent(
                    eEventTimeout,
                    pIntfContext,
                    NULL);

        // clear up the INTFCTL_INTERNAL_BLK_MEDIACONN bit since this is not a media sense handler
        pIntfContext->dwCtlFlags &= ~INTFCTL_INTERNAL_BLK_MEDIACONN;

        DbgAssert((dwErr == ERROR_SUCCESS,
                   "Dispatching timeout event failed for context 0x%p\n",
                   pIntfContext));
    }

    // unlock unref the context!
    LstRccsUnlockUnref(pIntfContext);

    DbgPrint((TRC_TRACK,"WZCSvcTimeoutHandler=%d]", dwErr));
    InterlockedDecrement(&g_nThreads);
}

//-----------------------------------------------------------
VOID
WZCWrkWzcSendNotif(
    IN  LPVOID pvData)
{
    DWORD                   dwErr = ERROR_SUCCESS;

    DbgPrint((TRC_TRACK,"[WZCWrkWzcSendNotif(0x%p)", pvData));
    DbgPrint((TRC_NOTIF, "Sending WZC_CONFIG_NOTIF to upper level apps"));
    dwErr = ElMediaEventsHandler(pvData);

    DbgPrint((TRC_TRACK,"WZCWrkWzcSendNotif]=%d", dwErr));
    InterlockedDecrement(&g_nThreads);
}

//-----------------------------------------------------------
//  EAPOLQueryGUIDNCSState
//  Called by Netman module query the ncs state of the GUID under 802.1X control
//  Arguments:
//      pGuidConn - Interface GUID
//      pncs - NCS status of the interface
//  Returns:    
//      S_OK - network connection status is reported by WZC
//      S_FALSE - status is not controlled by WZC
HRESULT
WZCQueryGUIDNCSState (
    IN  GUID           *pGuidConn,
    OUT NETCON_STATUS  *pncs)
{
    HRESULT     hr = S_FALSE;

    InterlockedIncrement(&g_nThreads);
    // check if the service is still running, return the call instantly
    if (g_WZCSvcStatus.dwCurrentState == SERVICE_RUNNING || 
        g_WZCSvcStatus.dwCurrentState == SERVICE_START_PENDING)
    {
        // check what Zero Config says about the adapter's status
        if (hr == S_FALSE)
        {
            WCHAR wszGuid[64]; // enough for "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"

            // convert the GUID to "{xxx...}" and get the ncStatus from the interface context (if any)
            if (StringFromGUID2(pGuidConn, wszGuid, 64) != 0)
                hr = LstQueryGUIDNCStatus(wszGuid, pncs);
        }

        // check what 802.1x says about the adapter's status
        if (hr == S_FALSE)
        {
            hr = EAPOLQueryGUIDNCSState (
                    pGuidConn,
                    pncs);
        }
    }
    InterlockedDecrement(&g_nThreads);
    return hr;
}

//-----------------------------------------------------------
//  EAPOLQueryGUIDNCSState
//  WZCTrayIconReady
//
//  Purpose:    Called by Netman module to inform about Tray being
//              ready for notifications from WZCSVC
//  Arguments:
//      pszUserName - Username of the user logged in on the desktop
//  Returns:    
//      None
VOID
WZCTrayIconReady (
    IN const WCHAR * pszUserName)
{
    EAPOLTrayIconReady(pszUserName);
}

//-----------------------------------------------------------
// WZCContextInit
// Description:Initialises an internal context with default values
// Parameters: pointer to an internal context with storage pre allocated
// Returns: win32 error code
DWORD WZCContextInit(PWZC_INTERNAL_CONTEXT pwzcICtxt)
{
    DWORD dwErr = ERROR_SUCCESS;

    DbgPrint((TRC_TRACK,"[WZCContextInit(%p=%d)", pwzcICtxt, pwzcICtxt->bValid));

    if (pwzcICtxt->bValid)
    {
        dwErr = ERROR_ALREADY_INITIALIZED;
    }
    else
    {
        PWZC_CONTEXT pwzcCtxt = &(pwzcICtxt->wzcContext);

        DbgPrint((TRC_TRACK,"Initializing wzc context"));

        // null out the service's context
        ZeroMemory(pwzcCtxt, sizeof(WZC_CONTEXT));

        __try
	    {
            //set defaults
            pwzcCtxt->tmTr = TMMS_DEFAULT_TR;
            pwzcCtxt->tmTc = TMMS_DEFAULT_TC;
            pwzcCtxt->tmTp = TMMS_DEFAULT_TP;
            pwzcCtxt->tmTf = TMMS_DEFAULT_TF;
            pwzcCtxt->tmTd = TMMS_DEFAULT_TD;

            //Init CriticalSection
            InitializeCriticalSection(&(pwzcICtxt->csContext));

            DbgPrint((TRC_TRACK,"Critical section initialized successfully"));

            // mark the context is valid
            pwzcICtxt->bValid = TRUE;
	    }
        __except(EXCEPTION_EXECUTE_HANDLER)
	    {
            dwErr = GetExceptionCode();
        }

        if (dwErr == ERROR_SUCCESS)
        {
            dwErr = LstConstructIntfContext(
                        NULL,
                        &(pwzcICtxt->pIntfTemplate));
        }
    }

    DbgPrint((TRC_TRACK,"WZCContextInit]=%d", dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// WZCContextDestroy
// Description:Destroys an internal context with default values
// Parameters: pointer to an internal context initialised using WZCContextInit
// Returns: win32 error code
DWORD WZCContextDestroy(PWZC_INTERNAL_CONTEXT pwzcICtxt)
{
    DWORD dwErr = ERROR_SUCCESS;
    PWZC_CONTEXT pwzcCtxt = NULL;

    DbgPrint((TRC_TRACK,"[WZCContextDestroy"));

    if (pwzcICtxt->bValid)
    {
        // destroy the global context here
        LstDestroyIntfContext(pwzcICtxt->pIntfTemplate);
        pwzcICtxt->pIntfTemplate = NULL;

        pwzcICtxt->bValid = FALSE;
        //Destroy critical section
        DeleteCriticalSection(&(pwzcICtxt->csContext));
    }

    DbgPrint((TRC_TRACK,"WZCContextDestroy]=%d", dwErr));
    return dwErr;
}


//-----------------------------------------------------------
// WzcContextQuery
// Description: Queries specified params in the global context and sends the 
// values back to the client.
// Parameters:
// [in] dwInFlags - Bitmask of the  WZC_CTL_* flags, indicates the 
// appropriate parameter.
// [out] pContext - Holds current values requested by user
// [out] pdwOutFlags - Indicates the values that were successfully returned
// Returns: win32 error code
DWORD WzcContextQuery(
        DWORD dwInFlags,
        PWZC_CONTEXT pContext, 
		LPDWORD pdwOutFlags)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwOutFlags = 0;
    PWZC_CONTEXT pwzcCtxt = &g_wzcInternalCtxt.wzcContext;

    DbgPrint((TRC_TRACK, "[WzcContextQuery(%d)", dwInFlags));
    if (FALSE == g_wzcInternalCtxt.bValid)
    {
        dwErr = ERROR_ARENA_TRASHED;
        goto exit;
    }

    EnterCriticalSection(&g_wzcInternalCtxt.csContext);
    if (dwInFlags & WZC_CONTEXT_CTL_LOG)
    {
        pContext->dwFlags |= (DWORD)(pwzcCtxt->dwFlags & WZC_CTXT_LOGGING_ON);
        dwOutFlags |= WZC_CONTEXT_CTL_LOG;
    }
    if (dwInFlags & WZC_CONTEXT_CTL_TIMER_TR)
    {
        pContext->tmTr = pwzcCtxt->tmTr;
        dwOutFlags |= WZC_CONTEXT_CTL_TIMER_TR;
    }
    if (dwInFlags & WZC_CONTEXT_CTL_TIMER_TC)
    {
        pContext->tmTc = pwzcCtxt->tmTc;
        dwOutFlags |= WZC_CONTEXT_CTL_TIMER_TC;
    }
    if (dwInFlags & WZC_CONTEXT_CTL_TIMER_TP)
    {
        pContext->tmTp = pwzcCtxt->tmTp;
        dwOutFlags |= WZC_CONTEXT_CTL_TIMER_TP;
    }
    if (dwInFlags & WZC_CONTEXT_CTL_TIMER_TF)
    {
        pContext->tmTf = pwzcCtxt->tmTf;
        dwOutFlags |= WZC_CONTEXT_CTL_TIMER_TF;
    }
    if (dwInFlags & WZC_CONTEXT_CTL_TIMER_TD)
    {
        pContext->tmTd = pwzcCtxt->tmTd;
        dwOutFlags |= WZC_CONTEXT_CTL_TIMER_TD;
    }
    LeaveCriticalSection(&g_wzcInternalCtxt.csContext);

exit:
    if (pdwOutFlags != NULL)
        *pdwOutFlags = dwOutFlags;

    DbgPrint((TRC_TRACK, "WzcContextQuery(out: 0x%08x)]=%d", dwOutFlags, dwErr));
    return dwErr;
}

//-----------------------------------------------------------
// WzcContextSet
// Description: Sets specified params in the global context to the values
// passed in by the client.
// Parameters:
// [in] dwInFlags - Bitmask of the  WZC_CTL_* flags, indicates the 
// appropriate parameter.
// [in] pContext - Should point to the user specified values
// [out] pdwOutFlags - Indicates the values that were successfully set
// Returns: win32 error code
DWORD WzcContextSet(
        DWORD dwInFlags,
        PWZC_CONTEXT pContext, 
		LPDWORD pdwOutFlags)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwOutFlags = 0;
    PWZC_CONTEXT pwzcCtxt = &g_wzcInternalCtxt.wzcContext;

    DbgPrint((TRC_TRACK, "[WzcContextSet(%d)", dwInFlags));
    if (FALSE == g_wzcInternalCtxt.bValid)
    {
        dwErr = ERROR_ARENA_TRASHED;
        goto exit;
    }

    EnterCriticalSection(&g_wzcInternalCtxt.csContext);
    //Set appropriate entries
    if (dwInFlags & WZC_CONTEXT_CTL_LOG)
    {
        if (pContext->dwFlags & WZC_CTXT_LOGGING_ON)
            pwzcCtxt->dwFlags |= WZC_CONTEXT_CTL_LOG;
        else
            pwzcCtxt->dwFlags &= ~WZC_CONTEXT_CTL_LOG;
        dwOutFlags |= WZC_CONTEXT_CTL_LOG;
    }
    if (dwInFlags & WZC_CONTEXT_CTL_TIMER_TR)
    {
        pwzcCtxt->tmTr = pContext->tmTr;
        dwOutFlags |= WZC_CONTEXT_CTL_TIMER_TR;
    }
    if (dwInFlags & WZC_CONTEXT_CTL_TIMER_TC)
    {
        pwzcCtxt->tmTc = pContext->tmTc;
        dwOutFlags |= WZC_CONTEXT_CTL_TIMER_TC;
    }
    if (dwInFlags & WZC_CONTEXT_CTL_TIMER_TP)
    {
        pwzcCtxt->tmTp = pContext->tmTp;
        dwOutFlags |= WZC_CONTEXT_CTL_TIMER_TP;
    }
    if (dwInFlags & WZC_CONTEXT_CTL_TIMER_TF)
    {
        pwzcCtxt->tmTf = pContext->tmTf;
        dwOutFlags |= WZC_CONTEXT_CTL_TIMER_TF;
    }
    if (dwInFlags & WZC_CONTEXT_CTL_TIMER_TD)
    {
        pwzcCtxt->tmTd = pContext->tmTd;
        dwOutFlags |= WZC_CONTEXT_CTL_TIMER_TD;
    }

    //Save into the registry
    dwErr = StoSaveWZCContext(NULL, &g_wzcInternalCtxt.wzcContext);
    DbgAssert((ERROR_SUCCESS == dwErr, "Error saving context to registry %d",dwErr));
    LeaveCriticalSection(&g_wzcInternalCtxt.csContext);

exit:
    if (pdwOutFlags != NULL)
        *pdwOutFlags = dwOutFlags;

    DbgPrint((TRC_TRACK, "WzcContextSet(out: 0x%08x)]=%d", dwOutFlags, dwErr));
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\utils.c ===
#include <precomp.h>
#include "tracing.h"
#include "utils.h"

//------------------------------------
// Allocates storage for RPC transactions. The RPC stubs will either call
// MIDL_user_allocate when it needs to un-marshall data into a buffer
// that the user must free.  RPC servers will use MIDL_user_allocate to
// allocate storage that the RPC server stub will free after marshalling
// the data.
PVOID
MIDL_user_allocate(IN size_t NumBytes)
{
    PVOID pMem = NULL;
    DWORD dwErr = ERROR_SUCCESS;

    if (NumBytes == 0)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        pMem = LocalAlloc(LMEM_ZEROINIT,NumBytes);
        if (pMem == NULL)
            dwErr = GetLastError();
    }
    DbgPrint((TRC_MEM, "[MIDL_user_allocate(%d)=0x%p;%d]", NumBytes, pMem, dwErr));
    SetLastError(dwErr);
    return pMem;
}

//------------------------------------
// Frees storage used in RPC transactions. The RPC client can call this
// function to free buffer space that was allocated by the RPC client
// stub when un-marshalling data that is to be returned to the client.
// The Client calls MIDL_user_free when it is finished with the data and
// desires to free up the storage.
// The RPC server stub calls MIDL_user_free when it has completed
// marshalling server data that is to be passed back to the client.
VOID
MIDL_user_free(IN LPVOID MemPointer)
{
    DbgPrint((TRC_MEM, "[MIDL_user_free(0x%p)]", MemPointer));
    if (MemPointer != NULL)
        LocalFree(MemPointer);
}


//------------------------------------
// Allocates general usage memory from the process heap
PVOID
Process_user_allocate(IN size_t NumBytes)
{
    PVOID pMem = NULL;
    DWORD dwErr = ERROR_SUCCESS;

    if (NumBytes == 0)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        pMem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, NumBytes);
        if (pMem == NULL)
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    DbgPrint((TRC_MEM, "[MemAlloc(%d)=0x%p;%d]", NumBytes, pMem, dwErr));
    SetLastError(dwErr);
    return pMem;
}

//------------------------------------
// Frees general usage memory
VOID
Process_user_free(IN LPVOID pMem)
{
    DbgPrint((TRC_MEM, "[MemFree(0x%p)]", pMem));
    if (pMem != NULL)
        HeapFree(GetProcessHeap(), 0, (pMem));
}

//-----------------------------------------------------------
// Searches pwzcConfig in the list pwzcVList. The entries are
// matched exclusively based on the matching SSIDs and on 
// matching Infrastructure Mode.
// [in]  pwzcVList: Set of WZC_WLAN_CONFIGs to search in 
// [in]  pwzcConfig: WZC_WLAN_CONFIG to look for
// [in]  nIdx: index in pwzcVList to start searching from
// Returns: Pointer to the entry that matches pwzcConfig or NULL
//          if none matches
PWZC_WLAN_CONFIG
WzcFindConfig(
    PWZC_802_11_CONFIG_LIST pwzcList,
    PWZC_WLAN_CONFIG        pwzcConfig,
    ULONG                   nIdx)
{
    PWZC_WLAN_CONFIG pMatchingConfig = NULL;

    // if there is no config in pwzcList, there is no reason in
    // looking further
    if (pwzcList != NULL)
    {
        ULONG i;

        // for each of the visible SSIDs, see if it matches the given one
        for (i = nIdx; i < pwzcList->NumberOfItems; i++)
        {
            PWZC_WLAN_CONFIG pCrt;

            pCrt = &(pwzcList->Config[i]);

            // the SSIDs match if they have the same InfrastructureMode, their
            // SSID strings have the same length and are the same
            if (pCrt->InfrastructureMode == pwzcConfig->InfrastructureMode &&
                pCrt->Ssid.SsidLength == pwzcConfig->Ssid.SsidLength &&
                RtlCompareMemory(pCrt->Ssid.Ssid, pwzcConfig->Ssid.Ssid, pCrt->Ssid.SsidLength) == pCrt->Ssid.SsidLength)
            {
                pMatchingConfig = pCrt;
                break;
            }
        }
    }

    return pMatchingConfig;
}

//---------------------------------------------------------------------
// Matches the content of the two configurations one against the other.
// [in]  pwzcConfigA: | configs to match
// [in]  pwzcConfigB: |
// [in/out] pbWepDiffOnly: TRUE if there is a difference and the difference is exclusively
//                         in the WEP Key index or in WEP Key Material. Otherwise is false.
// Returns: TRUE if the configs match, FALSE otherwise;
BOOL
WzcMatchConfig(
    PWZC_WLAN_CONFIG        pwzcConfigA,
    PWZC_WLAN_CONFIG        pwzcConfigB,
    PBOOL                   pbWepDiffOnly)
{
    BOOL bDiff;
    BOOL bWepDiff;

    bDiff = (pwzcConfigA->dwCtlFlags & WZCCTL_WEPK_PRESENT) != (pwzcConfigB->dwCtlFlags & WZCCTL_WEPK_PRESENT);
    bDiff = bDiff || (pwzcConfigA->Privacy != pwzcConfigB->Privacy);
    bDiff = bDiff || (pwzcConfigA->InfrastructureMode != pwzcConfigB->InfrastructureMode);
    bDiff = bDiff || (pwzcConfigA->AuthenticationMode != pwzcConfigB->AuthenticationMode);
    bDiff = bDiff || (memcmp(&pwzcConfigA->Ssid, &pwzcConfigB->Ssid, sizeof(NDIS_802_11_SSID)) != 0);

    bWepDiff = (pwzcConfigA->KeyIndex != pwzcConfigB->KeyIndex);
    bWepDiff = bWepDiff || (pwzcConfigA->KeyLength != pwzcConfigB->KeyLength);
    bWepDiff = bWepDiff || (memcmp(&pwzcConfigA->KeyMaterial, &pwzcConfigB->KeyMaterial, WZCCTL_MAX_WEPK_MATERIAL) != 0);

    if (pbWepDiffOnly != NULL)
        *pbWepDiffOnly = (!bDiff && bWepDiff);

    return !bDiff && !bWepDiff;
}


//-----------------------------------------------------------
// Converts an NDIS_802_11_BSSID_LIST object to an equivalent
// (imaged) WZC_802_11_CONFIG_LIST
// [in]  pndList: NDIS BSSID list to convert
// Returns: Pointer to the list of copied WZC configurations
PWZC_802_11_CONFIG_LIST
WzcNdisToWzc(
    PNDIS_802_11_BSSID_LIST pndList)
{
    PWZC_802_11_CONFIG_LIST pwzcList = NULL;

    // if there is no NDIS list, don't do anything
    if (pndList != NULL)
    {
        // allocate space for the WZC image
        pwzcList = (PWZC_802_11_CONFIG_LIST)
                   MemCAlloc(FIELD_OFFSET(WZC_802_11_CONFIG_LIST, Config) + 
                             pndList->NumberOfItems * sizeof(WZC_WLAN_CONFIG));
        // in case allocation failed, return NULL, the caller will know it
        // is an error since he passed down a !NULL pointer.
        if (pwzcList != NULL)
        {
            UINT i;
            LPBYTE prawList = (LPBYTE)&(pndList->Bssid[0]);

            pwzcList->NumberOfItems = pndList->NumberOfItems;

            // for each of the NDIS configs, copy the relevant data into the WZC config
            for (i = 0; i < pwzcList->NumberOfItems; i++)
            {
                PWZC_WLAN_CONFIG    pwzcConfig;
                PNDIS_WLAN_BSSID    pndBssid;

                pwzcConfig = &(pwzcList->Config[i]);
                pndBssid = (PNDIS_WLAN_BSSID)prawList;
                prawList += pndBssid->Length;

                pwzcConfig->Length = sizeof(WZC_WLAN_CONFIG);
                memcpy(&(pwzcConfig->MacAddress), &(pndBssid->MacAddress), sizeof(NDIS_802_11_MAC_ADDRESS));
                memcpy(&(pwzcConfig->Ssid), &(pndBssid->Ssid), sizeof(NDIS_802_11_SSID));
                pwzcConfig->Privacy = pndBssid->Privacy;
                pwzcConfig->Rssi = pndBssid->Rssi;
                pwzcConfig->NetworkTypeInUse = pndBssid->NetworkTypeInUse;
                memcpy(&(pwzcConfig->Configuration), &(pndBssid->Configuration), sizeof(NDIS_802_11_CONFIGURATION));
                pwzcConfig->InfrastructureMode = pndBssid->InfrastructureMode;
                memcpy(&(pwzcConfig->SupportedRates), &(pndBssid->SupportedRates), sizeof(NDIS_802_11_RATES));
            }
        }
    }

    return pwzcList;
}

//-----------------------------------------------------------
// WzcCleanupWzcList: Cleanup a list of WZC_WLAN_CONFIG objects
VOID
WzcCleanupWzcList(
    PWZC_802_11_CONFIG_LIST pwzcList)
{
    if (pwzcList != NULL)
    {
        UINT i;
        
        for (i=0; i<pwzcList->NumberOfItems; i++)
            MemFree(pwzcList->Config[i].rdUserData.pData);

        MemFree(pwzcList);
    }
}

//-----------------------------------------------------------
// RccsInit: Initializes an RCCS structure
DWORD
RccsInit(PRCCS_SYNC pRccs)
{
    DWORD dwErr = ERROR_SUCCESS;

    // assume pRccs is not null (it shouldn't be under any
    // circumstances)
    __try 
    {
        InitializeCriticalSection(&(pRccs->csMutex));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = GetExceptionCode();
    }
    // access through this structure will be paired as Enter/Leave calls
    // Object deletion will bump down the ref counter which will reach 0
    // and will trigger the destruction code.
    pRccs->nRefCount = 1;
    return dwErr;
}

//-----------------------------------------------------------
// RccsInit: Deletes an RCCS structure
DWORD
RccsDestroy(PRCCS_SYNC pRccs)
{
    // assume pRccs is not null (it shouldn't be under any
    // circumstances)
    DeleteCriticalSection(&(pRccs->csMutex));
    return ERROR_SUCCESS;
}

//-----------------------------------------------------------
// WzcCryptBuffer: Randomly generates a nBufLen bytes in the range
// [loByte hiByte], all stored in pBuffer (buffer assumed preallocated)
// Returns a win32 error code.
DWORD
WzcRndGenBuffer(LPBYTE pBuffer, UINT nBufLen, BYTE loByte, BYTE hiByte)
{
    DWORD dwErr = ERROR_SUCCESS;
    HCRYPTPROV hProv = (HCRYPTPROV)NULL;

    if (loByte >= hiByte)
        dwErr = ERROR_INVALID_PARAMETER;

    if (dwErr == ERROR_SUCCESS)
    {
        // acquire the crypt context
        if (!CryptAcquireContext(
                &hProv,
                NULL,
                NULL,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT))
            dwErr = GetLastError();

        DbgAssert((dwErr == ERROR_SUCCESS, "CryptAcquireContext failed with err=%d", dwErr));
    }

    // randomly generate the buffer of bytes
    if (dwErr == ERROR_SUCCESS)
    {
        if (!CryptGenRandom(
                hProv,
                nBufLen,
                pBuffer))
            dwErr = GetLastError();

        DbgAssert((dwErr == ERROR_SUCCESS, "CryptGenRandom failed with err=%d", dwErr));
    }

    // fix each byte from the buffer within the given range
    if (dwErr == ERROR_SUCCESS)
    {
        while (nBufLen > 0)
        {
            *pBuffer = loByte + *pBuffer % (hiByte - loByte + 1);
            pBuffer++;
            nBufLen--;
        }
    }

    // release the crypt context
    if (hProv != (HCRYPTPROV)NULL) 
        CryptReleaseContext(hProv,0);

     return dwErr;
}

//-----------------------------------------------------------
// WzcIsNullBuffer: Checks whether a buffer of nBufLen characters
// is all filled with null characters.
BOOL
WzcIsNullBuffer(LPBYTE pBuffer, UINT nBufLen)
{
    for (;nBufLen > 0 && *pBuffer == 0; pBuffer++, nBufLen--);
    return (nBufLen == 0);
}

//-----------------------------------------------------------
// WzcSSKClean: Cleans up the PSEC_SESSION_KEYS object given as parameter
VOID
WzcSSKClean(PSEC_SESSION_KEYS pSSK)
{
    if (pSSK->dblobSendKey.pbData != NULL)
    {
        LocalFree(pSSK->dblobSendKey.pbData);
        pSSK->dblobSendKey.cbData = 0;
        pSSK->dblobSendKey.pbData = NULL;
    }
    if (pSSK->dblobReceiveKey.pbData != NULL)
    {
        LocalFree(pSSK->dblobReceiveKey.pbData);
        pSSK->dblobReceiveKey.cbData = 0;
        pSSK->dblobReceiveKey.pbData = NULL;
    }
}

//-----------------------------------------------------------
// WzcSSKFree: Frees up the memory used by the PSEC_SESSION_KEYS parameter
VOID
WzcSSKFree(PSEC_SESSION_KEYS pSSK)
{
    if (pSSK != NULL)
    {
        WzcSSKClean(pSSK);
        MemFree(pSSK);
    }
}

//-----------------------------------------------------------
// WzcSSKEncrypt: Creates/Allocates a SEC_SESSION_KEYS object
// by encrypting the SESSION_KEYS object provided as parameter.
DWORD
WzcSSKEncrypt(PSEC_SESSION_KEYS pSSK, PSESSION_KEYS pSK)
{
    DWORD dwErr = ERROR_SUCCESS;
    DATA_BLOB blobIn;
    DATA_BLOB blobSndOut = {0, NULL};
    DATA_BLOB blobRcvOut = {0, NULL};

    if (pSSK == NULL || pSK == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    blobIn.cbData = pSK->dwKeyLength;
    blobIn.pbData = pSK->bSendKey;
    if (!CryptProtectData(
            &blobIn,        // DATA_BLOB *pDataIn,
            L"",            // LPCWSTR szDataDescr,
            NULL,           // DATA_BLOB *pOptionalEntropy,
            NULL,           // PVOID pvReserved,
            NULL,           // CRYPTPROTECT_PROMPTSTRUCT *pPromptStrct,
            0,              // DWORD dwFlags,
            &blobSndOut))   // DATA_BLOB *pDataOut
    {
        dwErr = GetLastError();
        goto exit;
    }

    blobIn.cbData = pSK->dwKeyLength;
    blobIn.pbData = pSK->bReceiveKey;
    if (!CryptProtectData(
            &blobIn,        // DATA_BLOB *pDataIn,
            L"",            // LPCWSTR szDataDescr,
            NULL,           // DATA_BLOB *pOptionalEntropy,
            NULL,           // PVOID pvReserved,
            NULL,           // CRYPTPROTECT_PROMPTSTRUCT *pPromptStrct,
            0,              // DWORD dwFlags,
            &blobRcvOut))   // DATA_BLOB *pDataOut
    {
        dwErr = GetLastError();
        goto exit;
    }

    pSSK->dblobSendKey = blobSndOut;
    pSSK->dblobReceiveKey = blobRcvOut;

exit:
    if (dwErr != ERROR_SUCCESS)
    {
        if (blobSndOut.pbData != NULL)
            LocalFree(blobSndOut.pbData);
        if (blobRcvOut.pbData != NULL)
            LocalFree(blobRcvOut.pbData);
    }
    return dwErr;
}

//-----------------------------------------------------------
// WzcSSKDecrypt: Creates/Allocates a SESSION_KEYS object
// by dencrypting the SEC_SESSION_KEYS object provided as parameter.
DWORD
WzcSSKDecrypt(PSEC_SESSION_KEYS pSSK, PSESSION_KEYS pSK)
{
    DWORD dwErr = ERROR_SUCCESS;
    DATA_BLOB blobSndOut = {0, NULL};
    DATA_BLOB blobRcvOut = {0, NULL};

    if (pSSK == NULL || pSK == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if (!CryptUnprotectData(
            &(pSSK->dblobSendKey),
            NULL,
            NULL,
            NULL,
            NULL,
            0,
            &blobSndOut))
    {
        dwErr = GetLastError();
        goto exit;
    }

    if (blobSndOut.cbData > MAX_SESSION_KEY_LENGTH)
    {
        dwErr = ERROR_INVALID_DATA;
        goto exit;
    }

    if (!CryptUnprotectData(
            &(pSSK->dblobReceiveKey),
            NULL,
            NULL,
            NULL,
            NULL,
            0,
            &blobRcvOut))
    {
        dwErr = GetLastError();
        goto exit;
    }

    if (blobRcvOut.cbData != blobSndOut.cbData)
    {
        dwErr = ERROR_INVALID_DATA;
        goto exit;
    }

    pSK->dwKeyLength = blobSndOut.cbData;
    memcpy(pSK->bSendKey, blobSndOut.pbData, blobSndOut.cbData);
    memcpy(pSK->bReceiveKey, blobRcvOut.pbData, blobRcvOut.cbData);

exit:
    if (blobSndOut.pbData != NULL)
        LocalFree(blobSndOut.pbData);
    if (blobRcvOut.pbData != NULL)
        LocalFree(blobRcvOut.pbData);
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\resources\eapollog.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    eapolmsg.h

Abstract:

    This module contains text messages used to generate event-log entries
    by EAPOL service.

Revision History:

    sachins, Apr 25 2000, Created

--*/


#define EAPOL_LOG_BASE                              2000

#define EAPOL_LOG_SERVICE_STARTED                         (EAPOL_LOG_BASE+1)
/*
 * EAPOL service was started successfully
 */

#define EAPOL_LOG_SERVICE_STOPPED                         (EAPOL_LOG_BASE+2)
/*
 * EAPOL service was stopped successfully
 */

#define EAPOL_LOG_SERVICE_RUNNING                         (EAPOL_LOG_BASE+3)
/*
 * EAPOL service is running
 */

#define EAPOL_LOG_UNKNOWN_ERROR                           (EAPOL_LOG_BASE+4)
/*
 * Unknown EAPOL error
 */

#define EAPOL_LOG_BASE_END                          (EAPOL_LOG_BASE+999)
/*
 * end.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\service\wzeroconf.h ===
#pragma once

#define WZEROCONF_SERVICE       TEXT("wzcsvc")
#define WZEROCONF_DLL           TEXT("wzcsvc.dll")
#define WZEROCONF_ENTRY_POINT        "WZCSvcMain"

typedef VOID (*PWZC_SERVICE_ENTRY) (IN DWORD argc, IN LPTSTR argv[]);

VOID
StartWZCService(
    IN DWORD  argc,
    IN LPWSTR argv[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\resources\eapoldlg.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//
#define BID_Dialer                      100
#define DID_DR_DialerUD                 117
#define CID_DR_EB_User                  1104
#define CID_DR_EB_Password              1103
#define CID_DR_PB_DialConnect           1590
#define CID_DR_PB_Cancel                1591
#define CID_DR_BM_Useless               1100
#define CID_DR_ST_User                  1413
#define CID_DR_ST_Password              1112
#define CID_DR_ST_Domain                1110
#define CID_DR_EB_Domain                1102
#define SID_NeedEapKeys                 1570
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\service\precomp.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\wzcsvc.h ===
#pragma once
#include "intflist.h"

extern HINSTANCE g_hInstance;
extern UINT g_nThreads;

VOID WINAPI
WZCSvcMain(
    IN DWORD   dwArgc,
    IN LPTSTR *lpszArgv);

DWORD
WZCSvcWMINotification(
    IN BOOL bRegister);

DWORD
WZCSvcUpdateStatus();

DWORD
WZCSvcControlHandler(
    IN DWORD dwControl,
    IN DWORD dwEventType,
    IN PVOID pEventData,
    IN PVOID pContext);

VOID CALLBACK
WZCSvcWMINotificationHandler(
    IN PWNODE_HEADER    pWnodeHdr,
    IN UINT_PTR         uiNotificationContext);

// all the device notifications are forwarded from the specific 
// handler to the central handler below.
VOID
WZCWrkDeviceNotifHandler(
    IN  LPVOID pvData);

// WZCTimeoutCallback: timer callback routine. It should not lock any cs, but just spawn
// the timer handler routine after referencing the context (to avoid premature deletion)
VOID WINAPI
WZCTimeoutCallback(
    IN PVOID pvData,
    IN BOOL  fTimerOrWaitFired);

VOID
WZCSvcTimeoutHandler(
    IN PVOID pvData);

VOID
WZCWrkWzcSendNotif(
    IN  LPVOID pvData);

VOID
WZCSvcShutdown(IN DWORD dwErrorCode);


// Internal WZC service settings.
typedef struct _WZC_INTERNAL_CONTEXT
{
    BOOL             bValid;        // indicates whether the context is valid (cs is initialized)
    WZC_CONTEXT      wzcContext;    // global WZC settings (timers, flags, etc)
    PINTF_CONTEXT    pIntfTemplate; // global interface context template.
    CRITICAL_SECTION csContext;
} WZC_INTERNAL_CONTEXT, *PWZC_INTERNAL_CONTEXT;

// WZCContextInit, WZCContextDestroy
// Description: Initialise and Destroy a context
// Parameters: 
//     [in] pwzcICtxt, pointer to a valid internal context object
// Returns: Win32 error code
DWORD WZCContextInit(
    IN PWZC_INTERNAL_CONTEXT pwzcICtxt);
DWORD WZCContextDestroy(
    IN PWZC_INTERNAL_CONTEXT pwzcICtxt);

// WzcContextQuery, WzcContextSet
// Description: Query and set the context
// Returns: win32 error code
DWORD WzcContextQuery(
    DWORD dwInFlags,
    PWZC_CONTEXT pContext, 
    LPDWORD pdwOutFlags);
DWORD WzcContextSet(
    DWORD dwInFlags,
    PWZC_CONTEXT pContext, 
    LPDWORD pdwOutFlags);

extern WZC_INTERNAL_CONTEXT g_wzcInternalCtxt;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\service\wzeroconf.c ===
#include <precomp.h>
#include "WZeroConf.h"

SERVICE_TABLE_ENTRY WZCServiceDispatchTable[] = 
{{ WZEROCONF_SERVICE, StartWZCService },
 { NULL, NULL}
};

VOID _cdecl 
main(VOID)
{
    (VOID) StartServiceCtrlDispatcher(WZCServiceDispatchTable);
}

VOID
StartWZCService(IN DWORD argc,IN LPWSTR argv[])
{
    HMODULE             hSvcDll = NULL;
    PWZC_SERVICE_ENTRY  pfnSvcEntry = NULL;

    // Load the DLL that contains the service.
    hSvcDll = LoadLibrary(WZEROCONF_DLL);
    if (hSvcDll == NULL)
        return;

    // Get the address of the service's main entry point.  This
    // entry point has a well-known name.
    pfnSvcEntry = (PWZC_SERVICE_ENTRY) GetProcAddress(
                                            hSvcDll,
                                            WZEROCONF_ENTRY_POINT);
    if (pfnSvcEntry == NULL)
        return;

    // Call the service's main entry point.  This call doesn't return
    // until the service exits.
    pfnSvcEntry(argc, argv);

    // Unload the DLL.
    //FreeLibrary(hSvcDll);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\argparse.c ===
#include <precomp.h>
#include "ErrCtrl.h"
#include "Utils.h"
#include "ArgParse.h"

//----------------------------------------------------
// Utility function for parsing an UINT type of argument;
DWORD
FnPaUint(LPWSTR *pwszArg, WCHAR wchTerm, UINT *pnValue)
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT nValue = 0;
    LPWSTR wszArg = (*pwszArg);

    if (*wszArg == L'\0' || *wszArg == wchTerm)
        dwErr = ERROR_BAD_FORMAT;
    else
    {
        for (nValue = 0; *wszArg != L'\0' && iswdigit(*wszArg); wszArg++)
        {
            if (*wszArg == wchTerm)
                break;
            nValue = nValue * 10 + ((*wszArg) - L'0');
        }

        if (*wszArg != wchTerm)
            dwErr = ERROR_BAD_FORMAT;
        else if (pnValue != NULL)
            *pnValue = nValue;
    }

    *pwszArg = wszArg;

    SetLastError(dwErr);
    return dwErr;
}

//----------------------------------------------------
// Utility function for parsing two hexa digits (one byte)
DWORD
FnPaByte(LPWSTR *pwszArg, BYTE *pbtValue)
{
    DWORD dwErr = ERROR_SUCCESS;
    BYTE btValue = 0;
    LPWSTR wszArg = (*pwszArg);

    if (iswxdigit(*wszArg))
    {
        btValue = HEX(*wszArg);
        wszArg++;
    }
    else
        dwErr = ERROR_BAD_FORMAT;

    if (dwErr == ERROR_SUCCESS && iswxdigit(*wszArg))
    {
        btValue <<= 4;
        btValue |= HEX(*wszArg);
        wszArg++;
    }
    else
        dwErr = ERROR_BAD_FORMAT;

    if (dwErr == ERROR_SUCCESS && pbtValue != NULL)
        *pbtValue = btValue;

    *pwszArg = wszArg;

    SetLastError(dwErr);
    return dwErr;
}

//----------------------------------------------------
// Utility function for common postprocessing of argument parsing routines
DWORD
FnPaPostProcess(DWORD dwErr, PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry)
{
    if (dwErr == ERROR_SUCCESS)
    {
        // it is guaranteed that when parsing the argument of a parameter
        // the parameter itself is encountered for the first time. Consequently
        // there is no need for checking whether this argumented param ever occured before.
        pPDData->dwArgumentedParams |= pPDEntry->nParamID;
    }

    SetLastError(dwErr);
    return dwErr;
}

//----------------------------------------------------
// Parser for the Guid type of argument
DWORD
FnPaGuid(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR wszGuid = NULL;
    UINT nGuidLen = wcslen(wszParamArg);

    if (nGuidLen < 1)
        dwErr = ERROR_BAD_FORMAT;
    
    if (dwErr == ERROR_SUCCESS)
    {
        // create a buffer for the GUID 
        wszGuid = MemCAlloc((nGuidLen + 1) * sizeof(WCHAR));
        if (wszGuid == NULL)
            dwErr = GetLastError();
    }

    if (dwErr == ERROR_SUCCESS)
    {
        wcscpy(wszGuid, wszParamArg);
        MemFree(pPDData->wzcIntfEntry.wszGuid);
        // copy the GUID into the param descriptors data
        pPDData->wzcIntfEntry.wszGuid = wszGuid;
    }

    return FnPaPostProcess(dwErr, pPDData, pPDEntry);
}

//----------------------------------------------------
// Parser for the argument of the "mask" parameter
DWORD
FnPaMask(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg)
{
    DWORD dwErr = ERROR_SUCCESS;
    NDIS_802_11_NETWORK_INFRASTRUCTURE ndIm;

    dwErr = FnPaUint(&wszParamArg, L'\0', (UINT *)&ndIm);

    if (dwErr == ERROR_SUCCESS)
    {
        if (ndIm > Ndis802_11AutoUnknown)
            dwErr = ERROR_INVALID_DATA;
        else
        {
            pPDData->wzcIntfEntry.dwCtlFlags &= ~INTFCTL_CM_MASK;
            pPDData->wzcIntfEntry.dwCtlFlags |= ndIm;
        }
    }

    return FnPaPostProcess(dwErr, pPDData, pPDEntry);
}

//----------------------------------------------------
// Parser for the argument of the "enabled" parameter
DWORD
FnPaEnabled(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL bEnabled;

    dwErr = FnPaUint(&wszParamArg, L'\0', (UINT *)&bEnabled);

    if (dwErr == ERROR_SUCCESS)
    {
        if (bEnabled > 1)
            dwErr = ERROR_INVALID_DATA;
        else if (bEnabled)
            pPDData->wzcIntfEntry.dwCtlFlags |= INTFCTL_ENABLED;
        else
            pPDData->wzcIntfEntry.dwCtlFlags &= ~INTFCTL_ENABLED;
    }

    return FnPaPostProcess(dwErr, pPDData, pPDEntry);
}

//----------------------------------------------------
// Parser for the argument of the "ssid" parameter
DWORD
FnPaSsid(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg)
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT nSsidWLen = wcslen(wszParamArg);
    UINT nSsidALen;
    LPBYTE pbtSsid = NULL;

    // ssid is hardcoded to 32 bytes in ntddndis.h
    pbtSsid = MemCAlloc(33);
    if (pbtSsid == NULL)
        dwErr = GetLastError();

    // trim out the '"' if any
    if (dwErr == ERROR_SUCCESS &&
        nSsidWLen > 2 && wszParamArg[0] == L'"' && wszParamArg[nSsidWLen-1] == '"')
    {
        wszParamArg++; nSsidWLen-=2;
        wszParamArg[nSsidWLen+1] = L'\0';
    }

    if (dwErr == ERROR_SUCCESS)
    {
        nSsidALen = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        wszParamArg,
                        wcslen(wszParamArg)+1,
                        pbtSsid,
                        33,
                        NULL,
                        NULL);
        // the call above includes the '\0' in the count of
        // characters converted. Normalize the length then,
        // (failure => all "f"s which is higher than 32 hence error)
        nSsidALen--;
        // a valid SSID should contain at least 1 char, and no more than 32
        if (nSsidALen < 1 || nSsidALen > 32)
            dwErr = ERROR_INVALID_DATA;
    }

    if (dwErr == ERROR_SUCCESS)
    {
        pPDData->wzcIntfEntry.rdSSID.dwDataLen = nSsidALen;
        pPDData->wzcIntfEntry.rdSSID.pData = pbtSsid;
    }
    else
        MemFree(pbtSsid);

    return FnPaPostProcess(dwErr, pPDData, pPDEntry);
}

//----------------------------------------------------
// Parser for the argument of the "bssid" parameter
DWORD
FnPaBssid(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg)
{
    DWORD dwErr = ERROR_SUCCESS;
    PNDIS_802_11_MAC_ADDRESS  pndMac = NULL;
    UINT i;

    // allocate space for the mac address
    pndMac = MemCAlloc(sizeof(NDIS_802_11_MAC_ADDRESS));
    if (pndMac == NULL)
        dwErr = GetLastError();

    for (i = 0; dwErr == ERROR_SUCCESS && i < sizeof(NDIS_802_11_MAC_ADDRESS); i++)
    {
        dwErr = FnPaByte(&wszParamArg, &((*pndMac)[i]));
        if (dwErr == ERROR_SUCCESS)
        {
            if (i != sizeof(NDIS_802_11_MAC_ADDRESS)-1 && *wszParamArg == L':')
                wszParamArg++;
            else if (i != sizeof(NDIS_802_11_MAC_ADDRESS)-1 || *wszParamArg != L'\0')
                dwErr = ERROR_BAD_FORMAT;
        }
    }

    if (dwErr == ERROR_SUCCESS)
    {
        pPDData->wzcIntfEntry.rdBSSID.dwDataLen = sizeof(NDIS_802_11_MAC_ADDRESS);
        pPDData->wzcIntfEntry.rdBSSID.pData = (LPBYTE)pndMac;
    }
    else
    {
        MemFree(pndMac);
    }

    return FnPaPostProcess(dwErr, pPDData, pPDEntry);
}

//----------------------------------------------------
// Parser for the argument of the "im" parameter
DWORD
FnPaIm(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg)
{
    DWORD dwErr = ERROR_SUCCESS;
    NDIS_802_11_NETWORK_INFRASTRUCTURE ndIm;

    dwErr = FnPaUint(&wszParamArg, L'\0', (UINT *)&ndIm);

    if (dwErr == ERROR_SUCCESS)
    {
        if (ndIm > Ndis802_11Infrastructure)
            dwErr = ERROR_INVALID_DATA;
        else
            pPDData->wzcIntfEntry.nInfraMode = ndIm;
    }

    return FnPaPostProcess(dwErr, pPDData, pPDEntry);
}

//----------------------------------------------------
// Parser for the argument of the "am" parameter
DWORD
FnPaAm(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg)
{
    DWORD dwErr = ERROR_SUCCESS;
    NDIS_802_11_AUTHENTICATION_MODE ndAm;

    dwErr = FnPaUint(&wszParamArg, L'\0', (UINT *)&ndAm);

    if (dwErr == ERROR_SUCCESS)
    {
        if (ndAm > Ndis802_11AuthModeShared)
            dwErr = ERROR_INVALID_DATA;
        else
            pPDData->wzcIntfEntry.nAuthMode = ndAm;
    }

    return FnPaPostProcess(dwErr, pPDData, pPDEntry);
}

//----------------------------------------------------
// Parser for the argument of the "priv" parameter
DWORD
FnPaPriv(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg)
{
    DWORD dwErr = ERROR_SUCCESS;
    NDIS_802_11_WEP_STATUS ndEncr;

    dwErr = FnPaUint(&wszParamArg, L'\0', (UINT *)&ndEncr);

    if (dwErr == ERROR_SUCCESS)
    {
        if (ndEncr != Ndis802_11WEPDisabled &&
            ndEncr != Ndis802_11WEPEnabled)
            dwErr = ERROR_INVALID_DATA;
        else
        {
            // change the semantic of nWepStatus according to XP SP (which expects a boolean!)
            pPDData->wzcIntfEntry.nWepStatus = ndEncr == Ndis802_11WEPDisabled ? 0 : 1;
        }
    }

    return FnPaPostProcess(dwErr, pPDData, pPDEntry);
}

//----------------------------------------------------
// Parser for the argument of the "key" parameter
DWORD
FnPaKey(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg)
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT nKIdx, nKLen;
    BOOL bIsHex;
    PNDIS_802_11_WEP pndKey = NULL;

    // get the key index
    dwErr = FnPaUint(&wszParamArg, L':', &nKIdx);

    // check whether the key index is within permitted values
    if (dwErr == ERROR_SUCCESS && (nKIdx < 1 || nKIdx > 4))
        dwErr = ERROR_INVALID_DATA;

    // check the key material length
    if (dwErr == ERROR_SUCCESS)
    {
        wszParamArg++;
        nKLen = wcslen(wszParamArg);

        // trim out the '"' if any
        if (nKLen > 2 && wszParamArg[0] == L'"' && wszParamArg[nKLen-1] == '"')
        {
            wszParamArg++; nKLen-=2;
        }

        switch (nKLen)
        {
        case 10:    // 5 bytes = 40 bits
        case 26:    // 13 bytes = 104 bits
        case 32:    // 16 bytes = 128 bits
            nKLen >>= 1;
            bIsHex = TRUE;
            break;
        case 5:     // 5 bytes = 40 bits
        case 13:    // 13 bytes = 104 bits
        case 16:    // 16 bytes = 128 bits
            bIsHex = FALSE;
            break;
        default:
            dwErr = ERROR_BAD_LENGTH;
            break;
        }
    }

    // allocate space for the key material
    if (dwErr == ERROR_SUCCESS)
    {
        pndKey = MemCAlloc(FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial) + nKLen);
        if (pndKey == NULL)
            dwErr = GetLastError();
        else
        {
            pndKey->Length = FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial) + nKLen;
            pndKey->KeyIndex = nKIdx-1;
            pndKey->KeyLength = nKLen;
        }
    }

    // parse the key material and fill it in the allocated space
    if (dwErr == ERROR_SUCCESS)
    {
        if (bIsHex)
        {
            UINT i;

            for (i = 0; dwErr == ERROR_SUCCESS && i < pndKey->KeyLength; i++)
                dwErr = FnPaByte(&wszParamArg, &(pndKey->KeyMaterial[i]));
        }
        else
        {
            UINT nAnsi;

            nAnsi = WideCharToMultiByte(
                CP_ACP,
                0,
                wszParamArg,
                nKLen,
                pndKey->KeyMaterial,
                pndKey->KeyLength,
                NULL,
                NULL);
            if (nAnsi != pndKey->KeyLength)
                dwErr = ERROR_BAD_FORMAT;
            else
                wszParamArg += pndKey->KeyLength;
        }
    }

    // if the key material proved to be correct, then pass the data in the pPDData
    if (dwErr == ERROR_SUCCESS)
    {
        _Asrt(*wszParamArg == L'\0' ||
              *wszParamArg == L'"',
              L"Code bug - key length incorrectly inferred.\n");
        pPDData->wzcIntfEntry.rdCtrlData.dwDataLen = pndKey->Length;
        pPDData->wzcIntfEntry.rdCtrlData.pData = (LPBYTE)pndKey;
    }
    else
    {
        MemFree(pndKey);
    }

    return FnPaPostProcess(dwErr, pPDData, pPDEntry);;
}

//----------------------------------------------------
// Parser for the boolean argument for the "onex" parameter
DWORD
FnPaOneX(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  bOneX;

    dwErr = FnPaUint(&wszParamArg, L'\0', (UINT *)&bOneX);

    if (dwErr == ERROR_SUCCESS)
    {
        if (bOneX != TRUE && bOneX != FALSE)
            dwErr = ERROR_INVALID_DATA;
        else
        {
            // save the parameter's argument
            pPDData->bOneX = bOneX;
        }
    }

    return FnPaPostProcess(dwErr, pPDData, pPDEntry);
}

//----------------------------------------------------
// Parser for the "outfile" file name parameter
FnPaOutFile(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg)
{
    FILE *pfOut;
    DWORD dwErr = ERROR_SUCCESS;

    pfOut = _wfopen(wszParamArg, L"a+");
    if (pfOut == NULL)
        dwErr = GetLastError();

    if (dwErr == ERROR_SUCCESS)
    {
        CHAR szCrtDate[32];
        CHAR szCrtTime[32];

        pPDData->pfOut = pfOut;
        fprintf(pPDData->pfOut,"\n\n[%s - %s]\n", 
            _strdate(szCrtDate), _strtime(szCrtTime));
    }

    return FnPaPostProcess(dwErr, pPDData, pPDEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\server\resources\zcdblog.h ===
/*
Copyright (c) 2000, Microsoft Corporation

Module Name:

    zcdblog.h

Abstract:

    This module contains text messages used to generate event-log entries
    by ZeroConf service.

Revision History:

    huis, July 30 2001, Created

--*/
#define ZCDB_LOG_BASE						3000

#define WZCSVC_SERVICE_STARTED              (ZCDB_LOG_BASE+1)
/*
 * Wireless Configuration service was started successfully
 */
#define WZCSVC_SERVICE_FAILED               (ZCDB_LOG_BASE+2)
/*
 * Wireless Configuration service failed to start.
 */
#define WZCSVC_SM_STATE_INIT                (ZCDB_LOG_BASE+3)
/*
 * Adding interface %1.
 */
#define WZCSVC_SM_STATE_HARDRESET           (ZCDB_LOG_BASE+4)
/*
 * Hard resetting interface.
 */
#define WZCSVC_SM_STATE_SOFTRESET           (ZCDB_LOG_BASE+5)
/*
 * Initiating scanning for wireless networks.
 */
#define WZCSVC_SM_STATE_DELAY_SR            (ZCDB_LOG_BASE+6)
/*
 * Driver failed scanning, rescheduling another scan in 5sec.
 */
#define WZCSVC_SM_STATE_QUERY               (ZCDB_LOG_BASE+7)
/*
 * Scan completed.
 */
#define WZCSVC_SM_STATE_QUERY_NOCHANGE      (ZCDB_LOG_BASE+8)
/*
 * No configuration change. Still associated to %1.
 */
#define WZCSVC_SM_STATE_ITERATE             (ZCDB_LOG_BASE+9)
/*
 * Plumbing configuration SSID: %1, Network Type: %2!d!.
 */
#define WZCSVC_SM_STATE_ITERATE_NONET       (ZCDB_LOG_BASE+10)
/*
 * No configurations left in the selection list.
 */
#define WZCSVC_SM_STATE_FAILED              (ZCDB_LOG_BASE+11)
/*
 * Failed to associated to any wireless network.
 */
#define WZCSVC_SM_STATE_CFGREMOVE           (ZCDB_LOG_BASE+12)
/*
 * Deleting configuration %1 and moving on.
 */
#define WZCSVC_SM_STATE_CFGPRESERVE         (ZCDB_LOG_BASE+13)
/*
 * Skipping configuration %1 for now, attempt authentication later.
 */
#define WZCSVC_SM_STATE_NOTIFY              (ZCDB_LOG_BASE+14)
/*
 * Wireless interface successfully associated to %1 [MAC %2].
 */
#define WZCSVC_SM_STATE_CFGHDKEY            (ZCDB_LOG_BASE+15)
/*
 * Configuration %1 has a default random WEP key. Authentication is disabled. Assuming invalid configuration.
 */
#define WZCSVC_EVENT_ADD                    (ZCDB_LOG_BASE+16)
/*
 * Received Device Arrival notification for %1.
 */
#define WZCSVC_EVENT_REMOVE                 (ZCDB_LOG_BASE+17)
/*
 * Received Device Removal notification for %1.
 */
#define WZCSVC_EVENT_CONNECT                (ZCDB_LOG_BASE+18)
/*
 * Received Media Connect notification.
 */
#define WZCSVC_EVENT_DISCONNECT             (ZCDB_LOG_BASE+19)
/*
 * Received Media Disconnect notification.
 */
#define WZCSVC_EVENT_TIMEOUT                (ZCDB_LOG_BASE+20)
/*
 * Received Timeout notification.
 */
#define WZCSVC_EVENT_CMDREFRESH             (ZCDB_LOG_BASE+21)
/*
 * Processing user command Refresh.
 */
#define WZCSVC_EVENT_CMDRESET               (ZCDB_LOG_BASE+22)
/*
 * Processing user command Reset.
 */
#define WZCSVC_EVENT_CMDCFGNEXT             (ZCDB_LOG_BASE+23)
/*
 * Processing command Next Configuration.
 */
#define WZCSVC_EVENT_CMDCFGDELETE           (ZCDB_LOG_BASE+24)
/*
 * Processing command Remove Configuration.
 */
#define WZCSVC_EVENT_CMDCFGNOOP             (ZCDB_LOG_BASE+25)
/*
 * Processing command Update data.
 */
#define WZCSVC_SM_STATE_CFGSKIP             (ZCDB_LOG_BASE+26)
/*
 * Deleting configuration %1 and moving on. If no better match is found, the configuration will be revived.
 */
#define WZCSVC_USR_CFGCHANGE                (ZCDB_LOG_BASE+27)
/*
 * Wireless configuration has been changed via an administrative call.
 */
#define WZCSVC_DETAILS_FLAGS                (ZCDB_LOG_BASE+28)
/*
 * [Enabled=%1; Fallback=%2; Mode=%3; Volatile=%4; Policy=%5%]%n
 */
#define WZCSVC_DETAILS_WCONFIG              (ZCDB_LOG_BASE+29)
/*
 * {Ssid=%1; Infrastructure=%2; Privacy=%3; [Volatile=%4%; Policy=%5%]}.%n
 */
#define WZCSVC_ERR_QUERRY_BSSID             (ZCDB_LOG_BASE+30)
/*
 * Failed to get the MAC address of the remote endpoint. Error code is %1!d!.
 */
#define WZCSVC_ERR_GEN_SESSION_KEYS         (ZCDB_LOG_BASE+31)
/*
 * Failed to generate the initial session keys. Error code is %1!d!.
 */
#define WZCSVC_BLIST_CHANGED                (ZCDB_LOG_BASE+32)
/*
 * The list of blocked networks has changed. It contains now %1!d! network(s).
 */
#define WZCSVC_ERR_CFG_PLUMB                (ZCDB_LOG_BASE+33)
/*
 * Failed to plumb the configuration %1. Error code is %2!d!.
 */

#define EAPOL_STATE_TRANSITION              (ZCDB_LOG_BASE+34)
/*
 * EAPOL State Transition: [%1!ws!] to [%2!ws!] 
 */

#define EAPOL_STATE_TIMEOUT                 (ZCDB_LOG_BASE+35)
/*
 * EAPOL State Timeout: [%1!ws!]
 */

#define EAPOL_MEDIA_CONNECT                 (ZCDB_LOG_BASE+36)
/*
 * Processing media connect event for [%1!ws!]
 */

#define EAPOL_MEDIA_DISCONNECT              (ZCDB_LOG_BASE+37)
/*
 * Processing media disconnect event for [%1!ws!]
 */

#define EAPOL_INTERFACE_ADDITION            (ZCDB_LOG_BASE+38)
/*
 * Processing interface addition event for [%1!ws!]
 */

#define EAPOL_INTERFACE_REMOVAL             (ZCDB_LOG_BASE+39)
/*
 * Processing interface removal event for [%1!ws!]
 */

#define EAPOL_NDISUIO_BIND                  (ZCDB_LOG_BASE+40)
/*
 * Processing adapter bind event for [%1!ws!]
 */

#define EAPOL_NDISUIO_UNBIND                (ZCDB_LOG_BASE+41)
/*
 * Processing adapter unbind event for [%1!ws!]
 */

#define EAPOL_USER_LOGON                    (ZCDB_LOG_BASE+42)
/*
 * Processing user logon event for interface [%1!ws!]
 */

#define EAPOL_USER_LOGOFF                   (ZCDB_LOG_BASE+43)
/*
 * Processing user logoff event for interface [%1!ws!]
 */

#define EAPOL_PARAMS_CHANGE                 (ZCDB_LOG_BASE+44)
/*
 * Processing 802.1X configuration parameters change event for [%1!ws!]
 */

#define EAPOL_USER_NO_CERTIFICATE           (ZCDB_LOG_BASE+45)
/*
 * Unable to find a valid certificate for 802.1X authentication
 */

#define EAPOL_ERROR_GET_IDENTITY            (ZCDB_LOG_BASE+46)
/*
 * Error in fetching %1!ws! identity 0x%2!0x!
 */

#define EAPOL_ERROR_AUTH_PROCESSING         (ZCDB_LOG_BASE+47)
/*
 * Error in authentication protocol processing 0x%1!0x!
 */

#define EAPOL_PROCESS_PACKET_EAPOL          (ZCDB_LOG_BASE+48)
/*
 * Packet %1!ws!: Dest:[%2!ws!] Src:[%3!ws!] EAPOL-Pkt-type:[%4!ws!] 
 */

#define EAPOL_PROCESS_PACKET_EAPOL_EAP      (ZCDB_LOG_BASE+49)
/*
 * Packet %1!ws!:%n Dest:[%2!ws!]%n Src:[%3!ws!]%n EAPOL-Pkt-type:[%4!ws!]%n Data-length:[%5!ld!]%n EAP-Pkt-type:[%6!ws!]%n EAP-Id:[%7!ld!]%n EAP-Data-Length:[%8!ld!]%n %9!ws!%n
 */

#define EAPOL_DESKTOP_REQUIRED_IDENTITY     (ZCDB_LOG_BASE+50)
/*
 * Interactive desktop required for user credentials selection
 */

#define EAPOL_DESKTOP_REQUIRED_LOGON        (ZCDB_LOG_BASE+51)
/*
 * Interactive desktop required to process logon information
 */

#define EAPOL_CANNOT_DESKTOP_MACHINE_AUTH   (ZCDB_LOG_BASE+52)
/*
 * Cannot interact with desktop during machine authentication
 */

#define EAPOL_WAITING_FOR_DESKTOP_LOAD      (ZCDB_LOG_BASE+53)
/*
 * Waiting for user interactive desktop to be loaded
 */

#define EAPOL_WAITING_FOR_DESKTOP_IDENTITY  (ZCDB_LOG_BASE+54)
/*
 * Waiting for 802.1X user module to fetch user credentials
 */

#define EAPOL_WAITING_FOR_DESKTOP_LOGON     (ZCDB_LOG_BASE+55)
/*
 * Waiting for 802.1X user module to process logon information
 */

#define EAPOL_ERROR_DESKTOP_IDENTITY        (ZCDB_LOG_BASE+56)
/*
 * Error in 802.1X user module while fetching user credentials 0x%1!0x!
 */

#define EAPOL_ERROR_DESKTOP_LOGON           (ZCDB_LOG_BASE+57)
/*
 * Error in 802.1X user module while process logon information 0x%1!0x!
 */

#define EAPOL_PROCESSING_DESKTOP_RESPONSE   (ZCDB_LOG_BASE+58)
/*
 * Processing response received from 802.1X user module
 */

#define EAPOL_STATE_DETAILS                 (ZCDB_LOG_BASE+59)
/*
 * EAP-Identity:[%1!S!]%n State:[%2!ws!]%n Authentication type:[%3!ws!]%n Authentication mode:[%4!ld!]%n EAP-Type:[%5!ld!]%n Fail count:[%6!ld!]%n 
 */

#define EAPOL_INVALID_EAPOL_KEY     (ZCDB_LOG_BASE+60)
/*
 * Invalid EAPOL-Key message
 */

#define EAPOL_ERROR_PROCESSING_EAPOL_KEY     (ZCDB_LOG_BASE+61)
/*
 * Error processing EAPOL-Key message %1!ld!
 */

#define EAPOL_INVALID_EAP_TYPE              (ZCDB_LOG_BASE+62)
/*
 * Invalid EAP-type=%1!ld! packet received. Expected EAP-type=%2!ld!
 */

#define EAPOL_NO_CERTIFICATE_USER           (ZCDB_LOG_BASE+63)
/*
 * Unable to find a valid user certificate for 802.1X authentication
 */

#define EAPOL_NO_CERTIFICATE_MACHINE           (ZCDB_LOG_BASE+64)
/*
 * Unable to find a valid machine certificate for 802.1X authentication
 */

#define EAPOL_EAP_AUTHENTICATION_SUCCEEDED      (ZCDB_LOG_BASE+65)
/*
 * 802.1X client authentication completed successfully with server 
 */

#define EAPOL_EAP_AUTHENTICATION_DEFAULT           (ZCDB_LOG_BASE+66)
/*
 * No 802.1X authentication performed since there was no response from server for 802.1X packets. Entering AUTHENTICATED state. 
 */

#define EAPOL_EAP_AUTHENTICATION_FAILED      (ZCDB_LOG_BASE+67)
/*
 * 802.1X client authentication failed. The error code is 0x%1!0x!
 */

#define EAPOL_EAP_AUTHENTICATION_FAILED_DEFAULT      (ZCDB_LOG_BASE+68)
/*
 * 802.1X client authentication failed. Network connectivity issues with authentication server were experienced.
 */

#define EAPOL_CERTIFICATE_DETAILS               (ZCDB_LOG_BASE+69)
/*
 * A %1!ws! certificate was used for 802.1X authentication%n
 *
 * Version: %2!ws!%n
 * Serial Number: %3!ws!%n
 * Issuer: %4!ws!%n
 * Friendly Name: %5!ws!%n
 * UPN: %6!ws!%n
 * Enhanced Key Usage: %7!ws!%n
 * Valid From: %8!ws!%n
 * Valid To: %9!ws!%n
 * Thumbprint: %10!ws!
 */

#define EAPOL_POLICY_CHANGE_NOTIFICATION        (ZCDB_LOG_BASE+70)
/*
 * Received policy change notification from Policy Engine 
 */

#define EAPOL_POLICY_UPDATED                    (ZCDB_LOG_BASE+71)
/*
 * Updated local policy settings with changed settings provided by Policy Engine
 */

#define EAPOL_NOT_ENABLED_PACKET_REJECTED       (ZCDB_LOG_BASE+72)
/*
 * 802.1X is not enabled for the current network setting. Packet received has been rejected.
 */

#define EAPOL_EAP_AUTHENTICATION_FAILED_ACQUIRED      (ZCDB_LOG_BASE+73)
/*
 * 802.1X client authentication failed. Possible errors are:
 * 1. Invalid username was entered
 * 2. Invalid certificate was chosen
 * 3. User account does not have privileges to authenticate
 *
 * Contact system administrator for more details
 */

#define EAPOL_NOT_CONFIGURED_KEYS               (ZCDB_LOG_BASE+74)
/*
 * No keys have been configured for the Wireless connection. Re-keying functionality will not work.
 */

#define EAPOL_NOT_RECEIVED_XMIT_KEY                  (ZCDB_LOG_BASE+75)
/*
 * No transmit WEP key was received for the Wireless connection after 802.1x authentication. The current setting has been marked as failed and the Wireless connection will be disconnected.
 */

#define ZCDB_LOG_BASE_END                   (ZCDB_LOG_BASE+999)
/* end.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\errctrl.h ===
#pragma once

#ifdef DBG
// Parameters:
//      (BOOL bCond, LPCTSTR cszFmt, ...)
// Semantics:
//      Condition bCond is expected to be TRUE. If this
//      doesn't happen, message is displayed and program
//      is exited.
// Usage:
//     _Assert((
//          errCode == ERROR_SUCCESS,
//          "Err code %d returned from call.\n",
//          GetLastError()
//     ));
// Output:
//
#define _Assert(params)     _Asrt params;
#else
// No code is generated for asserts in fre builds
#define _Assert
#endif

VOID _Asrt(BOOL bCond,
        LPCTSTR cszFmt,
        ...);
		
DWORD _Err(DWORD dwErrCode,
        LPCTSTR cszFmt,
        ...);

DWORD _Wrn(DWORD dwWarnCode,
        LPCTSTR cszFmt,
        ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\errctrl.c ===
#include <precomp.h>

// Positive Assert: it checks for the condition bCond
// and exits the program if it is not TRUE
VOID _Asrt(BOOL bCond,
        LPCTSTR cstrMsg,
        ...)
{
    if (!bCond)
    {
        DWORD dwErr = GetLastError();
        va_list arglist;
        va_start(arglist, cstrMsg);
		_vftprintf(stderr, cstrMsg, arglist);
        if (dwErr == ERROR_SUCCESS)
            dwErr = ERROR_GEN_FAILURE;
		exit(dwErr);
    }
}


DWORD _Err(DWORD dwErrCode,
        LPCTSTR cstrMsg,
        ...)
{
    va_list arglist;

    va_start(arglist, cstrMsg);
    _ftprintf(stderr, _T("[Err%u] "), dwErrCode);
    _vftprintf(stderr, cstrMsg, arglist);
    fflush(stdout);

    SetLastError(dwErrCode);
    return dwErrCode;
}

DWORD _Wrn(DWORD dwWarnCode,
        LPCTSTR cstrMsg,
        ...)
{
    va_list arglist;

    va_start(arglist, cstrMsg);
    _ftprintf(stderr, _T("[Wrn%u] "), dwWarnCode);
    _vftprintf(stderr, cstrMsg, arglist);
    fflush(stdout);

    return dwWarnCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\cmdfn.c ===
#include <precomp.h>
#include "ErrCtrl.h"
#include "Utils.h"
#include "PrmDescr.h"
#include "CmdFn.h"
#include "Output.h"

//----------------------------------------------------
// Sub command multiplier. If the GUID argument is "*", it
// will apply the command from within pPDData for each of
// the existent NICs. Otherwise, this is a pass through to
// the respective sub command;
DWORD
FnSubCmdMultiplier(PPARAM_DESCR_DATA pPDData)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (wcscmp(pPDData->wzcIntfEntry.wszGuid, L"*") == 0)
    {
        UINT i;
        INTFS_KEY_TABLE wzcIntfKeyTable = {0, NULL};

        dwErr = WZCEnumInterfaces(NULL, &wzcIntfKeyTable);

        if (dwErr == ERROR_SUCCESS)
        {
            for (i = 0; i < wzcIntfKeyTable.dwNumIntfs; i++)
            {
                MemFree(pPDData->wzcIntfEntry.wszGuid);
                pPDData->wzcIntfEntry.wszGuid = wzcIntfKeyTable.pIntfs[i].wszGuid;

                OutIntfsHeader(pPDData);
                dwErr = pPDData->pfnCommand(pPDData);
                OutIntfsTrailer(pPDData, dwErr);
            }

            RpcFree(wzcIntfKeyTable.pIntfs);
        }
    }
    else
    {
        dwErr = pPDData->pfnCommand(pPDData);
    }

    SetLastError(dwErr);
    return dwErr;
}

//----------------------------------------------------
// Sub command handler for the "show" the list of wireless NICs command
DWORD
FnSubCmdShowIntfs(PPARAM_DESCR_DATA pPDData)
{
    DWORD dwErr = ERROR_SUCCESS;
    INTFS_KEY_TABLE wzcIntfKeyTable = {0, NULL};

    dwErr = WZCEnumInterfaces(NULL, &wzcIntfKeyTable);

    if (dwErr == ERROR_SUCCESS)
    {
        UINT i;

        dwErr = OutNetworkIntfs(pPDData, &wzcIntfKeyTable);

        for (i = 0; i < wzcIntfKeyTable.dwNumIntfs; i++)
            RpcFree(wzcIntfKeyTable.pIntfs[i].wszGuid);

        RpcFree(wzcIntfKeyTable.pIntfs);
    }

    SetLastError(dwErr);
    return dwErr;
}

//----------------------------------------------------
// Sub command handler for the "show=Guid visible|preferred" command
DWORD
FnSubCmdShowNetworks(PPARAM_DESCR_DATA pPDData)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwInFlags;

    dwInFlags = (pPDData->dwExistingParams & PRM_VISIBLE) ? INTF_BSSIDLIST : INTF_PREFLIST;
    dwErr = WZCQueryInterface(
                NULL,
                _Os(dwInFlags),
                &pPDData->wzcIntfEntry,
                NULL);

    if (dwErr == ERROR_SUCCESS)
    {
        UINT nRetrieved = 0, nFiltered = 0;
        PWZC_802_11_CONFIG_LIST pwzcCfgList;
        
        if (pPDData->dwExistingParams & PRM_VISIBLE)
            pwzcCfgList = (PWZC_802_11_CONFIG_LIST)pPDData->wzcIntfEntry.rdBSSIDList.pData;
        else
            pwzcCfgList = (PWZC_802_11_CONFIG_LIST)pPDData->wzcIntfEntry.rdStSSIDList.pData;

        if (pwzcCfgList != NULL)
        {
            nRetrieved = pwzcCfgList->NumberOfItems;
            dwErr = WzcFilterList(
                        TRUE,       // retain the matching configurations
                        pPDData,
                        pwzcCfgList);
            if (dwErr == ERROR_SUCCESS)
                nFiltered = pwzcCfgList->NumberOfItems;
        }

        if (dwErr == ERROR_SUCCESS)
            dwErr = OutNetworkCfgList(pPDData, nRetrieved, nFiltered);

        // cleanup data
        if (dwErr == ERROR_SUCCESS)
        {
            RpcFree(pPDData->wzcIntfEntry.rdBSSIDList.pData);
            pPDData->wzcIntfEntry.rdBSSIDList.dwDataLen = 0;
            pPDData->wzcIntfEntry.rdBSSIDList.pData = NULL;

            RpcFree(pPDData->wzcIntfEntry.rdStSSIDList.pData);
            pPDData->wzcIntfEntry.rdStSSIDList.dwDataLen = 0;
            pPDData->wzcIntfEntry.rdStSSIDList.pData = NULL;
        }
    }

    SetLastError(dwErr);
    return dwErr;
}

//----------------------------------------------------
// Sub command handler for the "show=Guid" service settings command
DWORD
FnSubCmdShowSvcParams(PPARAM_DESCR_DATA pPDData)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwInFlags = 0;
    DWORD dwOutFlags = 0;

    // if there is anything specific requested from us
    if ((pPDData->dwExistingParams & ~(PRM_SHOW|PRM_FILE)) != 0)
    {
        if (pPDData->dwExistingParams & PRM_MASK)
            dwInFlags |= INTF_CM_MASK;
        if (pPDData->dwExistingParams & PRM_ENABLED)
            dwInFlags |= INTF_ENABLED;
        if (pPDData->dwExistingParams & PRM_SSID)
            dwInFlags |= INTF_SSID;
        if (pPDData->dwExistingParams & PRM_IM)
            dwInFlags |= INTF_INFRAMODE;
        if (pPDData->dwExistingParams & PRM_AM)
            dwInFlags |= INTF_AUTHMODE;
        if (pPDData->dwExistingParams & PRM_PRIV)
            dwInFlags |= INTF_WEPSTATUS;
        if (pPDData->dwExistingParams & PRM_BSSID)
            dwInFlags |= INTF_BSSID;
    }
    else
    {
        dwInFlags |= INTF_CM_MASK|INTF_ENABLED|INTF_SSID|INTF_INFRAMODE|INTF_AUTHMODE|INTF_WEPSTATUS|INTF_BSSID;
    }
    dwErr = WZCQueryInterface(
                NULL,
                _Os(dwInFlags),
                &pPDData->wzcIntfEntry,
                &dwOutFlags);

    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = OutSvcParams(pPDData, _Os(dwInFlags), dwOutFlags);
    }

    SetLastError(dwErr);
    return dwErr;
}

//----------------------------------------------------
// Sub command handler for the "add=Guid .." preferred network command
DWORD
FnSubCmdAddPreferred(PPARAM_DESCR_DATA pPDData)
{
    DWORD   dwErr = ERROR_SUCCESS;
    DWORD   dwInFlags;
    UINT    iNew = 0;   // index where to place the new network
    PWZC_802_11_CONFIG_LIST pwzcCfgList;
    UINT nNewCount=1;   // gives the new number of preferred networks (if 0=>don't alloc)

    dwInFlags = INTF_PREFLIST;
    dwErr = WZCQueryInterface(
                NULL,
                _Os(dwInFlags),
                &pPDData->wzcIntfEntry,
                NULL);
    // if anything went wrong, print out a warning and return with error
    if (dwErr != ERROR_SUCCESS)
    {
        _Wrn(dwErr, L"Failed to retrieve the list of preferred networks.\n");
    }

    if (dwErr == ERROR_SUCCESS)
    {
        // if we got a non-null list of preferred networks back, look into it
        if (pPDData->wzcIntfEntry.rdStSSIDList.pData != NULL)
        {
            UINT iAdhocHead;
            DWORD dwOrigArgPrmFlags;

            pwzcCfgList = (PWZC_802_11_CONFIG_LIST)pPDData->wzcIntfEntry.rdStSSIDList.pData;
            iAdhocHead = pwzcCfgList->NumberOfItems;

            // trick the flags for WzcConfigHit!
            dwOrigArgPrmFlags = pPDData->dwArgumentedParams;
            pPDData->dwArgumentedParams = PRM_SSID | PRM_IM;
            for (iNew = 0; iNew < pwzcCfgList->NumberOfItems; iNew++)
            {
                PWZC_WLAN_CONFIG pwzcConfig = &pwzcCfgList->Config[iNew];

                // determine the index of the first adhoc network
                if (iAdhocHead > iNew && pwzcConfig->InfrastructureMode == Ndis802_11IBSS)
                    iAdhocHead = iNew;

                // look for the indicated network
                if (WzcConfigHit(pPDData, pwzcConfig))
                    break;
            }
            // restore the flags
            pPDData->dwArgumentedParams = dwOrigArgPrmFlags;

            // if we didn't go through the whole list, we found a hit.
            if (iNew < pwzcCfgList->NumberOfItems)
                nNewCount = 0;
            else 
            {
                nNewCount = pwzcCfgList->NumberOfItems + 1;

                if (pPDData->wzcIntfEntry.nInfraMode == Ndis802_11IBSS)
                    iNew = iAdhocHead; // if adding an adhoc, insert it as the first adhoc
                else
                    iNew = 0; // if adding an infrastructure, insert it as the very first one
            }
        }

        // if we need to enlarge the list => allocate a new one
        if (nNewCount != 0)
        {
            pwzcCfgList = MemCAlloc(
                            FIELD_OFFSET(WZC_802_11_CONFIG_LIST, Config) + 
                            nNewCount * sizeof(WZC_WLAN_CONFIG));
            if (pwzcCfgList == NULL)
                dwErr = GetLastError();
            else
            {
                PWZC_WLAN_CONFIG pwzcNewCfg = &pwzcCfgList->Config[iNew];

                pwzcCfgList->NumberOfItems = nNewCount;
                pwzcCfgList->Index = nNewCount;
                // initialize the new entry with default values
                pwzcNewCfg->Length = sizeof(WZC_WLAN_CONFIG);
                pwzcNewCfg->InfrastructureMode = Ndis802_11Infrastructure;
                pwzcNewCfg->AuthenticationMode = Ndis802_11AuthModeOpen;
                // for XPSP, this is a boolean
                pwzcNewCfg->Privacy = 1;
            }
        }
    }

    // at this point, if everything is good, we should have the new list
    // in pwzcCfgList with the new entry initialized already. Should this be
    // newly allocated memory, then original entries need to be copied over
    if (dwErr == ERROR_SUCCESS)
    {
        PWZC_802_11_CONFIG_LIST pwzcOrigCfgList;
        PWZC_WLAN_CONFIG pwzcNewCfg = &pwzcCfgList->Config[iNew];

        pwzcOrigCfgList = (PWZC_802_11_CONFIG_LIST)pPDData->wzcIntfEntry.rdStSSIDList.pData;
        if (pwzcOrigCfgList != pwzcCfgList)
        {
            if (pwzcOrigCfgList != NULL)
            {
                if (iNew > 0)
                {
                    memcpy(
                        &pwzcCfgList->Config[0], 
                        &pwzcOrigCfgList->Config[0],
                        iNew * sizeof(WZC_WLAN_CONFIG));
                }

                if (iNew < pwzcOrigCfgList->NumberOfItems)
                {
                    memcpy(
                        &pwzcCfgList->Config[iNew+1],
                        &pwzcOrigCfgList->Config[iNew],
                        (pwzcOrigCfgList->NumberOfItems - iNew)*sizeof(WZC_WLAN_CONFIG));
                }

                // cleanup the original list
                MemFree(pwzcOrigCfgList);
            }

            // place the new one in the INTF_ENTRY
            pPDData->wzcIntfEntry.rdStSSIDList.dwDataLen = 
                FIELD_OFFSET(WZC_802_11_CONFIG_LIST, Config) + 
                pwzcCfgList->NumberOfItems * sizeof(WZC_WLAN_CONFIG);
            pPDData->wzcIntfEntry.rdStSSIDList.pData = (LPBYTE)pwzcCfgList;
        }

        // if "one time connect" is also required, set it up here
        if (pPDData->dwExistingParams & PRM_ONETIME)
            pwzcCfgList->Index = iNew;

        // the only thing required is to overwrite now the user settings
        // copy first the mandatory infrastructure mode
        pwzcNewCfg->InfrastructureMode = pPDData->wzcIntfEntry.nInfraMode;
        // copy then the mandatory ssid
        pwzcNewCfg->Ssid.SsidLength = pPDData->wzcIntfEntry.rdSSID.dwDataLen;
        memcpy(&pwzcNewCfg->Ssid.Ssid,
               pPDData->wzcIntfEntry.rdSSID.pData,
               pwzcNewCfg->Ssid.SsidLength);
        if (pPDData->dwArgumentedParams & PRM_IM)
            pwzcNewCfg->InfrastructureMode = pPDData->wzcIntfEntry.nInfraMode;
        if (pPDData->dwArgumentedParams & PRM_AM)
            pwzcNewCfg->AuthenticationMode = pPDData->wzcIntfEntry.nAuthMode;
        if (pPDData->dwArgumentedParams & PRM_PRIV)
            pwzcNewCfg->Privacy = pPDData->wzcIntfEntry.nWepStatus;
        if (pPDData->dwArgumentedParams & PRM_KEY)
        {
            PNDIS_802_11_WEP pndKey = (PNDIS_802_11_WEP)pPDData->wzcIntfEntry.rdCtrlData.pData;
            pwzcNewCfg->KeyIndex = pndKey->KeyIndex;
            pwzcNewCfg->KeyLength = pndKey->KeyLength;
            memcpy(pwzcNewCfg->KeyMaterial, pndKey->KeyMaterial, pwzcNewCfg->KeyLength);
            pwzcNewCfg->dwCtlFlags |= WZCCTL_WEPK_PRESENT;
            // on XP RTM we have to scramble the WEP key at this point!
            if (IsXPRTM())
            {
                BYTE chFakeKeyMaterial[] = {0x56, 0x09, 0x08, 0x98, 0x4D, 0x08, 0x11, 0x66, 0x42, 0x03, 0x01, 0x67, 0x66};
                UINT i;
                for (i = 0; i < WZCCTL_MAX_WEPK_MATERIAL; i++)
                    pwzcNewCfg->KeyMaterial[i] ^= chFakeKeyMaterial[(7*i)%13];
            }
        }
        else
        {
            pwzcNewCfg->dwCtlFlags &= ~WZCCTL_WEPK_PRESENT;
        }

        // if OneX is explictly required, set it here (it has been checked for consistency already)
        if (pPDData->dwArgumentedParams & PRM_ONEX)
            dwErr = WzcSetOneX(pPDData, pPDData->bOneX);
        // if OneX is not explicitly specified and this is a brand new network..
        else if (nNewCount != 0) 
            // disable OneX by default
            dwErr = WzcSetOneX(pPDData, FALSE);
        // in the case some existing preferred network is being modified and the change doesn't involve
        // the "onex" param, then the OneX state is left untouched.

        if (dwErr == ERROR_SUCCESS)
        {
            // all is set, now push this to the service
            dwErr = WZCSetInterface(
                        NULL,
                        _Os(dwInFlags),
                        &pPDData->wzcIntfEntry,
                        NULL);
        }
    }

    if (dwErr == ERROR_SUCCESS)
    {
        fprintf(pPDData->pfOut, "Done.\n");
    }

    // cleanup data
    if (dwErr == ERROR_SUCCESS)
    {
        RpcFree(pPDData->wzcIntfEntry.rdStSSIDList.pData);
        pPDData->wzcIntfEntry.rdStSSIDList.dwDataLen = 0;
        pPDData->wzcIntfEntry.rdStSSIDList.pData = NULL;
    }

    SetLastError(dwErr);
    return dwErr;
}

//----------------------------------------------------
// Sub command handler for the "delete=Guid .." preferred network command
DWORD
FnSubCmdDeletePreferred(PPARAM_DESCR_DATA pPDData)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwInFlags;

    dwInFlags = INTF_PREFLIST;
    dwErr = WZCQueryInterface(
                NULL,
                _Os(dwInFlags),
                &pPDData->wzcIntfEntry,
                NULL);

    if (dwErr != ERROR_SUCCESS)
    {
        _Wrn(dwErr, L"Failed to retreive the list of preferred networks.\n");
    }
    else
    {
        PWZC_802_11_CONFIG_LIST pwzcCfgList = (PWZC_802_11_CONFIG_LIST)pPDData->wzcIntfEntry.rdStSSIDList.pData;

        if (pwzcCfgList == NULL)
            fprintf(pPDData->pfOut, "Done: deleted 0 - remaining 0\n");
        else
        {
            UINT nNets = pwzcCfgList->NumberOfItems;

            dwErr = WzcFilterList(
                        FALSE,       // retain the non-matching configurations
                        pPDData,
                        pwzcCfgList);

            if (dwErr == ERROR_SUCCESS)
            {
                // make final adjustments to the list
                pPDData->wzcIntfEntry.rdStSSIDList.dwDataLen = 
                    FIELD_OFFSET(WZC_802_11_CONFIG_LIST, Config) +
                    pwzcCfgList->NumberOfItems * sizeof(WZC_WLAN_CONFIG);
                pwzcCfgList->Index = pwzcCfgList->NumberOfItems;
                dwErr = WZCSetInterface(
                            NULL,
                            _Os(dwInFlags),
                            &pPDData->wzcIntfEntry,
                            NULL);
            }

            if (dwErr == ERROR_SUCCESS)
            {
                fprintf(pPDData->pfOut, "Done: deleted %d - remaining %d\n", 
                    nNets - pwzcCfgList->NumberOfItems, 
                    pwzcCfgList->NumberOfItems);
            }
        }
    }

    // cleanup data
    if (dwErr == ERROR_SUCCESS)
    {
        RpcFree(pPDData->wzcIntfEntry.rdStSSIDList.pData);
        pPDData->wzcIntfEntry.rdStSSIDList.dwDataLen = 0;
        pPDData->wzcIntfEntry.rdStSSIDList.pData = NULL;
    }

    SetLastError(dwErr);
    return dwErr;
}

//----------------------------------------------------
// Sub command handler for the "set=Guid .." service settings command
DWORD
FnSubCmdSetSvcParams(PPARAM_DESCR_DATA pPDData)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwInFlags;

    dwInFlags = 0;
    if (pPDData->dwArgumentedParams & PRM_MASK)
        dwInFlags |= INTF_CM_MASK;
    if (pPDData->dwArgumentedParams & PRM_ENABLED)
        dwInFlags |= INTF_ENABLED;

    if (dwInFlags != 0)
    {
        // for RTM, all the control flags are set in one shot. So we need to
        // make sure we don't alter anything else but what we're asked for.
        if (IsXPRTM())
        {
            DWORD dwNewFlags;

            dwNewFlags = pPDData->wzcIntfEntry.dwCtlFlags;
            dwErr = WZCQueryInterface(
                        NULL,
                        _Os(INTF_CM_MASK),
                        &pPDData->wzcIntfEntry,
                        NULL);
            SetLastError(dwErr);
            _Asrt(dwErr == ERROR_SUCCESS, L"Backing up current control flags failed with error %d.\n", dwErr);

            if (dwInFlags & INTF_CM_MASK)
            {
                pPDData->wzcIntfEntry.dwCtlFlags &= ~INTFCTL_CM_MASK;
                pPDData->wzcIntfEntry.dwCtlFlags |= (dwNewFlags & INTFCTL_CM_MASK);
            }
            if (dwInFlags & INTF_ENABLED)
            {
                pPDData->wzcIntfEntry.dwCtlFlags &= ~INTFCTL_ENABLED;
                pPDData->wzcIntfEntry.dwCtlFlags |= (dwNewFlags & INTFCTL_ENABLED);
            }
        }

        dwErr = WZCSetInterface(
                    NULL,
                    _Os(dwInFlags),
                    &pPDData->wzcIntfEntry,
                    NULL);
        if (dwErr != ERROR_SUCCESS)
            _Wrn(dwErr, L"Failed to set all parameters - %08x <> %08x\n");
    }

    if (pPDData->dwExistingParams & PRM_REFRESH)
    {
        DWORD dwLErr;

        dwInFlags = INTF_LIST_SCAN;
        dwLErr = WZCRefreshInterface(
                    NULL,
                    _Os(dwInFlags),
                    &pPDData->wzcIntfEntry,
                    NULL);
        if (dwLErr != ERROR_SUCCESS)
            _Wrn(dwLErr,L"Failed to initiate wireless scan.\n");

        if (dwErr == ERROR_SUCCESS)
            dwErr = dwLErr;
    }

    if (dwErr == ERROR_SUCCESS)
        fprintf(pPDData->pfOut, "Done.\n");

    SetLastError(dwErr);
    return dwErr;
}

//=====================================================
//----------------------------------------------------
// Handler for the "show" command
DWORD
FnCmdShow(PPARAM_DESCR_DATA pPDData)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwAllowed, dwArgumented;

    // The command "show" has two different semantics when used with and without
    // argument (Guid).
    // If the command has been provided with argument...
    if (pPDData->dwArgumentedParams & PRM_SHOW)
    {
        //.. we need to retrieve the configuration of some NIC
        //
        // Check whether the request is for global svc parameters or for visible/preferred lists
        if ((pPDData->dwExistingParams & (PRM_VISIBLE|PRM_PREFERRED)) == 0)
        {
            dwArgumented = PRM_SHOW|PRM_FILE;
            dwAllowed = dwArgumented|PRM_MASK|PRM_ENABLED|PRM_SSID|PRM_IM|PRM_AM|PRM_PRIV|PRM_BSSID;

            // Request is for one the global svc parameters
            if ((pPDData->dwExistingParams & ~dwAllowed) != 0)
                dwErr = _Err(ERROR_TOO_MANY_NAMES,L"Inconsistent phrase. Some parameters are not service settings.\n");
            else if ((pPDData->dwArgumentedParams & ~dwArgumented) != 0)
                dwErr = _Err(ERROR_BAD_ARGUMENTS,L"The service settings don't require any value in this context.\n");
            else
            {
                pPDData->pfnCommand = FnSubCmdShowSvcParams;
                dwErr = FnSubCmdMultiplier(pPDData);
            }
        }
        else
        {
            dwArgumented = PRM_SHOW|PRM_SSID|PRM_IM|PRM_AM|PRM_PRIV|PRM_FILE;
            // Request is for one of the visible/preferred lists
            if (pPDData->dwExistingParams & PRM_VISIBLE)
            {
                dwArgumented |= PRM_BSSID;
                dwAllowed = dwArgumented | PRM_VISIBLE;
            }
            else
            {
                dwAllowed = dwArgumented | PRM_PREFERRED;
            }

            if ((pPDData->dwExistingParams & ~dwAllowed) != 0)
                dwErr = _Err(ERROR_TOO_MANY_NAMES,L"Inconsistent phrase. Some of the parameters are not expected for this command.\n");
            else if ((pPDData->dwExistingParams & dwArgumented)  != (pPDData->dwArgumentedParams & dwArgumented))
                dwErr = _Err(ERROR_BAD_ARGUMENTS,L"Value missing for some of the wireless network settings.\n");
            else
            {
                pPDData->pfnCommand = FnSubCmdShowNetworks;
                dwErr = FnSubCmdMultiplier(pPDData);
            }
        }
    }
    else
    {
        //.. we need to list the NICs available under WZC control
        // This command is incompatible with any other parameters
        if ((pPDData->dwExistingParams & ~(PRM_SHOW|PRM_FILE)) != 0)
            dwErr = _Err(ERROR_TOO_MANY_NAMES,L"Too many parameters for the generic \"show\" command.\n");
        else
            dwErr = FnSubCmdShowIntfs(pPDData);
    }

    SetLastError(dwErr);
    return dwErr;
}

//----------------------------------------------------
// Handler for the "add" command
DWORD
FnCmdAdd(PPARAM_DESCR_DATA pPDData)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwRequired = PRM_ADD | PRM_SSID | PRM_IM;
    DWORD dwArgumented = dwRequired | PRM_AM | PRM_PRIV | PRM_KEY | PRM_ONEX | PRM_FILE;
    DWORD dwAllowed = dwArgumented | PRM_ONETIME;

    if ((pPDData->dwExistingParams & dwRequired) != dwRequired)
        dwErr = _Err(ERROR_NO_DATA,L"Wireless network defined incompletely.\n");
    else if ((pPDData->dwExistingParams & dwArgumented) != (pPDData->dwArgumentedParams & dwArgumented))
        dwErr = _Err(ERROR_BAD_ARGUMENTS,L"No value provided for some of the wireless network settings.\n");
    else if ((pPDData->dwExistingParams & ~dwAllowed) != 0)
        dwErr = _Err(ERROR_TOO_MANY_NAMES,L"Inconsistent phrase. Some of the parameters are not expected for this command.\n");
    else if ((pPDData->dwArgumentedParams & PRM_ONEX) && (pPDData->bOneX) &&
            ((pPDData->wzcIntfEntry.nInfraMode == Ndis802_11IBSS) ||
             ((pPDData->dwArgumentedParams & PRM_PRIV) && (pPDData->wzcIntfEntry.nWepStatus == 0))))
        dwErr = _Err(ERROR_INVALID_DATA, L"Invalid \"onex\" parameter for the given \"im\" and/or \"priv\".\n");
    else
    {
        pPDData->pfnCommand = FnSubCmdAddPreferred;
        dwErr = FnSubCmdMultiplier(pPDData);
    }

    SetLastError(dwErr);
    return dwErr;
}

//----------------------------------------------------
// Handler for the "delete" command
DWORD
FnCmdDelete(PPARAM_DESCR_DATA pPDData)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwAllowed = PRM_DELETE | PRM_SSID | PRM_IM | PRM_AM | PRM_PRIV | PRM_FILE;

    if ((pPDData->dwExistingParams & ~dwAllowed) != 0)
        dwErr = _Err(ERROR_TOO_MANY_NAMES,L"Inconsistent phrase. Some of the parameters are not expected for this command.\n");
    else if ((pPDData->dwExistingParams & dwAllowed) != (pPDData->dwArgumentedParams & dwAllowed))
        dwErr = _Err(ERROR_BAD_ARGUMENTS,L"Value missing for some of the wireless network settings.\n");
    else
    {
        pPDData->pfnCommand = FnSubCmdDeletePreferred;
        dwErr = FnSubCmdMultiplier(pPDData);
    }

    SetLastError(dwErr);
    return dwErr;
}

//----------------------------------------------------
// Handler for the "set" command
DWORD
FnCmdSet(PPARAM_DESCR_DATA pPDData)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwArgumented = PRM_SET | PRM_MASK | PRM_ENABLED | PRM_FILE;
    DWORD dwAllowed = dwArgumented | PRM_REFRESH;

    if ((pPDData->dwExistingParams & ~dwAllowed) != 0)
        dwErr = _Err(ERROR_TOO_MANY_NAMES,L"Inconsistent phrase. Some of the parameters are not expected for this command.\n");
    else if ((pPDData->dwExistingParams & dwArgumented) != (pPDData->dwArgumentedParams & dwArgumented))
        dwErr = _Err(ERROR_BAD_ARGUMENTS,L"Value missing for some of the wireless network settings.\n");
    else if ((pPDData->dwExistingParams & dwAllowed) == PRM_SET)
        dwErr = _Err(ERROR_NO_DATA,L"Noop: No service parameter provided.\n");
    else
    {
        pPDData->pfnCommand = FnSubCmdSetSvcParams;
        dwErr = FnSubCmdMultiplier(pPDData);
    }

    SetLastError(dwErr);
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\argparse.h ===
#include "PrmDescr.h"
#pragma once

#define HEX(c)  ((c)<=L'9'?(c)-L'0':(c)<=L'F'?(c)-L'A'+0xA:(c)-L'a'+0xA)

//----------------------------------------------------
// Parser for the Guid type of argument
DWORD
FnPaGuid(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg);

//----------------------------------------------------
// Parser for the argument of the "mask" parameter
DWORD
FnPaMask(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg);

//----------------------------------------------------
// Parser for the argument of the "enabled" parameter
DWORD
FnPaEnabled(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg);

//----------------------------------------------------
// Parser for the argument of the "ssid" parameter
DWORD
FnPaSsid(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg);

//----------------------------------------------------
// Parser for the argument of the "bssid" parameter
DWORD
FnPaBssid(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg);

//----------------------------------------------------
// Parser for the argument of the "im" parameter
DWORD
FnPaIm(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg);

//----------------------------------------------------
// Parser for the argument of the "am" parameter
DWORD
FnPaAm(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg);

//----------------------------------------------------
// Parser for the argument of the "priv" parameter
DWORD
FnPaPriv(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg);

//----------------------------------------------------
// Parser for the argument of the "key" parameter
DWORD
FnPaKey(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg);

//----------------------------------------------------
// Parser for the boolean argument for the "onex" parameter
DWORD
FnPaOneX(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg);

//----------------------------------------------------
// Parser for the "outfile" file name parameter
FnPaOutFile(PPARAM_DESCR_DATA pPDData, PPARAM_DESCR pPDEntry, LPWSTR wszParamArg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\hash.h ===
#pragma once

typedef struct _HASH_NODE
{
    // hash structural links
    struct _HASH_NODE   *pUpLink;   // up level link to the "parent" node
    LIST_ENTRY          lstHoriz;   // horizontal links to "brother" nodes
    LIST_ENTRY          lstDown;    // down level links to "child" nodes
    // hash node data
    LPWSTR              wszKey;     // partial key info
    LPVOID              pObject;    // pointer to data opaque object
} HASH_NODE, *PHASH_NODE;

typedef struct _HASH
{
    BOOL                bValid;      // boolean telling whether the HASH is a valid object
    CRITICAL_SECTION    csMutex;
    PHASH_NODE          pRoot;
} HASH, *PHASH;

//--------- Private calls ------------------------------------------------
// Matches the keys one against the other.
UINT                            // [RET] number of matching chars
HshPrvMatchKeys(
    LPWSTR      wszKey1,        // [IN]  key 1
    LPWSTR      wszKey2);       // [IN]  key 2

// deletes all the pHash tree - doesn't touch the pObjects from within
// (if any)
VOID
HshDestructor(
    PHASH_NODE  pHash);         // [IN]  hash tree to delete

//--------- Public calls -------------------------------------------------
//
// Initializes a HASH structure
DWORD
HshInitialize(PHASH pHash);

// Cleans all resources referenced by a HASH structures
VOID
HshDestroy(PHASH pHash);

// Inserts an opaque object into the cache. The object is keyed on a wstring
// The call could alter the structure of the hash, hence it returns the reference
// to the updated hash.
DWORD                           // [RET] win32 error code
HshInsertObjectRef(
    PHASH_NODE  pHash,          // [IN]  hash to operate on
    LPWSTR      wszKey,         // [IN]  key of the object to insert
    LPVOID      pObject,        // [IN]  object itself to insert in the cache
    PHASH_NODE  *ppOutHash);    // [OUT] pointer to the updated hash

// Retrieves an object from the hash. The hash structure is not touched in
// any manner.
DWORD                           // [RET] win32 error code
HshQueryObjectRef(
    PHASH_NODE  pHash,          // [IN]  hash to operate on
    LPWSTR      wszKey,         // [IN]  key of the object to retrieve
    PHASH_NODE  *ppHashNode);   // [OUT] hash node referencing the queried object

// Removes the object referenced by the pHash node. This could lead to one or 
// more hash node removals (if a leaf node on an isolated branch) but it could
// also let the hash node untouched (i.e. internal node). 
// It is the caller's responsibility to clean up the object pointed by ppObject
DWORD                           // [RET] win32 error code
HshRemoveObjectRef(
    PHASH_NODE  pHash,          // [IN]  hash to operate on
    PHASH_NODE  pRemoveNode,    // [IN]  hash node to clear the reference to pObject
    LPVOID      *ppObject,      // [OUT] pointer to the object whose reference has been cleared
    PHASH_NODE  *ppOutHash);    // [OUT] pointer to the updated hash
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\cmdfn.h ===
#include "PrmDescr.h"
#pragma once

//----------------------------------------------------
// Handler for the "show" command
DWORD
FnCmdShow(PPARAM_DESCR_DATA pPDData);

//----------------------------------------------------
// Handler for the "add" command
DWORD
FnCmdAdd(PPARAM_DESCR_DATA pPDData);

//----------------------------------------------------
// Handler for the "delete" command
DWORD
FnCmdDelete(PPARAM_DESCR_DATA pPDData);

//----------------------------------------------------
// Handler for the "set" command
DWORD
FnCmdSet(PPARAM_DESCR_DATA pPDData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\hash.c ===
#include <precomp.h>
#include "ErrCtrl.h"
#include "utils.h"
#include "hash.h"

//~~~~~~~~~~~~~~~~~~~~~~~~ PRIVATE HASH FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Matches the keys one against the other.
UINT                            // [RET] number of matching chars
HshPrvMatchKeys(
    LPWSTR      wszKey1,        // [IN]  key 1
    LPWSTR      wszKey2)        // [IN]  key 2
{
    UINT i = 0;
    while (*wszKey1 != L'\0' && *wszKey1 == *wszKey2)
    {
        wszKey1++; wszKey2++;
        i++;
    }
    return i;
}

// deletes all the pHash tree - doesn't touch the pObjects from
// within (if any)
VOID
HshDestructor(
    PHASH_NODE  pHash)         // [IN]  hash tree to delete
{
    // pHash should not be NULL -- but who knows what the caller is doing!
    if (pHash != NULL)
    {
        while(!IsListEmpty(&(pHash->lstDown)))
        {
            PHASH_NODE pChild;
            pChild = CONTAINING_RECORD(pHash->lstDown.Flink, HASH_NODE, lstHoriz);

            HshDestructor(pChild);
        }
        RemoveEntryList(&(pHash->lstHoriz));
        MemFree(pHash->wszKey);
        MemFree(pHash);
    }
}

//~~~~~~~~~~~~~~~~~~~~~~~~ PUBLIC HASH FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Initializes a HASH structure
DWORD
HshInitialize(PHASH pHash)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (pHash != NULL)
    {
        __try 
        {
            InitializeCriticalSection(&(pHash->csMutex));
            pHash->bValid = TRUE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            dwErr = GetExceptionCode();
        }
        pHash->pRoot = NULL;
    }
    else
        dwErr = ERROR_INVALID_PARAMETER;

    SetLastError(dwErr);
    return dwErr;
}

// Cleans all resources referenced by a HASH structures
VOID
HshDestroy(PHASH pHash)
{
    HshDestructor(pHash->pRoot);
    if (pHash->bValid)
    {
        DeleteCriticalSection(&(pHash->csMutex));
        pHash->bValid = FALSE;
    }
}

// Inserts an opaque object into the cache. The object is keyed on a wstring
// The call could alter the structure of the hash, hence it returns the reference
// to the updated hash.
DWORD                           // [RET] win32 error code
HshInsertObjectRef(
    PHASH_NODE  pHash,          // [IN]  hash to operate on
    LPWSTR      wszKey,         // [IN]  key of the object to insert
    LPVOID      pObject,        // [IN]  object itself to insert in the cache
    PHASH_NODE  *ppOutHash)     // [OUT] pointer to the updated hash
{
    DWORD dwErr = ERROR_SUCCESS;

    _Asrt(ppOutHash != NULL, L"No output hash expected??");
    _Asrt(wszKey != NULL, L"Key info should not be NULL");

    // if the node passed in is NULL this means a new node
    // has to be created
    if (pHash == NULL)
    {
        // this node is definitely not in the hash
        // allocate the new node
        pHash = MemCAlloc(sizeof(HASH_NODE));
        if (pHash == NULL)
        {
            dwErr = GetLastError();
            goto exit;
        }
        // allocate mem for the new key
        pHash->wszKey = MemCAlloc(sizeof(WCHAR)*(wcslen(wszKey)+1));
        if (pHash->wszKey == NULL)
        {
            dwErr = GetLastError();
            MemFree(pHash);
            goto exit;
        }
        // copy the new key
        wcscpy(pHash->wszKey, wszKey);
        // initialize the horizontal and down lists
        InitializeListHead(&(pHash->lstHoriz));
        InitializeListHead(&(pHash->lstDown));
        // copy the reference to the object associated with the key
        pHash->pObject = pObject;
        // at this point we have a standalone newly created node:
        // no links are defined either on the horizontal, downwards or upwards
        // these will be set up (if needed) by the caller.
        *ppOutHash = pHash;
    }
    // if the node passed in is not NULL, we need to match as many
    // characters between wszKey and the node's key. Based on who's shorter
    // we decide to either set the reference (if keys identical) or 
    // break the branch (if wszKey is shorter than the current one) or
    // to recurse down the insertion.
    else
    {
        UINT        nMatch;
        PHASH_NODE  pChild;
        enum { MATCH, SUBSET, SUPERSET, UNDECIDED, RECURSE} nAnalysis;

        nMatch = HshPrvMatchKeys(wszKey, pHash->wszKey);

        // analyze the given key with respect to the current node;
        if (wszKey[nMatch] == L'\0' && pHash->wszKey[nMatch] == L'\0')
            // the key matches the current node
            nAnalysis = MATCH;
        else if (wszKey[nMatch] == L'\0')
            // the key is a subset of the current node
            nAnalysis = SUBSET;
        else 
        {
            // so far undecided - further see if this translates to SUPERSET
            // or even better, if SUPERSET can be handled by a child, hence
            // RECURSE.
            nAnalysis = UNDECIDED;

            if (pHash->wszKey[nMatch] == L'\0')
            {
                PLIST_ENTRY pEntry;

                // the new key is a superset of the current nod
                nAnalysis = SUPERSET;

                // the new key could be covered by one of the existent children.
                // check then if it is the case to send the work down to some child
                for (pEntry = pHash->lstDown.Flink;
                     pEntry != &(pHash->lstDown);
                     pEntry = pEntry->Flink)
                {
                    pChild = CONTAINING_RECORD(pEntry, HASH_NODE, lstHoriz);
                    if (wszKey[nMatch] == pChild->wszKey[0])
                    {
                        // the child to follow up has been located and saved
                        // in pChild. Set nAnalysis to UNDECIDED and break;
                        nAnalysis = RECURSE;
                        break;
                    }
                }
            }
        }

        // if the key matches exactly the current node
        // then is only a matter of setting the object's reference
        if (nAnalysis == MATCH)
        {
            // if the node is already referencing an object..
            if (pHash->pObject != NULL)
            {
                // signal out ERROR_DUPLICATE_TAG
                dwErr = ERROR_DUPLICATE_TAG;
            }
            else
            {
                // just insert the reference and get out with success.
                pHash->pObject = pObject;
                // save the Out hash pointer
                *ppOutHash = pHash;
            }
        }
        // if a child has been identified, let pChild (saved previously)
        // to follow up
        else if (nAnalysis == RECURSE)
        {
            dwErr = HshInsertObjectRef(
                        pChild,
                        wszKey+nMatch,
                        pObject,
                        ppOutHash);
            if (dwErr == ERROR_SUCCESS)
                *ppOutHash = pHash;
        }
        // if any of SUBSET, SUPERSET or UNDECIDED
        else
        {
            PHASH_NODE  pParent = NULL;
            LPWSTR      wszTrailKey = NULL;
            UINT        nTrailLen = 0;

            // [C = common part; c = current key; n = new key]
            // (SUBSET)               (UNDECIDED)
            // current: CCCCCccc  or  current: CCCCCccc
            // new:     CCCCC         new:     CCCCCnnnnn
            // 
            // In both cases, the current node splits.
            // Create first a new node, containing just CCCCC
            if (nAnalysis != SUPERSET)
            {
                // get the number of chars in pHash's key that are not matching 
                nTrailLen = wcslen(pHash->wszKey) - nMatch;

                // create first the trailing part of the key (allocate the number of
                // chars from the current node that didn't match)
                wszTrailKey = MemCAlloc(sizeof(WCHAR)*(nTrailLen+1));
                if (wszTrailKey == NULL)
                {
                    // if anything went wrong, just go out with the error.
                    // hash hasn't been modified.
                    dwErr = GetLastError();
                    goto exit;
                }
                // wcsncpy doesn't append the null terminator but the string
                // is already nulled out and it has the right size
                wcsncpy(wszTrailKey, pHash->wszKey+nMatch, nTrailLen);

                // create then the node that will act as the common parent
                pHash->wszKey[nMatch] = L'\0';
                dwErr = HshInsertObjectRef(
                    NULL,               // request a new node to be created
                    pHash->wszKey,      // common part of the current keys
                    NULL,               // this node is not referencing any object
                    &pParent);          // get back the newly created pointer.
                pHash->wszKey[nMatch] = wszTrailKey[0];

                // in case anything went wrong, the hash has not been altered,
                // we just need to bubble up the error.
                if (dwErr != ERROR_SUCCESS)
                {
                    MemFree(wszTrailKey);
                    goto exit;
                }

                // set the new parent up link
                pParent->pUpLink = pHash->pUpLink;
            }
            // (SUPERSET)              (UNDECIDED)
            // current: CCCCC      or  current: CCCCCccccc
            // new:     CCCCCnnn       new:     CCCCCnnn
            // In both cases a new node has to be created for the "nnn" part.
            if (nAnalysis != SUBSET)
            {
                dwErr = HshInsertObjectRef(
                            NULL,
                            wszKey + nMatch,
                            pObject,
                            &pChild);
                if (dwErr != ERROR_SUCCESS)
                {
                    // second creation failed, clean up everything and bail out
                    MemFree(wszTrailKey);
                    if (pParent != NULL)
                    {
                        MemFree(pParent->wszKey);
                        MemFree(pParent);
                    }
                    // hash structure is not altered at this point.
                    goto exit;
                }
                // link it up to the corresponding parent.
                pChild->pUpLink = (nAnalysis == SUPERSET) ? pHash : pParent;
            }

            // NO WAY BACK FROM NOW ON - hash is about to be altered
            // success is guaranteed
            // at this point, pChild is a non null pointer, with all the
            // LIST_ENTRIES from within the HASH_NODE initialized correctly.

            // (SUBSET)                 (UNDECIDED)
            // current: CCCCCccccc  or  current: CCCCCccccc
            // new:     CCCCC           new:     CCCCCnnn
            // if the node has split, put the new parent in its place
            if (nAnalysis != SUPERSET)
            {
                // set the current key to the shrinked unmatched trailing part
                MemFree(pHash->wszKey);
                pHash->wszKey = wszTrailKey;
                // set the current upLink to the new pParent node
                pHash->pUpLink = pParent;
                // insert the new parent into its place
                InsertHeadList(&(pHash->lstHoriz), &(pParent->lstHoriz));
                // remove the node from its previous parent
                RemoveEntryList(&(pHash->lstHoriz));
                // reset the current node's list
                InitializeListHead(&(pHash->lstHoriz));
                // insert the node to its new parent down list.
                InsertHeadList(&(pParent->lstDown), &(pHash->lstHoriz));
            }

            // (SUPERSET)              (UNDECIDED)
            // current: CCCCC      or  current: CCCCCccccc
            // new:     CCCCCnnn       new:     CCCCCnnn
            // if a new child node has been created, link it in the hash
            if (nAnalysis != SUBSET)
            {
                // if the given key was either a superset of the
                // current key or derived from the current key,
                // there is a separated node for it. Insert it in the down list
                if (nAnalysis == SUPERSET)
                {
                    InsertTailList(&(pHash->lstDown), &(pChild->lstHoriz));
                }
                else
                {
                    InsertTailList(&(pParent->lstDown), &(pChild->lstHoriz));
                }
            }
            else
            {
                // set the new parent's reference to this data.
                pParent->pObject = pObject;
            }
            *ppOutHash = (nAnalysis == SUPERSET) ? pHash : pParent;
            // and that's all - we're done successfully!
        }
    }

exit:
    SetLastError(dwErr);
    return dwErr;
}

// Retrieves an object from the hash. The hash structure is not touched in
// any manner.
DWORD                           // [RET] win32 error code
HshQueryObjectRef(
    PHASH_NODE  pHash,          // [IN]  hash to operate on
    LPWSTR      wszKey,         // [IN]  key of the object to retrieve
    PHASH_NODE  *ppHashNode)    // [OUT] hash node referencing the queried object
{
    DWORD dwErr = ERROR_FILE_NOT_FOUND;
    INT   nDiff;

    if (wszKey == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if (pHash == NULL)
    {
        dwErr = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    nDiff = wcscmp(wszKey, pHash->wszKey);

    if (nDiff == 0)
    {
        // The key is identical with the one in this node
        if (pHash->pObject != NULL)
        {
            if (ppHashNode != NULL)
            {
                *ppHashNode = pHash;
            }
            dwErr = ERROR_SUCCESS;
        }
        // If there is no object in this node, this means
        // the query failed with FILE_NOT_FOUND
    }
    else if (nDiff > 0)
    {
        // The key is larger than the current node's key
        UINT nTrail = wcslen(pHash->wszKey);
        PLIST_ENTRY pEntry;

        // The trailing part of the key could be covered by one of 
        // the children nodes. Scan then the Down list.
        for (pEntry = pHash->lstDown.Flink;
             pEntry != &(pHash->lstDown);
             pEntry = pEntry->Flink)
        {
            PHASH_NODE pChild;
            pChild = CONTAINING_RECORD(pEntry, HASH_NODE, lstHoriz);
            if (wszKey[nTrail] == pChild->wszKey[0])
            {
                // the child to follow up has been located and saved
                // in pChild. Try to match the trailing key against this node
                dwErr = HshQueryObjectRef(pChild, wszKey+nTrail, ppHashNode);
                break;
            }
        }
        // if no child has been located, dwErr is the default FILE_NOT_FOUND
    }
    // if nDiff < 0 - meaning key is included in the current node's key then
    // dwErr is the default FILE_NOT_FOUND which is good.

exit:
    SetLastError(dwErr);
    return dwErr;
}

// Removes the object referenced by the pHash node. This could lead to one or 
// more hash node removals (if a leaf node on an isolated branch) but it could
// also let the hash node untouched (i.e. internal node). 
// It is the caller's responsibility to clean up the object pointed by ppObject
DWORD                           // [RET] win32 error code
HshRemoveObjectRef(
    PHASH_NODE  pHash,          // [IN]  hash to operate on
    PHASH_NODE  pRemoveNode,    // [IN]  hash node to clear the reference to pObject
    LPVOID      *ppObject,      // [OUT] pointer to the object whose reference has been cleared
    PHASH_NODE  *ppOutHash)     // [OUT] pointer to the updated hash
{
    DWORD       dwErr = ERROR_SUCCESS;
    PHASH_NODE  pNewRoot = NULL;

    _Asrt(ppObject != NULL, L"No output object expected??");
    _Asrt(ppOutHash != NULL, L"No output hash expected??");
    _Asrt(pRemoveNode != NULL, L"No node to remove??");

    // if the node contains no reference, return FILE_NOT_FOUND
    if (pRemoveNode->pObject == NULL)
    {
        dwErr = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // remove the reference to the object at this moment
    *ppObject = pRemoveNode->pObject;
    pRemoveNode->pObject = NULL;

    // now climb the tree up to the root (!! - well it's a reversed tree) and merge
    // whatever nodes can be merged.
    // Merging: A node not referencing any object and having 0 or at most 1
    // successor can be deleted from the hash tree structure. 
    while ((pRemoveNode != NULL) &&
           (pRemoveNode->pObject == NULL) &&
           (pRemoveNode->lstDown.Flink->Flink == &(pRemoveNode->lstDown)))
    {
        PHASH_NODE  pUp = pRemoveNode->pUpLink;

        // if there is exactly 1 successor, its key needs to be prefixed with
        // the key of the node that is about to be removed. The successor also
        // needs to replace its parent in the hash tree structure.
        if (!IsListEmpty(&(pRemoveNode->lstDown)))
        {
            PHASH_NODE pDown;
            LPWSTR     wszNewKey;
            
            pDown = CONTAINING_RECORD(pRemoveNode->lstDown.Flink, HASH_NODE, lstHoriz);
            wszNewKey = MemCAlloc(sizeof(WCHAR)*(wcslen(pRemoveNode->wszKey)+wcslen(pDown->wszKey)+1));
            if (wszNewKey == NULL)
            {
                // if the allocation failed, bail out with the error code.
                // the reference had already been removed, the hash might
                // not be compacted but it is still valid!
                dwErr = GetLastError();
                goto exit;
            }
            wcscpy(wszNewKey, pRemoveNode->wszKey);
            wcscat(wszNewKey, pDown->wszKey);
            MemFree(pDown->wszKey);
            pDown->wszKey = wszNewKey;
            // now raise the child node as a replacement of its parent
            pDown->pUpLink = pRemoveNode->pUpLink;
            InsertHeadList(&(pRemoveNode->lstHoriz), &(pDown->lstHoriz));
            pNewRoot = pDown;
        }

        // remove the current node
        RemoveEntryList(&(pRemoveNode->lstHoriz));
        // cleanup all its memory
        MemFree(pRemoveNode->wszKey);
        MemFree(pRemoveNode);
        // finally go and check the upper level node (if there is any)
        pRemoveNode = pUp;
    }

    // if pRemoveNode ended up to be NULL, this means either the whole hash has been cleared
    // or a "brother" took the role of the root. pNewRoot has the right value in both cases
    // if pRemoveNode is not NULL, since it walked up the chain constantly it means pHash (the
    // original root) was not affected. Hence, return it out.
    *ppOutHash = (pRemoveNode == NULL) ? pNewRoot : pHash;

exit:
    SetLastError(dwErr);
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\output.c ===
#include <precomp.h>
#include "ErrCtrl.h"
#include "Utils.h"
#include "Output.h"

//------------------------------------------------------
// Output utility routine for printing the BSSID
// NOTE: This routine shouldn't be called from multithreaded apps.
// WZCTOOL is far from being multithreaded though!
LPWSTR
OutBssid(PPARAM_DESCR_DATA pPDData, PNDIS_802_11_MAC_ADDRESS pndBssid)
{
    static WCHAR wszBssid[32];

    if (pndBssid == NULL)
        wcscpy(wszBssid, L"#Err#");
    else
        wsprintf(wszBssid,L"%02x:%02x:%02x:%02x:%02x:%02x",
             (*pndBssid)[0], (*pndBssid)[1], (*pndBssid)[2], (*pndBssid)[3], (*pndBssid)[4], (*pndBssid)[5]);

    return wszBssid;
}

//------------------------------------------------------
// Output utility routine for printing the SSID
// NOTE: This routine shouldn't be called from multithreaded apps.
// WZCTOOL is far from being multithreaded though!
LPWSTR
OutSsid(PPARAM_DESCR_DATA pPDData, PNDIS_802_11_SSID pndSsid)
{
    static WCHAR wszSsid[64];

    if (pndSsid == NULL)
        wcscpy(wszSsid, L"#Err#");
    else
    {
        if (pndSsid->SsidLength >= 32)
        {
            wsprintf(wszSsid, L"[%d] #Err#", pndSsid->SsidLength);
        }
        else
        {
            CHAR szSsid[33];
            memcpy(szSsid, pndSsid->Ssid, pndSsid->SsidLength);
            szSsid[pndSsid->SsidLength] = '\0';
            wsprintf(wszSsid, L"[%d] %S", pndSsid->SsidLength, szSsid);
        }
    }

    return wszSsid;
}

//------------------------------------------------------
// Output routine for a wireless network configuration (visible or preferred)
DWORD
OutNetworkConfig(PPARAM_DESCR_DATA pPDData, PWZC_WLAN_CONFIG pwzcConfig)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (pwzcConfig == NULL)
        dwErr = ERROR_GEN_FAILURE;
    else
    {
        CHAR szLine[120];
        UINT nIdx;

        memset(szLine,' ', 120);
        nIdx = sprintf(szLine, "%S", OutSsid(pPDData, &pwzcConfig->Ssid));
        szLine[nIdx] = ' ';
        nIdx += 36 - (nIdx%36);
        if (pPDData->dwExistingParams & PRM_VISIBLE)
        {
            nIdx += sprintf(szLine+nIdx, "%S", OutBssid(pPDData, &pwzcConfig->MacAddress));
            szLine[nIdx] = ' ';
            nIdx += 2;
        }
        nIdx += sprintf(szLine+nIdx, "im=%d", pwzcConfig->InfrastructureMode);
        szLine[nIdx] = ' ';
        nIdx += 8 - (nIdx%8);
        nIdx += sprintf(szLine+nIdx, "am=%d", pwzcConfig->AuthenticationMode);
        szLine[nIdx] = ' ';
        nIdx += 8 - (nIdx%8);
        // for XP SP, the meaning of this field is boolean!
        nIdx += sprintf(szLine+nIdx, "priv=%d", pwzcConfig->Privacy ? Ndis802_11WEPEnabled : Ndis802_11WEPDisabled);
        if (pPDData->dwExistingParams & PRM_PREFERRED)
        {
            szLine[nIdx] = ' ';
            nIdx += 8 - (nIdx%8);
            if (pwzcConfig->dwCtlFlags & WZCCTL_WEPK_PRESENT)
                nIdx += sprintf(szLine+nIdx, "key=%d", pwzcConfig->KeyIndex + 1);
            else
                nIdx += sprintf(szLine+nIdx, "key=?");
        }
        fprintf(pPDData->pfOut, "%s\n",szLine);
    }

    SetLastError(dwErr);
    return dwErr;
}

//======================================================
// Public routines
//------------------------------------------------------
// Output header for the case of a multiplied command (applying to * interfaces)
DWORD
OutIntfsHeader(PPARAM_DESCR_DATA pPDData)
{
    fwprintf(pPDData->pfOut, L"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%s\n", pPDData->wzcIntfEntry.wszGuid);

    SetLastError(ERROR_SUCCESS);
    return ERROR_SUCCESS;
}

//------------------------------------------------------
// Output trailer for the case of a multiplied command (applying to * interfaces)
DWORD
OutIntfsTrailer(PPARAM_DESCR_DATA pPDData, DWORD dwErr)
{
    fwprintf(pPDData->pfOut, L"____________________________________Completed with code %d\n", dwErr);

    SetLastError(ERROR_SUCCESS);
    return ERROR_SUCCESS;
}

//------------------------------------------------------
// Output routine for the list of wireless interfaces
DWORD
OutNetworkIntfs(PPARAM_DESCR_DATA pPDData, PINTFS_KEY_TABLE pIntfTable)
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT i;

    if (pIntfTable == NULL)
        dwErr = ERROR_INVALID_PARAMETER;
    else
    {
        for (i = 0; i < pIntfTable->dwNumIntfs; i++)
        {
            fwprintf(pPDData->pfOut, L"[%d] %s\n", i, pIntfTable->pIntfs[i].wszGuid);
        }
    }

    SetLastError(dwErr);
    return dwErr;
}

//------------------------------------------------------
// Output routine for the generic service WZC parameters (flags are Os specific)
DWORD
OutSvcParams(PPARAM_DESCR_DATA pPDData, DWORD dwOsInFlags, DWORD dwOsOutFlags)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (dwOsInFlags & _Os(INTF_CM_MASK))
    {
        fprintf(pPDData->pfOut, "Mask        : ");         
        if (dwOsOutFlags & _Os(INTF_CM_MASK))
            fprintf(pPDData->pfOut, "%d\n",pPDData->wzcIntfEntry.dwCtlFlags & INTFCTL_CM_MASK); 
        else
            fprintf(pPDData->pfOut, "#Err#\n");
    }
    if (dwOsInFlags & _Os(INTF_ENABLED))
    {
        fprintf(pPDData->pfOut, "Enabled     : ");
        if (dwOsOutFlags & _Os(INTF_ENABLED))
            fprintf(pPDData->pfOut, "%d\n", pPDData->wzcIntfEntry.dwCtlFlags & INTF_ENABLED ? 1 : 0);
        else
            fprintf(pPDData->pfOut, "#Err#\n");
    }
    if (dwOsInFlags & _Os(INTF_SSID))
    {
        fprintf(pPDData->pfOut, "SSID        : ");
        if (dwOsOutFlags & _Os(INTF_SSID))
        {
            NDIS_802_11_SSID Ssid = {0};
            Ssid.SsidLength = pPDData->wzcIntfEntry.rdSSID.dwDataLen;
            if (Ssid.SsidLength <= 32)
                memcpy(Ssid.Ssid, pPDData->wzcIntfEntry.rdSSID.pData, Ssid.SsidLength);

            fprintf(pPDData->pfOut, "%S\n", OutSsid(pPDData, &Ssid));
        }
        else
            fprintf(pPDData->pfOut, "#Err#\n");
    }
    if (dwOsInFlags & _Os(INTF_BSSID))
    {
        fprintf(pPDData->pfOut, "BSSID       : ");
        if (dwOsOutFlags & _Os(INTF_BSSID))
            fprintf(pPDData->pfOut, "%S\n", OutBssid(pPDData, (PNDIS_802_11_MAC_ADDRESS)pPDData->wzcIntfEntry.rdBSSID.pData));
        else
            fprintf(pPDData->pfOut, "#Err#\n");
    }
    if (dwOsInFlags & _Os(INTF_INFRAMODE))
    {
        fprintf(pPDData->pfOut, "Infra Mode  : ");
        if (dwOsOutFlags & _Os(INTF_INFRAMODE))
            fprintf(pPDData->pfOut, "%d\n", pPDData->wzcIntfEntry.nInfraMode);
        else
            fprintf(pPDData->pfOut, "#Err#\n");
    }
    if (dwOsInFlags & _Os(INTF_AUTHMODE))
    {
        fprintf(pPDData->pfOut, "Auth Mode   : ");
        if (dwOsOutFlags & _Os(INTF_AUTHMODE))
            fprintf(pPDData->pfOut, "%d\n", pPDData->wzcIntfEntry.nAuthMode);
        else
            fprintf(pPDData->pfOut, "#Err#\n");
    }
    if (dwOsInFlags & _Os(INTF_WEPSTATUS))
    {
        fprintf(pPDData->pfOut, "Privacy     : ");
        if (dwOsOutFlags & _Os(INTF_WEPSTATUS))
            fprintf(pPDData->pfOut, "%d\n", pPDData->wzcIntfEntry.nWepStatus);
        else
            fprintf(pPDData->pfOut, "#Err#\n");
    }

    SetLastError(dwErr);
    return dwErr;
}

//------------------------------------------------------
// Output routine for a list of wireless networks (visible or preferred)
DWORD
OutNetworkCfgList(PPARAM_DESCR_DATA pPDData, UINT nRetrieved, UINT nFiltered)
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT i;
    PWZC_802_11_CONFIG_LIST pwzcCfgList;

    if (pPDData->dwExistingParams & PRM_VISIBLE)
    {
        pwzcCfgList = (PWZC_802_11_CONFIG_LIST)pPDData->wzcIntfEntry.rdBSSIDList.pData;
        fprintf(pPDData->pfOut, "Visible networks: ");
    }
    else
    {
        pwzcCfgList = (PWZC_802_11_CONFIG_LIST)pPDData->wzcIntfEntry.rdStSSIDList.pData;
        fprintf(pPDData->pfOut, "Preferred networks: ");
    }
    fprintf(pPDData->pfOut, "retrieved %d - filtered %d.\n------------------------------------\n", nRetrieved, nFiltered);

    if (pwzcCfgList != NULL)
    {
        for (i = 0; dwErr == ERROR_SUCCESS && i < pwzcCfgList->NumberOfItems; i++)
        {
            PWZC_WLAN_CONFIG pwzcConfig = &pwzcCfgList->Config[i];

            dwErr = OutNetworkConfig(pPDData, pwzcConfig);
        }
    }

    SetLastError(dwErr);
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\output.h ===
#include "PrmDescr.h"
#pragma once

//------------------------------------------------------
// Output header for the case of a multiplied command (applying to * interfaces)
DWORD
OutIntfsHeader(PPARAM_DESCR_DATA pPDData);

//------------------------------------------------------
// Output trailer for the case of a multiplied command (applying to * interfaces)
DWORD
OutIntfsTrailer(PPARAM_DESCR_DATA pPDData, DWORD dwErr);

//------------------------------------------------------
// Output routine for the list of wireless interfaces
DWORD
OutNetworkIntfs(PPARAM_DESCR_DATA pPDData, PINTFS_KEY_TABLE pIntfTable);

//------------------------------------------------------
// Output routine for the generic service WZC parameters
DWORD
OutSvcParams(PPARAM_DESCR_DATA pPDData, DWORD dwOsInFlags, DWORD dwOsOutFlags);

//------------------------------------------------------
// Output routine for a list of wireless networks (visible or preferred)
DWORD
OutNetworkCfgList(PPARAM_DESCR_DATA pPDData, UINT nRetrieved, UINT nFiltered);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\utils.h ===
#include "PrmDescr.h"
#pragma once

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// MEMORY ALLOCATION UTILITIES (defines, structs, funcs)
#define MemCAlloc(nBytes)   Process_user_allocate(nBytes)
#define MemFree(pMem)       Process_user_free(pMem)

PVOID
Process_user_allocate(size_t NumBytes);

VOID
Process_user_free(LPVOID pMem);

// global variables
extern OSVERSIONINFOEX      g_verInfoEx;

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// UTILITIES (defines, structs, funcs)
//-----------------------------------------------------------
// True if the utility runs on XP RTM (non svc pack, bld 2600)
BOOL IsXPRTM();

// Translates current WZC control flags to values from legacy OS versions
// Returns the Os dependant flag value
DWORD _Os(DWORD dwApiCtl);

// WzcConfigHit: tells weather the WZC_WLAN_CONFIG matches the criteria in pPDData
BOOL
WzcConfigHit(
    PPARAM_DESCR_DATA pPDData,
    PWZC_WLAN_CONFIG pwzcConfig);

// WzcFilterList: Filter the wzc list according to the settings in pPDData
DWORD
WzcFilterList(
    BOOL bInclude,
    PPARAM_DESCR_DATA pPDData,
    PWZC_802_11_CONFIG_LIST pwzcList);

// WzcDisableOneX: Make sure 802.1x is disabled for the SSID in pPDData
DWORD
WzcSetOneX(
    PPARAM_DESCR_DATA pPDData,
    BOOL bEnableOneX);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\precomp.h ===
#pragma once

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <tchar.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rpc.h>
#include <windows.h>

#include <ntddndis.h>
#include <ntddip.h>
typedef NDIS_802_11_MAC_ADDRESS *PNDIS_802_11_MAC_ADDRESS;

#include <ndisguid.h>
#include <shellapi.h>

#include <wzcsapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\prmdescr.c ===
#include <precomp.h>
#include "PrmDescr.h"
#include "ArgParse.h"
#include "CmdFn.h"

// global object storing all the data needed in order to process the wzctool command
PARAM_DESCR_DATA  g_PDData;

// global table containing the description of all possible parameters
PARAM_DESCR g_PDTable[] =
{
    // param ID ------- param string -- arg parser ---- command function
    {PRM_SHOW,      L"show",        FnPaGuid,       FnCmdShow},
    {PRM_ADD,       L"add",         FnPaGuid,       FnCmdAdd},
    {PRM_DELETE,    L"delete",      FnPaGuid,       FnCmdDelete},
    {PRM_SET,       L"set",         FnPaGuid,       FnCmdSet},
    {PRM_VISIBLE,   L"visible",     NULL,           NULL},
    {PRM_PREFERRED, L"preferred",   NULL,           NULL},
    {PRM_MASK,      L"mask",        FnPaMask,       NULL},  
    {PRM_ENABLED,   L"enabled",     FnPaEnabled,    NULL},  
    {PRM_SSID,      L"ssid",        FnPaSsid,       NULL},  
    {PRM_BSSID,     L"bssid",       FnPaBssid,      NULL},  
    {PRM_IM,        L"im",          FnPaIm,         NULL},  
    {PRM_AM,        L"am",          FnPaAm,         NULL},  
    {PRM_PRIV,      L"priv",        FnPaPriv,       NULL},  
    {PRM_ONETIME,   L"onetime",     NULL,           NULL},
    {PRM_REFRESH,   L"refresh",     NULL,           NULL},
    {PRM_KEY,       L"key",         FnPaKey,        NULL},
    {PRM_ONEX,      L"onex",        FnPaOneX,       NULL},
    {PRM_FILE,      L"output",      FnPaOutFile,    NULL}
};

// global hash used to store all the acceptable parameters
HASH g_PDHash;

//----------------------------------------------------------
// initialize and fill in the hash for the parameter descriptors
// Returns: win32 error
DWORD
PDInitialize()
{
    DWORD dwErr;

    // initialize the parameter descriptors data
    ZeroMemory(&g_PDData, sizeof(PARAM_DESCR_DATA));
    g_PDData.pfOut = stdout;

    // initialize the parameter descriptors hash
    dwErr = HshInitialize(&g_PDHash);
    // fill in the parameter descriptors hash
    if (dwErr == ERROR_SUCCESS)
    {
        UINT nPDTableSize = sizeof(g_PDTable) / sizeof(PARAM_DESCR);
        UINT i;

        for (i=0; dwErr == ERROR_SUCCESS && i < nPDTableSize; i++)
        {
            PPARAM_DESCR pPDTableEntry = &(g_PDTable[i]);
            dwErr = HshInsertObjectRef(
                        g_PDHash.pRoot,
                        pPDTableEntry->wszParam,
                        pPDTableEntry,
                        &(g_PDHash.pRoot));
        }
    }

    SetLastError(dwErr);
    return dwErr;
}

//----------------------------------------------------------
// Clean out resources used for the parameter descriptors
VOID
PDDestroy()
{
    // clean out the parameter descriptors data
    WZCDeleteIntfObj(&(g_PDData.wzcIntfEntry));
    // close the output file
    if (g_PDData.pfOut != stdout)
    {
        fclose(g_PDData.pfOut);
        g_PDData.pfOut = stdout;
    }

    // clean out resources used by the parameter descriptors hash
    HshDestroy(&g_PDHash);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\prmdescr.h ===
#include "hash.h"
#pragma once

typedef struct _PARAM_DESCR_DATA *PPARAM_DESCR_DATA;
typedef struct _PARAM_DESCR      *PPARAM_DESCR;

typedef DWORD (*PARAM_PARSE_FN)(
        PPARAM_DESCR_DATA pPDData,
        PPARAM_DESCR      pPDEntry,
        LPWSTR wszParamArg);

typedef DWORD (*PARAM_CMD_FN)(
        PPARAM_DESCR_DATA pPDData);

typedef struct _PARAM_DESCR_DATA
{
    DWORD           dwExistingParams;   // bitmask of params provided by the user
    DWORD           dwArgumentedParams; // bitmask of argumented params provided by the user (subset of dwExistingParams)
    FILE            *pfOut;
    BOOL            bOneX;              // OneX boolean value
    PARAM_CMD_FN    pfnCommand;         // function handler for the cmd line command
    INTF_ENTRY      wzcIntfEntry;       // storage for all WZC params
} PARAM_DESCR_DATA;

typedef struct _PARAM_DESCR
{
    UINT            nParamID;       // parameter ID
    LPWSTR          wszParam;       // parameter string
    PARAM_PARSE_FN  pfnArgParser;   // parser function for the parameter's argument
    PARAM_CMD_FN    pfnCommand;     // command function for the parameter
} PARAM_DESCR;

#define PRM_SHOW        0x00000001
#define PRM_ADD         0x00000002
#define PRM_DELETE      0x00000004
#define PRM_SET         0x00000008
#define PRM_VISIBLE     0x00000010
#define PRM_PREFERRED   0x00000020
#define PRM_MASK        0x00000040
#define PRM_ENABLED     0x00000080
#define PRM_SSID        0x00000100
#define PRM_BSSID       0x00000200
#define PRM_IM          0x00000400
#define PRM_AM          0x00000800
#define PRM_PRIV        0x00001000
#define PRM_ONETIME     0x00002000
#define PRM_REFRESH     0x00004000
#define PRM_KEY         0x00008000
#define PRM_ONEX        0x00010000
#define PRM_FILE        0x00020000

extern PARAM_DESCR_DATA     g_PDData;
extern PARAM_DESCR          g_PDTable[];
extern HASH                 g_PDHash;

//----------------------------------------------------------
// Initialize and fill in hash for the parameter descriptors
// Returns: win32 error
DWORD
PDInitialize();

//----------------------------------------------------------
// Clean out resources used for the parameter descriptors
VOID
PDDestroy();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\utils.c ===
#include <precomp.h>
#include "utils.h"

// global storing the OS version#
OSVERSIONINFOEX g_verInfoEx = {0};

//------------------------------------
// Allocates general usage memory from the process heap
PVOID
Process_user_allocate(IN size_t NumBytes)
{
    PVOID pMem;
    pMem = (NumBytes > 0) ? HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, NumBytes) : NULL;
    return pMem;
}

//------------------------------------
// Frees general usage memory
VOID
Process_user_free(IN LPVOID pMem)
{
    if (pMem != NULL)
        HeapFree(GetProcessHeap(), 0, (pMem));
}

BOOL IsXPRTM()
{
    return (g_verInfoEx.dwBuildNumber == 2600) && (g_verInfoEx.wServicePackMajor == 0);
}

// Translates current WZC control flags to values from legacy OS versions
// Returns the Os dependant flag value
DWORD _Os(DWORD dwApiCtl)
{
    // the only translation should happen for XP RTM
    if (IsXPRTM())
    {
        DWORD dwRTMApiCtl = 0;

        if (dwApiCtl & INTF_BSSIDLIST)
            dwRTMApiCtl |= 0x00004000;
        if (dwApiCtl & INTF_PREFLIST)
            dwRTMApiCtl |= 0x00000020;
        if (dwApiCtl & INTF_CM_MASK)
            dwRTMApiCtl |= 0x00000010;
        if (dwApiCtl & INTF_ENABLED)
            dwRTMApiCtl |= 0x00000010;
        if (dwApiCtl & INTF_SSID)
            dwRTMApiCtl |= 0x00001000;
        if (dwApiCtl & INTF_INFRAMODE)
            dwRTMApiCtl |= 0x00000200;
        if (dwApiCtl & INTF_AUTHMODE)
            dwRTMApiCtl |= 0x00000400;
        if (dwApiCtl & INTF_WEPSTATUS)
            dwRTMApiCtl |= 0x00000800;
        if (dwApiCtl & INTF_BSSID)
            dwRTMApiCtl |= 0x00002000;
        if (dwApiCtl & INTF_LIST_SCAN)
            dwRTMApiCtl |= 0x00008000;

        dwApiCtl = dwRTMApiCtl;
    }
    
    return dwApiCtl;
}

//-----------------------------------------------------------
// WzcConfigHit: tells weather the WZC_WLAN_CONFIG matches the criteria in pPDData
BOOL
WzcConfigHit(
    PPARAM_DESCR_DATA pPDData,
    PWZC_WLAN_CONFIG pwzcConfig)
{
    BOOL bRet = TRUE;

    if (bRet && (pPDData->dwArgumentedParams & PRM_IM))
    {
        bRet = (pwzcConfig->InfrastructureMode == pPDData->wzcIntfEntry.nInfraMode);
    }
    if (bRet && (pPDData->dwArgumentedParams & PRM_AM))
    {
        bRet = (pwzcConfig->AuthenticationMode == pPDData->wzcIntfEntry.nAuthMode);
    }
    if (bRet && (pPDData->dwArgumentedParams & PRM_PRIV))
    {
        bRet = (pwzcConfig->Privacy == pPDData->wzcIntfEntry.nWepStatus);
    }
    if (bRet && (pPDData->dwArgumentedParams & PRM_BSSID))
    {
        bRet = (memcmp(
                    &(pwzcConfig->MacAddress),
                    pPDData->wzcIntfEntry.rdBSSID.pData,
                    sizeof(NDIS_802_11_MAC_ADDRESS)) 
                 == 0);
    }
    if (bRet && (pPDData->dwArgumentedParams & PRM_SSID))
    {
        bRet = (pwzcConfig->Ssid.SsidLength == pPDData->wzcIntfEntry.rdSSID.dwDataLen);
        bRet = bRet &&
               (memcmp(
                    &(pwzcConfig->Ssid.Ssid),
                    pPDData->wzcIntfEntry.rdSSID.pData,
                    pwzcConfig->Ssid.SsidLength) 
                == 0);
    }
    return bRet;
}

//-----------------------------------------------------------
// WzcFilterList: Filter the wzc list according to the settings in pPDData
DWORD
WzcFilterList(
    BOOL bInclude,
    PPARAM_DESCR_DATA pPDData,
    PWZC_802_11_CONFIG_LIST pwzcList)
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT i;

    if (pwzcList == NULL)
        dwErr = ERROR_GEN_FAILURE;
    else
    {
        for (i = 0; i < pwzcList->NumberOfItems; i++)
        {
            PWZC_WLAN_CONFIG pwzcConfig = &pwzcList->Config[i];

            if (bInclude != WzcConfigHit(pPDData, pwzcConfig))
            {
                if (i < pwzcList->NumberOfItems - 1)
                {
                    memmove(
                        &pwzcList->Config[i],
                        &pwzcList->Config[i+1],
                        (pwzcList->NumberOfItems - i - 1) * sizeof(WZC_WLAN_CONFIG));
                }
                i--;
                pwzcList->NumberOfItems--;
            }
        }
    }

    SetLastError(dwErr);
    return dwErr;
}

//-----------------------------------------------------------
// WzcDisableOneX: Make sure 802.1x is disabled for the SSID in pPDData
DWORD
WzcSetOneX(
    PPARAM_DESCR_DATA pPDData,
    BOOL bEnableOneX)
{
    DWORD dwErr = ERROR_SUCCESS;
    EAPOL_INTF_PARAMS   eapolParams = {0};

    if (pPDData == NULL ||
        (pPDData->dwArgumentedParams & PRM_SSID) == 0 ||
        (pPDData->wzcIntfEntry.rdSSID.dwDataLen > MAX_SSID_LEN))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        memcpy(eapolParams.bSSID, 
               pPDData->wzcIntfEntry.rdSSID.pData,
               pPDData->wzcIntfEntry.rdSSID.dwDataLen);
        eapolParams.dwSizeOfSSID = pPDData->wzcIntfEntry.rdSSID.dwDataLen;
    }

    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = WZCEapolGetInterfaceParams (
                    NULL,
                    pPDData->wzcIntfEntry.wszGuid,
                    &eapolParams);
    }

    if (IsXPRTM() && dwErr != ERROR_SUCCESS)
    {
        eapolParams.dwEapFlags = DEFAULT_MACHINE_AUTH_STATE | DEFAULT_GUEST_AUTH_STATE;
        eapolParams.dwEapType = DEFAULT_EAP_TYPE;
        memcpy(eapolParams.bSSID, 
               pPDData->wzcIntfEntry.rdSSID.pData,
               pPDData->wzcIntfEntry.rdSSID.dwDataLen);
        eapolParams.dwSizeOfSSID = pPDData->wzcIntfEntry.rdSSID.dwDataLen;
        dwErr = ERROR_SUCCESS;
    }

    if (dwErr == ERROR_SUCCESS)
    {
        if (bEnableOneX)
            eapolParams.dwEapFlags |= EAPOL_ENABLED;
        else
            eapolParams.dwEapFlags &= ~EAPOL_ENABLED;

        dwErr = WZCEapolSetInterfaceParams (
                    NULL,
                    pPDData->wzcIntfEntry.wszGuid,
                    &eapolParams);
    }

    SetLastError(dwErr);
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\layer2svc\zeroconf\wzctool\wzctool.c ===
#include <precomp.h>
#include "ErrCtrl.h"
#include "PrmDescr.h"
#include "utils.h"

//-------------------------------------------------------
// Parser code for the command line parameters.
// Parameters:
// [IN] nArgc: number of command line parameters
// [IN] pwszArgv: array of pointers to the command line parameteres
// [OUT] pnErrArgi: index to the faulty parameter (in case of error)
// Returns:
//    ERROR_SUCCESS in case everything went fine
//    any win32 error in case of failure. On error, pnErrArgi indicates
//    the faulty parameter.
DWORD
WZCToolParse(UINT nPrmC, LPWSTR *pwszPrmV, UINT *pnErrPrmI)
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT  nPrmI = 0;

    for (nPrmI = 0; dwErr == ERROR_SUCCESS && nPrmI < nPrmC; nPrmI++)
    {
        LPWSTR          pArg;
        PHASH_NODE      pPrmNode;
        PPARAM_DESCR    pPrmDescr;

        // get the pointer to the parameter's argument, if any
        pArg = wcschr(pwszPrmV[nPrmI], L'=');
        if (pArg != NULL)
            *pArg = L'\0';

        // get the hash node for the parameter, if it is present in the hash
        pPrmNode = NULL;
        dwErr = HshQueryObjectRef(
            g_PDHash.pRoot,
            pwszPrmV[nPrmI],
            &pPrmNode);

        // restore the '=' in the parameter string
        if (pArg != NULL)
        {
            *pArg = L'=';
            pArg++;
        }

        // if the parameter is valid (found in the hash)
        if (dwErr == ERROR_SUCCESS)
        {
            // get the pointer to the parameter descriptor
            pPrmDescr = (PPARAM_DESCR)pPrmNode->pObject;

            // check if this is not a duplicated parameter
            if (g_PDData.dwExistingParams & pPrmDescr->nParamID)
                // if it is, set the error
                dwErr = ERROR_DUPLICATE_TAG;
            else
            {
                // else mark the parameter does exist now
                g_PDData.dwExistingParams |= pPrmDescr->nParamID;

                // if this is a command parameter and one has been found already,
                // only accepts one command per call.
                if (pPrmDescr->pfnCommand != NULL && g_PDData.pfnCommand != NULL)
                    dwErr = ERROR_INVALID_FUNCTION;
            }
        }

        // if everything is ok so far and this param has an argument..
        if (dwErr == ERROR_SUCCESS && pArg != NULL)
        {
            // ..if the param does not support arguments..
            if (pPrmDescr->pfnArgParser == NULL)
                // set the error
                dwErr = ERROR_NOT_SUPPORTED;
            else
                // otherwise have the param to parse its argument.
                dwErr = pPrmDescr->pfnArgParser(&g_PDData, pPrmDescr, pArg);
        }

        // if the parameter is entirely successful parsing its argument (if any) and is a
        // command parameter (it is the first) encountered, save its command handler
        if (dwErr == ERROR_SUCCESS && pPrmDescr->pfnCommand != NULL)
            g_PDData.pfnCommand = pPrmDescr->pfnCommand;
    }

    if (dwErr != ERROR_SUCCESS && pnErrPrmI != NULL)
        *pnErrPrmI = nPrmI;

    return dwErr;
}

void _cdecl main()
{
    LPWSTR *pwszPrmV = NULL;
    UINT   nPrmC = 0;
    UINT   nErrPrmI;
    DWORD  dwErr;


    // get OS version
    g_verInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (!GetVersionEx((LPOSVERSIONINFO)&g_verInfoEx))
        _Asrt(FALSE, L"Error %d determining the OS version\n", GetLastError());

    // get the command line in WCHAR
    pwszPrmV = CommandLineToArgvW(GetCommandLineW(), &nPrmC);
    _Asrt(nPrmC >= 2, L"Invalid parameters count (%d)\n", nPrmC);
    _Asrt(pwszPrmV != NULL, L"Invalid parameters array (%p)\n", pwszPrmV);

    // initialize and fill in the parameter's list,
    // initialize the parameter descriptor data
    dwErr = PDInitialize();
    _Asrt(dwErr == ERROR_SUCCESS, L"Unexpected error (%d) in param hash initialization.\n", dwErr);

    // scan command line parameters
    dwErr = WZCToolParse(nPrmC-1, pwszPrmV+1, &nErrPrmI);
    _Asrt(dwErr == ERROR_SUCCESS, L"Error %d encountered while parsing parameter \"%s\"\n", 
          dwErr,
          dwErr != ERROR_SUCCESS ? pwszPrmV[nErrPrmI] : NULL);

    _Asrt(g_PDData.pfnCommand != NULL,
          L"Noop: No action parameter provided.\n");

    dwErr = g_PDData.pfnCommand(&g_PDData);
    _Asrt(dwErr == ERROR_SUCCESS,L"Error %d encountered while executing the command.\n",dwErr);

    // cleanout whatever resources we might have had allocated
    PDDestroy();

    // set the %errorlevel% environment variable
    exit(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\parser\pgm.h ===
//============================================================================
//
//  Copyright (C) 1999 Microsoft Corporation
//
//  FILE: PGM.h
//
//  Description: PGM Parser
//
//  Note: info for this parser was gleaned from:
//  PGM
//
//  Modification History:
//
//  Madhurima Pawar      08/04/00    Created
//============================================================================

#ifndef _PGM_H_
#define _PGM_H_

#include <windows.h>
#include <netmon.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>


#define PGM_FMT_STR_SIZE        80*10      //The Max length of a string of the NetMon interface
#define PGM_INDENT              3       //How far to indent when formatting the PGM Properties
#define PGM_AF_IPV4				1	   //IP version 1
#define PGM_PROTOCOL_NUMBER     113   //The PGM source port number
#define SOURCE_ID_LENGTH        6


// structure for decoding the header -----------------------------------------
/*
typedef struct _WIDE_OPTION {
    WORD OptionType;
    WORD OptionLength;
    BYTE OptionValue[1];
} WIDE_OPTION, *LPWIDE_OPTION;
*/

typedef enum
{
    PGM_SUMMARY = 0,
    PGM_SOURCE_PORT,
    PGM_DESTINATION_PORT,
    PGM_TYPE,
    PGM_CHECKSUM ,
    PGM_GLOBAL_SOURCE_ID,
    PGM_TSDU_LENGTH,
    PGM_SEQUENCE_NUMBER,
    PGM_TRAILING_EDGE,
    PGM_LEADING_EDGE,
    PGM_NLA_TYPE_SOURCE,
    PGM_NLA_TYPE_MCAST_GROUP,
    PGM_NLA_AFI,
    PGM_NLA_RESERVED,
    PGM_NLA_IP,
    PGM_OPTIONS,
    PGM_OPTIONS_FLAGS,
    PGM_HEADER_OPTIONS,
    PGM_OPTION_TYPE_NAK_SEQ,
    PGM_OPTION_TYPE_FRAGMENT,
    PGM_OPTION_TYPE_LATE_JOINER,
    PGM_OPTION_TYPE_SYN,
    PGM_OPTION_TYPE_FIN,
    PGM_OPTION_TYPE_RST,
    PGM_OPTION_TYPE_PARITY_PRM,
    PGM_OPTION_TYPE_PARITY_GRP,
    PGM_OPTION_TYPE_PARITY_TGSIZE,
    PGM_OPTIONS_FIELD_LENGTH,
    PGM_OPTIONS_NAK_SEQ,
    PGM_OPTIONS_MESSAGE_FIRST_SEQUENCE,
    PGM_OPTIONS_MESSAGE_OFFSET,
    PGM_OPTIONS_MESSAGE_LENGTH,
    PGM_OPTIONS_LATE_JOINER,
    PGM_OPTIONS_PARITY_OPT,
    PGM_OPTIONS_PARITY_PRM_GRP_SZ,
    PGM_OPTIONS_PARITY_GRP,
    PGM_OPTIONS_PARITY_TG_SZ,
    PGM_DATA
};

// ***********************************************************
//                      PGM - specific data
// ***********************************************************
#define htons(x)        ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))

__inline long
htonl(long x)
{
    return((((x) >> 24) & 0x000000FFL) |
                        (((x) >>  8) & 0x0000FF00L) |
                        (((x) <<  8) & 0x00FF0000L) |
                        (((x) << 24) & 0xFF000000L));
}

#define ntohs(x)        htons(x)
#define ntohl(x)        htonl(x)


typedef struct
{
    USHORT          NLA_AFI;
    USHORT          Reserved;
    ULONG           IpAddress;
}   NLA;

typedef struct _PGM_COMMON_HDR {
    USHORT SrcPort;
    USHORT DestPort;

    UCHAR Type;
    UCHAR Options;
    USHORT Checksum;

    UCHAR gSourceId[SOURCE_ID_LENGTH];
    USHORT TSDULength;
} PGM_COMMON_HDR, *PPGM_COMMON_HDR;

typedef struct
{
    PGM_COMMON_HDR      CommonHeader;

    ULONG               SpmSequenceNumber;          // SPM_SQN
    ULONG               TrailingEdgeSeqNumber;      // SPM_TRAIL == TXW_TRAIL
    ULONG               LeadingEdgeSeqNumber;       // SPM_LEAD == TXW_LEAD

    NLA                 PathNLA;
}   SPM_PACKET_HEADER;

typedef struct
{
    PGM_COMMON_HDR      CommonHeader;

    ULONG               DataSequenceNumber;
    ULONG               TrailingEdgeSequenceNumber;
}   DATA_PACKET_HEADER;

typedef struct
{
    PGM_COMMON_HDR                  CommonHeader;

    ULONG                           RequestedSequenceNumber;
    NLA                             SourceNLA;
    NLA                             MCastGroupNLA;
}   NAK_NCF_PACKET_HEADER;

typedef struct
{
    UCHAR       Type;
    UCHAR       Length;
    USHORT      TotalOptionsLength;
} tPACKET_OPTION_LENGTH;

//
// Generic Packet Option Format
//
typedef struct
{
    UCHAR       OptionType;
    UCHAR       Length;
    UCHAR       ReservedOPX;
    UCHAR       OptionSpecific;
} tPACKET_OPTION_GENERIC;

#if 0   // Original values
#define PACKET_HEADER_OPTIONS_PRESENT               0x80    // bit 0
#define PACKET_HEADER_OPTIONS_NETWORK_SIGNIFICANT   0x40    // bit 1
#define PACKET_HEADER_OPTIONS_VAR_PKTLEN            0x02    // bit 6
#define PACKET_HEADER_OPTIONS_PARITY                0x01    // bit 7
#endif  // 0

#define PACKET_HEADER_OPTIONS_PRESENT               0x01    // bit 7
#define PACKET_HEADER_OPTIONS_NETWORK_SIGNIFICANT   0x02    // bit 6
#define PACKET_HEADER_OPTIONS_VAR_PKTLEN            0x40    // bit 1
#define PACKET_HEADER_OPTIONS_PARITY                0x80    // bit 0

#define PACKET_TYPE_SPM     0x00
#define PACKET_TYPE_POLL    0x01
#define PACKET_TYPE_POLR    0x02
#define PACKET_TYPE_ODATA   0x04
#define PACKET_TYPE_RDATA   0x05
#define PACKET_TYPE_NAK     0x08
#define PACKET_TYPE_NNAK    0x09
#define PACKET_TYPE_NCF     0x0A
#define PACKET_TYPE_SPMR    0x0C

#define PACKET_OPTION_LENGTH        0x00

#define PACKET_OPTION_FRAGMENT      0x01
#define PACKET_OPTION_NAK_LIST      0x02
#define PACKET_OPTION_JOIN          0x03
#define PACKET_OPTION_REDIRECT      0x07
#define PACKET_OPTION_SYN           0x0D
#define PACKET_OPTION_FIN           0x0E
#define PACKET_OPTION_RST           0x0F

#define PACKET_OPTION_PARITY_PRM    0x08
#define PACKET_OPTION_PARITY_GRP    0x09
#define PACKET_OPTION_CURR_TGSIZE   0x0A
#define PACKET_OPTION_CR            0x10
#define PACKET_OPTION_CRQST         0x11
#define PACKET_OPTION_NAK_BO_IVL    0x04
#define PACKET_OPTION_NAK_BO_RNG    0x05
#define PACKET_OPTION_NBR_UNREACH   0x0B
#define PACKET_OPTION_PATH_NLA      0x0C
#define PACKET_OPTION_INVALID       0x7F

#define PACKET_OPTION_TYPE_END_BIT          0x80

#define MAX_SEQUENCES_PER_NAK_OPTION    62
#define PGM_PACKET_OPT_MIN_NAK_LIST_LENGTH    (4 + 4)
#define PGM_PACKET_OPT_MAX_NAK_LIST_LENGTH    (4 + 4*MAX_SEQUENCES_PER_NAK_OPTION)


#define PGM_PACKET_EXTENSION_LENGTH             4
#define PGM_PACKET_OPT_FRAGMENT_LENGTH         16
#define PGM_PACKET_OPT_MIN_NAK_LIST_LENGTH    (4 + 4)
#define PGM_PACKET_OPT_MAX_NAK_LIST_LENGTH    (4 + 4*MAX_SEQUENCES_PER_NAK_OPTION)
#define PGM_PACKET_OPT_JOIN_LENGTH              8
#define PGM_PACKET_OPT_SYN_LENGTH               4
#define PGM_PACKET_OPT_FIN_LENGTH               4
#define PGM_PACKET_OPT_RST_LENGTH               4

#define PGM_PACKET_OPT_PARITY_PRM_LENGTH        8
#define PGM_PACKET_OPT_PARITY_GRP_LENGTH        8
#define PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH 8
#define PGM_PACKET_OPT_PARITY_FRAGMENT_LENGTH   8

#endif // _PGM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\dll\wshrm.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wshrm.c

Abstract:

    This module contains necessary routines for the Pragmatic General Multicast
    (PGM) Windows Sockets Helper DLL.  This DLL provides the transport-specific
    support necessary for the Windows Sockets DLL to use the PGM Transport.

    This file is largely a clone of the TCP/IP helper code.

Author:

    Mohammad Shabbir Alam (MAlam)    30-March-2000

Revision History:

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>

#include <stdio.h>
#include <tdi.h>

#include <winsock2.h>
#include <wsahelp.h>

#include <nspapi.h>
#include <nspapip.h>

#include <wsRm.h>
#include <rmcommon.h>


// #define TRACE_ON    1

#if defined(DBG) && defined(TRACE_ON)
#define PgmLog      DbgPrint
#define PgmError    DbgPrint

#else

#if defined(DBG)
#define PgmError    DbgPrint
#else
#define PgmError    
#endif  // DBG

#define PgmLog    
#endif  // DBG && TRACE_ON


//----------------------------------------------------------------------------
//
// Structure and variables to define the triples supported by the
// Pgm Transport. The first entry of each array is considered
// the canonical triple for that socket type; the other entries are
// synonyms for the first.
//

typedef struct _MAPPING_TRIPLE {
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;

MAPPING_TRIPLE PgmMappingTriples[] = { AF_INET,   SOCK_RDM,       IPPROTO_RM,
                                       AF_INET,   SOCK_STREAM,    IPPROTO_RM };


//
// Define valid flags for WSHOpenSocket2().
//
#define VALID_PGM_FLAGS         (WSA_FLAG_OVERLAPPED        |   \
                                 WSA_FLAG_MULTIPOINT_C_LEAF |   \
                                 WSA_FLAG_MULTIPOINT_D_LEAF)

#define DD_PGM_DEVICE_NAME      L"\\Device\\Pgm"

#define PGM_NAME L"WSHRM"

#define DEFAULT_RECEIVE_BUFFER_SIZE 8192
#define DEFAULT_MULTICAST_TTL       1
#define DEFAULT_MULTICAST_INTERFACE INADDR_ANY
#define DEFAULT_MULTICAST_LOOPBACK  TRUE

#define WINSOCK_SPI_VERSION         2
#define PGM_MESSAGE_SIZE            (((ULONG)-1) / 2)

#define IS_DGRAM_SOCK(type)  (((type) == SOCK_DGRAM) || ((type) == SOCK_RAW))

//
// The GUID identifying this provider.
//
GUID PgmProviderGuid = { /* c845f828-500f-4e1e-87c2-5dfca19b5348 */
    0xc845f828,
    0x500f,
    0x4e1e,
    {0x87, 0xc2, 0x5d, 0xfc, 0xa1, 0x9b, 0x53, 0x48}
  };


/* ****
    XP1_CONNECTIONLESS      ==> Sock type can only be:  SOCK_DGRAM
                                                        SOCK_RAW

    XP1_MESSAGE_ORIENTED    ==> Sock type can only be:  SOCK_DGRAM
                                                        SOCK_RAW
                                                        SOCK_RDM
                                                        SOCK_SEQPACKET
                                 XP1_PSEUDO_STREAM <==> SOCK_STREAM
**** */

WSAPROTOCOL_INFOW Winsock2Protocols[] =
    {
        //
        // PGM RDM  (SOCK_RDM cannot be CONNECTIONLESS)
        //
        {
            PGM_RDM_SERVICE_FLAGS,                  // dwServiceFlags1
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO,              // dwProviderFlags
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET,                                // iAddressFamily
            sizeof(SOCKADDR_IN),                    // iMaxSockAddr
            sizeof(SOCKADDR_IN),                    // iMinSockAddr
            SOCK_RDM,                               // iSocketType
            IPPROTO_RM,                             // iProtocol
            0,                                      // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            PGM_MESSAGE_SIZE,                       // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Pgm (RDM)"                      // szProtocol
        },

        //
        // PGM Stream
        //
        {
            PGM_STREAM_SERVICE_FLAGS,               // dwServiceFlags1
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO,              // dwProviderFlags
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET,                                // iAddressFamily
            sizeof(SOCKADDR_IN),                    // iMaxSockAddr
            sizeof(SOCKADDR_IN),                    // iMinSockAddr
            SOCK_STREAM,                            // iSocketType
            IPPROTO_RM,                             // iProtocol
            0,                                      // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            0,                                      // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Pgm (Stream)"                   // szProtocol
        },
    };

#define NUM_WINSOCK2_PROTOCOLS  \
            (sizeof(Winsock2Protocols) / sizeof(Winsock2Protocols[0]))

//
// The socket context structure for this DLL.  Each open TCP/IP socket
// will have one of these context structures, which is used to maintain
// information about the socket.
//

typedef struct _WSHPGM_SOCKET_CONTEXT {
    INT         AddressFamily;
    INT         SocketType;
    INT         Protocol;
    INT         ReceiveBufferSize;
    DWORD       Flags;
    INT         MulticastTtl;
    tIPADDRESS  MulticastOutInterface;
    tIPADDRESS  MulticastInInterface;
    tIPADDRESS  MultipointTarget;
    USHORT      MultipointPort;
    BOOLEAN     MulticastLoopback;
    BOOLEAN     MultipointLeaf;
} WSHPGM_SOCKET_CONTEXT, *PWSHPGM_SOCKET_CONTEXT;

//----------------------------------------------------------------------------
//
// Forward declarations of internal routines.
//

BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    );

#if(WINVER <= 0x0500)
ULONG
MyInetAddr(
    IN LPWSTR String,
    OUT LPWSTR * Terminator
    );
#endif  // WINVER

INT
SetTdiInformation (
    IN HANDLE   TdiConnectionObjectHandle,
    IN ULONG    Ioctl,
    IN PVOID    InputBuffer,
    IN ULONG    InputBufferLength,
    IN PVOID    OutputBuffer,
    IN ULONG    OutputBufferLength,
    IN BOOLEAN  WaitForCompletion
    );

//----------------------------------------------------------------------------

BOOLEAN
DllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL
    )
{

    PgmLog ("WSHPgm.DllInitialize:  Reason=<%x> ...\n", Reason);

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:

        //
        // We don't need to receive thread attach and detach
        // notifications, so disable them to help application
        // performance.
        //

        DisableThreadLibraryCalls( DllHandle );

        return TRUE;

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;

} // DllInitialize


//----------------------------------------------------------------------------

INT
WSHOpenSocket(
    IN OUT  PINT            AddressFamily,
    IN OUT  PINT            SocketType,
    IN OUT  PINT            Protocol,
    OUT     PUNICODE_STRING TransportDeviceName,
    OUT     PVOID           *HelperDllSocketContext,
    OUT     PDWORD          NotificationEvents
    )
{
    INT     RetVal;

    RetVal = WSHOpenSocket2 (AddressFamily,
                             SocketType,
                             Protocol,
                             0,           // Group
                             0,           // Flags
                             TransportDeviceName,
                             HelperDllSocketContext,
                             NotificationEvents);

    return (RetVal);
} // WSHOpenSocket


INT
WSHOpenSocket2(
    IN OUT  PINT            AddressFamily,
    IN OUT  PINT            SocketType,
    IN OUT  PINT            Protocol,
    IN      GROUP           Group,
    IN      DWORD           Flags,
    OUT     PUNICODE_STRING TransportDeviceName,
    OUT     PVOID           *HelperDllSocketContext,
    OUT     PDWORD          NotificationEvents
    )

/*++

Routine Description:

    Does the necessary work for this helper DLL to open a socket and is
    called by the winsock DLL in the socket() routine.  This routine
    verifies that the specified triple is valid, determines the NT
    device name of the TDI provider that will support that triple,
    allocates space to hold the socket's context block, and
    canonicalizes the triple.

Arguments:

    AddressFamily - on input, the address family specified in the
        socket() call.  On output, the canonicalized value for the
        address family.

    SocketType - on input, the socket type specified in the socket()
        call.  On output, the canonicalized value for the socket type.

    Protocol - on input, the protocol specified in the socket() call.
        On output, the canonicalized value for the protocol.

    Group - Identifies the group for the new socket.

    Flags - Zero or more WSA_FLAG_* flags as passed into WSASocket().

    TransportDeviceName - receives the name of the TDI provider that
        will support the specified triple.

    HelperDllSocketContext - receives a context pointer that the winsock
        DLL will return to this helper DLL on future calls involving
        this socket.

    NotificationEvents - receives a bitmask of those state transitions
        this helper DLL should be notified on.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHPGM_SOCKET_CONTEXT context;

    if (IsTripleInList (PgmMappingTriples,
                        sizeof(PgmMappingTriples) / sizeof(PgmMappingTriples[0]),
                        *AddressFamily,
                        *SocketType,
                        *Protocol))
    {
        //
        // It's an Rdm PGM socket. Check the flags.
        //
        if ((Flags & ~VALID_PGM_FLAGS) != 0)
        {
            PgmError ("\tWSHPgm.WSHOpenSocket2:  ERROR: Flags=<%x> & VALID_PGM_FLAGS=<%x>\n",
                Flags, (ULONG)~VALID_PGM_FLAGS);
            return WSAEINVAL;
        }

        //
        // Return the canonical form of a CDP socket triple.
        //
        *AddressFamily = PgmMappingTriples[0].AddressFamily;
        *SocketType = PgmMappingTriples[0].SocketType;
        *Protocol = PgmMappingTriples[0].Protocol;

        //
        // Indicate the name of the TDI device that will service
        // SOCK_RDM sockets for PGM.
        //
        RtlInitUnicodeString (TransportDeviceName, DD_PGM_DEVICE_NAME);
    }
    else
    {
        //
        // This should never happen if the registry information about this
        // helper DLL is correct.  If somehow this did happen, just return
        // an error.
        //
        PgmError ("\tWSHPgm.WSHOpenSocket2: Invalid Triple AddrFamily=<%d>, SockType=<%d>, Protocol=<%d>!\n",
            *AddressFamily, *SocketType, *Protocol);

        return WSAEINVAL;
    }

    //
    // Allocate context for this socket.  The Windows Sockets DLL will
    // return this value to us when it asks us to get/set socket options.
    //
    context = RtlAllocateHeap (RtlProcessHeap( ), 0, sizeof(*context));
    if (context == NULL)
    {
        PgmError ("WSHPgm.WSHOpenSocket2:  WSAENOBUFS -- <%d> bytes\n", sizeof(*context));
        return WSAENOBUFS;
    }
    RtlZeroMemory (context, sizeof(*context));

    //
    // Initialize the context for the socket.
    //
    context->AddressFamily = *AddressFamily;
    context->SocketType = *SocketType;
    context->Protocol = *Protocol;
    context->ReceiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;
    context->Flags = Flags;

    context->MulticastTtl = DEFAULT_MULTICAST_TTL;
    context->MulticastOutInterface = DEFAULT_MULTICAST_INTERFACE;
    context->MulticastInInterface = DEFAULT_MULTICAST_INTERFACE;
    context->MulticastLoopback = DEFAULT_MULTICAST_LOOPBACK;
    context->MultipointLeaf = FALSE;

    //
    // Tell the Windows Sockets DLL which state transitions we're
    // interested in being notified of.  The only times we need to be
    // called is after a connect has completed so that we can turn on
    // the sending of keepalives if SO_KEEPALIVE was set before the
    // socket was connected, when the socket is closed so that we can
    // free context information, and when a connect fails so that we
    // can, if appropriate, dial in to the network that will support the
    // connect attempt.
    //
    if (*SocketType == SOCK_RDM)
    {
        *NotificationEvents = WSH_NOTIFY_LISTEN | WSH_NOTIFY_CONNECT | WSH_NOTIFY_CLOSE
                             | WSH_NOTIFY_CONNECT_ERROR | WSH_NOTIFY_BIND;
    }
    else    // *SocketType == SOCK_STREAM
    {
        *NotificationEvents = WSH_NOTIFY_LISTEN | WSH_NOTIFY_CONNECT | WSH_NOTIFY_CLOSE
                             | WSH_NOTIFY_CONNECT_ERROR;
    }

    PgmLog ("WSHPgm.WSHOpenSocket2:  Succeeded -- %s\n",
        (*SocketType == SOCK_RDM ? "SOCK_RDM" : "SOCK_STREAM"));

    //
    // Everything worked, return success.
    //
    *HelperDllSocketContext = context;
    return NO_ERROR;
} // WSHOpenSocket2


//----------------------------------------------------------------------------

INT
WSHNotify (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    )

/*++

Routine Description:

    This routine is called by the winsock DLL after a state transition
    of the socket.  Only state transitions returned in the
    NotificationEvents parameter of WSHOpenSocket() are notified here.
    This routine allows a winsock helper DLL to track the state of
    socket and perform necessary actions corresponding to state
    transitions.

Arguments:

    HelperDllSocketContext - the context pointer given to the winsock
        DLL by WSHOpenSocket().

    SocketHandle - the handle for the socket.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    NotifyEvent - indicates the state transition for which we're being
        called.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHPGM_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT err;

    //
    // We should only be called after a connect() completes or when the
    // socket is being closed.
    //
    if (NotifyEvent == WSH_NOTIFY_BIND)
    {
        //
        // Set options for Address handle
        //
        PgmLog ("WSHPgm.WSHNotify[WSH_NOTIFY_BIND]:  ...\n");
        if (!context->MultipointLeaf)
        {
            tPGM_MCAST_REQUEST      MCastRequest;

            PgmLog ("WSH_NOTIFY_BIND:  Address=<%x>, Connection=<%x>, OutIf=<%x>, InIf=<%x>\n",
                TdiAddressObjectHandle, TdiConnectionObjectHandle, context->MulticastOutInterface,
                context->MulticastInInterface);

            if (context->MulticastOutInterface)
            {
                MCastRequest.MCastOutIf = context->MulticastOutInterface;

                err = SetTdiInformation (TdiAddressObjectHandle,
                                         IOCTL_PGM_WSH_SET_SEND_IF,
                                         &MCastRequest,
                                         sizeof (MCastRequest),
                                         NULL,
                                         0,
                                         TRUE);
                if (err != NO_ERROR)
                {
                    PgmError ("WSHPgm.WSHNotify: Error=<%x> setting MCastIf on Bind\n", err);
                    return err;
                }
            }

            if (context->MulticastInInterface)
            {
                MCastRequest.MCastInfo.MCastInIf = context->MulticastInInterface;

                err = SetTdiInformation (TdiAddressObjectHandle,
                                         IOCTL_PGM_WSH_ADD_RECEIVE_IF,
                                         &MCastRequest,
                                         sizeof (MCastRequest),
                                         NULL,
                                         0,
                                         TRUE);
                if (err != NO_ERROR)
                {
                    PgmError ("WSHPgm.WSHNotify: Error=<%x> setting MCastIf on Bind\n", err);
                    return err;
                }
            }

            context->MultipointLeaf = TRUE;
        }
    }
    else if (NotifyEvent == WSH_NOTIFY_CONNECT)
    {
        //
        // If a connection-object option was set on the socket before
        // it was connected, set the option for real now.
        //
        PgmLog ("WSHPgm.WSHNotify[WSH_NOTIFY_CONNECT]:  ...\n");
    }
    else if (NotifyEvent == WSH_NOTIFY_CONNECT_ERROR)
    {
        //
        // Return WSATRY_AGAIN to get wsock32 to attempt the connect
        // again.  Any other return code is ignored.
        //
        PgmLog ("WSHPgm.WSHNotify[WSH_NOTIFY_CONNECT_ERROR]:  ...\n");
    }
    else if (NotifyEvent == WSH_NOTIFY_LISTEN)
    {
        //
        // If a connection-object option was set on the socket before
        // it was connected, set the option for real now.
        //
        PgmLog ("WSHPgm.WSHNotify[WSH_NOTIFY_LISTEN]:  ...\n");
    }
    else if (NotifyEvent == WSH_NOTIFY_CLOSE)
    {
        //
        // Free the socket context.
        //
        PgmLog ("WSHPgm.WSHNotify[WSH_NOTIFY_CONNECT_CLOSE]:  ...\n");
        RtlFreeHeap (RtlProcessHeap( ), 0, context);
    }
    else
    {
        PgmError ("WSHPgm.WSHNotify:  Unknown Event: <%x>  ...\n", NotifyEvent);
        return WSAEINVAL;
    }

    return NO_ERROR;

} // WSHNotify


//----------------------------------------------------------------------------

INT
WSHSetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    )

/*++

Routine Description:

    This routine sets information about a socket for those socket
    options supported in this helper DLL.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to setsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to setsockopt().

    OptionName - the optname parameter passed to setsockopt().

    OptionValue - the optval parameter passed to setsockopt().

    OptionLength - the optlen parameter passed to setsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHPGM_SOCKET_CONTEXT      context = HelperDllSocketContext;
    PWSHPGM_SOCKET_CONTEXT      ParentContext = (PWSHPGM_SOCKET_CONTEXT) OptionValue;
    tPGM_MCAST_REQUEST          MCastRequest;
    INT                         error;
    INT                         optionValue;
    RM_SEND_WINDOW UNALIGNED    *pSetWindowInfo;
    RM_FEC_INFO                 *pFECInfo;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if (Level == SOL_INTERNAL && OptionName == SO_CONTEXT)
    {
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //
        if (OptionLength < sizeof(*context))
        {
            PgmError ("WSHPgm.WSHSetSocketInformation:  WSAEINVAL -- <%d> < <%d>\n",
                OptionLength, sizeof(*context));

            return WSAEINVAL;
        }

        if (HelperDllSocketContext == NULL)
        {
            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //
            context = RtlAllocateHeap (RtlProcessHeap( ), 0, sizeof(*context));
            if (context == NULL)
            {
                PgmError ("WSHPgm.WSHSetSocketInformation:  WSAENOBUFS -- <%d> bytes\n", sizeof(*context));
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //
            RtlCopyMemory (context, OptionValue, sizeof(*context) );

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //
            *(PWSHPGM_SOCKET_CONTEXT *)OptionValue = context;

            PgmLog ("WSHPgm.WSHSetSocketInformation[SOL_INTERNAL:SO_CONTEXT]  Inherited socket handle\n");

            return NO_ERROR;
        }

        //
        // The socket was accept()'ed and it needs to have the same
        // properties as it's parent.  The OptionValue buffer
        // contains the context information of this socket's parent.
        //

        ParentContext = (PWSHPGM_SOCKET_CONTEXT)OptionValue;

        ASSERT( context->AddressFamily == ParentContext->AddressFamily );
        ASSERT( context->SocketType == ParentContext->SocketType );
        ASSERT( context->Protocol == ParentContext->Protocol );

        //
        // Record this fact in the leaf socket so we can drop membership
        // when the leaf socket is closed.
        //
        context->MultipointLeaf = ParentContext->MultipointLeaf;
        context->MultipointTarget = ParentContext->MultipointTarget;
        context->MultipointPort = ParentContext->MultipointPort;
        context->MulticastOutInterface = ParentContext->MulticastOutInterface;
        context->MulticastInInterface = ParentContext->MulticastInInterface;

        PgmLog ("WSHPgm.WSHSetSocketInformation[SOL_INTERNAL:SO_CONTEXT]  Accepted socket handle\n");
        return NO_ERROR;
    }

    //
    // The only other levels we support here are SOL_SOCKET and IPPROTO_RM
    //

    if (Level != SOL_SOCKET &&
        Level != IPPROTO_RM)
    {
        PgmError ("WSHPgm.WSHSetSocketInformation: Unsupported Level=<%d>\n", Level);
        return WSAEINVAL;
    }

    //
    // Make sure that the option length is sufficient.
    //
    if (OptionLength < sizeof(char))
    {
        PgmError ("WSHPgm.WSHSetSocketInformation: OptionLength=<%d> < <%d>\n", OptionLength, sizeof(char));
        return WSAEFAULT;
    }

    if (OptionLength >= sizeof (int))
    {
        optionValue = *((INT UNALIGNED *)OptionValue);
    }
    else
    {
        optionValue = (UCHAR)*OptionValue;
    }

    if (Level == IPPROTO_RM)
    {
        //
        // Act based on the specific option.
        //
        switch (OptionName)
        {
            case RM_RATE_WINDOW_SIZE:
            {
                if ((!TdiAddressObjectHandle) ||
                    (OptionLength < sizeof(RM_SEND_WINDOW)))
                {
                    return WSAEINVAL;
                }

                pSetWindowInfo = (RM_SEND_WINDOW UNALIGNED *) OptionValue;

                MCastRequest.TransmitWindowInfo.RateKbitsPerSec = pSetWindowInfo->RateKbitsPerSec;
                MCastRequest.TransmitWindowInfo.WindowSizeInMSecs = pSetWindowInfo->WindowSizeInMSecs;
                MCastRequest.TransmitWindowInfo.WindowSizeInBytes = pSetWindowInfo->WindowSizeInBytes;

                error = SetTdiInformation (TdiAddressObjectHandle,
                                           IOCTL_PGM_WSH_SET_WINDOW_SIZE_RATE,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           NULL,
                                           0,
                                           TRUE);
                if (error != NO_ERROR)
                {
                    PgmError ("WSHPgm.WSHSetSocketInformation:  ERROR=<%d> setting Window Rate Size=<%x>\n",
                        error, optionValue);
                    return error;
                }

                PgmLog ("WSHSetSocketInformation[RATE_WINDOW_SIZE]:  Set Window Rate Size\n");

                return (NO_ERROR);
            }

            case RM_SEND_WINDOW_ADV_RATE:
            {
                if (!TdiAddressObjectHandle)
                {
                    return WSAEINVAL;
                }

                MCastRequest.WindowAdvancePercentage = (ULONG) optionValue;

                error = SetTdiInformation (TdiAddressObjectHandle,
                                           IOCTL_PGM_WSH_SET_ADVANCE_WINDOW_RATE,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           NULL,
                                           0,
                                           TRUE);
                if (error != NO_ERROR)
                {
                    PgmError ("WSHPgm.WSHSetSocketInformation:  ERROR=<%d> setting Window Adv. Rate=<%x>\n",
                        error, optionValue);
                    return error;
                }

                PgmLog ("WSHSetSocketInformation[SEND_WINDOW_ADV_RATE]:  Set Window Adv. Rate\n");

                return (NO_ERROR);
            }

            case RM_LATEJOIN:
            {
                if (!TdiAddressObjectHandle)
                {
                    return WSAEINVAL;
                }

                MCastRequest.LateJoinerPercentage = (ULONG) optionValue;

                error = SetTdiInformation (TdiAddressObjectHandle,
                                           IOCTL_PGM_WSH_SET_LATE_JOINER_PERCENTAGE,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           NULL,
                                           0,
                                           TRUE);
                if (error != NO_ERROR)
                {
                    PgmError ("WSHPgm.WSHSetSocketInformation:  ERROR=<%d> setting LATEJOIN=<%x>\n",
                        error, optionValue);

                    return error;
                }

                PgmLog ("WSHSetSocketInformation[LATEJOIN]:  <%d %%>\n", MCastRequest.LateJoinerPercentage);

                return (NO_ERROR);
            }

            case RM_SET_MESSAGE_BOUNDARY:
            {
                if (!TdiConnectionObjectHandle)
                {
                    return WSAEINVAL;
                }

                MCastRequest.NextMessageBoundary = (ULONG) optionValue;

                error = SetTdiInformation (TdiConnectionObjectHandle,
                                           IOCTL_PGM_WSH_SET_NEXT_MESSAGE_BOUNDARY,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           NULL,
                                           0,
                                           TRUE);
                if (error != NO_ERROR)
                {
                    PgmError ("WSHPgm.WSHSetSocketInformation:  ERROR=<%d> setting NextMessageBoundary=<%x>\n",
                        error, optionValue);
                    return error;
                }

                PgmLog ("WSHSetSocketInformation[MESSAGE_BOUNDARY]:  Set next message boundary = <%d>\n",
                    MCastRequest.NextMessageBoundary);

                return (NO_ERROR);
            }

            case RM_SET_SEND_IF:
            {
                //
                // If we have a TDI address object, set this option to
                // the address object.  If we don't have a TDI address
                // object then we'll have to wait until after the socket
                // is bound.
                //
                PgmLog ("WSHSetSocketInformation[SEND_IF]:  Address=<%x>, Connection=<%x>, OutIf=<%x>\n",
                    TdiAddressObjectHandle, TdiConnectionObjectHandle, optionValue);

                if (TdiAddressObjectHandle != NULL)
                {

                    MCastRequest.MCastOutIf = * ((tIPADDRESS *) &optionValue);
                    error = SetTdiInformation (TdiAddressObjectHandle,
                                               IOCTL_PGM_WSH_SET_SEND_IF,
                                               &MCastRequest,
                                               sizeof (MCastRequest),
                                               NULL,
                                               0,
                                               TRUE);
                    if (error != NO_ERROR)
                    {
                        PgmError ("WSHPgm.WSHSetSocketInformation:  ERROR=<%d> setting MCastOutIf=<%x>\n",
                            error, optionValue);
                        return error;
                    }

                    PgmLog ("WSHPgm.WSHSetSocketInformation[SEND_IF]:  Set MCastIf=<%x>\n",optionValue);

                    context->MulticastOutInterface = optionValue;
                }
                else
                {
                    //
                    // Save the Interface for now!
                    //
                    context->MulticastOutInterface = optionValue;
                    PgmError ("WSHPgm.WSHSetSocketInformation[SET_SEND_IF]: WARNING -- NULL Address!\n");
                }

                return (NO_ERROR);
            }

            case RM_ADD_RECEIVE_IF:
            {
                PgmLog ("WSHSetSocketInformation[ADD_RECEIVE_IF]: Address=<%x>, Connection=<%x>, If=<%x>\n",
                    TdiAddressObjectHandle, TdiConnectionObjectHandle, optionValue);

                //
                // If we have a TDI address object, set this option to
                // the address object.  If we don't have a TDI address
                // object then we'll have to wait until after the socket
                // is bound.
                //
                if (TdiAddressObjectHandle != NULL)
                {
                    MCastRequest.MCastInfo.MCastInIf = * ((tIPADDRESS *) &optionValue);
                    error = SetTdiInformation (TdiAddressObjectHandle,
                                               IOCTL_PGM_WSH_ADD_RECEIVE_IF,
                                               &MCastRequest,
                                               sizeof (MCastRequest),
                                               NULL,
                                               0,
                                               TRUE);
                    if (error != NO_ERROR)
                    {
                        PgmError ("WSHPgm.WSHSetSocketInformation:  ERROR=<%d> adding MCastInIf=<%x>\n",
                            error, optionValue);
                        return error;
                    }

                    PgmLog ("WSHSetSocketInformation[ADD_RECEIVE_IF]: Set MCastIf=<%x>\n",optionValue);

                    context->MulticastInInterface = optionValue;
                }
                else
                {
                    //
                    // Save the Interface for now!
                    //
                    context->MulticastInInterface = optionValue;
                    PgmError ("WSHPgm.WSHSetSocketInformation[ADD_RECEIVE_IF]: WARNING-- NULL Address!\n");
                }

                return (NO_ERROR);
            }

            case RM_DEL_RECEIVE_IF:
            {
                PgmLog ("WSHSetSocketInformation[DEL_RECEIVE_IF]: Address=<%x>, Connection=<%x>, InIf=<%x>\n",
                    TdiAddressObjectHandle, TdiConnectionObjectHandle, optionValue);

                //
                // If we have a TDI address object, set this option to
                // the address object.  If we don't have a TDI address
                // object then we'll have to wait until after the socket
                // is bound.
                //
                if (TdiAddressObjectHandle != NULL)
                {
                    MCastRequest.MCastInfo.MCastInIf = * ((tIPADDRESS *) &optionValue);
                    error = SetTdiInformation (TdiAddressObjectHandle,
                                               IOCTL_PGM_WSH_DEL_RECEIVE_IF,
                                               &MCastRequest,
                                               sizeof (MCastRequest),
                                               NULL,
                                               0,
                                               TRUE);
                    if (error != NO_ERROR)
                    {
                        PgmError ("WSHPgm.WSHSetSocketInformation:  ERROR=<%d> deleting MCastInIf=<%x>\n",
                            error, optionValue);
                        return error;
                    }

                    PgmLog ("WSHSetSocketInformation[DEL_RECEIVE_IF]: Set MCastIf=<%x>\n",optionValue);

                    context->MulticastInInterface = optionValue;
                }
                else
                {
                    if (context->MulticastInInterface == (tIPADDRESS) optionValue)
                    {
                        context->MulticastInInterface = 0;
                    }
                    PgmError ("WSHPgm.WSHSetSocketInformation[DEL_RECEIVE_IF]: WARNING-- NULL Address!\n");
                }

                return (NO_ERROR);
            }

            case RM_USE_FEC:
            {
                if ((!TdiAddressObjectHandle) ||
                    (OptionLength < sizeof(RM_FEC_INFO)))
                {
                    return WSAEINVAL;
                }

                pFECInfo = (RM_FEC_INFO *) OptionValue;

                MCastRequest.FECInfo.FECBlockSize               = pFECInfo->FECBlockSize;
                MCastRequest.FECInfo.FECProActivePackets        = pFECInfo->FECProActivePackets;
                MCastRequest.FECInfo.FECGroupSize               = pFECInfo->FECGroupSize;
                MCastRequest.FECInfo.fFECOnDemandParityEnabled  = pFECInfo->fFECOnDemandParityEnabled;

                error = SetTdiInformation (TdiAddressObjectHandle,
                                           IOCTL_PGM_WSH_USE_FEC,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           NULL,
                                           0,
                                           TRUE);
                if (error != NO_ERROR)
                {
                    PgmError ("WSHPgm.WSHSetSocketInformation:  ERROR=<%d> setting FEC = <%x>\n",
                        error, optionValue);
                    return error;
                }

                PgmLog ("WSHSetSocketInformation[RATE_WINDOW_SIZE]:  Set FEC Info\n");

                return (NO_ERROR);
            }

            case RM_SET_MCAST_TTL:
            {
                if (!TdiAddressObjectHandle)
                {
                    return WSAEINVAL;
                }

                MCastRequest.MCastTtl = (ULONG) optionValue;

                error = SetTdiInformation (TdiAddressObjectHandle,
                                           IOCTL_PGM_WSH_SET_MCAST_TTL,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           NULL,
                                           0,
                                           TRUE);
                if (error != NO_ERROR)
                {
                    PgmError ("WSHPgm.WSHSetSocketInformation:  ERROR=<%d> setting MCastTtl=<%x>\n",
                        error, optionValue);
                    return error;
                }

                PgmLog ("WSHSetSocketInformation[MESSAGE_BOUNDARY]:  Set MCastTtl = <%d>\n",
                    MCastRequest.MCastTtl);

                return (NO_ERROR);
            }

            case RM_SENDER_WINDOW_ADVANCE_METHOD:
            {
                if (!TdiAddressObjectHandle)
                {
                    return WSAEINVAL;
                }

                MCastRequest.WindowAdvanceMethod = (ULONG) optionValue;

                error = SetTdiInformation (TdiAddressObjectHandle,
                                           IOCTL_PGM_WSH_SET_WINDOW_ADVANCE_METHOD,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           NULL,
                                           0,
                                           TRUE);
                if (error != NO_ERROR)
                {
                    PgmError ("WSHPgm.WSHSetSocketInformation:  ERROR=<%d> setting WindowAdvanceMethod=<%x>\n",
                        error, optionValue);
                    return error;
                }

                PgmLog ("WSHSetSocketInformation[WINDOW_ADVANCE_METHOD]:  Set WindowAdvanceMethod = <%d>\n",
                    MCastRequest.WindowAdvanceMethod);

                return (NO_ERROR);
            }

            case RM_HIGH_SPEED_INTRANET_OPT:
            {
                if (!TdiAddressObjectHandle)
                {
                    return WSAEINVAL;
                }

                MCastRequest.HighSpeedIntranetOptimization = (ULONG) optionValue;

                error = SetTdiInformation (TdiAddressObjectHandle,
                                           IOCTL_PGM_WSH_SET_HIGH_SPEED_INTRANET_OPT,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           NULL,
                                           0,
                                           TRUE);
                if (error != NO_ERROR)
                {
                    PgmError ("WSHPgm.WSHSetSocketInformation:  ERROR=<%d> setting HighSpeedOptimization=<%x>\n",
                        error, optionValue);
                    return error;
                }

                PgmLog ("WSHSetSocketInformation[WINDOW_ADVANCE_METHOD]:  Set HighSpeedOptimization=<%d>\n",
                    MCastRequest.HighSpeedIntranetOptimization);

                return (NO_ERROR);
            }

            default:
            {
                PgmError ("WSHPgm.WSHSetSocketInformation[IPPROTO_RM]: Unsupported option=<%d>\n",OptionName);
                error = WSAENOPROTOOPT;
                break;
            }
        }
    }
    else
    {
        //
        // Handle socket-level options.
        //
        switch (OptionName)
        {
            case SO_RCVBUF:
            {
                //
                // If the receive buffer size is being changed, tell PGM about
                // it.  Do nothing if this is a datagram.
                //
                if (context->ReceiveBufferSize == optionValue ||
                    IS_DGRAM_SOCK(context->SocketType))
                {
                    error = NO_ERROR;
                    break;
                }

                PgmLog ("WSHSetSocketInformation[SO_RCVBUF]: Address=<%x>, Connection=<%x>, BuffLen=<%x>\n",
                    TdiAddressObjectHandle, TdiConnectionObjectHandle, optionValue);

                if ((!TdiConnectionObjectHandle) ||
                    (OptionLength > sizeof (int)))
                {
                    return WSAEINVAL;
                }

                MCastRequest.RcvBufferLength = optionValue;
                error = SetTdiInformation (TdiConnectionObjectHandle,
                                           IOCTL_PGM_WSH_SET_RCV_BUFF_LEN,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           NULL,
                                           0,
                                           TRUE);
                if (error != NO_ERROR)
                {
                    PgmError ("WSHPgm.WSHSetSocketInformation:  ERROR=<%d> setting SO_RCVBUF=<%x>\n",
                        error, optionValue);
                    return error;
                }

                PgmLog ("WSHSetSocketInformation[SOL_SOCKET]:  Set SO_RCVBUF=<%x>\n", optionValue);
                context->ReceiveBufferSize = optionValue;
                break;
            }

            default:
            {
                PgmError ("WSHPgm.WSHSetSocketInformation[SOL_SOCKET]: Unsupported Option=<%d>\n",OptionName);
                error = WSAENOPROTOOPT;
                break;
            }
        }
    }

    return error;
} // WSHSetSocketInformation


//----------------------------------------------------------------------------

INT
WSHGetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    )

/*++

Routine Description:

    This routine retrieves information about a socket for those socket
    options supported in this helper DLL.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to getsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to getsockopt().

    OptionName - the optname parameter passed to getsockopt().

    OptionValue - the optval parameter passed to getsockopt().

    OptionLength - the optlen parameter passed to getsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHPGM_SOCKET_CONTEXT context = HelperDllSocketContext;
    tPGM_MCAST_REQUEST          MCastRequest;
    RM_SEND_WINDOW UNALIGNED    *pSetWindowInfo;
    RM_FEC_INFO UNALIGNED       *pFECInfo;
    RM_SENDER_STATS UNALIGNED   *pSenderStats;
    RM_RECEIVER_STATS UNALIGNED *pReceiverStats;
    INT                         error;

    UNREFERENCED_PARAMETER( HelperDllSocketContext );
    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if (Level == SOL_INTERNAL && OptionName == SO_CONTEXT)
    {
        //
        // The Windows Sockets DLL is requesting context information
        // from us.  If an output buffer was not supplied, the Windows
        // Sockets DLL is just requesting the size of our context
        // information.
        //
        if (OptionValue != NULL)
        {
            //
            // Make sure that the buffer is sufficient to hold all the
            // context information.
            //
            if (*OptionLength < sizeof(*context))
            {
                PgmLog ("WSHPgm.WSHGetSocketInformation:  OptionLength=<%d> < ContextLength=<%d>\n",
                    *OptionLength, sizeof(*context));
                return WSAEFAULT;
            }

            //
            // Copy in the context information.
            //
            RtlCopyMemory( OptionValue, context, sizeof(*context) );
        }

        *OptionLength = sizeof(*context);

        PgmLog ("WSHPgm.WSHGetSocketInformation[SOL_INTERNAL:SO_CONTEXT]:  OptionLength=<%d>\n",
            *OptionLength);
        return NO_ERROR;
    }

    //
    // The only other levels we support here are SOL_SOCKET and IPPROTO_RM
    //
    if (Level != SOL_SOCKET &&
        Level != IPPROTO_RM)
    {
        PgmError ("WSHPgm.WSHGetSocketInformation: Unsupported Level=<%d>\n", Level);
        return WSAEINVAL;
    }

    //
    // Make sure that the output buffer is sufficiently large.
    //

    if (*OptionLength < sizeof(char))
    {
        return WSAEFAULT;
    }

    __try
    {
        RtlZeroMemory (OptionValue, *OptionLength);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return WSAEFAULT;
    }

    if (Level == IPPROTO_RM)
    {
        switch (OptionName)
        {
            case RM_RATE_WINDOW_SIZE:
            {
                if ((!TdiAddressObjectHandle) ||
                    (*OptionLength < sizeof(RM_SEND_WINDOW)))
                {
                    return WSAEINVAL;
                }

                error = SetTdiInformation (TdiAddressObjectHandle,
                                           IOCTL_PGM_WSH_QUERY_WINDOW_SIZE_RATE,
                                           NULL,
                                           0,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           TRUE);
                if (error == NO_ERROR)
                {
                    pSetWindowInfo = (RM_SEND_WINDOW UNALIGNED *) OptionValue;

                    pSetWindowInfo->RateKbitsPerSec = MCastRequest.TransmitWindowInfo.RateKbitsPerSec;
                    pSetWindowInfo->WindowSizeInMSecs = MCastRequest.TransmitWindowInfo.WindowSizeInMSecs;
                    pSetWindowInfo->WindowSizeInBytes = MCastRequest.TransmitWindowInfo.WindowSizeInBytes;
                }
                else
                {
                    PgmError ("WSHPgm.WSHGetSocketInformation:  ERROR=<%d> Querying Window RateSize\n",error);
                    return error;
                }

                PgmLog ("WSHPgm.WSHGetSocketInformation[RATE_WINDOW_SIZE]:  Get Window Rate Size\n");

                return (NO_ERROR);
            }

            case RM_SEND_WINDOW_ADV_RATE:
            {
                if ((!TdiAddressObjectHandle) ||
                    (*OptionLength < sizeof(ULONG)))
                {
                    return WSAEINVAL;
                }

                error = SetTdiInformation (TdiAddressObjectHandle,
                                           IOCTL_PGM_WSH_QUERY_ADVANCE_WINDOW_RATE,
                                           NULL,
                                           0,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           TRUE);
                if (error == NO_ERROR)
                {
                    * ((PULONG) OptionValue) = MCastRequest.WindowAdvancePercentage;
                }
                else
                {
                    PgmError ("WSHPgm.WSHGetSocketInformation:  ERROR=<%d> Querying WindowAdvRate\n", error);
                    return error;
                }

                PgmLog ("WSHPgm.WSHGetSocketInformation[WINDOW_ADV_RATE]:  %d\n",
                    MCastRequest.WindowAdvancePercentage);

                return (NO_ERROR);
            }

            case RM_LATEJOIN:
            {
                if ((!TdiAddressObjectHandle) ||
                    (*OptionLength < sizeof(ULONG)))
                {
                    return WSAEINVAL;
                }

                error = SetTdiInformation (TdiAddressObjectHandle,
                                           IOCTL_PGM_WSH_QUERY_LATE_JOINER_PERCENTAGE,
                                           NULL,
                                           0,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           TRUE);
                if (error == NO_ERROR)
                {
                    * ((PULONG) OptionValue) = MCastRequest.LateJoinerPercentage;
                }
                else
                {
                    PgmError ("WSHGetSocketInformation:  ERROR=<%d> Querying LateJoinerPercentage\n", error);
                    return error;
                }

                PgmLog ("WSHPgm.WSHGetSocketInformation[LATEJOIN]:  <%d>\n",
                    MCastRequest.LateJoinerPercentage);

                return (NO_ERROR);
            }

            case RM_SENDER_WINDOW_ADVANCE_METHOD:
            {
                if ((!TdiAddressObjectHandle) ||
                    (*OptionLength < sizeof(ULONG)))
                {
                    return WSAEINVAL;
                }

                error = SetTdiInformation (TdiAddressObjectHandle,
                                           IOCTL_PGM_WSH_QUERY_WINDOW_ADVANCE_METHOD,
                                           NULL,
                                           0,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           TRUE);
                if (error == NO_ERROR)
                {
                    * ((PULONG) OptionValue) = MCastRequest.WindowAdvanceMethod;
                }
                else
                {
                    PgmError ("WSHGetSocketInformation:  ERROR=<%d> Querying WindowAdvanceMethod\n", error);
                    return error;
                }

                PgmLog ("WSHPgm.WSHGetSocketInformation[WINDOW_ADVANCE_METHOD]:  <%d>\n",
                    MCastRequest.WindowAdvanceMethod);

                return (NO_ERROR);
            }

            case RM_USE_FEC:
            {
                if ((!TdiAddressObjectHandle) ||
                    (*OptionLength < sizeof(RM_FEC_INFO)))
                {
                    return WSAEINVAL;
                }

                PgmLog ("WSHPgm.WSHGetSocketInformation[FEC_INFO]:  Get FEC_INFO\n");

                error = SetTdiInformation (TdiAddressObjectHandle,
                                           IOCTL_PGM_WSH_QUERY_FEC_INFO,
                                           NULL,
                                           0,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           TRUE);
                if (error == NO_ERROR)
                {
                    pFECInfo = (RM_FEC_INFO UNALIGNED *) OptionValue;
                    RtlCopyMemory (pFECInfo, &MCastRequest.FECInfo, sizeof(RM_FEC_INFO));
                }
                else
                {
                    PgmError ("WSHGetSocketInformation:  ERROR=<%d> Querying FEC_INFO\n", error);
                    return error;
                }

                return (NO_ERROR);
            }

            case RM_SENDER_STATISTICS:
            {
                if ((!TdiConnectionObjectHandle) ||
                    (*OptionLength < sizeof(RM_SENDER_STATS)))
                {
                    return WSAEINVAL;
                }

                error = SetTdiInformation (TdiConnectionObjectHandle,
                                           IOCTL_PGM_WSH_QUERY_SENDER_STATS,
                                           NULL,
                                           0,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           TRUE);
                if (error == NO_ERROR)
                {
                    pSenderStats = (RM_SENDER_STATS UNALIGNED *) OptionValue;
                    RtlCopyMemory (pSenderStats, &MCastRequest.SenderStats, sizeof(RM_SENDER_STATS));
                }
                else
                {
                    PgmError ("WSHGetSocketInformation:  ERROR=<%d> Querying SENDER_STATS\n", error);
                    return error;
                }

                PgmLog ("WSHPgm.WSHGetSocketInformation[SENDER_STATS]:  Get SENDER_STATS\n");

                return (NO_ERROR);
            }

            case RM_RECEIVER_STATISTICS:
            {
                if ((!TdiConnectionObjectHandle) ||
                    (*OptionLength < sizeof(RM_RECEIVER_STATS)))
                {
                    return WSAEINVAL;
                }

                error = SetTdiInformation (TdiConnectionObjectHandle,
                                           IOCTL_PGM_WSH_QUERY_RECEIVER_STATS,
                                           NULL,
                                           0,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           TRUE);
                if (error == NO_ERROR)
                {
                    pReceiverStats = (RM_RECEIVER_STATS UNALIGNED *) OptionValue;
                    RtlCopyMemory (pReceiverStats, &MCastRequest.ReceiverStats, sizeof(RM_RECEIVER_STATS));
                }
                else
                {
                    PgmError ("WSHGetSocketInformation:  ERROR=<%d> Querying RECEIVER_STATS\n", error);
                    return error;
                }

                PgmLog ("WSHPgm.WSHGetSocketInformation[RECEIVER_STATS]:  Get RECEIVER_STATS\n");

                return (NO_ERROR);
            }

            case RM_HIGH_SPEED_INTRANET_OPT:
            {
                if ((!TdiAddressObjectHandle) ||
                    (*OptionLength < sizeof(ULONG)))
                {
                    return WSAEINVAL;
                }

                error = SetTdiInformation (TdiAddressObjectHandle,
                                           IOCTL_PGM_WSH_QUERY_HIGH_SPEED_INTRANET_OPT,
                                           NULL,
                                           0,
                                           &MCastRequest,
                                           sizeof (MCastRequest),
                                           TRUE);
                if (error == NO_ERROR)
                {
                    * ((PULONG) OptionValue) = MCastRequest.HighSpeedIntranetOptimization;
                }
                else
                {
                    PgmError ("WSHPgm.WSHGetSocketInformation:  ERROR=<%d> Querying HighSpeedIntranetOptimization\n", error);
                    return error;
                }

                PgmLog ("WSHPgm.WSHGetSocketInformation[HIGH_SPEED_INTRANET_OPT]:  %d\n",
                    MCastRequest.HighSpeedIntranetOptimization);

                return (NO_ERROR);
            }

            default:
            {
                return WSAEINVAL;
            }
        }
    }

    PgmError ("WSHPgm.WSHGetSocketInformation[%s]:  Unsupported OptionName=<%d>\n",
        (Level == SOL_SOCKET ? "SOL_SOCKET" : "IPPROTO_RM"), OptionName);

    return WSAENOPROTOOPT;

} // WSHGetSocketInformation


//----------------------------------------------------------------------------

INT
WSHGetSockaddrType (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    )

/*++

Routine Description:

    This routine parses a sockaddr to determine the type of the
    machine address and endpoint address portions of the sockaddr.
    This is called by the winsock DLL whenever it needs to interpret
    a sockaddr.

Arguments:

    Sockaddr - a pointer to the sockaddr structure to evaluate.

    SockaddrLength - the number of bytes in the sockaddr structure.

    SockaddrInfo - a pointer to a structure that will receive information
        about the specified sockaddr.


Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    UNALIGNED SOCKADDR_IN *sockaddr = (PSOCKADDR_IN)Sockaddr;
    ULONG i;

    //
    // Make sure that the address family is correct.
    //
    if (sockaddr->sin_family != AF_INET)
    {
        return WSAEAFNOSUPPORT;
    }

    //
    // Make sure that the length is correct.
    //
    if (SockaddrLength < sizeof(SOCKADDR_IN))
    {
        return WSAEFAULT;
    }

    //
    // The address passed the tests, looks like a good address.
    // Determine the type of the address portion of the sockaddr.
    //

    if (sockaddr->sin_addr.s_addr == INADDR_ANY)
    {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoWildcard;
    }
    else if (sockaddr->sin_addr.s_addr == INADDR_BROADCAST)
    {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoBroadcast;
    }
    else if (sockaddr->sin_addr.s_addr == INADDR_LOOPBACK)
    {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoLoopback;
    }
    else
    {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoNormal;
    }

    //
    // Determine the type of the port (endpoint) in the sockaddr.
    //
    if (sockaddr->sin_port == 0)
    {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;
    }
    else if (ntohs (sockaddr->sin_port) < 2000)
    {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoReserved;
    }
    else
    {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoNormal;
    }

    //
    // Zero out the sin_reserved_mbz part of the address.  We silently allow
    // nonzero values in this field.
    //
    for (i = 0; i < sizeof(sockaddr->sin_zero); i++)
    {
        sockaddr->sin_zero[i] = 0;
    }

    PgmLog ("WSHPgm.WSHGetSockAddrType:  Addr=<%x>=><%x>, Port=<%x>=><%x>\n",
        sockaddr->sin_addr.s_addr, SockaddrInfo->AddressInfo, sockaddr->sin_port, SockaddrInfo->EndpointInfo);

    return NO_ERROR;

} // WSHGetSockaddrType



INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPWSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Enumerates the protocols supported by this helper.

Arguments:

    lpiProtocols - Pointer to a NULL-terminated array of protocol
        identifiers. Only protocols specified in this array will
        be returned by this function. If this pointer is NULL,
        all protocols are returned.

    lpTransportKeyName -

    lpProtocolBuffer - Pointer to a buffer to fill with PROTOCOL_INFO
        structures.

    lpdwBufferLength - Pointer to a variable that, on input, contains
        the size of lpProtocolBuffer. On output, this value will be
        updated with the size of the data actually written to the buffer.

Return Value:

    INT - The number of protocols returned if successful, -1 if not.

--*/

{
    DWORD bytesRequired;
    PPROTOCOL_INFO PgmProtocolInfo;
    BOOL useRM = FALSE;
    DWORD i;

    UNREFERENCED_PARAMETER(lpTransportKeyName);

    //
    // Make sure that the caller cares about RM.
    //
    if (ARGUMENT_PRESENT (lpiProtocols))
    {
        for (i = 0; lpiProtocols[i] != 0; i++)
        {
            if (lpiProtocols[i] == IPPROTO_RM)
            {
                useRM = TRUE;
            }
        }
    }
    else
    {
        useRM = TRUE;
    }

    if (!useRM)
    {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //
    bytesRequired = (DWORD)((sizeof(PROTOCOL_INFO) * 1) + ((wcslen (PGM_NAME) + 1) * sizeof(WCHAR)));
    if (bytesRequired > *lpdwBufferLength)
    {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    //
    // Fill in PGM info
    //
    PgmProtocolInfo = lpProtocolBuffer;
    PgmProtocolInfo->lpProtocol = (LPWSTR) ((PBYTE)lpProtocolBuffer + *lpdwBufferLength -
                                    ((wcslen(PGM_NAME) + 1) * sizeof(WCHAR)));
    PgmProtocolInfo->dwServiceFlags = PGM_RDM_SERVICE_FLAGS;
    PgmProtocolInfo->iAddressFamily = AF_INET;
    PgmProtocolInfo->iSocketType = SOCK_RDM;
    PgmProtocolInfo->iProtocol = IPPROTO_RM;
    PgmProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_IN);
    PgmProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_IN);
    PgmProtocolInfo->dwMessageSize = PGM_MESSAGE_SIZE;
    wcscpy (PgmProtocolInfo->lpProtocol, PGM_NAME);

    *lpdwBufferLength = bytesRequired;

    PgmLog ("WSHPgm.WSHEnumProtocols:  ServiceFlags=<%x>, <%x>...\n",
        PGM_RDM_SERVICE_FLAGS, PGM_STREAM_SERVICE_FLAGS);

    return 1;

} // WSHEnumProtocols



//----------------------------------------------------------------------------

INT
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a wildcard socket address.  A wildcard address
    is one which will bind the socket to an endpoint of the transport's
    choosing.  For TCP/IP, a wildcard address has IP address ==
    0.0.0.0 and port = 0.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a wildcard
        address.

    Sockaddr - points to a buffer which will receive the wildcard socket
        address.

    SockaddrLength - receives the length of the wioldcard sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    if (*SockaddrLength < sizeof(SOCKADDR_IN))
    {
        return WSAEFAULT;
    }

    *SockaddrLength = sizeof(SOCKADDR_IN);

    //
    // Just zero out the address and set the family to AF_INET
    //
    RtlZeroMemory (Sockaddr, sizeof(SOCKADDR_IN));
    Sockaddr->sa_family = AF_INET;

    PgmLog ("WSHPgm.WSHGetWildcardSockaddr:  ...\n");
    return NO_ERROR;

} // WSAGetWildcardSockaddr


//----------------------------------------------------------------------------

DWORD
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    )

/*++

Routine Description:

    Returns the list of address family/socket type/protocol triples
    supported by this helper DLL.

Arguments:

    Mapping - receives a pointer to a WINSOCK_MAPPING structure that
        describes the triples supported here.

    MappingLength - the length, in bytes, of the passed-in Mapping buffer.

Return Value:

    DWORD - the length, in bytes, of a WINSOCK_MAPPING structure for this
        helper DLL.  If the passed-in buffer is too small, the return
        value will indicate the size of a buffer needed to contain
        the WINSOCK_MAPPING structure.

--*/

{
    DWORD mappingLength;

    mappingLength = sizeof(WINSOCK_MAPPING) - sizeof(MAPPING_TRIPLE) + sizeof(PgmMappingTriples);

    //
    // If the passed-in buffer is too small, return the length needed
    // now without writing to the buffer.  The caller should allocate
    // enough memory and call this routine again.
    //
    if (mappingLength > MappingLength)
    {
        return mappingLength;
    }

    //
    // Fill in the output mapping buffer with the list of triples
    // supported in this helper DLL.
    //
    Mapping->Rows = sizeof(PgmMappingTriples) / sizeof(PgmMappingTriples[0]);
    Mapping->Columns = sizeof(MAPPING_TRIPLE) / sizeof(DWORD);
    RtlMoveMemory (Mapping->Mapping, PgmMappingTriples, sizeof(PgmMappingTriples));

    PgmLog ("WSHPgm.WSHGetWinsockMapping:  MappingLength=<%d>\n", mappingLength);

    //
    // Return the number of bytes we wrote.
    //
    return mappingLength;

} // WSHGetWinsockMapping


//----------------------------------------------------------------------------

INT
WINAPI
WSHAddressToString (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    )

/*++

Routine Description:

    Converts a SOCKADDR to a human-readable form.

Arguments:

    Address - The SOCKADDR to convert.

    AddressLength - The length of Address.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    AddressString - Receives the formatted address string.

    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    WCHAR           string[32];
    INT             length;
    LPSOCKADDR_IN   addr;
    INT             err = NO_ERROR;

    //
    // Quick sanity checks.
    //
    if( AddressLength < sizeof(SOCKADDR_IN))
    {
        return WSAEFAULT;
    }

    __try {
        addr = (LPSOCKADDR_IN)Address;

        if (addr->sin_family != AF_INET)
        {
            return WSAEINVAL;
        }

        //
        // Do the converstion.
        //
        // BUGBUG: We should really use the DavidTr huge-but-fast
        // table based lookup for this, but we already have two copies
        // of that 1K table in the system (one in WSOCK32.DLL, and one it
        // WS2_32.DLL). I really don't want to see Yet Another Copy here.
        //
        length = swprintf (string, L"%d.%d.%d.%d", (addr->sin_addr.s_addr >>  0) & 0xFF,
                                                   (addr->sin_addr.s_addr >>  8) & 0xFF,
                                                   (addr->sin_addr.s_addr >> 16) & 0xFF,
                                                   (addr->sin_addr.s_addr >> 24) & 0xFF);

        if (addr->sin_port != 0)
        {
            length += swprintf (string + length, L":%u", ntohs (addr->sin_port));
        }

        length++;   // account for terminator
        if (*AddressStringLength >= (DWORD)length)
        {
            RtlCopyMemory (AddressString, string, length * sizeof(WCHAR));
        }
        else
        {
            err = WSAEFAULT;
        }

        *AddressStringLength = length;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        err = WSAEFAULT;
    }

    PgmLog ("WSHPgm.WSHAddressToString:  status=<%d>\n", err);
    return err;

} // WSHAddressToString


//----------------------------------------------------------------------------


INT
WINAPI
WSHStringToAddress (
    IN LPWSTR AddressString,
    IN DWORD AddressFamily,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPSOCKADDR Address,
    IN OUT LPINT AddressLength
    )

/*++

Routine Description:

    Fills in a SOCKADDR structure by parsing a human-readable string.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    AddressFamily - The address family to which the string belongs.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    Address - Receives the SOCKADDR structure.

    AddressLength - On input, contains the length of Address. On output,
        contains the number of bytes actually written to Address.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
    LPWSTR          terminator;
    ULONG           ipAddress;
    USHORT          port;
    LPSOCKADDR_IN   addr;

    __try {
        //
        // Quick sanity checks.
        //
        if (*AddressLength < sizeof(SOCKADDR_IN))
        {
            *AddressLength = sizeof(SOCKADDR_IN);
            return WSAEFAULT;
        }

        if (AddressFamily != AF_INET)
        {
            return WSAEINVAL;
        }

        //
        // Convert it.
        //
#if(WINVER > 0x0500)
        if (!NT_SUCCESS (RtlIpv4StringToAddressW (AddressString,
                                                  FALSE,
                                                  &terminator,
                                                  (IN_ADDR*)&ipAddress)))
#else
        ipAddress = MyInetAddr (AddressString, &terminator);
        if (ipAddress == INADDR_NONE)
#endif  // WINVER
        {
            return WSAEINVAL;
        }
        if (ipAddress == INADDR_NONE)
        {
            return WSAEINVAL;
        }

        if (*terminator == L':')
        {
            WCHAR ch;
            USHORT base;

            terminator++;
            port = 0;
            base = 10;

            if (*terminator == L'0')
            {
                base = 8;
                terminator++;

                if (*terminator == L'x')
                {
                    base = 16;
                    terminator++;
                }
            }

            while (ch = *terminator++)
            {
                if (iswdigit(ch))
                {
                    port = (port * base) + (ch - L'0');
                }
                else if (base == 16 && iswxdigit(ch))
                {
                    port = (port << 4);
                    port += ch + 10 - (iswlower(ch) ? L'a' : L'A');
                }
                else
                {
                    return WSAEINVAL;
                }
            }
        }
        else if (*terminator == 0)
        {
            port = 0;
        } 
        else
        {
            return WSAEINVAL;
        }

        //
        // Build the address.
        //
        RtlZeroMemory (Address, sizeof(SOCKADDR_IN));

        addr = (LPSOCKADDR_IN)Address;
        *AddressLength = sizeof(SOCKADDR_IN);

        addr->sin_family = AF_INET;
        addr->sin_port = htons (port);
        addr->sin_addr.s_addr = ipAddress;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return WSAEFAULT;
    }

    PgmLog ("WSHPgm.WSHStringToAddress:\n");
    return NO_ERROR;

} // WSHStringToAddress


//----------------------------------------------------------------------------

INT
WINAPI
WSHGetBroadcastSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a broadcast socket address.  A broadcast address
    may be used as a destination for the sendto() API to send a datagram
    to all interested clients.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a broadcast
        address.

    Sockaddr - points to a buffer which will receive the broadcast socket
        address.

    SockaddrLength - receives the length of the broadcast sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    LPSOCKADDR_IN addr;

    PgmError ("WSHPgm.WSHGetBroadcastSockaddr:  Not Supported!\n");

    return (WSAEOPNOTSUPP);

    if (*SockaddrLength < sizeof(SOCKADDR_IN))
    {
        return WSAEFAULT;
    }

    *SockaddrLength = sizeof(SOCKADDR_IN);

    //
    // Build the broadcast address.
    //
    addr = (LPSOCKADDR_IN) Sockaddr;

    RtlZeroMemory (addr, sizeof(*addr));

    addr->sin_family = AF_INET;
    addr->sin_addr.s_addr = htonl (INADDR_BROADCAST);

    return NO_ERROR;

} // WSAGetBroadcastSockaddr


//----------------------------------------------------------------------------

INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )

/*++

Routine Description:

    Returns the GUID identifying the protocols supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "Pgm".

    ProviderGuid - Points to a buffer that receives the provider's GUID.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
    INT     RetVal = WSAEINVAL;

    if (ProviderName == NULL || ProviderGuid == NULL)
    {
        RetVal = WSAEFAULT;
    }
    else if (_wcsicmp (ProviderName, L"Pgm") == 0)
    {
        RtlCopyMemory (ProviderGuid, &PgmProviderGuid, sizeof(GUID));
        RetVal = NO_ERROR;
    }

    PgmLog ("WSHPgm.WSHGetProviderGuid:  ProviderName=<%ws>, RetVal=<%x>\n", ProviderName, RetVal);
    return (RetVal);

} // WSHGetProviderGuid



//----------------------------------------------------------------------------

INT
WINAPI
WSHGetWSAProtocolInfo (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    )

/*++

Routine Description:

    Retrieves a pointer to the WSAPROTOCOL_INFOW structure(s) describing
    the protocol(s) supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProtocolInfo - Receives a pointer to the WSAPROTOCOL_INFOW array.

    ProtocolInfoEntries - Receives the number of entries in the array.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
    INT     RetVal = WSAEINVAL;

    if (ProviderName == NULL || ProtocolInfo == NULL || ProtocolInfoEntries == NULL)
    {
        RetVal = WSAEFAULT;
    }
    else if (_wcsicmp (ProviderName, L"RMCast") == 0)
    {
        *ProtocolInfo = Winsock2Protocols;
        *ProtocolInfoEntries = NUM_WINSOCK2_PROTOCOLS;

        RetVal = NO_ERROR;
    }

    PgmLog ("WSHPgm.WSHGetWSAProtocolInfo:  ProviderName=<%ws>, RetVal=<%x>\n", ProviderName, RetVal);
    return (RetVal);

} // WSHGetWSAProtocolInfo


//----------------------------------------------------------------------------

INT
WINAPI
WSHIoctl (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    OUT LPBOOL NeedsCompletion
    )

/*++

Routine Description:

    Performs queries & controls on the socket. This is basically an
    "escape hatch" for IOCTLs not supported by MSAFD.DLL. Any unknown
    IOCTLs are routed to the socket's helper DLL for protocol-specific
    processing.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're controlling.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    IoControlCode - Control code of the operation to perform.

    InputBuffer - Address of the input buffer.

    InputBufferLength - The length of InputBuffer.

    OutputBuffer - Address of the output buffer.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - Receives the number of bytes actually written
        to the output buffer.

    Overlapped - Pointer to a WSAOVERLAPPED structure for overlapped
        operations.

    CompletionRoutine - Pointer to a completion routine to call when
        the operation is completed.

    NeedsCompletion - WSAIoctl() can be overlapped, with all the gory
        details that involves, such as setting events, queuing completion
        routines, and posting to IO completion ports. Since the majority
        of the IOCTL codes can be completed quickly "in-line", MSAFD.DLL
        can optionally perform the overlapped completion of the operation.

        Setting *NeedsCompletion to TRUE (the default) causes MSAFD.DLL
        to handle all of the IO completion details iff this is an
        overlapped operation on an overlapped socket.

        Setting *NeedsCompletion to FALSE tells MSAFD.DLL to take no
        further action because the helper DLL will perform any necessary
        IO completion.

        Note that if a helper performs its own IO completion, the helper
        is responsible for maintaining the "overlapped" mode of the socket
        at socket creation time and NOT performing overlapped IO completion
        on non-overlapped sockets.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
    INT err;
    NTSTATUS status;

    //
    // Quick sanity checks.
    //
    if (HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        NumberOfBytesReturned == NULL ||
        NeedsCompletion == NULL)
    {
        return WSAEINVAL;
    }

    *NeedsCompletion = TRUE;

    switch (IoControlCode)
    {
        default:
            err = WSAEINVAL;
            break;
    }

    PgmLog ("WSHPgm.WSHIoctl:  Returning <%d>\n", err);
    return err;

}   // WSHIoctl


//----------------------------------------------------------------------------

INT
WINAPI
WSHJoinLeaf (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN PVOID LeafHelperDllSocketContext,
    IN SOCKET LeafSocketHandle,
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    IN LPWSABUF CallerData,
    IN LPWSABUF CalleeData,
    IN LPQOS SocketQOS,
    IN LPQOS GroupQOS,
    IN DWORD Flags
    )

/*++

Routine Description:

    Performs the protocol-dependent portion of creating a multicast
    socket.

Arguments:

    The following four parameters correspond to the socket passed into
    the WSAJoinLeaf() API:

    HelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    SocketHandle - The handle of the socket used to establish the
        multicast "session".

    TdiAddressObjectHandle - The TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - The TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    The next two parameters correspond to the newly created socket that
    identifies the multicast "session":

    LeafHelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    LeafSocketHandle - The handle of the socket that identifies the
        multicast "session".

    Sockaddr - The name of the peer to which the socket is to be joined.

    SockaddrLength - The length of Sockaddr.

    CallerData - Pointer to user data to be transferred to the peer
        during multipoint session establishment.

    CalleeData - Pointer to user data to be transferred back from
        the peer during multipoint session establishment.

    SocketQOS - Pointer to the flowspecs for SocketHandle, one in each
        direction.

    GroupQOS - Pointer to the flowspecs for the socket group, if any.

    Flags - Flags to indicate if the socket is acting as sender,
        receiver, or both.

Return Value:

    INT - 0 if successful, a WinSock error code if not.

--*/

{
    tPGM_MCAST_REQUEST      MCastRequest;
    INT                     err;
    BOOL                    bSet_RM_MULTICAST_IF = FALSE;
    PWSHPGM_SOCKET_CONTEXT  context;

    //
    // Note: at this time we only support non-rooted control schemes,
    //       and therefore no leaf socket is created
    //
    //
    // Quick sanity checks.
    //
    if (HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        TdiAddressObjectHandle == NULL ||
        LeafHelperDllSocketContext != NULL ||
        LeafSocketHandle != INVALID_SOCKET ||
        Sockaddr == NULL ||
        Sockaddr->sa_family != AF_INET ||
        SockaddrLength < sizeof(SOCKADDR_IN) ||
        ( CallerData != NULL && CallerData->len > 0 ) ||
        ( CalleeData != NULL && CalleeData->len > 0 ) ||
        SocketQOS != NULL ||
        GroupQOS != NULL)
    {
        return WSAEINVAL;
    }

    context = HelperDllSocketContext;

    MCastRequest.MCastInfo.MCastIpAddr = ((LPSOCKADDR_IN)Sockaddr)->sin_addr.s_addr; // MCast group to join...
    MCastRequest.MCastInfo.MCastInIf = context->MulticastInInterface;     // Multicast If to rcv packets on
    MCastRequest.MCastOutIf = context->MulticastOutInterface;     // Multicast If to send packets on

    //
    // Now figure out the local interface. Note that the local interface
    // specified in IP_ADD_MEMBERSHIP applies to that on which you wish
    // to receive datagrams, while the local interface specified in
    // RM_MULTICAST_IF applies to that from which to send multicast
    // packets.  If there is >1 local interface then we want to be
    // consistent regarding the send/recv interfaces.
    //
    if (context->MulticastInInterface == DEFAULT_MULTICAST_INTERFACE)
    {
        TDI_REQUEST_QUERY_INFORMATION query;
        char            tdiAddressInfo[FIELD_OFFSET (TDI_ADDRESS_INFO, Address)
                                        + sizeof (TA_IP_ADDRESS)];
        NTSTATUS        status;
        IO_STATUS_BLOCK ioStatusBlock;

        //
        // App hasn't set RM_MULTICAST_IF, so retrieve the bound
        // address and use that for the send & recv interfaces
        //
        RtlZeroMemory (&query, sizeof (query));
        query.QueryType = TDI_QUERY_ADDRESS_INFO;

        status = NtDeviceIoControlFile (TdiAddressObjectHandle,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &ioStatusBlock,
                                        IOCTL_TDI_QUERY_INFORMATION,
                                        &query,
                                        sizeof (query),
                                        tdiAddressInfo,
                                        sizeof(tdiAddressInfo));

        if (NT_SUCCESS(status))
        {
            PTA_IP_ADDRESS  pIpAddress = (PTA_IP_ADDRESS)
                                         (tdiAddressInfo+FIELD_OFFSET (TDI_ADDRESS_INFO, Address));

            if (MCastRequest.MCastInfo.MCastInIf != DEFAULT_MULTICAST_INTERFACE)
            {
                bSet_RM_MULTICAST_IF = TRUE;
                MCastRequest.MCastInfo.MCastInIf = pIpAddress->Address[0].Address[0].in_addr;
                context->MulticastInInterface = MCastRequest.MCastInfo.MCastInIf;
            }
        }
        else
        {
            PgmError ("WSHPgm!WSHJoinLeaf:  DeviceIoCtrl failed to QueryInformation, status=<%x>\n",
                status);
        }
    }

    err = NO_ERROR;

    //
    // If the Flags param indicates that caller is a sender only,
    // then there's no point in actually joining the group (anyone
    // can send to a multicast group, but it's only members of the
    // group who recv the packets).  So, just check to see if it
    // is necessary to set the RM_MULTICAST_IF to remain consistent
    // with the bound address.
    //
    // Otherwise, caller is a receiver (possibly a sender too), so
    // we really do want to join the group.
    //
    if (Flags != JL_SENDER_ONLY)
    {
        PgmLog ("WSHJoinLeaf[JL_RECEIVER]:  Address=<%x>, Connection=<%x>\n",
            TdiAddressObjectHandle, TdiConnectionObjectHandle);

        //
        // Add ourselves as a receiver
        //
        MCastRequest.MCastPort = ((LPSOCKADDR_IN)Sockaddr)->sin_port;
        err = SetTdiInformation (TdiAddressObjectHandle,
                                 IOCTL_PGM_WSH_JOIN_MCAST_LEAF,
                                 &MCastRequest,
                                 sizeof (MCastRequest),
                                 NULL,
                                 0,
                                 TRUE);

        if (err == NO_ERROR)
        {
            //
            // Record this fact in the leaf socket so we can drop membership
            // when the leaf socket is closed.
            //
            context->MultipointLeaf = TRUE;
            context->MultipointTarget = MCastRequest.MCastInfo.MCastIpAddr;
            context->MultipointPort = ((LPSOCKADDR_IN)Sockaddr)->sin_port;

            PgmLog ("WSHPgm!WSHJoinLeaf:  JoinLeaf to <%x:%x> SUCCEEDed\n",
                MCastRequest.MCastInfo.MCastIpAddr);
        }
        else
        {
            PgmError ("WSHPgm!WSHJoinLeaf:  JoinLeaf to <%x> FAILed, err=<%d>\n",
                MCastRequest.MCastInfo.MCastIpAddr, err);
        }
    }

    if ((TdiConnectionObjectHandle) &&
        (err == NO_ERROR) &&
        (bSet_RM_MULTICAST_IF))
    {
        //
        // If we have a TDI address object, set this option to
        // the address object.  If we don't have a TDI address
        // object then we'll have to wait until after the socket
        // is bound.
        //
        PgmLog ("WSHJoinLeaf[bSet_RM_MULTICAST_IF]:  Address=<%x>, Connection=<%x>\n",
            TdiAddressObjectHandle, TdiConnectionObjectHandle);

        err = SetTdiInformation (TdiAddressObjectHandle,
                                 IOCTL_PGM_WSH_ADD_RECEIVE_IF,
                                 &MCastRequest,
                                 sizeof (MCastRequest),
                                 NULL,
                                 0,
                                 TRUE);

        if (err == NO_ERROR)
        {
            PgmLog ("WSHPgm!WSHJoinLeaf:  Set MCastIf=<%x> SUCCEEDed\n", MCastRequest.MCastInfo.MCastInIf);
            context->MulticastInInterface = MCastRequest.MCastInfo.MCastInIf;
        }
        else
        {
            PgmLog ("WSHPgm!WSHJoinLeaf:  Set MCastIf=<%x> FAILed, err=<%d>\n",
                MCastRequest.MCastInfo.MCastInIf, err);
        }
    }

    return err;

} // WSHJoinLeaf



//----------------------------------------------------------------------------
//
// Internal routines
//
//----------------------------------------------------------------------------


BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    )

/*++

Routine Description:

    Determines whether the specified triple has an exact match in the
    list of triples.

Arguments:

    List - a list of triples (address family/socket type/protocol) to
        search.

    ListLength - the number of triples in the list.

    AddressFamily - the address family to look for in the list.

    SocketType - the socket type to look for in the list.

    Protocol - the protocol to look for in the list.

Return Value:

    BOOLEAN - TRUE if the triple was found in the list, false if not.

--*/

{
    ULONG i;

    //
    // Walk through the list searching for an exact match.
    //
    for (i = 0; i < ListLength; i++)
    {
        //
        // If all three elements of the triple match, return indicating
        // that the triple did exist in the list.
        //
        if (AddressFamily == List[i].AddressFamily &&
            SocketType == List[i].SocketType &&
            Protocol == List[i].Protocol)
        {
            return TRUE;
        }
    }

    //
    // The triple was not found in the list.
    //

    return FALSE;
} // IsTripleInList


#if(WINVER <= 0x0500)
//----------------------------------------------------------------------------
ULONG
MyInetAddr(
    IN LPWSTR String,
    OUT LPWSTR * Terminator
    )

/*++

Routine Description:

    This function interprets the character string specified by the cp
    parameter.  This string represents a numeric Internet address
    expressed in the Internet standard ".'' notation.  The value
    returned is a number suitable for use as an Internet address.  All
    Internet addresses are returned in network order (bytes ordered from
    left to right).

    Internet Addresses

    Values specified using the "." notation take one of the following
    forms:

    a.b.c.d   a.b.c     a.b  a

    When four parts are specified, each is interpreted as a byte of data
    and assigned, from left to right, to the four bytes of an Internet
    address.  Note that when an Internet address is viewed as a 32-bit
    integer quantity on the Intel architecture, the bytes referred to
    above appear as "d.c.b.a''.  That is, the bytes on an Intel
    processor are ordered from right to left.

    Note: The following notations are only used by Berkeley, and nowhere
    else on the Internet.  In the interests of compatibility with their
    software, they are supported as specified.

    When a three part address is specified, the last part is interpreted
    as a 16-bit quantity and placed in the right most two bytes of the
    network address.  This makes the three part address format
    convenient for specifying Class B network addresses as
    "128.net.host''.

    When a two part address is specified, the last part is interpreted
    as a 24-bit quantity and placed in the right most three bytes of the
    network address.  This makes the two part address format convenient
    for specifying Class A network addresses as "net.host''.

    When only one part is given, the value is stored directly in the
    network address without any byte rearrangement.

Arguments:

    String - A character string representing a number expressed in the
        Internet standard "." notation.

    Terminator - Receives a pointer to the character that terminated
        the conversion.

Return Value:

    If no error occurs, inet_addr() returns an in_addr structure
    containing a suitable binary representation of the Internet address
    given.  Otherwise, it returns the value INADDR_NONE.

--*/

{
        ULONG val, base, n;
        WCHAR c;
        ULONG parts[4], *pp = parts;

again:
        /*
         * Collect number up to ``.''.
         * Values are specified as for C:
         * 0x=hex, 0=octal, other=decimal.
         */
        val = 0; base = 10;
        if (*String == L'0') {
                base = 8, String++;
                if (*String == L'x' || *String == L'X')
                        base = 16, String++;
        }

        while (c = *String) {
                if (iswdigit(c)) {
                        val = (val * base) + (c - L'0');
                        String++;
                        continue;
                }
                if (base == 16 && iswxdigit(c)) {
                        val = (val << 4) + (c + 10 - (islower(c) ? L'a' : L'A'));
                        String++;
                        continue;
                }
                break;
        }
        if (*String == L'.') {
                /*
                 * Internet format:
                 *      a.b.c.d
                 *      a.b.c   (with c treated as 16-bits)
                 *      a.b     (with b treated as 24 bits)
                 */
                /* GSS - next line was corrected on 8/5/89, was 'parts + 4' */
                if (pp >= parts + 3) {
                        *Terminator = String;
                        return ((ULONG) -1);
                }
                *pp++ = val, String++;
                goto again;
        }
        /*
         * Check for trailing characters.
         */
        if (*String && !iswspace(*String) && (*String != L':')) {
                *Terminator = String;
                return (INADDR_NONE);
        }
        *pp++ = val;
        /*
         * Concoct the address according to
         * the number of parts specified.
         */
        n = (ULONG)(pp - parts);
        switch ((int) n) {

        case 1:                         /* a -- 32 bits */
                val = parts[0];
                break;

        case 2:                         /* a.b -- 8.24 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xffffff)) {
                    *Terminator = String;
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | (parts[1] & 0xffffff);
                break;

        case 3:                         /* a.b.c -- 8.8.16 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xffff)) {
                    *Terminator = String;
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                        (parts[2] & 0xffff);
                break;

        case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xff) || (parts[3] > 0xff)) {
                    *Terminator = String;
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                      ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
                break;

        default:
                *Terminator = String;
                return (INADDR_NONE);
        }

        val = htonl(val);
        *Terminator = String;
        return (val);
}
#endif  // WINVER


//----------------------------------------------------------------------------
INT
NtStatusToSocketError (
    IN NTSTATUS Status
    )
{

    switch ( Status ) {

    case STATUS_PENDING:
        ASSERT (FALSE);
        return WSASYSCALLFAILURE;

    case STATUS_INVALID_HANDLE:
    case STATUS_OBJECT_TYPE_MISMATCH:
        return WSAENOTSOCK;

    case STATUS_INSUFFICIENT_RESOURCES:
    case STATUS_PAGEFILE_QUOTA:
    case STATUS_COMMITMENT_LIMIT:
    case STATUS_WORKING_SET_QUOTA:
    case STATUS_NO_MEMORY:
    case STATUS_CONFLICTING_ADDRESSES:
    case STATUS_QUOTA_EXCEEDED:
    case STATUS_TOO_MANY_PAGING_FILES:
    case STATUS_REMOTE_RESOURCES:
    case STATUS_TOO_MANY_ADDRESSES:
        return WSAENOBUFS;

    case STATUS_SHARING_VIOLATION:
    case STATUS_ADDRESS_ALREADY_EXISTS:
        return WSAEADDRINUSE;

    case STATUS_LINK_TIMEOUT:
    case STATUS_IO_TIMEOUT:
    case STATUS_TIMEOUT:
        return WSAETIMEDOUT;

    case STATUS_GRACEFUL_DISCONNECT:
        return WSAEDISCON;

    case STATUS_REMOTE_DISCONNECT:
    case STATUS_CONNECTION_RESET:
    case STATUS_LINK_FAILED:
    case STATUS_CONNECTION_DISCONNECTED:
    case STATUS_PORT_UNREACHABLE:
        return WSAECONNRESET;

    case STATUS_LOCAL_DISCONNECT:
    case STATUS_TRANSACTION_ABORTED:
    case STATUS_CONNECTION_ABORTED:
        return WSAECONNABORTED;

    case STATUS_BAD_NETWORK_PATH:
    case STATUS_NETWORK_UNREACHABLE:
    case STATUS_PROTOCOL_UNREACHABLE:
        return WSAENETUNREACH;

    case STATUS_HOST_UNREACHABLE:
        return WSAEHOSTUNREACH;

    case STATUS_CANCELLED:
    case STATUS_REQUEST_ABORTED:
        return WSAEINTR;

    case STATUS_BUFFER_OVERFLOW:
    case STATUS_INVALID_BUFFER_SIZE:
        return WSAEMSGSIZE;

    case STATUS_BUFFER_TOO_SMALL:
    case STATUS_ACCESS_VIOLATION:
        return WSAEFAULT;

    case STATUS_DEVICE_NOT_READY:
    case STATUS_REQUEST_NOT_ACCEPTED:
        return WSAEWOULDBLOCK;

    case STATUS_INVALID_NETWORK_RESPONSE:
    case STATUS_NETWORK_BUSY:
    case STATUS_NO_SUCH_DEVICE:
    case STATUS_NO_SUCH_FILE:
    case STATUS_OBJECT_PATH_NOT_FOUND:
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_UNEXPECTED_NETWORK_ERROR:
        return WSAENETDOWN;

    case STATUS_INVALID_CONNECTION:
        return WSAENOTCONN;

    case STATUS_REMOTE_NOT_LISTENING:
    case STATUS_CONNECTION_REFUSED:
        return WSAECONNREFUSED;

    case STATUS_PIPE_DISCONNECTED:
        return WSAESHUTDOWN;

    case STATUS_INVALID_ADDRESS:
    case STATUS_INVALID_ADDRESS_COMPONENT:
        return WSAEADDRNOTAVAIL;

    case STATUS_NOT_SUPPORTED:
    case STATUS_NOT_IMPLEMENTED:
        return WSAEOPNOTSUPP;

    case STATUS_ACCESS_DENIED:
        return WSAEACCES;

    default:

        if ( NT_SUCCESS(Status) ) {

#if DBG
            DbgPrint ("SockNtStatusToSocketError: success status %lx "
                       "not mapped\n", Status );
#endif

            return NO_ERROR;
        }

#if DBG
        DbgPrint ("SockNtStatusToSocketError: unable to map 0x%lX, returning\n", Status );
#endif

        return WSAENOBUFS;

    case STATUS_UNSUCCESSFUL:
    case STATUS_INVALID_PARAMETER:
    case STATUS_ADDRESS_CLOSED:
    case STATUS_CONNECTION_INVALID:
    case STATUS_ADDRESS_ALREADY_ASSOCIATED:
    case STATUS_ADDRESS_NOT_ASSOCIATED:
    case STATUS_CONNECTION_ACTIVE:
    case STATUS_INVALID_DEVICE_STATE:
    case STATUS_INVALID_DEVICE_REQUEST:
        return WSAEINVAL;

    }

} // NtStatusToSocketError
VOID
CompleteTdiActionApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock
    )
{
    //
    // Just free the heap we allocated to hold the IO status block and
    // the TDI action buffer.  There is nothing we can do if the call
    // failed.
    //

    RtlFreeHeap( RtlProcessHeap( ), 0, ApcContext );

} // CompleteTdiActionApc



INT
SetTdiInformation (
    IN HANDLE   TdiObjectHandle,
    IN ULONG    Ioctl,
    IN PVOID    InputBuffer,
    IN ULONG    InputBufferLength,
    IN PVOID    OutputBuffer,
    IN ULONG    OutputBufferLength,
    IN BOOLEAN  WaitForCompletion
    )

/*++

Routine Description:

    Performs a TDI action to the TCP/IP driver.  A TDI action translates
    into a streams T_OPTMGMT_REQ.

Arguments:

    TdiConnectionObjectHandle - a TDI connection object on which to perform
        the TDI action.

    Entity - value to put in the tei_entity field of the TDIObjectID
        structure.

    Class - value to put in the toi_class field of the TDIObjectID
        structure.

    Type - value to put in the toi_type field of the TDIObjectID
        structure.

    Id - value to put in the toi_id field of the TDIObjectID structure.

    InputBuffer - a pointer to a buffer to set as the information.

    InputBufferLength - the length of the buffer.

    WaitForCompletion - TRUE if we should wait for the TDI action to
        complete, FALSE if we're at APC level and cannot do a wait.

Return Value:

    INT - NO_ERROR, or a Windows Sockets error code.

--*/

{
    NTSTATUS status;
    PVOID                           completionApc;
    PVOID                           apcContext;
    IO_STATUS_BLOCK                 IoStatusBlock;
    IO_STATUS_BLOCK                 *pIoStatusBlock;

    if (WaitForCompletion || InputBufferLength>32)
    {
        //
        // Allocate space to hold the TDI set information buffers and the IO
        // status block.  These cannot be stack variables in case we must
        // return before the operation is complete.
        //
        pIoStatusBlock = RtlAllocateHeap (RtlProcessHeap( ),
                                         0,
                                         sizeof (*pIoStatusBlock));
        if (pIoStatusBlock == NULL)
        {
            return WSAENOBUFS;
        }
    }
    else
    {
        pIoStatusBlock = (PIO_STATUS_BLOCK) &IoStatusBlock;
    }

    //
    // If we need to wait for completion of the operation, create an
    // event to wait on.  If we can't wait for completion because we
    // are being called at APC level, we'll use an APC routine to
    // free the heap we allocated above.
    //

    if (WaitForCompletion)
    {
        completionApc = NULL;
        apcContext = NULL;
    }
    else
    {
        completionApc = CompleteTdiActionApc;
        apcContext = pIoStatusBlock;
    }

    //
    // Make the actual TDI action call.  The Streams TDI mapper will
    // translate this into a TPI option management request for us and
    // give it to .
    //
    IoStatusBlock.Status = STATUS_PENDING;
    status = NtDeviceIoControlFile (TdiObjectHandle,
                                    NULL,
                                    completionApc,
                                    apcContext,
                                    pIoStatusBlock,
                                    Ioctl,
                                    InputBuffer,
                                    InputBufferLength,
                                    OutputBuffer,          // Use same buffer as output buffer!
                                    OutputBufferLength);

    //
    // If the call pended and we were supposed to wait for completion,
    // then wait.
    //
    if ( status == STATUS_PENDING && WaitForCompletion)
    {
#if DBG
        INT count=0;
#endif

        while (pIoStatusBlock->Status==STATUS_PENDING)
        {
            LARGE_INTEGER   timeout;
            //
            // Wait one millisecond
            //
            timeout.QuadPart = -1i64*1000i64*10i64;
            NtDelayExecution (FALSE, &timeout);
#if DBG
            if (count++>10*1000)
            {
                DbgPrint ("WSHPGM: Waiting for PGM IOCTL completion for more than 10 seconds!!!!\n");
                DbgBreakPoint ();
            }
#endif
        }
        status = pIoStatusBlock->Status;
    }

    if ((pIoStatusBlock != (PIO_STATUS_BLOCK) &IoStatusBlock) &&
        (WaitForCompletion || !NT_SUCCESS(status)))
    {
        RtlFreeHeap (RtlProcessHeap( ), 0, pIoStatusBlock);
    }

    if (NT_SUCCESS (status))
    {
        return NO_ERROR;
    }
    else
    {
        return NtStatusToSocketError (status);
    }

} // SetTdiInformation


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\inc\drvprocs.h ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    DrvProcs.c

Abstract:

    This file contains the function prototypes in the Driver.

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/



#ifndef _DRVPROCS_H_
#define _DRVPROCS_H_

//
// In Data.c
//
NTSTATUS
FilterAndAddNaksToList(
    IN  tSEND_SESSION       *pSend,
    IN  tNAKS_LIST          *pNaksList
    );

NTSTATUS
InitRDataInfo(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tSEND_SESSION       *pSend
    );

VOID
DestroyRDataInfo(
    IN  tSEND_SESSION   *pSend
    );

BOOLEAN
AnyMoreNaks(
    IN  tSEND_RDATA_CONTEXT *pRData
    );

BOOLEAN
GetNextNakIndex(
    IN  tSEND_RDATA_CONTEXT *pRData,
    OUT UCHAR               *pNakIndex
    );

PSEND_RDATA_CONTEXT
AnyRequestPending(
    IN  tRDATA_INFO         *pRDataInfo
    );

VOID
UpdateRDataTrailingEdge(
    IN  tRDATA_INFO         *pRDataInfo,
    IN  SEQ_TYPE            SeqNum
    );

PSEND_RDATA_CONTEXT
FindFirstEntry(
    IN  tSEND_SESSION       *pSend,
    IN  tSEND_RDATA_CONTEXT **ppRDataLast,
    IN  BOOLEAN             fIgnoreWaitTime
    );

ULONG
RemoveAllEntries(
    IN  tSEND_SESSION       *pSend,
    IN  BOOLEAN             fForceRemoveAll
    );

VOID
RemoveEntry(
    IN  tRDATA_INFO         *pRDataInfo,
    IN  tSEND_RDATA_CONTEXT *pRData
    );

VOID
DestroyEntry(
    IN  tRDATA_INFO         *pRDataInfo,
    IN  tSEND_RDATA_CONTEXT *pRData
    );

LIST_ENTRY  *
InitReceiverData(
    IN  tRECEIVE_SESSION        *pReceive
    );

tNAK_FORWARD_DATA   *
FindReceiverEntry(
    IN  tRECEIVE_CONTEXT        *pReceiver,
    IN  SEQ_TYPE                SeqNum
    );

VOID
AppendPendingReceiverEntry(
    IN  tRECEIVE_CONTEXT        *pReceiver,
    IN  tNAK_FORWARD_DATA       *pNak
    );

VOID
RemovePendingReceiverEntry(
    IN  tNAK_FORWARD_DATA       *pNak
    );

VOID
RemoveAllPendingReceiverEntries(
    IN  tRECEIVE_CONTEXT        *pReceiver
    );

//
// In Driver.c
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

VOID
PgmUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
PgmIoComplete(
    IN  PIRP            pIrp,
    IN  NTSTATUS        Status,
    IN  ULONG           SentLength
    );

NTSTATUS
PgmCheckSetCancelRoutine(
    IN  PIRP            pIrp,
    IN  PVOID           CancelRoutine,
    IN  BOOLEAN         fLocked
    );

NTSTATUS
PgmCancelCancelRoutine(
    IN  PIRP            pIrp
    );

//
// In Init.c
//
BOOLEAN
PgmFipsInitialize(
    VOID
    );

NTSTATUS
InitPgm(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

VOID
CleanupInit(
    enum eCLEANUP_STAGE     CleanupStage
    );

NTSTATUS
InitStaticPgmConfig(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

NTSTATUS
InitDynamicPgmConfig(
    );

NTSTATUS
PgmReadRegistryParameters(
    IN  PUNICODE_STRING         RegistryPath,
    OUT tPGM_REGISTRY_CONFIG    **pPgmDynamic
    );

NTSTATUS
AllocateInitialPgmStructures(
    );

NTSTATUS
PgmCreateDevice(
    );

VOID
PgmDereferenceDevice(
    IN OUT  tPGM_DEVICE **ppPgmDevice,
    IN      ULONG       RefContext
    );

//
// In TdiPnP.c
//
BOOLEAN
SrcIsUs(
    tIPADDRESS  IpAddress
    );

BOOLEAN
SrcIsOnLocalSubnet(
    tIPADDRESS  IpAddress
    );

NTSTATUS
SetTdiHandlers(
    );

NTSTATUS
GetIpInterfaceIndexFromAddress(
    IN  tIPADDRESS      NetIpAddr,
    OUT ULONG           *pIPInterfaceIndex
    );

NTSTATUS
ListenOnAllInterfaces(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  PGMLockHandle       *pOldIrqDynamicConfig,
    IN  PGMLockHandle       *pOldIrqAddress
    );

VOID
StopListeningOnAllInterfacesExcept(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  PVOID               Data1,
    IN  PVOID               Unused
    );

//
// In Tdi.c
//
NTSTATUS
TdiOpenAddressHandle(
    IN  tPGM_DEVICE     *pPgmDevice,
    IN  PVOID           HandlerContext,
    IN  ULONG           IpAddress,
    IN  USHORT          PortNumber,
    OUT HANDLE          *pFileHandle,
    OUT PFILE_OBJECT    *ppFileObject,
    OUT PDEVICE_OBJECT  *ppDeviceObject
    );

NTSTATUS
CloseAddressHandles(
    IN  HANDLE          FileHandle,
    IN  PFILE_OBJECT    pFileObject
    );

NTSTATUS
PgmTdiOpenControl(
    IN  tPGM_DEVICE         *pPgmDevice
    );

NTSTATUS
PgmSetTcpInfo(
    IN HANDLE       FileHandle,
    IN ULONG        ToiId,
    IN PVOID        pData,
    IN ULONG        DataLength
    );

NTSTATUS
PgmQueryTcpInfo(
    IN  HANDLE       FileHandle,
    IN  ULONG        ToiId,
    IN  PVOID        pDataIn,
    IN  ULONG        DataInLength,
    OUT PVOID        *ppDataOut,
    OUT ULONG        *pDataOutLength
    );

VOID
PgmDereferenceControl(
    IN  tCONTROL_CONTEXT    *pControlContext,
    IN  ULONG               RefContext
    );

NTSTATUS
TdiSendDatagram(
    IN  PFILE_OBJECT                pTdiFileObject,
    IN  PDEVICE_OBJECT              pTdiDeviceObject,
    IN  PVOID                       pBuffer,
    IN  ULONG                       BufferLength,
    IN  pCLIENT_COMPLETION_ROUTINE  pClientCompletionRoutine,
    IN  PVOID                       ClientCompletionContext1,
    IN  PVOID                       ClientCompletionContext2,
    IN  tIPADDRESS                  DestIpAddress,
    IN  USHORT                      DestPort,
    IN  BOOLEAN                     fPagedBuffer
    );

NTSTATUS
PgmProcessIPRequest(
    IN ULONG        IOControlCode,
    IN PVOID        pInBuffer,
    IN ULONG        InBufferLen,
    OUT PVOID       *pOutBuffer,
    IN OUT ULONG    *pOutBufferLen
    );

//
// In Address.c
//
BOOLEAN
GetIpAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *pTransportAddr,
    IN  ULONG                       BufferLength,   // Total Buffer length
    OUT tIPADDRESS                  *pIpAddress,
    OUT USHORT                      *pPort
    );

NTSTATUS
PgmCreateAddress(
    IN  tPGM_DEVICE                 *pPgmDevice,
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp,
    IN  PFILE_FULL_EA_INFORMATION   TargetEA
    );

VOID
PgmDestroyAddress(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  PVOID               Unused1,
    IN  PVOID               Unused2
    );

VOID
PgmDereferenceAddress(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  ULONG               RefContext
    );

NTSTATUS
PgmCleanupAddress(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  PIRP                pIrp
    );

NTSTATUS
PgmCloseAddress(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmAssociateAddress(
    IN  tPGM_DEVICE                 *pPgmDevice,
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp
    );

NTSTATUS
PgmDisassociateAddress(
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp
    );

NTSTATUS
PgmSetEventHandler(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmSetMCastOutIf(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
SetSenderMCastOutIf(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tIPADDRESS          IpAddress       // Net format
    );

NTSTATUS
ReceiverAddMCastIf(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tIPADDRESS          IpAddress,                  // In host format
    IN  PGMLockHandle       *pOldIrqDynamicConfig,
    IN  PGMLockHandle       *pOldIrqAddress
    );

NTSTATUS
PgmAddMCastReceiveIf(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmDelMCastReceiveIf(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmSetWindowSizeAndSendRate(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmQueryWindowSizeAndSendRate(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmSetWindowAdvanceRate(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmQueryWindowAdvanceRate(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmSetLateJoinerPercentage(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmQueryLateJoinerPercentage(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmSetWindowAdvanceMethod(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmQueryWindowAdvanceMethod(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmSetNextMessageBoundary(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmSetMCastTtl(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmSetFECInfo(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmQueryFecInfo(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmQueryHighSpeedOptimization(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmSetHighSpeedOptimization(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmQuerySenderStats(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmQueryReceiverStats(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

//
// In Connect.c
//
NTSTATUS
PgmCreateConnection(
    IN  tPGM_DEVICE                 *pPgmDevice,
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp,
    IN  PFILE_FULL_EA_INFORMATION   TargetEA
    );

VOID
PgmDereferenceSessionCommon(
    IN  tSEND_SESSION       *pSend,
    IN  ULONG               Verify,
    IN  ULONG               RefContext
    );

NTSTATUS
PgmCleanupConnection(
    IN  tCOMMON_SESSION_CONTEXT *pConnect,
    IN  PIRP                    pIrp
    );

NTSTATUS
PgmCloseConnection(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
PgmConnect(
    IN  tPGM_DEVICE                 *pPgmDevice,
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp
    );

NTSTATUS
PgmDisconnect(
    IN  tPGM_DEVICE                 *pPgmDevice,
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp
    );

NTSTATUS
PgmSetRcvBufferLength(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

//
// In Receive.c
//
VOID
RemovePendingIrps(
    IN  tRECEIVE_SESSION    *pReceive,
    IN  LIST_ENTRY          *pIrpsList
    );

NTSTATUS
ProcessOptions(
    IN  tPACKET_OPTION_LENGTH UNALIGNED *pPacketExtension,
    IN  ULONG                           BytesAvailable,
    IN  ULONG                           PacketType,
    OUT tPACKET_OPTIONS                 *pPacketOptions,
    OUT tNAKS_LIST                      *pNaksList
    );

VOID
CleanupPendingNaks(
    IN  tRECEIVE_SESSION                *pReceive,
    IN  PVOID                           fDerefReceive,
    IN  PVOID                           fReceiveLockHeld
    );

NTSTATUS
ExtractNakNcfSequences(
    IN  tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED  *pNakNcfPacket,
    IN  ULONG                                   BytesAvailable,
    OUT tNAKS_LIST                              *pNakNcfList,
    OUT SEQ_TYPE                                *pLastSequenceNumber,
    IN  UCHAR                                   FECGroupSize
    );

NTSTATUS
TdiRcvDatagramHandler(
    IN PVOID                pDgramEventContext,
    IN INT                  SourceAddressLength,
    IN PVOID                pSourceAddress,
    IN INT                  OptionsLength,
    IN PVOID                pOptions,
    IN ULONG                ReceiveDatagramFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT ULONG               *pBytesTaken,
    IN PVOID                pTsdu,
    OUT PIRP                *ppIrp
    );

VOID
ReceiveTimerTimeout(
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArg1,
    IN  PVOID   SystemArg2
    );

VOID
PgmCancelReceiveIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

NTSTATUS
PgmReceive(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

//
// In Send.c
//
VOID
PgmDereferenceSendContext(
    IN  tCLIENT_SEND_REQUEST        *pSendDataContext
    );

NTSTATUS
PgmBuildSenderPacketHeaders(
    IN  tSEND_SESSION   *pSend
    );

VOID
SendSessionTimeout(
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArg1,
    IN  PVOID   SystemArg2
    );

NTSTATUS
PgmSendRequestFromClient(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
SenderProcessNakPacket(
    IN  tADDRESS_CONTEXT                        *pAddress,
    IN  tSEND_SESSION                           *pSend,
    IN  ULONG                                   BytesIndicated,
    IN  tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED  *pNakPacket
    );

//
// In Query.c
//
NTSTATUS
PgmQueryInformation(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    );

//
// In Utils.c
//
VOID
GetRandomData(
    IN  PUCHAR  pBuffer,
    IN  ULONG   BufferSize
    );

ULONG
GetRandomInteger(
    IN  ULONG   StartRange,
    IN  ULONG   EndRange
    );

NTSTATUS
PgmQueueForDelayedExecution(
    IN  PVOID                   DelayedWorkerRoutine,
    IN  PVOID                   Context1,
    IN  PVOID                   Context2,
    IN  PVOID                   Context3,
    IN  BOOLEAN                 fConfigLockHeld
    );

typedef
VOID
(*PPGM_WORKER_ROUTINE) (PVOID   Context1,
                        PVOID   Context2,
                        PVOID   Context3);

#ifdef  OLD_LOGGING
NTSTATUS
PgmLog(
    IN  enum eSEVERITY_LEVEL    Severity,
    IN  ULONG                   Path,
    IN  PUCHAR                  pszFunctionName,
    IN  PUCHAR                  Format,
    ...
    );
#endif  // OLD_LOGGING

//
// In FileIo.c
//
NTSTATUS
PgmCreateDataFileAndMapSection(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tSEND_SESSION       *pSend
    );

NTSTATUS
PgmCopyDataToBuffer(
    IN  tSEND_SESSION   *pSend,
    IN  PMDL            pMdlChain,
    IN  ULONG           DataSize,
    OUT ULONG           *pNumDataPackets,
    OUT ULONG           *pStartOffset
    );

NTSTATUS
PgmUnmapAndCloseDataFile(
    IN  tSEND_SESSION   *pSend
    );

//
// In FEC.c
//
NTSTATUS
FECInitGlobals(
    );

NTSTATUS
CreateFECContext(
    IN  tFEC_CONTEXT    *pFec,
    IN  LONG            k,
    IN  LONG            n,
    IN  BOOLEAN         fFECDecoder
    );

VOID
DestroyFECContext(
    tFEC_CONTEXT    *pFec
    );

NTSTATUS
FECEncode(
    IN  tFEC_CONTEXT    *pFec,
    IN  PUCHAR          pBlocks[],
    IN  LONG            GroupSize,
    IN  LONG            BlockSize,
    IN  LONG            Index,
    OUT PUCHAR          pEncoded
    );

NTSTATUS
FECDecode(
    IN      tFEC_CONTEXT    *pFec,
    IN OUT  tPENDING_DATA   *pDataBlocks,
    IN      LONG            BlockSize,
    IN      LONG            k
    );

//
// In Security.c
//
NTSTATUS
PgmBuildAdminSecurityDescriptor(
    OUT SECURITY_DESCRIPTOR     **ppSecurityDescriptor
    );

NTSTATUS
PgmGetUserInfo(
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp,
    OUT TOKEN_USER                  **ppUserId,
    OUT BOOLEAN                     *pfUserIsAdmin
    );

//
// In xsum.<arch>
//
ULONG
tcpxsum(
    ULONG   Seed,
    CHAR    *Ptr,
    ULONG   Length
    );
#endif // _DRVPROCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\inc\macroes.h ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Macroes.h

Abstract:

    This module contains definitions of commonly used macroes

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#ifndef _MACROES_H_
#define _MACROES_H_

#ifdef  OLD_LOGGING
#define     MAX_DEBUG_MESSAGE_LENGTH   300

//
// Debug Flags
//
#define DBG_ENABLE_DBGPRINT 0x00000001
#define DBG_DRIVER_ENTRY    0x00000002
#define DBG_INIT_PGM        0x00000004
#define DBG_DEBUG_REF       0x00000008
#define DBG_PNP             0x00000010
#define DBG_TDI             0x00000020
#define DBG_ADDRESS         0x00000040
#define DBG_CONNECT         0x00000080
#define DBG_QUERY           0x00000100
#define DBG_SEND            0x00000200
#define DBG_RECEIVE         0x00000400
#define DBG_FILEIO          0x00000800
#define DBG_FEC             0x00001000

//
// DbgPrint macroes
//

enum eSEVERITY_LEVEL
{
    PGM_LOG_DISABLED,           // No logging!
    PGM_LOG_CRITICAL_ERROR,     // Major errors which can seriously affect functionality
    PGM_LOG_ERROR,              // Common errors which do not affect the system as a whole
    PGM_LOG_INFORM_STATUS,      // Mostly to verify major functionality was executed
    PGM_LOG_INFORM_ALL_FUNCS,   // 1 per function to allow path tracking (not req if printing all code paths)
    PGM_LOG_INFORM_PATH,        // Interspersed throughout function to trace If paths
    PGM_LOG_INFORM_DETAIL,      // while loops, etc
    PGM_LOG_INFORM_REFERENCES,  // 
    PGM_LOG_EVERYTHING
};
#endif  // OLD_LOGGING


#ifdef  FILE_LOGGING
#define WPP_CONTROL_GUIDS   WPP_DEFINE_CONTROL_GUID(CtlGuid,(681507e2,356e,4e18,8d5a,a8eddedadf5d), \
        WPP_DEFINE_BIT(LogCriticalError)                                   \
        WPP_DEFINE_BIT(LogError)                                           \
        WPP_DEFINE_BIT(LogStatus)                                          \
        WPP_DEFINE_BIT(LogFec)                                             \
        WPP_DEFINE_BIT(LogAllFuncs)                                        \
        WPP_DEFINE_BIT(LogPath)                                            \
        WPP_DEFINE_BIT(LogReferences)                                      \
        WPP_DEFINE_BIT(LogEverything)                                      \
    )
#else

#if DBG
enum eLOGGING_LEVEL
{
    LogDisabled,                // No logging!
    LogCriticalError,           // Major errors which can seriously affect functionality
    LogError,                   // Common errors which do not affect the system as a whole
    LogStatus,                  // Mostly to verify major functionality was executed
    LogFec,                     // FEC
    LogAllFuncs,                // 1 per function to allow path tracking (not req if printing all code paths)
    LogPath,                    // Interspersed throughout function to trace If paths
    LogReferences,              // 
    LogEverything
};

#define PgmTrace(X,Y)           \
    if (X <= PgmLoggingLevel)   \
    {                           \
        DbgPrint ("RMCast.");   \
        DbgPrint Y;             \
    }
#else
#define PgmTrace(X,Y)
#endif  // DBG

#endif  // FILE_LOGGING


#if DBG
//
// ASSERT
//
#undef ASSERT
#define ASSERT(exp)                             \
if (!(exp))                                     \
{                                               \
    DbgPrint("Assertion \"%s\" failed at file %s, line %d\n", #exp, __FILE__, __LINE__ );           \
    if (!PgmDynamicConfig.DoNotBreakOnAssert)   \
    {                                           \
        DbgBreakPoint();                        \
    }                                           \
}
#endif  // DBG


//
// Data/pointer verification
//
#define PGM_VERIFY_HANDLE(p, V)                                             \
    ((p) && (p->Verify == V))

#define PGM_VERIFY_HANDLE2(p, V1, V2)                                       \
    ((p) && ((p->Verify == V1) || (p->Verify == V2)))

#define PGM_VERIFY_HANDLE3(p, V1, V2, V3)                                   \
    ((p) && ((p->Verify == V1) || (p->Verify == V2) || (p->Verify == V3)))

//----------------------------------------------------------------------------
//
// Sequence number macroes
//

#define SEQ_LT(a,b)     ((SIGNED_SEQ_TYPE)((a)-(b)) < 0)
#define SEQ_LEQ(a,b)    ((SIGNED_SEQ_TYPE)((a)-(b)) <= 0)
#define SEQ_GT(a,b)     ((SIGNED_SEQ_TYPE)((a)-(b)) > 0)
#define SEQ_GEQ(a,b)    ((SIGNED_SEQ_TYPE)((a)-(b)) >= 0)


//----------------------------------------------------------------------------

//
// Definitions:
//
#define IS_MCAST_ADDRESS(IpAddress) ((((PUCHAR)(&IpAddress))[3]) >= ((UCHAR)0xe0))
#define CLASSD_ADDR(a)  (( (*((uchar *)&(a))) & 0xf0) == 0xe0)

//
// Alloc and Free macroes
//
#define PGM_TAG(x) (((x)<<24)|'\0mgP')
#define PgmAllocMem(_Size, _Tag)   \
    ExAllocatePoolWithTag(NonPagedPool, (_Size),(_Tag))

#define PgmFreeMem(_Ptr)            ExFreePool(_Ptr)

//
// Misc Ke + Ex macroes
//
#define PgmGetCurrentIrql   KeGetCurrentIrql
#define PgmInterlockedInsertTailList(_pHead, _pEntry, _pStruct) \
     ExInterlockedInsertTailList(_pHead, _pEntry, &(_pStruct)->LockInfo.SpinLock);

//----------------------------------------------------------------------------
//
// PgmAcquireResourceExclusive (Resource, Wait)
//
/*++
Routine Description:

    Acquires the Resource by calling an executive support routine.

Arguments:


Return Value:

    None

--*/
//
// Resource Macros
//
#define PgmAcquireResourceExclusive( _Resource, _Wait )     \
    KeEnterCriticalRegion();                                \
    ExAcquireResourceExclusiveLite(_Resource,_Wait);

//----------------------------------------------------------------------------
//
// PgmReleaseResource (Resource)
//
/*++
Routine Description:

    Releases the Resource by calling an excutive support routine.

Arguments:


Return Value:

    None

--*/
#define PgmReleaseResource( _Resource )         \
    ExReleaseResourceLite(_Resource);           \
    KeLeaveCriticalRegion();

//----------------------------------------------------------------------------
//++
//
// LARGE_INTEGER
// PgmConvert100nsToMilliseconds(
//     IN LARGE_INTEGER HnsTime
//     );
//
// Routine Description:
//
//     Converts time expressed in hundreds of nanoseconds to milliseconds.
//
// Arguments:
//
//     HnsTime - Time in hundreds of nanoseconds.
//
// Return Value:
//
//     Time in milliseconds.
//
//--

#define SHIFT10000 13
static LARGE_INTEGER Magic10000 = {0xe219652c, 0xd1b71758};

#define PgmConvert100nsToMilliseconds(HnsTime) \
            RtlExtendedMagicDivide((HnsTime), Magic10000, SHIFT10000)

//----------------------------------------------------------------------------

//
// Lock Macroes
//
#if DBG
#define PgmInitLock(_Struct, _N)                            \
    KeInitializeSpinLock (&(_Struct)->LockInfo.SpinLock);   \
    (_Struct)->LockInfo.LockNumber = _N;
#else
#define PgmInitLock(_Struct, _N)                            \
    KeInitializeSpinLock (&(_Struct)->LockInfo.SpinLock);
#endif  // DBG

typedef KIRQL       PGMLockHandle;

#if DBG
#define PgmLock(_Struct, _OldIrqLevel)                                                      \
{                                                                                           \
    ULONG  CurrProc;                                                                        \
    ExAcquireSpinLock (&(_Struct)->LockInfo.SpinLock, &(_OldIrqLevel));                     \
    CurrProc = KeGetCurrentProcessorNumber();                                               \
    ASSERT ((_Struct)->LockInfo.LockNumber > PgmDynamicConfig.CurrentLockNumber[CurrProc]); \
    PgmDynamicConfig.CurrentLockNumber[CurrProc] |= (_Struct)->LockInfo.LockNumber;         \
    (_Struct)->LockInfo.LastLockLine = __LINE__;                                            \
}

#define PgmLockAtDpc(_Struct)                                                               \
{                                                                                           \
    ULONG  CurrProc;                                                                        \
    ExAcquireSpinLockAtDpcLevel (&(_Struct)->LockInfo.SpinLock);                            \
    CurrProc = KeGetCurrentProcessorNumber();                                               \
    ASSERT ((_Struct)->LockInfo.LockNumber > PgmDynamicConfig.CurrentLockNumber[CurrProc]); \
    PgmDynamicConfig.CurrentLockNumber[CurrProc] |= (_Struct)->LockInfo.LockNumber;         \
    (_Struct)->LockInfo.LastLockLine = __LINE__;                                            \
}

#define PgmUnlock(_Struct, _OldIrqLevel)                                                    \
{                                                                                           \
    ULONG  CurrProc = KeGetCurrentProcessorNumber();                                        \
    ASSERT (PgmDynamicConfig.CurrentLockNumber[CurrProc] & (_Struct)->LockInfo.LockNumber); \
    PgmDynamicConfig.CurrentLockNumber[CurrProc] &= ~((_Struct)->LockInfo.LockNumber);      \
    (_Struct)->LockInfo.LastUnlockLine = __LINE__;                                          \
    ExReleaseSpinLock (&(_Struct)->LockInfo.SpinLock, _OldIrqLevel);                        \
}
// ASSERT ((_Struct)->LockInfo.LockNumber > PgmDynamicConfig.CurrentLockNumber[CurrProc]);

#define PgmUnlockAtDpc(_Struct)                                                             \
{                                                                                           \
    ULONG  CurrProc = KeGetCurrentProcessorNumber();                                        \
    ASSERT (PgmDynamicConfig.CurrentLockNumber[CurrProc] & (_Struct)->LockInfo.LockNumber); \
    PgmDynamicConfig.CurrentLockNumber[CurrProc] &= ~((_Struct)->LockInfo.LockNumber);      \
    (_Struct)->LockInfo.LastUnlockLine = __LINE__;                                          \
    ExReleaseSpinLockFromDpcLevel (&(_Struct)->LockInfo.SpinLock);                          \
}
// ASSERT ((_Struct)->LockInfo.LockNumber > PgmDynamicConfig.CurrentLockNumber[CurrProc]); \

#else
#define PgmLock(_Struct, _OldIrqLevel)        \
    ExAcquireSpinLock (&(_Struct)->LockInfo.SpinLock, &(_OldIrqLevel));

#define PgmLockAtDpc(_Struct)        \
    ExAcquireSpinLockAtDpcLevel (&(_Struct)->LockInfo.SpinLock);

#define PgmUnlock(_Struct, _OldIrqLevel)        \
    ExReleaseSpinLock (&(_Struct)->LockInfo.SpinLock, _OldIrqLevel);                     \

#define PgmUnlockAtDpc(_Struct)        \
    ExReleaseSpinLockFromDpcLevel (&(_Struct)->LockInfo.SpinLock);                     \

#endif  // DBG

//
// Memory management macroes
//
#define PgmZeroMemory                   RtlZeroMemory
#define PgmMoveMemory                   RtlMoveMemory
#define PgmCopyMemory                   RtlCopyMemory
#define PgmEqualMemory(_a, _b, _n)      memcmp(_a,_b,_n)

//
// Timer Macroes
//
#define MILLISEC_TO_100NS   10000
#define PgmInitTimer(_PgmTimer)    \
    KeInitializeTimer (&((_PgmTimer)->t_timer));

#define PgmStartTimer(_PgmTimer, _DeltaTimeInMilliSecs, _TimerExpiryRoutine, _Context)  \
{                                                                                       \
    LARGE_INTEGER   Time;                                                               \
    Time.QuadPart = UInt32x32To64 (_DeltaTimeInMilliSecs, MILLISEC_TO_100NS);           \
    Time.QuadPart = -(Time.QuadPart);                                                   \
    KeInitializeDpc (&((_PgmTimer)->t_dpc), (PVOID)_TimerExpiryRoutine, _Context);      \
    KeSetTimer (&((_PgmTimer)->t_timer), Time, &((_PgmTimer))->t_dpc);                  \
}

#define PgmStopTimer(_PgmTimer)     \
    ((int) KeCancelTimer(&((_PgmTimer)->t_timer)))

//
// Referencing and dereferencing macroes
//
#define PGM_REFERENCE_DEVICE( _pPgmDevice, _RefContext, _fLocked)   \
{                                                                   \
    PGMLockHandle       OldIrq;                                     \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmLock (_pPgmDevice, OldIrq);                              \
    }                                                               \
    ASSERT (PGM_VERIFY_HANDLE (_pPgmDevice, PGM_VERIFY_DEVICE));    \
    ASSERT (++_pPgmDevice->ReferenceContexts[_RefContext]);         \
    ++_pPgmDevice->RefCount;                                        \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmUnlock (_pPgmDevice, OldIrq);                            \
    }                                                               \
}

/*
    PgmTrace (LogPath, (                                            \
        "\t++pPgmDevice[%x]=<%x:%d->%d>, <%d:%s>\n",                \
            _RefContext, _pPgmDevice,_pPgmDevice->RefCount,(_pPgmDevice->RefCount+1),__LINE__,__FILE__));   \
*/

#define PGM_REFERENCE_CONTROL( _pControl, _RefContext, _fLocked)    \
{                                                                   \
    PGMLockHandle       OldIrq;                                     \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmLock (_pControl, OldIrq);                                \
    }                                                               \
    ASSERT (PGM_VERIFY_HANDLE (_pControl, PGM_VERIFY_CONTROL));     \
    ASSERT (++_pControl->ReferenceContexts[_RefContext]);           \
    ++_pControl->RefCount;                                          \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmUnlock (_pControl, OldIrq);                              \
    }                                                               \
}

/*
    PgmTrace (LogPath, (                                            \
        "\t++pControl[%x]=<%x:%d->%d>, <%d:%s>\n",                  \
            _RefContext, _pControl,_pControl->RefCount,(_pControl->RefCount+1),__LINE__,__FILE__)); \
*/

#define PGM_REFERENCE_ADDRESS( _pAddress, _RefContext, _fLocked)    \
{                                                                   \
    PGMLockHandle       OldIrq;                                     \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmLock (_pAddress, OldIrq);                                \
    }                                                               \
    ASSERT (PGM_VERIFY_HANDLE (_pAddress, PGM_VERIFY_ADDRESS));     \
    ASSERT (++_pAddress->ReferenceContexts[_RefContext]);           \
    ++_pAddress->RefCount;                                          \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmUnlock (_pAddress, OldIrq);                              \
    }                                                               \
}

/*
    PgmTrace (LogPath, (                                            \
        "\t++pAddress[%x]=<%x:%d->%d>, <%d:%s>\n",                  \
            _RefContext, _pAddress,_pAddress->RefCount,(_pAddress->RefCount+1),__LINE__,__FILE__)); \
*/

#define PGM_REFERENCE_SEND_DATA_CONTEXT( _pSendDC, _fLocked)        \
{                                                                   \
    PGMLockHandle       OldIrq;                                     \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmLock (_pSendDC->pSend, OldIrq);                          \
    }                                                               \
    ASSERT (PGM_VERIFY_HANDLE (_pSendDC, PGM_VERIFY_SEND_DATA_CONTEXT));    \
    ++_pSendDC->RefCount;                                           \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmUnlock (_pSendDC, OldIrq);                               \
    }                                                               \
}

/*
    PgmTrace (LogPath, (                                            \
        "\t++pSendDataContext[%x]=<%x:%d->%d>, <%d:%s>\n",          \
            _RefContext, _pSendDC,_pSendDC->RefCount,(_pSendDC->RefCount+1),__LINE__,__FILE__)); \
*/

#define PGM_REFERENCE_SESSION( _pSession, _Verify, _RefContext, _fLocked)    \
{                                                                   \
    PGMLockHandle       OldIrq;                                     \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmLock (_pSession, OldIrq);                                    \
    }                                                               \
    ASSERT (PGM_VERIFY_HANDLE2 (_pSession, _Verify, PGM_VERIFY_SESSION_DOWN)); \
    ASSERT (++_pSession->ReferenceContexts[_RefContext]);               \
    ++_pSession->RefCount;                                              \
    if (!_fLocked)                                                  \
    {                                                               \
        PgmUnlock (_pSession, OldIrq);                                  \
    }                                                               \
}

/*
    PgmTrace (LogPath, (                                            \
        "\t++pSession[%x]=<%x:%d->%d>, <%d:%s>\n",                  \
            _RefContext, _pSession,_pSession->RefCount,(_pSession->RefCount+1),__LINE__,__FILE__));     \
*/

#define PGM_REFERENCE_SESSION_SEND( _pSend, _RefContext, _fLocked)  \
    PGM_REFERENCE_SESSION (_pSend, PGM_VERIFY_SESSION_SEND, _RefContext, _fLocked)

#define PGM_REFERENCE_SESSION_RECEIVE( _pRcv, _RefContext, _fLocked)\
    PGM_REFERENCE_SESSION (_pRcv, PGM_VERIFY_SESSION_RECEIVE, _RefContext, _fLocked)

#define PGM_REFERENCE_SESSION_UNASSOCIATED( _pRcv, _RefContext, _fLocked)\
    PGM_REFERENCE_SESSION (_pRcv, PGM_VERIFY_SESSION_UNASSOCIATED, _RefContext, _fLocked)


//
// Dereferencing ...
//

#define PGM_DEREFERENCE_DEVICE( _pDevice, _RefContext)              \
{                                                                   \
    PgmDereferenceDevice (_pDevice, _RefContext);                   \
}

/*
    PgmTrace (LogPath, (                                            \
        "\t--pDevice[%x]=<%x:%d->%d>, <%d:%s>\n",                   \
            _RefContext, _pDevice,_pDevice->RefCount,(_pDevice->RefCount-1),__LINE__,__FILE__));    \
*/

#define PGM_DEREFERENCE_CONTROL( _pControl, _RefContext)            \
{                                                                   \
    PgmDereferenceControl (_pControl, _RefContext);                 \
}

/*
    PgmTrace (LogPath, (                                            \
        "\t--pControl[%x]=<%x:%d->%d>, <%d:%s>\n",                  \
            _RefContext, _pControl,_pControl->RefCount,(_pControl->RefCount-1),__LINE__,__FILE__)); \
*/

#define PGM_DEREFERENCE_ADDRESS( _pAddress, _RefContext)            \
{                                                                   \
    PgmDereferenceAddress (_pAddress, _RefContext);                 \
}

/*
    PgmTrace (LogPath, (                                            \
        "\t--pAddress[%x]=<%x:%d->%d>, <%d:%s>\n",                  \
            _RefContext, _pAddress,_pAddress->RefCount,(_pAddress->RefCount-1),__LINE__,__FILE__)); \
*/

#define PGM_DEREFERENCE_SEND_CONTEXT( _pSendDC)                     \
{                                                                   \
    PgmDereferenceSendContext (_pSendDC);                 \
}

/*
    PgmTrace (LogPath, (                                            \
        "\t--pSendDC=<%x:%d->%d>, <%d:%s>\n",                  \
            _pSendDC,_pSendDC->RefCount,(_pSendDC->RefCount-1),__LINE__,__FILE__)); \
*/

#define PGM_DEREFERENCE_SESSION( _pSession, _Verify, _RefContext)   \
{                                                                   \
    PgmDereferenceSessionCommon (_pSession, _Verify, _RefContext);  \
}

/*
    PgmTrace (LogPath, (                                            \
        "\t--pSession[%x]=<%x:%d->%d>, Verify=<%x>, <%d:%s>\n",     \
            _RefContext, _pSession,_pSession->RefCount,(_pSession->RefCount-1),_Verify,__LINE__,__FILE__)); \
*/

#define PGM_DEREFERENCE_SESSION_SEND( _pSession, _RefContext)       \
    PGM_DEREFERENCE_SESSION (_pSession, PGM_VERIFY_SESSION_SEND, _RefContext)

#define PGM_DEREFERENCE_SESSION_RECEIVE( _pSession, _RefContext)    \
    PGM_DEREFERENCE_SESSION (_pSession, PGM_VERIFY_SESSION_RECEIVE, _RefContext)

#define PGM_DEREFERENCE_SESSION_UNASSOCIATED( _pSession, _RefContext)    \
    PGM_DEREFERENCE_SESSION (_pSession, PGM_VERIFY_SESSION_UNASSOCIATED, _RefContext)

//----------------------------------------------------------------------------
//
// PgmAttachFsp()
//
/*++
Routine Description:

    This macro attaches a process to the File System Process to be sure
    that handles are created and released in the same process

Arguments:

Return Value:

    none

--*/

#if(WINVER > 0x0500)
#define PgmAttachProcess(_pEProcess, _pApcState, _pAttached, _Context)\
{                                                                   \
    if (PsGetCurrentProcess() !=  _pEProcess)                       \
    {                                                               \
        KeStackAttachProcess(PsGetProcessPcb(_pEProcess), _pApcState);           \
        *_pAttached = TRUE;                                         \
    }                                                               \
    else                                                            \
    {                                                               \
        *_pAttached = FALSE;                                        \
    }                                                               \
}
#else
#define PgmAttachProcess(_pEProcess, _pApcState, _pAttached, _Context)\
{                                                                   \
    if (PsGetCurrentProcess() !=  _pEProcess)                       \
    {                                                               \
        KeStackAttachProcess(&_pEProcess->Pcb, _pApcState);         \
        *_pAttached = TRUE;                                         \
    }                                                               \
    else                                                            \
    {                                                               \
        *_pAttached = FALSE;                                        \
    }                                                               \
}
#endif  // WINVER

#define PgmAttachFsp(_pApcState, _pAttached, _Context)              \
    PgmAttachProcess (PgmStaticConfig.FspProcess, _pApcState, _pAttached, _Context)

#define PgmAttachToProcessForVMAccess(_pSend, _pApcState, _pAttached, _Context) \
    PgmAttachProcess (PgmStaticConfig.FspProcess, _pApcState, _pAttached, _Context)


//    PgmAttachProcess ((_pSend)->Process, _pAttached, _Context)

//
// PgmDetachFsp()
//
/*++
Routine Description:

    This macro detaches a process from the File System Process
    if it was ever attached

Arguments:

Return Value:

--*/

#define PgmDetachProcess(_pApcState, _pAttached, _Context)  \
{                                                           \
    if (*_pAttached)                                        \
    {                                                       \
        KeUnstackDetachProcess(_pApcState);                 \
    }                                                       \
}

#define PgmDetachFsp    PgmDetachProcess

//----------------------------------------------------------------------------
#endif  _MACROES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\inc\types.h ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Types.h

Abstract:

    This file contains the typedefs and constants for PGM.

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#ifndef _TYPES_H
#define _TYPES_H


#if(WINVER > 0x0500)
#if DBG
// #define FILE_LOGGING    1
#else
#define FILE_LOGGING    1
#endif  // DBG
#endif  // WINVER

// #define FEC_DBG         1

#ifdef DROP_DBG
extern  ULONG   DropCount;
#endif  // DROP_DBG

//----------------------------------------------------------------------------
#define MAX_BUFF_DBG    1   // To debug Watermarks!
// #define IP_FIX          1

//----------------------------------------------------------------------------
#define ROUTER_ALERT_SIZE           4       // from Ipdef.h
#define TL_INSTANCE                 0
//----------------------------------------------------------------------------
//
// To be set sometime:
//
#define MAX_RECEIVE_SIZE    0xffff

//----------------------------------------------------------------------------
extern  HANDLE      TdiClientHandle;

//----------------------------------------------------------------------------

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons(x)        ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))

__inline long
htonl(long x)
{
    return((((x) >> 24) & 0x000000FFL) |
                        (((x) >>  8) & 0x0000FF00L) |
                        (((x) <<  8) & 0x00FF0000L) |
                        (((x) << 24) & 0xFF000000L));
}
#endif

#define ntohs(x)        htons(x)
#define ntohl(x)        htonl(x)

//
// Sequence NumberType
//
typedef ULONG       SEQ_TYPE;
typedef LONG        SIGNED_SEQ_TYPE;

#define SOURCE_ID_LENGTH    6

#ifndef FILE_LOGGING
#if DBG
extern enum eLOGGING_LEVEL  PgmLoggingLevel;
#endif  // DBG
#endif  // !FILE_LOGGING


#ifdef  OLD_LOGGING
extern ULONG                PgmDebuggerPath;
extern enum eSEVERITY_LEVEL PgmDebuggerSeverity;

extern ULONG                PgmLogFilePath;
extern enum eSEVERITY_LEVEL PgmLogFileSeverity;
#endif  // OLD_LOGGING

//
// Lock structure and locking order info
//
#define DCONFIG_LOCK            0x0001
#define DEVICE_LOCK             0x0002
#define ADDRESS_LOCK            0x0004
#define CONTROL_LOCK            0x0008
#define SESSION_LOCK            0x0010

//
// FEC Global Info
//
#define GF_BITS  8                      // code over GF(2**GF_BITS) - change to suit
#define GF_SIZE ((1 << GF_BITS) - 1)    /* powers of \alpha */

#define FEC_MAX_GROUP_BITS  GF_BITS
#define FEC_MAX_GROUP_SIZE  (1 << (FEC_MAX_GROUP_BITS-1))
#define FEC_MAX_BLOCK_SIZE  ((1 << FEC_MAX_GROUP_BITS)-1)
extern  UCHAR   gFECLog2 [];


//
// Enumerate all the different stages of cleanup of the driver
//
enum eCLEANUP_STAGE
{
    E_CLEANUP_STATIC_CONFIG = 1,
    E_CLEANUP_DYNAMIC_CONFIG,
    E_CLEANUP_REGISTRY_PARAMETERS,
    E_CLEANUP_STRUCTURES,
    E_CLEANUP_DEVICE,
    E_CLEANUP_PNP,
    E_CLEANUP_UNLOAD
};

typedef struct
{
    DEFINE_LOCK_STRUCTURE(SpinLock)         // to lock access on an MP machine
#if DBG
    ULONG               LastLockLine;
    ULONG               LastUnlockLine;
    ULONG               LockNumber;         // spin lock number for this struct
#endif  // DBG
} tPGM_LOCK_INFO;


typedef struct _tPGM_TIMER
{
    KTIMER              t_timer;
    KDPC                t_dpc;
} tPGM_TIMER;

//
// Structure used for TDI_QUERY_ADDRESS request
//
typedef struct
{
    ULONG           ActivityCount;
    TA_IP_ADDRESS   IpAddress;
}   tTDI_QUERY_ADDRESS_INFO;


// ----------------------------------------------------

#define     TDI_LOOKASIDE_DEPTH                     100
#define     SENDER_BUFFER_LOOKASIDE_DEPTH           100
#define     SEND_CONTEXT_LOOKASIDE_DEPTH            100
#define     NON_PARITY_CONTEXT_LOOKASIDE_DEPTH      200
#define     PARITY_CONTEXT_LOOKASIDE_DEPTH          200
#define     DEBUG_MESSAGES_LOOKASIDE_DEPTH           20
#define     RDATA_REQUESTS_MIN_LOOKASIDE_DEPTH     1000

typedef struct
{
    PEPROCESS               FspProcess;
    PDRIVER_OBJECT          DriverObject;
    UNICODE_STRING          RegistryPath;           // Ptr to registry Location

    PFILE_OBJECT            FipsFileObject;
    FIPS_FUNCTION_TABLE     FipsFunctionTable;
    BOOLEAN                 FipsInitialized;

    NPAGED_LOOKASIDE_LIST   TdiLookasideList;
#ifdef  OLD_LOGGING
    NPAGED_LOOKASIDE_LIST   DebugMessagesLookasideList;
#endif  // OLD_LOGGING

} tPGM_STATIC_CONFIG;

#define PGM_CONFIG_FLAG_UNLOADING               0x00000001
#define PGM_CONFIG_FLAG_RECEIVE_TIMER_RUNNING   0x00000002

typedef struct
{
    // Line # 1
    LIST_ENTRY          SenderAddressHead;
    LIST_ENTRY          ReceiverAddressHead;

    // Line # 2
    LIST_ENTRY          DestroyedAddresses;
    LIST_ENTRY          ClosedAddresses;

    // Line # 3
    LIST_ENTRY          ClosedConnections;
    LIST_ENTRY          ConnectionsCreated;

    // Line # 4
    LIST_ENTRY          CleanedUpConnections;
    LIST_ENTRY          CurrentReceivers;

    // Line # 5
    LIST_ENTRY          LocalInterfacesList;
    LIST_ENTRY          WorkerQList;

    // Line # 6
    LARGE_INTEGER       TimeoutGranularity;
    LARGE_INTEGER       LastReceiverTimeout;

    // Line # 7
    ULONGLONG           ReceiversTimerTickCount;
    ULONG               GlobalFlags;
    ULONG               NumWorkerThreadsQueued;

    // Line # 8
    UCHAR               gSourceId[SOURCE_ID_LENGTH];
    USHORT              SourcePort;
    ULONG               MaxMTU;
    ULONG               DoNotBreakOnAssert;

    // Line # 9
    tPGM_TIMER          SessionTimer;
    KEVENT              LastWorkerItemEvent;

    tPGM_LOCK_INFO      LockInfo;           // spin lock info for this struct
#if DBG
    ULONG               CurrentLockNumber[MAXIMUM_PROCESSORS];
#endif  // DBG
} tPGM_DYNAMIC_CONFIG;


//
// Flags for Registry configurations
//
#define PGM_REGISTRY_SENDER_FILE_SPECIFIED      0x00000001

typedef struct
{
    ULONG               RefCount;
    ULONG               Flags;

    UNICODE_STRING      ucSenderFileLocation;
} tPGM_REGISTRY_CONFIG;

extern tPGM_STATIC_CONFIG   PgmStaticConfig;
extern tPGM_DYNAMIC_CONFIG  PgmDynamicConfig;
extern tPGM_REGISTRY_CONFIG *pPgmRegistryConfig;

//
// Registry configurable parameter names
//
#define PARAM_SENDER_FILE_LOCATION      L"SenderFileLocation"

//
// Handle Verifiers
//
#define PGM_VERIFY_DEVICE               0x43564544  // DEVC
#define PGM_VERIFY_CONTROL              0x544E4F43  // CONT
#define PGM_VERIFY_ADDRESS              0x52444441  // ADDR
#define PGM_VERIFY_ADDRESS_DOWN         0x32444441  // ADD2

#define PGM_VERIFY_SESSION_UNASSOCIATED 0x30534553  // SES0
#define PGM_VERIFY_SESSION_DOWN         0x32534553  // SES2
#define PGM_VERIFY_SESSION_SEND         0x53534553  // SESS
#define PGM_VERIFY_SESSION_RECEIVE      0x52534553  // SESR

//
// Enumerate all the different places the device can be referenced to
// keep track of RefCounts
//
enum eREF_DEVICE
{
    REF_DEV_CREATE,
    REF_DEV_ADDRESS_NOTIFICATION,
    REF_DEV_MAX
};

#define WC_PGM_CLIENT_NAME              L"Pgm"
#define WC_PGM_DEVICE_EXPORT_NAME       L"\\Device\\Pgm"
#define WS_DEFAULT_SENDER_FILE_LOCATION L"\\SystemRoot\\System32"

typedef struct
{
    DEVICE_OBJECT   *pPgmDeviceObject;
    ULONG           State;
    ULONG           Verify;
    ULONG           RefCount;

    UNICODE_STRING  ucBindName;         // name exported by this device
    // these are handles to the transport control object, so we can do things
    // like query provider info...
    HANDLE          hControl;
    PDEVICE_OBJECT  pControlDeviceObject;
    PFILE_OBJECT    pControlFileObject;

    KEVENT          DeviceCleanedupEvent;

    tPGM_LOCK_INFO  LockInfo;        // spin lock info for this struct

// #if DBG
    ULONG           ReferenceContexts[REF_DEV_MAX];
// #endif  // DBG
    UCHAR           BindNameBuffer[1];
} tPGM_DEVICE;

extern  tPGM_DEVICE         *pgPgmDevice;
extern  DEVICE_OBJECT       *pPgmDeviceObject;


typedef struct
{
    UCHAR   Address[6];
}tMAC_ADDRESS;

typedef struct
{
    LIST_ENTRY      Linkage;
    tIPADDRESS      IpAddress;
    tIPADDRESS      SubnetMask;
} tADDRESS_ON_INTERFACE;

typedef struct
{
    LIST_ENTRY      Linkage;
    LIST_ENTRY      Addresses;

    ULONG           IpInterfaceIndex;
    ULONG           MTU;
    tIPADDRESS      SubnetMask;

    ULONG           Flags;
    tMAC_ADDRESS    MacAddress;
} tLOCAL_INTERFACE;

// **********************************************************************
// *                        File System Contexts                        *
// **********************************************************************

//
// Control FileSystemContext
//
//
// Enumerate all the different places the device can be referenced to
// keep track of RefCounts
//
enum eREF_CONTROL
{
    REF_CONTROL_CREATE,
    REF_CONTROL_MAX
};

typedef struct _tCONTROL_CONTEXT
{
    // Line # 1
    LIST_ENTRY          Linkage;         // link to next item in list
    ULONG               Verify;          // set to a known value to verify block
    LONG                RefCount;

    tPGM_LOCK_INFO      LockInfo;        // spin lock info for this struct

// #if DBG
    ULONG               ReferenceContexts[REF_CONTROL_MAX];
// #endif  // DBG
} tCONTROL_CONTEXT;


typedef struct _FEC_CONTEXT
{
    LONG    k;                          // Max Transmission Group Size
    LONG    n;                          // Block size
    UCHAR   *pEncodeMatrix;
    UCHAR   *pDecodeMatrix;
    ULONG   *pInvertMatrixInfo;
} tFEC_CONTEXT, *PFEC_CONTEXT;

typedef struct _BUILD_PARITY_CONTEXT
{
    UCHAR                   NextFECPacketIndex;
    UCHAR                   NumPacketsInThisGroup;
    USHORT                  Pad;

    ULONG                   OptionsFlags;
    PUCHAR                  pDataBuffers[1];
} tBUILD_PARITY_CONTEXT;

//
// This is the client-procedure to be called on completing a send
//
typedef VOID
(*pCLIENT_COMPLETION_ROUTINE) (PVOID    pSendContext1,
                               PVOID    pSendContext2,
                               NTSTATUS status);


//
// Address FileSystemContext
//
//
// Enumerate all the different places the device can be referenced to
// keep track of RefCounts
//
enum eREF_ADDRESS
{
    REF_ADDRESS_CREATE,
    REF_ADDRESS_VERIFY_USER,
    REF_ADDRESS_ASSOCIATED,
    REF_ADDRESS_CONNECT,
    REF_ADDRESS_SET_INFO,
    REF_ADDRESS_SEND_DIRECT,
    REF_ADDRESS_TDI_RCV_HANDLER,
    REF_ADDRESS_SEND_IN_PROGRESS,
    REF_ADDRESS_RECEIVE_ACTIVE,
    REF_ADDRESS_CLIENT_RECEIVE,
    REF_ADDRESS_DISCONNECT,
    REF_ADDRESS_STOP_LISTENING,
    REF_ADDRESS_MAX
};

#define MAX_STREAMS_PER_NONADMIN_RECEIVER       2
#define MAX_RECEIVE_INTERFACES                  20

#define PGM_ADDRESS_FLAG_INVALID_OUT_IF         0x00000001
#define PGM_ADDRESS_USE_WINDOW_AS_DATA_CACHE    0x00000002
#define PGM_ADDRESS_LISTEN_ON_ALL_INTERFACES    0x00000004
#define PGM_ADDRESS_WAITING_FOR_NEW_INTERFACE   0x00000008
#define PGM_ADDRESS_HIGH_SPEED_OPTIMIZED        0x00000010

typedef struct _tADDRESS_CONTEXT
{
    //
    // *** Common ***
    //
    // Line # 1
    LIST_ENTRY                  Linkage;         // link to next item in list
    ULONG                       Verify;          // set to a known value to verify block
    LONG                        RefCount;

    // Line # 2
    LIST_ENTRY                  AssociatedConnections;
    PEPROCESS                   Process;

    // Line # 3
    PIRP                        pIrpClose;
    ULONG                       Flags;
    HANDLE                      FileHandle;
    PFILE_OBJECT                pFileObject;

    // Line # 4
    PDEVICE_OBJECT              pDeviceObject;
    HANDLE                      RAlertFileHandle;
    PFILE_OBJECT                pRAlertFileObject;
    PDEVICE_OBJECT              pRAlertDeviceObject;

    // Line # 5
    PTDI_IND_CONNECT            evConnect;     // Client Event to call
    PVOID                       ConEvContext;  // EVENT Context to pass to client
    PTDI_IND_RECEIVE            evReceive;
    PVOID                       RcvEvContext;

    // Line # 6
    PTDI_IND_DISCONNECT         evDisconnect;
    PVOID                       DiscEvContext;
    PTDI_IND_ERROR              evError;
    PVOID                       ErrorEvContext;

    // Line # 7
    PTDI_IND_RECEIVE_DATAGRAM   evRcvDgram;
    PVOID                       RcvDgramEvContext;
    PTDI_IND_RECEIVE_EXPEDITED  evRcvExpedited;
    PVOID                       RcvExpedEvContext;

    // Line # 8
    PTDI_IND_SEND_POSSIBLE      evSendPossible;
    PVOID                       SendPossEvContext;
    TOKEN_USER                  *pUserId;

    //
    // *** Sender -specific ***
    //
    tMAC_ADDRESS        OutIfMacAddress;
    USHORT              SenderMCastPort;

    // Line # 9
    tIPADDRESS          SenderMCastOutIf;
    ULONG               OutIfFlags;
    ULONG               OutIfMTU;
    ULONG               LateJoinerPercentage;       // Percentage of window that late joiner can request

    // Line # 10
    ULONG               MCastPacketTtl;
    // --  send window settings
    ULONGLONG           MaxWindowSizeBytes;
    ULONGLONG           RateKbitsPerSec;
    ULONGLONG           WindowSizeInBytes;
    ULONGLONG           WindowSizeInMSecs;
    ULONG               WindowAdvancePercentage;

    // Line #     -- FEC settings
    USHORT              FECBlockSize;
    USHORT              FECProActivePackets;
    UCHAR               FECGroupSize;
    UCHAR               FECOptions;

    //
    // *** Receiver -specific ***
    //
    LIST_ENTRY                  ListenHead;             // List of Clients listening
    tIPADDRESS                  ReceiverMCastAddr;      // For receiving MCast packets (host format)
    USHORT                      ReceiverMCastPort;
    USHORT                      NumReceiveInterfaces;
    ULONG                       ReceiverInterfaceList[MAX_RECEIVE_INTERFACES+1];
    tIPADDRESS                  LastSpmSource;

    //
    // *** Common, including Debug ***
    //
    tPGM_LOCK_INFO              LockInfo;        // spin lock info for this struct

// #if DBG
    ULONG                       ReferenceContexts[REF_ADDRESS_MAX];
// #endif  // DBG
} tADDRESS_CONTEXT, *PADDRESS_CONTEXT;


typedef struct _tTDI_SEND_CONTEXT
{
    TDI_CONNECTION_INFORMATION      TdiConnectionInfo;
    TA_IP_ADDRESS                   TransportAddress;

    pCLIENT_COMPLETION_ROUTINE      pClientCompletionRoutine;
    PVOID                           ClientCompletionContext1;
    PVOID                           ClientCompletionContext2;
    BOOLEAN                         fPagedBuffer;
} tTDI_SEND_CONTEXT;

typedef struct _RCV_COMPLETE_CONTEXT
{
    tADDRESS_CONTEXT    *pAddress;
    ULONG               SrcAddressLength;
    ULONG               BytesAvailable;
    PVOID               pSrcAddress;
    UCHAR               BufferData[4];
} tRCV_COMPLETE_CONTEXT;

//
// Connect FileSystemContext
//
//
// Enumerate all the different places the Connection can be referenced to
// keep track of RefCounts
//
enum eREF_CONNECT
{
    REF_SESSION_CREATE,
    REF_SESSION_ASSOCIATED,
    REF_SESSION_TIMER_RUNNING,
    REF_SESSION_SEND_CONNECT,
    REF_SESSION_SEND_RDATA,
    REF_SESSION_SEND_SPM,
    REF_SESSION_SEND_NAK,
    REF_SESSION_SEND_NCF,
    REF_SESSION_SEND_IN_WINDOW,
    REF_SESSION_TDI_RCV_HANDLER,
    REF_SESSION_CLIENT_RECEIVE,
    REF_SESSION_CLEANUP_NAKS,
    REF_SESSION_DISCONNECT,
    REF_SESSION_MAX
};

#define FLAG_CONNECT_CLIENT_IS_LISTENING    1

#define MAX_DATA_FILE_NAME_LENGTH    50

#define PGM_SESSION_FLAG_STOP_TIMER         0x00000001
#define PGM_SESSION_FLAG_WORKER_RUNNING     0x00000002
#define PGM_SESSION_FLAG_SEND_AMBIENT_SPM   0x00000004
#define PGM_SESSION_FLAG_FIRST_PACKET       0x00000008
#define PGM_SESSION_FLAG_SENDER             0x00000010
#define PGM_SESSION_FLAG_RECEIVER           0x00000020
#define PGM_SESSION_FLAG_NAK_TIMED_OUT      0x00000040
#define PGM_SESSION_TERMINATED_GRACEFULLY   0x00000080
#define PGM_SESSION_TERMINATED_ABORT        0x00000100
#define PGM_SESSION_ON_TIMER                0x00000200
#define PGM_SESSION_FLAG_IN_INDICATE        0x00000400
#define PGM_SESSION_WAIT_FOR_RECEIVE_IRP    0x00000800
#define PGM_SESSION_SENDER_DISCONNECTED     0x00001000
#define PGM_SESSION_CLIENT_DISCONNECTED     0x00002000
#define PGM_SESSION_SENDS_CANCELLED         0x00004000
#define PGM_SESSION_DATA_FROM_LOOKASIDE     0x00008000

typedef struct _TSI
{
    union
    {
        struct
        {
            UCHAR                   GSI[SOURCE_ID_LENGTH];
            USHORT                  hPort;          // Out port for Sender, remote port for Reciever
        };
        ULONGLONG                   ULLTSI;
    };
} tTSI, *PTSI;


#define     NUM_INDICES         32
#define     NUM_INDICES_BITS     5      /* 5 bits all-set ==> 31 indices + 1 for overflow */

typedef struct _RDATA_INFO
{
    LIST_ENTRY                  PendingRDataRequests;
    ULONG                       EntrySize;
    ULONG                       IndexShift;
    ULONG                       IndexMask;
    ULONG                       MaxIndices;
    ULONG                       TrailIndex;
    ULONG                       NumAllocated;
    SEQ_TYPE                    RepairDataMaxEntries;
    SEQ_TYPE                    RepairDataMask;
    SEQ_TYPE                    RepairDataIndexShift;
    LIST_ENTRY                  *pRepairData;
    NPAGED_LOOKASIDE_LIST       RDataLookasideList;
    PVOID                       pFirstEntry[NUM_INDICES];
} tRDATA_INFO, *PRDATA_INFO;


typedef struct _tCOMMON_SESSION_CONTEXT
{
    // Line # 1
    LIST_ENTRY                  Linkage;
    ULONG                       Verify;
    ULONG                       RefCount;

    // Line # 2
    tADDRESS_CONTEXT            *pAssociatedAddress;
    ULONG                       SessionFlags;
    struct _tSEND_CONTEXT       *pSender;
    struct _tRECEIVE_CONTEXT    *pReceiver;

    tIPADDRESS                  TdiIpAddress;
    USHORT                      TdiPort;

    tTSI                        TSI;
    PEPROCESS                   Process;
    CONNECTION_CONTEXT          ClientSessionContext;
    PIRP                        pIrpCleanup;
    PIRP                        pIrpDisconnect;
    PIRP                        pIrpDisassociate;

    // -- FEC settings
    tFEC_CONTEXT                FECContext;
    PUCHAR                      pFECBuffer;
    USHORT                      MaxMTULength;
    USHORT                      MaxFECPacketLength;
    USHORT                      FECBlockSize;
    USHORT                      FECProActivePackets;
    UCHAR                       FECGroupSize;
    UCHAR                       FECOptions;

    ULONG                       RateCalcTimeout;

    ULONGLONG                   DataBytesAtLastInterval;        // # client data bytes sent upto last interval
    ULONGLONG                   TotalBytesAtLastInterval;       // SPM, OData and RData bytes upto last interval

    ULONGLONG                   DataBytes;                      // # client data bytes sent out so far
    ULONGLONG                   TotalBytes;                     // SPM, OData and RData bytes
    ULONGLONG                   TotalPacketsReceived;
    ULONGLONG                   RateKBitsPerSecLast;            // Internally calculated rate in the last INTERNAL_RATE_CALCULATION_FREQUENCY
    ULONGLONG                   MaxRateKBitsPerSec;             // Maximum observed rate in any INTERNAL_RATE_CALCULATION_FREQUENCY
    ULONGLONG                   RateKBitsPerSecOverall;         // Internally calculated rate from the beginning
    tPGM_TIMER                  SessionTimer;

    tPGM_LOCK_INFO  LockInfo;        // spin lock info for this struct
// #if DBG
    ULONG                       ReferenceContexts[REF_SESSION_MAX];
// #endif  // DBG
} tCOMMON_SESSION_CONTEXT, *PCOMMON_SESSION_CONTEXT;

typedef struct _tCOMMON_SESSION_CONTEXT tSEND_SESSION,      *PSEND_SESSION;
typedef struct _tCOMMON_SESSION_CONTEXT tRECEIVE_SESSION,   *PRECEIVE_SESSION;

typedef struct _tSEND_CONTEXT
{
    // Line # 1
    LIST_ENTRY                  Linkage;
    UNICODE_STRING              DataFileName;

    // Line # 2
    tADDRESS_CONTEXT            *pAddress;
    tIPADDRESS                  DestMCastIpAddress;
    tIPADDRESS                  SenderMCastOutIf;
    USHORT                      DestMCastPort;

    //
    // DataFile options
    //
    // Line # 3
    HANDLE                      FileHandle;
    HANDLE                      SectionHandle;
    PVOID                       pSectionObject;
    PUCHAR                      SendDataBufferMapping;

    // Line # 4
    ULONGLONG                   MaxDataFileSize;
    ULONGLONG                   MaxPacketsInBuffer;

    // Line # 5
    ULONG                       NextSendNumber;
    ULONG                       PacketBufferSize;
    ULONG                       MaxPayloadSize;

    //
    // Data Packet info
    //
    ULONG                       BufferPacketsAvailable;
    // Line # 6
    ULONGLONG                   BufferSizeAvailable;
    ULONGLONG                   LeadingWindowOffset;
    // Line # 7
    ULONGLONG                   TrailingWindowOffset;
    ULONG                       NumODataRequestsPending;
    ULONG                       NumRDataRequestsPending;
    // Line # 8
    SEQ_TYPE                    NextODataSequenceNumber;
    SEQ_TYPE                    LastODataSentSequenceNumber;
    SEQ_TYPE                    TrailingEdgeSequenceNumber;
    SEQ_TYPE                    TrailingGroupSequenceNumber;
    // Line # 9
    SEQ_TYPE                    LastMessageFirstSequence;
    SEQ_TYPE                    NextSpmSequenceNumber;
    SEQ_TYPE                    LateJoinSequenceNumbers;
    SEQ_TYPE                    LastVariableTGPacketSequenceNumber;  // FEC-specific
    // Line # 10
    SEQ_TYPE                    EmptySequencesForLastSend;
    ULONG                       NumPacketsRemaining;
    ULONG                       PacketsSentSinceLastSpm;
    ULONG                       SpmOptions;
    // Line # 11
    ULONG                       DataOptions;
    ULONG                       DataOptionsLength;
    ULONG                       ThisSendMessageLength;
    ULONG                       BytesSent;

    //
    // Current Senders
    //
    // Line # 14
    LIST_ENTRY                  CompletedSendsInWindow;
    LIST_ENTRY                  PendingPacketizedSends;
    // Line # 15
    LIST_ENTRY                  PendingSends;
    tRDATA_INFO                 *pRDataInfo;
    PVOID                       pLastProActiveGroupLeader;

    //
    // Send Timer variables
    //
    // Line # 16
    LARGE_INTEGER               LastTimeout;
    LARGE_INTEGER               TimeoutGranularity;
    // Line # 17
    ULONGLONG                   TimerTickCount;
    ULONGLONG                   SendTimeoutCount;
    // Line # 18
    ULONGLONG                   DisconnectTimeInTicks;
    ULONGLONG                   WindowAdvanceDeltaTime;
    // Line # 19
    ULONGLONG                   WindowSizeTime;
    ULONGLONG                   RDataLingerTime;
    // Line # 20
    ULONGLONG                   NextWindowAdvanceTime;
    ULONGLONG                   TrailingEdgeTime;
    // Line # 21
    ULONGLONG                   CurrentTimeoutCount;
    ULONGLONG                   CurrentSPMTimeout;
    // Line # 22
    ULONGLONG                   AmbientSPMTimeout;
    ULONGLONG                   HeartbeatSPMTimeout;
    // Line # 23
    ULONGLONG                   InitialHeartbeatSPMTimeout;
    ULONGLONG                   MaxHeartbeatSPMTimeout;
    ULONG                       CurrentBytesSendable;
    ULONG                       IncrementBytesOnSendTimeout;

    ULONG                       OriginalIncrementBytes;
    ULONG                       DeltaIncrementBytes;
    //
    // FEC-specific
    //
    tBUILD_PARITY_CONTEXT       *pProActiveParityContext;

    //
    // Lookaside list
    //
    // Line # 25
    NPAGED_LOOKASIDE_LIST       SenderBufferLookaside;
    NPAGED_LOOKASIDE_LIST       SendContextLookaside;

    //
    // Event for sender thread to synchronize on
    //
    KEVENT                      SendEvent;
    HANDLE                      SendHandle;
    ERESOURCE                   Resource;       // Used to lock access at passive Irqls

    ULONGLONG                   ODataPacketsInLastInterval;
    ULONGLONG                   RDataPacketsInLastInterval;

    //
    // Sender Statistics
    //
    ULONGLONG                   NaksReceived;           // # NAKs received so far
    ULONGLONG                   NaksReceivedTooLate;    // # NAKs recvd after window advanced
    ULONGLONG                   NumOutstandingNaks;     // # NAKs yet to be responded to
    ULONGLONG                   NumNaksAfterRData;      // # NAKs yet to be responded to
    ULONGLONG                   TotalODataPacketsSent;  // # ODATA sent so far
    ULONGLONG                   TotalRDataPacketsSent;  // # Repairs (RDATA) sent so far
} tSEND_CONTEXT;


typedef struct _tRECEIVE_CONTEXT
{
    // Line # 1
    LIST_ENTRY              Linkage;
    tCOMMON_SESSION_CONTEXT *pReceive;
    tADDRESS_CONTEXT        *pAddress;

    // Line # 2     -- Addresses
    tIPADDRESS              SenderIpAddress;
    tIPADDRESS              LastSpmSource;
    tIPADDRESS              ListenMCastIpAddress;
    USHORT                  ListenMCastPort;
    USHORT                  SessionNakType;

    // Line # 3     -- Sequence # tracking
    SEQ_TYPE                LastTrailingEdgeSeqNum;
    SEQ_TYPE                NextODataSequenceNumber;
    SEQ_TYPE                FirstNakSequenceNumber;
    SEQ_TYPE                FurthestKnownGroupSequenceNumber;

    // Line # 4
    SEQ_TYPE                FurthestKnownSequenceNumber;
    SEQ_TYPE                FinDataSequenceNumber;
    SEQ_TYPE                LastSpmSequenceNumber;
    ULONG                   MaxNakWaitTimeoutMSecs;

    // Line # 5
    ULONGLONG               OutstandingNakTimeout;
    ULONGLONG               MaxOutstandingNakTimeout;

    // Line # 6
    ULONGLONG               InitialOutstandingNakTimeout;
    ULONGLONG               LastNakSendTime;

    ULONGLONG               LastDataConsumedTime;

    // Line # 6
    LIST_ENTRY              BufferedDataList;
    LIST_ENTRY              NaksForwardDataList;

    // Line # 7
    LIST_ENTRY              PendingNaksList;
    LIST_ENTRY              ReceiveIrpsList;

    // Line # 8
    LIST_ENTRY              *pReceiveData;
    SEQ_TYPE                ReceiveDataMask;
    USHORT                  ReceiveDataMaxEntries;
    USHORT                  ReceiveDataIndexShift;

    // Line # 8
    PIRP                    pIrpReceive;
    ULONG                   TotalBytesInMdl;
    ULONG                   BytesInMdl;
    ULONG                   RcvBufferLength;

    // Line # 9
    ULONG                   CurrentMessageLength;
    ULONG                   CurrentMessageProcessed;
    ULONG                   TotalDataPacketsBuffered;
    ULONG                   DataPacketsPendingIndicate;

    // Line # 10
    ULONG                   DataPacketsPendingNaks;
    ULONG                   NumPacketGroupsPendingClient;
    ULONG                   MaxBufferLength;
    ULONG                   DataBufferLookasideLength;

    // Line # 11
    ULONG                   NumDataBuffersFromLookaside;
    USHORT                  MaxPacketsBufferedInLookaside;

    NPAGED_LOOKASIDE_LIST   DataBufferLookaside;
    NPAGED_LOOKASIDE_LIST   NonParityContextLookaside;
    NPAGED_LOOKASIDE_LIST   ParityContextLookaside;

    ULONG                   AverageSpmInterval;
    ULONG                   MaxSpmInterval;
    ULONG                   NumSpmIntervalSamples;
    ULONGLONG               StatSumOfSpmIntervals;
    ULONGLONG               LastSpmTickCount;
    ULONGLONG               LastSessionTickCount;
    ULONGLONG               StartTickCount;
    ULONGLONG               MinSequencesInWindow;
    ULONGLONG               MaxSequencesInWindow;
    ULONGLONG               DataPacketsIndicated;

    ULONGLONG               AverageSequencesInWindow;
    ULONGLONG               StatSumOfWindowSeqs;
    ULONGLONG               NumWindowSamples;
    ULONGLONG               AverageNcfRDataResponseTC;
    ULONGLONG               StatSumOfNcfRDataTicks;
    ULONGLONG               NumNcfRDataTicksSamples;
    ULONGLONG               MaxRDataResponseTCFromWindow;
    ULONGLONG               WindowSizeLastInMSecs;

    ULONGLONG               NumODataPacketsReceived;
    ULONGLONG               NumRDataPacketsReceived;
    ULONGLONG               NumDataPacketsDropped;
    ULONGLONG               NumDupPacketsBuffered;
    ULONGLONG               NumDupPacketsOlderThanWindow;
    ULONGLONG               NumPendingNaks;
    ULONGLONG               NumOutstandingNaks;
    ULONGLONG               TotalSelectiveNaksSent;
    ULONGLONG               TotalParityNaksSent;
} tRECEIVE_CONTEXT;


//
// OData context
//
typedef struct _tCLIENT_SEND_REQUEST
{
    // Line # 1
    LIST_ENTRY                      Linkage;

    // Record-keeping information -- set when send request comes from client
    ULONG                           SendNumber;
    PIRP                            pIrp;
    PIRP                            pIrpToComplete;
    tSEND_SESSION                   *pSend;
    ULONGLONG                       SendStartTime;
    ULONG                           NextDataOffsetInMdl;
    ULONG                           DataOptions;
    ULONG                           DataOptionsLength;

    // Message-specific information -- set initially for tracking Message boundaries
    ULONG                           ThisMessageLength;
    ULONG                           LastMessageOffset;
    ULONG                           NumPacketsRemaining;
    struct _tCLIENT_SEND_REQUEST    *pMessage2Request;

    // Static Send information -- set when the send is packetized (may be set more than once)
    SEQ_TYPE                        StartSequenceNumber;
    SEQ_TYPE                        EndSequenceNumber;
    SEQ_TYPE                        MessageFirstSequenceNumber;

    ULONG                           BytesInSend;
    ULONG                           BytesLeftToPacketize;
    ULONG                           DataPacketsPacketized;
    ULONG                           DataBytesInLastPacket;
    ULONG                           DataPayloadSize;

    // Dynamic-specific information -- updated on every OData send and completion
    ULONGLONG                       NextPacketOffset;
    ULONG                           NumDataPacketsSent;
    ULONG                           NumDataPacketsSentSuccessfully;
    ULONG                           NumSendsPending;
    ULONG                           NumParityPacketsToSend;

    // FEC-specific
    PVOID                           pLastMessageVariableTGPacket;

    BOOLEAN                         bLastSend;

} tCLIENT_SEND_REQUEST, *PCLIENT_SEND_REQUEST;

//
// **************************************
//

// Sender's Data contexts
//
typedef struct _tSEND_RDATA_CONTEXT
{
    // Line # 1
    LIST_ENTRY              Linkage;
    SEQ_TYPE                RDataSequenceNumber;

    // Line # 2
    ULONGLONG               EarliestRDataSendTime;
    ULONGLONG               PostRDataHoldTime;

    // Line # 3
    ULONGLONG               CleanupTime;
    tSEND_SESSION           *pSend;
    USHORT                  NumPacketsInTransport;
    USHORT                  NumParityNaks;

    // Line # 4
    union
    {
        UCHAR               SelectiveNaksMask[16];          // 16 * 8 = 128 ==> Max packets in group!
        ULONGLONG           SelectiveNaks[2];
    };

    // Line # 5
    LIST_ENTRY              FastFindLinkage;
    tBUILD_PARITY_CONTEXT   OnDemandParityContext;          // Must be last field in struct
} tSEND_RDATA_CONTEXT, *PSEND_RDATA_CONTEXT;

typedef struct
{
    ULONG                       MessageFirstSequence;
    ULONG                       MessageOffset;
    ULONG                       MessageLength;
}   tFRAGMENT_OPTIONS;

typedef struct
{
    USHORT                      EncodedTSDULength;
    UCHAR                       FragmentOptSpecific;
    UCHAR                       Pad;
    tFRAGMENT_OPTIONS           EncodedFragmentOptions;
}   tPOST_PACKET_FEC_CONTEXT;

typedef struct
{
    UCHAR                       FECGroupInfo;
    UCHAR                       NumPacketsInThisGroup;
    UCHAR                       FragmentOptSpecific;
    union
    {
        UCHAR                   ReceiverFECOptions;
        UCHAR                   SenderNextFECPacketIndex;
    };
}   tFEC_OPTIONS;

typedef struct
{
    USHORT                      TotalPacketLength;
    USHORT                      OptionsLength;
    ULONG                       OptionsFlags;
    USHORT                      LateJoinerOptionOffset;
    USHORT                      FragmentOptionOffset;

    ULONG                       LateJoinerSequence;
    ULONG                       MessageFirstSequence;
    ULONG                       MessageOffset;
    ULONG                       MessageLength;

    tFEC_OPTIONS                FECContext;
}   tPACKET_OPTIONS;


//
// Receiver's NAK + Out-of-order context
//
enum eNAK_TIMEOUT
{
    NAK_PENDING_0,
    NAK_PENDING_RB,
    NAK_PENDING_RPT_RB,
    NAK_OUTSTANDING
};

//
// Set flags for the different Nak types
//
#define NAK_TYPE_SELECTIVE  0x01
#define NAK_TYPE_PARITY     0x02

#define MAX_SEQUENCES_PER_NAK_OPTION    62

typedef struct _tNAKS_CONTEXT
{
    LIST_ENTRY      Linkage;
    SEQ_TYPE        Sequences[MAX_SEQUENCES_PER_NAK_OPTION+1];
    USHORT          NumSequences;
    USHORT          NakType;
} tNAKS_CONTEXT, *PNAKS_CONTEXT;

typedef struct _tNAKS_LIST
{
    SEQ_TYPE        pNakSequences[MAX_SEQUENCES_PER_NAK_OPTION+1];
    USHORT          NumSequences;
    USHORT          NakType;
    union
    {
        USHORT      NumParityNaks[MAX_SEQUENCES_PER_NAK_OPTION+1];
        USHORT      NakIndex[MAX_SEQUENCES_PER_NAK_OPTION+1];
    };
} tNAKS_LIST, *PNAKS_LIST;

#define PENDING_DATA_LOOKASIDE_ALLOCATION_FLAG  0x00000001

typedef struct _PENDING_DATA
{
    PUCHAR      pDataPacket;
    PUCHAR      DecodeBuffer;

    USHORT      PacketLength;
    USHORT      DataOffset;
    UCHAR       PacketIndex;
    UCHAR       ActualIndexOfDataPacket;
    UCHAR       NcfsReceivedForActualIndex;
    UCHAR       FragmentOptSpecific;

    ULONG       MessageFirstSequence;
    ULONG       MessageOffset;
    ULONG       MessageLength;
    ULONG       PendingDataFlags;
} tPENDING_DATA;
    

typedef struct _tNAK_FORWARD_DATA
{
    // Line # 1
    LIST_ENTRY              Linkage;
    SEQ_TYPE                SequenceNumber;

    // Line # 2
    ULONGLONG               PendingNakTimeout;
    ULONGLONG               OutstandingNakTimeout;

    // Line # 3
    ULONGLONG               FirstNcfTickCount;
    ULONG                   AllOptionsFlags;
    USHORT                  ParityDataSize;
    USHORT                  MinPacketLength;

    // Line # 4
    UCHAR                   WaitingNcfRetries;
    UCHAR                   PacketsInGroup;
    UCHAR                   NumDataPackets;
    UCHAR                   NumParityPackets;

    UCHAR                   WaitingRDataRetries;
    UCHAR                   ThisGroupSize;
    UCHAR                   OriginalGroupSize;
    UCHAR                   NextIndexToIndicate;

    LIST_ENTRY              LookupLinkage;
    LIST_ENTRY              SendNakLinkage;

    // Line # 4
    tPENDING_DATA           pPendingData[1];
} tNAK_FORWARD_DATA, *PNAK_FORWARD_DATA;


//
// **************************************
//
// Worker Queue context
//
typedef struct
{
    WORK_QUEUE_ITEM         Item;   // Used by OS to queue these requests
    LIST_ENTRY              PgmConfigLinkage;
    PVOID                   WorkerRoutine;
    PVOID                   Context1;
    PVOID                   Context2;
    PVOID                   Context3;
} PGM_WORKER_CONTEXT;


// **********************************************************************
// *                           Timer  Definitions                       *
// **********************************************************************
#define     BASIC_TIMER_GRANULARITY_IN_MSECS         20             // 20 millisecs

//  Statistics timer
#define     INTERNAL_RATE_CALCULATION_FREQUENCY    4096             // ~4 secs
#define     LOG2_INTERNAL_RATE_CALCULATION_FREQUENCY 12

// **********************************************************************
// *                        Sender defaults                             *
// **********************************************************************
#define     NUM_LEAKY_BUCKETS                         2
#define     SENDER_MAX_WINDOW_SIZE_PACKETS          (((SEQ_TYPE)-1) / 2)
#define     MIN_RECOMMENDED_WINDOW_MSECS            10*1000         // 10 seconds
#define     MID_RECOMMENDED_WINDOW_MSECS            30*1000         // 5 minutes
#define     MAX_RECOMMENDED_WINDOW_MSECS          5*60*1000         // 5 minutes

// SPM timer
#define     AMBIENT_SPM_TIMEOUT_IN_MSECS            500             // 0.5 Sec
#define     INITIAL_HEARTBEAT_SPM_TIMEOUT_IN_MSECS  1000            // 1 Sec
#define     MAX_HEARTBEAT_SPM_TIMEOUT_IN_MSECS      15*1000         // 15 Secs
#define     MAX_DATA_PACKETS_BEFORE_SPM             50              // Not more than 50 data pkts before SPM

// RData timer
#define     RDATA_LINGER_TIME_MSECS                  60             // Time before and after sending RData

#define     MIN_PREFERRED_REPAIR_PERCENTAGE           7

// **********************************************************************
// *                         Receiver Settings                          *
// **********************************************************************
#define     MAX_PACKETS_BUFFERED                 3*1000             // Limit on # of buffered packets/session
#define     MAX_SEQUENCES_IN_RCV_WINDOW          5*1000             // Limit on # of Nak Contexts/session
#define     MAX_SPM_INTERVAL_MSECS            5*60*1000             // 5 minutes
#define     MAX_DATA_CONSUMPTION_TIME_MSECS   5*60*1000             // 5 minutes

// Nak timer
#define     OUT_OF_ORDER_PACKETS_BEFORE_NAK           2             // Before starting Nak
#define     NAK_WAITING_NCF_MAX_RETRIES              10

#define     NAK_MIN_INITIAL_BACKOFF_TIMEOUT_MS_OPT    2             // 0.002 Secs
#define     NAK_MAX_INITIAL_BACKOFF_TIMEOUT_MS_OPT   20             // 0.02 Secs
#define     NAK_MIN_INITIAL_BACKOFF_TIMEOUT_MSECS    50             // 0.2 Secs
#define     NAK_MAX_INITIAL_BACKOFF_TIMEOUT_MSECS   100             // 0.5 Secs
#define     NAK_RANDOM_BACKOFF_MSECS                        \
                GetRandomInteger (NAK_MIN_INITIAL_BACKOFF_TIMEOUT_MSECS,NAK_MAX_INITIAL_BACKOFF_TIMEOUT_MSECS)

#define     NAK_RANDOM_BACKOFF_MSECS_OPT                    \
                GetRandomInteger (NAK_MIN_INITIAL_BACKOFF_TIMEOUT_MS_OPT,NAK_MAX_INITIAL_BACKOFF_TIMEOUT_MS_OPT)

#define     NAK_REPEAT_INTERVAL_MSECS_OPT            50             // 0.05 Secs -- Timeout before retrying
#define     NAK_REPEAT_INTERVAL_MSECS               750             // 0.75 Secs -- Timeout before retrying

// Ncf timer
#define     INITIAL_NAK_OUTSTANDING_TIMEOUT_MS_OPT  100             // 0.1 Secs -- Waiting for RData after NCF
#define     INITIAL_NAK_OUTSTANDING_TIMEOUT_MSECS  2000             // 2 Secs -- Waiting for RData after NCF
#define     NCF_WAITING_RDATA_MAX_RETRIES            10             // Max NCFs before fatal error

// **********************************************************************
// *                           Packet Definitions                       *
// **********************************************************************

#include <packon.h>
//
// IP v4 Header
//
typedef struct IPV4Header {
    UCHAR           HeaderLength                : 4;    // Version
    UCHAR           Version                     : 4;    // Length
    UCHAR           TypeOfService;                      // Type of service.
    USHORT          TotalLength;                        // Total length of datagram.
    USHORT          Identification;                     // Identification.
    USHORT          FlagsAndFragmentOffset;             // Flags and fragment offset.
    UCHAR           TimeToLive;                         // Time to live.
    UCHAR           Protocol;                           // Protocol.
    USHORT          Checksum;                           // Header checksum.
    ULONG           SourceIp;                           // Source address.
    ULONG           DestinationIp;                      // Destination address.
} IPV4Header;

//
// Common PGM Header:
//
typedef struct
{
    USHORT          SrcPort;
    USHORT          DestPort;

    UCHAR           Type;
    UCHAR           Options;
    USHORT          Checksum;

    UCHAR           gSourceId[SOURCE_ID_LENGTH];
    USHORT          TSDULength;
}   tCOMMON_HEADER;

#define     IPV4_NLA_AFI    1

typedef struct
{
    USHORT          NLA_AFI;
    USHORT          Reserved;
    tIPADDRESS      IpAddress;
}   tNLA;

//
// SPMs (Session-specific -- Sender only -- periodic)   ==> Range: [0, 3]
//
#define PACKET_TYPE_SPM     0x00
#define PACKET_TYPE_POLL    0x01
#define PACKET_TYPE_POLR    0x02
typedef struct
{
    tCOMMON_HEADER      CommonHeader;

    ULONG               SpmSequenceNumber;          // SPM_SQN
    ULONG               TrailingEdgeSeqNumber;      // SPM_TRAIL == TXW_TRAIL
    ULONG               LeadingEdgeSeqNumber;       // SPM_LEAD == TXW_LEAD

    tNLA                PathNLA;
}   tBASIC_SPM_PACKET_HEADER;

//
// Data packets (data and repairs)                      ==> Range: [4, 7]
//
#define PACKET_TYPE_ODATA   0x04
#define PACKET_TYPE_RDATA   0x05
typedef struct
{
    tCOMMON_HEADER      CommonHeader;

    ULONG               DataSequenceNumber;
    ULONG               TrailingEdgeSequenceNumber;
}   tBASIC_DATA_PACKET_HEADER;

//
// NAK/NCF Packets (hop-by-hop reliable NAK forwarding) ==> Range: [8, B]
//
#define PACKET_TYPE_NAK     0x08
#define PACKET_TYPE_NNAK    0x09
#define PACKET_TYPE_NCF     0x0A
typedef struct
{
    tCOMMON_HEADER                  CommonHeader;

    ULONG                           RequestedSequenceNumber;
    tNLA                            SourceNLA;
    tNLA                            MCastGroupNLA;
}   tBASIC_NAK_NCF_PACKET_HEADER;

typedef struct
{
    ULONG                           RefCount;
    ULONG                           SuccessfulSends;
    tBASIC_NAK_NCF_PACKET_HEADER    NakPacket;
} tNAK_CONTEXT;

//
// SPM Request Pkts (session-specific, receiver only)   ==> Range: [C, F]
//
#define PACKET_TYPE_SPMR    0x0C


//
// Options flag values
//
#define PACKET_HEADER_OPTIONS_PRESENT               0x01    // bit 7
#define PACKET_HEADER_OPTIONS_NETWORK_SIGNIFICANT   0x02    // bit 6
#define PACKET_HEADER_OPTIONS_VAR_PKTLEN            0x40    // bit 1
#define PACKET_HEADER_OPTIONS_PARITY                0x80    // bit 0

// **********************************************************************
// *                           Packet Options                           *
// **********************************************************************

//
// We can have a maximum of 16 options per packet
//

//
// Generic Packet Option Format
//
typedef struct
{
    UCHAR       E_OptionType;
    UCHAR       OptionLength;
    UCHAR       Reserved_F_Opx;
    UCHAR       U_OptSpecific;
} tPACKET_OPTION_GENERIC;


#define PACKET_OPTION_TYPE_END_BIT              0x80

#define PACKET_OPTION_RES_F_OPX_IGNORE          0x00
#define PACKET_OPTION_RES_F_OPX_INVALIDATE      0x01
#define PACKET_OPTION_RES_F_OPX_DISCARD         0x02
#define PACKET_OPTION_RES_F_OPX_UNSUPPORTED     0x03

#define PACKET_OPTION_RES_F_OPX_ENCODED_BIT     0x04
#define PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT 0x80

#define PACKET_OPTION_SPECIFIC_FEC_OND_BIT      0x01
#define PACKET_OPTION_SPECIFIC_FEC_PRO_BIT      0x02

#define PACKET_OPTION_SPECIFIC_RST_N_BIT        0x80

//
// Packet Option format for Length option
//
typedef struct
{
    UCHAR       Type;
    UCHAR       Length;
    USHORT      TotalOptionsLength;
} tPACKET_OPTION_LENGTH;

#define PACKET_OPTION_LENGTH        0x00        // All packets

#define PACKET_OPTION_FRAGMENT      0x01        // ODATA, RDATA only
#define PACKET_OPTION_NAK_LIST      0x02        // NAKs, NCFs
#define PACKET_OPTION_JOIN          0x03        // ODATA, RDATA, SPM
#define PACKET_OPTION_REDIRECT      0x07        // POLR
#define PACKET_OPTION_SYN           0x0D        // ODATA, RDATA
#define PACKET_OPTION_FIN           0x0E        // SPMs, ODATA, RDATA
#define PACKET_OPTION_RST           0x0F        // SPMs only

#define PACKET_OPTION_PARITY_PRM    0x08        // SPMs only
#define PACKET_OPTION_PARITY_GRP    0x09        // Parity packets only (parity ODATA, RDATA)
#define PACKET_OPTION_CURR_TGSIZE   0x0A        // ODATA, RDATA, SPMs

#define PACKET_OPTION_CR            0x10        // NAKs only
#define PACKET_OPTION_CRQST         0x11        // SPMs only
#define PACKET_OPTION_NAK_BO_IVL    0x04        // NCFs, SPMs, or POLLs
#define PACKET_OPTION_NAK_BO_RNG    0x05        // SPMs
#define PACKET_OPTION_NBR_UNREACH   0x0B        // SPMs and NCFs
#define PACKET_OPTION_PATH_NLA      0x0C        // NCFs
#define PACKET_OPTION_INVALID       0x7F

//
// Internal flags used for processing options
//
#define PGM_OPTION_FLAG_FRAGMENT            0x00000001
#define PGM_OPTION_FLAG_NAK_LIST            0x00000004          // Network Significant
#define PGM_OPTION_FLAG_JOIN                0x00000008
#define PGM_OPTION_FLAG_REDIRECT            0x00000010          // Network Significant
#define PGM_OPTION_FLAG_SYN                 0x00000020
#define PGM_OPTION_FLAG_FIN                 0x00000040
#define PGM_OPTION_FLAG_RST                 0x00000080
#define PGM_OPTION_FLAG_RST_N               0x00000100
// FEC-related options
#define PGM_OPTION_FLAG_PARITY_PRM          0x00000200          // Network Significant
#define PGM_OPTION_FLAG_PARITY_GRP          0x00000400
#define PGM_OPTION_FLAG_PARITY_CUR_TGSIZE   0x00000800          // Network Significant (except on ODATA)

#define PGM_OPTION_FLAG_CR                  0x00001000          // Network Significant
#define PGM_OPTION_FLAG_CRQST               0x00002000          // Network Significant
#define PGM_OPTION_FLAG_NAK_BO_IVL          0x00004000
#define PGM_OPTION_FLAG_NAK_BO_RNG          0x00008000
#define PGM_OPTION_FLAG_NBR_UNREACH         0x00010000          // Network Significant
#define PGM_OPTION_FLAG_PATH_NLA            0x00020000          // Network Significant
#define PGM_OPTION_FLAG_INVALID             0x00040000

#define PGM_OPTION_FLAG_UNRECOGNIZED        0x80000000

#define PGM_VALID_DATA_OPTION_FLAGS     (PGM_OPTION_FLAG_FRAGMENT |         \
                                         PGM_OPTION_FLAG_JOIN |             \
                                         PGM_OPTION_FLAG_SYN |              \
                                         PGM_OPTION_FLAG_FIN |              \
                                         PGM_OPTION_FLAG_PARITY_GRP |       \
                                         PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)

#define PGM_VALID_SPM_OPTION_FLAGS      (PGM_OPTION_FLAG_JOIN |             \
                                         PGM_OPTION_FLAG_FIN |              \
                                         PGM_OPTION_FLAG_RST |              \
                                         PGM_OPTION_FLAG_RST_N |            \
                                         PGM_OPTION_FLAG_PARITY_PRM |       \
                                         PGM_OPTION_FLAG_PARITY_CUR_TGSIZE |\
                                         PGM_OPTION_FLAG_CRQST |            \
                                         PGM_OPTION_FLAG_NAK_BO_IVL |       \
                                         PGM_OPTION_FLAG_NAK_BO_RNG |       \
                                         PGM_OPTION_FLAG_NBR_UNREACH)

#define PGM_VALID_NAK_OPTION_FLAGS      (PGM_OPTION_FLAG_NAK_LIST |         \
                                         PGM_OPTION_FLAG_CR)

#define PGM_VALID_NCF_OPTION_FLAGS      (PGM_OPTION_FLAG_NAK_LIST |         \
                                         PGM_OPTION_FLAG_NAK_BO_IVL |       \
                                         PGM_OPTION_FLAG_NBR_UNREACH |      \
                                         PGM_OPTION_FLAG_PATH_NLA)

#define PGM_VALID_POLR_OPTION_FLAGS     (PGM_OPTION_FLAG_REDIRECT)

#define PGM_VALID_POLL_OPTION_FLAGS     (PGM_OPTION_FLAG_NAK_BO_IVL)

#define NETWORK_SIG_ALL_OPTION_FLAGS    (PGM_OPTION_FLAG_NAK_LIST |         \
                                         PGM_OPTION_FLAG_REDIRECT |         \
                                         PGM_OPTION_FLAG_PARITY_PRM |       \
                                         PGM_OPTION_FLAG_PARITY_CUR_TGSIZE |\
                                         PGM_OPTION_FLAG_CR |               \
                                         PGM_OPTION_FLAG_CRQST |            \
                                         PGM_OPTION_FLAG_NBR_UNREACH |      \
                                         PGM_OPTION_FLAG_PATH_NLA)

//
// NETWORK_SIG_ODATA_OPTIONS_FLAGS == 0
//
#define NETWORK_SIG_ODATA_OPTIONS_FLAGS (PGM_VALID_DATA_OPTION_FLAGS &      \
                                         NETWORK_SIG_ALL_OPTION_FLAGS &     \
                                         ~PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)

//
// NETWORK_SIG_RDATA_OPTIONS_FLAGS == CUR_TGSIZE
//
#define NETWORK_SIG_RDATA_OPTIONS_FLAGS (PGM_VALID_DATA_OPTION_FLAGS &      \
                                         NETWORK_SIG_ALL_OPTION_FLAGS)

//
// NETWORK_SIG_SPM_OPTIONS_FLAGS == PARITY_PRM | CUR_TGSIZE | CRQST | NBR_UNREACH
//
#define NETWORK_SIG_SPM_OPTIONS_FLAGS   (PGM_VALID_SPM_OPTION_FLAGS &       \
                                         NETWORK_SIG_ALL_OPTION_FLAGS)

//
// NETWORK_SIG_NAK_OPTIONS_FLAGS == NAK_LIST | CR
//
#define NETWORK_SIG_NAK_OPTIONS_FLAGS   (PGM_VALID_NAK_OPTION_FLAGS &       \
                                         NETWORK_SIG_ALL_OPTION_FLAGS)

//
// NETWORK_SIG_NCF_OPTIONS_FLAGS == NAK_LIST | NBR_UNREACH | PATH_NLA
//
#define NETWORK_SIG_NCF_OPTIONS_FLAGS   (PGM_VALID_NCF_OPTION_FLAGS &       \
                                         NETWORK_SIG_ALL_OPTION_FLAGS)

//
// NETWORK_SIG_POLR_OPTIONS_FLAGS == REDIRECT
//
#define NETWORK_SIG_POLR_OPTIONS_FLAGS  (PGM_VALID_POLR_OPTION_FLAGS &       \
                                         NETWORK_SIG_ALL_OPTION_FLAGS)

//
// NETWORK_SIG_POLL_OPTIONS_FLAGS == 0
//
#define NETWORK_SIG_POLL_OPTIONS_FLAGS  (PGM_VALID_POLL_OPTION_FLAGS &       \
                                         NETWORK_SIG_ALL_OPTION_FLAGS)


// Based on the above, the maximum lengths (with the addition of the Packet extension option) are:
#define PGM_PACKET_EXTENSION_LENGTH             4
#define PGM_PACKET_OPT_FRAGMENT_LENGTH         16
#define PGM_PACKET_OPT_MIN_NAK_LIST_LENGTH    (4 + 4)
#define PGM_PACKET_OPT_MAX_NAK_LIST_LENGTH    (4 + 4*MAX_SEQUENCES_PER_NAK_OPTION)
#define PGM_PACKET_OPT_JOIN_LENGTH              8
#define PGM_PACKET_OPT_SYN_LENGTH               4
#define PGM_PACKET_OPT_FIN_LENGTH               4
#define PGM_PACKET_OPT_RST_LENGTH               4

#define PGM_PACKET_OPT_PARITY_PRM_LENGTH        8
#define PGM_PACKET_OPT_PARITY_GRP_LENGTH        8
#define PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH 8

//
// The following settings are for the currently used options only.
// It will need to be modified if new options are used
//
#define PGM_MAX_DATA_HEADER_LENGTH      (sizeof(tBASIC_DATA_PACKET_HEADER) +        \
                                         PGM_PACKET_EXTENSION_LENGTH +              \
                                         PGM_PACKET_OPT_FRAGMENT_LENGTH +           \
                                         PGM_PACKET_OPT_JOIN_LENGTH +               \
                                         PGM_PACKET_OPT_SYN_LENGTH)                     /* or FIN or RST */

#define PGM_MAX_FEC_DATA_HEADER_LENGTH  (sizeof(tBASIC_DATA_PACKET_HEADER) +        \
                                         PGM_PACKET_EXTENSION_LENGTH +              \
                                         PGM_PACKET_OPT_FRAGMENT_LENGTH +           \
                                         PGM_PACKET_OPT_PARITY_GRP_LENGTH +         \
                                         PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH +  \
                                         PGM_PACKET_OPT_SYN_LENGTH +                \
                                         PGM_PACKET_OPT_FIN_LENGTH)                     /* or RST */

#define PGM_MAX_SPM_HEADER_LENGTH       (sizeof(tBASIC_SPM_PACKET_HEADER) +         \
                                         PGM_PACKET_EXTENSION_LENGTH +              \
                                         PGM_PACKET_OPT_JOIN_LENGTH +               \
                                         PGM_PACKET_OPT_PARITY_PRM_LENGTH +         \
                                         PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH +  \
                                         PGM_PACKET_OPT_FIN_LENGTH)                     /* or RST */

#define PGM_MAX_NAK_NCF_HEADER_LENGTH   (sizeof(tBASIC_NAK_NCF_PACKET_HEADER) +     \
                                         PGM_PACKET_EXTENSION_LENGTH +              \
                                         PGM_PACKET_OPT_MAX_NAK_LIST_LENGTH)

#include <packoff.h>

//
// Include the definition for the Data file formatting unit
//
typedef struct
{
    tPACKET_OPTIONS             PacketOptions;
    tBASIC_DATA_PACKET_HEADER   DataPacket;
}   tPACKET_BUFFER;

#endif  // _TYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\parser\pgm.c ===
//============================================================================
//
//  Copyright (C) 2000 Microsoft Corporation
//
//  FILE: PGM.c
//
//  Description: Parses a PGM frame
//                  Displays the PGM header
//                  Displays the PGM options
//
//  Note: info for this parser was gleaned from:
//         (PGM Documentation)
//
//  Modification History
//
//  Madhurima Pawar (t-mpawar@microsoft.com)      08/04/00    Created
//============================================================================

#include "PGM.h"

//============================================================================
//Global variables
//============================================================================

HPROTOCOL		hPGM = NULL;         //Handle to PGM's parser database properties
DWORD			PGMAttached = 0;     //Number of times protocol instances that are running

//====================================================================
//External functions used to regester PGM. These function are exported to Netmon
//By putting a _delspec the function is immediatly exported and does not have to 
//be exported through a .def file. This is useful when many parsers are in 
//one dll and some are included and some are not.
//=================================================================================

extern VOID	  _declspec(dllexport) WINAPI PGM_Register( HPROTOCOL hPGM);
extern VOID   _declspec(dllexport) WINAPI PGM_Deregister( HPROTOCOL hPGM);
extern LPBYTE _declspec(dllexport) WINAPI PGM_RecognizeFrame( HFRAME hFrame, 
																 LPBYTE pMACFrame, 
																 LPBYTE pPGMFrame, 
																 DWORD PGMType, 
																 DWORD BytesLeft, 
																 HPROTOCOL hPrevProtocol, 
																 DWORD nPrevProtOffset,
																 LPDWORD pProtocolStatus,
																 LPHPROTOCOL phNextProtocol, 
																 PDWORD_PTR InstData);
extern LPBYTE _declspec(dllexport) WINAPI PGM_AttachProperties( HFRAME hFrame, 
																   LPBYTE pMACFrame, 
																   LPBYTE pPGMFrame, 
																   DWORD PGMType, 
																   DWORD BytesLeft, 
																   HPROTOCOL hPrevProtocol, 
																   DWORD nPrevProtOffset,
																   DWORD_PTR InstData);
extern DWORD  _declspec(dllexport) WINAPI PGM_FormatProperties( HFRAME hFrame, 
																   LPBYTE pMACFrame, 
																   LPBYTE pPGMFrame, 
																   DWORD nPropertyInsts, 
																   LPPROPERTYINST p);
extern VOID WINAPIV PGM_FmtSummary( LPPROPERTYINST pPropertyInst );

//============================================================================
//Format functions customize the format of the data. Network Monitor
//provides baic format structures such as IP version 4 address. 
//All other formats must be writen by the programmer.
//============================================================================

VOID WINAPIV PGM_FormatSummary( LPPROPERTYINST pPropertyInst);

//============================================================================
//Define the entry points that we will pass back to NetMon at dll 
//entry time 
//============================================================================

ENTRYPOINTS PGMEntryPoints =
{
    PGM_Register,
    PGM_Deregister,
    PGM_RecognizeFrame,
    PGM_AttachProperties,
    PGM_FormatProperties,
};

//====================================================================
//Property Value Labels are tables that map numbers to strings.
//====================================================================

LABELED_BYTE PGMTypes[] =				//The types of PGM
{
    { 0, "SPM" },    
    { 1, "POLL" },
    { 2, "POLR" },
    { 4, "ODATA" },
    { 5, "RDATA" },
    { 8, "NACK" },
    { 9, "NNACK" },
    { 10, "NCF" } ,
};

LABELED_BIT PGMHeaderOptions[] =
{
    { 7, "Non-Parity                         ", "PARITY                       " },
    { 6, "Not a variable-length parity packet", "VARIABLE LENGTH PARITY PACKET" },
    { 1, "Not Network Significant            ", "NETWORK SIGNIFICANT          " },
    { 0, "No header Options                  ", "Packet header has options    " },
};

LABELED_BIT PGMParityOptions[] =
{
    { 1, "No Pro-Active Parity     ", "PRO-ACTIVE Parity enabled" },
    { 0, "Selective NAKs Only      ", "ON-DEMAND Parity enabled " },
};

//====================================================================
//Make a set out of the above listings. The set contains the list 
//aswell as the size
//====================================================================

SET PGMTypesSET =			  {(sizeof(PGMTypes)/sizeof(LABELED_BYTE)),  PGMTypes };
SET PGMHeaderOptionsSET =	  {(sizeof(PGMHeaderOptions)/sizeof(LABELED_BIT)),  PGMHeaderOptions };
SET PGMParityOptionsSET =	  {(sizeof(PGMParityOptions)/sizeof(LABELED_BIT)),  PGMParityOptions };

//====================================================================
//PGM Database (Properties Table). This table stores the properties
//of each field in an PGM package. Each field property has a name, 
//size and format function. FormatPropertyInstance is the standard 
//NetMon formatter. The comment is the location of the property in 
//the table
//====================================================================

PROPERTYINFO  PGMPropertyTable[] = 
{

    // PGM_SUMMARY (0)
    { 0, 0,
      "Summary",
      "Summary of the PGM Packet",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,  
      PGM_FmtSummary         
    },

    // PGM_SOURCE_PORT (1)
    { 0, 0,
      "Source Port",
      "Source Port",
      PROP_TYPE_BYTESWAPPED_WORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_DESTINATION_PORT (2)
    { 0, 0,
      "Destination Port",
      "Destination Port",
      PROP_TYPE_BYTESWAPPED_WORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_TYPE (3)
    { 0, 0,
      "Type",
      "Type of PGM",
      PROP_TYPE_BYTE,
      PROP_QUAL_LABELED_SET,
      &PGMTypesSET,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_CHECKSUM (4)
    { 0, 0,
      "Checksum",
      "Checksum for PGM packet",
      PROP_TYPE_BYTESWAPPED_WORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_GLOBAL_SOURCE_ID (5)
    { 0, 0,
      "Global Source Id",
      "Global Source Id for PGM session",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_TSDU_LENGTH (6)
    { 0, 0,
      "TSDU Length",
      "TSDU Length",
      PROP_TYPE_BYTESWAPPED_WORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_SEQUENCE_NUMBER (7)
    { 0, 0,
      "Sequence Number",
      "Packet Sequence Number",
      PROP_TYPE_BYTESWAPPED_DWORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_TRAILING_EDGE (8)
    { 0, 0,
      "Trailing Edge",
      "Trailing Edge Sequence Number",
      PROP_TYPE_BYTESWAPPED_DWORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_LEADING_EDGE (9)
    { 0, 0,
      "Leading Edge",
      "Leading Edge Sequence Number",
      PROP_TYPE_BYTESWAPPED_DWORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_NLA_TYPE_SOURCE (10)
    { 0, 0,
      "Source Path NLA",
      "Source Path NLA",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_NLA_TYPE_MCAST_GROUP (11)
    { 0, 0,
      "MCAST Group NLA",
      "MCAST Group NLA",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_NLA_AFI (12)
    { 0, 0,
      "NLA AFI",
      "NLA AFI",
      PROP_TYPE_BYTESWAPPED_WORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_NLA_RESERVED (13)
    { 0, 0,
      "NLA RESERVED",
      "NLA RESERVED",
      PROP_TYPE_BYTESWAPPED_WORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_NLA_IP (14)
    { 0, 0,
      "NLA ADDRESS",
      "NLA ADDRESS",
      PROP_TYPE_IP_ADDRESS,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTIONS (15)
    { 0, 0,
      "Options",
      "Options of PGM Packet",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTIONS_FLAGS (16)
    { 0, 0,
      "Options Flags",
      "Options Flags",
      PROP_TYPE_BYTE,
      PROP_QUAL_FLAGS,
      &PGMHeaderOptionsSET,
      PGM_FMT_STR_SIZE*4,
      FormatPropertyInstance
    },

    // PGM_HEADER_OPTIONS (17)
    { 0, 0,
      "Pgm Header Options",
      "Pgm Header Options",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTION_TYPE_NAK_SEQ (18)
    { 0, 0,
      "Nak / Ncf Sequences",
      "Nak / Ncf Sequences",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTION_TYPE_FRAGMENT (19)
    { 0, 0,
      "Message Fragment",
      "Message Fragment",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTION_TYPE_LATE_JOINER (20)
    { 0, 0,
      "Late Joiner",
      "Late Joiner",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTION_TYPE_SYN (21)
    { 0, 0,
      "Session SYN",
      "Session SYN",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTION_TYPE_FIN (22)
    { 0, 0,
      "Session FIN",
      "Session FIN",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTION_TYPE_RST (23)
    { 0, 0,
      "Session Reset",
      "Session Reset",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTION_TYPE_PARITY_PRM (24)
    { 0, 0,
      "Parity Parameters",
      "Parity Parameters",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTION_TYPE_PARITY_GRP (25)
    { 0, 0,
      "Parity Group Option Present",
      "Parity Group Option Present",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTION_TYPE_PARITY_TGSIZE (26)
    { 0, 0,
      "Parity Current TG Size Option Present",
      "Parity Current TG Size Option Present",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTIONS_FIELD_LENGTH (27)
    { 0, 0,
      "Options Length",
      "Options Length",
      PROP_TYPE_BYTESWAPPED_WORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTIONS_NAK_SEQ (28)
    { 0, 0,
      "Nak Sequence",
      "Nak Sequence",
      PROP_TYPE_BYTESWAPPED_DWORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTIONS_MESSAGE_FIRST_SEQUENCE (29)
    { 0, 0,
      "Message First Sequence",
      "Message First Sequence",
      PROP_TYPE_BYTESWAPPED_DWORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTIONS_MESSAGE_OFFSET (30)
    { 0, 0,
      "Message Offset",
      "Message Offset",
      PROP_TYPE_BYTESWAPPED_DWORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTIONS_MESSAGE_LENGTH (31)
    { 0, 0,
      "Message Length",
      "Message Length",
      PROP_TYPE_BYTESWAPPED_DWORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTIONS_LATE_JOINER (32)
    { 0, 0,
      "Late Joiner Sequence",
      "Late Joiner Sequence",
      PROP_TYPE_BYTESWAPPED_DWORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTIONS_PARITY_OPT (33)
    { 0, 0,
      "Parity Flags",
      "Parity Flags",
      PROP_TYPE_BYTE,
      PROP_QUAL_FLAGS,
      &PGMParityOptionsSET,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTIONS_PARITY_PRM_GRP_SZ (34)
    { 0, 0,
      "Parity Group Size",
      "Parity Group Size",
      PROP_TYPE_BYTESWAPPED_DWORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTIONS_PARITY_GRP (35)
    { 0, 0,
      "Parity Group Number",
      "Parity Group Number",
      PROP_TYPE_BYTESWAPPED_DWORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_OPTIONS_PARITY_TG_SZ (36)
    { 0, 0,
      "Parity TG Size",
      "Parity TG Size",
      PROP_TYPE_BYTESWAPPED_DWORD,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance
    },

    // PGM_DATA (37)
    { 0,0,
      "Data",
      "Data contained in PGM packet",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      PGM_FMT_STR_SIZE,
      FormatPropertyInstance },
};


//====================================================================
//Number of entries in the property table above
//====================================================================

DWORD nNumPGMProps = (sizeof(PGMPropertyTable)/sizeof(PROPERTYINFO));

//============================================================================
// 
//  PGM_LoadParser - Tells Netmon which protocol precedes and follows PGM
//
//  Modification history: June 30, 1999
//  
//  Madhurima Pawar      08/04/00    Created                                                                          
//============================================================================
DWORD PGM_LoadParser(PPF_PARSERINFO pParserInfo)
{
	DWORD NumberOfHandOffSets=1;

    //
	//This information is visible when the parser is selected in NetMon
    //
    wsprintf( pParserInfo->szProtocolName, "PGM" );
    wsprintf( pParserInfo->szComment,      "Pragmatic General Multicast (PGM)" );
    wsprintf( pParserInfo->szHelpFile,     "");

    //
    //Allocate memory for the handoffset and its two entries
    //
    pParserInfo->pWhoHandsOffToMe=(PPF_HANDOFFSET)
								  HeapAlloc (GetProcessHeap(),
                                             HEAP_ZERO_MEMORY,
											  sizeof (PF_HANDOFFSET) +
											  sizeof (PF_HANDOFFENTRY) * (NumberOfHandOffSets));
	
	if(NULL==pParserInfo->pWhoHandsOffToMe)
	{
		//
		//Unable to create handoffset
		//
		return 1;
	}
   pParserInfo->pWhoHandsOffToMe->nEntries=NumberOfHandOffSets; 
   
   //
   //Indicate the port that belong to PGM.
   //
   wsprintf (pParserInfo->pWhoHandsOffToMe->Entry[0].szIniFile, "TCPIP.INI");
   wsprintf (pParserInfo->pWhoHandsOffToMe->Entry[0].szIniSection, "IP_HandoffSet"); 
   wsprintf (pParserInfo->pWhoHandsOffToMe->Entry[0].szProtocol, "PGM"); 
   pParserInfo->pWhoHandsOffToMe->Entry[0].dwHandOffValue  = PGM_PROTOCOL_NUMBER; 
   pParserInfo->pWhoHandsOffToMe->Entry[0].ValueFormatBase = HANDOFF_VALUE_FORMAT_BASE_DECIMAL; 
  
   return 0;
}

//============================================================================
//  Function: ParserAutoInstallInfo
// 
//  Description: Installs the parser into NetMon. Sets up the Handoff set
//               The handoffset indicates which protocol hands of to the parser and
//               who the parser hands of to. 
//
//				 
//  Modification History
//
//  Madhurima Pawar      08/04/00    Created
//=============================================================================
PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo() 
{

    PPF_PARSERDLLINFO pParserDllInfo; 
    DWORD NumProtocols, Error;

	//The number of protocols in this parser is 1
    NumProtocols = 1;

    //Allocate memory for parser info:
    pParserDllInfo = (PPF_PARSERDLLINFO) HeapAlloc (GetProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    sizeof (PF_PARSERDLLINFO) +
                                                    (NumProtocols) * sizeof (PF_PARSERINFO));

    //Failed to allocate memory
    if( pParserDllInfo == NULL)
    {
		//
		//Unable to allocate memory
		//
        return NULL;
    }       
    
    // fill in the parser DLL info
    pParserDllInfo->nParsers = NumProtocols;

    // fill in the individual parser infos...
	Error = PGM_LoadParser (&(pParserDllInfo->ParserInfo[0]));
	if(Error)
	{
		//
		//Unable to allocate memory
		//
		return(NULL);
	}

	//Return the parser information to netmon
    return (pParserDllInfo);

}

//============================================================================
//  Function: DLLEntry
// 
//  Description: Registers the parser with Netmon and creates the PGM
//				 Properties table.
//
//  Modification History
//
//  Madhurima Pawar      08/04/00    Created
//=============================================================================

BOOL WINAPI DLLEntry( HANDLE hInstance, ULONG Command, LPVOID Reserved)
{

    // what type of call is this
    switch( Command )
    {
        case DLL_PROCESS_ATTACH:

            // are we loading for the first time?
            if (PGMAttached == 0)
            {
                // the first time in we need to tell the kernel 
                // about ourselves
				//Create PGM db it PGM added to Parser
				hPGM = CreateProtocol ("PGM",  &PGMEntryPoints,  ENTRYPOINTS_SIZE);
            }

            PGMAttached++;
            break;

        case DLL_PROCESS_DETACH:

            // are we detaching our last instance?
            PGMAttached--;
            if( PGMAttached == 0 )
            {
                // last guy out needs to clean up
                DestroyProtocol( hPGM);

            }
            break;
    }

    // Netmon parsers ALWAYS return TRUE.
    return TRUE;
}

//============================================================================
//  Function: PGM_Register
// 
//  Description: Create our property database and handoff sets.
//
//  Modification History
//
//  Madhurima Pawar      08/04/00    Created
//============================================================================

VOID BHAPI PGM_Register( HPROTOCOL hPGM)
{
    WORD  i;

	//
    // tell the kernel to make reserve some space for our property table
	//
    CreatePropertyDatabase (hPGM, nNumPGMProps);

	//
    // add our properties to the kernel's database
	//
    for (i = 0; i < nNumPGMProps; i++)
    {
        AddProperty (hPGM, &PGMPropertyTable[i]);
    }

}

//============================================================================
//  Function: PGM_Deregister
// 
//  Description: Destroy our property database and handoff set
//
//  Modification History
//
//  Madhurima Pawar      08/04/00    Created
//============================================================================

VOID WINAPI PGM_Deregister( HPROTOCOL hPGM)
{
    // tell the kernel that it may now free our database
    DestroyPropertyDatabase (hPGM);
}

//============================================================================
//  Function: PGM_RecognizeFrame
// 
//  Description: Determine whether we exist in the frame at the spot 
//               indicated. We also indicate who (if anyone) follows us
//               and how much of the frame we claim.
//
//============================================================================

LPBYTE BHAPI PGM_RecognizeFrame( HFRAME      hFrame,         
                                 LPBYTE      pMacFrame,      
                                 LPBYTE      pPGMFrame, 
                                 DWORD       MacType,        
                                 DWORD       BytesLeft,      
                                 HPROTOCOL   hPrevProtocol,  
                                 DWORD       nPrevProtOffset,
                                 LPDWORD     pProtocolStatus,
                                 LPHPROTOCOL phNextProtocol,
                                 PDWORD_PTR     InstData)       
{
    //
    // Since we do not know of any protocol currently on top of Pgm,
    // we do not need to do much here.
    //
#if 0
    PPGM_COMMON_HDR         pPGMHdr = (PPGM_COMMON_HDR) pPGMFrame;
    SPM_PACKET_HEADER       *pSpm = (SPM_PACKET_HEADER *) pPGMFrame;
    DATA_PACKET_HEADER      *pData = (DATA_PACKET_HEADER *) pPGMFrame;
    NAK_NCF_PACKET_HEADER   *pNakNcf = (NAK_NCF_PACKET_HEADER *) pPGMFrame;
    DWORD                   BytesRequired = sizeof (PGM_COMMON_HDR);
    BYTE                    PacketType;
    tPACKET_OPTION_LENGTH UNALIGNED *pPacketExtension = NULL;

    // do we have the minimum header
    if (BytesLeft < BytesRequired)
    {
        //
        // This not a valid Pgm frame
        //
        *pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
        return NULL;
    }

    PacketType = pPGMHdr->Type & 0x0f;
    switch (PacketType)
    {
        case (PACKET_TYPE_SPM):
        {
            BytesRequired = sizeof (SPM_PACKET_HEADER);
            pPacketExtension = (tPACKET_OPTION_LENGTH UNALIGNED *) (pSpm + 1);
            break;
        }

        case (PACKET_TYPE_ODATA):
        case (PACKET_TYPE_RDATA):
        {
            BytesRequired = sizeof (DATA_PACKET_HEADER);
            pPacketExtension = (tPACKET_OPTION_LENGTH UNALIGNED *) (pData + 1);
            break;
        }

        case (PACKET_TYPE_NAK):
        case (PACKET_TYPE_NCF):
        {
            BytesTaken = sizeof (NAK_NCF_PACKET_HEADER);
            pPacketExtension = (tPACKET_OPTION_LENGTH UNALIGNED *) (pNakNcf + 1);
            break;
        }

        default:
        {
            //
            // This not a recognized Pgm frame
            //
            *pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
            return NULL;
        }
    }

    if ((pPGMHdr->Options & PACKET_HEADER_OPTIONS_PRESENT) &&
        (BytesLeft >= BytesRequired + (sizeof(tPACKET_OPTION_LENGTH) + sizeof(tPACKET_OPTION_GENERIC))))
    {
        BytesRequired += pPacketExtension->TotalOptionsLength;
    }

    // do we have a complete header
    if (BytesLeft < BytesRequired)
    {
        //
        // This not a valid Pgm frame
        //
        *pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
        return NULL;
    }


    if (BytesLeft <= BytesRequired)
    {
	    // No protocol follows us so claim whole packet
        *pProtocolStatus = PROTOCOL_STATUS_CLAIMED;
        return NULL;
    }
    *pProtocolStatus = PROTOCOL_STATUS_RECOGNIZED;

    return NULL;
#endif  // 0

    // this is a Pgm frame but we don't know the next protocol
    *pProtocolStatus = PROTOCOL_STATUS_CLAIMED;

    return NULL;
}

//============================================================================
//============================================================================

DWORD
ProcessOptions(
    HFRAME                          hFrame,
    tPACKET_OPTION_LENGTH UNALIGNED *pPacketExtension,
    DWORD                           BytesLeft,
    BYTE                            PacketType
    )
{
    tPACKET_OPTION_GENERIC UNALIGNED    *pOptionHeader;
    USHORT                              TotalOptionsLength;
    DWORD                               BytesProcessed = 0;
    UCHAR                               i;

    if ((BytesLeft < ((sizeof(tPACKET_OPTION_LENGTH) + sizeof(tPACKET_OPTION_GENERIC)))) || // Ext+opt
        (pPacketExtension->Type != PACKET_OPTION_LENGTH) ||
        (pPacketExtension->Length != 4) ||
        (BytesLeft < (TotalOptionsLength = ntohs (pPacketExtension->TotalOptionsLength))))  // Verify length
    {
        //
        // Need to get at least our header from transport!
        //
        return (BytesProcessed);
    }

    AttachPropertyInstance (hFrame,
                            PGMPropertyTable[PGM_HEADER_OPTIONS].hProperty,
                            TotalOptionsLength,
                            pPacketExtension,
                            0,1,0); // HELPID, Level, Errorflag

    AttachPropertyInstance (hFrame,
                            PGMPropertyTable[PGM_OPTIONS_FIELD_LENGTH].hProperty,
                            sizeof (WORD),
                            &pPacketExtension->TotalOptionsLength,
                            0,2,0); // HELPID, Level, Errorflag

    pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) (pPacketExtension + 1);
    BytesLeft -= PACKET_OPTION_LENGTH;
    BytesProcessed += PGM_PACKET_EXTENSION_LENGTH;

    do
    {
        if (pOptionHeader->Length > BytesLeft)
        {
            return (BytesProcessed);
        }

        switch (pOptionHeader->OptionType & ~PACKET_OPTION_TYPE_END_BIT)
        {
            case (PACKET_OPTION_NAK_LIST):
            {
                if (((PacketType != PACKET_TYPE_NAK) &&
                     (PacketType != PACKET_TYPE_NCF) &&
                     (PacketType != PACKET_TYPE_NNAK)) ||
                    (pOptionHeader->Length < PGM_PACKET_OPT_MIN_NAK_LIST_LENGTH) ||
                    (pOptionHeader->Length > PGM_PACKET_OPT_MAX_NAK_LIST_LENGTH))
                {
                    return (BytesProcessed);
                }

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTION_TYPE_NAK_SEQ].hProperty,
                                        pOptionHeader->Length,
                                        pOptionHeader,
                                        0,2,0); // HELPID, Level, Errorflag

                for (i=0; i < (pOptionHeader->Length-4)/4; i++)
                {
                    AttachPropertyInstance (hFrame,
                                            PGMPropertyTable[PGM_OPTIONS_NAK_SEQ].hProperty,
                                            sizeof (DWORD),
                                            &((PULONG)(pOptionHeader+1))[i],
                                            0,3,0); // HELPID, Level, Errorflag
                }

                break;
            }

            case (PACKET_OPTION_FRAGMENT):
            {
                if (pOptionHeader->Length != PGM_PACKET_OPT_FRAGMENT_LENGTH)
                {
                    return (BytesProcessed);
                }

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTION_TYPE_FRAGMENT].hProperty,
                                        PGM_PACKET_OPT_FRAGMENT_LENGTH,
                                        pOptionHeader,
                                        0,2,0); // HELPID, Level, Errorflag

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTIONS_MESSAGE_FIRST_SEQUENCE].hProperty,
                                        sizeof (DWORD),
                                        &((PULONG)(pOptionHeader+1))[0],
                                        0,3,0); // HELPID, Level, Errorflag

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTIONS_MESSAGE_OFFSET].hProperty,
                                        sizeof (DWORD),
                                        &((PULONG)(pOptionHeader+1))[1],
                                        0,3,0); // HELPID, Level, Errorflag

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTIONS_MESSAGE_LENGTH].hProperty,
                                        sizeof (DWORD),
                                        &((PULONG)(pOptionHeader+1))[2],
                                        0,3,0); // HELPID, Level, Errorflag

                break;
            }

            case (PACKET_OPTION_JOIN):
            {
                if (pOptionHeader->Length != PGM_PACKET_OPT_JOIN_LENGTH)
                {
                    return (BytesProcessed);
                }

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTION_TYPE_LATE_JOINER].hProperty,
                                        PGM_PACKET_OPT_JOIN_LENGTH,
                                        pOptionHeader,
                                        0,2,0); // HELPID, Level, Errorflag

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTIONS_LATE_JOINER].hProperty,
                                        sizeof (DWORD),
                                        &((PULONG)(pOptionHeader+1))[0],
                                        0,3,0); // HELPID, Level, Errorflag

                break;
            }

            case (PACKET_OPTION_SYN):
            {
                if (pOptionHeader->Length != PGM_PACKET_OPT_SYN_LENGTH)
                {
                    return (BytesProcessed);
                }

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTION_TYPE_SYN].hProperty,
                                        PGM_PACKET_OPT_SYN_LENGTH,
                                        pOptionHeader,
                                        0, 2, 0);

                break;
            }

            case (PACKET_OPTION_FIN):
            {
                if (pOptionHeader->Length != PGM_PACKET_OPT_FIN_LENGTH)
                {
                    return (BytesProcessed);
                }

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTION_TYPE_FIN].hProperty,
                                        PGM_PACKET_OPT_FIN_LENGTH,
                                        pOptionHeader,
                                        0, 2, 0);

                break;
            }

            case (PACKET_OPTION_RST):
            {
                if (pOptionHeader->Length != PGM_PACKET_OPT_RST_LENGTH)
                {
                    return (BytesProcessed);
                }

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTION_TYPE_RST].hProperty,
                                        PGM_PACKET_OPT_RST_LENGTH,
                                        pOptionHeader,
                                        0, 2, 0);

                break;
            }

            //
            // FEC options
            //
            case (PACKET_OPTION_PARITY_PRM):
            {
                if (pOptionHeader->Length != PGM_PACKET_OPT_PARITY_PRM_LENGTH)
                {
                    return (BytesProcessed);
                }

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTION_TYPE_PARITY_PRM].hProperty,
                                        PGM_PACKET_OPT_PARITY_PRM_LENGTH,
                                        pOptionHeader,
                                        0, 2, 0);

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTIONS_PARITY_OPT].hProperty,
                                        sizeof (BYTE),
                                        &pOptionHeader->OptionSpecific,
                                        0,3,0); // HELPID, Level, Errorflag

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTIONS_PARITY_PRM_GRP_SZ].hProperty,
                                        sizeof (DWORD),
                                        &((PULONG)(pOptionHeader+1))[0],
                                        0,3,0); // HELPID, Level, Errorflag

                break;
            }

            case (PACKET_OPTION_PARITY_GRP):
            {
                if (pOptionHeader->Length != PGM_PACKET_OPT_PARITY_GRP_LENGTH)
                {
                    return (BytesProcessed);
                }

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTION_TYPE_PARITY_GRP].hProperty,
                                        PGM_PACKET_OPT_PARITY_GRP_LENGTH,
                                        pOptionHeader,
                                        0, 2, 0);

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTIONS_PARITY_GRP].hProperty,
                                        sizeof (DWORD),
                                        &((PULONG)(pOptionHeader+1))[0],
                                        0,3,0); // HELPID, Level, Errorflag

                break;
            }

            case (PACKET_OPTION_CURR_TGSIZE):
            {
                if (pOptionHeader->Length != PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH)
                {
                    return (BytesProcessed);
                }

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTION_TYPE_PARITY_TGSIZE].hProperty,
                                        PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH,
                                        pOptionHeader,
                                        0, 2, 0);

                AttachPropertyInstance (hFrame,
                                        PGMPropertyTable[PGM_OPTIONS_PARITY_TG_SZ].hProperty,
                                        sizeof (DWORD),
                                        &((PULONG)(pOptionHeader+1))[0],
                                        0,3,0); // HELPID, Level, Errorflag

                break;
            }

            default:
            {
                return (BytesProcessed);
            }
        }

        BytesLeft -= pOptionHeader->Length;
        BytesProcessed += pOptionHeader->Length;

        if (pOptionHeader->OptionType & PACKET_OPTION_TYPE_END_BIT)
        {
            break;
        }

        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *)
                            (((UCHAR *) pOptionHeader) + pOptionHeader->Length);

    } while (BytesLeft >= sizeof(tPACKET_OPTION_GENERIC));

    return (BytesProcessed);
}


VOID
PGM_FmtNLA(
    HFRAME  hFrame,
    NLA     *pNLA,
    BOOL    fIsSourceNLA
    )
{
    //The type of the PGM frame
    if (fIsSourceNLA)
    {
        AttachPropertyInstance (hFrame,
                                PGMPropertyTable[PGM_NLA_TYPE_SOURCE].hProperty,
                                sizeof (NLA),
                                pNLA,
                                0,1,0); // HELPID, Level, Errorflag
    }
    else
    {
        AttachPropertyInstance (hFrame,
                                PGMPropertyTable[PGM_NLA_TYPE_MCAST_GROUP].hProperty,
                                sizeof (NLA),
                                pNLA,
                                0,1,0); // HELPID, Level, Errorflag
    }

    AttachPropertyInstance (hFrame,
                            PGMPropertyTable[PGM_NLA_AFI].hProperty,
                            sizeof (WORD),
                            &pNLA->NLA_AFI,
                            0,2,0); // HELPID, Level, Errorflag

    AttachPropertyInstance (hFrame,
                            PGMPropertyTable[PGM_NLA_RESERVED].hProperty,
                            sizeof (WORD),
                            &pNLA->Reserved,
                            0,2,0); // HELPID, Level, Errorflag

    AttachPropertyInstance (hFrame,
                            PGMPropertyTable[PGM_NLA_IP].hProperty,
                            sizeof (DWORD),
                            &pNLA->IpAddress,
                            0,2,0); // HELPID, Level, Errorflag
}

//============================================================================
//  Function: PGM_AttachProperties
// 
//  Description: Indicate where in the frame each of our properties live.
//
//  Modification History
//
//  Madhurima Pawar      08/04/00    Created
//============================================================================

LPBYTE BHAPI PGM_AttachProperties( HFRAME      hFrame,         
                                      LPBYTE      pMacFrame,     
                                      LPBYTE      pPGMFrame,   
                                      DWORD       MacType,        
                                      DWORD       BytesLeft,      
                                      HPROTOCOL   hPrevProtocol,  
                                      DWORD       nPrevProtOffset,
                                      DWORD_PTR   InstData)       

{
    PPGM_COMMON_HDR     pPGMHdr = (PPGM_COMMON_HDR)pPGMFrame;
    BYTE                PacketType;
    USHORT              TSIPort;
    UCHAR               pGlobalSrcId [SOURCE_ID_LENGTH*2+1+sizeof(USHORT)*2+1];
    SPM_PACKET_HEADER       *pSpm = (SPM_PACKET_HEADER *) pPGMHdr;
    DATA_PACKET_HEADER      *pData = (DATA_PACKET_HEADER *) pPGMHdr;
    NAK_NCF_PACKET_HEADER   *pNakNcf = (NAK_NCF_PACKET_HEADER *) pPGMHdr;
    tPACKET_OPTION_LENGTH   *pOptionsHeader = NULL;
    DWORD               BytesTaken = 0;
    DWORD               OptionsLength = 0;
    PUCHAR              pPgmData;

    PacketType = pPGMHdr->Type & 0x0f;
    if ((PacketType == PACKET_TYPE_NAK)  ||
        (PacketType == PACKET_TYPE_NNAK) ||
        (PacketType == PACKET_TYPE_SPMR) ||
        (PacketType == PACKET_TYPE_POLR))
    {
        TSIPort = ntohs (pPGMHdr->DestPort);
    }
    else
    {
        TSIPort = ntohs (pPGMHdr->SrcPort);
    }

    wsprintf (pGlobalSrcId, "%02X%02X%02X%02X%02X%02X.%04X",
                pPGMHdr->gSourceId[0],
                pPGMHdr->gSourceId[1],
                pPGMHdr->gSourceId[2],
                pPGMHdr->gSourceId[3],
                pPGMHdr->gSourceId[4],
                pPGMHdr->gSourceId[5],
                TSIPort);

    //Add the PGM header information
    //PGM summary information transaction ID and Message type
    //Has a special formater PGM_FormatSummary
    AttachPropertyInstance( hFrame,
                            PGMPropertyTable[PGM_SUMMARY].hProperty,
                            (WORD) BytesLeft,
                            (LPBYTE)pPGMFrame,
                            0, 0, 0 );

    //The source port of the PGM frame
    AttachPropertyInstance (hFrame,
                            PGMPropertyTable[PGM_SOURCE_PORT].hProperty,
                            sizeof(WORD),
                            &pPGMHdr->SrcPort,
                            0, 1, 0);

    AttachPropertyInstance (hFrame,
                            PGMPropertyTable[PGM_DESTINATION_PORT].hProperty,
                            sizeof(WORD),
                            &pPGMHdr->DestPort,
                            0, 1, 0);

    //The type of the PGM frame
    AttachPropertyInstanceEx( hFrame,
                            PGMPropertyTable[PGM_TYPE].hProperty,
                            sizeof(BYTE),
                            &pPGMHdr->Type,
                            sizeof(BYTE),
                            &PacketType,
                            0, 1, 0);

    AttachPropertyInstance (hFrame,
                            PGMPropertyTable[PGM_OPTIONS].hProperty,
                            sizeof (BYTE),
                            &pPGMHdr->Options,
                            0,1,0); // HELPID, Level, Errorflag

    AttachPropertyInstance (hFrame,
                            PGMPropertyTable[PGM_OPTIONS_FLAGS].hProperty,
                            sizeof (BYTE),
                            &pPGMHdr->Options,
                            0,2,0); // HELPID, Level, Errorflag


    //The checksum of the PGM frame
    AttachPropertyInstance( hFrame,
                            PGMPropertyTable[PGM_CHECKSUM].hProperty,
                            sizeof(WORD),
                            &(pPGMHdr->Checksum),
                            0, 1, 0);

    //The Global Session Id
    AttachPropertyInstanceEx (hFrame,
                              PGMPropertyTable[PGM_GLOBAL_SOURCE_ID].hProperty,
                              SOURCE_ID_LENGTH,
                              pPGMHdr->gSourceId,
                              (SOURCE_ID_LENGTH*2+1+sizeof(USHORT)*2+1),
                              pGlobalSrcId,
                              0, 1, 0);

   //The source port of the PGM frame
    AttachPropertyInstance( hFrame,
                            PGMPropertyTable[PGM_TSDU_LENGTH].hProperty,
                            sizeof(WORD),
                            &pPGMHdr->TSDULength,
                            0, 1, 0);
    switch (PacketType)
    {
        case (PACKET_TYPE_SPM):
        {
            // Spm Sequence Number
            AttachPropertyInstance (hFrame,
                                    PGMPropertyTable[PGM_SEQUENCE_NUMBER].hProperty,
                                    sizeof(DWORD),
                                    &pSpm->SpmSequenceNumber,
                                    0, 1, 0);

            // Sender's trailing edge
            AttachPropertyInstance (hFrame,
                                    PGMPropertyTable[PGM_TRAILING_EDGE].hProperty,
                                    sizeof(DWORD),
                                    &pSpm->TrailingEdgeSeqNumber,
                                    0, 1, 0);

            // Sender's trailing edge
            AttachPropertyInstance (hFrame,
                                    PGMPropertyTable[PGM_LEADING_EDGE].hProperty,
                                    sizeof(DWORD),
                                    &pSpm->LeadingEdgeSeqNumber,
                                    0, 1, 0);

            PGM_FmtNLA (hFrame, &pSpm->PathNLA, TRUE);

            BytesTaken = sizeof (SPM_PACKET_HEADER);
            pOptionsHeader = (tPACKET_OPTION_LENGTH *) (pSpm + 1);

            break;
        }

        case (PACKET_TYPE_ODATA):
        case (PACKET_TYPE_RDATA):
        {
            // Sender's sequence number
            AttachPropertyInstance (hFrame,
                                    PGMPropertyTable[PGM_SEQUENCE_NUMBER].hProperty,
                                    sizeof(DWORD),
                                    &pData->DataSequenceNumber,
                                    0, 1, 0);

            // Sender's trailing edge
            AttachPropertyInstance (hFrame,
                                    PGMPropertyTable[PGM_TRAILING_EDGE].hProperty,
                                    sizeof(DWORD),
                                    &pData->TrailingEdgeSequenceNumber,
                                    0, 1, 0);

            BytesTaken = sizeof (DATA_PACKET_HEADER);
            pOptionsHeader = (tPACKET_OPTION_LENGTH *) (pData + 1);

            break;
        }

        case (PACKET_TYPE_NAK):
        case (PACKET_TYPE_NCF):
        {
            AttachPropertyInstance (hFrame,
                                    PGMPropertyTable[PGM_SEQUENCE_NUMBER].hProperty,
                                    sizeof(DWORD),
                                    &pNakNcf->RequestedSequenceNumber,
                                    0, 1, 0);

            PGM_FmtNLA (hFrame, &pNakNcf->SourceNLA, TRUE);
            PGM_FmtNLA (hFrame, &pNakNcf->MCastGroupNLA, FALSE);

            BytesTaken = sizeof (NAK_NCF_PACKET_HEADER);
            pOptionsHeader = (tPACKET_OPTION_LENGTH *) (pNakNcf + 1);

            break;
        }

        default:
        {
            break;
        }
    }

    if ((pPGMHdr->Options & PACKET_HEADER_OPTIONS_PRESENT) &&
        (pOptionsHeader))
    {
        OptionsLength = ProcessOptions (hFrame, pOptionsHeader, (BytesLeft-BytesTaken), PacketType);
    }

    if (((PacketType == PACKET_TYPE_ODATA) ||
         (PacketType == PACKET_TYPE_RDATA)) &&
        (BytesLeft > (BytesTaken+OptionsLength)))
    {
        BytesLeft -= (BytesTaken+OptionsLength);

        pPgmData = ((PUCHAR) pPGMHdr) + BytesTaken + OptionsLength;
        AttachPropertyInstance (hFrame,
                                PGMPropertyTable[PGM_DATA].hProperty,
                                BytesLeft,
                                pPgmData,
                                0,1,0); // HELPID, Level, Errorflag
    }

    //Always returns NULL
    return NULL;
}

//============================================================================
//  Function: PGM_FormatProperties
// 
//  Description: Format the given properties on the given frame.
//
//  Modification History
//
//  Madhurima Pawar      08/04/00    Created
//============================================================================
DWORD BHAPI PGM_FormatProperties( HFRAME          hFrame,
                                  LPBYTE          pMacFrame,
                                  LPBYTE          pPGMFrame,
                                  DWORD           nPropertyInsts,
                                  LPPROPERTYINST  p)
{
    // loop through the property instances
    while( nPropertyInsts-- > 0)
    {
        // and call the formatter for each
        ( (FORMAT)(p->lpPropertyInfo->InstanceData) )( p);
        p++;
    }

    return NMERR_SUCCESS;
}


//*****************************************************************************
//
// Name:    PGM_FmtSummary
//
// Description:
//
// Parameters:  LPPROPERTYINST lpPropertyInst: pointer to property instance.
//
// Return Code: VOID.
//
// History:
// 10/15/2000  MAlam  Created.
//
//*****************************************************************************

VOID WINAPIV
PGM_FmtSummary(
    LPPROPERTYINST pPropertyInst
    )
{

    LPBYTE                  pReturnedString = pPropertyInst->szPropertyText;
    PPGM_COMMON_HDR         pPgmHeader = (PPGM_COMMON_HDR) (pPropertyInst->lpData);
    SPM_PACKET_HEADER       *pSpm = (SPM_PACKET_HEADER *) pPgmHeader;
    DATA_PACKET_HEADER      *pData = (DATA_PACKET_HEADER *) pPgmHeader;
    NAK_NCF_PACKET_HEADER   *pNakNcf = (NAK_NCF_PACKET_HEADER *) pPgmHeader;
    UCHAR                   PacketType = pPgmHeader->Type & 0x0f;
    UCHAR                   *szPacketDesc = NULL;
    USHORT                  TSIPort;

    if ((PacketType == PACKET_TYPE_NAK)  ||
        (PacketType == PACKET_TYPE_NNAK) ||
        (PacketType == PACKET_TYPE_SPMR) ||
        (PacketType == PACKET_TYPE_POLR))
    {
        TSIPort = ntohs (pPgmHeader->DestPort);
    }
    else
    {
        TSIPort = ntohs (pPgmHeader->SrcPort);
    }

    szPacketDesc = LookupByteSetString (&PGMTypesSET, PacketType);
    wsprintf (pReturnedString,
              "%s%s:",
               szPacketDesc, (pPgmHeader->Options & PACKET_HEADER_OPTIONS_PARITY ? " (P)" : ""));

    switch (PacketType)
    {
        case (PACKET_TYPE_SPM):
        {
            wsprintf (&pReturnedString [strlen(pReturnedString)],
                " Seq: %d, Window: %d-%d",
                ntohl (pSpm->SpmSequenceNumber), ntohl (pSpm->TrailingEdgeSeqNumber), ntohl (pSpm->LeadingEdgeSeqNumber));

            break;
        }

        case (PACKET_TYPE_ODATA):
        case (PACKET_TYPE_RDATA):
        {
            wsprintf (&pReturnedString [strlen(pReturnedString)],
                " Seq: %d, Trail: %d, DataBytes: %d",
                ntohl (pData->DataSequenceNumber), ntohl (pData->TrailingEdgeSequenceNumber),
                ((ULONG) ntohs (pPgmHeader->TSDULength)));

            break;
        }

        case (PACKET_TYPE_NAK):
        case (PACKET_TYPE_NCF):
        {
            wsprintf (&pReturnedString [strlen(pReturnedString)],
                " Seq: %d%s",
                ntohl (pNakNcf->RequestedSequenceNumber),
                (pPgmHeader->Options & PACKET_HEADER_OPTIONS_PRESENT ? " ..." : ""));

            break;
        }

        default:
        {
            break;
        }
    }

    wsprintf (&pReturnedString [strlen(pReturnedString)],
              " TSIPort = %hu", TSIPort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\address.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Address.c

Abstract:

    This module implements Address handling routines
    for the PGM Transport

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"

#include <ipinfo.h>     // for IPInterfaceInfo
#include <tcpinfo.h>    // for AO_OPTION_xxx, TCPSocketOption
#include <tdiinfo.h>    // for CL_TL_ENTITY, TCP_REQUEST_SET_INFORMATION_EX

#ifdef FILE_LOGGING
#include "address.tmh"
#endif  // FILE_LOGGING

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#endif
//*******************  Pageable Routine Declarations ****************


#if(WINVER <= 0x0500)
extern POBJECT_TYPE *IoFileObjectType;
#endif  // WINVER

//----------------------------------------------------------------------------

BOOLEAN
GetIpAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *pTransportAddr,
    IN  ULONG                       BufferLength,   // Total Buffer length
    OUT tIPADDRESS                  *pIpAddress,
    OUT USHORT                      *pPort
    )
/*++

Routine Description:

    This routine extracts the IP address from the TDI address block

Arguments:

    IN  pTransportAddr  -- the block of TDI address(es)
    IN  BufferLength    -- length of the block
    OUT pIpAddress      -- contains the IpAddress if we succeeded
    OUT pPort           -- contains the port if we succeeded

Return Value:

    TRUE if we succeeded in extracting the IP address, FALSE otherwise

--*/
{
    ULONG                       MinBufferLength;    // Minimun reqd to read next AddressType and AddressLength
    TA_ADDRESS                  *pAddress;
    TDI_ADDRESS_IP UNALIGNED    *pValidAddr;
    INT                         i;
    BOOLEAN                     fAddressFound = FALSE;

    if (BufferLength < sizeof(TA_IP_ADDRESS))
    {
        PgmTrace (LogError, ("GetIpAddress: ERROR -- "  \
            "Rejecting Open Address request -- BufferLength<%d> < Min<%d>\n",
                BufferLength, sizeof(TA_IP_ADDRESS)));
        return (FALSE);
    }

    try
    {
        MinBufferLength = FIELD_OFFSET(TRANSPORT_ADDRESS,Address) + FIELD_OFFSET(TA_ADDRESS,Address);
        pAddress = (TA_ADDRESS *) &pTransportAddr->Address[0];  // address type + the actual address
        for (i=0; i<pTransportAddr->TAAddressCount; i++)
        {
            //
            // We support only IP address types:
            //
            if ((pAddress->AddressType == TDI_ADDRESS_TYPE_IP) &&
                (pAddress->AddressLength >= TDI_ADDRESS_LENGTH_IP)) // sizeof (TDI_ADDRESS_IP)
            {

                pValidAddr = (TDI_ADDRESS_IP UNALIGNED *) pAddress->Address;
                *pIpAddress = pValidAddr->in_addr;
                *pPort = pValidAddr->sin_port;
                fAddressFound = TRUE;
                break;
            }

            //
            // Verify that we have enough Buffer space to read in next Address if IP address
            //
            MinBufferLength += pAddress->AddressLength + FIELD_OFFSET(TA_ADDRESS,Address);
            if (BufferLength < (MinBufferLength + sizeof(TDI_ADDRESS_IP)))
            {
                break;
            }

            //
            // Set pAddress to point to the next address
            //
            pAddress = (TA_ADDRESS *) (((PUCHAR) pAddress->Address) + pAddress->AddressLength);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        PgmTrace (LogError, ("GetIpAddress: ERROR -- "  \
            "Exception <0x%x> trying to access Addr info\n", GetExceptionCode()));
    }

    PgmTrace (LogAllFuncs, ("GetIpAddress:  "  \
        "%s!\n", (fAddressFound ? "SUCCEEDED" : "FAILED")));

    return (fAddressFound);
}


//----------------------------------------------------------------------------

NTSTATUS
SetSenderMCastOutIf(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tIPADDRESS          IpAddress       // Net format
    )
/*++

Routine Description:

    This routine sets the outgoing interface for multicast traffic

Arguments:

    IN  pAddress    -- Pgm's Address object (contains file handle over IP)
    IN  IpAddress   -- interface address

Return Value:

    NTSTATUS - Final status of the set Interface operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    ULONG               BufferLength = 50;
    IPInterfaceInfo     *pIpIfInfo = NULL;

    status = PgmSetTcpInfo (pAddress->FileHandle,
                            AO_OPTION_MCASTIF,
                            &IpAddress,
                            sizeof (tIPADDRESS));

    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("SetSenderMCastOutIf: ERROR -- "  \
            "AO_OPTION_MCASTIF for <%x> (RouterAlert) returned <%x>\n", IpAddress, status));

        return (status);
    }

    status = PgmSetTcpInfo (pAddress->RAlertFileHandle,
                            AO_OPTION_MCASTIF,
                            &IpAddress,
                            sizeof (tIPADDRESS));
    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("SetSenderMCastOutIf: ERROR -- "  \
            "AO_OPTION_MCASTIF for <%x> (RouterAlert) returned <%x>\n", IpAddress, status));

        return (status);
    }

    //
    // Now, determine the MTU
    //
    status = PgmQueryTcpInfo (pAddress->RAlertFileHandle,
                              IP_INTFC_INFO_ID,
                              &IpAddress,
                              sizeof (tIPADDRESS),
                              &pIpIfInfo,
                              &BufferLength);

    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("SetSenderMCastOutIf: ERROR -- "  \
            "IP_INTFC_INFO_ID for <%x> returned <%x>\n", IpAddress, status));

        return (status);
    }

    if (pIpIfInfo->iii_mtu <= (sizeof(IPV4Header) +
                            ROUTER_ALERT_SIZE +
                            PGM_MAX_FEC_DATA_HEADER_LENGTH))
    {
        PgmTrace (LogError, ("SetSenderMCastOutIf: ERROR -- "  \
            "MTU=<%d> for Ip=<%x> is too small, <= <%d>\n",
                pIpIfInfo->iii_mtu, IpAddress,
                (sizeof(IPV4Header) + ROUTER_ALERT_SIZE + PGM_MAX_FEC_DATA_HEADER_LENGTH)));

        PgmFreeMem (pIpIfInfo);

        return (STATUS_UNSUCCESSFUL);
    }

    PgmLock (pAddress, OldIrq);

    //
    // get the length of the mac address in case is is less than 6 bytes
    //
    BufferLength = pIpIfInfo->iii_addrlength < sizeof(tMAC_ADDRESS) ?
                                            pIpIfInfo->iii_addrlength : sizeof(tMAC_ADDRESS);
    PgmZeroMemory (pAddress->OutIfMacAddress.Address, sizeof(tMAC_ADDRESS));
    PgmCopyMemory (&pAddress->OutIfMacAddress, pIpIfInfo->iii_addr, BufferLength);
    pAddress->OutIfMTU = pIpIfInfo->iii_mtu - (sizeof(IPV4Header) + ROUTER_ALERT_SIZE);
    pAddress->OutIfFlags = pIpIfInfo->iii_flags;
    pAddress->SenderMCastOutIf = ntohl (IpAddress);

    PgmUnlock (pAddress, OldIrq);

    PgmTrace (LogStatus, ("SetSenderMCastOutIf:  "  \
        "OutIf=<%x>, MTU=<%d>==><%d>\n",
            pAddress->SenderMCastOutIf, pIpIfInfo->iii_mtu, pAddress->OutIfMTU));

    PgmFreeMem (pIpIfInfo);
    return (status);
}


//----------------------------------------------------------------------------

VOID
PgmDestroyAddress(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  PVOID               Unused1,
    IN  PVOID               Unused2
    )
/*++

Routine Description:

    This routine closes the Files handles opened earlier and free's the memory
    It should only be called if there is no Reference on the Address Context

Arguments:

    IN  pAddress    -- Pgm's Address object

Return Value:

    NONE

--*/
{
    if (pAddress->RAlertFileHandle)
    {
        CloseAddressHandles (pAddress->RAlertFileHandle, pAddress->pRAlertFileObject);
        pAddress->RAlertFileHandle = NULL;
    }

    if (pAddress->FileHandle)
    {
        CloseAddressHandles (pAddress->FileHandle, pAddress->pFileObject);
        pAddress->FileHandle = NULL;
    }
    else
    {
        ASSERT (0);
    }

    if (pAddress->pUserId)
    {
        PgmFreeMem (pAddress->pUserId);
        pAddress->pUserId = NULL;
    }

    PgmFreeMem (pAddress);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmCreateAddress(
    IN  tPGM_DEVICE                 *pPgmDevice,
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp,
    IN  PFILE_FULL_EA_INFORMATION   TargetEA
    )
/*++

Routine Description:

    This routine is called to create an address context for the client
    It's main task is to allocate the memory, open handles on IP, and
    set the initial IP options

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer
    IN  TargetEA    -- contains the MCast address info (determines whether
                        the client is a sender or receiver)

Return Value:

    NTSTATUS - Final status of the CreateAddress operation

--*/
{
    tADDRESS_CONTEXT            *pAddress = NULL;
    PADDRESS_CONTEXT            pOldAddress, pOldAddressToDeref;
    TRANSPORT_ADDRESS UNALIGNED *pTransportAddr;
    tMCAST_INFO                 MCastInfo;
    NTSTATUS                    status;
    tIPADDRESS                  IpAddress;
    LIST_ENTRY                  *pEntry;
    USHORT                      Port;
    PGMLockHandle               OldIrq;
    ULONG                       NumUserStreams;
    TOKEN_USER                  *pUserId = NULL;
    BOOLEAN                     fUserIsAdmin = FALSE;

    status = PgmGetUserInfo (pIrp, pIrpSp, &pUserId, &fUserIsAdmin);
    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("PgmCreateAddress: ERROR -- "  \
            "GetUserInfo FAILed status=<%x>!\n", status));
    }

    //
    // Verify Minimum Buffer length!
    //
    pTransportAddr = (TRANSPORT_ADDRESS UNALIGNED *) &(TargetEA->EaName[TargetEA->EaNameLength+1]);
    if (!GetIpAddress (pTransportAddr, TargetEA->EaValueLength, &IpAddress, &Port))
    {
        PgmTrace (LogError, ("PgmCreateAddress: ERROR -- "  \
            "GetIpAddress FAILed to return valid Address!\n"));

        PgmFreeMem (pUserId);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    //
    // Convert the parameters to host format
    //
    IpAddress = ntohl (IpAddress);
    Port = ntohs (Port);

    //
    // If we have been supplied an address at bind time, it has to
    // be a Multicast address
    //
    if ((IpAddress) &&
        (!IS_MCAST_ADDRESS (IpAddress)))
    {
        PgmTrace (LogError, ("PgmCreateAddress: ERROR -- "  \
            "IP=<%x> is not MCast addr!\n", IpAddress));

        PgmFreeMem (pUserId);
        return (STATUS_UNSUCCESSFUL);
    }
    else if ((!IpAddress) &&
             (!fUserIsAdmin))
    {
        PgmTrace (LogError, ("PgmCreateAddress: ERROR -- "  \
            "Sender MUST be Admin!\n"));

        PgmFreeMem (pUserId);
        return (STATUS_ACCESS_DENIED);
    }

    //
    // So, we found a valid address -- now, open it!
    //
    if (!(pAddress = PgmAllocMem (sizeof(tADDRESS_CONTEXT), PGM_TAG('0'))))
    {
        PgmTrace (LogError, ("PgmCreateAddress: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES!\n"));

        PgmFreeMem (pUserId);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    PgmZeroMemory (pAddress, sizeof (tADDRESS_CONTEXT));
    InitializeListHead (&pAddress->Linkage);
    InitializeListHead (&pAddress->AssociatedConnections);  // List of associated connections
    InitializeListHead (&pAddress->ListenHead);             // List of Clients listening on this address
    PgmInitLock (pAddress, ADDRESS_LOCK);

    pAddress->Verify = PGM_VERIFY_ADDRESS;
    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_CREATE, TRUE); // Set Locked to TRUE since it not in use

    pAddress->Process = (PEPROCESS) PsGetCurrentProcess();
    pAddress->pUserId = pUserId;

    //
    // Now open a handle on IP
    //
    status = TdiOpenAddressHandle (pgPgmDevice,
                                   (PVOID) pAddress,
                                   0,                   // Open any Src address
                                   IPPROTO_RM,          // PGM port
                                   &pAddress->FileHandle,
                                   &pAddress->pFileObject,
                                   &pAddress->pDeviceObject);

    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("PgmCreateAddress: ERROR -- "  \
            "TdiOpenAddressHandle returned <%x>, Destroying pAddress=<%p>\n",
                status, pAddress));

        PgmFreeMem (pUserId);
        PgmFreeMem (pAddress);
        return (status);
    }

    if (IpAddress)
    {
        //
        // We are now ready to start receiving data (if we have been designated an MCast receiver)
        // Save the MCast addresses (if any were provided)
        //
        pAddress->ReceiverMCastAddr = IpAddress;    // Saved in Host format
        pAddress->ReceiverMCastPort = Port;
        pAddress->pUserId = pUserId;

        PgmLock (&PgmDynamicConfig, OldIrq);

        //
        // Verify that Non-Admin user has < MAX_STREAMS_PER_NONADMIN_RECEIVER Sessions for this IP and Port #
        //
        NumUserStreams = 0;
        pOldAddress = pOldAddressToDeref = NULL;
        if (!fUserIsAdmin)
        {
            pEntry = PgmDynamicConfig.ReceiverAddressHead.Flink;
            while (pEntry != &PgmDynamicConfig.ReceiverAddressHead)
            {
                pOldAddress = CONTAINING_RECORD (pEntry, tADDRESS_CONTEXT, Linkage);

                if ((IpAddress == pOldAddress->ReceiverMCastAddr) &&
                    (Port == pOldAddress->ReceiverMCastPort))
                {
                    PGM_REFERENCE_ADDRESS (pOldAddress, REF_ADDRESS_VERIFY_USER, FALSE);
                    PgmUnlock (&PgmDynamicConfig, OldIrq);
                    if (pOldAddressToDeref)
                    {
                        PGM_DEREFERENCE_ADDRESS (pOldAddressToDeref, REF_ADDRESS_VERIFY_USER);
                    }
                    pOldAddressToDeref = pOldAddress;

                    if (RtlEqualSid (pUserId->User.Sid, pOldAddress->pUserId->User.Sid))
                    {
                        NumUserStreams++;
                    }

                    PgmLock (&PgmDynamicConfig, OldIrq);
                }

                pEntry = pOldAddress->Linkage.Flink;
            }

            if (NumUserStreams >= MAX_STREAMS_PER_NONADMIN_RECEIVER)
            {
                PgmUnlock (&PgmDynamicConfig, OldIrq);

                if (pOldAddressToDeref)
                {
                    PGM_DEREFERENCE_ADDRESS (pOldAddressToDeref, REF_ADDRESS_VERIFY_USER);
                    pOldAddressToDeref = NULL;
                }

                PgmTrace (LogError, ("PgmCreateAddress: ERROR -- "  \
                    "Non-admin user trying to open %d+1 handle for IP:Port=<%x:%x>\n",
                        NumUserStreams, IpAddress, Port));

                PgmDestroyAddress (pAddress, NULL, NULL);

                return (STATUS_ACCESS_DENIED);
            }
        }

        InsertTailList (&PgmDynamicConfig.ReceiverAddressHead, &pAddress->Linkage);
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        if (pOldAddressToDeref)
        {
            PGM_DEREFERENCE_ADDRESS (pOldAddressToDeref, REF_ADDRESS_VERIFY_USER);
            pOldAddressToDeref = NULL;
        }
    }
    else
    {
        //
        // This is an address for sending mcast packets, so
        // Open another FileObject for sending packets with RouterAlert option
        //
        status = TdiOpenAddressHandle (pgPgmDevice,
                                       NULL,
                                       0,                   // Open any Src address
                                       IPPROTO_RM,          // PGM port
                                       &pAddress->RAlertFileHandle,
                                       &pAddress->pRAlertFileObject,
                                       &pAddress->pRAlertDeviceObject);

        if (!NT_SUCCESS (status))
        {
            PgmTrace (LogError, ("PgmCreateAddress: ERROR -- "  \
                "AO_OPTION_IPOPTIONS for Router Alert returned <%x>, Destroying pAddress=<%p>\n",
                    status, pAddress));

            PgmDestroyAddress (pAddress, NULL, NULL);

            return (status);
        }

        PgmLock (&PgmDynamicConfig, OldIrq);

        //
        // Set the default sender parameters
        // Since we don't know the MTU at this time, we
        // will assume 1.4K window size for Ethernet
        //
        pAddress->RateKbitsPerSec = SENDER_DEFAULT_RATE_KBITS_PER_SEC;
        pAddress->WindowSizeInBytes = SENDER_DEFAULT_WINDOW_SIZE_BYTES;
        pAddress->MaxWindowSizeBytes = SENDER_MAX_WINDOW_SIZE_PACKETS;
        pAddress->MaxWindowSizeBytes *= 1400;
        ASSERT (pAddress->MaxWindowSizeBytes >= SENDER_DEFAULT_WINDOW_SIZE_BYTES);
        pAddress->WindowSizeInMSecs = (BITS_PER_BYTE * pAddress->WindowSizeInBytes) /
                                      SENDER_DEFAULT_RATE_KBITS_PER_SEC;
        pAddress->WindowAdvancePercentage = SENDER_DEFAULT_WINDOW_ADV_PERCENTAGE;
        pAddress->LateJoinerPercentage = SENDER_DEFAULT_LATE_JOINER_PERCENTAGE;
        pAddress->FECGroupSize = 1;     // ==> No FEC packets!
        pAddress->MCastPacketTtl = MAX_MCAST_TTL;
        InsertTailList (&PgmDynamicConfig.SenderAddressHead, &pAddress->Linkage);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
    }

    PgmTrace (LogStatus, ("PgmCreateAddress:  "  \
        "%s -- pAddress=<%p>, IP:Port=<%x:%x>\n", (IpAddress ? "Receiver" : "Sender"),
        pAddress, IpAddress, Port));

    pIrpSp->FileObject->FsContext = pAddress;
    pIrpSp->FileObject->FsContext2 = (PVOID) TDI_TRANSPORT_ADDRESS_FILE;

    return (STATUS_SUCCESS);
}



//----------------------------------------------------------------------------

VOID
PgmDereferenceAddress(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  ULONG               RefContext
    )
/*++

Routine Description:

    This routine decrements the RefCount on the address object
    and causes a cleanup to occur if the RefCount went to 0

Arguments:

    IN  pAddress    -- Pgm's address object
    IN  RefContext  -- context for which this address object
                        was referenced earlier

Return Value:

    NONE

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    PIRP                pIrpClose;
    PIO_STACK_LOCATION  pIrpSp;

    PgmLock (pAddress, OldIrq);

    ASSERT (PGM_VERIFY_HANDLE2 (pAddress,PGM_VERIFY_ADDRESS, PGM_VERIFY_ADDRESS_DOWN));
    ASSERT (pAddress->RefCount);             // Check for too many derefs
    ASSERT (pAddress->ReferenceContexts[RefContext]--);

    if (--pAddress->RefCount)
    {
        PgmUnlock (pAddress, OldIrq);
        return;
    }

    ASSERT (IsListEmpty (&pAddress->AssociatedConnections));
    PgmUnlock (pAddress, OldIrq);

    //
    // Just Remove from the ClosedAddresses list
    //
    PgmLock (&PgmDynamicConfig, OldIrq);
    PgmLock (pAddress, OldIrq1);

    pIrpClose = pAddress->pIrpClose;
    pAddress->pIrpClose = NULL;

    RemoveEntryList (&pAddress->Linkage);

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    PgmTrace (LogStatus, ("PgmDereferenceAddress:  "  \
        "Destroying Address=<%p>\n", pAddress));

    if (PgmGetCurrentIrql())
    {
        status = PgmQueueForDelayedExecution (PgmDestroyAddress, pAddress, NULL, NULL, FALSE);
        if (!NT_SUCCESS (status))
        {
            PgmInterlockedInsertTailList (&PgmDynamicConfig.DestroyedAddresses, &pAddress->Linkage, &PgmDynamicConfig);
        }
    }
    else
    {
        PgmDestroyAddress (pAddress, NULL, NULL);
    }

    //
    // pIrpClose will be NULL if we dereferencing the address
    // as a result of an error during the Create
    //
    if (pIrpClose)
    {
        pIrpSp = IoGetCurrentIrpStackLocation (pIrpClose);
        pIrpSp->FileObject->FsContext = NULL;
        PgmIoComplete (pIrpClose, STATUS_SUCCESS, 0);
    }
}


//----------------------------------------------------------------------------

NTSTATUS
PgmCleanupAddress(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  PIRP                pIrp
    )
/*++

Routine Description:

    This routine is called as a result of a close on the client's
    address handle.  Our main job here is to mark the address
    as being cleaned up (so it that subsequent operations will
    fail) and complete the request only when the last RefCount
    has been dereferenced.

Arguments:

    IN  pAddress    -- Pgm's address object
    IN  pIrp        -- Client's request Irp

Return Value:

    NTSTATUS - Final status of the set event operation (STATUS_PENDING)

--*/
{
    NTSTATUS        status;
    PGMLockHandle   OldIrq, OldIrq1;

    PgmTrace (LogStatus, ("PgmCleanupAddress:  "  \
        "Address=<%p> FileHandle=<%p>, FileObject=<%p>\n",
            pAddress, pAddress->FileHandle, pAddress->pFileObject));

    PgmLock (&PgmDynamicConfig, OldIrq);
    PgmLock (pAddress, OldIrq1);

    ASSERT (PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS));
    pAddress->Verify = PGM_VERIFY_ADDRESS_DOWN;

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    return (STATUS_SUCCESS);
}

//----------------------------------------------------------------------------

NTSTATUS
PgmCloseAddress(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is the final dispatch operation to be performed
    after the cleanup, which should result in the address being
    completely destroyed -- our RefCount must have already
    been set to 0 when we completed the Cleanup request.

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- Current request stack location

Return Value:

    NTSTATUS - Final status of the operation (STATUS_SUCCESS)

--*/
{
    PGMLockHandle       OldIrq, OldIrq1;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;

    PgmTrace (LogAllFuncs, ("PgmCloseAddress:  "  \
        "Address=<%p>, RefCount=<%d>\n", pAddress, pAddress->RefCount));

    //
    // Remove from the global list and Put it on the Closed list!
    //
    PgmLock (&PgmDynamicConfig, OldIrq);
    PgmLock (pAddress, OldIrq1);

    RemoveEntryList (&pAddress->Linkage);
    InsertTailList (&PgmDynamicConfig.ClosedAddresses, &pAddress->Linkage);
    pAddress->pIrpClose = pIrp;

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_CREATE);

    //
    // The final Dereference will complete the Irp!
    //
    return (STATUS_PENDING);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmAssociateAddress(
    IN  tPGM_DEVICE                 *pPgmDevice,
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp
    )
/*++

Routine Description:

    This routine associates a connection with an address object

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    tADDRESS_CONTEXT                *pAddress = NULL;
    tCOMMON_SESSION_CONTEXT         *pSession = pIrpSp->FileObject->FsContext;
    PTDI_REQUEST_KERNEL_ASSOCIATE   pParameters = (PTDI_REQUEST_KERNEL_ASSOCIATE) &pIrpSp->Parameters;
    PFILE_OBJECT                    pFileObject = NULL;
    NTSTATUS                        status;
    PGMLockHandle                   OldIrq, OldIrq1, OldIrq2;
    ULONG                           i;
    UCHAR                           pRandomData[SOURCE_ID_LENGTH];

    //
    // Get a pointer to the file object, which points to the address
    // element by calling a kernel routine to convert the filehandle into
    // a file object pointer.
    //
    status = ObReferenceObjectByHandle (pParameters->AddressHandle,
                                        FILE_READ_DATA,
                                        *IoFileObjectType,
                                        pIrp->RequestorMode,
                                        (PVOID *) &pFileObject,
                                        NULL);

    if (!NT_SUCCESS(status))
    {
        PgmTrace (LogError, ("PgmAssociateAddress: ERROR -- "  \
            "Invalid Address Handle=<%p>\n", pParameters->AddressHandle));
        return (STATUS_INVALID_HANDLE);
    }

    //
    // Acquire the DynamicConfig lock so as to ensure that the Address
    // and Connection cannot get removed while we are processing it!
    //
    PgmLock (&PgmDynamicConfig, OldIrq);

    //
    // Verify the Connection handle
    //
    if ((!PGM_VERIFY_HANDLE (pSession, PGM_VERIFY_SESSION_UNASSOCIATED)) ||
        (pSession->pAssociatedAddress))       // Ensure the connection is not already associated!
    {
        PgmTrace (LogError, ("PgmAssociateAddress: ERROR -- "  \
            "Invalid Session Handle=<%p>\n", pSession));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        ObDereferenceObject ((PVOID) pFileObject);
        return (STATUS_INVALID_HANDLE);
    }

    //
    // Verify the Address handle
    //
    pAddress = pFileObject->FsContext;
    if ((pFileObject->DeviceObject->DriverObject != PgmStaticConfig.DriverObject) ||
        (PtrToUlong (pFileObject->FsContext2) != TDI_TRANSPORT_ADDRESS_FILE) ||
        (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)))
    {
        PgmTrace (LogError, ("PgmAssociateAddress: ERROR -- "  \
            "Invalid Address Context=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        ObDereferenceObject ((PVOID) pFileObject);
        return (STATUS_INVALID_HANDLE);
    }

    PgmLock (pAddress, OldIrq1);
    PgmLock (pSession, OldIrq2);

    ASSERT (!pSession->pReceiver && !pSession->pSender);

    //
    // Now try to allocate the send / receive context
    //
    status = STATUS_INSUFFICIENT_RESOURCES;
    if (pAddress->ReceiverMCastAddr)
    {
        if (pSession->pReceiver = PgmAllocMem (sizeof(tRECEIVE_CONTEXT), PGM_TAG('0')))
        {
            //
            // We are a receiver
            //
            PgmZeroMemory (pSession->pReceiver, sizeof(tRECEIVE_CONTEXT));
            InitializeListHead (&pSession->pReceiver->Linkage);
            InitializeListHead (&pSession->pReceiver->NaksForwardDataList);
            InitializeListHead (&pSession->pReceiver->ReceiveIrpsList);
            InitializeListHead (&pSession->pReceiver->BufferedDataList);
            InitializeListHead (&pSession->pReceiver->PendingNaksList);

            pSession->Verify = PGM_VERIFY_SESSION_RECEIVE;
            PGM_REFERENCE_SESSION_RECEIVE (pSession, REF_SESSION_ASSOCIATED, TRUE);

            pSession->pReceiver->ListenMCastIpAddress = pAddress->ReceiverMCastAddr;
            pSession->pReceiver->ListenMCastPort = pAddress->ReceiverMCastPort;
            pSession->pReceiver->pReceive = pSession;

            status = STATUS_SUCCESS;
        }
    }
    else if (pSession->pSender = PgmAllocMem (sizeof(tSEND_CONTEXT), PGM_TAG('0')))
    {
        //
        // We are a sender
        //
        PgmZeroMemory (pSession->pSender, sizeof(tSEND_CONTEXT));
        InitializeListHead (&pSession->pSender->Linkage);
        InitializeListHead (&pSession->pSender->PendingSends);
        InitializeListHead (&pSession->pSender->CompletedSendsInWindow);
        ExInitializeResourceLite (&pSession->pSender->Resource);

        pSession->Verify = PGM_VERIFY_SESSION_SEND;

        GetRandomData (pRandomData, SOURCE_ID_LENGTH);
        for (i=0; i<SOURCE_ID_LENGTH; i++)
        {
            pSession->TSI.GSI[i] = pRandomData[i] ^ pAddress->OutIfMacAddress.Address[i];
        }

        PGM_REFERENCE_SESSION_SEND (pSession, REF_SESSION_ASSOCIATED, TRUE);

        status = STATUS_SUCCESS;
    }

    if  (!NT_SUCCESS (status))
    {
        PgmUnlock (pSession, OldIrq2);
        PgmUnlock (pAddress, OldIrq1);
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        ObDereferenceObject ((PVOID) pFileObject);

        PgmTrace (LogError, ("PgmAssociateAddress: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES allocating context for %s, pAddress=<%p>, pSession=<%p>\n",
                (pAddress->ReceiverMCastAddr ? "pReceiver" : "pSender"), pAddress, pSession));

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Now associate the connection with the address!
    // Unlink from the ConnectionsCreated list which was linked
    // when the connection was created, and put on the AssociatedConnections list
    //
    pSession->pAssociatedAddress = pAddress;
    RemoveEntryList (&pSession->Linkage);
    InsertTailList (&pAddress->AssociatedConnections, &pSession->Linkage);

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_ASSOCIATED, TRUE);

    PgmUnlock (pSession, OldIrq2);
    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    ObDereferenceObject ((PVOID) pFileObject);

    PgmTrace (LogStatus, ("PgmAssociateAddress:  "  \
        "Associated pSession=<%p> with pAddress=<%p>\n", pSession, pAddress));

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmDisassociateAddress(
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp
    )
/*++

Routine Description:

    This routine disassociates a connection from an address object

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    PGMLockHandle                   OldIrq, OldIrq1, OldIrq2;
    ULONG                           CheckFlags;
    NTSTATUS                        status;
    tADDRESS_CONTEXT                *pAddress = NULL;
    tCOMMON_SESSION_CONTEXT         *pSession = pIrpSp->FileObject->FsContext;

    //
    // Acquire the DynamicConfig lock so as to ensure that the Address
    // and Connection Linkages cannot change while we are processing it!
    //
    PgmLock (&PgmDynamicConfig, OldIrq);

    //
    // First verify all the handles
    //
    if (!PGM_VERIFY_HANDLE3 (pSession, PGM_VERIFY_SESSION_SEND,
                                       PGM_VERIFY_SESSION_RECEIVE,
                                       PGM_VERIFY_SESSION_DOWN))
    {
        PgmTrace (LogError, ("PgmDisassociateAddress: ERROR -- "  \
            "Invalid Session Handle=<%p>, Verify=<%x>\n",
                pSession, (pSession ? pSession->Verify : 0)));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    pAddress = pSession->pAssociatedAddress;
    if (!PGM_VERIFY_HANDLE2 (pAddress, PGM_VERIFY_ADDRESS, PGM_VERIFY_ADDRESS_DOWN))
    {
        PgmTrace (LogError, ("PgmDisassociateAddress: ERROR -- "  \
            "pSession=<%p>, Invalid Address Context=<%p>\n", pSession, pSession->pAssociatedAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    PgmTrace (LogStatus, ("PgmDisassociateAddress:  "  \
        "Disassociating pSession=<%p:%p> from pAddress=<%p>\n",
            pSession, pSession->ClientSessionContext, pSession->pAssociatedAddress));

    PgmLock (pAddress, OldIrq1);
    PgmLock (pSession, OldIrq2);

    //
    // Unlink from the AssociatedConnections list, which was linked
    // when the connection was created.
    //
    pSession->pAssociatedAddress = NULL;      // Disassociated!
    RemoveEntryList (&pSession->Linkage);
    if (PGM_VERIFY_HANDLE2 (pSession, PGM_VERIFY_SESSION_SEND, PGM_VERIFY_SESSION_RECEIVE))
    {
        //
        // The connection is still active, so just put it on the CreatedConnections list
        //
        InsertTailList (&PgmDynamicConfig.ConnectionsCreated, &pSession->Linkage);
    }
    else    // PGM_VERIFY_SESSION_DOWN
    {
        //
        // The Connection was CleanedUp and may even be closed,
        // so put it on the CleanedUp list!
        //
        InsertTailList (&PgmDynamicConfig.CleanedUpConnections, &pSession->Linkage);
    }

    CheckFlags = PGM_SESSION_FLAG_IN_INDICATE | PGM_SESSION_CLIENT_DISCONNECTED;
    if (CheckFlags == (pSession->SessionFlags & CheckFlags))
    {
        pSession->pIrpDisassociate = pIrp;
        status = STATUS_PENDING;
    }
    else
    {
        pSession->SessionFlags |= PGM_SESSION_CLIENT_DISCONNECTED;
        status = STATUS_SUCCESS;
    }

    PgmUnlock (pSession, OldIrq2);
    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    if (PGM_VERIFY_HANDLE (pSession, PGM_VERIFY_SESSION_RECEIVE))
    {
        PGM_DEREFERENCE_SESSION_RECEIVE (pSession, REF_SESSION_ASSOCIATED);
    }
    else if (PGM_VERIFY_HANDLE (pSession, PGM_VERIFY_SESSION_SEND))
    {
        PGM_DEREFERENCE_SESSION_SEND (pSession, REF_SESSION_ASSOCIATED);
    }
    else    // we have already been cleaned up, so just do unassociated!
    {
        PGM_DEREFERENCE_SESSION_UNASSOCIATED (pSession, REF_SESSION_ASSOCIATED);
    }

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_ASSOCIATED);

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetMCastOutIf(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called as a result of the client attempting
    to set the outgoing interface for MCast traffic

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set outgoing interface operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    ULONG               Length;
    ULONG               BufferLength = 50;
    UCHAR               pBuffer[50];
    IPInterfaceInfo     *pIpIfInfo = (IPInterfaceInfo *) pBuffer;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;
    ULONG               *pInfoBuffer = (PULONG) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmSetMCastOutIf: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmSetMCastOutIf: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (pAddress->ReceiverMCastAddr)                                  // Cannot set OutIf on Receiver!
    {
        PgmTrace (LogError, ("PgmSetMCastOutIf: ERROR -- "  \
            "Invalid Option for Receiver, pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO, FALSE);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    status = SetSenderMCastOutIf (pAddress, pInputBuffer->MCastOutIf);

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO);

    PgmTrace (LogStatus, ("PgmSetMCastOutIf:  "  \
        "OutIf = <%x>\n", pAddress->SenderMCastOutIf));

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
ReceiverAddMCastIf(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tIPADDRESS          IpAddress,                  // In host format
    IN  PGMLockHandle       *pOldIrqDynamicConfig,
    IN  PGMLockHandle       *pOldIrqAddress
    )
/*++

Routine Description:

    This routine is called as a result of the client attempting
    to add an interface to the list of interfaces listening for
    MCast traffic

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the add interface operation

--*/
{
    NTSTATUS            status;
    tMCAST_INFO         MCastInfo;
    ULONG               IpInterfaceIndex;
    USHORT              i;

    if (!pAddress->ReceiverMCastAddr)                                // Cannot set ReceiveIf on Sender!
    {
        PgmTrace (LogError, ("ReceiverAddMCastIf: ERROR -- "  \
            "Invalid Option for Sender, pAddress=<%p>\n", pAddress));

        return (STATUS_NOT_SUPPORTED);
    }

    status = GetIpInterfaceIndexFromAddress (IpAddress, &IpInterfaceIndex);
    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("ReceiverAddMCastIf: ERROR -- "  \
            "GetIpInterfaceIndexFromAddress returned <%x> for Address=<%x>\n",
                status, IpAddress));

        return (STATUS_SUCCESS);
    }

    //
    // If we are already listening on this interface, return success
    //
    for (i=0; i <pAddress->NumReceiveInterfaces; i++)
    {
#ifdef IP_FIX
        if (pAddress->ReceiverInterfaceList[i] == IpInterfaceIndex)
#else
        if (pAddress->ReceiverInterfaceList[i] == IpAddress)
#endif  // IP_FIX
        {
            PgmTrace (LogStatus, ("ReceiverAddMCastIf:  "  \
                "InAddress=<%x> -- Already listening on IfContext=<%x>\n",
                    IpAddress, IpInterfaceIndex));

            return (STATUS_SUCCESS);
        }
    }

    //
    // If we have reached the limit on the interfaces we can listen on,
    // return error
    //
    if (pAddress->NumReceiveInterfaces >= MAX_RECEIVE_INTERFACES)
    {
        PgmTrace (LogError, ("ReceiverAddMCastIf: ERROR -- "  \
            "Listening on too many interfaces!, pAddress=<%p>\n", pAddress));

        return (STATUS_NOT_SUPPORTED);
    }

    PgmUnlock (pAddress, *pOldIrqAddress);
    PgmUnlock (&PgmDynamicConfig, *pOldIrqDynamicConfig);

    //
    // This is the interface for receiving mcast packets on, so do JoinLeaf
    // 
    MCastInfo.MCastIpAddr = htonl (pAddress->ReceiverMCastAddr);
#ifdef IP_FIX
    MCastInfo.MCastInIf = IpInterfaceIndex;
    status = PgmSetTcpInfo (pAddress->FileHandle,
                            AO_OPTION_INDEX_ADD_MCAST,
                            &MCastInfo,
                            sizeof (tMCAST_INFO));
#else
    MCastInfo.MCastInIf = ntohl (IpAddress);
    status = PgmSetTcpInfo (pAddress->FileHandle,
                            AO_OPTION_ADD_MCAST,
                            &MCastInfo,
                            sizeof (tMCAST_INFO));
#endif  // IP_FIX

    PgmLock (&PgmDynamicConfig, *pOldIrqDynamicConfig);
    PgmLock (pAddress, *pOldIrqAddress);

    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("ReceiverAddMCastIf: ERROR -- "  \
            "PgmSetTcpInfo returned: <%x>, If=<%x>\n", status, IpAddress));

        return (status);
    }

#ifdef IP_FIX
    pAddress->ReceiverInterfaceList[pAddress->NumReceiveInterfaces++] = IpInterfaceIndex;
#else
    pAddress->ReceiverInterfaceList[pAddress->NumReceiveInterfaces++] = IpAddress;
#endif  // IP_FIX

    PgmTrace (LogStatus, ("ReceiverAddMCastIf:  "  \
        "Added Ip=<%x>, IfContext=<%x>\n", IpAddress, IpInterfaceIndex));

    return (status);
}



//----------------------------------------------------------------------------

NTSTATUS
PgmSetEventHandler(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine sets the client's Event Handlers wrt its address context

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    NTSTATUS                        status = STATUS_SUCCESS;
    tADDRESS_CONTEXT                *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    PTDI_REQUEST_KERNEL_SET_EVENT   pKeSetEvent = (PTDI_REQUEST_KERNEL_SET_EVENT) &pIrpSp->Parameters;
    PVOID                           pEventHandler = pKeSetEvent->EventHandler;
    PVOID                           pEventContext = pKeSetEvent->EventContext;
    PGMLockHandle                   OldIrq, OldIrq1;

    PgmLock (&PgmDynamicConfig, OldIrq);
    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmSetEventHandler: ERROR -- "  \
            "Invalid Address Handle=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    PgmTrace (LogAllFuncs, ("PgmSetEventHandler:  "  \
        "Type=<%x>, Handler=<%p>, Context=<%p>\n", pKeSetEvent->EventType, pEventHandler, pEventContext));

    if (!pEventHandler)
    {
        //
        // We will set it to use the default Tdi Handler!
        //
        pEventContext = NULL;
    }

    PgmLock (pAddress, OldIrq1);
    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO, TRUE);

    switch (pKeSetEvent->EventType)
    {
        case TDI_EVENT_CONNECT:
        {
            if (!pAddress->ReceiverMCastAddr)
            {
                PgmUnlock (pAddress, OldIrq1);
                PgmUnlock (&PgmDynamicConfig, OldIrq);

                PgmTrace (LogError, ("PgmSetEventHandler: ERROR -- "  \
                    "TDI_EVENT_CONNECT:  pAddress=<%p> is not a Receiver\n", pAddress));

                return (STATUS_UNSUCCESSFUL);
            }

            pAddress->evConnect = (pEventHandler ? pEventHandler : TdiDefaultConnectHandler);
            pAddress->ConEvContext = pEventContext;

            //
            // If no default interface was specified, we need to set one now
            //
            if (!pAddress->NumReceiveInterfaces)
            {
                if (!IsListEmpty (&PgmDynamicConfig.LocalInterfacesList))
                {
                    status = ListenOnAllInterfaces (pAddress, &OldIrq, &OldIrq1);

                    if (NT_SUCCESS (status))
                    {
                        PgmTrace (LogAllFuncs, ("PgmSetEventHandler:  "  \
                            "CONNECT:  ListenOnAllInterfaces for pAddress=<%p> succeeded\n", pAddress));
                    }
                    else
                    {
                        PgmTrace (LogError, ("PgmSetEventHandler: ERROR -- "  \
                            "CONNECT:  ListenOnAllInterfaces for pAddress=<%p> returned <%x>\n",
                                pAddress, status));
                    }
                }

                pAddress->Flags |= (PGM_ADDRESS_WAITING_FOR_NEW_INTERFACE |
                                    PGM_ADDRESS_LISTEN_ON_ALL_INTERFACES);
            }

            break;
        }

        case TDI_EVENT_DISCONNECT:
        {
            pAddress->evDisconnect = (pEventHandler ? pEventHandler : TdiDefaultDisconnectHandler);
            pAddress->DiscEvContext = pEventContext;
            break;
        }

        case TDI_EVENT_ERROR:
        {
            pAddress->evError = (pEventHandler ? pEventHandler : TdiDefaultErrorHandler);
            pAddress->ErrorEvContext = pEventContext;
            break;
        }

        case TDI_EVENT_RECEIVE:
        {
            pAddress->evReceive = (pEventHandler ? pEventHandler : TdiDefaultReceiveHandler);
            pAddress->RcvEvContext = pEventContext;
            break;
        }

        case TDI_EVENT_RECEIVE_DATAGRAM:
        {
            pAddress->evRcvDgram = (pEventHandler ? pEventHandler : TdiDefaultRcvDatagramHandler);
            pAddress->RcvDgramEvContext = pEventContext;
            break;
        }

        case TDI_EVENT_RECEIVE_EXPEDITED:
        {
            pAddress->evRcvExpedited = (pEventHandler ? pEventHandler : TdiDefaultRcvExpeditedHandler);
            pAddress->RcvExpedEvContext = pEventContext;
            break;
        }

        case TDI_EVENT_SEND_POSSIBLE:
        {
            pAddress->evSendPossible = (pEventHandler ? pEventHandler : TdiDefaultSendPossibleHandler);
            pAddress->SendPossEvContext = pEventContext;
            break;
        }

        case TDI_EVENT_CHAINED_RECEIVE:
        case TDI_EVENT_CHAINED_RECEIVE_DATAGRAM:
        case TDI_EVENT_CHAINED_RECEIVE_EXPEDITED:
        case TDI_EVENT_ERROR_EX:
        {
            status = STATUS_NOT_SUPPORTED;
            break;
        }

        default:
        {
            PgmTrace (LogError, ("PgmSetEventHandler: ERROR -- "  \
                "Invalid Event Type = <%x>\n", pKeSetEvent->EventType));
            status = STATUS_UNSUCCESSFUL;
            break;
        }
    }

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO);

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmAddMCastReceiveIf(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called as a result of the client attempting
    to add an interface to the list of interfaces listening for
    MCast traffic

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the add interface operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmAddMCastReceiveIf: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmAddMCastReceiveIf: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    PgmLock (pAddress, OldIrq1);

    if (!pInputBuffer->MCastInfo.MCastInIf)
    {
        //
        // We will use default behavior
        //
        pAddress->Flags |= PGM_ADDRESS_LISTEN_ON_ALL_INTERFACES;

        PgmUnlock (pAddress, OldIrq1);
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        PgmTrace (LogPath, ("PgmAddMCastReceiveIf:  "  \
            "Application requested bind to IP=<%x>\n", pInputBuffer->MCastInfo.MCastInIf));

        return (STATUS_SUCCESS);
    }

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO, TRUE);

    status = ReceiverAddMCastIf (pAddress, ntohl (pInputBuffer->MCastInfo.MCastInIf), &OldIrq, &OldIrq1);

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO);

    if (NT_SUCCESS (status))
    {
        PgmTrace (LogPath, ("PgmAddMCastReceiveIf:  "  \
            "Added Address=<%x>\n", pInputBuffer->MCastInfo.MCastInIf));
    }
    else
    {
        PgmTrace (LogError, ("PgmAddMCastReceiveIf: ERROR -- "  \
            "ReceiverAddMCastIf returned <%x>, Address=<%x>\n", status, pInputBuffer->MCastInfo.MCastInIf));
    }

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmDelMCastReceiveIf(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client to remove an interface from the list
    of interfaces we are currently listening on

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the delete interface operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;
    tMCAST_INFO         MCastInfo;
    ULONG               IpInterfaceIndex;
    USHORT              i;
    BOOLEAN             fFound;
#ifndef IP_FIX
    tIPADDRESS          IpAddress;
#endif  // !IP_FIX

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmDelMCastReceiveIf: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmDelMCastReceiveIf: ERROR -- "  \
            "Invalid Handles pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (!pAddress->ReceiverMCastAddr)                                 // Cannot set ReceiveIf on Sender!
    {
        PgmTrace (LogError, ("PgmDelMCastReceiveIf: ERROR -- "  \
            "Invalid Option for Sender, pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    status = GetIpInterfaceIndexFromAddress (ntohl(pInputBuffer->MCastInfo.MCastInIf), &IpInterfaceIndex);
    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("PgmDelMCastReceiveIf: ERROR -- "  \
            "GetIpInterfaceIndexFromAddress returned <%x> for Address=<%x>\n",
                status, pInputBuffer->MCastInfo.MCastInIf));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_ADDRESS);
    }

    PgmLock (pAddress, OldIrq1);

    //
    // Now see if we are even listening on this interface
    //
    fFound = FALSE;
#ifndef IP_FIX
    IpAddress = ntohl(pInputBuffer->MCastInfo.MCastInIf);
#endif  // !IP_FIX
    for (i=0; i <pAddress->NumReceiveInterfaces; i++)
    {
#ifdef IP_FIX
        if (pAddress->ReceiverInterfaceList[i] == IpInterfaceIndex)
#else
        if (pAddress->ReceiverInterfaceList[i] == IpAddress)
#endif  // IP_FIX
        {
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        PgmTrace (LogStatus, ("PgmDelMCastReceiveIf:  "  \
            "Receiver is no longer listening on InAddress=<%x>, IfContext=<%x>\n",
                pInputBuffer->MCastInfo.MCastInIf, IpInterfaceIndex));

        PgmUnlock (pAddress, OldIrq1);
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_SUCCESS);
    }

    pAddress->NumReceiveInterfaces--;
    while (i < pAddress->NumReceiveInterfaces)
    {
        pAddress->ReceiverInterfaceList[i] = pAddress->ReceiverInterfaceList[i+1];
        i++;
    }

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO, TRUE);

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    MCastInfo.MCastIpAddr = htonl (pAddress->ReceiverMCastAddr);
#ifdef IP_FIX
    MCastInfo.MCastInIf = IpInterfaceIndex;
    status = PgmSetTcpInfo (pAddress->FileHandle,
                            AO_OPTION_INDEX_DEL_MCAST,
                            &MCastInfo,
                            sizeof (tMCAST_INFO));
#else
    MCastInfo.MCastInIf = pInputBuffer->MCastInfo.MCastInIf;
    status = PgmSetTcpInfo (pAddress->FileHandle,
                            AO_OPTION_DEL_MCAST,
                            &MCastInfo,
                            sizeof (tMCAST_INFO));
#endif  // IP_FIX

    if (NT_SUCCESS (status))
    {
        PgmTrace (LogStatus, ("PgmDelMCastReceiveIf:  "  \
            "MCast Addr:Port=<%x:%x>, OutIf=<%x>\n",
                pAddress->ReceiverMCastAddr, pAddress->ReceiverMCastPort,
                pInputBuffer->MCastInfo.MCastInIf));
    }
    else
    {
        PgmTrace (LogError, ("PgmDelMCastReceiveIf: ERROR -- "  \
            "PgmSetTcpInfo returned: <%x> for IP=<%x>, IfContext=<%x>\n",
                status, pInputBuffer->MCastInfo.MCastInIf, IpInterfaceIndex));
        return (status);
    }

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO);

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetWindowSizeAndSendRate(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to override the default
    Send Rate and Window size specifications

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;
    ULONGLONG          RateKbitsPerSec;       // Send rate
    ULONGLONG          WindowSizeInBytes;
    ULONGLONG          WindowSizeInMSecs;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmSetWindowSizeAndSendRate: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmSetWindowSizeAndSendRate: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if ((pAddress->ReceiverMCastAddr) ||                            // Cannot set OutIf on Receiver!
        (!IsListEmpty (&pAddress->AssociatedConnections)))          // Cannot set options on active sender
    {
        PgmTrace (LogError, ("PgmSetWindowSizeAndSendRate: ERROR -- "  \
            "Invalid Option, pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    RateKbitsPerSec = pInputBuffer->TransmitWindowInfo.RateKbitsPerSec;
    WindowSizeInBytes = pInputBuffer->TransmitWindowInfo.WindowSizeInBytes;
    WindowSizeInMSecs = pInputBuffer->TransmitWindowInfo.WindowSizeInMSecs;

    //
    // Now, fill in missing info
    //
    if ((RateKbitsPerSec || WindowSizeInMSecs || WindowSizeInBytes) &&     // no paramter specified -- error
        (!(RateKbitsPerSec && WindowSizeInMSecs && WindowSizeInBytes)))    // all parameters specified
    {
        //
        // If 2 parameters have been specified, we only need to compute the third one
        //
        if (RateKbitsPerSec && WindowSizeInMSecs)
        {
            ASSERT (WindowSizeInMSecs >= MIN_RECOMMENDED_WINDOW_MSECS);
            WindowSizeInBytes = (WindowSizeInMSecs * RateKbitsPerSec) / BITS_PER_BYTE;
        }
        else if (RateKbitsPerSec && WindowSizeInBytes)
        {
            WindowSizeInMSecs = (BITS_PER_BYTE * WindowSizeInBytes) / RateKbitsPerSec;
        }
        else if (WindowSizeInBytes && WindowSizeInMSecs)
        {
            RateKbitsPerSec = (WindowSizeInBytes * BITS_PER_BYTE) / WindowSizeInMSecs;
            ASSERT (WindowSizeInMSecs >= MIN_RECOMMENDED_WINDOW_MSECS);
        }
        // for the remainder of the scenarios only 1 parameter has been specified
        // Since WindowSizeInMSecs does not really affect our boundaries,
        // it is the easiest to ignore while picking the defaults
        else if (RateKbitsPerSec)
        {
            if (RateKbitsPerSec <= 500)   // If the requested rate <= 0.5MB/sec, use a larger window
            {
                WindowSizeInMSecs = MAX_RECOMMENDED_WINDOW_MSECS;
            }
            else if (RateKbitsPerSec > 10000)   // If the requested rate is very high, use the Min window
            {
                WindowSizeInMSecs = MIN_RECOMMENDED_WINDOW_MSECS;
            }
            else
            {
                WindowSizeInMSecs = MID_RECOMMENDED_WINDOW_MSECS;
            }
            WindowSizeInBytes = (WindowSizeInMSecs * RateKbitsPerSec) / BITS_PER_BYTE;
        }
        else if ((WindowSizeInBytes) &&
                 (WindowSizeInBytes >= pAddress->OutIfMTU))             // Necessary so that Win Adv rate!=0
        {
            RateKbitsPerSec = SENDER_DEFAULT_RATE_KBITS_PER_SEC;
            WindowSizeInMSecs = (BITS_PER_BYTE * WindowSizeInBytes) / RateKbitsPerSec;
            ASSERT (WindowSizeInMSecs >= MIN_RECOMMENDED_WINDOW_MSECS);
        }
        else if ((WindowSizeInMSecs < pAddress->MaxWindowSizeBytes) &&  // Necessary so that Rate >= 1
                 (WindowSizeInMSecs >= MIN_RECOMMENDED_WINDOW_MSECS) &&
                 (WindowSizeInMSecs >= pAddress->OutIfMTU))             // Necessary so that Win Adv rate!=0
        {
            // This is trickier -- we will first try to determine our constraints
            // and try to use default settings, otherwise attempt to use the median value.
            if (WindowSizeInMSecs <= (BITS_PER_BYTE * (pAddress->MaxWindowSizeBytes /
                                                       SENDER_DEFAULT_RATE_KBITS_PER_SEC)))
            {
                RateKbitsPerSec = SENDER_DEFAULT_RATE_KBITS_PER_SEC;
                WindowSizeInBytes = (WindowSizeInMSecs * RateKbitsPerSec) / BITS_PER_BYTE;
            }
            // Hmm, we have to drop below out preferred rate -- try to pick the median range
            else if (RateKbitsPerSec = BITS_PER_BYTE * (pAddress->MaxWindowSizeBytes /
                                                        (WindowSizeInMSecs * 2)))
            {   
                WindowSizeInBytes = (WindowSizeInMSecs * RateKbitsPerSec) / BITS_PER_BYTE;
            }
            else
            {
                //
                // Darn, we have to go with a huge file size and the min. rate!
                //
                RateKbitsPerSec = 1;
                WindowSizeInBytes = WindowSizeInMSecs;
            }
        }
    }

    //
    // Check validity of requested settings
    //
    if ((!(RateKbitsPerSec && WindowSizeInMSecs && WindowSizeInBytes)) ||  // all 3 must be specified from above
        (RateKbitsPerSec != (WindowSizeInBytes * BITS_PER_BYTE / WindowSizeInMSecs)) ||
        (WindowSizeInBytes > pAddress->MaxWindowSizeBytes) ||
        (WindowSizeInBytes < pAddress->OutIfMTU))
    {
        PgmTrace (LogError, ("PgmSetWindowSizeAndSendRate: ERROR -- "  \
            "Invalid settings for pAddress=<%p>, Rate=<%d>, WSizeBytes=<%d>, WSizeMS=<%d>, MaxWSize=<%I64d>\n",
                pAddress,
                pInputBuffer->TransmitWindowInfo.RateKbitsPerSec,
                pInputBuffer->TransmitWindowInfo.WindowSizeInBytes,
                pInputBuffer->TransmitWindowInfo.WindowSizeInMSecs,
                pAddress->MaxWindowSizeBytes));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_PARAMETER);
    }

    pAddress->RateKbitsPerSec = (ULONG) RateKbitsPerSec;
    pAddress->WindowSizeInBytes = (ULONG) WindowSizeInBytes;
    pAddress->WindowSizeInMSecs = (ULONG) WindowSizeInMSecs;

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    PgmTrace (LogStatus, ("PgmSetWindowSizeAndSendRate:  "  \
        "Settings for pAddress=<%p>: Rate=<%I64d>, WSizeBytes=<%I64d>, WSizeMS=<%I64d>\n",
            pAddress, RateKbitsPerSec, WindowSizeInBytes, WindowSizeInMSecs));

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueryWindowSizeAndSendRate(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Send Rate and Window size specifications

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmQueryWindowSizeAndSendRate: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmQueryWindowSizeAndSendRate: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (pAddress->ReceiverMCastAddr)                              // Invalid option for Receiver!
    {
        PgmTrace (LogError, ("PgmQueryWindowSizeAndSendRate: ERROR -- "  \
            "Invalid option ofr receiver pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    PgmZeroMemory (pBuffer, sizeof (tPGM_MCAST_REQUEST));
    pBuffer->TransmitWindowInfo.RateKbitsPerSec = (ULONG) pAddress->RateKbitsPerSec;
    pBuffer->TransmitWindowInfo.WindowSizeInBytes = (ULONG) pAddress->WindowSizeInBytes;
    pBuffer->TransmitWindowInfo.WindowSizeInMSecs = (ULONG) pAddress->WindowSizeInMSecs;

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetWindowAdvanceRate(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to override the default
    Window Advance rate

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmSetWindowAdvanceRate: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    status = STATUS_SUCCESS;
    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmSetWindowAdvanceRate: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        status = STATUS_INVALID_HANDLE;
    }
    else if ((pAddress->ReceiverMCastAddr) ||                       // Cannot set OutIf on Receiver!
             (!IsListEmpty (&pAddress->AssociatedConnections)))     // Cannot set options on active sender
    {
        PgmTrace (LogError, ("PgmSetWindowAdvanceRate: ERROR -- "  \
            "Invalid pAddress type or state <%p>\n", pAddress));

        status = STATUS_NOT_SUPPORTED;
    }

    if (!NT_SUCCESS (status))
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (status);
    }

    if ((pInputBuffer->WindowAdvancePercentage) &&
        (pInputBuffer->WindowAdvancePercentage <= MAX_WINDOW_INCREMENT_PERCENTAGE))
    {
        pAddress->WindowAdvancePercentage = pInputBuffer->WindowAdvancePercentage;
        status = STATUS_SUCCESS;
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    PgmUnlock (&PgmDynamicConfig, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueryWindowAdvanceRate(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Send Window advance rate

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmQueryWindowAdvanceRate: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmQueryWindowAdvanceRate: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (pAddress->ReceiverMCastAddr)                              // Invalid option for Receiver!
    {
        PgmTrace (LogError, ("PgmQueryWindowAdvanceRate: ERROR -- "  \
            "Invalid option for receiver, pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    PgmZeroMemory (pBuffer, sizeof (tPGM_MCAST_REQUEST));
    pBuffer->WindowAdvancePercentage = pAddress->WindowAdvancePercentage;
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetLateJoinerPercentage(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to override the default
    Late Joiner percentage (i.e. % of Window late joiner can request)

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmSetLateJoinerPercentage: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    status = STATUS_SUCCESS;
    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmSetLateJoinerPercentage: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        status = STATUS_INVALID_HANDLE;
    }
    else if ((pAddress->ReceiverMCastAddr) ||                       // Cannot set LateJoin % on Receiver!
             (!IsListEmpty (&pAddress->AssociatedConnections)))     // Cannot set options on active sender
    {
        PgmTrace (LogError, ("PgmSetLateJoinerPercentage: ERROR -- "  \
            "Invalid pAddress type or state <%p>\n", pAddress));

        status = STATUS_NOT_SUPPORTED;
    }

    if (!NT_SUCCESS (status))
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (status);
    }

    if (pInputBuffer->LateJoinerPercentage <= SENDER_MAX_LATE_JOINER_PERCENTAGE)
    {
        pAddress->LateJoinerPercentage = pInputBuffer->LateJoinerPercentage;
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    PgmUnlock (&PgmDynamicConfig, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueryLateJoinerPercentage(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Late Joiner percentage

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmQueryLateJoinerPercentage: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmQueryLateJoinerPercentage: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (pAddress->ReceiverMCastAddr)                              // Cannot query LateJoin % on Receiver!
    {
        PgmTrace (LogError, ("PgmQueryLateJoinerPercentage: ERROR -- "  \
            "Invalid option for receiver, pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    pBuffer->LateJoinerPercentage = pAddress->LateJoinerPercentage;

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetWindowAdvanceMethod(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to override the default
    Late Joiner percentage (i.e. % of Window late joiner can request)

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmSetWindowAdvanceMethod: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    status = STATUS_SUCCESS;
    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmSetWindowAdvanceMethod: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        status = STATUS_INVALID_HANDLE;
    }
    else if (pAddress->ReceiverMCastAddr)                           // Cannot set WindowAdvanceMethod on Receiver!
    {
        PgmTrace (LogError, ("PgmSetWindowAdvanceMethod: ERROR -- "  \
            "Invalid pAddress type or state <%p>\n", pAddress));

        status = STATUS_NOT_SUPPORTED;
    }

    if (!NT_SUCCESS (status))
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (status);
    }

    if (pInputBuffer->WindowAdvanceMethod == E_WINDOW_ADVANCE_BY_TIME)
    {
        pAddress->Flags &= ~PGM_ADDRESS_USE_WINDOW_AS_DATA_CACHE;
    }
    else if (pInputBuffer->WindowAdvanceMethod == E_WINDOW_USE_AS_DATA_CACHE)
    {
//        pAddress->Flags |= PGM_ADDRESS_USE_WINDOW_AS_DATA_CACHE;
        status = STATUS_NOT_SUPPORTED;      // Not supported for now!
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    PgmUnlock (&PgmDynamicConfig, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueryWindowAdvanceMethod(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Window Advance Method

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmQueryWindowAdvanceMethod: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmQueryWindowAdvanceMethod: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    if (pAddress->ReceiverMCastAddr)                              // Cannot query WindowAdvanceMethod on Receiver!
    {
        PgmTrace (LogError, ("PgmQueryWindowAdvanceMethod: ERROR -- "  \
            "Invalid option for receiver, pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    PgmZeroMemory (pBuffer, sizeof (tPGM_MCAST_REQUEST));
    if (pAddress->Flags & PGM_ADDRESS_USE_WINDOW_AS_DATA_CACHE)
    {
        pBuffer->WindowAdvanceMethod = E_WINDOW_USE_AS_DATA_CACHE;
    }
    else
    {
        pBuffer->WindowAdvanceMethod = E_WINDOW_ADVANCE_BY_TIME;
    }

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetNextMessageBoundary(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to set the Message length
    for the next set of messages (typically, 1 send is sent as 1 Message).

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tSEND_SESSION       *pSend = (tSEND_SESSION *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmSetNextMessageBoundary: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if ((!PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_SEND)) ||
        (!pSend->pAssociatedAddress))
    {
        PgmTrace (LogError, ("PgmSetNextMessageBoundary: ERROR -- "  \
            "Invalid Handle pSend=<%p>\n", pSend));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (!pSend->pSender)
    {
        PgmTrace (LogError, ("PgmSetNextMessageBoundary: ERROR -- "  \
            "Invalid Option for Receiver, pSend=<%p>\n", pSend));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    PgmLock (pSend, OldIrq1);

    if ((pInputBuffer->NextMessageBoundary) &&
        (!pSend->pSender->ThisSendMessageLength))
    {
        pSend->pSender->ThisSendMessageLength = pInputBuffer->NextMessageBoundary;
        status = STATUS_SUCCESS;
    }
    else
    {
        PgmTrace (LogError, ("PgmSetNextMessageBoundary: ERROR -- "  \
            "Invalid parameter = <%d>\n", pInputBuffer->NextMessageBoundary));

        status = STATUS_INVALID_PARAMETER;
    }

    PgmUnlock (pSend, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetFECInfo(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to set the parameters
    for using FEC

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmSetFECInfo: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    status = STATUS_SUCCESS;
    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmSetFECInfo: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        status = STATUS_INVALID_HANDLE;
    }
    else if ((pAddress->ReceiverMCastAddr) ||                       // Cannot set FEC on Receiver!
             (!IsListEmpty (&pAddress->AssociatedConnections)))     // Cannot set options on active sender
    {
        PgmTrace (LogError, ("PgmSetFECInfo: ERROR -- "  \
            "Invalid pAddress type or state <%p>\n", pAddress));

        status = STATUS_NOT_SUPPORTED;
    }

    if (!NT_SUCCESS (status))
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (status);
    }

    PgmLock (pAddress, OldIrq1);

    if (!(pInputBuffer->FECInfo.FECProActivePackets || pInputBuffer->FECInfo.fFECOnDemandParityEnabled) ||
        !(pInputBuffer->FECInfo.FECBlockSize && pInputBuffer->FECInfo.FECGroupSize) ||
         (pInputBuffer->FECInfo.FECBlockSize > FEC_MAX_BLOCK_SIZE) ||
         (pInputBuffer->FECInfo.FECBlockSize <= pInputBuffer->FECInfo.FECGroupSize) ||
         (!gFECLog2[pInputBuffer->FECInfo.FECGroupSize]))       // FECGroup size has to be power of 2
    {
        PgmTrace (LogError, ("PgmSetFECInfo: ERROR -- "  \
            "Invalid parameters, FECBlockSize= <%d>, FECGroupSize=<%d>\n",
                pInputBuffer->FECInfo.FECBlockSize, pInputBuffer->FECInfo.FECGroupSize));

        status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        status = STATUS_SUCCESS;

        pAddress->FECBlockSize = pInputBuffer->FECInfo.FECBlockSize;
        pAddress->FECGroupSize = pInputBuffer->FECInfo.FECGroupSize;
        pAddress->FECOptions = 0;   // Init

        if (pInputBuffer->FECInfo.FECProActivePackets)
        {
            pAddress->FECProActivePackets = pInputBuffer->FECInfo.FECProActivePackets;
            pAddress->FECOptions |= PACKET_OPTION_SPECIFIC_FEC_PRO_BIT;
        }
        if (pInputBuffer->FECInfo.fFECOnDemandParityEnabled)
        {
            pAddress->FECOptions |= PACKET_OPTION_SPECIFIC_FEC_OND_BIT;
        }
    }

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueryFecInfo(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Send Window advance rate

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmQueryFecInfo: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmQueryFecInfo: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if ((pAddress->ReceiverMCastAddr) ||                            // Cannot query Fec on Receiver!
        (!IsListEmpty (&pAddress->AssociatedConnections)))          // Cannot query options on active sender
    {
        PgmTrace (LogError, ("PgmQueryFecInfo: ERROR -- "  \
            "Invalid Option for receiver, pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    PgmZeroMemory (pBuffer, sizeof (tPGM_MCAST_REQUEST));
    pBuffer->FECInfo.FECBlockSize = pAddress->FECBlockSize;
    pBuffer->FECInfo.FECGroupSize = pAddress->FECGroupSize;
    pBuffer->FECInfo.FECProActivePackets = pAddress->FECProActivePackets;
    if (pAddress->FECOptions & PACKET_OPTION_SPECIFIC_FEC_OND_BIT)
    {
        pBuffer->FECInfo.fFECOnDemandParityEnabled = TRUE;
    }
    else
    {
        pBuffer->FECInfo.fFECOnDemandParityEnabled = FALSE;
    }

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetMCastTtl(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to set the Message length
    for the next set of messages (typically, 1 send is sent as 1 Message).

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmSetMCastTtl: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmSetMCastTtl: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }
    if (pAddress->ReceiverMCastAddr)                              // Cannot set MCast Ttl on Receiver!
    {
        PgmTrace (LogError, ("PgmSetMCastTtl: ERROR -- "  \
            "Invalid Options for Receiver, pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_NOT_SUPPORTED);
    }

    PgmLock (pAddress, OldIrq1);

    if ((pInputBuffer->MCastTtl) &&
        (pInputBuffer->MCastTtl <= MAX_MCAST_TTL))
    {
        pAddress->MCastPacketTtl = pInputBuffer->MCastTtl;
        status = STATUS_SUCCESS;
    }
    else
    {
        PgmTrace (LogError, ("PgmSetMCastTtl: ERROR -- "  \
            "Invalid parameter = <%d>\n", pInputBuffer->MCastTtl));

        status = STATUS_INVALID_PARAMETER;
    }

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueryHighSpeedOptimization(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the
    Address is optimized for High Speed Intranet scenario

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmQueryHighSpeedOptimization: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmQueryHighSpeedOptimization: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    PgmZeroMemory (pBuffer, sizeof (tPGM_MCAST_REQUEST));
    if (pAddress->Flags & PGM_ADDRESS_HIGH_SPEED_OPTIMIZED)
    {
        pBuffer->HighSpeedIntranetOptimization = 1;
    }
    else
    {
        pBuffer->HighSpeedIntranetOptimization = 0;
    }

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetHighSpeedOptimization(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to optimize
    this address for High Speed Intranet scenario.

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tADDRESS_CONTEXT    *pAddress = (tADDRESS_CONTEXT *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmSetHighSpeedOptimization: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogError, ("PgmSetHighSpeedOptimization: ERROR -- "  \
            "Invalid Handle pAddress=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    PgmLock (pAddress, OldIrq1);

    PgmTrace (LogStatus, ("PgmSetHighSpeedOptimization:  "  \
        "HighSpeedIntranetOptimization = %sSet ==> %sSet\n",
            ((pAddress->Flags & PGM_ADDRESS_HIGH_SPEED_OPTIMIZED) ? "" : "Not "),
            (pInputBuffer->HighSpeedIntranetOptimization ? "" : "Not ")));

    if (pInputBuffer->HighSpeedIntranetOptimization)
    {
        pAddress->Flags |= PGM_ADDRESS_HIGH_SPEED_OPTIMIZED;
    }
    else
    {
        pAddress->Flags &= ~PGM_ADDRESS_HIGH_SPEED_OPTIMIZED;
    }

    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQuerySenderStats(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Sender-side statistics

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tSEND_SESSION       *pSend = (tSEND_SESSION *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmQuerySenderStats: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if ((!PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_SEND)) ||
        (!pSend->pSender) ||
        (!pSend->pAssociatedAddress))
    {
        PgmTrace (LogError, ("PgmQuerySenderStats: ERROR -- "  \
            "Invalid Handle pSend=<%p>\n", pSend));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    PgmLock (pSend, OldIrq1);

    PgmZeroMemory (pBuffer, sizeof (tPGM_MCAST_REQUEST));
    pBuffer->SenderStats.DataBytesSent = pSend->DataBytes;
    pBuffer->SenderStats.TotalBytesSent = pSend->TotalBytes;
    pBuffer->SenderStats.RateKBitsPerSecLast = pSend->RateKBitsPerSecLast;
    pBuffer->SenderStats.RateKBitsPerSecOverall = pSend->RateKBitsPerSecOverall;
    pBuffer->SenderStats.NaksReceived = pSend->pSender->NaksReceived;
    pBuffer->SenderStats.NaksReceivedTooLate = pSend->pSender->NaksReceivedTooLate;
    pBuffer->SenderStats.NumOutstandingNaks = pSend->pSender->NumOutstandingNaks;
    pBuffer->SenderStats.NumNaksAfterRData = pSend->pSender->NumNaksAfterRData;
    pBuffer->SenderStats.RepairPacketsSent = pSend->pSender->TotalRDataPacketsSent;
    pBuffer->SenderStats.TotalODataPacketsSent = pSend->pSender->TotalODataPacketsSent;
    pBuffer->SenderStats.BufferSpaceAvailable = pSend->pSender->BufferSizeAvailable;
    pBuffer->SenderStats.TrailingEdgeSeqId = (SEQ_TYPE) pSend->pSender->TrailingEdgeSequenceNumber;
    pBuffer->SenderStats.LeadingEdgeSeqId = (SEQ_TYPE) pSend->pSender->LastODataSentSequenceNumber;

    PgmUnlock (pSend, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueryReceiverStats(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client via setopt to query the current
    Sender-side statistics

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the query operation

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq, OldIrq1;
    tRECEIVE_SESSION    *pReceive = (tRECEIVE_SESSION *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmQueryReceiverStats: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    if ((!PGM_VERIFY_HANDLE (pReceive, PGM_VERIFY_SESSION_RECEIVE)) ||
        (!pReceive->pReceiver) ||
        (!pReceive->pAssociatedAddress))
    {
        PgmTrace (LogError, ("PgmQueryReceiverStats: ERROR -- "  \
            "Invalid Handle pReceive=<%p>\n", pReceive));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_INVALID_HANDLE);
    }

    PgmLock (pReceive, OldIrq1);

    PgmZeroMemory (pBuffer, sizeof (tPGM_MCAST_REQUEST));
    pBuffer->ReceiverStats.NumODataPacketsReceived = pReceive->pReceiver->NumODataPacketsReceived;
    pBuffer->ReceiverStats.NumRDataPacketsReceived = pReceive->pReceiver->NumRDataPacketsReceived;
    pBuffer->ReceiverStats.NumDuplicateDataPackets = pReceive->pReceiver->NumDupPacketsOlderThanWindow +
                                                     pReceive->pReceiver->NumDupPacketsBuffered;

    pBuffer->ReceiverStats.DataBytesReceived = pReceive->DataBytes;
    pBuffer->ReceiverStats.TotalBytesReceived = pReceive->TotalBytes;
    pBuffer->ReceiverStats.RateKBitsPerSecLast = pReceive->RateKBitsPerSecLast;
    pBuffer->ReceiverStats.RateKBitsPerSecOverall = pReceive->RateKBitsPerSecOverall;

    pBuffer->ReceiverStats.TrailingEdgeSeqId = (SEQ_TYPE) pReceive->pReceiver->LastTrailingEdgeSeqNum;
    pBuffer->ReceiverStats.LeadingEdgeSeqId = (SEQ_TYPE) pReceive->pReceiver->FurthestKnownGroupSequenceNumber;
    pBuffer->ReceiverStats.AverageSequencesInWindow = pReceive->pReceiver->AverageSequencesInWindow;
    pBuffer->ReceiverStats.MinSequencesInWindow = pReceive->pReceiver->MinSequencesInWindow;
    pBuffer->ReceiverStats.MaxSequencesInWindow = pReceive->pReceiver->MaxSequencesInWindow;

    pBuffer->ReceiverStats.FirstNakSequenceNumber = pReceive->pReceiver->FirstNakSequenceNumber;
    pBuffer->ReceiverStats.NumPendingNaks = pReceive->pReceiver->NumPendingNaks;
    pBuffer->ReceiverStats.NumOutstandingNaks = pReceive->pReceiver->NumOutstandingNaks;
    pBuffer->ReceiverStats.NumDataPacketsBuffered = pReceive->pReceiver->TotalDataPacketsBuffered;
    pBuffer->ReceiverStats.TotalSelectiveNaksSent = pReceive->pReceiver->TotalSelectiveNaksSent;
    pBuffer->ReceiverStats.TotalParityNaksSent = pReceive->pReceiver->TotalParityNaksSent;

    PgmUnlock (pReceive, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    pIrp->IoStatus.Information =  sizeof (tPGM_MCAST_REQUEST);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\data.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Data.c

Abstract:

    This module implements routines commonly by the
    send and receive modules

Author:

    Mohammad Shabbir Alam (MAlam)   8-24-2001

Revision History:

--*/


#include "precomp.h"

#ifdef FILE_LOGGING
#include "data.tmh"
#endif  // FILE_LOGGING

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#endif
//*******************  Pageable Routine Declarations ****************



//----------------------------------------------------------------------------
#define     MAX_REPAIR_INDICES         32768        // Must be a power of 2!

NTSTATUS
InitRDataInfo(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tSEND_SESSION       *pSend
    )
{
    tRDATA_INFO         *pRDataInfo;
    ULONGLONG           MaxPackets;
    ULONG               NumBits;
    LIST_ENTRY          *pListEntry;
    USHORT              i, LookasideDepth = RDATA_REQUESTS_MIN_LOOKASIDE_DEPTH;
    tSEND_CONTEXT       *pSender = pSend->pSender;

    if (pSender->pRDataInfo)
    {
        PgmTrace (LogError, ("InitRDataInfo: ERROR -- "  \
            "Previous Table already present for pSend=<%p>\n", pSend));

        ASSERT (0);
        return (STATUS_UNSUCCESSFUL);
    }

    if (!(pRDataInfo = PgmAllocMem (sizeof (tRDATA_INFO), PGM_TAG('S'))))
    {
        PgmTrace (LogError, ("InitRDataInfo: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES -- pRDataInfo\n"));

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    PgmZeroMemory (pRDataInfo, sizeof (tRDATA_INFO));
    InitializeListHead (&pRDataInfo->PendingRDataRequests);

    pRDataInfo->RepairDataMaxEntries = MAX_REPAIR_INDICES;
    pRDataInfo->RepairDataMask = pRDataInfo->RepairDataMaxEntries - 1;
    pRDataInfo->RepairDataIndexShift = gFECLog2[pSend->FECGroupSize];

    if (!(pListEntry = PgmAllocMem ((sizeof (LIST_ENTRY) * pRDataInfo->RepairDataMaxEntries), PGM_TAG('s'))))
    {
        PgmTrace (LogError, ("InitRDataInfo: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES -- pListEntry\n"));

        PgmFreeMem (pRDataInfo);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    pRDataInfo->EntrySize = sizeof(tSEND_RDATA_CONTEXT) + pSend->FECGroupSize*sizeof(PUCHAR);

    if (pAddress->Flags & PGM_ADDRESS_HIGH_SPEED_OPTIMIZED)
    {
        LookasideDepth = LookasideDepth << 1;       // Double the Lookaside depth for high speed
    }

    ExInitializeNPagedLookasideList (&pRDataInfo->RDataLookasideList,
                                     NULL,
                                     NULL,
                                     0,
                                     pRDataInfo->EntrySize,
                                     PGM_TAG('R'),
                                     LookasideDepth);

    NumBits = 0;
    MaxPackets = pSender->MaxPacketsInBuffer;
    while (MaxPackets)
    {
        NumBits++;
        MaxPackets = MaxPackets >> 1;
    }

    pRDataInfo->MaxIndices = NUM_INDICES;
    pRDataInfo->IndexMask = NUM_INDICES - 1;
    if (NumBits < NUM_INDICES_BITS)
    {
        pRDataInfo->IndexShift = 0;
//        ASSERT (0);
    }
    else
    {
        pRDataInfo->IndexShift = NumBits - NUM_INDICES_BITS;
    }

    pRDataInfo->pRepairData = pListEntry;
    for (i=0; i<pRDataInfo->RepairDataMaxEntries; i++)
    {
        InitializeListHead (&pListEntry[i]);
    }

    pSender->pRDataInfo = pRDataInfo;
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
VOID
DestroyRDataInfo(
    IN  tSEND_SESSION   *pSend
    )
{
    tSEND_CONTEXT       *pSender = pSend->pSender;
    tRDATA_INFO         *pRDataInfo = pSender->pRDataInfo;
    LIST_ENTRY          *pRepairData = pRDataInfo->pRepairData;
    ULONG               i;

    ExDeleteNPagedLookasideList (&pRDataInfo->RDataLookasideList);

    ASSERT (IsListEmpty (&pRDataInfo->PendingRDataRequests));

    for (i=0; i<pRDataInfo->RepairDataMaxEntries; i++)
    {
        ASSERT (IsListEmpty (&pRepairData[i]));
    }
    PgmFreeMem (pRDataInfo->pRepairData);
    PgmFreeMem (pRDataInfo);
    pSend->pSender->pRDataInfo = NULL;
}


//----------------------------------------------------------------------------
PSEND_RDATA_CONTEXT
AnyRequestPending(
    IN  tRDATA_INFO         *pRDataInfo
    )
{
    if (IsListEmpty (&pRDataInfo->PendingRDataRequests))
    {
        return (NULL);
    }

    return (CONTAINING_RECORD (pRDataInfo->PendingRDataRequests.Flink, tSEND_RDATA_CONTEXT, Linkage));
}


//----------------------------------------------------------------------------
VOID
ClearNakIndices(
    IN  tSEND_RDATA_CONTEXT *pRData
    )
{
    pRData->NumParityNaks = 0;
    pRData->SelectiveNaks[1] = pRData->SelectiveNaks[0] = 0;
}


//----------------------------------------------------------------------------
BOOLEAN
AddSelectiveNakToList(
    IN  USHORT              NakOffset,
    IN  tSEND_RDATA_CONTEXT *pRData
    )
{
    USHORT      NakIndex;
    UCHAR       NakBit;

    if (NakOffset >= 128)
    {
        ASSERT (0);
        return (FALSE);
    }

    NakIndex = NakOffset >> 3;
    NakBit = (UCHAR) (1 << (NakOffset & 0x07));

    if (pRData->SelectiveNaksMask[NakIndex] & NakBit)
    {
        return (FALSE);
    }

    pRData->SelectiveNaksMask[NakIndex] |= NakBit;
    return (TRUE);
}



//----------------------------------------------------------------------------
BOOLEAN
GetNextNakIndex(
    IN  tSEND_RDATA_CONTEXT *pRData,
    OUT UCHAR               *pNakIndex
    )
{
    UCHAR           i, LowestSetBit, Offset = 0;

    for (i=0; i<16; i++)
    {
        if (pRData->SelectiveNaksMask[i])
        {
            //
            // First, find the lowest bit
            //
            LowestSetBit = pRData->SelectiveNaksMask[i] & ~(pRData->SelectiveNaksMask[i] - 1);
            pRData->SelectiveNaksMask[i] &= ~LowestSetBit;       // Clear this bit
            Offset += gFECLog2[LowestSetBit];
            *pNakIndex = Offset;
            return (TRUE);
        }

        Offset += 8;
    }

    *pNakIndex = 128;
    return (FALSE);
}


//----------------------------------------------------------------------------
BOOLEAN
AnyMoreNaks(
    IN  tSEND_RDATA_CONTEXT *pRData
    )
{
    if ((pRData->NumParityNaks) ||
        (pRData->SelectiveNaks[0]) ||
        (pRData->SelectiveNaks[1]))
    {
        return (TRUE);
    }

    return (FALSE);
}


//----------------------------------------------------------------------------
PSEND_RDATA_CONTEXT
FindFirstEntry(
    IN  tSEND_SESSION       *pSend,
    IN  tSEND_RDATA_CONTEXT **ppRDataLast,
    IN  BOOLEAN             fIgnoreWaitTime
    )
{
    tSEND_RDATA_CONTEXT *pRDataContext;
    tSEND_RDATA_CONTEXT *pRDataLast;
    LIST_ENTRY          *pEntry;
    tSEND_CONTEXT       *pSender = pSend->pSender;
    tRDATA_INFO         *pRDataInfo = pSender->pRDataInfo;
    ULONG               NumOtherRequests = pSender->NumODataRequestsPending;
    ULONGLONG           TimerTickCount = pSender->TimerTickCount;

    ASSERT (pSender->NumRDataRequestsPending <= pRDataInfo->NumAllocated);

    if (IsListEmpty (&pRDataInfo->PendingRDataRequests))
    {
        return (NULL);
    }

    if ((ppRDataLast) &&
        (pRDataLast = *ppRDataLast))
    {
        pEntry = &pRDataLast->Linkage;
    }
    else
    {
        pRDataLast = NULL;
        pEntry = &pRDataInfo->PendingRDataRequests;
    }

    while ((pEntry = pEntry->Flink) != &pRDataInfo->PendingRDataRequests)
    {
        pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);
        if (!pRDataContext->CleanupTime)
        {
            if ((fIgnoreWaitTime) ||
                (!NumOtherRequests) ||
                ((TimerTickCount >= pRDataContext->EarliestRDataSendTime)))
            {
                if (ppRDataLast)
                {
                    *ppRDataLast = pRDataLast;
                }
                return (pRDataContext);
            }

            pRDataLast = pRDataContext;
        }
        else if ((!pRDataContext->NumPacketsInTransport) &&
                 (TimerTickCount > pRDataContext->CleanupTime))
        {
            ClearNakIndices (pRDataContext);

            pEntry = pEntry->Blink;
            RemoveEntry (pRDataInfo, pRDataContext);
            DestroyEntry (pRDataInfo, pRDataContext);
        }
    }

    if (ppRDataLast)
    {
        *ppRDataLast = NULL;
    }
    return (NULL);
}


//----------------------------------------------------------------------------
PSEND_RDATA_CONTEXT
FindEntry(
    IN  SEQ_TYPE            SeqNum,
    IN  tSEND_SESSION       *pSend,
    IN  tRDATA_INFO         *pRDataInfo
    )
{
    tSEND_RDATA_CONTEXT         *pRDataContext = NULL;
    LIST_ENTRY                  *pEntry = NULL;
    ULONG                       i, Index, PrevIndex;

    if (IsListEmpty (&pRDataInfo->PendingRDataRequests))
    {
        return (NULL);
    }

    //
    // Try to find this entry via the FastFind list
    //
    Index = (SeqNum >> pRDataInfo->RepairDataIndexShift) & pRDataInfo->RepairDataMask;
    pEntry = &pRDataInfo->pRepairData[Index];
    while ((pEntry = pEntry->Flink) != &pRDataInfo->pRepairData[Index])
    {
        pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, FastFindLinkage);

        if (pRDataContext->RDataSequenceNumber == SeqNum)
        {
            return (pRDataContext);
        }
        else if (SEQ_GT (pRDataContext->RDataSequenceNumber, SeqNum))
        {
            break;
        }
    }

    return (NULL);
}


//----------------------------------------------------------------------------
ULONG
InsertInPendingList(
    IN  tSEND_SESSION       *pSend,
    IN  SEQ_TYPE            SeqNum,
    IN  tRDATA_INFO         *pRDataInfo,
    IN  tSEND_RDATA_CONTEXT *pRDataNew,
    IN  tSEND_RDATA_CONTEXT *pRDataContextPrev
    )
{
    ULONG                   i, PrevIndex, Index;
    SEQ_TYPE                MidSeq;
    LIST_ENTRY              *pEntry;
    tSEND_RDATA_CONTEXT     *pRDataPrev;
    tSEND_RDATA_CONTEXT     *pRDataContext;
    tSEND_CONTEXT           *pSender = pSend->pSender;
    ULONG                   LeadIndex;

    LeadIndex = ((pSender->NextODataSequenceNumber-1) >> pRDataInfo->IndexShift) & pRDataInfo->IndexMask;
    ASSERT (LeadIndex < pRDataInfo->MaxIndices);

    Index = (SeqNum >> pRDataInfo->IndexShift) & pRDataInfo->IndexMask;
    ASSERT (Index < pRDataInfo->MaxIndices);

    if (IsListEmpty (&pRDataInfo->PendingRDataRequests))
    {
        InsertTailList (&pRDataInfo->PendingRDataRequests, &pRDataNew->Linkage);
        return (Index);
    }

    pEntry = NULL;
    if (pRDataContextPrev)
    {
        PrevIndex = (pRDataContextPrev->RDataSequenceNumber >> pRDataInfo->IndexShift) & pRDataInfo->IndexMask;
        ASSERT (PrevIndex < pRDataInfo->MaxIndices);
        if (Index == PrevIndex)
        {
            pEntry = pRDataContextPrev->Linkage.Flink;
        }
    }

    if ((pEntry) ||
        (((pRDataInfo->TrailIndex != LeadIndex) ||
          (Index != LeadIndex)) &&
         (pEntry = pRDataInfo->pFirstEntry[Index])) ||
        ((pSender->NumRDataRequestsPending < pRDataInfo->IndexMask) &&
         (pEntry = pRDataInfo->PendingRDataRequests.Flink)))
    {
        while (pEntry != &pRDataInfo->PendingRDataRequests)
        {
            pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);

            if (SEQ_GEQ (pRDataContext->RDataSequenceNumber, SeqNum))
            {
                ASSERT (pRDataContext->RDataSequenceNumber != SeqNum);

                //
                // Insert before this Context
                //
                pRDataNew->Linkage.Flink = &pRDataContext->Linkage;
                pRDataNew->Linkage.Blink = pRDataContext->Linkage.Blink;
                pRDataContext->Linkage.Blink->Flink = &pRDataNew->Linkage;
                pRDataContext->Linkage.Blink = &pRDataNew->Linkage;

                return (Index);
            }

            pEntry = pEntry->Flink;
        }

        //
        // Insert at the end since we must have reached the end of the list!
        //
        ASSERT (pEntry == &pRDataInfo->PendingRDataRequests);
        InsertTailList (&pRDataInfo->PendingRDataRequests, &pRDataNew->Linkage);

        return (Index);
    }

    ASSERT ((Index == LeadIndex) ||
            (!pRDataInfo->pFirstEntry[Index]));

    if (Index == LeadIndex)
    {
        //
        // This Sequence is either at the leading edge or trailing edge
        //
        MidSeq = pSender->TrailingGroupSequenceNumber +
                 ((pSender->NextODataSequenceNumber - pSender->TrailingGroupSequenceNumber) >> 1);

        if (SEQ_LT (SeqNum, MidSeq))    // nearer the trailing edge
        {
            pEntry = &pRDataInfo->PendingRDataRequests;
            while ((pEntry = pEntry->Flink) != &pRDataInfo->PendingRDataRequests)
            {
                pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);

                if (SEQ_GEQ (pRDataContext->RDataSequenceNumber, SeqNum))
                {
                    ASSERT (pRDataContext->RDataSequenceNumber != SeqNum);

                    //
                    // Insert before this Context
                    //
                    pRDataNew->Linkage.Flink = &pRDataContext->Linkage;
                    pRDataNew->Linkage.Blink = pRDataContext->Linkage.Blink;
                    pRDataContext->Linkage.Blink->Flink = &pRDataNew->Linkage;
                    pRDataContext->Linkage.Blink = &pRDataNew->Linkage;

                    return (Index);
                }
            }

            //
            // Insert at the end since we must have reached the end of the list!
            //
            ASSERT (pEntry == &pRDataInfo->PendingRDataRequests);
            InsertTailList (&pRDataInfo->PendingRDataRequests, &pRDataNew->Linkage);

            return (Index);
        }
        //
        // Else we will need to search from the Tail end -- below!
        //
    }
    else    // if (Index != LeadIndex)
    {
        //
        // See if we can find a Context to insert ahead of
        //
        PrevIndex = 0;
        pRDataContext = NULL;
        if (Index > LeadIndex)
        {
            ASSERT ((Index >= pRDataInfo->TrailIndex) &&
                    (LeadIndex <= pRDataInfo->TrailIndex));

            for (i=Index+1; i<pRDataInfo->MaxIndices; i++)
            {
                if (pEntry = pRDataInfo->pFirstEntry[i])
                {
                    pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);
                    break;
                }
            }
        }
        else
        {
            PrevIndex = Index;
        }

        if (!pRDataContext)
        {
            for (i=PrevIndex; i<=LeadIndex; i++)
            {
                if (pEntry = pRDataInfo->pFirstEntry[i])
                {
                    pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);
                    if (SEQ_GT (SeqNum, pRDataContext->RDataSequenceNumber))
                    {
                        //
                        // This can happen if the LeadIndex and TrailIndex are the same, and
                        // we have entries from both the leading and trailing edge in this Index
                        //
                        ASSERT ((i == LeadIndex) &&
                                (LeadIndex == pRDataInfo->TrailIndex));
                        pRDataContext = NULL;
                    }
                    break;
                }
            }
        }

        if (pRDataContext)
        {
            //
            // Insert before this Context
            //
            pRDataNew->Linkage.Flink = &pRDataContext->Linkage;
            pRDataNew->Linkage.Blink = pRDataContext->Linkage.Blink;
            pRDataContext->Linkage.Blink->Flink = &pRDataNew->Linkage;
            pRDataContext->Linkage.Blink = &pRDataNew->Linkage;

            return (Index);
        }

        //
        // pRDataContext will still be NULL iff we have to insert near
        // the tail end of the list, for which we will need to search
        // backwards from the end!
        //
    }

    //
    // Search backwards from the end of the list
    //
    pRDataPrev = NULL;
    pEntry = &pRDataInfo->PendingRDataRequests;
    while ((pEntry = pEntry->Blink) != &pRDataInfo->PendingRDataRequests)
    {
        pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);

        //
        // Find the first Context whose Seq is < this Seq
        //
        if (SEQ_LEQ (pRDataContext->RDataSequenceNumber, SeqNum))
        {
            ASSERT (pRDataContext->RDataSequenceNumber != SeqNum);
            pRDataPrev = pRDataContext;
            break;
        }
    }

    if (pRDataPrev)
    {
        //
        // Insert ahead of this Context
        //
        pRDataNew->Linkage.Blink = &pRDataPrev->Linkage;
        pRDataNew->Linkage.Flink = pRDataPrev->Linkage.Flink;
        pRDataPrev->Linkage.Flink->Blink = &pRDataNew->Linkage;
        pRDataPrev->Linkage.Flink = &pRDataNew->Linkage;
    }
    else
    {
        InsertHeadList (&pRDataInfo->PendingRDataRequests, &pRDataNew->Linkage);
    }

    return (Index);
}


//----------------------------------------------------------------------------
PSEND_RDATA_CONTEXT
InsertEntry(
    IN  tSEND_SESSION       *pSend,
    IN  SEQ_TYPE            SeqNum,
    IN  tRDATA_INFO         *pRDataInfo,
    IN  tSEND_RDATA_CONTEXT *pRDataContextPrev
    )
{
    ULONG                   Index;
    LIST_ENTRY              *pEntry;
    tSEND_RDATA_CONTEXT     *pRDataNew;
    tSEND_RDATA_CONTEXT     *pRDataContext;

    if (!(pRDataNew = ExAllocateFromNPagedLookasideList (&pRDataInfo->RDataLookasideList)))
    {
        PgmTrace (LogError, ("InsertEntry: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES\n"));

        return (NULL);
    }
    PgmZeroMemory (pRDataNew, pRDataInfo->EntrySize);
    pRDataNew->RDataSequenceNumber = SeqNum;

    pRDataInfo->NumAllocated++;
    ASSERT (pSend->pSender->NumRDataRequestsPending < pRDataInfo->NumAllocated);

    Index = InsertInPendingList (pSend, SeqNum, pRDataInfo, pRDataNew, pRDataContextPrev);

    //
    // Set the Table information
    //
    if ((!(pEntry = pRDataInfo->pFirstEntry[Index])) ||
        ((pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage)) &&
         (SEQ_LT (SeqNum, pRDataContext->RDataSequenceNumber))))
    {
        pRDataInfo->pFirstEntry[Index] = &pRDataNew->Linkage;
    }

    //
    // Now, Insert this entry into the FastFind list
    //
    Index = (SeqNum >> pRDataInfo->RepairDataIndexShift) & pRDataInfo->RepairDataMask;
    pEntry = &pRDataInfo->pRepairData[Index];
    while ((pEntry = pEntry->Flink) != &pRDataInfo->pRepairData[Index])
    {
        pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, FastFindLinkage);

        if (SEQ_GEQ (pRDataContext->RDataSequenceNumber, SeqNum))
        {
            ASSERT ((SEQ_GT (pRDataContext->RDataSequenceNumber, SeqNum)) ||
                    (pRDataContext->CleanupTime));
                     
            break;
        }
    }
    pRDataNew->FastFindLinkage.Flink = pEntry;
    pRDataNew->FastFindLinkage.Blink = pEntry->Blink;
    pEntry->Blink->Flink = &pRDataNew->FastFindLinkage;
    pEntry->Blink = &pRDataNew->FastFindLinkage;

    return (pRDataNew);
}


//----------------------------------------------------------------------------
VOID
RemoveEntry(
    IN  tRDATA_INFO         *pRDataInfo,
    IN  tSEND_RDATA_CONTEXT *pRData
    )
{
    tSEND_RDATA_CONTEXT *pRDataNext;
    ULONG               Index, NextIndex;
    SEQ_TYPE            SeqNum = pRData->RDataSequenceNumber;

    ASSERT (!IsListEmpty (&pRData->Linkage));
    Index = (SeqNum >> pRDataInfo->IndexShift) & pRDataInfo->IndexMask;
    ASSERT (Index < pRDataInfo->MaxIndices);

    //
    // See if we need to update the Table
    //
    if (&pRData->Linkage == pRDataInfo->pFirstEntry[Index])
    {
        if (pRData->Linkage.Flink == &pRDataInfo->PendingRDataRequests)
        {
            pRDataInfo->pFirstEntry[Index] = NULL;
        }
        else
        {
            pRDataNext = CONTAINING_RECORD (pRData->Linkage.Flink, tSEND_RDATA_CONTEXT, Linkage);
            NextIndex = (pRDataNext->RDataSequenceNumber >> pRDataInfo->IndexShift) & pRDataInfo->IndexMask;
            ASSERT (NextIndex < pRDataInfo->MaxIndices);

            if (NextIndex == Index)
            {
                pRDataInfo->pFirstEntry[Index] = &pRDataNext->Linkage;
            }
            else
            {
                pRDataInfo->pFirstEntry[Index] = NULL;
            }
        }
    }

    RemoveEntryList (&pRData->Linkage);
    InitializeListHead (&pRData->Linkage);
}



//----------------------------------------------------------------------------
VOID
DestroyEntry(
    IN  tRDATA_INFO         *pRDataInfo,
    IN  tSEND_RDATA_CONTEXT *pRData
    )
{
    ASSERT (IsListEmpty (&pRData->Linkage));
    RemoveEntryList (&pRData->FastFindLinkage);
    ExFreeToNPagedLookasideList (&pRDataInfo->RDataLookasideList, pRData);
    pRDataInfo->NumAllocated--;
}


//----------------------------------------------------------------------------
ULONG
RemoveAllEntries(
    IN  tSEND_SESSION       *pSend,
    IN  BOOLEAN             fForceRemoveAll
    )
{
    LIST_ENTRY          *pEntry;
    tSEND_RDATA_CONTEXT *pRDataContext;
    tRDATA_INFO         *pRDataInfo = pSend->pSender->pRDataInfo;
    ULONGLONG           TimerTickCount = pSend->pSender->TimerTickCount;
    ULONG               NumEntriesRemoved = 0;

    pEntry = &pRDataInfo->PendingRDataRequests;
    while ((pEntry = pEntry->Flink) != &pRDataInfo->PendingRDataRequests)
    {
        pRDataContext = CONTAINING_RECORD (pEntry, tSEND_RDATA_CONTEXT, Linkage);

        if ((fForceRemoveAll) ||
            ((pRDataContext->CleanupTime) &&
             (TimerTickCount > pRDataContext->CleanupTime)))
        {
            ClearNakIndices (pRDataContext);

            //
            // Save pEntry since the current pEntry is about to be removed
            //
            pEntry = pEntry->Blink;

            if (!pRDataContext->NumPacketsInTransport)
            {
                if (!pRDataContext->CleanupTime)
                {
                    NumEntriesRemoved++;
                    pSend->pSender->NumRDataRequestsPending--;
                }

                RemoveEntry (pRDataInfo, pRDataContext);
                DestroyEntry (pRDataInfo, pRDataContext);
            }
            else
            {
                //
                // We have a packet pending in the transport
                //
                if (!pRDataContext->CleanupTime)
                {
                    NumEntriesRemoved++;
                    pSend->pSender->NumRDataRequestsPending--;
                }

                pRDataContext->CleanupTime = TimerTickCount;
                pRDataContext->PostRDataHoldTime = 0;
                RemoveEntry (pRDataInfo, pRDataContext);
            }
        }
    }

    ASSERT (pSend->pSender->NumRDataRequestsPending <= pRDataInfo->NumAllocated);
    return (NumEntriesRemoved);
}


//----------------------------------------------------------------------------
VOID
UpdateRDataTrailingEdge(
    IN  tRDATA_INFO         *pRDataInfo,
    IN  SEQ_TYPE            SeqNum
    )
{
    pRDataInfo->TrailIndex = (SeqNum >> pRDataInfo->IndexShift) & pRDataInfo->IndexMask;
}

//----------------------------------------------------------------------------

NTSTATUS
FilterAndAddNaksToList(
    IN  tSEND_SESSION       *pSend,
    IN  tNAKS_LIST          *pNaksList
    )
{
    UCHAR               i, NumNcfs;
    SEQ_TYPE            SeqNum, FurthestGroupSeqNum;
    ULONGLONG           PreRDataWait;
    tSEND_RDATA_CONTEXT *pRDataNew;
    tSEND_RDATA_CONTEXT *pRDataNext;
    tSEND_RDATA_CONTEXT *pRDataPrev = NULL;
    BOOLEAN             fNewEntry, fAppendRemainingEntries = FALSE;
    tSEND_CONTEXT       *pSender = pSend->pSender;
    tRDATA_INFO         *pRDataInfo = pSender->pRDataInfo;
    BOOLEAN             fHoldForCleanup = !(pSend->pAssociatedAddress->Flags &
                                            PGM_ADDRESS_HIGH_SPEED_OPTIMIZED);

    NumNcfs = 0;
    pRDataPrev = NULL;
    FurthestGroupSeqNum = pSender->LastODataSentSequenceNumber & ~((SEQ_TYPE) pSend->FECGroupSize-1);
    for (i = 0; i < pNaksList->NumSequences; i++)
    {
        SeqNum = pNaksList->pNakSequences[i];
        pRDataNew = pRDataNext = NULL;
        if ((!fAppendRemainingEntries) &&
            (pRDataNew = FindEntry (SeqNum, pSend, pRDataInfo)))
        {
            fNewEntry = FALSE;
        }
        else if (pRDataNew = InsertEntry (pSend, SeqNum, pRDataInfo, pRDataPrev))
        {
            fNewEntry = TRUE;
        }
        else
        {
            PgmTrace (LogError, ("FindOrAddRDataSequences: ERROR -- "  \
                "[1] STATUS_INSUFFICIENT_RESOURCES\n"));
            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        //
        // OK, we now have the RData context
        //
        if (fNewEntry)
        {
            pRDataNew->pSend = pSend;

            if (!pSend->FECOptions)
            {
                pRDataNew->SelectiveNaksMask[0] = 1;
                pSender->NumOutstandingNaks++;
            }
            else if (pNaksList->NakType & NAK_TYPE_SELECTIVE)
            {
                AddSelectiveNakToList (pNaksList->NakIndex[i], pRDataNew);
                pSender->NumOutstandingNaks++;
            }
            else
            {
                pRDataNew->NumParityNaks = pNaksList->NumParityNaks[i];
                pSender->NumOutstandingNaks += pNaksList->NumParityNaks[i];
            }
            pSender->NumRDataRequestsPending++;
            ASSERT (pSender->NumRDataRequestsPending <= pRDataInfo->NumAllocated);

            if (SEQ_GT (pSender->LastODataSentSequenceNumber, pSender->TrailingGroupSequenceNumber))
            {
                PreRDataWait = (((SEQ_TYPE) (pRDataNew->RDataSequenceNumber -
                                             pSender->TrailingGroupSequenceNumber)) *
                                pSender->RDataLingerTime) /
                               ((SEQ_TYPE) (pSender->LastODataSentSequenceNumber -
                                            pSender->TrailingGroupSequenceNumber + 1));
                pRDataNew->EarliestRDataSendTime = pSender->TimerTickCount + PreRDataWait;
                if (fHoldForCleanup)
                {
                    pRDataNew->PostRDataHoldTime = pSender->RDataLingerTime - PreRDataWait;
                }
                else
                {
                    pRDataNew->PostRDataHoldTime = 0;
                }
            }
            else
            {
                pRDataNew->EarliestRDataSendTime = 0;
                if (fHoldForCleanup)
                {
                    pRDataNew->PostRDataHoldTime = pSender->RDataLingerTime;
                }
                else
                {
                    pRDataNew->PostRDataHoldTime = 0;
                }
            }

            PgmTrace (LogPath, ("FilterAndAddNaksToList:  "  \
                "Appended Sequence # [%d] to RData list!\n",
                    (ULONG) pNaksList->pNakSequences[i]));
        }
        else if (pRDataNew->CleanupTime)    // Old entry already serviced -- in post send phase
        {
            //
            // Reuse this RData only if it has passed the Linger time
            //
            if ((!pRDataNew->PostRDataHoldTime) ||
                (pSender->TimerTickCount < pRDataNew->CleanupTime))
            {
                //
                // Ignore this request!
                //
                pSender->NumNaksAfterRData++;
                continue;
            }

            pSender->NumRDataRequestsPending++;
            ASSERT (pSender->NumRDataRequestsPending <= pRDataInfo->NumAllocated);
            pRDataNew->CleanupTime = 0;
            ClearNakIndices (pRDataNew);

            if (!pSend->FECOptions)
            {
                pRDataNew->SelectiveNaksMask[0] = 1;
                pSender->NumOutstandingNaks++;
            }
            else if (pNaksList->NakType & NAK_TYPE_SELECTIVE)
            {
                if (AddSelectiveNakToList (pNaksList->NakIndex[i], pRDataNew));
                {
                    pSender->NumOutstandingNaks++;
                }
            }
            else
            {
                pRDataNew->NumParityNaks = pNaksList->NumParityNaks[i];
                pSender->NumOutstandingNaks += pNaksList->NumParityNaks[i];
            }

            if (SEQ_GT (pSender->LastODataSentSequenceNumber, pSender->TrailingGroupSequenceNumber))
            {
                PreRDataWait = (((SEQ_TYPE) (pRDataNew->RDataSequenceNumber -
                                             pSender->TrailingGroupSequenceNumber)) *
                                pSender->RDataLingerTime) /
                               ((SEQ_TYPE) (pSender->LastODataSentSequenceNumber -
                                            pSender->TrailingGroupSequenceNumber + 1));
                pRDataNew->EarliestRDataSendTime = pSender->TimerTickCount + PreRDataWait;
                if (fHoldForCleanup)
                {
                    pRDataNew->PostRDataHoldTime = pSender->RDataLingerTime - PreRDataWait;
                }
                else
                {
                    pRDataNew->PostRDataHoldTime = 0;
                }
            }
            else
            {
                pRDataNew->EarliestRDataSendTime = 0;
                if (fHoldForCleanup)
                {
                    pRDataNew->PostRDataHoldTime = pSender->RDataLingerTime;
                }
                else
                {
                    pRDataNew->PostRDataHoldTime = 0;
                }
            }

        }
        // Entry still waiting to be serviced
        else if (pNaksList->NakType & NAK_TYPE_SELECTIVE)
        {
            if (!pSend->FECOptions)
            {
                pRDataNew->SelectiveNaksMask[0] = 1;
            }
            else if ((!pRDataNew->NumParityNaks) &&
                     (SEQ_LT (SeqNum, FurthestGroupSeqNum)))
            {
                //
                // Ignore this request since we will not add any new Selective Naks if no Parity Naks left
                // (No Parity Naks implies that we do not have any Parity Naks or have finished sending them)
                // or it is not in the leading group
                //
                pSender->NumNaksAfterRData++;
                continue;
            }
            else if (AddSelectiveNakToList (pNaksList->NakIndex[i], pRDataNew))
            {
                pSender->NumOutstandingNaks++;
            }
        }
        else if (pNaksList->NumParityNaks[i] > pRDataNew->NumParityNaks)      // Parity Naks
        {
            ASSERT (pNaksList->NakType & NAK_TYPE_PARITY);
            pSender->NumOutstandingNaks += (pNaksList->NumParityNaks[i] - pRDataNew->NumParityNaks);
            pRDataNew->NumParityNaks = pNaksList->NumParityNaks[i];
        }

        pRDataPrev = pRDataNew;
        pNaksList->pNakSequences[NumNcfs] = pNaksList->pNakSequences[i];
        pNaksList->NumParityNaks[NumNcfs] = pNaksList->NumParityNaks[i];
        NumNcfs++;
    }

    pNaksList->NumSequences = NumNcfs;
    return (STATUS_SUCCESS);
}



//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

#define     MAX_RECEIVE_INDICES             1024        // Must be a power of 2!
#define     MAX_RECEIVE_INDICES_HIGH_SPEED  8192        // Must be a power of 2!



LIST_ENTRY  *
InitReceiverData(
    IN  tRECEIVE_SESSION        *pReceive
    )
{
    tRECEIVE_CONTEXT        *pReceiver = pReceive->pReceiver;
    LIST_ENTRY              *pListEntry;
    USHORT                  i;

    if (pReceive->pAssociatedAddress->Flags & PGM_ADDRESS_HIGH_SPEED_OPTIMIZED)
    {
        pReceiver->ReceiveDataMaxEntries = MAX_RECEIVE_INDICES_HIGH_SPEED;
    }
    else
    {
        pReceiver->ReceiveDataMaxEntries = MAX_RECEIVE_INDICES;
    }

    pReceiver->ReceiveDataMask = pReceiver->ReceiveDataMaxEntries - 1;
    pReceiver->ReceiveDataIndexShift = 0;

    if (!(pListEntry = PgmAllocMem ((sizeof (LIST_ENTRY) * pReceiver->ReceiveDataMaxEntries), PGM_TAG('R'))))
    {
        PgmTrace (LogError, ("InitReceiverData: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES\n"));

        return (NULL);
    }

    for (i=0; i<pReceiver->ReceiveDataMaxEntries; i++)
    {
        InitializeListHead (&pListEntry[i]);
    }

    return (pListEntry);
}


tNAK_FORWARD_DATA   *
FindReceiverEntry(
    IN  tRECEIVE_CONTEXT        *pReceiver,
    IN  SEQ_TYPE                SeqNum
    )
{
    USHORT                  Index;
    LIST_ENTRY              *pEntry;
    tNAK_FORWARD_DATA       *pNak;

    Index = (USHORT) ((SeqNum >> pReceiver->ReceiveDataIndexShift) & pReceiver->ReceiveDataMask);
    pEntry = &pReceiver->pReceiveData[Index];
    while ((pEntry = pEntry->Flink) != &pReceiver->pReceiveData[Index])
    {
        pNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, LookupLinkage);

        if (pNak->SequenceNumber == SeqNum)
        {
            return (pNak);
        }
        else if (SEQ_GT (pNak->SequenceNumber, SeqNum))
        {
            break;
        }
    }

    return (NULL);
}


VOID
AppendPendingReceiverEntry(
    IN  tRECEIVE_CONTEXT        *pReceiver,
    IN  tNAK_FORWARD_DATA       *pNak
    )
{
    USHORT                  Index;

    Index = (USHORT)((pNak->SequenceNumber >> pReceiver->ReceiveDataIndexShift) & pReceiver->ReceiveDataMask);
    InsertTailList (&pReceiver->pReceiveData[Index], &pNak->LookupLinkage);
    InsertTailList (&pReceiver->PendingNaksList, &pNak->SendNakLinkage);
}


VOID
RemovePendingReceiverEntry(
    IN  tNAK_FORWARD_DATA       *pNak
    )
{
    ASSERT (!IsListEmpty (&pNak->LookupLinkage));
    ASSERT (!IsListEmpty (&pNak->SendNakLinkage));

    RemoveEntryList (&pNak->SendNakLinkage);
    InitializeListHead (&pNak->SendNakLinkage);

    RemoveEntryList (&pNak->LookupLinkage);
    InitializeListHead (&pNak->LookupLinkage);
}

VOID
RemoveAllPendingReceiverEntries(
    IN  tRECEIVE_CONTEXT        *pReceiver
    )
{
    USHORT                  i;
    LIST_ENTRY              *pEntry;
    tNAK_FORWARD_DATA       *pNak;

    if (!pReceiver->pReceiveData)
    {
        return;
    }

    while (!IsListEmpty (&pReceiver->PendingNaksList))
    {
        pEntry = RemoveHeadList (&pReceiver->PendingNaksList);
        pNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, SendNakLinkage);
        InitializeListHead (pEntry);

        ASSERT (!IsListEmpty (&pNak->LookupLinkage));
        RemoveEntryList (&pNak->LookupLinkage);
        InitializeListHead (&pNak->LookupLinkage);
    }

    pEntry = pReceiver->pReceiveData;
    for (i=0; i<pReceiver->ReceiveDataMaxEntries; i++)
    {
        ASSERT (IsListEmpty (&pEntry[i]));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\connect.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Connect.c

Abstract:

    This module implements Connect handling routines
    for the PGM Transport

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"
#include <tcpinfo.h>    // for AO_OPTION_xxx, TCPSocketOption
#include <ipexport.h>   // for IP_OPT_ROUTER_ALERT

#ifdef FILE_LOGGING
#include "connect.tmh"
#endif  // FILE_LOGGING


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PgmCreateConnection)
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

NTSTATUS
PgmCreateConnection(
    IN  tPGM_DEVICE                 *pPgmDevice,
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp,
    IN  PFILE_FULL_EA_INFORMATION   TargetEA
    )
/*++

Routine Description:

    This routine is called to create a connection context for the client
    At this time, we do not knwo which address which connection will
    be associated with, nor do we know whether it will be a sender
    or a receiver.

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer
    IN  TargetEA    -- contains the client's Connect context

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    NTSTATUS                    status;
    CONNECTION_CONTEXT          ConnectionContext;
    tCOMMON_SESSION_CONTEXT     *pSession = NULL;

    PAGED_CODE();

    if (TargetEA->EaValueLength < sizeof(CONNECTION_CONTEXT))
    {
        PgmTrace (LogError, ("PgmCreateConnection: ERROR -- "  \
            "(BufferLength=%d < Min=%d)\n", TargetEA->EaValueLength, sizeof(CONNECTION_CONTEXT)));
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    if (!(pSession = PgmAllocMem (sizeof(tCOMMON_SESSION_CONTEXT), PGM_TAG('0'))))
    {
        PgmTrace (LogError, ("PgmCreateConnection: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES, Requested <%d> bytes\n", sizeof(tCOMMON_SESSION_CONTEXT)));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    PgmZeroMemory (pSession, sizeof (tCOMMON_SESSION_CONTEXT));

    InitializeListHead (&pSession->Linkage);
    PgmInitLock (pSession, SESSION_LOCK);
    pSession->Verify = PGM_VERIFY_SESSION_UNASSOCIATED;
    PGM_REFERENCE_SESSION_UNASSOCIATED (pSession, REF_SESSION_CREATE, TRUE);
    pSession->Process = (PEPROCESS) PsGetCurrentProcess();

    // the connection context value is stored in the string just after the
    // name "connectionContext", and it is most likely unaligned, so just
    // copy it out.( 4 bytes of copying ).
    PgmCopyMemory (&pSession->ClientSessionContext,
                   (CONNECTION_CONTEXT) &TargetEA->EaName[TargetEA->EaNameLength+1],
                   sizeof (CONNECTION_CONTEXT));

    PgmTrace (LogStatus, ("PgmCreateConnection:  "  \
        "pSession=<%p>, ConnectionContext=<%p>\n",
            pSession, * ((PVOID UNALIGNED *) &TargetEA->EaName[TargetEA->EaNameLength+1])));

    // link on to list of open connections for this device so that we
    // know how many open connections there are at any time (if we need to know)
    // This linkage is only in place until the client does an associate, then
    // the connection is unlinked from here and linked to the client ConnectHead.
    //
    PgmInterlockedInsertTailList (&PgmDynamicConfig.ConnectionsCreated, &pSession->Linkage,&PgmDynamicConfig);

    pIrpSp->FileObject->FsContext = pSession;
    pIrpSp->FileObject->FsContext2 = (PVOID) TDI_CONNECTION_FILE;

    return (STATUS_SUCCESS);
}



//----------------------------------------------------------------------------

VOID
PgmCleanupSession(
    IN  tCOMMON_SESSION_CONTEXT *pSession,
    IN  PVOID                   Unused1,
    IN  PVOID                   Unused2
    )
/*++

Routine Description:

    This routine performs the cleanup operation for a session
    handle once the RefCount goes to 0.  It is called after a
    cleanup has been requested on this handle
    This routine has to be called at Passive Irql since we will
    need to do some file/section handle manipulation here.

Arguments:

    IN  pSession    -- the session object to be cleaned up

Return Value:

    NONE

--*/
{
    PIRP            pIrpCleanup;
    PGMLockHandle   OldIrq;

    PgmTrace (LogStatus, ("PgmCleanupSession:  "  \
        "Cleanup Session=<%p>\n", pSession));

    if ((pSession->SessionFlags & PGM_SESSION_FLAG_SENDER) &&
        (pSession->pSender->SendDataBufferMapping))
    {
        PgmUnmapAndCloseDataFile (pSession);
        pSession->pSender->SendDataBufferMapping = NULL;
    }

    PgmLock (pSession, OldIrq);
    pSession->Process = NULL;           // To remember that we have cleanedup

    if (pIrpCleanup = pSession->pIrpCleanup)
    {
        pSession->pIrpCleanup = NULL;
        PgmUnlock (pSession, OldIrq);
        PgmIoComplete (pIrpCleanup, STATUS_SUCCESS, 0);
    }
    else
    {
        PgmUnlock (pSession, OldIrq);
    }
}


//----------------------------------------------------------------------------

VOID
PgmDereferenceSessionCommon(
    IN  tCOMMON_SESSION_CONTEXT *pSession,
    IN  ULONG                   SessionType,
    IN  ULONG                   RefContext
    )
/*++

Routine Description:

    This routine is called as a result of a dereference on a session object

Arguments:

    IN  pSession    -- the Session object
    IN  SessionType -- basically, whether it is PGM_VERIFY_SESSION_SEND
                        or PGM_VERIFY_SESSION_RECEIVE
    IN  RefContext  -- the context for which this session object was
                        referenced earlier

Return Value:

    NONE

--*/
{
    NTSTATUS                status;
    PGMLockHandle           OldIrq;
    PIRP                    pIrpCleanup;
    LIST_ENTRY              *pEntry;
    tNAK_FORWARD_DATA       *pNak;

    PgmLock (pSession, OldIrq);

    ASSERT (PGM_VERIFY_HANDLE2 (pSession, SessionType, PGM_VERIFY_SESSION_DOWN));
    ASSERT (pSession->RefCount);             // Check for too many derefs
    ASSERT (pSession->ReferenceContexts[RefContext]--);

    if (--pSession->RefCount)
    {
        PgmUnlock (pSession, OldIrq);
        return;
    }

    PgmTrace (LogStatus, ("PgmDereferenceSessionCommon:  "  \
        "pSession=<%p> Derefenced out, pIrpCleanup=<%p>\n", pSession, pSession->pIrpCleanup));

    ASSERT (!pSession->pAssociatedAddress);

    pIrpCleanup = pSession->pIrpCleanup;
    //
    // Sonce we may have a lot of memory buffered up, we need
    // to free it at non-Dpc
    //
    if (pSession->pReceiver)
    {
        CleanupPendingNaks (pSession, (PVOID) FALSE, (PVOID) TRUE);
    }
    PgmUnlock (pSession, OldIrq);

    //
    // Remove from the global list
    //
    PgmLock (&PgmDynamicConfig, OldIrq);
    RemoveEntryList (&pSession->Linkage);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    //
    // If we are currently at Dpc, we will have to close the handles
    // on a Delayed Worker thread!
    //
    if (PgmGetCurrentIrql())
    {
        status = PgmQueueForDelayedExecution (PgmCleanupSession, pSession, NULL, NULL, FALSE);
        if (!NT_SUCCESS (status))
        {
            //
            // Apparently we ran out of Resources!
            // Complete the cleanup Irp for now and hope that the Close
            // can complete the rest of the cleanup
            //
            PgmTrace (LogError, ("PgmDereferenceSessionCommon: ERROR -- "  \
                "OUT_OF_RSRC, cannot queue Worker request for pSession=<%p>\n", pSession));

            if (pIrpCleanup)
            {
                pSession->pIrpCleanup = NULL;
                PgmIoComplete (pIrpCleanup, STATUS_SUCCESS, 0);
            }
        }
    }
    else
    {
        PgmCleanupSession (pSession, NULL, NULL);
    }
}


//----------------------------------------------------------------------------

NTSTATUS
PgmCleanupConnection(
    IN  tCOMMON_SESSION_CONTEXT *pSession,
    IN  PIRP                    pIrp
    )
/*++

Routine Description:

    This routine is called as a result of a close on the client's
    session handle.  If we are a sender, our main job here is to
    send the FIN immediately, otherwise if we are a receiver, we
    need to remove ourselves from the timer list

Arguments:

    IN  pSession    -- the Session object
    IN  pIrp        -- Client's request Irp

Return Value:

    NTSTATUS - Final status of the request (STATUS_PENDING)

--*/
{
    tCLIENT_SEND_REQUEST    *pSendContext;
    PGMLockHandle           OldIrq, OldIrq1;

    PgmLock (&PgmDynamicConfig, OldIrq);
    PgmLock (pSession, OldIrq1);

    ASSERT (PGM_VERIFY_HANDLE3 (pSession, PGM_VERIFY_SESSION_UNASSOCIATED,
                                          PGM_VERIFY_SESSION_SEND,
                                          PGM_VERIFY_SESSION_RECEIVE));
    pSession->Verify = PGM_VERIFY_SESSION_DOWN;

    //
    // If Connection is currently associated, we must let the Disassociate handle
    // Removing the connection from the list
    //
    if (pSession->pAssociatedAddress)
    {
        PgmTrace (LogStatus, ("PgmCleanupConnection:  "  \
            "WARNING:  pSession=<%p : %x> was not disassociated from pAddress=<%p : %x> earlier\n",
                pSession, pSession->Verify,
                pSession->pAssociatedAddress, pSession->pAssociatedAddress->Verify));

        ASSERT (0);

        PgmUnlock (pSession, OldIrq1);
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        PgmDisassociateAddress (pIrp, IoGetCurrentIrpStackLocation(pIrp));

        PgmLock (&PgmDynamicConfig, OldIrq);
        PgmLock (pSession, OldIrq1);
    }

    ASSERT (!pSession->pAssociatedAddress);

    //
    // Remove connection from either ConnectionsCreated list
    // or ConnectionsDisassociated list
    //
    RemoveEntryList (&pSession->Linkage);
    InsertTailList (&PgmDynamicConfig.CleanedUpConnections, &pSession->Linkage);

    PgmTrace (LogAllFuncs, ("PgmCleanupConnection:  "  \
        "pSession=<%p>\n", pSession));

    pSession->pIrpCleanup = pIrp;
    if (pSession->SessionFlags & PGM_SESSION_ON_TIMER)
    {
        pSession->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
    }

    PgmUnlock (pSession, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    PGM_DEREFERENCE_SESSION_UNASSOCIATED (pSession, REF_SESSION_CREATE);

    return (STATUS_PENDING);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmCloseConnection(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is the final dispatch operation to be performed
    after the cleanup, which should result in the session object
    being completely destroyed -- our RefCount must have already
    been set to 0 when we completed the Cleanup request.

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the operation (STATUS_SUCCESS)

--*/
{
    tCOMMON_SESSION_CONTEXT *pSession = (tCOMMON_SESSION_CONTEXT *) pIrpSp->FileObject->FsContext;

    PgmTrace (LogAllFuncs, ("PgmCloseConnection:  "  \
        "pSession=<%p>\n", pSession));

    ASSERT (!pSession->pIrpCleanup);

    if (pSession->Process)
    {
        PgmTrace (LogStatus, ("PgmCloseConnection:  "  \
            "WARNING!  pSession=<%p>, Not yet cleaned up -- Calling cleanup again ...\n", pSession));

        PgmCleanupSession (pSession, NULL, NULL);
    }

    pIrpSp->FileObject->FsContext = NULL;

    if (pSession->FECOptions)
    {
        DestroyFECContext (&pSession->FECContext);
    }

    if (pSession->pSender)
    {
        ExDeleteResourceLite (&pSession->pSender->Resource);  // Delete the resource

        if (pSession->pSender->DataFileName.Buffer)
        {
            PgmFreeMem (pSession->pSender->DataFileName.Buffer);
        }

        if (pSession->pSender->pProActiveParityContext)
        {
            PgmFreeMem (pSession->pSender->pProActiveParityContext);
        }

        if (pSession->pSender->SendTimeoutCount)
        {
            ExDeleteNPagedLookasideList (&pSession->pSender->SenderBufferLookaside);
            ExDeleteNPagedLookasideList (&pSession->pSender->SendContextLookaside);
        }
        PgmFreeMem (pSession->pSender);
    }
    else if (pSession->pReceiver)
    {
        ASSERT (!pSession->pReceiver->NumDataBuffersFromLookaside);
        if (pSession->SessionFlags & PGM_SESSION_DATA_FROM_LOOKASIDE)   // Ensure no more lookaside!
        {
            ASSERT (pSession->pReceiver->MaxBufferLength);
            ExDeleteNPagedLookasideList (&pSession->pReceiver->DataBufferLookaside);
        }
        else
        {
            ASSERT (!pSession->pReceiver->MaxBufferLength);
        }

        if (pSession->pFECBuffer)
        {
            PgmFreeMem (pSession->pFECBuffer);
        }

        if (pSession->FECGroupSize)
        {
            ExDeleteNPagedLookasideList (&pSession->pReceiver->NonParityContextLookaside);

            if (pSession->FECOptions)
            {
                ExDeleteNPagedLookasideList (&pSession->pReceiver->ParityContextLookaside);
            }
        }

        if (pSession->pReceiver->pReceiveData)
        {
            PgmFreeMem (pSession->pReceiver->pReceiveData);
            pSession->pReceiver->pReceiveData = NULL;
        }

        PgmFreeMem (pSession->pReceiver);
    }

    PgmFreeMem (pSession);

    //
    // The final Dereference will complete the Irp!
    //
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
NTSTATUS
PgmConnect(
    IN  tPGM_DEVICE                 *pPgmDevice,
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp
    )
/*++

Routine Description:

    This routine is called to setup a connection, but since we are
    doing PGM, there are no packets to be sent out.  What we will
    do here is to create the file + section map for buffering the
    data packets, and also finalize the settings based on the default
    + user -specified settings

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the connect operation

--*/
{
    tIPADDRESS                  IpAddress, OutIfAddress;
    LIST_ENTRY                  *pEntry;
    LIST_ENTRY                  *pEntry2;
    tLOCAL_INTERFACE            *pLocalInterface = NULL;
    tADDRESS_ON_INTERFACE       *pLocalAddress = NULL;
    USHORT                      Port;
    PGMLockHandle               OldIrq, OldIrq1, OldIrq2;
    NTSTATUS                    status;
    ULONGLONG                   WindowAdvanceInMSecs;
    tADDRESS_CONTEXT            *pAddress = NULL;
    tSEND_SESSION               *pSend = (tSEND_SESSION *) pIrpSp->FileObject->FsContext;
    PTDI_REQUEST_KERNEL         pRequestKernel  = (PTDI_REQUEST_KERNEL) &pIrpSp->Parameters;
    ULONG                       Length, MCastTtl;
    UCHAR                       RouterAlert[4] = {IP_OPT_ROUTER_ALERT, ROUTER_ALERT_SIZE, 0, 0};

    ASSERT (!pSend->pSender->SendTimeoutCount);
    //
    // Verify Minimum Buffer length!
    //
    if (!GetIpAddress (pRequestKernel->RequestConnectionInformation->RemoteAddress,
                       pRequestKernel->RequestConnectionInformation->RemoteAddressLength,
                       &IpAddress,
                       &Port))
    {
        PgmTrace (LogError, ("PgmConnect: ERROR -- "  \
            "pSend=<%p>, Invalid Dest address!\n", pSend));
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    //
    // Now, verify that the Connection handle is valid + associated!
    //
    if ((!PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_SEND)) ||
        (!(pAddress = pSend->pAssociatedAddress)) ||
        (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)) ||
        (pAddress->Flags & PGM_ADDRESS_FLAG_INVALID_OUT_IF))
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        PgmTrace (LogError, ("PgmConnect: ERROR -- "  \
            "BAD Handle(s), pSend=<%p>, pAddress=<%p>\n", pSend, pAddress));

        return (STATUS_INVALID_HANDLE);
    }

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_CONNECT, FALSE);
    PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_CONNECT, FALSE);

    //
    // If we are not optimized for high speed Intranet environment,
    // set the Router Alert option
    //
    if (!(pAddress->Flags & PGM_ADDRESS_HIGH_SPEED_OPTIMIZED))
    {
        ASSERT (pAddress->RAlertFileHandle);
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        status = PgmSetTcpInfo (pAddress->RAlertFileHandle,
                                AO_OPTION_IPOPTIONS,
                                RouterAlert,
                                sizeof (RouterAlert));

        if (!NT_SUCCESS (status))
        {
            PgmTrace (LogError, ("PgmConnect: ERROR -- "  \
                "AO_OPTION_IPOPTIONS for Router Alert returned <%x>\n", status));

            PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_CONNECT);
            PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_CONNECT);
            return (status);
        }

        PgmLock (&PgmDynamicConfig, OldIrq);
    }

    //
    // If an outgoing interface has not yet been specified by the
    // client, select one ourselves
    //
    if (!pAddress->SenderMCastOutIf)
    {
        status = STATUS_ADDRESS_NOT_ASSOCIATED;
        OutIfAddress = 0;

        pEntry = &PgmDynamicConfig.LocalInterfacesList;
        while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
        {
            pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
            pEntry2 = &pLocalInterface->Addresses;
            while ((pEntry2 = pEntry2->Flink) != &pLocalInterface->Addresses)
            {
                pLocalAddress = CONTAINING_RECORD (pEntry2, tADDRESS_ON_INTERFACE, Linkage);
                OutIfAddress = htonl (pLocalAddress->IpAddress);

                PgmUnlock (&PgmDynamicConfig, OldIrq);
                status = SetSenderMCastOutIf (pAddress, OutIfAddress);
                PgmLock (&PgmDynamicConfig, OldIrq);

                break;
            }

            if (OutIfAddress)
            {
                break;
            }
        }

        if (!NT_SUCCESS (status))
        {
            PgmUnlock (&PgmDynamicConfig, OldIrq);
            PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_CONNECT);
            PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_CONNECT);

            PgmTrace (LogError, ("PgmConnect: ERROR -- "  \
                "Could not bind sender to <%x>!\n", OutIfAddress));

            return (STATUS_UNSUCCESSFUL);
        }
    }

    //
    // So, we found a valid address to send to
    //
    pSend->pSender->DestMCastIpAddress = ntohl (IpAddress);
    pSend->pSender->DestMCastPort = pAddress->SenderMCastPort = ntohs (Port);
    pSend->pSender->SenderMCastOutIf = pAddress->SenderMCastOutIf;

    //
    // Set the FEC Info (if applicable)
    //
    pSend->FECBlockSize = pAddress->FECBlockSize;
    pSend->FECGroupSize = pAddress->FECGroupSize;

    if (pAddress->FECOptions)
    {
        Length = sizeof(tBUILD_PARITY_CONTEXT) + pSend->FECGroupSize*sizeof(PUCHAR);
        if (!(pSend->pSender->pProActiveParityContext = (tBUILD_PARITY_CONTEXT *) PgmAllocMem (Length,PGM_TAG('0'))) ||
            (!NT_SUCCESS (status = CreateFECContext (&pSend->FECContext, pSend->FECGroupSize, pSend->FECBlockSize, FALSE))))
        {
            if (pSend->pSender->pProActiveParityContext)
            {
                PgmFreeMem (pSend->pSender->pProActiveParityContext);
                pSend->pSender->pProActiveParityContext = NULL;
            }

            PgmUnlock (&PgmDynamicConfig, OldIrq);
            PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_CONNECT);
            PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_CONNECT);

            PgmTrace (LogError, ("PgmConnect: ERROR -- "  \
                "CreateFECContext returned <%x>, pSend=<%p>, Dest IpAddress=<%x>, Port=<%x>\n",
                    status, pSend, IpAddress, Port));

            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        pSend->FECOptions = pAddress->FECOptions;
        pSend->FECProActivePackets = pAddress->FECProActivePackets;
        pSend->pSender->SpmOptions |= PGM_OPTION_FLAG_PARITY_PRM;
        pSend->pSender->LastVariableTGPacketSequenceNumber = -1;

        ASSERT (!(pSend->FECProActivePackets || pSend->FECProActivePackets) ||
                 ((pSend->FECGroupSize && pSend->FECBlockSize) &&
                  (pSend->FECGroupSize < pSend->FECBlockSize)));

        //
        // Now determine the MaxPayloadsize and buffer size
        // We will also need to adjust the buffer size to avoid alignment issues
        //
        Length = sizeof (tPACKET_OPTIONS) + pAddress->OutIfMTU + sizeof (tPOST_PACKET_FEC_CONTEXT);
        pSend->pSender->PacketBufferSize = (Length + sizeof (PVOID) - 1) & ~(sizeof (PVOID) - 1);
        pSend->pSender->MaxPayloadSize = pAddress->OutIfMTU - (PGM_MAX_FEC_DATA_HEADER_LENGTH + sizeof (USHORT));
    }
    else
    {
        Length = sizeof (tPACKET_OPTIONS) + pAddress->OutIfMTU;
        pSend->pSender->PacketBufferSize = (Length + sizeof (PVOID) - 1) & ~(sizeof (PVOID) - 1);
        pSend->pSender->MaxPayloadSize = pAddress->OutIfMTU - PGM_MAX_DATA_HEADER_LENGTH;
    }
    ASSERT (pSend->pSender->MaxPayloadSize);

    //
    // Set the Global Src Port + Global Src Id
    //
    // We don't want the local port and remote port to be the same
    // (especially for handling TSI settings on loopback case),
    // so pick a different port
    //
    pSend->TSI.hPort = PgmDynamicConfig.SourcePort++;
    if (pSend->TSI.hPort == pAddress->SenderMCastPort)
    {
        pSend->TSI.hPort = PgmDynamicConfig.SourcePort++;
    }

    //
    // Now, initialize the Sender info
    //
    InitializeListHead (&pSend->pSender->PendingSends);
    InitializeListHead (&pSend->pSender->PendingPacketizedSends);
    InitializeListHead (&pSend->pSender->CompletedSendsInWindow);

    MCastTtl = pAddress->MCastPacketTtl;
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    KeInitializeEvent (&pSend->pSender->SendEvent, SynchronizationEvent, FALSE);

    //
    // Now, set the MCast TTL
    //
    status = PgmSetTcpInfo (pAddress->FileHandle,
                            AO_OPTION_MCASTTTL,
                            &MCastTtl,
                            sizeof (ULONG));
    if (NT_SUCCESS (status))
    {
        //
        // Set the MCast TTL for the RouterAlert handle also
        //
        status = PgmSetTcpInfo (pAddress->RAlertFileHandle,
                                AO_OPTION_MCASTTTL,
                                &MCastTtl,
                                sizeof (ULONG));
    }

    if (NT_SUCCESS (status))
    {
        status = PgmCreateDataFileAndMapSection (pAddress, pSend);
        if (!NT_SUCCESS (status))
        {
            PgmTrace (LogError, ("PgmConnect: ERROR -- "  \
                "PgmCreateDataFileAndMapSection returned <%x>, pSend=<%p>, Dest IpAddress=<%x>, Port=<%x>\n",
                    status, pSend, IpAddress, Port));
        }
    }
    else
    {
        PgmTrace (LogError, ("PgmConnect: ERROR -- "  \
            "AO_OPTION_MCASTTTL returned <%x>\n", status));
    }

    if (!NT_SUCCESS (status))
    {
        if (pAddress->FECOptions)
        {
            DestroyFECContext (&pSend->FECContext);
            ASSERT (pSend->pSender->pProActiveParityContext);
            PgmFreeMem (pSend->pSender->pProActiveParityContext);
            pSend->pSender->pProActiveParityContext = NULL;
        }

        PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_CONNECT);
        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_CONNECT);

        return (status);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    //
    // Set the appropriate data parameters for the timeout routine
    // If the Send rate is quite high, we may need to send more than
    // 1 packet per timeout, but typically it should be low enough to
    // require several timeouts
    // Rate of Kb/Sec == Rate of Bytes/MilliSecs
    //
    ASSERT (pAddr