------------------
// Returns the text for an item in the autocomplete list
//--------------------------------------------------------------------------
BOOL CAutoComplete::_GetItem
(
    int iIndex,         // zero-based index
    LPWSTR pszText,     // location to return text
    int cchMax,         // size of pszText buffer
    BOOL fDisplayName   // TRUE = return name to display
                        // FALSE = return name to go to edit box
)
{
    // Check for special "Search for <typed in>" entry at end of the list
    if (m_fSearchFor && iIndex == m_iLastMatch - m_iFirstMatch)
    {
        ASSERT(NULL != m_pszCurrent);

        WCHAR szFormat[MAX_PATH];
        int id = fDisplayName ? IDS_SEARCHFOR : IDS_SEARCHFORCMD;

        MLLoadString(id, szFormat, ARRAYSIZE(szFormat));
        StringCchPrintf(pszText, cchMax, szFormat, m_pszCurrent);
    }

    // Normal list entry
    else
    {
        CACString* pStr;

        // If we're using Sorting indicies, then we are retrieving our entries
        // out of m_hdpaPrefix sort, which contains only matched entries
        if (m_hdpaSortIndex)
        {
            pStr = (CACString *)DPA_GetPtr(m_hdpaSortIndex, iIndex);
        }
        else
        {
            pStr = (CACString *)DPA_GetPtr(m_hdpa, iIndex + m_iFirstMatch);
        }

        if (pStr)
        {
            StringCchCopy(pszText, cchMax, pStr->GetStr());
        }
        else if (cchMax >= 1)
        {
            pszText[0] = 0;
        }
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
// Frees an item in our autocomplete list
//--------------------------------------------------------------------------
int CAutoComplete::_DPADestroyCallback(LPVOID p, LPVOID d)
{
    ((CACString*)p)->Release();
    return 1;
}

//+-------------------------------------------------------------------------
// Frees our last completion list
//--------------------------------------------------------------------------
void CAutoComplete::_FreeDPAPtrs(HDPA hdpa)
{
    TraceMsg(AC_GENERAL, "CAutoComplete::_FreeDPAPtrs(hdpa = 0x%x)", hdpa);

    if (hdpa)
    {
        DPA_DestroyCallback(hdpa, _DPADestroyCallback, 0);
        hdpa = NULL;
    }
}

//+-------------------------------------------------------------------------
// DPA callback used to order the matches by the sort index
//--------------------------------------------------------------------------
int CALLBACK CAutoComplete::_DPACompareSortIndex(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    CACString* ps1 = (CACString*)p1;
    CACString* ps2 = (CACString*)p2;

    return ps1->CompareSortingIndex(*ps2);
}

//+-------------------------------------------------------------------------
// Updates the matching completion
//--------------------------------------------------------------------------
void CAutoComplete::_UpdateCompletion
(
    LPCWSTR pszTyped,   // typed in string to match
    int iChanged,       // char added since last update or -1
    BOOL fAppend        // ok to append completion
)
{
    int iFirstMatch = -1;
    int iLastMatch = -1;
    int nChars = lstrlen(pszTyped);

    // Was it a wildcard search?
    BOOL fWildCard = pszTyped && (pszTyped[0] == CH_WILDCARD) && (pszTyped[1] == L'\0');
    if (fWildCard && DPA_GetPtrCount(m_hdpa))
    {
        // Everything matches
        iFirstMatch = 0;
        iLastMatch = DPA_GetPtrCount(m_hdpa) - 1;
    }
    else
    {
        // PERF: Special case where current == search string
    /*
        //
        // Find the first matching index
        //
        if (iChanged > 0)
        {
            // PERF: Get UC and LC versions of WC for compare below?
            WCHAR wc = pszTyped[iChanged];

            // A character was added so search from current location
            for (int i = m_iFirstMatch; i < DPA_GetPtrCount(m_hdpa); ++i)
            {
                CACString* pStr;

                pStr = (CACString*)DPA_GetPtr(m_hdpa, i);
                ASSERT(pStr);
                if (pStr && pStr->GetLength() >= iChanged && ChrCmpI((*pStr)[iChanged], wc) == 0)
                {
                    // This is the first match
                    iFirstMatch = i;
                    break;
                }
            }
        }
        else
    */
        {
            // We have to search the whole list
            // PERF: Switch to a binary search.
            for (int i = 0; i < DPA_GetPtrCount(m_hdpa); ++i)
            {
                CACString* pStr;

                pStr = (CACString*)DPA_GetPtr(m_hdpa, i);
                ASSERT(pStr);
                if (pStr &&
                    (pStr->StrCmpNI(pszTyped, nChars) == 0))
                {
                    iFirstMatch = i;
                    break;
                }
            }
        }

        if (-1 != iFirstMatch)
        {
            //
            // Find the last match
            //
            // PERF: Should we binary search up to the last end of list?
            for (iLastMatch = iFirstMatch; iLastMatch + 1 < DPA_GetPtrCount(m_hdpa); ++iLastMatch)
            {
                CACString* pStr;

                pStr = (CACString*)DPA_GetPtr(m_hdpa, iLastMatch + 1);
                ASSERT(pStr);
                if (NULL == pStr || (pStr->StrCmpNI(pszTyped, nChars) != 0))
                {
                    break;
                }
            }
        }
    }

    //
    // See if we should add "Search for <stuff typed in>" to the end of
    // the list.
    //
    int iSearchFor = 0;
    int nScheme;

    if (m_fSearchForAdded &&

        // Not a drive letter
        (*pszTyped && pszTyped[1] != L':') &&

        // Not a UNC path
        (pszTyped[0] != L'\\' && pszTyped[1] != L'\\') &&

        // Not a known scheme
        ((nScheme = GetUrlScheme(pszTyped)) == URL_SCHEME_UNKNOWN ||
        nScheme == URL_SCHEME_INVALID) &&

        // Ignore anything theat begins with "www"
        !(pszTyped[0] == L'w' && pszTyped[1] == L'w' && pszTyped[2] == L'w')

        // Not a search keyword
//        !Is
        )
    {
        // Add "Search for <stuff typed in>"
        iSearchFor = 1;
    }
    m_fSearchFor = iSearchFor;

    m_iLastMatch = iLastMatch + iSearchFor;
    m_iFirstMatch = iFirstMatch;
    if (iSearchFor && iFirstMatch == -1)
    {
        // There is one entry - the special "search for <>" entry
        m_iFirstMatch = 0;
    }

    // Sort the matches using the sort index
    if (m_hdpaSortIndex && iFirstMatch != -1)
    {
        // First put the matches in this sorted dpa
        DPA_GetPtrCount(m_hdpaSortIndex) = 0;
        for (int i=0; i <= m_iLastMatch-m_iFirstMatch; i++)
        {
            CACString *pStr = (CACString *)DPA_GetPtr(m_hdpa, m_iFirstMatch+i);
            DPA_InsertPtr(m_hdpaSortIndex, i, (LPVOID)pStr);
        }

        // Now order it by sort index (rather than alphabetically)
        DPA_Sort(m_hdpaSortIndex, _DPACompareSortIndex, 0);
    }

    if (_IsAutoSuggestEnabled())
    {
        // Update our drop-down list
        if ((m_iFirstMatch == -1) ||                // Hide if there are no matches
            ((m_iLastMatch == m_iFirstMatch) &&     // Or if only one match which we've already typed (IForms)
                (((CACString*)DPA_GetPtr(m_hdpa, m_iFirstMatch))->StrCmpI(pszTyped) == 0)))
        {
            _HideDropDown();
        }
        else
        {
            if (m_hwndList)
            {
                int cItems = m_iLastMatch - m_iFirstMatch + 1;
                ListView_SetItemCountEx(m_hwndList, cItems, 0);
            }

            _ShowDropDown();
            _UpdateScrollbar();
        }
    }

    if (_IsAutoAppendEnabled() && fAppend && m_iFirstMatch != -1 && !fWildCard)
    {
        // If caret is not at the end of the string, don't append
        DWORD dwSel = Edit_GetSel(m_hwndEdit);
        int iStartSel = LOWORD(dwSel);
        int iEndSel = HIWORD(dwSel);
        int iLen = lstrlen(pszTyped);
        if (iStartSel == iStartSel && iStartSel != iLen)
        {
            return;
        }

        // FEATURE: Should use the shortest match
        m_iAppended = -1;
        _AppendNext(TRUE);
    }
}

//+-------------------------------------------------------------------------
// Appends the next completion to the current edit text.  Returns TRUE if
// successful.
//--------------------------------------------------------------------------
BOOL CAutoComplete::_AppendNext
(
    BOOL fAppendToWhack  // Apend to next whack (false = append entire match)
)
{
    // Nothing to complete?
    if (NULL == m_hdpa || 0 == DPA_GetPtrCount(m_hdpa) ||
        m_iFirstMatch == -1 || !_WantToAppendResults())
        return FALSE;

    //
    // If nothing currently appended, init to the
    // last item so that we will wrap around to the
    // first item
    //
    if (m_iAppended == -1)
    {
        m_iAppended = m_iLastMatch;
    }

    int iAppend = m_iAppended;
    CACString* pStr;

    //
    // Loop through the items until we find one without a prefix
    //
    do
    {
        if (++iAppend > m_iLastMatch)
        {
            iAppend = m_iFirstMatch;
        }
        pStr = (CACString*)DPA_GetPtr(m_hdpa, iAppend);
        if (pStr &&

            // Don't append if match has as www. prefix
            (pStr->PrefixLength() < 4 || StrCmpNI(pStr->GetStr() + pStr->PrefixLength() - 4, L"www.", 4) != 0) &&

            // Ignore the "Search for" if present
            !(m_fSearchFor && iAppend == m_iLastMatch))
        {
            // We found one so append it
            _Append(*pStr, fAppendToWhack);
            m_iAppended = iAppend;
        }
    }
    while (iAppend != m_iAppended);
    return TRUE;
}

//+-------------------------------------------------------------------------
// Appends the previous completion to the current edit text.  Returns TRUE
// if successful.
//--------------------------------------------------------------------------
BOOL CAutoComplete::_AppendPrevious
(
    BOOL fAppendToWhack  // Append to next whack (false = append entire match)
)
{
    // Nothing to complete?
    if (NULL == m_hdpa || 0 == DPA_GetPtrCount(m_hdpa) ||
        m_iFirstMatch == -1 || !_WantToAppendResults())
        return FALSE;

    //
    // If nothing currently appended, init to the
    // first item so that we will wrap around to the
    // last item
    //
    if (m_iAppended == -1)
    {
        m_iAppended = m_iFirstMatch;
    }

    int iAppend = m_iAppended;
    CACString* pStr;

    //
    // Loop through the items until we find one without a prefix
    //
    do
    {
        if (--iAppend < m_iFirstMatch)
        {
            iAppend = m_iLastMatch;
        }
        pStr = (CACString*)DPA_GetPtr(m_hdpa, iAppend);
        if (pStr &&

            // Don't append if match has as www. prefix
            (pStr->PrefixLength() < 4 || StrCmpNI(pStr->GetStr() + pStr->PrefixLength() - 4, L"www.", 4) != 0) &&

            // Ignore the "Search for" if present
            !(m_fSearchFor && iAppend == m_iLastMatch))
        {
            // We found one so append it
            _Append(*pStr, fAppendToWhack);
            m_iAppended = iAppend;
        }
    }
    while (iAppend != m_iAppended);

    return TRUE;
}

//+-------------------------------------------------------------------------
// Appends the completion to the current edit text
//--------------------------------------------------------------------------
void CAutoComplete::_Append
(
    CACString& rStr,    // item to append to the editbox text
    BOOL fAppendToWhack  // Apend to next whack (false = append entire match)
)
{
    ASSERT(_IsAutoAppendEnabled());

    if (m_pszCurrent)
    {
        int cchCurrent = lstrlen(m_pszCurrent);
        LPCWSTR pszAppend = rStr.GetStrToCompare() + cchCurrent;
        int cchAppend;

        if (fAppendToWhack)
        {
            //
            // Advance to the whacks.
            //
            const WCHAR *pch = pszAppend;
            cchAppend = 0;

            while (*pch && !_IsWhack(*pch))
            {
                ++cchAppend;
                pch++;
            }

            //
            // Advance past the whacks.
            //
            while (*pch && _IsWhack(*pch))
            {
                ++cchAppend;
                pch++;
            }
        }
        else
        {
            // Append entire match
            cchAppend = lstrlen(pszAppend);
        }

        WCHAR szAppend[MAX_URL_STRING];
        StringCchCopy(szAppend,  cchAppend + 1, pszAppend);
        _UpdateText(cchCurrent, cchCurrent + cchAppend, m_pszCurrent, szAppend);

        m_fAppended = TRUE;
    }
}

//+-------------------------------------------------------------------------
// Hides the AutoSuggest dropdown
//--------------------------------------------------------------------------
void CAutoComplete::_HideDropDown()
{
    if (m_hwndDropDown)
    {
        ShowWindow(m_hwndDropDown, SW_HIDE);
    }
}

//+-------------------------------------------------------------------------
// Shows and positions the autocomplete dropdown
//--------------------------------------------------------------------------
void CAutoComplete::_ShowDropDown()
{
    if (m_hwndDropDown && !_IsComboboxDropped() && !m_fImeCandidateOpen)
    {
        // If the edit window is visible, it better have focus!
        // (Intelliforms uses an invisible window that doesn't
        // get focus.)
        if (IsWindowVisible(m_hwndEdit) && m_hwndEdit != GetFocus())
        {
            ShowWindow(m_hwndDropDown, SW_HIDE);
            return;
        }

        if (!IsWindowVisible(m_hwndDropDown))
        {
            // It should not be possible to open a new dropdown while
            // another dropdown is visible!  But to be safe we'll check ...
            if (s_hwndDropDown)
            {
                ASSERT(FALSE);
                ShowWindow(s_hwndDropDown, SW_HIDE);
            }

            s_hwndDropDown = m_hwndDropDown;

            //
            // Install a thread hook so that we can detect when something
            // happens that should hide the dropdown.
            //
            ENTERCRITICAL;
            if (s_hhookMouse)
            {
                // Should never happen because the hook is removed when the dropdown
                // is hidden.  But we can't afford to orphan a hook so we check just
                // in case!
                ASSERT(FALSE);
                UnhookWindowsHookEx(s_hhookMouse);
            }
            s_hhookMouse = SetWindowsHookEx(WH_MOUSE, s_MouseHook, HINST_THISDLL, NULL);
            LEAVECRITICAL;

            //
            // Subclass the parent windows so that we can detect when something
            // happens that should hide the dropdown
            //
            _SubClassParent(m_hwndEdit);
        }

        _PositionDropDown();
    }
}

//+-------------------------------------------------------------------------
// Positions dropdown based on edit window position
//--------------------------------------------------------------------------
void CAutoComplete::_PositionDropDown()
{
    RECT rcEdit;
    GetWindowRect(m_hwndEdit, &rcEdit);
    int x = rcEdit.left;
    int y = rcEdit.bottom;

    // Don't resize if user already has
    if (!m_fDropDownResized)
    {
        m_nDropHeight = 100;
        MINMAXINFO mmi = {0};
        SendMessage(m_hwndDropDown, WM_GETMINMAXINFO, 0, (LPARAM)&mmi);
        m_nDropWidth = max(RECTWIDTH(rcEdit), mmi.ptMinTrackSize.x);

        // Calculate dropdown height based on number of string matches
        if (m_hdpa)
        {
/*
            int iDropDownHeight =
                    m_nStatusHeight +
                    ListView_GetItemSpacing(m_hwndList, FALSE) * DPA_GetPtrCount(m_hdpa);
*/

            int iDropDownHeight =
                    m_nStatusHeight - GetSystemMetrics(SM_CYBORDER) +
                    HIWORD(ListView_ApproximateViewRect(m_hwndList, -1, -1, -1));

            if (m_nDropHeight > iDropDownHeight)
            {
                m_nDropHeight = iDropDownHeight;
            }
        }
    }

    int w = m_nDropWidth;
    int h = m_nDropHeight;

    BOOL fDroppedUp = FALSE;

    //
    // Make sure we don't go off the screen
    //
    HMONITOR hMonitor = MonitorFromWindow(m_hwndEdit, MONITOR_DEFAULTTONEAREST);
    if (hMonitor)
    {
        MONITORINFO mi;
        mi.cbSize = sizeof(mi);
        if (GetMonitorInfo(hMonitor, &mi))
        {
            RECT rcMon = mi.rcMonitor;
            int cxMax = rcMon.right - rcMon.left;
            if (w > cxMax)
            {
                w = cxMax;
            }

/*
            if (x < rcMon.left)
            {
                // Off the left edge, so move right
                x += rcMon.left - x;
            }
            else if (x + w > rcMon.right)
            {
                // Off the right edge, so move left
                x -= (x + w - rcMon.right);
            }
*/
            int cyMax = (RECTHEIGHT(rcMon) - RECTHEIGHT(rcEdit));
            if (h > cyMax)
            {
                h = cyMax;
            }

            if (y + h > rcMon.bottom

#ifdef ALLOW_ALWAYS_DROP_UP
                || m_fAlwaysDropUp
#endif

                )
            {
                // Off the bottom of the screen, so see if there is more
                // room in the up direction
                if (rcEdit.top > rcMon.bottom - rcEdit.bottom)
                {
                    // There's more room to pop up
                    y = max(rcEdit.top - h, 0);
                    h = rcEdit.top - y;
                    fDroppedUp = TRUE;
                }
                else
                {
                    // Don't let it go past the bottom
                    h = rcMon.bottom - y;
                }
            }
        }
    }

    BOOL fFlipped = BOOLIFY(m_fDroppedUp) ^ BOOLIFY(fDroppedUp);
    m_fDroppedUp = fDroppedUp;

    SetWindowPos(m_hwndDropDown, HWND_TOP, x, y, w, h, SWP_SHOWWINDOW | SWP_NOACTIVATE);

    if (fFlipped)
    {
        _UpdateGrip();
    }
}

//+-------------------------------------------------------------------------
// Window procedure for the subclassed edit box
//--------------------------------------------------------------------------
LRESULT CAutoComplete::_EditWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_SETTEXT:
        //
        // If the text is changed programmatically, we hide the dropdown.
        // This fixed a bug in the dialog at:
        //
        // Internet Options\security\Local Intranet\Sites\Advanced
        //
        //   - If you select something in the dropdown the press enter,
        //     the enter key is intercepeted by the dialog which clears
        //     the edit field, but the drop-down is not hidden.
        //
        if (!m_fSettingText)
        {
            _HideDropDown();
        }
        break;

    case WM_GETDLGCODE:
        {
            //
            // If the auto-suggest drop-down if up, we process
            // the tab key.
            //
            BOOL fDropDownVisible = m_hwndDropDown && IsWindowVisible(m_hwndDropDown);

            if (wParam == VK_TAB && IsFlagSet(m_dwOptions, ACO_USETAB))
            {
                if ((GetKeyState(VK_CONTROL) < 0) ||
                    !fDropDownVisible)
                {
                    break;
                }

                // We want the tab key
                return DLGC_WANTTAB;
            }
            else if (wParam == VK_ESCAPE && fDropDownVisible)
            {
                // eat escape so that dialog boxes (e.g. File Open) are not closed
                return DLGC_WANTALLKEYS;
            }
            break;
        }

    case WM_KEYDOWN:
        if (wParam == VK_TAB)
        {
            BOOL fDropDownVisible = m_hwndDropDown && IsWindowVisible(m_hwndDropDown);
            if (fDropDownVisible &&
                GetKeyState(VK_CONTROL) >= 0)
            {
                // Map tab to down-arrow and shift-tab to up-arrow
                wParam = (GetKeyState(VK_SHIFT) >= 0) ? VK_DOWN : VK_UP;
            }
            else
            {
                return 0;
            }
        }

        // Ensure the background thread knows we have focus
        _GotFocus();

//            ASSERT(m_hThread || m_pThread->IsDisabled());  // If this occurs then we didn't process a WM_SETFOCUS when we should have.  BryanSt.
        if (_OnKeyDown(wParam) == 0)
        {
            //
            // We handled it.
            //
            return 0;
        }

        if (wParam == VK_DELETE)
        {
            LRESULT lRes = DefSubclassProc(m_hwndEdit, uMsg, wParam, lParam);
            _StartCompletion(FALSE);
            return lRes;
        }
        break;

    case WM_CHAR:
        return _OnChar(wParam, lParam);

    case WM_CUT:
    case WM_PASTE:
    case WM_CLEAR:
    {
        LRESULT lRet = DefSubclassProc(m_hwndEdit, uMsg, wParam, lParam);

        // See if we need to update the completion
        if (!m_pThread->IsDisabled())
        {
            _GotFocus();
            _StartCompletion(TRUE);
        }
        return lRet;
    }
    case WM_SETFOCUS:
        m_pThread->GotFocus();
        break;

    case WM_KILLFOCUS:
        {
            HWND hwndGetFocus = (HWND)wParam;

            // Ignore focus change to ourselves
            if (m_hwndEdit != hwndGetFocus)
            {
                if (m_hwndDropDown && GetFocus() != m_hwndDropDown)
                {
                    _HideDropDown();
                }
                m_pThread->LostFocus();
            }
            break;
        }
    case WM_DESTROY:
        {
            HWND hwndEdit = m_hwndEdit;
            TraceMsg(AC_GENERAL, "CAutoComplete::_WndProc(WM_DESTROY) releasing subclass.");

            RemoveWindowSubclass(hwndEdit, s_EditWndProc, 0);

            if (m_hwndDropDown)
            {
                //
                // If the dropdown and its associated listview are fully created, we can simply
                // destroy them.
                //
                if (m_hwndList)
                {
                    DestroyWindow(m_hwndDropDown);
                }

                //
                // We are likely in the middle of creating the listview and destroy the dropdown now
                // can result in a crash (another thread probably destroyed the edit window).  So we
                // post a message to get the dropdown to destroy itself.  The background thread will
                // hold this dll in memory until the dropdown is gone.
                //
                else
                {
                    // Don't call DestroyWindow. See AM_DESTROY comment in dropdown's wndproc.
                    _GotFocus();
                    if (m_pThread->HasFocus())
                    {
                        PostMessage(m_hwndDropDown, AM_DESTROY, 0, 0);
                    }
                    else
                    {
                        // If the background thread is not running, we can't rely on it to
                        // keep us in memory during shutdown, so synchronously destroy the
                        // window and cross your fingers.
                        DestroyWindow(m_hwndDropDown);
                    }
                }
            }

            m_pThread->SyncShutDownBGThread();
            SAFERELEASE(m_pThread);
            Release();      // Release subclass Ref.

            // Pass it onto the old wndproc.
            return DefSubclassProc(hwndEdit, uMsg, wParam, lParam);
        }
        break;
    case WM_MOVE:
        {
            if (m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
            {
                // Follow edit window, for example when intelliforms window scrolls w/intellimouse
                _PositionDropDown();
            }
        }
        break;

/*
    case WM_COMMAND:
        if (m_pThread->IsDisabled())
        {
            break;
        }
        return _OnCommand(wParam, lParam);
*/
/*
    case WM_CONTEXTMENU:
        if (m_pThread->IsDisabled())
        {
            break;
        }
        return _ContextMenu(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
*/

    case WM_LBUTTONDBLCLK:
    {
        //
        // Bypass our word break routine.  We only register this callback on NT because it
        // doesn't work right on win9x.
        //
        if (m_fEditControlUnicode)
        {
            //
            // We break words at url delimiters for ctrl-left & ctrl-right, but
            // we want double-click to use standard word selection so that it is easy
            // to select the URL.
            //
            SendMessage(m_hwndEdit, EM_SETWORDBREAKPROC, 0, (DWORD_PTR)m_oldEditWordBreakProc);

            LRESULT lres = DefSubclassProc(m_hwndEdit, uMsg, wParam, lParam);

            // Restore our word-break callback
            SendMessage(m_hwndEdit, EM_SETWORDBREAKPROC, 0, (DWORD_PTR)EditWordBreakProcW);
            return lres;
        }
        break;
    }

    case WM_SETFONT:
    {
        // If we have a dropdown, recreate it with the latest font
        m_hfontListView = (HFONT)wParam;
        if (m_hwndDropDown)
        {
            _StopSearch();
            DestroyWindow(m_hwndDropDown);
            m_hwndDropDown = NULL;
            _SeeWhatsEnabled();
        }
        break;
    }
    case WM_IME_NOTIFY:
        {
            // We don't want autocomplete to obsure the IME candidate window
            DWORD dwCommand = (DWORD)wParam;
            if (dwCommand == IMN_OPENCANDIDATE)
            {
                m_fImeCandidateOpen = TRUE;
                _HideDropDown();
            }
            else if (dwCommand == IMN_CLOSECANDIDATE)
            {
                m_fImeCandidateOpen = FALSE;
            }
        }
        break;
    default:
        // Handle registered messages
        if (uMsg == m_uMsgSearchComplete)
        {
            _OnSearchComplete((HDPA)lParam, (BOOL)wParam);
            return 0;
        }

        // Pass mouse wheel messages to the drop-down if it is visible
        else if ((uMsg == WM_MOUSEWHEEL || uMsg == g_msgMSWheel) &&
            m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
        {
            SendMessage(m_hwndList, uMsg, wParam, lParam);
            return 0;
        }
        break;
    }


    return DefSubclassProc(m_hwndEdit, uMsg, wParam, lParam);
}

//+-------------------------------------------------------------------------
// Static window procedure for the subclassed edit box
//--------------------------------------------------------------------------
LRESULT CALLBACK CAutoComplete::s_EditWndProc
(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    UINT_PTR uIdSubclass,   // always zero for us
    DWORD_PTR dwRefData     // -> CAutoComplete
)
{
    CAutoComplete* pac = (CAutoComplete*)dwRefData;
    if (pac)
    {
        ASSERT(pac->m_hwndEdit == hwnd);
        return pac->_EditWndProc(uMsg, wParam, lParam);
    }
    else
    {
        TraceMsg(TF_WARNING, "CAutoComplete::s_EditWndProc() --- pac == NULL");
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }
}

//+-------------------------------------------------------------------------
// Draws the sizing grip. We do this ourselves rather than call
// DrawFrameControl because the standard API does not flip upside down on
// all platforms.  (NT and win98 seem to use a font and thus ignore the map
// mode)
//--------------------------------------------------------------------------
BOOL DrawGrip(register HDC hdc, LPRECT lprc, BOOL fEraseBackground)
{
    int x, y;
    int xMax, yMax;
    int dMin;
    HBRUSH hbrOld;
    HPEN hpen, hpenOld;
    DWORD rgbHilight, rgbShadow;

    //
    // The grip is really a pattern of 4 repeating diagonal lines:
    //      One glare
    //      Two raised
    //      One empty
    // These lines run from bottom left to top right, in the bottom right
    // corner of the square given by (lprc->left, lprc->top, dMin by dMin.
    //
    dMin = min(lprc->right-lprc->left, lprc->bottom-lprc->top);
    xMax = lprc->left + dMin;
    yMax = lprc->top + dMin;

    //
    // Setup colors
    //
    hbrOld      = GetSysColorBrush(COLOR_3DFACE);
    rgbHilight  = GetSysColor(COLOR_3DHILIGHT);
    rgbShadow   = GetSysColor(COLOR_3DSHADOW);

    //
    // Fill in background of ENTIRE rect
    //
    if (fEraseBackground)
    {
        hbrOld = SelectBrush(hdc, hbrOld);
        PatBlt(hdc, lprc->left, lprc->top, lprc->right-lprc->left,
                lprc->bottom-lprc->top, PATCOPY);
        SelectBrush(hdc, hbrOld);
    }
    else
    {
/*
        hpen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOW));
        if (hpen == NULL)
            return FALSE;
        hpenOld = SelectPen(hdc, hpen);

        x = lprc->left - 1;
        y = lprc->top - 1;
        MoveToEx(hdc, x, yMax, NULL);
        LineTo(hdc, xMax, y);

        SelectPen(hdc, hpenOld);
        DeletePen(hpen);
*/

        //
        // Draw background color directly under grip:
        //
        hpen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DFACE));
        if (hpen == NULL)
            return FALSE;
        hpenOld = SelectPen(hdc, hpen);

        x = lprc->left + 3;
        y = lprc->top + 3;
        while (x < xMax)
        {
            //
            // Since dMin is the same horz and vert, x < xMax and y < yMax
            // are interchangeable...
            //
            MoveToEx(hdc, x, yMax, NULL);
            LineTo(hdc, xMax, y);

            // Skip 3 lines in between
            x += 4;
            y += 4;
        }

        SelectPen(hdc, hpenOld);
        DeletePen(hpen);
    }

    //
    // Draw glare with COLOR_3DHILIGHT:
    //      Create proper pen
    //      Select into hdc
    //      Starting at lprc->left, draw a diagonal line then skip the
    //          next 3
    //      Select out of hdc
    //
    hpen = CreatePen(PS_SOLID, 1, rgbHilight);
    if (hpen == NULL)
        return FALSE;
    hpenOld = SelectPen(hdc, hpen);

    x = lprc->left;
    y = lprc->top;
    while (x < xMax)
    {
        //
        // Since dMin is the same horz and vert, x < xMax and y < yMax
        // are interchangeable...
        //

        MoveToEx(hdc, x, yMax, NULL);
        LineTo(hdc, xMax, y);

        // Skip 3 lines in between
        x += 4;
        y += 4;
    }

    SelectPen(hdc, hpenOld);
    DeletePen(hpen);

    //
    // Draw raised part with COLOR_3DSHADOW:
    //      Create proper pen
    //      Select into hdc
    //      Starting at lprc->left+1, draw 2 diagonal lines, then skip
    //          the next 2
    //      Select outof hdc
    //
    hpen = CreatePen(PS_SOLID, 1, rgbShadow);
    if (hpen == NULL)
        return FALSE;
    hpenOld = SelectPen(hdc, hpen);

    x = lprc->left+1;
    y = lprc->top+1;
    while (x < xMax)
    {
        //
        // Draw two diagonal lines touching each other.
        //

        MoveToEx(hdc, x, yMax, NULL);
        LineTo(hdc, xMax, y);

        x++;
        y++;

        MoveToEx(hdc, x, yMax, NULL);
        LineTo(hdc, xMax, y);

        //
        // Skip 2 lines inbetween
        //
        x += 3;
        y += 3;
    }

    SelectPen(hdc, hpenOld);
    DeletePen(hpen);

    return TRUE;
}

//+-------------------------------------------------------------------------
// Update the visible characteristics of the gripper depending on whether
// the dropdown is "dropped up" or the scrollbar is visible
//--------------------------------------------------------------------------
void CAutoComplete::_UpdateGrip()
{
    if (m_hwndGrip)
    {
        //
        // If we have a scrollbar the gripper has a rectangular shape.
        //
        if (m_hwndScroll && IsWindowVisible(m_hwndScroll))
        {
            SetWindowRgn(m_hwndGrip, NULL, FALSE);
        }
        //
        // Otherwise, give it  a trinagular window region
        //
        else
        {
            int nWidth = GetSystemMetrics(SM_CXVSCROLL);
            int nHeight = GetSystemMetrics(SM_CYHSCROLL);
            POINT rgpt[3] =
            {
                {nWidth, 0},
                {nWidth, nHeight},
                {0, nHeight},
            };

            //
            // If dropped up, convert the "bottom-Right" tringle into
            // a "top-right" triangle
            //
            if (m_fDroppedUp)
            {
                rgpt[2].y = 0;
            }

            HRGN hrgn = CreatePolygonRgn(rgpt, ARRAYSIZE(rgpt), WINDING);
            if (hrgn && !SetWindowRgn(m_hwndGrip, hrgn, TRUE))
                DeleteObject(hrgn);
        }
        InvalidateRect(m_hwndGrip, NULL, TRUE);
    }
}

//+-------------------------------------------------------------------------
// Transfer the listview scroll info into our scrollbar control
//--------------------------------------------------------------------------
void CAutoComplete::_UpdateScrollbar()
{
    if (m_hwndScroll)
    {
        SCROLLINFO si;
        si.cbSize = sizeof(si);
        si.fMask = SIF_ALL;
        BOOL fScrollVisible = IsWindowVisible(m_hwndScroll);

        if (GetScrollInfo(m_hwndList, SB_VERT, &si))
        {
            SetScrollInfo(m_hwndScroll, SB_CTL, &si, TRUE);
            UINT nRange = si.nMax - si.nMin;
            BOOL fShow = (nRange != 0) && (nRange != (UINT)(si.nPage - 1));
            ShowScrollBar(m_hwndScroll, SB_CTL, fShow);
            if (BOOLIFY(fScrollVisible) ^ BOOLIFY(fShow))
            {
                _UpdateGrip();
            }
        }
    }
}

//+-------------------------------------------------------------------------
// Window procedure for the AutoSuggest drop-down
//--------------------------------------------------------------------------
LRESULT CAutoComplete::_DropDownWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_NCCREATE:
        {
            //
            // Add a listview to the dropdown
            //
            m_hwndList = CreateWindowEx(0,
                                        WC_LISTVIEW,
                                        c_szAutoSuggestTitle,
                                        WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | LVS_REPORT | LVS_NOCOLUMNHEADER | LVS_SINGLESEL | LVS_OWNERDATA | LVS_OWNERDRAWFIXED,
                                        0, 0, 30000, 30000,
                                        m_hwndDropDown, NULL, HINST_THISDLL, NULL);

            if (m_hwndList)
            {
                SetWindowTheme(m_hwndList, L"AutoComplete", NULL);

                // Subclass the listview window
                if (SetProp(m_hwndList, c_szAutoCompleteProp, this))
                {
                    // point it to our wndproc and save the old one
                    m_pOldListViewWndProc = (WNDPROC)SetWindowLongPtr(m_hwndList, GWLP_WNDPROC, (LONG_PTR) &s_ListViewWndProc);
                }

                ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TRACKSELECT);

                LV_COLUMN lvColumn;
                lvColumn.mask = LVCF_FMT | LVCF_WIDTH;
                lvColumn.fmt = LVCFMT_LEFT;
                lvColumn.cx = LISTVIEW_COLUMN_WIDTH;
                ListView_InsertColumn(m_hwndList, 0, &lvColumn);

                // We'll get the default dimensions when we first show it
                m_nDropWidth = 0;
                m_nDropHeight = 0;

                // Add a scrollbar
                m_hwndScroll = CreateWindowEx(0, WC_SCROLLBAR, NULL,
                                WS_CHILD | SBS_VERT | SBS_RIGHTALIGN,
                                0, 0, 20, 100, m_hwndDropDown, 0, HINST_THISDLL, NULL);

                SetWindowTheme(m_hwndScroll, L"AutoComplete", NULL);

                // Add a sizebox
                m_hwndGrip = CreateWindowEx(0, WC_SCROLLBAR, NULL,
                                WS_CHILD | WS_VISIBLE | SBS_SIZEBOX | SBS_SIZEBOXBOTTOMRIGHTALIGN,
                                0, 0, 20, 100, m_hwndDropDown, 0, HINST_THISDLL, NULL);
                if (m_hwndGrip)
                {
                    SetWindowSubclass(m_hwndGrip, s_GripperWndProc, 0, (ULONG_PTR)this);
                    _UpdateGrip();

                    SetWindowTheme(m_hwndGrip, L"AutoComplete", NULL);
                }
            }
            return (m_hwndList != NULL);
        }
        case WM_DESTROY:
        {
            //
            // I'm paranoid - should happen when we're hidden
            //
            if (s_hwndDropDown != NULL && s_hwndDropDown == m_hwndDropDown)
            {
                // Should never happen, but we take extra care not to leak a window hook!
                ASSERT(FALSE);

                ENTERCRITICAL;
                if (s_hhookMouse)
                {
                    UnhookWindowsHookEx(s_hhookMouse);
                    s_hhookMouse = NULL;
                }
                LEAVECRITICAL;
                s_hwndDropDown = NULL;
            }
            _UnSubClassParent(m_hwndEdit);

            // Unsubclass this window
            SetWindowLongPtr(m_hwndDropDown, GWLP_USERDATA, (LONG_PTR)NULL);

            HWND hwnd = m_hwndDropDown;
            m_hwndDropDown = NULL;

            if (m_hwndList)
            {
                DestroyWindow(m_hwndList);
                m_hwndList = NULL;
            }
            if (m_hwndScroll)
            {
                DestroyWindow(m_hwndScroll);
                m_hwndScroll = NULL;
            }
            if (m_hwndGrip)
            {
                DestroyWindow(m_hwndGrip);
                m_hwndGrip = NULL;
            }

            // The dropdown incremented the autocomplete object's ref count.
            Release();
            return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
        }
        case WM_SYSCOLORCHANGE:
            SendMessage(m_hwndList, uMsg, wParam, lParam);
            break;

        case WM_WININICHANGE:
            SendMessage(m_hwndList, uMsg, wParam, lParam);
            if (wParam == SPI_SETNONCLIENTMETRICS)
            {
                _UpdateGrip();
            }
            break;

        case WM_GETMINMAXINFO:
        {
            //
            // Don't shrink smaller than the size of the gripper
            //
            LPMINMAXINFO pMmi = (LPMINMAXINFO)lParam;

            pMmi->ptMinTrackSize.x = GetSystemMetrics(SM_CXVSCROLL);
            pMmi->ptMinTrackSize.y = GetSystemMetrics(SM_CYHSCROLL);
            return 0;
        }
        case WM_MOVE:
        {
            //
            // Reposition the list view in case we switch between dropping-down
            // and dropping up.
            //
            RECT rc;
            GetClientRect(m_hwndDropDown, &rc);
            int nWidth = RECTWIDTH(rc);
            int nHeight = RECTHEIGHT(rc);

            int cxGrip = GetSystemMetrics(SM_CXVSCROLL);
            int cyGrip = GetSystemMetrics(SM_CYHSCROLL);

            if (m_fDroppedUp)
            {
                SetWindowPos(m_hwndGrip, HWND_TOP, nWidth - cxGrip, 0, cxGrip, cyGrip, SWP_NOACTIVATE);
                SetWindowPos(m_hwndScroll, HWND_TOP, nWidth - cxGrip, cyGrip, cxGrip, nHeight-cyGrip, SWP_NOACTIVATE);
            }
            else
            {
                SetWindowPos(m_hwndGrip, HWND_TOP, nWidth - cxGrip, nHeight - cyGrip, cxGrip, cyGrip, SWP_NOACTIVATE);
                SetWindowPos(m_hwndScroll, HWND_TOP, nWidth - cxGrip, 0, cxGrip, nHeight-cyGrip, SWP_NOACTIVATE);
            }
            break;
        }
        case WM_SIZE:
        {
            int nWidth  = LOWORD(lParam);
            int nHeight = HIWORD(lParam);

            int cxGrip = GetSystemMetrics(SM_CXVSCROLL);
            int cyGrip = GetSystemMetrics(SM_CYHSCROLL);

            if (m_fDroppedUp)
            {
                SetWindowPos(m_hwndGrip, HWND_TOP, nWidth - cxGrip, 0, cxGrip, cyGrip, SWP_NOACTIVATE);
                SetWindowPos(m_hwndScroll, HWND_TOP, nWidth - cxGrip, cyGrip, cxGrip, nHeight-cyGrip, SWP_NOACTIVATE);
            }
            else
            {
                SetWindowPos(m_hwndGrip, HWND_TOP, nWidth - cxGrip, nHeight - cyGrip, cxGrip, cyGrip, SWP_NOACTIVATE);
                SetWindowPos(m_hwndScroll, HWND_TOP, nWidth - cxGrip, 0, cxGrip, nHeight-cyGrip, SWP_NOACTIVATE);
            }

            // Save the new dimensions
            m_nDropWidth = nWidth + 2*GetSystemMetrics(SM_CXBORDER);
            m_nDropHeight = nHeight + 2*GetSystemMetrics(SM_CYBORDER);

            MoveWindow(m_hwndList, 0, 0, LISTVIEW_COLUMN_WIDTH + 10*cxGrip, nHeight, TRUE);
            _UpdateScrollbar();
            InvalidateRect(m_hwndList, NULL, FALSE);
            break;
        }

        case WM_NCHITTEST:
            {
                RECT rc;
                POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

                // If the in the grip, show the sizing cursor
                if (m_hwndGrip)
                {
                    GetWindowRect(m_hwndGrip, &rc);

                    if (PtInRect(&rc, pt))
                    {
                        if(IS_WINDOW_RTL_MIRRORED(m_hwndDropDown))
                        {
                            return (m_fDroppedUp) ? HTTOPLEFT : HTBOTTOMLEFT;
                        }
                        else
                        {
                            return (m_fDroppedUp) ? HTTOPRIGHT : HTBOTTOMRIGHT;
                        }
                    }
                }
            }
            break;

        case WM_SHOWWINDOW:
            {
                s_fNoActivate = FALSE;

                BOOL fShow = (BOOL)wParam;
                if (!fShow)
                {
                    //
                    // We are being hidden so we no longer need to
                    // subclass the parent windows.
                    //
                    _UnSubClassParent(m_hwndEdit);

                    //
                    // Remove the mouse hook.  We shouldn't need to protect this global with
                    // a critical section because another dropdown cannot be shown
                    // before we are hidden.  But we don't want to chance orphaning a hook
                    // so to be safe we protect write access to this variable.
                    //
                    ENTERCRITICAL;
                    if (s_hhookMouse)
                    {
                        UnhookWindowsHookEx(s_hhookMouse);
                        s_hhookMouse = NULL;
                    }
                    LEAVECRITICAL;

                    s_hwndDropDown = NULL;

                    // Deselect the current selection
                    int iCurSel = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                    if (iCurSel)
                    {
                        ListView_SetItemState(m_hwndList, iCurSel, 0, 0x000f);
                    }
                }
            }
            break;

        case WM_MOUSEACTIVATE:
            //
            // We don't want mouse clicks to activate us and
            // take focus from the edit box.
            //
            return (LRESULT)MA_NOACTIVATE;

        case WM_NCLBUTTONDOWN:
            //
            // We don't want resizing to activate us and deactivate the app.
            // The WM_MOUSEACTIVATE message above prevents mouse downs from
            // activating us, but mouse up after a resize still activates us.
            //
            if (wParam == HTBOTTOMRIGHT ||
                wParam == HTTOPRIGHT)
            {
                s_fNoActivate = TRUE;
            }
            break;

        case WM_VSCROLL:
        {
            ASSERT(m_hwndScroll);

            //
            // Pass the scroll messages from our control to the listview
            //
            WORD nScrollCode = LOWORD(wParam);
            if (nScrollCode == SB_THUMBTRACK || nScrollCode == SB_THUMBPOSITION)
            {
                //
                // The listview ignores the 16-bit position passed in and
                // queries the internal window scrollbar for the tracking
                // position.  Since this returns the wrong track position,
                // we have to handle thumb tracking ourselves.
                //
                WORD nPos = HIWORD(wParam);

                SCROLLINFO si;
                si.cbSize = sizeof(si);
                si.fMask = SIF_ALL;

                if (GetScrollInfo(m_hwndScroll, SB_CTL, &si))
                {
                    //
                    // The track position is always at the top of the list.
                    // So, if we are scrolling up, make sure that the track
                    // position is visible.  Otherwise we need to ensure
                    // that a full page is visible below the track positon.
                    //
                    int nEnsureVisible = si.nTrackPos;
                    if (si.nTrackPos > si.nPos)
                    {
                        nEnsureVisible += si.nPage - 1;
                    }
                    SendMessage(m_hwndList, LVM_ENSUREVISIBLE, nEnsureVisible, FALSE);
                }
            }
            else
            {
                // Let listview handle it
                SendMessage(m_hwndList, uMsg, wParam, lParam);
            }
            _UpdateScrollbar();
            return 0;
        }
        case WM_EXITSIZEMOVE:
            //
            // Resize operation is over so permit the app to lose acitvation
            //
            s_fNoActivate = FALSE;
            m_fDropDownResized = TRUE;
            return 0;

        case WM_DRAWITEM:
            _DropDownDrawItem((LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_NOTIFY:
            if (_DropDownNotify((LPNMHDR)lParam))
            {
                return TRUE;
            }
            break;

        case AM_UPDATESCROLLPOS:
        {
            if (m_hwndScroll)
            {
                int nTop = ListView_GetTopIndex(m_hwndList);
                SetScrollPos(m_hwndScroll, SB_CTL, nTop, TRUE);
            }
            return 0;
        }
        case AM_BUTTONCLICK:
        {
            //
            // This message is sent by the thread hook when a mouse click is detected outside
            // the drop-down window.  Unless the click occurred inside the combobox, we will
            // hide the dropdown.
            //
            MOUSEHOOKSTRUCT *pmhs = (MOUSEHOOKSTRUCT*)lParam;
            HWND hwnd = pmhs->hwnd;
            RECT rc;

            if (hwnd != m_hwndCombo && hwnd != m_hwndEdit &&

                // See if we clicked within the bounds of the editbox.  This is
                // necessary for intelliforms.
                // FEATURE: This assumes that the editbox is entirely visible!
                GetWindowRect(m_hwndEdit, &rc) && !PtInRect(&rc, pmhs->pt))
            {
                _HideDropDown();
            }
            return 0;
        }
        case AM_DESTROY:
        {
            //
            // We post this message to destroy the dropdown to avoid a strange crash
            // that happens if we call DestroyWindow when the edit window is destroyed.
            // The crash happens when a parent of the endit window is on another thread
            // and that parent is destroyed in the middle of us creating a listview
            // child of the dropdown.
            //
            DestroyWindow(m_hwndDropDown);
            return 0;
        }
    }

    return DefWindowProcWrap(m_hwndDropDown, uMsg, wParam, lParam);
}


void CAutoComplete::_DropDownDrawItem(LPDRAWITEMSTRUCT pdis)
{
    //
    // We need to draw the contents of the list view ourselves
    // so that we can show items in the selected state even
    // when the edit control has focus.
    //

    if (pdis->itemID != -1)
    {
        HDC hdc = pdis->hDC;
        RECT rc = pdis->rcItem;
        BOOL fTextHighlight = pdis->itemState & ODS_SELECTED;

        // Setup the dc before we use it.
        BOOL fRTLReading = GetWindowLong(pdis->hwndItem, GWL_EXSTYLE) & WS_EX_RTLREADING;
        UINT uiOldTextAlign;
        if (fRTLReading)
        {
            uiOldTextAlign = GetTextAlign(hdc);
            SetTextAlign(hdc, uiOldTextAlign | TA_RTLREADING);
        }

        if (m_hfontListView)
        {
            SelectObject(hdc, m_hfontListView);
        }
        SetBkColor(hdc, GetSysColor(fTextHighlight ?
                        COLOR_HIGHLIGHT : COLOR_WINDOW));
        SetTextColor(hdc, GetSysColor(fTextHighlight ?
                        COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));

        // Center the string vertically within rc
        SIZE sizeText;
        WCHAR szText[MAX_URL_STRING];
        _GetItem(pdis->itemID, szText, ARRAYSIZE(szText), TRUE);
        int cch = lstrlen(szText);
        GetTextExtentPoint(hdc, szText, cch, &sizeText);
        int yMid = (rc.top + rc.bottom) / 2;
        int yString = yMid - (sizeText.cy/2);
        int xString = 5;

        //
        // If this is a .url string, don't display the extension
        //
        if (cch > 4 && StrCmpNI(szText + cch - 4, L".url", 4) == 0)
        {
            cch -= 4;
        }

        ExtTextOut(hdc, xString, yString, ETO_OPAQUE | ETO_CLIPPED, &rc, szText, cch, NULL);

        // Restore the text align in the dc.
        if (fRTLReading)
        {
            SetTextAlign(hdc, uiOldTextAlign);
        }
    }
}

BOOL CAutoComplete::_DropDownNotify(LPNMHDR pnmhdr)
{
    WCHAR szBuf[MAX_URL_STRING];        // Just one instance of the buffer

    //
    // Respond to notification messages from the list view
    //
    switch (pnmhdr->code)
    {
        case LVN_GETDISPINFO:
        {
            //
            // Return the text for an autosuggest item
            //
            ASSERT(pnmhdr->hwndFrom == m_hwndList);
            LV_DISPINFO* pdi = (LV_DISPINFO*)pnmhdr;
            if (pdi->item.mask & LVIF_TEXT)
            {
                _GetItem(pdi->item.iItem, pdi->item.pszText, pdi->item.cchTextMax, TRUE);
            }
            break;
        }
        case LVN_GETDISPINFOA:
        {
            //
            // For win9x support (added for automated testing)
            //
            ASSERT(pnmhdr->hwndFrom == m_hwndList);
            LV_DISPINFOA* pdi = (LV_DISPINFOA*)pnmhdr;
            if (pdi->item.mask & LVIF_TEXT)
            {
                _GetItem(pdi->item.iItem, szBuf, ARRAYSIZE(szBuf), TRUE);
                SHUnicodeToAnsi(szBuf, pdi->item.pszText, pdi->item.cchTextMax);
            }
            break;
        }
        case LVN_ITEMCHANGED:
        {
            //
            // When an item is selected in the list view, we transfer it to the
            // edit control.  But only if the selection was not caused by the
            // mouse passing over an element (hot tracking).
            //
            if (!m_fInHotTracking)
            {
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW)pnmhdr;
                if ((pnmv->uChanged & LVIF_STATE) && (pnmv->uNewState & (LVIS_FOCUSED | LVIS_SELECTED)))
                {
                    _GetItem(pnmv->iItem, szBuf, ARRAYSIZE(szBuf), FALSE);

                    // Copy the selection to the edit box and place caret at the end
                    _SetEditText(szBuf);
                    int cch = lstrlen(szBuf);
                    Edit_SetSel(m_hwndEdit, cch, cch);
                }
            }

            //
            // Update the scrollbar.  Note that we have to post a message to do this
            // after returning from this function.  Otherwise we get old info
            // from the listview about the scroll positon.
            //
            PostMessage(m_hwndDropDown, AM_UPDATESCROLLPOS, 0, 0);
            break;
        }
        case LVN_ITEMACTIVATE:
        {
            //
            // Someone activated an item in the listview. We want to make sure that
            // the items is selected (without hot tracking) so that the contents
            // are moved to the edit box, and then simulate and enter key press.
            //

            LPNMITEMACTIVATE lpnmia = (LPNMITEMACTIVATE)pnmhdr;
            _GetItem(lpnmia->iItem, szBuf, ARRAYSIZE(szBuf), FALSE);

            // Copy the selection to the edit box and place caret at the end
            _SetEditText(szBuf);
            int cch = lstrlen(szBuf);
            Edit_SetSel(m_hwndEdit, cch, cch);

            //
            // Intelliforms don't want an enter key because this would submit the
            // form, so first we try sending a notification.
            //
            if (SendMessage(m_hwndEdit, m_uMsgItemActivate, 0, (LPARAM)szBuf) == 0)
            {
                // Not an intelliform, so simulate an enter key instead.
                SendMessage(m_hwndEdit, WM_KEYDOWN, VK_RETURN, 0);
                SendMessage(m_hwndEdit, WM_KEYUP, VK_RETURN, 0);
            }
            _HideDropDown();
            break;
        }
        case LVN_HOTTRACK:
        {
            //
            // Select items as we mouse-over them
            //
            LPNMLISTVIEW lpnmlv = (LPNMLISTVIEW)pnmhdr;
            LVHITTESTINFO lvh;
            lvh.pt = lpnmlv->ptAction;
            int iItem = ListView_HitTest(m_hwndList, &lvh);
            if (iItem != -1)
            {
                // Update the current selection. The m_fInHotTracking flag prevents the
                // edit box contents from being updated
                m_fInHotTracking = TRUE;
                ListView_SetItemState(m_hwndList, iItem, LVIS_SELECTED|LVIS_FOCUSED, 0x000f);
                SendMessage(m_hwndList, LVM_ENSUREVISIBLE, iItem, FALSE);
                m_fInHotTracking = FALSE;
            }

            // We processed this...
            return TRUE;
        }
    }
    return FALSE;
}


//+-------------------------------------------------------------------------
// Static window procedure for the AutoSuggest drop-down
//--------------------------------------------------------------------------
LRESULT CALLBACK CAutoComplete::s_DropDownWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAutoComplete* pThis;
    if (uMsg == WM_NCCREATE)
    {
        pThis = (CAutoComplete*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pThis);
        pThis->m_hwndDropDown = hwnd;
    }
    else
    {
        pThis = (CAutoComplete*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    if (pThis && (pThis->m_hwndDropDown == hwnd))
    {
        return pThis->_DropDownWndProc(uMsg, wParam, lParam);
    }
    else
    {
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }
}

//+-------------------------------------------------------------------------
// We subclass the listview to prevent it from activating the drop-down
// when someone clicks on it.
//--------------------------------------------------------------------------
LRESULT CAutoComplete::_ListViewWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet;
    switch (uMsg)
    {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_MBUTTONUP:
            //
            // Prevent mouse clicks from activating this view
            //
            s_fNoActivate = TRUE;
            lRet = CallWindowProc(m_pOldListViewWndProc, m_hwndList, uMsg, wParam, lParam);
            s_fNoActivate = FALSE;
            return 0;

        case WM_DESTROY:
            // Restore old wndproc.
            RemoveProp(m_hwndList, c_szAutoCompleteProp);
            if (m_pOldListViewWndProc)
            {
                SetWindowLongPtr(m_hwndList, GWLP_WNDPROC, (LONG_PTR) m_pOldListViewWndProc);
                lRet = CallWindowProc(m_pOldListViewWndProc, m_hwndList, uMsg, wParam, lParam);
                m_pOldListViewWndProc = NULL;
            }
            return 0;

        case WM_GETOBJECT:
            if ((DWORD)lParam == OBJID_CLIENT)
            {
                SAFERELEASE(m_pDelegateAccObj);

                if (SUCCEEDED(CreateStdAccessibleObject(m_hwndList,
                                                        OBJID_CLIENT,
                                                        IID_IAccessible,
                                                        (void **)&m_pDelegateAccObj)))
                {
                    return LresultFromObject(IID_IAccessible, wParam, SAFECAST(this, IAccessible *));
                }
            }
            break;

        case WM_NCHITTEST:
        {
            RECT rc;
            POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

            // If in the grip area, let our parent handle it
            if (m_hwndGrip)
            {
                GetWindowRect(m_hwndGrip, &rc);

                if (PtInRect(&rc, pt))
                {
                    return HTTRANSPARENT;
                }
            }
            break;
        }
    }
    lRet = CallWindowProc(m_pOldListViewWndProc, m_hwndList, uMsg, wParam, lParam);
    return lRet;
}

//+-------------------------------------------------------------------------
// Static window procedure for the subclassed listview
//--------------------------------------------------------------------------
LRESULT CAutoComplete::s_ListViewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAutoComplete* pac = (CAutoComplete*)GetProp(hwnd, c_szAutoCompleteProp);
    if (pac)
    {
        return pac->_ListViewWndProc(uMsg, wParam, lParam);
    }
    else
    {
        TraceMsg(TF_WARNING, "CAutoComplete::s_ListViewWndProc() --- pac == NULL");
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }
}

//+-------------------------------------------------------------------------
// This message hook is only installed when the AutoSuggest dropdown
// is visible.  It hides the dropdown if you click on any window other than
// the dropdown or associated editbox/combobox.
//--------------------------------------------------------------------------
LRESULT CALLBACK CAutoComplete::s_MouseHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    if (nCode >= 0)
    {
        MOUSEHOOKSTRUCT *pmhs = (MOUSEHOOKSTRUCT*)lParam;
        ASSERT(pmhs);

        switch (wParam)
        {
            case WM_LBUTTONDOWN:
            case WM_MBUTTONDOWN:
            case WM_RBUTTONDOWN:
            case WM_NCLBUTTONDOWN:
            case WM_NCMBUTTONDOWN:
            case WM_NCRBUTTONDOWN:
            {
                HWND hwnd = pmhs->hwnd;

                // If the click was outside the edit/combobox/dropdown, then
                // hide the dropdown.
                if (hwnd != s_hwndDropDown)
                {
                    // Ignore if the button was clicked in the dropdown
                    RECT rc;
                    if (GetWindowRect(s_hwndDropDown, &rc) && !PtInRect(&rc, pmhs->pt))
                    {
                        // Inform the dropdown
                        SendMessage(s_hwndDropDown, AM_BUTTONCLICK, 0, (LPARAM)pmhs);
                    }
                }
                break;
            }
        }
    }

    return CallNextHookEx(s_hhookMouse, nCode, wParam, lParam);
}

//+-------------------------------------------------------------------------
// Subclasses all of the parents of hwnd so we can determine when they
// are moved, deactivated, or clicked on.  We use these events to signal
// the window that has focus to hide its autocomplete dropdown. This is
// similar to the CB_SHOWDROPDOWN message sent to comboboxes, but we cannot
// assume that we are autocompleting a combobox.
//--------------------------------------------------------------------------
void CAutoComplete::_SubClassParent
(
    HWND hwnd   // window to notify of events
)
{
    //
    // Subclass all the parent windows because any of them could cause
    // the position of hwnd to change which should hide the dropdown.
    //
    HWND hwndParent = hwnd;
    DWORD dwThread = GetCurrentThreadId();

    while (hwndParent = GetParent(hwndParent))
    {
        // Only subclass if this window is owned by our thread
        if (dwThread == GetWindowThreadProcessId(hwndParent, NULL))
        {
            SetWindowSubclass(hwndParent, s_ParentWndProc, 0, (ULONG_PTR)this);
        }
    }
}

//+-------------------------------------------------------------------------
// Unsubclasses all of the parents of hwnd.  We use the helper functions in
// comctl32 to safely unsubclass a window even if someone else subclassed
// the window after us.
//--------------------------------------------------------------------------
void CAutoComplete::_UnSubClassParent
(
    HWND hwnd   // window to notify of events
)
{
    HWND hwndParent = hwnd;
    DWORD dwThread = GetCurrentThreadId();

    while (hwndParent = GetParent(hwndParent))
    {
        // Only need to unsubclass if this window is owned by our thread
        if (dwThread == GetWindowThreadProcessId(hwndParent, NULL))
        {
            RemoveWindowSubclass(hwndParent, s_ParentWndProc, 0);
        }
    }
}

//+-------------------------------------------------------------------------
// Subclassed window procedure of the parents ot the editbox being
// autocompleted.  This intecepts messages that should case the autocomplete
// dropdown to be hidden.
//--------------------------------------------------------------------------
LRESULT CALLBACK CAutoComplete::s_ParentWndProc
(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    UINT_PTR uIdSubclass,   // always zero for us
    DWORD_PTR dwRefData     // -> CParentWindow
)
{
    CAutoComplete* pThis = (CAutoComplete*)dwRefData;

    if (!pThis)
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
        case WM_WINDOWPOSCHANGED:
        {
            //
            // Check the elapsed time since this was last called.  We want to avoid an infinite loop
            // with another window that also wants to be on top.
            //
            static DWORD s_dwTicks = 0;
            DWORD dwTicks = GetTickCount();
            DWORD dwEllapsed = dwTicks - s_dwTicks;
            s_dwTicks = dwTicks;

            if (dwEllapsed > 100)
            {
                // Make sure our dropdown stays on top
                LPWINDOWPOS pwp = (LPWINDOWPOS)lParam;
                if (IsFlagClear(pwp->flags, SWP_NOZORDER) && IsWindowVisible(pThis->m_hwndDropDown))
                {
                    SetWindowPos(pThis->m_hwndDropDown, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);
                }
            }
            break;
        }
        case WM_ACTIVATE:
        {
            // Ignore if we are not being deactivated
            WORD fActive = LOWORD(wParam);
            if (fActive != WA_INACTIVE)
            {
                break;
            }
            // Drop through
        }
        case WM_MOVING:
        case WM_SIZE:
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
            pThis->_HideDropDown();
            break;

        case WM_NCACTIVATE:
            //
            // While clicking on the autosuggest dropdown, we
            // want to prevent the dropdown from being activated.
            //
            if (s_fNoActivate)
                return FALSE;
            break;

        case WM_DESTROY:
            RemoveWindowSubclass(hwnd, s_ParentWndProc, 0);
            break;

        default:
            break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

//+-------------------------------------------------------------------------
// Subclassed window procedure fir the grip re-sizer control
//--------------------------------------------------------------------------
LRESULT CALLBACK CAutoComplete::s_GripperWndProc
(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    UINT_PTR uIdSubclass,   // always zero for us
    DWORD_PTR dwRefData     // -> CParentWindow
)
{
    CAutoComplete* pThis = (CAutoComplete*)dwRefData;

    if (!pThis)
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
        case WM_NCHITTEST:
            return HTTRANSPARENT;

        case WM_PAINT:
            PAINTSTRUCT ps;
            BeginPaint(hwnd, &ps);
            EndPaint(hwnd, &ps);
            break;

        case WM_ERASEBKGND:
        {
            HDC hdc = (HDC)wParam;
            RECT rc;
            GetClientRect(hwnd, &rc);
            int nOldMapMode = 0;
            BOOL fScrollVisible = pThis->m_hwndScroll && IsWindowVisible(pThis->m_hwndScroll);

            //
            // See if we need to vertically flip the grip
            //
            if (pThis->m_fDroppedUp)
            {
                nOldMapMode = SetMapMode(hdc, MM_ANISOTROPIC);
                SetWindowOrgEx(hdc, 0, 0, NULL);
                SetWindowExtEx(hdc, 1, 1, NULL);
                SetViewportOrgEx(hdc, 0, GetSystemMetrics(SM_CYHSCROLL), NULL);
                SetViewportExtEx(hdc, 1, -1, NULL);
            }
            // The standard DrawFrameControl API does not draw upside down on all platforms
//            DrawFrameControl(hdc, &rc, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);
            DrawGrip(hdc, &rc, fScrollVisible);
            if (nOldMapMode)
            {
                SetViewportOrgEx(hdc, 0, 0, NULL);
                SetViewportExtEx(hdc, 1, 1, NULL);
                SetMapMode(hdc, nOldMapMode);
            }
            return 1;
        }
        case WM_DESTROY:
            RemoveWindowSubclass(hwnd, s_GripperWndProc, 0);
            break;

        default:
            break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\bandobj.h ===
// implements the dataobject for a deskbar band

extern UINT g_cfDeskBand;
extern UINT g_cfDeskBandState;

class CBandDataObject : public IDataObject
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    
    // IDataObject methods

    STDMETHODIMP GetData(FORMATETC *pfmtetcIn, STGMEDIUM *pstgmed);
    STDMETHODIMP GetDataHere(FORMATETC *pfmtetc, STGMEDIUM *pstgpmed);
    STDMETHODIMP QueryGetData(FORMATETC *pfmtetc);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pfmtetcIn, FORMATETC *pfmtetcOut);
    STDMETHODIMP SetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed, BOOL bRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppienumFormatEtc);
    STDMETHODIMP DAdvise(FORMATETC *pfmtetc, DWORD dwAdviseFlags, IAdviseSink * piadvsink, PDWORD pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppienumStatData);
    
    CBandDataObject();
    HRESULT Init(IUnknown* punkBand, IBandSite *pbs, DWORD dwBandID);
    
protected:
    ~CBandDataObject();
    ULONG _cRef;
    IStream* _pstm;         // band state (IPS::Save)
    DWORD _dwState;         // band's bandsite state (DWORD *)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\bandobj.cpp ===
#include "priv.h"
#include "bandobj.h"


UINT g_cfDeskBand = 0;
UINT g_cfDeskBandState = 0;

void InitCFDeskBand()
{
    if (!g_cfDeskBand) 
        g_cfDeskBand = RegisterClipboardFormat(TEXT("DeskBand"));
    if (!g_cfDeskBandState) 
        g_cfDeskBandState = RegisterClipboardFormat(TEXT("DeskBandState"));
}

CBandDataObject::CBandDataObject()
    : _cRef(1)
{
    InitCFDeskBand();
}

HRESULT CBandDataObject::Init(IUnknown* punkBand, IBandSite *pbs, DWORD dwBandID)
{
    HRESULT hres = E_FAIL;
    _pstm = SHCreateMemStream(NULL, 0);

    if (_pstm) {

        IPersistStream *ppstm;
        punkBand->QueryInterface(IID_IPersistStream, (LPVOID*)&ppstm);
        if (ppstm) {
            LARGE_INTEGER li = {0};
            OleSaveToStream(ppstm, _pstm);
            _pstm->Seek(li, STREAM_SEEK_SET, NULL);
            ppstm->Release();

            // bandsite state flags
            _dwState = 0;  // (if we fail just do w/o the state flags)
            if (pbs)
                pbs->QueryBand(dwBandID, NULL, &_dwState, NULL, 0);

            hres = S_OK;
            
        }
    }

    return hres;
}

CBandDataObject::~CBandDataObject()
{
    if (_pstm)
        _pstm->Release();
}

ULONG CBandDataObject::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CBandDataObject::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}



HRESULT CBandDataObject::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IDataObject))
    {
        *ppvObj = SAFECAST(this, IDataObject*);
        AddRef();
        return S_OK;
    } 

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

// *** IDataObject ***

HRESULT CBandDataObject::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    HRESULT hres = E_FAIL;
    if (pformatetcIn->cfFormat == g_cfDeskBand)
    {
        if (pformatetcIn->tymed & TYMED_ISTREAM && EVAL(_pstm))
        {
            ASSERT(_pstm);
            
            pmedium->tymed = TYMED_ISTREAM;
            pmedium->pstm = _pstm;  // no AddRef since we xfer ownership
            _pstm = NULL;           // can only use it 1x (read causes seek)
            pmedium->pUnkForRelease = NULL;

            hres = S_OK;
        }
    }        
    else if (pformatetcIn->cfFormat == g_cfDeskBandState)
    {
        if (pformatetcIn->tymed & TYMED_HGLOBAL)
        {
            pmedium->tymed = TYMED_HGLOBAL;
            pmedium->hGlobal = GlobalAlloc(GPTR, sizeof (DWORD));
            if (pmedium->hGlobal)
            {
                DWORD *pdw = (DWORD*)(pmedium->hGlobal);

                *pdw = _dwState;

                pmedium->pUnkForRelease = NULL;

                hres = S_OK;
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }
    }

    return hres;
}

HRESULT CBandDataObject::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    return E_NOTIMPL;
}

HRESULT CBandDataObject::QueryGetData(FORMATETC *pformatetc)
{
    HRESULT hres = S_FALSE;
    // TODO: (reuse, perf) use rgfmtetc table lookup
    if ((pformatetc->cfFormat == g_cfDeskBand) &&
      (pformatetc->tymed & TYMED_ISTREAM) ||
        (pformatetc->cfFormat == g_cfDeskBandState) &&
      (pformatetc->tymed & TYMED_HGLOBAL))
    {
        hres = S_OK;
    }
    return hres;
}

HRESULT CBandDataObject::GetCanonicalFormatEtc(FORMATETC *pformatetcIn, FORMATETC *pformatetcOut)
{
    *pformatetcOut = *pformatetcIn;
    return DATA_S_SAMEFORMATETC;
}

HRESULT CBandDataObject::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    return E_NOTIMPL;
}

HRESULT CBandDataObject::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc)
{
    HRESULT hr = E_FAIL;

    if (dwDirection == DATADIR_GET)
    {
        FORMATETC rgfmtetc[] =
        {
            { g_cfDeskBand,            NULL, 0, -1, TYMED_ISTREAM },
            { g_cfDeskBandState,       NULL, 0, -1, TYMED_HGLOBAL },
        };

        hr = SHCreateStdEnumFmtEtc(ARRAYSIZE(rgfmtetc), rgfmtetc, ppenumFormatEtc);
    }
    
    return hr;
}

HRESULT CBandDataObject::DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    return E_NOTIMPL;
}

HRESULT CBandDataObject::DUnadvise(DWORD dwConnection)
{
    return E_NOTIMPL;
}

HRESULT CBandDataObject::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
    return E_NOTIMPL;
}

//***   IDataObject_GetDeskBandState -- get band's bandsite state flags from BandDataObject
// NOTES
//  'paired' w/ DragBandState (inline in CBandDataObject::Init)
DWORD IDataObject_GetDeskBandState(IDataObject *pdtobj)
{
    DWORD dwState = 0;      // (if we fail just do w/o the state flags)

    FORMATETC fmte = {g_cfDeskBandState, NULL, 0, -1, TYMED_HGLOBAL};
    STGMEDIUM stg;
    HRESULT hrTmp;

    hrTmp = pdtobj->GetData(&fmte, &stg);
    if (SUCCEEDED(hrTmp))
    {
        DWORD *p = (DWORD *)(stg.hGlobal);

        dwState = *p;

        ReleaseStgMedium(&stg);
    }

    return dwState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\autocomp.h ===
/* Copyright 1996 Microsoft */

#ifndef _AUTOCOMP_HPP_
#define _AUTOCOMP_HPP_

#include "accdel.h"

// TODO List:
// 1. Convert AutoComplete to be a Free Threaded object and move it and all it's
//    lists into MultiApartment model.
// 2. Get thread out of ThreadPool API in shlwapi.dll instead of creating thead our
//    selves.
// 3. See if SHWaitForSendMessageThread() will cause a lock if bg thread is in SendMessage().
//    If so, make sure the bg loop's hard loop doesn't call SendMessage() in this case without
//    first looking for QUIT message.



// WARNING On Usage:
//   This object is marked Apartment model and this abuses COM.  These are rules 
// that need to be followed to prevent bugs.  This object will be used within three scopes.  
// The first scope is the caller doing: 1a) CoInitialize(), 1b) CoCreateInstance(). 
// 1c) p->Init(), 1d) p->Release(), 1e) CoUninitialize().
// The second scope is the object doing: 2a) Subclass();AddRef(), 2b) WM_DESTROY;Release();
// 1c) p->Init(), 1d) p->Release(), 1e) CoUninitialize().
// The third scope is the background thread doing: 3a) (in thread proc) CoInitialize(), 
// 3b) CoUninitialize(). 
// This object requires that 1E come after 2B and that should be the only requirement
// for the use of this object.


//
// PRIVATE
//
#define AC_LIST_GROWTH_CONST         50
const WCHAR CH_WILDCARD = L'\1';    // indicates a wildcard search

//
// Debug Flags
//
#define AC_WARNING          TF_WARNING + TF_AUTOCOMPLETE
#define AC_ERROR            TF_ERROR   + TF_AUTOCOMPLETE
#define AC_GENERAL          TF_GENERAL + TF_AUTOCOMPLETE
#define AC_FUNC             TF_FUNC    + TF_AUTOCOMPLETE

// Enable test regkey
#define ALLOW_ALWAYS_DROP_UP

//
// WndProc messages to the dropdown window
//
enum
{
    AM_BUTTONCLICK = WM_APP + 400,
    AM_UPDATESCROLLPOS,
    AM_DESTROY
};

//
// Flags passed from background thread when the search is completed
enum
{
    SRCH_LIMITREACHED   = 0x01, // out of memory or we reached our limit
    SRCH_USESORTINDEX   = 0x02, // use sort index to order results
};

#define ACO_UNINITIALIZED       0x80000000    // if autocomplete options have not been initialized

//
// PUBLIC
//
HRESULT SHUseDefaultAutoComplete(HWND hwndEdit, 
                               IBrowserService * pbs,       IN  OPTIONAL
                               IAutoComplete2 ** ppac,      OUT OPTIONAL
                               IShellService ** ppssACLISF, OUT OPTIONAL
                               BOOL fUseCMDMRU);

// Forward references
class CAutoComplete;
class CACString* CreateACString(LPCWSTR pszStr);

//+-------------------------------------------------------------------------
// CACString - Autocomplete string shared by foreground & background threads
//--------------------------------------------------------------------------
class CACString
{
public:
    ULONG AddRef();
    ULONG Release();
    ULONG GetSortIndex() { return m_ulSortIndex; }
    void  SetSortIndex(ULONG ulIndex) { m_ulSortIndex = ulIndex; }
    LPCWSTR GetStr() const { return m_sz; }
    LPCWSTR GetStrToCompare() const { return m_sz + m_iIgnore; }
    int GetLength() const { return m_cChars; }
    int GetLengthToCompare() const { return m_cChars - m_iIgnore; }
    const WCHAR& operator [] (int nIndex) const { return m_sz[nIndex]; }
    operator LPCWSTR() { return m_sz; }
    BOOL HasPrefix() { return m_iIgnore; }
    BOOL PrefixLength() { return m_iIgnore; }

    // Note, the following compare functions ignore the prefix of the CACString
    int CompareSortingIndex(CACString& r);
    int StrCmpI(LPCWSTR psz) { return ::StrCmpI(m_sz + m_iIgnore, psz); }
    int StrCmpI(CACString& r) { return ::StrCmpI(m_sz + m_iIgnore, r.m_sz + r.m_iIgnore); }
    int StrCmpNI(LPCWSTR psz, int cch) { return ::StrCmpNI(m_sz + m_iIgnore, psz, cch); }

protected:
    friend CACString* CreateACString(LPCWSTR pszStr, int iIgnore, ULONG ulSortIndex);

    // Prevent creation on stack
    CACString();

    LONG  m_cRef;           // reference count
    int   m_cChars;         // length of string (excluding null)
    int   m_iIgnore;        // # prefix characters to ignore when comparing strings
    ULONG m_ulSortIndex;    // can be used instead of default alphabetical sorting
    WCHAR m_sz[1];          // first character of the string
};

//+-------------------------------------------------------------------------
// CACThread - Autocomplete thread that runs in the background
//--------------------------------------------------------------------------
class CACThread : public IUnknown
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

                CACThread(CAutoComplete& rAutoComp);
    virtual     ~CACThread();

    BOOL        Init(IEnumString* pes, IACList* pacl);

    void        GotFocus(); 
    void        LostFocus();
    BOOL        HasFocus() { return m_fWorkItemQueued != 0; }
    BOOL        StartSearch(LPCWSTR pszSearch, DWORD dwOptions);
    void        StopSearch();
    void        SyncShutDownBGThread();
    BOOL        IsDisabled() { return m_fDisabled; }

    // Helper functions
    static BOOL MatchesSpecialPrefix(LPCWSTR pszSearch);
    static int  GetSpecialPrefixLen(LPCWSTR psz);

protected:
    LONG            m_cRef;
    CAutoComplete*  m_pAutoComp;     // portion of autocomplete that runs on main thread
    LONG            m_fWorkItemQueued; // if request made to shlwapi thread pool
    LONG            m_idThread;
    HANDLE          m_hCreateEvent;  // thread startup syncronizatrion
    BOOL            m_fDisabled:1;   // is autocomplete disabled?
    LPWSTR          m_pszSearch;     // String we are currently searching for
    HDPA            m_hdpa_list;     // list of completions
    DWORD           m_dwSearchStatus;// see SRCH_* flags
    IEnumString*    m_pes;           // Used internally for real AutoComplete functionality.
    IEnumACString*  m_peac;          // Used with IEnumString to get sort index
    IACList*        m_pacl;          // Additional methods for autocomplete lists (optional).

    void        _SendAsyncShutDownMsg(BOOL fFinalShutDown);
    void        _FreeThreadData();
    HRESULT     _ThreadLoop();
    HRESULT     _Next(LPWSTR szUrl, ULONG cchUrl, ULONG* pulSortIndex);
    HRESULT     _ProcessMessage(MSG * pMsg, DWORD * pdwTimeout, BOOL * pfStayAlive);
    void        _Search(LPWSTR pszSearch, DWORD dwOptions);
    BOOL        _AddToList(LPTSTR pszUrl, int cchMatch, ULONG ulSortIndex);
    void        _DoExpand(LPCWSTR pszSearch);
    static DWORD WINAPI _ThreadProc(LPVOID lpv);
    static int CALLBACK _DpaCompare(LPVOID p1, LPVOID p2, LPARAM lParam);
};

//+-------------------------------------------------------------------------
// CAutoComplete - Main autocomplete class that runs on the main UI thread
//--------------------------------------------------------------------------
class CAutoComplete
                : public IAutoComplete2
                , public IAutoCompleteDropDown
                , public IEnumString
                , public CDelegateAccessibleImpl
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; }
    virtual STDMETHODIMP Reset();
    virtual STDMETHODIMP Clone(IEnumString **ppenum) { return E_NOTIMPL; }

    // *** IAutoComplete ***
    virtual STDMETHODIMP Init(HWND hwnd, IUnknown *punkACL, LPCOLESTR pwszRegKeyPath, LPCOLESTR pwszQuickCompleteString);
    virtual STDMETHODIMP Enable(BOOL fEnable);

    // *** IAutoComplete2 ***
    virtual STDMETHODIMP SetOptions(DWORD dwFlag);
    virtual STDMETHODIMP GetOptions(DWORD* pdwFlag);

    // *** IAutoCompleteDropDown ***
    virtual STDMETHODIMP GetDropDownStatus(DWORD *pdwFlags, LPWSTR *ppwszString);
    virtual STDMETHODIMP ResetEnumerator();

    // *** IAccessible ***
    STDMETHODIMP get_accName(VARIANT varChild, BSTR  *pszName);

protected:
    // Methods called by the background thread
    friend CACThread;
    void SearchComplete(HDPA hdpa, DWORD dwSearchStatus) { PostMessage(m_hwndEdit, m_uMsgSearchComplete, dwSearchStatus, (LPARAM)hdpa); }
    BOOL IsEnabled();

    // Constructor / Destructor (protected so we can't create on stack)
    CAutoComplete();
    virtual ~CAutoComplete();

    // Instance creator
    friend HRESULT CAutoComplete_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    BOOL _Init();

    // Private variables
    LONG            m_cRef;

    CACThread*      m_pThread;              // background autocomplete thread
    TCHAR           m_szQuickComplete[MAX_PATH];
    TCHAR           m_szRegKeyPath[MAX_PATH];
    DWORD           m_dwFlags;
    HWND            m_hwndEdit;
    HWND            m_hwndCombo;            // if m_hwndEdit is part of a combobox
    HFONT           m_hfontListView;
    LPTSTR          m_pszCurrent;
    int             m_iCurrent;
    DWORD           m_dwLastSearchFlags;
    WNDPROC         m_pOldListViewWndProc;

    IEnumString *   m_pes;                  // Used internally for real AutoComplete functionality.
    IACList *       m_pacl;                 // Additional methods for autocomplete lists (optional).

    HDPA            m_hdpa;                 // sorted completions list
    HDPA            m_hdpaSortIndex;        // matches from m_hdpa ordered by sort index
    LPWSTR          m_pszLastSearch;        // string last sent for completion
    int             m_iFirstMatch;          // first match in list (-1 if no matches)
    int             m_iLastMatch;           // last match in list (-1 if no matches)
    int             m_iAppended;            // item completed in the edit box
    BITBOOL         m_fEditControlUnicode:1;  // if the edit control is unicode.
    BITBOOL         m_fNeedNewList:1;       // last search was truncated
    BITBOOL         m_fDropDownResized:1;   // user has resized drop down
    BITBOOL         m_fAppended:1;          // if something currently appended
    BITBOOL         m_fSearchForAdded:1;    // if last item in dpa is "Search for <>"
    BITBOOL         m_fSearchFor:1;         // if "Search for <>" is to be displayed
    BITBOOL         m_fImeCandidateOpen:1;  // if the IME's candidate window is visible
    DWORD           m_dwOptions;            // autocomplete options (ACO_*)
    EDITWORDBREAKPROC m_oldEditWordBreakProc; // original word break proc for m_hwndEdit

    // Member variables for drop-down auto-suggest window
    HWND            m_hwndDropDown;         // Shows completions in drop-down window
    HWND            m_hwndList;             // Shows completions in drop-down window
    HWND            m_hwndScroll;           // scrollbar
    HWND            m_hwndGrip;             // gripper for resizing the dropdown
    int             m_nStatusHeight;        // height of status in drop-down
    int             m_nDropWidth;           // width of drop-down window
    int             m_nDropHeight;          // height of drop-down window
    int             m_cxGripper;            // width/height of gripper
    BITBOOL         m_fDroppedUp:1;         // if dropdown is over top the edit box
#ifdef ALLOW_ALWAYS_DROP_UP
    BITBOOL         m_fAlwaysDropUp:1;      // TEST regkey to always drop up
#endif
    BITBOOL         m_fSettingText:1;       // if setting the edit text
    BITBOOL         m_fInHotTracking:1;     // if new selection is due to hot-tracking 

    // Member Variables used for external IEnumString
    IEnumString *   m_pesExtern;            // Used internally for real AutoComplete functionality.
    LPTSTR          m_szEnumString;

    // Registered messages sent to edit window
    UINT            m_uMsgSearchComplete;
    UINT            m_uMsgItemActivate;

    static HHOOK    s_hhookMouse;           // windows hook installed when drop-down visible
    static HWND     s_hwndDropDown;         // dropdown currently visible
    static BOOL     s_fNoActivate;          // keep topmost-window from losing activation

    void        _OnSearchComplete(HDPA hdpa, DWORD dwSearchStatus);
    BOOL        _GetItem(int iIndex, LPWSTR pswText, int cchMax, BOOL fDisplayName);
    void        _UpdateCompletion(LPCWSTR pszTyped, int iChanged, BOOL fAppend);
    void        _HideDropDown();
    void        _ShowDropDown();
    void        _PositionDropDown();
    void        _SeeWhatsEnabled();
    BOOL        _IsAutoSuggestEnabled() { return m_dwOptions & ACO_AUTOSUGGEST; }
    BOOL        _IsRTLReadingEnabled() { return m_dwOptions & ACO_RTLREADING; }
    BOOL        _IsAutoAppendEnabled() { return (m_dwOptions & ACO_AUTOAPPEND) || (m_dwOptions & ACO_UNINITIALIZED); }
    BOOL        _IsComboboxDropped() { return (m_hwndCombo && ComboBox_GetDroppedState(m_hwndCombo)); }
    void        _UpdateGrip();
    void        _UpdateScrollbar();

    static BOOL _IsWhack(TCHAR ch);
    static BOOL _IsBreakChar(WCHAR wch);
    BOOL        _WantToAppendResults();
    int         _JumpToNextBreak(int iLoc, DWORD dwFlags);
    BOOL        _CursorMovement(WPARAM wParam);
    void        _RemoveCompletion();
    void        _GetEditText();
    void        _SetEditText(LPCWSTR psz);
    void        _UpdateText(int iStartSel, int iEndSel, LPCTSTR pszCurrent, LPCTSTR pszNew);
    BOOL        _OnKeyDown(WPARAM wParam);
    LRESULT     _OnChar(WPARAM wParam, LPARAM lParam);
    void        _StartCompletion(BOOL fAppend, BOOL fEvenIfEmpty = FALSE);
    BOOL        _StartSearch(LPCWSTR pszSearch);
    void        _StopSearch();
    BOOL        _ResetSearch();
    void        _GotFocus();
    LPTSTR      _QuickEnter();
    BOOL        _AppendNext(BOOL fAppendToWhack);
    BOOL        _AppendPrevious(BOOL fAppendToWhack);
    void        _Append(CACString& rStr, BOOL fAppendToWhack);
    BOOL        _SetQuickCompleteStrings(LPCOLESTR pcszRegKeyPath, LPCOLESTR pcszQuickCompleteString);
    void        _SubClassParent(HWND hwnd);
    void        _UnSubClassParent(HWND hwnd);

    LRESULT     _DropDownWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT     _EditWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT     _ListViewWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

    void        _DropDownDrawItem(LPDRAWITEMSTRUCT pdis);
    BOOL        _DropDownNotify(LPNMHDR pnmhdr);

    static int  _DPADestroyCallback(LPVOID p, LPVOID d);
    static void _FreeDPAPtrs(HDPA hdpa);
    static int CALLBACK _DPACompareSortIndex(LPVOID p1, LPVOID p2, LPARAM lParam);
    static int CALLBACK EditWordBreakProcW(LPWSTR lpch, int ichCurrent, int cch, int code);
    static LRESULT CALLBACK s_EditWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
    static LRESULT CALLBACK s_DropDownWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK s_ListViewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK s_ParentWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
    static LRESULT CALLBACK s_GripperWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
    static LRESULT CALLBACK s_MouseHook(int nCode, WPARAM wParam, LPARAM lParam);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\bands.cpp ===
#include "priv.h"
#include "bands.h"
#include "util.h"
#include "resource.h"

#include "..\inc\bands.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\bandprxy.cpp ===
/**************************************************************\
    FILE: bandprxy.cpp

    DESCRIPTION:
        The CBandProxy class will allow bands to navigate a
    generic browser window.  This will work correctly if the
    band is tied to the Browser Window because it's a ToolBar.
    Or if it's a toolband, each time a navigation happens,
    the top most browser window needs to be found or a new window 
    created.
\**************************************************************/

#include "priv.h"
#include "sccls.h"
#include "itbar.h"
#include "itbdrop.h"
#include "util.h"
#include <varutil.h>
#include "bandprxy.h"

#define DM_PERSIST      DM_TRACE        // trace IPS::Load, ::Save, etc.


//================================================================= 
// Implementation of CBandProxy
//=================================================================

/****************************************************\
    FUNCTION: CBandProxy_CreateInstance
  
    DESCRIPTION:
        This function will create an instance of the
    CBandProxy COM object.
\****************************************************/
HRESULT CBandProxy_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CBandProxy * p = new CBandProxy();
    if (p) 
    {
        *ppunk = SAFECAST(p, IBandProxy *);
        return NOERROR;
    }

    return E_OUTOFMEMORY;
}


/****************************************************\
    FUNCTION: Address Band Constructor
\****************************************************/
CBandProxy::CBandProxy() : _cRef(1)
{
    DllAddRef();
    TraceMsg(TF_SHDLIFE, "ctor CBandProxy %x", this);

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!_pwb);
    ASSERT(!_punkSite);
}


/****************************************************\
    FUNCTION: Address Band destructor
\****************************************************/
CBandProxy::~CBandProxy()
{
    ATOMICRELEASE(_pwb);
    ATOMICRELEASE(_punkSite);

    TraceMsg(TF_SHDLIFE, "dtor CBandProxy %x", this);
    DllRelease();
}



//===========================
// *** IUnknown Interface ***
/****************************************************\
    FUNCTION: AddRef
\****************************************************/
ULONG CBandProxy::AddRef()
{
    _cRef++;
    return _cRef;
}

/****************************************************\
    FUNCTION: Release
\****************************************************/
ULONG CBandProxy::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

/****************************************************\
    FUNCTION: QueryInterface
\****************************************************/
HRESULT CBandProxy::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IBandProxy))
    {
        *ppvObj = SAFECAST(this, IBandProxy*);
    } 
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


//================================
//  ** IBandProxy Interface ***

/****************************************************\
    FUNCTION: SetSite
  
    DESCRIPTION:
        This function will be called to have this
    Toolband try to obtain enough information about it's
    parent Toolbar to create the Band window and maybe
    connect to a Browser Window.  
\****************************************************/
HRESULT CBandProxy::SetSite(IUnknown * punk)
{
    HRESULT hr = S_OK;

    // On UNIX, we always have a browser.
    // Note, that there's no memory leak happened, 
    // because we get the browser only once 
    // and release it once too (in destructor).
#ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX
    _fHaveBrowser = FALSE;
    ATOMICRELEASE(_pwb);
#endif

    IUnknown_Set(&_punkSite, punk);
    return hr;
}


/****************************************************\
    FUNCTION: CreateNewWindow
  
    DESCRIPTION:
        If this function succeeds, the caller must
    use and release the returned interface quickly.  The
    caller cannot hold on to the Interface because
    the user may close the window and make releasing
    it impossible.
\****************************************************/
HRESULT CBandProxy::CreateNewWindow(IUnknown** ppunk)
{
    return CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                                 IID_PPV_ARG(IUnknown, ppunk));
    // ZekeL: Add code to prep new Browser here.
}


IWebBrowser2* CBandProxy::_GetBrowser()
{
    if (!_fHaveBrowser)
    {
        IUnknown * punkHack;

        _fHaveBrowser = TRUE;

        // HACK: Bands docked on the side of the screen besides the Taskbar will be
        //       able to get a IWebBrowser2 interface pointer.  But we expect this
        //       to be pointing to a valid browser that we are attached to.  Navigating
        //       this interface appears to create new windows, which is not what we
        //       want, because we will try to recycle windows and do special behavior
        //       if the shift key is down.  This QS will detect this case and prevent
        //       it from confusing us.
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SShellDesktop, IID_PPV_ARG(IUnknown, &punkHack))))
            punkHack->Release();
        else
            IUnknown_QueryService(_punkSite, SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &_pwb));
    }

    return _pwb;
}


// this does the default UI work of opening a new window if the shift
// key is down
// or creating a browser if one isn't available already
IWebBrowser2* CBandProxy::_GetBrowserWindow()
{
    IUnknown* punk = NULL;
    IWebBrowser2* pwb = NULL;

    GetBrowserWindow(&punk);

    if (punk) 
    {
        punk->QueryInterface(IID_PPV_ARG(IWebBrowser2, &pwb));

        // Always make browser visible.
        MakeBrowserVisible(punk);
        punk->Release();
    }
    
    return pwb;
}

/****************************************************\
    FUNCTION: GetBrowserWindow
  
    DESCRIPTION:
        this is to just *GET* the browser.  It does not
    do any auto-creating work.
        If this function succseeds, the caller must
    use and release the returned interface quickly.  The
    caller cannot hold on to the Interface because
    the user may close the window and make releasing
    it impossible.

\****************************************************/
HRESULT CBandProxy::GetBrowserWindow(IUnknown** ppunk)
{
    HRESULT hr;

    *ppunk = _GetBrowser();
    if (*ppunk)
    {
        (*ppunk)->AddRef();
        hr =  S_OK;
    } 
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************\
    FUNCTION: IsConnected
  
    DESCRIPTION:
        Indicate if we have a direct connection to the
    browser window.
    S_FALSE == no
    S_OK == yes.
\****************************************************/
HRESULT CBandProxy::IsConnected()
{
    return _GetBrowser() ? S_OK : S_FALSE;
}


/****************************************************\
    FUNCTION: MakeBrowserVisible
  
    DESCRIPTION:
        Make browser visible.
\****************************************************/
HRESULT CBandProxy::MakeBrowserVisible(IUnknown* punk)
{
    IWebBrowserApp * pdie;

    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IWebBrowserApp, &pdie))))
    {
        pdie->put_Visible(TRUE);
        
        HWND hwnd;
        if (SUCCEEDED(SHGetTopBrowserWindow(punk, &hwnd)))
        {
            if (IsIconic(hwnd))
                ShowWindow(hwnd, SW_RESTORE);
        }
        
        pdie->Release();
    }

    return S_OK;
}


/****************************************************\
    FUNCTION: NavigateToPIDL
  
    DESCRIPTION:
        The caller needs to free the PIDL parameter and
    it can be done at any time.  (No need to worry
    about async navigation)  
\****************************************************/
HRESULT CBandProxy::NavigateToPIDL(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_FAIL;

    IWebBrowser2* pwb = _GetBrowserWindow();
    if (pwb)
    {
        VARIANT varThePidl;

        hr = InitVariantFromIDList(&varThePidl, pidl);
        if (SUCCEEDED(hr))
        {
            hr = pwb->Navigate2(&varThePidl, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);
            VariantClear(&varThePidl);
        }
        pwb->Release();
    }
    else
    {
        LPCITEMIDLIST pidlTemp;
        IShellFolder* psf;
        
        if (SUCCEEDED(IEBindToParentFolder(pidl, &psf, &pidlTemp)))
        {
            IContextMenu* pcm;

            hr = psf->GetUIObjectOf(NULL, 1, &pidlTemp, IID_PPV_ARG_NULL(IContextMenu, &pcm));
            if (SUCCEEDED(hr))
            {
                hr = IContextMenu_Invoke(pcm, NULL, NULL, 0);
                pcm->Release();
            }
            psf->Release();
        }
    }

    return hr;
}




/****************************************************\
    FUNCTION: NavigateToUrlOLE
  
    DESCRIPTION:
        Navigate to the Specified URL.  
\****************************************************/
HRESULT CBandProxy::_NavigateToUrlOLE(BSTR bstrURL, VARIANT * pvFlags)
{
    HRESULT hr = S_OK;

    ASSERT(bstrURL); // must have valid URL to browse to

    IWebBrowser2* pwb = _GetBrowserWindow();
    // This will assert if someone was hanging around in the debugger
    // too long.  While will cause the call to timing out.
    if (pwb) 
    {
        VARIANT varURL;
        varURL.vt = VT_BSTR;
        varURL.bstrVal = bstrURL;

        hr = pwb->Navigate2(&varURL, pvFlags, PVAREMPTY, PVAREMPTY, PVAREMPTY);
        // VariantClear() not called because caller will free the allocated string.
        pwb->Release();
    } 
    else 
    {
        SHELLEXECUTEINFO sei;

        FillExecInfo(sei, NULL, NULL, bstrURL, NULL, NULL, SW_SHOWNORMAL);
        // this navigate code path gets hit only from the edit address bar -- since the user
        // would have to interactively put in a weird failure case path to get here, its not an issue.
        if (ShellExecuteEx(&sei))
            hr = S_OK;
        else
            hr = E_FAIL;

    }


    return hr;
}


/****************************************************\
    FUNCTION: NavigateToURLW
  
    DESCRIPTION:
        Navigate to the Specified URL.
\****************************************************/
HRESULT CBandProxy::NavigateToURL(LPCWSTR lpwzURL, VARIANT * Flags)
{
    HRESULT hr;

    LBSTR::CString          strPath( lpwzURL );

    hr = _NavigateToUrlOLE( strPath, Flags );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\bandprxy.h ===
/**************************************************************\
    FILE: bandprxy.h

    DESCRIPTION:
        The CBandProxy class will allow bands to navigate a
    generic browser window.  This will work correctly if the
    band is tied to the Browser Window because it's a ToolBar.
    Or if it's a toolband, each time a navigation happens,
    the top most browser window needs to be found or a new window 
    created.
\**************************************************************/

#ifndef _BANDPRXY_H
#define _BANDPRXY_H

#include "bands.h"


///////////////////////////////////////////////////////////////////
// #DEFINEs
#define    SEC_DEFAULT             0x0000
#define    SEC_WAIT                0x0002
#define    SEC_SHELLSERVICEOBJECTS 0x0004
#define    SEC_NOUI                0x0008


/**************************************************************\
    CLASS: CBandProxy

    DESCRIPTION:
        The CBandProxy class will allow bands to navigate a
    generic browser window.  This will work correctly if the
    band is tied to the Browser Window because it's a ToolBar.
    Or if it's a toolband, each time a navigation happens,
    the top most browser window needs to be found or a new window 
    created.
\**************************************************************/
class CBandProxy
                : public IBandProxy // (Includes IUnknown)
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IBandProxy methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);        
    virtual STDMETHODIMP CreateNewWindow(IUnknown** ppunk);        
    virtual STDMETHODIMP GetBrowserWindow(IUnknown** ppunk);        
    virtual STDMETHODIMP IsConnected();
    virtual STDMETHODIMP NavigateToPIDL(LPCITEMIDLIST pidl);        
    virtual STDMETHODIMP NavigateToURL(LPCWSTR wzUrl, VARIANT * Flags);        

    // Constructor / Destructor
    CBandProxy();
    ~CBandProxy(void);

    // Friend Functions
    friend HRESULT CBandProxy_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);   

protected:
    //////////////////////////////////////////////////////
    //  Private Member Variables 
    //////////////////////////////////////////////////////
    int             _cRef;

    BITBOOL         _fHaveBrowser : 1;  // We haven't tried to get _pwb
    IWebBrowser2 *  _pwb;
    IUnknown *      _punkSite;

    HRESULT _NavigateToUrlOLE(BSTR bstrURL, VARIANT * Flags);
    HRESULT MakeBrowserVisible(IUnknown* punk);
    IWebBrowser2* _GetBrowserWindow();
    IWebBrowser2* _GetBrowser();
};


#endif /* _BANDPRXY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\basebar.h ===
#ifndef BaseBar_H_
#define BaseBar_H_
#include "cwndproc.h"

#ifdef __cplusplus

//========================================================================
// class CBaseBar (CBaseBar* pwbar)
//========================================================================
class CBaseBar : public IOleCommandTarget
               , public IServiceProvider
               , public IDeskBar
                ,public IInputObjectSite
                ,public IInputObject
               , public CImpWndProc
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // *** IDeskBar methods ***
    virtual STDMETHODIMP SetClient(IUnknown* punk);
    virtual STDMETHODIMP GetClient(IUnknown** ppunkClient);
    virtual STDMETHODIMP OnPosRectChangeDB (LPRECT prc);

    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IInputObject methods ***
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

protected:
    // Constructor & Destructor
    CBaseBar();
    virtual ~CBaseBar();
    friend HRESULT CBaseBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    
    BOOL _CheckForwardWinEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);    

    virtual void _NotifyModeChange(DWORD dwMode); // NOTE: we may be abhe to get rid of this virtual...
    void _GetBorderRect(RECT* prc);

    virtual STDMETHODIMP ShowDW(BOOL fShow); // match IDockingWindow::ShowDW
    virtual STDMETHODIMP CloseDW(DWORD dwReserved); // match IDockingWindow::CloseDW
    virtual LRESULT _OnCommand(UINT msg, WPARAM wparam, LPARAM lparam);
    virtual LRESULT _OnNotify(UINT msg, WPARAM wparam, LPARAM lparam);
    virtual void _OnSize(void);
    virtual void _OnCreate();
    virtual void _OnPostedPosRectChange();
    virtual DWORD _GetExStyle();
    virtual DWORD _GetClassStyle();

    // Window procedure
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    

    // Member variables
    UINT            _cRef;                  // reference count
    IUnknown*       _punkChild;             // ptr to IUnknown  for client area
    IDeskBarClient*     _pDBC;              // cached BaseBarClient for _punkChild
    IWinEventHandler*   _pWEH;              // cached IWenEventHandler for _punkChild
    HWND            _hwndChild;             // cached HWND      for _punkChild
    HWND            _hwndSite;              // hwnd of the site

    BOOL            _fShow :1;
    BOOL            _fPosRectChangePending;

    DWORD           _dwMode;

    SIZE            _szChild;               // last requested size from child

private:
    // Private members
    void _RegisterDeskBarClass();
    void _CreateDeskBarWindow();

};

#endif // __cplusplus
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\bandsite.h ===
#ifndef _bandsite_h
#define _bandsite_h

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#define SZ_REGKEY_GLOBALADMINSETTINGS TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\IEAK")
#define SZ_REGVALUE_GLOBALADMINSETTINGS TEXT("Admin Band Settings")

// Admin Settings (dwAdminSettings)
#define BAND_ADMIN_NORMAL       0x00000000
#define BAND_ADMIN_NODDCLOSE    0x00000001  // Disable Drag & Drop, and Close
#define BAND_ADMIN_NOMOVE       0x00000002  // Disable Moving within a Bar.
#define BAND_ADMIN_ADMINMACHINE 0x80000000  // This is an admin machine and this bit displays the two Admin Context Menu items

BOOL BandSite_HandleMessage(IUnknown *punk, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
void BandSite_SetMode(IUnknown *punk, DWORD dwMode);

BOOL ConfirmRemoveBand(HWND hwnd, UINT uID, LPCTSTR szName);

#ifdef WANT_CBANDSITE_CLASS

// UIActivateIO callback instance data
typedef struct tagACTDATA {
    LPMSG   lpMsg;  // IN
    HRESULT hres;
    IUnknown *punk;
} ACTDATA;


// this is a converted struct.  the reason why its a class is to get refcounting.
// let everybody get to the member vars.
class CBandItemData
{
public:
    CBandItemData() : _cRef(1) {}
    ULONG AddRef() { return InterlockedIncrement(&_cRef); }
    ULONG Release() { ULONG cRef = InterlockedDecrement(&_cRef); if (0 == cRef) delete this; return cRef; }

    HWND hwnd;
    IDeskBand *pdb;
    IWinEventHandler *pweh;
    POINTL ptMinSize;
    POINTL ptMaxSize;
    POINTL ptIntegral;
    POINTL ptActual;
    WCHAR szTitle[256];
    DWORD dwModeFlags;
    DWORD dwBandID;
    BITBOOL fShow:1;            // current show state
    BITBOOL fNoTitle:1;         // 1:don't show title
    DWORD dwAdminSettings;
    COLORREF crBkgnd;

private:
    LONG _cRef;
};

typedef int (*PFNBANDITEMENUMCALLBACK)(CBandItemData *pbid, LPVOID pData);

int     _UIActIOCallback(CBandItemData *pbid, void *pv);

typedef struct {
    HRESULT hres;
    const GUID * pguidService;
    const IID * piid;
    void ** ppvObj;
} QSDATA;

int     _QueryServiceCallback(CBandItemData *pbid, void *pv);

#include "caggunk.h"

class CBandSite : public CAggregatedUnknown
                , public IBandSite
                , public IInputObjectSite
                , public IInputObject
                , public IDeskBarClient
                , public IWinEventHandler
                , public IPersistStream
                , public IDropTarget
                , public IServiceProvider
                , public IBandSiteHelper
                , public IOleCommandTarget
{

public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAggregatedUnknown::QueryInterface(riid, ppvObj);};
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CAggregatedUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { return CAggregatedUnknown::Release();};

    // *** IPersistStream methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP IsDirty(void);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);

    // *** IBandSite methods ***
    virtual STDMETHODIMP AddBand(IUnknown* punk);
    virtual STDMETHODIMP EnumBands(UINT uBand, DWORD* pdwBandID);
    virtual STDMETHODIMP QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName);
    virtual STDMETHODIMP SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState);
    virtual STDMETHODIMP RemoveBand(DWORD dwBandID);
    virtual STDMETHODIMP GetBandObject(DWORD dwBandID, REFIID riid, LPVOID* ppvObj);
    virtual STDMETHODIMP SetBandSiteInfo(const BANDSITEINFO * pbsinfo);
    virtual STDMETHODIMP GetBandSiteInfo(BANDSITEINFO * pbsinfo);
    
    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }
    
    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IInputObject methods ***
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IDeskBarClient methods ***
    virtual STDMETHODIMP SetDeskBarSite(THIS_ IUnknown* punkSite) ;
    virtual STDMETHODIMP SetModeDBC (THIS_ DWORD dwMode) ;
    virtual STDMETHODIMP UIActivateDBC(THIS_ DWORD dwState) ;
    virtual STDMETHODIMP GetSize    (THIS_ DWORD dwWhich, LPRECT prc);
    
    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent (HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    
    // *** IDropTarget ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IBandSiteHelper methods ***
    virtual STDMETHODIMP LoadFromStreamBS(IStream *pstm, REFIID riid, LPVOID *ppv);
    virtual STDMETHODIMP SaveToStreamBS(IUnknown *punk, IStream *pstm);

    // *** IOleCommandTarget ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    CBandSite(IUnknown *punkAgg);

protected:
    virtual HRESULT v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj);
    IDeskBar* _pdb;
    IUnknown* _punkSite;
    IBandSite* _pbsOuter; // the aggregating bandsite
    
    virtual HRESULT _Initialize(HWND hwndParent);
    virtual void _OnCloseBand(DWORD dwBandID);
    virtual LRESULT _OnBeginDrag(NMREBAR* pnm);
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual IDropTarget* _WrapDropTargetForBand(IDropTarget* pdtBand);
    virtual DWORD _GetWindowStyle(DWORD* pdwExStyle);
    virtual HMENU _LoadContextMenu();
    HRESULT _OnBSCommand(int idCmd, DWORD idBandActive, CBandItemData *pbid);

    HRESULT _AddBand(IUnknown* punk);

    virtual HRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    IDataObject* _DataObjForBand(DWORD dwBandID);
    CBandItemData* _GetBandItemDataStructByID(DWORD uID);
    virtual int _ContextMenuHittest(LPARAM lParam, POINT* ppt);

    // container specific (rebar) members

    virtual BOOL            _AddBandItem(CBandItemData *pbid);
    virtual void            _DeleteBandItem(int i);
    CBandItemData * _GetBandItem(int i);
    int             _GetBandItemCount();
    void            _BandItemEnumCallback(int dincr, PFNBANDITEMENUMCALLBACK pfnCB, void *pv);
    void            _DeleteAllBandItems();
    virtual void    _ShowBand(CBandItemData *pbid, BOOL fShow);

    int             _BandIDToIndex(DWORD dwBandID);
    DWORD           _IndexToBandID(int i);
    DWORD           _BandIDFromPunk(IUnknown* punk);

    HRESULT         _SetBandStateHelper(DWORD dwBandID, DWORD dwMask, DWORD dwState);
    virtual void    _UpdateAllBands(BOOL fBSOnly, BOOL fNoAutoSize);
    void            _UpdateBand(DWORD dwBandID);
    BOOL            _UpdateBandInfo(CBandItemData *pbid, BOOL fBSOnly);

    void            _GetBandInfo(CBandItemData *pbid, DESKBANDINFO *pdbi);
    virtual void    _BandInfoFromBandItem(REBARBANDINFO *prbbi, CBandItemData *pbid, BOOL fBSOnly);
    virtual void    v_SetTabstop(LPREBARBANDINFO prbbi);
    BOOL            _IsEnableTitle(CBandItemData *pbid);

    BOOL            _IsHeightReasonable(UINT cy);
    HRESULT         _LoadBandInfo(IStream *pstm, int i, DWORD dwVersion);
    HRESULT         _SaveBandInfo(IStream *pstm, int i);

    HRESULT _AddBandByID(IUnknown *punk, DWORD dwID);
    BOOL _SendToToolband(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    BOOL _HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    int _BandIndexFromPunk(IUnknown *punk);
    BOOL _IsBandTabstop(CBandItemData *pbid);
    IUnknown* _GetNextTabstopBand(IUnknown* ptb, BOOL fBackwards);
    virtual HRESULT _CycleFocusBS(LPMSG lpMsg);
    void _OnRBAutoSize(NMRBAUTOSIZE* pnm);
    void _DoDragDrop();
    BOOL _PreDragDrop();
    virtual void _Close();

    
    BOOL _IsBandDeleteable(DWORD dwBandID);
    void _MinimizeBand(DWORD dwBandID);
    void _MaximizeBand(DWORD dwBandID);
    void _CheckNotifyOnAddRemove(DWORD dwBandID, int iCode);

    DWORD _GetAdminSettings(DWORD dwBandID);
    void _SetAdminSettings(DWORD dwBandID, DWORD dwNewAdminSettings);

    void _ReleaseBandItemData(CBandItemData *pbid, int iIndex);    

    void _CacheActiveBand(IUnknown* ptb);
    HRESULT _IsRestricted(DWORD dwBandID, DWORD dwRestrictAction, DWORD dwBandFlags);

    virtual ~CBandSite();
    
    HWND  _hwnd;
    HDSA  _hdsaBandItemData;
    DWORD _dwMode;
    DWORD _dwShowState;
    DWORD _dwBandIDNext;
    DWORD _dwStyle;

    IDataObject* _pdtobj;   // the stored drag drop data object;
    UINT    _uDragBand;
    DWORD   _dwDropEffect;
    
    IOleCommandTarget *_pct;
    IUnknown *_ptbActive;

    // cache for message reflector stuff
    HWND    _hwndCache;
    IWinEventHandler *_pwehCache;

    // Stuff we need to remember while our context menu is up
    IContextMenu3* _pcm3Parent;

    IShellLinkA *_plink;
    IBandProxy * _pbp;
    BITBOOL _fCreatedBandProxy:1;
    BITBOOL _fDragSource :1;
    BITBOOL _fNoDropTarget :1;
    BITBOOL _fIEAKInstalled :1;    // If TRUE, then display 2 extra contex menu items for Admins to use.
    UINT    _fDragging:2;           // we're dragging (0:FALSE 1:move [2:size])
    HWND    _hwndDD;                // window for cool D&D cursor drawing.
    
    friend HRESULT CBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
};

typedef enum {
    CNOAR_ADDBAND       =   1,
    CNOAR_REMOVEBAND    =   2,
    CNOAR_CLOSEBAR      =   3,
} CNOAR_CODES;

#endif // WANT_CBANDSITE_CLASS


#ifdef __cplusplus
};       /* End of extern "C" { */
#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\basebar.cpp ===
#include "priv.h"
#include "apithk.h"
#include "mshtmhst.h"
#include "basebar.h"

#ifdef MAINWIN
#include <mainwin.h>
EXTERN_C MwPaintSpecialEOBorder( HWND hWnd, HDC hDC );
#endif

#define DBM_ONPOSRECTCHANGE  (WM_USER)


//*** CBaseBar::IDeskBar::* {
//


/*----------------------------------------------------------
Purpose: IDeskBar::SetClient

         Usually the function that composes a bar/bandsite/band
         union is responsible for calling this method to inform
         the bar what the client (bandsite) is.

*/
HRESULT CBaseBar::SetClient(IUnknown *punkChild)
{
    if (_punkChild != NULL)
    {
        // 4, 3, 2, 1 Release
        _hwndChild = NULL;

        if (_pDBC)
        {
            // This must happen first, before _pWEH becomes NULL so cleanup
            // notifications can still go thru
            _pDBC->SetDeskBarSite(NULL);
        }

        ATOMICRELEASE(_pDBC);

        ATOMICRELEASE(_pWEH);

        ATOMICRELEASE(_punkChild);
    }

    _punkChild = punkChild;

    HRESULT hr = S_OK;
    if (_punkChild != NULL)
    {
        // 1, 2, 3, 4 QI/AddRef/etc.
        _punkChild->AddRef();
        if (!_hwnd)
        {
            _RegisterDeskBarClass();
            _CreateDeskBarWindow();
            if (!_hwnd)
            {
                return E_OUTOFMEMORY;
            }

            // can't do CBaseBar::_Initialize yet (haven't done SetSite yet)
        }

        hr = _punkChild->QueryInterface(IID_PPV_ARG(IWinEventHandler, &_pWEH));
        if (SUCCEEDED(hr))
        {
            hr = _punkChild->QueryInterface(IID_PPV_ARG(IDeskBarClient, &_pDBC));
            if (SUCCEEDED(hr))
            {
                // nothing to cache yet due to lazy CreateWindow
                hr = _pDBC->SetDeskBarSite(SAFECAST(this, IDeskBar*));

                IUnknown_GetWindow(_punkChild, &_hwndChild);
            }
        }
    }

    return hr;
}

HRESULT CBaseBar::GetClient(IUnknown **ppunk)
{
    *ppunk = _punkChild;
    if (_punkChild)
        _punkChild->AddRef();
    return _punkChild ? S_OK : E_FAIL;
}

HRESULT CBaseBar::OnPosRectChangeDB(LPRECT prc)
{
    _szChild.cx = RECTWIDTH(*prc);
    _szChild.cy = RECTHEIGHT(*prc);

    // We can't change our size right away because we haven't returned from processing
    // this WM_SIZE message. If we resize right now, USER gets confused...
    //
    // We cannot use PeekMessage to determine if there is already a pending
    // DBM_ONPOSRECTCHANGE because that allows incoming SendMessage's to
    // arrive, and then we can get into a bad recursive situation when there
    // are a lot of SHChangeNotify's arriving in rapid succession.
    //
    if (!_fPosRectChangePending)
    {
        _fPosRectChangePending = TRUE;
        PostMessage(_hwnd, DBM_ONPOSRECTCHANGE, 0, 0);
    }

    return S_OK;
}

//  Derived classes are expected to implement this method and do something
//  interesting...
void CBaseBar::_OnPostedPosRectChange()
{
}

// }

HRESULT CBaseBar::ShowDW(BOOL fShow)
{
    fShow = BOOLIFY(fShow);

    if (BOOLIFY(_fShow) == fShow)
        return S_OK;

    _fShow = fShow;

    if (_pDBC)
        return _pDBC->UIActivateDBC(fShow ? DBC_SHOW : DBC_HIDE);
    else
        return E_UNEXPECTED;
}

void CBaseBar::_OnCreate()
{
    SendMessage(_hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);
}

LRESULT CBaseBar::_OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);

    return lres;
}


/***
 */
LRESULT CBaseBar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    switch (uMsg) {
    case WM_CREATE:
        _OnCreate();
        break;

    case WM_COMMAND:
        return _OnCommand(uMsg, wParam, lParam);
        

    case WM_SIZE:     
        _OnSize();    
        break;

    case WM_NOTIFY:
        return _OnNotify(uMsg, wParam, lParam);

#if 0
    // we'd like to set focus to the 1st band when somebody clicks in
    // 'dead space' on the bar (i.e. make it look like they TABed in).
    // however for some reason the below code has the bad effect of
    // de-selecting text in (e.g.) the addr edit control (it's as if
    // the control thinks we've clicked there 2x rather than 1x).
    case WM_SETFOCUS:
        if (IUnknown_HasFocusIO(_pDBC) == S_FALSE)
            IUnknown_UIActivateIO(_pDBC, TRUE, NULL);
        break;
#endif
        
    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
    case WM_CONTEXTMENU:
    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_MENUCHAR:
    case WM_PALETTECHANGED:
        _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);
        break;

    case DBM_ONPOSRECTCHANGE:
        _fPosRectChangePending = FALSE;
        _OnPostedPosRectChange();
        break;

#ifdef MAINWIN
    case WM_NCPAINTSPECIALFRAME:
        // In  case  of  motif look  the  MwPaintBorder paints a Etched In
        // border if WM_NCPAINTSPECIALFRAME returns FALSE. We are handling
        // this message here and drawing the Etched Out frame explicitly.
        // wParam - HDC
        if (MwCurrentLook() == LOOK_MOTIF)
        {
            MwPaintSpecialEOBorder( hwnd, (HDC)wParam );
            return TRUE;
        }
#endif

    default:
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }

    return lres;
}

/***
 */
CBaseBar::CBaseBar() : _cRef(1)
{
    DllAddRef();
}

/***
 */
CBaseBar::~CBaseBar()
{
    // see Release, where we call virtuals (which can't be called from dtor)
    DllRelease();
}

/***
 */
void CBaseBar::_RegisterDeskBarClass()
{
    WNDCLASS  wc = {0};
    wc.style            = _GetClassStyle();
    wc.lpfnWndProc      = s_WndProc;
    //wc.cbClsExtra       = 0;
    wc.cbWndExtra       = SIZEOF(CBaseBar*);
    wc.hInstance        = HINST_THISDLL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE+1);
    //wc.lpszMenuName     =  NULL;
    wc.lpszClassName    = TEXT("BaseBar");
    //wc.hIcon            = NULL;

    SHRegisterClass(&wc);
}

DWORD CBaseBar::_GetExStyle()
{
    return WS_EX_TOOLWINDOW;
}

DWORD CBaseBar::_GetClassStyle()
{
    return CS_HREDRAW | CS_VREDRAW;
}

void CBaseBar::_CreateDeskBarWindow()
{
#ifndef UNIX
    // _hwnd is set in s_WndProc
    DWORD dwExStyle = _GetExStyle();    
    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;
    HWND hwndDummy = CreateWindowEx(
                                    dwExStyle,
                                    TEXT("BaseBar"), NULL,
                                    _hwndSite ? WS_CHILD | WS_CLIPCHILDREN : WS_POPUP | WS_CLIPCHILDREN,
                                    0,0,100,100,
                                    _hwndSite, NULL, HINST_THISDLL,
                                    (LPVOID)SAFECAST(this, CImpWndProc*));
#else
    // This change removes a flash at the corner of the
    // screen. We create a small 1,1 window.

    HWND hwndDummy = CreateWindowEx(
                                    _GetExStyle(),
                                    TEXT("BaseBar"), NULL,
                                    _hwndSite ? WS_CHILD | WS_CLIPCHILDREN : WS_POPUP | WS_CLIPCHILDREN,
                                    -100,-100,1,1,
                                    _hwndSite, NULL, HINST_THISDLL,
                                    (LPVOID)SAFECAST(this, CImpWndProc*));
#endif
}


void CBaseBar::_OnSize(void)
{
    RECT rc;

    if (!_hwndChild)
        return;

    GetClientRect(_hwnd, &rc);
    SetWindowPos(_hwndChild, 0,
            rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
            SWP_NOACTIVATE|SWP_NOZORDER);
}

void CBaseBar::_NotifyModeChange(DWORD dwMode)
{
    if (_pDBC) {
        _dwMode = dwMode;
        // FEATURE: should we add an STBBIF_VIEWMODE_FLOAT?
        _pDBC->SetModeDBC(_dwMode);
    }
}

BOOL CBaseBar::_CheckForwardWinEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HWND hwnd = NULL;

    *plres = 0;
    switch (uMsg)
    {
    case WM_CONTEXTMENU:
    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_MENUCHAR:
        hwnd = _hwndChild;
        break;

    case WM_NOTIFY:
        hwnd = ((LPNMHDR)lParam)->hwndFrom;
        break;
        
    case WM_COMMAND:
        hwnd = GET_WM_COMMAND_HWND(wParam, lParam);
        break;
        
    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
    case WM_PALETTECHANGED:
        hwnd = _hwndChild;
        break;
    }
    
    if (hwnd && _pWEH && _pWEH->IsWindowOwner(hwnd) == S_OK)
    {
        _pWEH->OnWinEvent(_hwnd, uMsg, wParam, lParam, plres);
        return TRUE;
    }
    return FALSE;
}

/***
 */
LRESULT CBaseBar::_OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);

    return lres;
}

HRESULT CBaseBar::CloseDW(DWORD dwReserved)
{
    SetClient(NULL);
    if (_hwnd) {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
    return S_OK;
}


HRESULT CBaseBar::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CBaseBar, IOleWindow),
        QITABENT(CBaseBar, IDeskBar),
        QITABENT(CBaseBar, IInputObject),
        QITABENT(CBaseBar, IInputObjectSite),
        QITABENT(CBaseBar, IServiceProvider),
        QITABENT(CBaseBar, IOleCommandTarget),
        { 0 },
    };

    return QISearch(this, (LPCQITAB)qit, riid, ppvObj);
}


ULONG CBaseBar::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CBaseBar::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    // 'virtual dtor'
    // gotta do virtual stuff here (not in dtor) because can't call
    // any virtuals in the dtor
    // CBaseBar::Destroy() {
    CloseDW(0);
    // }

    delete this;
    return 0;
}

//*** CBaseBar::IOleWindow::* {
//

HRESULT CBaseBar::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;
    return (_hwnd) ? S_OK : E_FAIL;
}

HRESULT CBaseBar::ContextSensitiveHelp(BOOL fEnterMode)
{
    // FEATURE: Visit here later.
    return E_NOTIMPL;
}
// }


// }
// some helpers... {

// What's the point of having
// these empty implementations in the base class?
//

//*** CBaseBar::IServiceProvider::*
//
HRESULT CBaseBar::QueryService(REFGUID guidService,
                                REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL;

    return hres;
}

//*** CBaseBar::IOleCommandTarget::*
//
HRESULT CBaseBar::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return MayQSForward(_pDBC, OCTD_DOWN, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

HRESULT CBaseBar::Exec(const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt,
    VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    return MayExecForward(_pDBC, OCTD_DOWN, pguidCmdGroup, nCmdID, nCmdexecopt,
        pvarargIn, pvarargOut);
}

// }


//*** CDeskBar::IInputObject::* {

HRESULT CBaseBar::HasFocusIO()
{
    HRESULT hres;

    hres = IUnknown_HasFocusIO(_pDBC);
    return hres;
}

HRESULT CBaseBar::TranslateAcceleratorIO(LPMSG lpMsg)
{
    HRESULT hres;

    hres = IUnknown_TranslateAcceleratorIO(_pDBC, lpMsg);
    return hres;
}

HRESULT CBaseBar::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT hres;

    hres = IUnknown_UIActivateIO(_pDBC, fActivate, lpMsg);
    return hres;
}

// }

//***   CDeskBar::IInputObjectSite::* {

HRESULT CBaseBar::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return NOERROR;
}

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\bandsite.cpp ===
#include "priv.h"
#include "sccls.h"
#include <uxtheme.h>
#define WANT_CBANDSITE_CLASS
#include "bandsite.h"
#include "bandobj.h"
#include "caggunk.h"
#include "droptgt.h"
#include "resource.h"
#include "bands.h"
#include "legacy.h"
#include "apithk.h"

#include "mluisupp.h"

#define TF_BANDDD   0x00400000
#define DM_INIT     0               //
#define DM_PERSIST  0               // trace IPS::Load, ::Save, etc.
#define DM_MENU     0               // menu code
#define DM_DRAG     0               // drag&drop
#define DM_FOCUS    0               // focus
#define DM_PERF     0               // perf tune
#define DM_PERF2    0               // perf tune (verbose)

#define IDM_DRAGDROP    1

#define ISMOVEDDISABLED(dwBandID)   ((S_OK == _IsRestricted(dwBandID, RA_MOVE, BAND_ADMIN_NOMOVE)) ? TRUE : FALSE)
#define ISDDCLOSEDISABLED(dwBandID) ((S_OK == _IsRestricted(dwBandID, RA_DRAG, BAND_ADMIN_NODDCLOSE)) ? TRUE : FALSE)

// drag state (NOTE from dockbar.h)
#define DRAG_NIL        0       // nil
#define DRAG_MOVE       1       // moving
#define DRAG_SIZE       2       // sizing

typedef struct {
    UINT cx;
    UINT fStyle;
    UINT cxMinChild;
    UINT cyMinChild;
    UINT cyIntegral;
    UINT cyMaxChild;
    UINT cyChild;
} PERSISTBANDINFO_V3;


typedef struct {
    UINT cx;
    UINT fStyle;
    UINT cxMinChild;  // UNUSED. reclaim!
    UINT cyMinChild;
    UINT cyIntegral;   // UNUSED
    UINT cyMaxChild;    // UNUSED.
    UINT cyChild;
    DWORD dwAdminSettings;
    BITBOOL fNoTitle:1;
} PERSISTBANDINFO;
#define RBBIM_XPERSIST  (RBBIM_SIZE | RBBIM_CHILDSIZE | RBBIM_STYLE)

#ifdef DEBUG

extern unsigned long DbStreamTell(IStream *pstm);

#else

#define DbStreamTell(pstm)      ((ULONG) 0)

#endif

UINT _FixMenuIndex(HMENU hmenu, UINT indexMenu)
{
    UINT i;

    i = GetMenuItemCount(hmenu);
    if (indexMenu > i)
        indexMenu = i;
    return indexMenu;
}

#define SUPERCLASS CAggregatedUnknown


HRESULT CBandSite::v_InternalQueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        // perf: last tuned 980728
        QITABENT(CBandSite, IBandSite),             // IID_IBandSite
        QITABENT(CBandSite, IInputObject),          // IID_IInputObject
        QITABENT(CBandSite, IServiceProvider),      // IID_IServiceProvider
        QITABENT(CBandSite, IOleCommandTarget),     // IID_IOleCommandTarget
        QITABENTMULTI(CBandSite, IOleWindow, IDeskBarClient),   // IID_IOleWindow
        QITABENT(CBandSite, IWinEventHandler),      // IID_IWinEventHandler
        QITABENT(CBandSite, IInputObjectSite),      // IID_IInputObjectSite
        QITABENT(CBandSite, IDeskBarClient),        // IID_IDeskBarClient
        QITABENTMULTI(CBandSite, IPersist, IPersistStream),     // rare IID_IPersist
        QITABENT(CBandSite, IPersistStream),        // rare IID_IPersistStream
        QITABENT(CBandSite, IBandSiteHelper),       // rare IBandSiteHelper
        QITABENT(CBandSite, IDropTarget),           // rare IID_IDropTarget
        { 0 },
    };
    
    return QISearch(this, qit, riid, ppvObj);
}

DWORD _SetDataListFlags(IUnknown *punk, DWORD dwMaskBits, DWORD dwValue)
{
    DWORD dw = 0;
    IShellLinkDataList *pdl;
    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &pdl))))
    {
        pdl->GetFlags(&dw);
        dw = (dw & ~dwMaskBits) | (dwValue & dwMaskBits);
        pdl->SetFlags(dw);
        pdl->Release();
    }
    return dw;
}


/////  impl of IServiceProvider
HRESULT CBandSite::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL; // assume error

    if (IsEqualIID(guidService, SID_IBandProxy)) 
    {
        hres =  QueryService_SID_IBandProxy(_punkSite, riid, &_pbp, ppvObj);
        if(!_pbp)
        {
            // We need to create it ourselves since our parent couldn't help
            ASSERT(FALSE == _fCreatedBandProxy);

            hres = CreateIBandProxyAndSetSite(_punkSite, riid, &_pbp, ppvObj);
            if(_pbp)
            {
                ASSERT(S_OK == hres);
                _fCreatedBandProxy = TRUE;   
            }
        }
    } 
    else if (IsEqualIID(guidService, SID_ITopViewHost)) 
    {
        return QueryInterface(riid, ppvObj);
    } 
    else if (IsEqualIID(guidService, IID_IBandSite))
    {
        // It is common for bands to save/load pidls for persistence.
        // CShellLink is a robust way to do this, so let's share one
        // among all the bands.
        //
        // NOTE: This is shared between bands, so if you request it
        // you must complete your use of it within the scope of your
        // function call!
        //
        if (IsEqualIID(riid, IID_IShellLinkA) ||
            IsEqualIID(riid, IID_IShellLinkW))
        {
            if (NULL == _plink)
                CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &_plink));
            if (_plink)
            {
                // we know that the bandsite is going to be pointing to local folders
                // to avoid a perf hit we get in loading the LINKINFO.DLL we explictly
                // disable that functionality here.
                _SetDataListFlags(_plink, SLDF_FORCE_NO_LINKINFO, SLDF_FORCE_NO_LINKINFO);
                hres = _plink->QueryInterface(riid, ppvObj);
            }
        }
    } 
    else
    {
        hres = IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
    }
    return hres;
}

HRESULT CBandSite::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;

    return *lphwnd ?  S_OK : E_FAIL;
}

CBandSite::CBandSite(IUnknown* punkAgg) : SUPERCLASS(punkAgg)
{
    DWORD dwData = 0;
    DWORD dwSize = sizeof(dwData);

    // We assume this object was zero inited.
    ASSERT(!_pbp);
    ASSERT(FALSE == _fCreatedBandProxy);
    SHRegGetUSValue(SZ_REGKEY_GLOBALADMINSETTINGS, SZ_REGVALUE_GLOBALADMINSETTINGS,
        NULL, &dwData, &dwSize, FALSE, NULL, 0);

    if (IsFlagSet(dwData, BAND_ADMIN_ADMINMACHINE))
        _fIEAKInstalled = TRUE;
    else
        _fIEAKInstalled = FALSE;

    _dwStyle = BSIS_AUTOGRIPPER;

    //
    //  We check whether or not this succeeded in CBandSite::_Initialize
    //
    _QueryOuterInterface(IID_PPV_ARG(IBandSite, &_pbsOuter));
    DllAddRef();
}

void CBandSite::_ReleaseBandItemData(CBandItemData *pbid, int iIndex)
{
    if (pbid->pdb) 
    {
        pbid->pdb->CloseDW(0);

        if (-1 != iIndex)
        {
            REBARBANDINFO rbbi;

            // The band's hwnd is typically destroyed in CloseDW
            rbbi.cbSize = sizeof(rbbi);
            rbbi.fMask = RBBIM_CHILD | RBBIM_LPARAM;
            rbbi.hwndChild = NULL;
            rbbi.lParam = NULL;
            SendMessage(_hwnd, RB_SETBANDINFO, iIndex, (LPARAM) &rbbi);
        }

        // this is called from remove and the destroy.
        IUnknown_SetSite(pbid->pdb, NULL);
        ATOMICRELEASE(pbid->pdb);
    }

    if (pbid->pweh == _pwehCache)
        ATOMICRELEASE(_pwehCache);

    ATOMICRELEASE(pbid->pweh);
    pbid->Release();
}

CBandSite::~CBandSite()
{
    ATOMICRELEASE(_pdtobj);

    if(_pbp && _fCreatedBandProxy)
        _pbp->SetSite(NULL);
        
    ATOMICRELEASE(_pbp);

    ATOMICRELEASE(_pwehCache);
    _CacheActiveBand(NULL);

    _Close();

    SetDeskBarSite(NULL);

    if (_plink)
        _plink->Release();

    RELEASEOUTERINTERFACE(_pbsOuter);
    DllRelease();
}

//***   _IsBandDeleteable --
// ENTRY/EXIT
//  idBand  band ID
//  ret     TRUE if deletable, o.w. FALSE (also FALSE on bogus band)
BOOL CBandSite::_IsBandDeleteable(DWORD dwBandID)
{
    DWORD dwState;

    if (FAILED(_pbsOuter->QueryBand(dwBandID, NULL, &dwState, NULL, 0))
      || (dwState & BSSF_UNDELETEABLE))
    {
        return FALSE;
    }

    ASSERT(dwBandID != (DWORD)-1);  // make sure QueryBand catches this

    return TRUE;
}

DWORD CBandSite::_GetAdminSettings(DWORD dwBandID)
{
    DWORD dwAdminSettings = BAND_ADMIN_NORMAL;

    CBandItemData *pbid = _GetBandItem(_BandIDToIndex(dwBandID)); 
    if (pbid)
    {
        dwAdminSettings = pbid->dwAdminSettings;
        pbid->Release();
    }
    return dwAdminSettings;
}


void CBandSite::_SetAdminSettings(DWORD dwBandID, DWORD dwNewAdminSettings)
{
    CBandItemData *pbid = _GetBandItem(_BandIDToIndex(dwBandID)); 
    if (pbid)
    {
        pbid->dwAdminSettings = dwNewAdminSettings;
        pbid->Release();
    }
}


//***   CBandSite::IBandSite::* {

/*----------------------------------------------------------
Purpose: IBandSite::EnumBands method

*/
HRESULT CBandSite::EnumBands(UINT uBand, DWORD* pdwBandID)
{
    ASSERT((NULL == pdwBandID && (UINT)-1 == uBand) || 
           IS_VALID_WRITE_PTR(pdwBandID, DWORD));

    if (uBand == (UINT)-1)
        return _GetBandItemCount();      // query count

    CBandItemData *pbid = _GetBandItem(uBand);
    if (pbid)
    {
        *pdwBandID = pbid->dwBandID;
        pbid->Release();
        return S_OK;
    }
    return E_FAIL;
}


/*----------------------------------------------------------
Purpose: IBandSite::QueryBand method

*/
HRESULT CBandSite::QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName)
{
    ASSERT(NULL == ppstb || IS_VALID_WRITE_PTR(ppstb, IDeskBand));
    ASSERT(NULL == pdwState || IS_VALID_WRITE_PTR(pdwState, DWORD));
    ASSERT(NULL == pszName || IS_VALID_WRITE_BUFFER(pszName, WCHAR, cchName));

    if (ppstb)
        *ppstb = NULL;

    CBandItemData *pbid = _GetBandItemDataStructByID(dwBandID);
    if (!pbid)
        return E_FAIL;
    if (pszName)
    {
        StrCpyNW(pszName, pbid->szTitle, cchName);
    }

    if (ppstb)
    {
        *ppstb = pbid->pdb;
        if (pbid->pdb)
        {
            pbid->pdb->AddRef();
        }
    }
    
    if (pdwState)
    {
        *pdwState = 0;
        if (pbid->fShow)
            *pdwState = BSSF_VISIBLE;
        if (pbid->fNoTitle)
            *pdwState |= BSSF_NOTITLE;
        if (pbid->dwModeFlags & DBIMF_UNDELETEABLE)
            *pdwState |= BSSF_UNDELETEABLE;
    }

    pbid->Release();
    return S_OK;
}


/*----------------------------------------------------------
Purpose: IBandSite::SetBandState

* NOTES
*   failure handling is inconsistent (1 band vs. all bands case)
*/
HRESULT CBandSite::SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState)
{
    HRESULT hr;

    if (dwBandID == (DWORD) -1)
    {
        BOOL fChange = FALSE;
        for (int i = _GetBandItemCount() - 1; i >= 0; i--)
        {
            CBandItemData *pbid = _GetBandItem(i);
            if (pbid)
            {
                hr = _SetBandStateHelper(pbid->dwBandID, dwMask, dwState);
                ASSERT(SUCCEEDED(hr));
                fChange |= (hr != S_OK);
                pbid->Release();
            }
            else
            {
                return E_FAIL;
            }
        }
        if (fChange)
            _UpdateAllBands(FALSE, FALSE);
        return S_OK;
    }
    else
    {
        hr = _SetBandStateHelper(dwBandID, dwMask, dwState);
        if (SUCCEEDED(hr) && hr != S_OK)
        {
            _UpdateBand(dwBandID);
            return S_OK;
        }
    }
    return E_FAIL;
}

//***
// ENTRY/EXIT
//  ret     S_OK|changed on success, o.w. E_*.
// NOTES
//  only a helper for SetBandState, don't call directly
HRESULT CBandSite::_SetBandStateHelper(DWORD dwBandID, DWORD dwMask, DWORD dwState)
{
    HRESULT hr = E_FAIL;
    CBandItemData *pbid = _GetBandItem(_BandIDToIndex(dwBandID));
    if (pbid)
    {
        DWORD dwOldState;

        if (FAILED(QueryBand(dwBandID, NULL, &dwOldState, NULL, 0)))
        {
            ASSERT(0);  // 'impossible'
            dwOldState = (DWORD)-1;
        }

        if (dwMask & BSSF_VISIBLE)
            _ShowBand(pbid, dwState & BSSF_VISIBLE);

        if (dwMask & BSSF_NOTITLE)
            pbid->fNoTitle = BOOLIFY(dwState & BSSF_NOTITLE);
            
        // FEATURE: (kkahl): BSSF_UNDELETABLE cannot currently be modified with
        // this interface.
        hr = ResultFromShort((dwOldState ^ dwState) & dwMask);
        pbid->Release();
    }
    return hr;
}

//***   _CheckNotifyOnAddRemove -- handle notifies for add/remove/empty
// DESCRIPTION
//  add/remove always sends a BSID_BANDADDED/BSID_BANDREMOVED.
//  remove of last always sends a DBCID_EMPTY.
//  in floating mode, a transition to/from 1 band does a refresh.
//
void CBandSite::_CheckNotifyOnAddRemove(DWORD dwBandID, int iCode)
{
    int cBands;
    if (!_pct)
        return;

    if (iCode == CNOAR_CLOSEBAR)
    {
        // Shut down the whole thing
        cBands = 0;
    }
    else
    {
        VARIANTARG var;
        int nCmdID;

        cBands = _GetBandItemCount();   // post-op # (since op happened in caller)

        VariantInit(&var);
        var.vt = VT_UI4;
        var.ulVal = dwBandID;

        BOOL fOne = FALSE;
        switch (iCode)
        {
        case CNOAR_ADDBAND:
            fOne = (cBands == 2);   // 1->2
            nCmdID = BSID_BANDADDED;
            break;
        case CNOAR_REMOVEBAND:
            fOne = (cBands == 1);   // 2->1
            nCmdID = BSID_BANDREMOVED;
            break;
        default:
            ASSERT(0);
            return;
        }

        if ((fOne && (_dwMode & DBIF_VIEWMODE_FLOATING)))
        {
            // n.b. fBSOnly *must* be TRUE for perf
            _UpdateAllBands(TRUE, TRUE);  // force refresh of optional gripper/title
        }

        _pct->Exec(&CGID_BandSite, nCmdID, 0, &var, NULL);
    }

    if (cBands == 0)
    {
        ASSERT(iCode != CNOAR_ADDBAND);     // sanity check
        _pct->Exec(&CGID_DeskBarClient, DBCID_EMPTY, 0, NULL, NULL);
    }

    return;
}

/*----------------------------------------------------------
Purpose: IBandSite::RemoveBand method

*/
HRESULT CBandSite::RemoveBand(DWORD dwBandID)
{
    int iIndex = _BandIDToIndex(dwBandID);
    CBandItemData *pbid = _GetBandItem(iIndex);
    if (pbid)
    {
        // Release the banditem data first, while it can still
        // receive cleanup notifications from its control.  *Then*
        // delete the band item.
        _ReleaseBandItemData(pbid, iIndex);
        _DeleteBandItem(iIndex);    // unhook from host (rebar)
        _CheckNotifyOnAddRemove(dwBandID, CNOAR_REMOVEBAND);
        pbid->Release();
        return S_OK;
    }
    return E_FAIL;
}


void CBandSite::_OnCloseBand(DWORD dwBandID)
{
    if (dwBandID == -1)
    {
        // Close everything
        _CheckNotifyOnAddRemove(dwBandID, CNOAR_CLOSEBAR);
    }
    else
    {
        // Close just this band

        CBandItemData *pbid = _GetBandItemDataStructByID(dwBandID);
        if (pbid)
        {
            if (ConfirmRemoveBand(_hwnd, IDS_CONFIRMCLOSEBAND, pbid->szTitle))
            {
                RemoveBand(dwBandID);
            }
            pbid->Release();
        }
    }
}

void CBandSite::_MinimizeBand(DWORD dwBandID)
{
    SendMessage(_hwnd, RB_MINIMIZEBAND, _BandIDToIndex(dwBandID), TRUE);
}

void CBandSite::_MaximizeBand(DWORD dwBandID)
{
    SendMessage(_hwnd, RB_MAXIMIZEBAND, _BandIDToIndex(dwBandID), TRUE);
}

//
// private insert a band into the container control by ID
// returns the band ID in ShortFromResult(hres)
//

HRESULT CBandSite::_AddBandByID(IUnknown *punk, DWORD dwID)
{
    IDeskBand *pdb;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IDeskBand, &pdb));
    if (SUCCEEDED(hr)) 
    {
        ASSERT(pdb);
        CBandItemData *pbid = new CBandItemData();
        if (pbid)
        {
            pbid->dwBandID = dwID;
            pbid->pdb = pdb;
            pdb->AddRef();
            pbid->fShow = TRUE;     // initially visible

            pbid->pdb->QueryInterface(IID_PPV_ARG(IWinEventHandler, &pbid->pweh));
            hr = IUnknown_SetSite(pbid->pdb, SAFECAST(this, IBandSite*));
            if (SUCCEEDED(hr))
            {
                hr = pbid->pdb->GetWindow(&pbid->hwnd);
                if (SUCCEEDED(hr))
                {
                    // takes ownership in success case
                    if (_AddBandItem(pbid))
                    {
                        if (_dwShowState == DBC_SHOW) 
                        {
                            ASSERT(pbid->fShow);
                            pbid->pdb->ShowDW(TRUE);
                            _MinimizeBand(pbid->dwBandID);
                        }
                
                        _CheckNotifyOnAddRemove(pbid->dwBandID, CNOAR_ADDBAND);
                        hr = ResultFromShort(pbid->dwBandID); // success
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
            }

            if (FAILED(hr))
            {
                // clean up
                _ReleaseBandItemData(pbid, -1);
            }

            // Now that we've added the band, clear the _SendToToolband cache.
            //
            // We need to do this because we might have gotten a message for
            // the band before it was inserted, in which case we'll have cached
            // a NULL handler for the band's hwnd (preventing the band from
            // getting any messages thereafter).
            ATOMICRELEASE(_pwehCache);
            _hwndCache = NULL;
        } 
        else
        {
            hr = E_OUTOFMEMORY;
        }
        pdb->Release();
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: IBandSite::AddBand method.

         Insert a band into the container control.

Returns: the band ID in ShortFromResult(hres)

*/
HRESULT CBandSite::AddBand(IUnknown *punk)
{
    HRESULT hres = _AddBandByID(punk, _dwBandIDNext);
    if (SUCCEEDED(hres))
    {
        _dwBandIDNext++;
    }
    return hres;
}

void CBandSite::_UpdateBand(DWORD dwBandID)
{
    CBandItemData *pbid = _GetBandItem(_BandIDToIndex(dwBandID)); 
    if (pbid)
    {
        _UpdateBandInfo(pbid, FALSE);
        _OnRBAutoSize(NULL);
        pbid->Release();
    }
}

void CBandSite::_UpdateAllBands(BOOL fBSOnly, BOOL fNoAutoSize)
{
    BOOL_PTR fRedraw = SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);

    for (int i = _GetBandItemCount() - 1; i >= 0; i--)
    {
        CBandItemData *pbid = _GetBandItem(i);
        if (pbid)
        {
            _UpdateBandInfo(pbid, fBSOnly);
            pbid->Release();
        }
    }    

    SendMessage(_hwnd, WM_SETREDRAW, fRedraw, 0);

    if (!fNoAutoSize)
    {
        SendMessage(_hwnd, RB_SIZETORECT, 0, 0);
        _OnRBAutoSize(NULL);
    }
}

// *** IOleCommandTarget ***
HRESULT CBandSite::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup)
    {
        if (IsEqualIID(*pguidCmdGroup, IID_IDockingWindow))
        {
            for (ULONG i=0 ; i<cCmds ; i++)
            {
                switch (rgCmds[i].cmdID)
                {
                case DBID_BANDINFOCHANGED:
                case DBID_PUSHCHEVRON:
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                    break;

                case DBID_PERMITAUTOHIDE:
                    // defer decision to the bands
                    for (int iBand = _GetBandItemCount() - 1; iBand >= 0; iBand--)
                    {
                        CBandItemData *pbid = _GetBandItem(iBand);
                        if (pbid)
                        {
                            HRESULT hrTemp = IUnknown_QueryStatus(pbid->pdb, pguidCmdGroup, 1, &rgCmds[i], pcmdtext);
                            pbid->Release();
                            if (SUCCEEDED(hrTemp) &&
                                ((rgCmds[i].cmdf & OLECMDF_SUPPORTED) && !(rgCmds[i].cmdf & OLECMDF_ENABLED)))
                            {
                                break;
                            }
                        }
                    }
                    break;
    
                default:
                    rgCmds[i].cmdf = 0;
                    break;
                }
            }
            return S_OK;
        }
        else if (IsEqualIID(*pguidCmdGroup, CGID_Explorer))
        {
            return IUnknown_QueryStatus(_ptbActive, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
        }
    }

    // if we got here, we didn't handle it
    // forward it down
    return MayQSForward(_ptbActive, OCTD_DOWN, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}


int _QueryServiceCallback(CBandItemData *pbid, void *pv)
{
    QSDATA* pqsd = (QSDATA*)pv;

    if (pbid->fShow)
        pqsd->hres = IUnknown_QueryService(pbid->pdb, *(pqsd->pguidService), *(pqsd->piid), pqsd->ppvObj);

    // stop if we found the service
    return SUCCEEDED(pqsd->hres) ? FALSE : TRUE;
}


typedef struct {
    HRESULT hres;
    const GUID *pguidCmdGroup;
    DWORD nCmdID;
    DWORD nCmdexecopt;
    VARIANTARG *pvarargIn;
    VARIANTARG *pvarargOut;
} EXECDATA;

int _ExecCallback(CBandItemData *pbid, void *pv)
{
    EXECDATA* ped = (EXECDATA*)pv;
    
    ped->hres = IUnknown_Exec(pbid->pdb, ped->pguidCmdGroup, ped->nCmdID, ped->nCmdexecopt,
        ped->pvarargIn, ped->pvarargOut);
    return 1;
}

HRESULT CBandSite::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;
    HRESULT hresTmp;

    if (pguidCmdGroup == NULL)
    {
        /*NOTHING*/
        ;
    }
    else if (IsEqualIID(*pguidCmdGroup, CGID_DeskBand))
    {
        switch (nCmdID)
        {
        case DBID_BANDINFOCHANGED:
            if (!pvarargIn)
                _UpdateAllBands(FALSE, FALSE);
            else if (pvarargIn->vt == VT_I4) 
                _UpdateBand(pvarargIn->lVal);
            hres = S_OK;
            
            // forward this up.
            if (_pct)
            {
                _pct->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            }
            goto Lret;

        case DBID_PUSHCHEVRON:
            if (pvarargIn && pvarargIn->vt == VT_I4)
            {
                int iIndex = _BandIDToIndex(nCmdexecopt);
                SendMessage(_hwnd, RB_PUSHCHEVRON, iIndex, pvarargIn->lVal);
                hres = S_OK;
            }
            goto Lret;

        case DBID_MAXIMIZEBAND:
            if (pvarargIn && pvarargIn->vt == VT_UI4)
                _MaximizeBand(pvarargIn->ulVal);
            hres = S_OK;
            goto Lret;
#if 1 // { FEATURE: temporary until add cbs::Select() mfunc
        case DBID_SHOWONLY:
            {
                int iCount = _GetBandItemCount();
                
                // pvaIn->punkVal:
                //  punk hide everyone except me
                //  0    hide everyone
                //  1    show everyone
                // FEATURE: we should use pvaIn->lVal not punkVal since we're
                // allowing 0 & 1 !!! (and not doing addref/release)
                ASSERT(pvarargIn && pvarargIn->vt == VT_UNKNOWN);
                if (pvarargIn->punkVal == NULL || pvarargIn->punkVal == (IUnknown*)1)
                    TraceMsg(TF_BANDDD, "cbs.e: (id=DBID_SHOWONLY, punk=%x)", pvarargIn->punkVal);
                // show myself, hide everyone else
                TraceMsg(TF_BANDDD, "cbs.Exec(DBID_SHOWONLY): n=%d", _GetBandItemCount());

                // wait to show this band until we've hidden the others
                CBandItemData *pbidShow = NULL;
                // FEATURE: this (IUnknown*)1 is bogus! Also mentioned above.
                BOOL bShowAll = (pvarargIn->punkVal == (IUnknown*)1);
                for (int i = iCount - 1; i >= 0; i--)
                {
                    CBandItemData *pbid = _GetBandItem(i);
                    if (pbid)
                    {
                        BOOL fShow = bShowAll || SHIsSameObject(pbid->pdb, pvarargIn->punkVal);
                        if (!fShow || bShowAll)
                        {
                            _ShowBand(pbid, fShow);
                        }
                        else
                        {
                            pbidShow = pbid;
                            pbidShow->AddRef();
                        }
                        pbid->Release();
                    }
                }
                if (pbidShow)
                {
                    _ShowBand(pbidShow, TRUE);
                    // nash:37290 set focus to band on open
                    if (_dwShowState == DBC_SHOW)
                        IUnknown_UIActivateIO(pbidShow->pdb, TRUE, NULL);
                    else
                        ASSERT(0);
                    pbidShow->Release();
                }
            }
            break;
#endif // }
        }
    }
    else if (IsEqualIID(*pguidCmdGroup, CGID_Explorer))
    {
        return IUnknown_Exec(_ptbActive, pguidCmdGroup, nCmdID, nCmdexecopt,
                pvarargIn, pvarargOut);
    }
    else if (IsEqualIID(*pguidCmdGroup, CGID_DeskBarClient))
    {
        switch (nCmdID)
        {
        case DBCID_ONDRAG:
            if (pvarargIn->vt == VT_I4)
            {
                ASSERT(pvarargIn->lVal == 0 || pvarargIn->lVal == DRAG_MOVE);
                TraceMsg(DM_TRACE, "cbs.e: DBCID_ONDRAG i=%d", pvarargIn->lVal);
                _fDragging = pvarargIn->lVal;
            }
            break;

        case DBCID_GETBAR:
            // return IUnkown of my IDeskBar host
            if ((pvarargOut != NULL) && _pdb)
            {
                ::VariantInit(pvarargOut);
                V_VT(pvarargOut)      = VT_UNKNOWN;
                V_UNKNOWN(pvarargOut) = _pdb;
                _pdb->AddRef();
                hres = S_OK;
                goto Lret;
            }
            break;
        }
    }


    // if we got here, we didn't handle it
    // see if we should forward it down
    hresTmp = IsExecForward(pguidCmdGroup, nCmdID);
    if (SUCCEEDED(hresTmp) && HRESULT_CODE(hresTmp) > 0)
    {
        // down (singleton or broadcast)
        if (HRESULT_CODE(hresTmp) == OCTD_DOWN)
        {
            // down (singleton)

            hres = IUnknown_Exec(_ptbActive, pguidCmdGroup, nCmdID, nCmdexecopt,
                pvarargIn, pvarargOut);
        }
        else
        {
            // down (broadcast)
            // n.b. hres is a bit weird: 'last one wins'
            // FEATURE: should we just return S_OK?
            ASSERT(HRESULT_CODE(hresTmp) == OCTD_DOWNBROADCAST);

            EXECDATA ctd = { hres, pguidCmdGroup, nCmdID, nCmdexecopt,
                pvarargIn, pvarargOut };

            _BandItemEnumCallback(1, _ExecCallback, &ctd);
            hres = ctd.hres;
        }
    }

Lret:
    return hres;
}

/***    _ShowBand -- show/hide band (cached state, band, and rebar band)
 */
void CBandSite::_ShowBand(CBandItemData *pbid, BOOL fShow)
{
    int i;

    pbid->fShow = BOOLIFY(fShow);
    if (pbid->pdb)
    {
        pbid->pdb->ShowDW(fShow && (_dwShowState == DBC_SHOW));
    }
    
    i = _BandIDToIndex(pbid->dwBandID);
    SendMessage(_hwnd, RB_SHOWBAND, i, fShow);

    // get me a window to draw D&D curosors on. . .
    SHGetTopBrowserWindow(SAFECAST(this, IBandSite*), &_hwndDD);
}


/*----------------------------------------------------------
Purpose: IBandSite::GetBandSiteInfo

*/
HRESULT CBandSite::GetBandSiteInfo(BANDSITEINFO * pbsinfo)
{
    ASSERT(IS_VALID_WRITE_PTR(pbsinfo, BANDSITEINFO));

    if (pbsinfo->dwMask & BSIM_STATE)
        pbsinfo->dwState = _dwMode;

    if (pbsinfo->dwMask & BSIM_STYLE)
        pbsinfo->dwStyle = _dwStyle;

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IBandSite::SetBandSiteInfo

*/
HRESULT CBandSite::SetBandSiteInfo(const BANDSITEINFO * pbsinfo)
{
    ASSERT(IS_VALID_READ_PTR(pbsinfo, BANDSITEINFO));

    if (pbsinfo->dwMask & BSIM_STATE)
        _dwMode = pbsinfo->dwState;

    if (pbsinfo->dwMask & BSIM_STYLE)
    {
        // If the BSIS_SINGLECLICK style changed, change the rebar style
        if ( _hwnd && ((_dwStyle ^ pbsinfo->dwStyle) & BSIS_SINGLECLICK) )
            SHSetWindowBits(_hwnd, GWL_STYLE, RBS_DBLCLKTOGGLE, (pbsinfo->dwStyle & BSIS_SINGLECLICK)?0:RBS_DBLCLKTOGGLE);
            
        _dwStyle = pbsinfo->dwStyle;
    }

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IBandSite::GetBandObject

*/
HRESULT CBandSite::GetBandObject(DWORD dwBandID, REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IDataObject)) 
    {
        *ppvObj = _DataObjForBand(dwBandID);
        if (*ppvObj)
            hres = S_OK;
    }
    else 
    {
        CBandItemData *pbid = _GetBandItemDataStructByID(dwBandID);
        if (pbid)
        {
            if (pbid->pdb)
            {
                hres = pbid->pdb->QueryInterface(riid, ppvObj);
            }
            pbid->Release();
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Returns a pointer to the band item data given an
         externally known band ID.

Returns: NULL if band ID is illegal
*/
CBandItemData* CBandSite::_GetBandItemDataStructByID(DWORD uID)
{
    int iBand = _BandIDToIndex(uID);
    if (iBand == -1)
        return NULL;
    return _GetBandItem(iBand);
}


__inline HRESULT _FwdWinEvent(IWinEventHandler* pweh, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    ASSERT(pweh);
    ASSERT(hwnd == HWND_BROADCAST || pweh->IsWindowOwner(hwnd) == S_OK);

    return pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
}

/*----------------------------------------------------------
Purpose: Forwards messages to the band that owns the window.

Returns: TRUE if the message was forwarded

*/
BOOL CBandSite::_SendToToolband(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    BOOL fSent = FALSE;
    LRESULT lres = 0;

    if (hwnd)
    {
        if (hwnd == _hwndCache)
        {
            ASSERT(hwnd != HWND_BROADCAST);

            if (_pwehCache)
            {
                _FwdWinEvent(_pwehCache, hwnd, uMsg, wParam, lParam, &lres);
                fSent = TRUE;
            }
        }
        else
        {
            CBandItemData *pbid = NULL;
            // pbid ownership is goofy here -- we still have a ref once we break out of the loop.
            for (int i = _GetBandItemCount() - 1; i >= 0; i--)
            {
                if (pbid)
                    pbid->Release();

                pbid = _GetBandItem(i);
                if (pbid)
                {
                    if (pbid->pweh)
                    {
                        if (hwnd == HWND_BROADCAST || 
                          (pbid->pweh->IsWindowOwner(hwnd) == S_OK))
                        {
                            _FwdWinEvent(pbid->pweh, hwnd, uMsg, wParam, lParam, &lres);
                            fSent = TRUE;

                            if (hwnd != HWND_BROADCAST)
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        if (hwnd == HWND_BROADCAST && pbid->hwnd)
                        {
                            lres = SendMessage(pbid->hwnd, uMsg, wParam, lParam);
                            fSent = TRUE;
                        }
                    }
                }
            }

            if (hwnd != HWND_BROADCAST)
            {
                ATOMICRELEASE(_pwehCache);
                _hwndCache = hwnd;
                if (fSent && pbid)
                {
                    _pwehCache = pbid->pweh;
                    _pwehCache->AddRef();
                }
            }
            if (pbid)
                pbid->Release();
        }
    }

    if (plres)
        *plres = lres;
    
    return fSent;
}

typedef struct {
    HWND hwnd;
    HRESULT hres;
} WINDOWOWNERDATA;

int _IsWindowOwnerCallback(CBandItemData *pbid, void *pv)
{
    WINDOWOWNERDATA* pwod = (WINDOWOWNERDATA*)pv;
    
    if (pbid->pweh && (pbid->pweh->IsWindowOwner(pwod->hwnd) == S_OK)) 
    {
        pwod->hres = S_OK;
        return 0;
    }
    return 1;
}

HRESULT CBandSite::IsWindowOwner(HWND hwnd)
{
    if (hwnd == _hwnd)
        return S_OK;
    
    WINDOWOWNERDATA wod = { hwnd, S_FALSE };
    _BandItemEnumCallback(1, _IsWindowOwnerCallback, &wod);
    return wod.hres;
}

//***   CBandSite::IDeskBarClient::* {
HRESULT CBandSite::GetSize(DWORD dwWhich, LPRECT prc)
{
    HRESULT hres = E_FAIL;
    switch (dwWhich)
    {
    case DBC_GS_IDEAL:
        {
            prc->right = 0;
            prc->bottom = 0;
            
            BOOL_PTR fRedraw = SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);
            for (int i = _GetBandItemCount() - 1; i >= 0; i--)
            {
                CBandItemData *pbid = _GetBandItem(i);
                if (pbid)
                {
                    RECT rc;
                    
                    SendMessage(_hwnd, RB_GETBANDBORDERS, _BandIDToIndex(pbid->dwBandID), (LPARAM) &rc);
                    _UpdateBandInfo(pbid, FALSE);
                    
                    if (pbid->fShow)
                    {
                        if (_dwMode & (DBIF_VIEWMODE_FLOATING | DBIF_VIEWMODE_VERTICAL))
                        {
                            prc->right = max(prc->right, pbid->ptActual.x + (rc.left + rc.right));
                            prc->bottom += pbid->ptActual.y + rc.top + rc.bottom;
                        }
                        else
                        {
                            prc->bottom = max(prc->right, pbid->ptActual.x + (rc.left + rc.right));
                            prc->right += pbid->ptActual.y + rc.top + rc.bottom;
                        }
                    }
                    hres = S_OK;
                    pbid->Release();
                }
            }
            SendMessage(_hwnd, WM_SETREDRAW, fRedraw, 0);
        }
        break;
        
    case DBC_GS_SIZEDOWN:
        {
            // Used to make a band change size in chuncks
            SendMessage(_hwnd, RB_SIZETORECT, RBSTR_CHANGERECT, (LPARAM)prc);
            hres = S_OK;
        }
        break;
    }
    return hres;
}


void CBandSite::_Close() 
{        
    if (_hwnd)
    {
        //  (scotth): This method is getting called by the destructor,
        //  and calls _DeleteAllBandItems, which sends messages to _hwnd.
        //  _hwnd is already destroyed by this time.  If you hit this assert
        //  it is because in debug windows it RIPs like crazy.
        // 970508 (adp): pblm was that we weren't doing DestroyWnd etc.
        //  
        //  Do no remove this assert....please fix the root problem.
        ASSERT(IS_VALID_HANDLE(_hwnd, WND));
        SendMessage(_hwnd, WM_SETREDRAW, 0, 0);
        _DeleteAllBandItems(); 

        DestroyWindow(_hwnd);
        _hwnd = 0;
    }
}

    
HRESULT CBandSite::UIActivateDBC(DWORD dwState)
{
    if (dwState != _dwShowState)
    {
        BOOL fShow = dwState;

        _dwShowState = dwState;
        // map UIActivateDBC to ShowDW
        if (DBC_SHOWOBSCURE == dwState)
            fShow = FALSE;

        BOOL_PTR fRedraw = SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);
        for (int i = _GetBandItemCount() - 1; i >= 0; i--)
        {
            CBandItemData *pbid = _GetBandItem(i);
            if (pbid)
            {
                if (pbid->pdb)
                {
                    pbid->pdb->ShowDW(fShow && pbid->fShow);
                }
                pbid->Release();
            }
        }

        // do this now intead of at creation so that 
        // rebar doesn't keep trying to autosize us while
        // we're not even visible
        SHSetWindowBits(_hwnd, GWL_STYLE, RBS_AUTOSIZE, RBS_AUTOSIZE);
        SendMessage(_hwnd, WM_SIZE, 0, 0);
        SendMessage(_hwnd, WM_SETREDRAW, (DBC_SHOW == dwState) ? TRUE : fRedraw, 0);
    }
    return S_OK;
}

DWORD CBandSite::_GetWindowStyle(DWORD* pdwExStyle)
{
    *pdwExStyle = WS_EX_TOOLWINDOW;
    DWORD dwStyle = RBS_REGISTERDROP | RBS_VARHEIGHT | RBS_BANDBORDERS |
                    WS_VISIBLE |  WS_CHILD | WS_CLIPCHILDREN |
                    WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NORESIZE | CCS_NOPARENTALIGN;
    if (_dwStyle & BSIS_LEFTALIGN)
    {
        dwStyle |= RBS_VERTICALGRIPPER;
    }

    if (!(_dwStyle & BSIS_SINGLECLICK))
    {
        dwStyle |= RBS_DBLCLKTOGGLE;
    }

    return dwStyle;
}

HRESULT CBandSite::_Initialize(HWND hwndParent)
{
    //
    //  I hope we have an IBandSite to talk to.
    //
    if (!_pbsOuter)
        return E_FAIL;

    if (!_hwnd) 
    {
        DWORD dwExStyle;
        DWORD dwStyle = _GetWindowStyle(&dwExStyle);

        _hwnd = CreateWindowEx(dwExStyle, REBARCLASSNAME, NULL, dwStyle,
                               0, 0, 0, 0, hwndParent, (HMENU) FCIDM_REBAR, HINST_THISDLL, NULL);

        if (_hwnd)
        {
            SendMessage(_hwnd, RB_SETTEXTCOLOR, 0, CLR_DEFAULT);
            SendMessage(_hwnd, RB_SETBKCOLOR, 0, CLR_DEFAULT);
            SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);
        }
    }
    
    return _hwnd ? S_OK : E_OUTOFMEMORY;
}

HRESULT CBandSite::SetDeskBarSite(IUnknown* punkSite)
{
    HRESULT hr = S_OK;

    if (!punkSite)
    {
        // Time to tell the bands to free their
        // back pointers on us or we never get freed...

        // 970325 for now bs::SetDeskBarSite(NULL) is 'overloaded'
        // to mean do both a CloseDW and a SetSite.
        // when we clean up our act and have a bs::Close iface
        // we'll go back to the '#else' code below.
        if (_hwnd)
            _Close();
    }

    ATOMICRELEASE(_pct);
    ATOMICRELEASE(_pdb);
    ATOMICRELEASE(_punkSite);

    if (_pbp && _fCreatedBandProxy)
        _pbp->SetSite(punkSite);

    if (punkSite)
    {
        _punkSite = punkSite;
        _punkSite->AddRef();

        if (!_hwnd) 
        {
            HWND hwndParent;
            IUnknown_GetWindow(punkSite, &hwndParent);
            hr = _Initialize(hwndParent);
        }

        punkSite->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_pct));
        punkSite->QueryInterface(IID_PPV_ARG(IDeskBar, &_pdb));
    }
    
    return hr;
}

HRESULT CBandSite::SetModeDBC(DWORD dwMode)
{
    if (dwMode != _dwMode)
    {
        _dwMode = dwMode;

        if (_hwnd)
        {
            DWORD dwStyle = 0;
            if (dwMode & (DBIF_VIEWMODE_FLOATING | DBIF_VIEWMODE_VERTICAL))
            {
                dwStyle |= CCS_VERT;
            }
            SHSetWindowBits(_hwnd, GWL_STYLE, CCS_VERT, dwStyle);
        }

        _UpdateAllBands(FALSE, FALSE);
    }
    return S_OK;
}

// }

IDropTarget* CBandSite::_WrapDropTargetForBand(IDropTarget* pdtBand)
{
    if (!pdtBand || (_dwStyle & BSIS_NODROPTARGET))
    {
        // addref it for the new pointer
        if (pdtBand)
            pdtBand->AddRef();
        return pdtBand;
    }
    else
    {
        return DropTargetWrap_CreateInstance(pdtBand, SAFECAST(this, IDropTarget*), _hwndDD);
    }
}

LRESULT CBandSite::_OnNotify(LPNMHDR pnm)
{
    NMOBJECTNOTIFY *pnmon = (NMOBJECTNOTIFY *)pnm;
    
    switch (pnm->code)
    {
    case RBN_GETOBJECT:
    {
        pnmon->hResult = E_FAIL;
        
        // if we're the drag source, then a band is dragging... we want to only
        // give out the bandsite's drop target
        if (pnmon->iItem != -1 && !_fDragSource) 
        {
            CBandItemData *pbid = _GetBandItemDataStructByID(pnmon->iItem);
            if (pbid)
            {
                if (pbid->pdb)
                {
                    pnmon->hResult = pbid->pdb->QueryInterface(*pnmon->piid, &pnmon->pObject);

                    // give a wrapped droptarget instead of the band's droptarget
                    if (IsEqualIID(*pnmon->piid, IID_IDropTarget))
                    {
                        IDropTarget* pdtBand;
                        BOOL fNeedReleasePdtBand = FALSE;

                        if (SUCCEEDED(pnmon->hResult))
                        {
                            pdtBand = (IDropTarget*)(pnmon->pObject);
                        }
                        else
                        {
                            CDropDummy *pdtgt = new CDropDummy(_hwndDD);
                            pdtBand = SAFECAST(pdtgt, IDropTarget*);
                            fNeedReleasePdtBand = TRUE;
                        }

                        IDropTarget* pdt = _WrapDropTargetForBand(pdtBand);
                        if (pdt)
                        {
                            pnmon->pObject = pdt;
                            pnmon->hResult = S_OK;

                            // we've handed off pdtBand to pdt
                            fNeedReleasePdtBand = TRUE;
                        }

                        if (fNeedReleasePdtBand && pdtBand)
                            pdtBand->Release();
                    }

                    if (FAILED(pnmon->hResult) && !(_dwStyle & BSIS_NODROPTARGET)) 
                        pnmon->hResult = QueryInterface(*pnmon->piid, &pnmon->pObject);
                }
                pbid->Release();
            }
        } 
        break;
    }

    case RBN_BEGINDRAG:
        return _OnBeginDrag((NMREBAR*)pnm);

    case RBN_AUTOSIZE:
        _OnRBAutoSize((NMRBAUTOSIZE*)pnm);
        break;

    case RBN_CHEVRONPUSHED:
    {
        LPNMREBARCHEVRON pnmch = (LPNMREBARCHEVRON) pnm;
        CBandItemData *pbid = _GetBandItem(pnmch->uBand);
        if (pbid)
        {
            MapWindowPoints(_hwnd, HWND_DESKTOP, (LPPOINT)&pnmch->rc, 2);
            ToolbarMenu_Popup(_hwnd, &pnmch->rc, pbid->pdb, pbid->hwnd, 0, (DWORD)pnmch->lParamNM);
            pbid->Release();
        }
        break;
    }

    case RBN_AUTOBREAK:
    {
        if (_dwStyle & BSIS_PREFERNOLINEBREAK)
        {
            Comctl32_FixAutoBreak(pnm);
        }
        break;
    }
    }

    return 0;
}

void CBandSite::_OnRBAutoSize(NMRBAUTOSIZE* pnm)
{
    // DRAG_MOVE: we turn off autosize during (most of) a move because
    // fVertical is out of sync until the very end
    if (_pdb && _GetBandItemCount() && _fDragging != DRAG_MOVE)
    {
        RECT rc;
        int iHeightCur;
        int iHeight = (int)SendMessage(_hwnd, RB_GETBARHEIGHT, 0, 0);

#ifdef DEBUG
        DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
#endif

        GetWindowRect(_hwnd, &rc);
        MapWindowRect(HWND_DESKTOP, GetParent(_hwnd), &rc);

        if (_dwMode & (DBIF_VIEWMODE_FLOATING | DBIF_VIEWMODE_VERTICAL))
        {
            ASSERT((dwStyle & CCS_VERT));
            iHeightCur = RECTWIDTH(rc);
            rc.right = rc.left + iHeight;
        }
        else
        {
            ASSERT(!(dwStyle & CCS_VERT));
            iHeightCur = RECTHEIGHT(rc);
            rc.bottom = rc.top + iHeight;
        }

        if ((iHeightCur != iHeight) || (IsOS(OS_WHISTLERORGREATER)))
        {
            _pdb->OnPosRectChangeDB(&rc);
        }
    }
}

IDataObject* CBandSite::_DataObjForBand(DWORD dwBandID)
{
    IDataObject* pdtobjReturn = NULL;

    CBandItemData *pbid = _GetBandItemDataStructByID(dwBandID);
    if (pbid)
    {
        if (pbid->pdb)
        {
            CBandDataObject* pdtobj = new CBandDataObject();
            if (pdtobj)
            {
                if (SUCCEEDED(pdtobj->Init(pbid->pdb, this, dwBandID)))
                {
                    pdtobjReturn = pdtobj;
                    pdtobjReturn->AddRef();
                }            
                pdtobj->Release();
            }
        }
        pbid->Release();
    }
    return pdtobjReturn;
}

LRESULT CBandSite::_OnBeginDrag(NMREBAR* pnm)
{
    LRESULT lres = 0;
    DWORD dwBandID = _IndexToBandID(pnm->uBand);

    IDataObject* pdtobj = _DataObjForBand(dwBandID);

    ATOMICRELEASE(_pdtobj);

    _uDragBand = pnm->uBand;
    _pdtobj = pdtobj;
    // because the RBN_BEGINDRAG is synchronous and so is SHDoDragDrop
    // post this message to ourselves instead of calling dragdrop directly.
    // note that we don't have a window of our own, so we post to our parent
    // and let the message reflector send it back to us
    PostMessage(GetParent(_hwnd), WM_COMMAND, MAKELONG(0, IDM_DRAGDROP), (LPARAM)_hwnd);
    return 1;
}

// return TRUE if the user drags out of the rect of the rebar meaning that we should
// go into ole drag drop.
BOOL CBandSite::_PreDragDrop()
{
    BOOL f = FALSE;
    RECT rc;
    POINT pt;
    DWORD dwBandID = _IndexToBandID(_uDragBand);    // Find the BandID before an reordering that may happen.
    
    GetWindowRect(_hwnd, &rc);
    SetCapture(_hwnd);

    InflateRect(&rc, GetSystemMetrics(SM_CXEDGE) * 3, GetSystemMetrics(SM_CYEDGE) * 3);
    while (GetCapture() == _hwnd)
    {
        MSG msg;
        
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            switch (msg.message)
            {
            case WM_MOUSEMOVE:
                GetCursorPos(&pt);
                if (!ISMOVEDDISABLED(dwBandID))
                {
                    if (PtInRect(&rc, pt))
                    {
                        SendMessage(_hwnd, RB_DRAGMOVE, 0, (LPARAM)-1);
                    } else if (!ISDDCLOSEDISABLED(dwBandID) && _pdtobj)
                    {
                        // we've moved out of the bounds of the rebar..  switch to ole drag
                        f = TRUE;
                        SetCapture(NULL);
                    }
                }
                break;

            case WM_LBUTTONUP:
            case WM_LBUTTONDOWN:
            case WM_MBUTTONUP:
            case WM_MBUTTONDOWN:
            case WM_RBUTTONUP:
            case WM_RBUTTONDOWN:
                // bail on any mouse button action
                SetCapture(NULL);
                break;
                
            case WM_KEYDOWN:
                switch (msg.wParam)
                {
                case VK_ESCAPE:
                    SetCapture(NULL);
                    break;
                }
                // fall through
                
            default:
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    if (ISDDCLOSEDISABLED(dwBandID) || !_IsBandDeleteable(dwBandID))
    {
        /// if don't allow close, never return true for ole drag.
        f = FALSE;
    }

    return f;
}

void CBandSite::_DoDragDrop()
{
    DWORD dwBandID = _IndexToBandID(_uDragBand);
    DWORD dwEffect = DROPEFFECT_MOVE;

    _fDragSource = TRUE;

    SendMessage(_hwnd, RB_BEGINDRAG, _uDragBand, (LPARAM)-2);

    HRESULT hres = S_OK;

    // first check to see if we even need to go into Ole drag, or if
    // it can all be contained within the rebar
    if (_PreDragDrop())
    {
        SHLoadOLE(SHELLNOTIFY_OLELOADED); // Browser Only - our shell32 doesn't know ole has been loaded
        hres = SHDoDragDrop(_hwnd, _pdtobj, NULL, dwEffect, &dwEffect);
    }
    else
    {
        // if we kept it all within win32 dragging, then set no drop effect
        dwEffect = DROPEFFECT_NONE;
    }

    SendMessage(_hwnd, RB_ENDDRAG, 0, 0);
    _fDragSource = FALSE;
    if (dwEffect & DROPEFFECT_MOVE) 
    {
        RemoveBand(dwBandID);
    } 
    else if (!dwEffect && hres == DRAGDROP_S_DROP) 
    {
        // if the drop was done, but the target didn't allow
        // then we float the band.
    }

    ATOMICRELEASE(_pdtobj);
}

HMENU CBandSite::_LoadContextMenu()
{
    return LoadMenuPopup_PrivateNoMungeW(MENU_BANDSITE1);
}

HRESULT CBandSite::_OnBSCommand(int idCmd, DWORD idBandActive, CBandItemData *pbid)
{
    HRESULT hr = S_OK;

    switch (idCmd)
    {
    case BSIDM_CLOSEBAND:
        _OnCloseBand(idBandActive);
        break;

    case BSIDM_SHOWTITLEBAND:
        ASSERT(idBandActive != (DWORD)-1 && pbid);
        if (pbid)
        {
            pbid->fNoTitle = !pbid->fNoTitle;
            _UpdateBandInfo(pbid, FALSE);
        }
        break;

    case BSIDM_IEAK_DISABLE_MOVE:
    case BSIDM_IEAK_DISABLE_DDCLOSE:
        ASSERT(idBandActive != (DWORD)-1);
        if (idBandActive != (DWORD)-1)
        {
            static const int idCmds[]  = { BSIDM_IEAK_DISABLE_MOVE,   BSIDM_IEAK_DISABLE_DDCLOSE  };
            static const int idFlags[] = { BAND_ADMIN_NOMOVE,         BAND_ADMIN_NODDCLOSE        };

            DWORD dwFlag = SHSearchMapInt(idCmds, idFlags, ARRAYSIZE(idCmds), idCmd);
            DWORD dwAdminSettings = _GetAdminSettings(idBandActive);

            // Toggle Setting.
            ToggleFlag(dwAdminSettings, dwFlag);

            // Set Menu Item Check Mark appropriately.
            _SetAdminSettings(idBandActive, dwAdminSettings);
        }
        break;

    default:
        ASSERT(0);
        hr = E_FAIL;
        break;
    }

    return hr;
}

// returns the index of the band hit by lParam using context menu semantics (lParam == -1 for keyboard)
int CBandSite::_ContextMenuHittest(LPARAM lParam, POINT* ppt)
{
    int iBandIndex;

    if (lParam == (LPARAM) -1)
    {
        // Keyboard activation.  Use active band.
        DWORD dwBandID = _BandIDFromPunk(_ptbActive);
        iBandIndex = _BandIDToIndex(dwBandID);

        CBandItemData *pbid = _GetBandItem(iBandIndex);
        if (pbid)
        {
            RECT rc;
            GetWindowRect(pbid->hwnd, &rc);
            ppt->x = rc.left;
            ppt->y = rc.top;
            pbid->Release();
        }
    }
    else
    {
        // Mouse activation.  Figure out which band got clicked.
        RBHITTESTINFO rbht;

        ppt->x = GET_X_LPARAM(lParam);
        ppt->y = GET_Y_LPARAM(lParam);
        rbht.pt = *ppt;
        ScreenToClient(_hwnd, &rbht.pt);
        SendMessage(_hwnd, RB_HITTEST, 0, (LPARAM)&rbht);
        iBandIndex = rbht.iBand;
    }

    return iBandIndex;
}

HRESULT CBandSite::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = S_OK;

    HMENU hmenu = CreatePopupMenu();

    if (hmenu)
    {
        HRESULT hresT;
        int idCmd = 1;
        IContextMenu *pcm, *pcmParent = NULL, *pcmChild = NULL;

        POINT pt;
        int iBandIndex = _ContextMenuHittest(lParam, &pt);

        // map rebar index to band id
        // get band info for that band id
        DWORD idBandActive = _IndexToBandID(iBandIndex);
        CBandItemData *pbid = _GetBandItemDataStructByID(idBandActive);

        //
        // self (top)
        //
        int idCmdBS1 = idCmd;

        HMENU hmenuMe = _LoadContextMenu();
        if (hmenuMe)
        {
            BOOL fDeleteShowTitle = TRUE;
            if (pbid && !(_dwStyle & BSIS_LOCKED))
            {
                DESKBANDINFO dbi;

                CheckMenuItem(hmenuMe, BSIDM_SHOWTITLEBAND,
                    pbid->fNoTitle ? MF_BYCOMMAND|MF_UNCHECKED : MF_BYCOMMAND|MF_CHECKED);
                dbi.dwMask = 0;     // paranoia (and needed for taskband!)
                _GetBandInfo(pbid, &dbi);
                // make sure pbid in sync
                ASSERT((dbi.dwMask & DBIM_TITLE) || pbid->fNoTitle);
                if ((dbi.dwMask & DBIM_TITLE) && _IsEnableTitle(pbid))
                {
                    fDeleteShowTitle = FALSE;
                }
            }

            if (fDeleteShowTitle)
            {
                DeleteMenu(hmenuMe, BSIDM_SHOWTITLEBAND, MF_BYCOMMAND);
            }

            idCmd += Shell_MergeMenus(hmenu, hmenuMe, 0, idCmd, 0x7fff, 0) - (idCmd);
            DestroyMenu(hmenuMe);
        }

        //
        // child
        //
        int idCmdChild = idCmd;

        if (pbid && pbid->pdb)
        {
            // merge in band's menu (at front)
            hresT = pbid->pdb->QueryInterface(IID_PPV_ARG(IContextMenu, &pcmChild));
            if (SUCCEEDED(hresT))
            {
                // 0=at front
                hresT = pcmChild->QueryContextMenu(hmenu, 0, idCmd, 0x7fff, 0);
                if (SUCCEEDED(hresT))
                    idCmd += HRESULT_CODE(hresT);
            }
        }

        //
        // self (bottom)
        //
        int idCmdBS2 = idCmd;

        if (!(_dwStyle & BSIS_NOCONTEXTMENU))
        {
            hmenuMe = LoadMenuPopup_PrivateNoMungeW(MENU_BANDSITE2);
            if (hmenuMe)
            {
                // disable 'Close Band' if it's marked undeleteable
                // nash:17821: don't disable when 0 bands (so user can easily
                // get out of toasted mode)
                if ((idBandActive == (DWORD)-1) || // if mouse not over a band, delete close menu item
                    (!_IsBandDeleteable(idBandActive) ||
                     ISDDCLOSEDISABLED(idBandActive)) ||
                     (_dwStyle & BSIS_LOCKED))
                {
                    DeleteMenu(hmenuMe, BSIDM_CLOSEBAND, MF_BYCOMMAND);
                }

                if (!_fIEAKInstalled)
                {
                    DeleteMenu(hmenuMe, BSIDM_IEAK_DISABLE_DDCLOSE, MF_BYCOMMAND);
                    DeleteMenu(hmenuMe, BSIDM_IEAK_DISABLE_MOVE, MF_BYCOMMAND);
                }
                else
                {
                    DWORD dwAdminSettings = _GetAdminSettings(idBandActive);

                    if (IsFlagSet(dwAdminSettings, BAND_ADMIN_NODDCLOSE))
                        _CheckMenuItem(hmenuMe, BSIDM_IEAK_DISABLE_DDCLOSE, TRUE);

                    if (IsFlagSet(dwAdminSettings, BAND_ADMIN_NOMOVE))
                        _CheckMenuItem(hmenuMe, BSIDM_IEAK_DISABLE_MOVE, TRUE);
                }

                idCmd += Shell_MergeMenus(hmenu, hmenuMe, (UINT) -1, idCmd, 0x7fff, 0) - (idCmd);
                DestroyMenu(hmenuMe);
            }
        }

        //
        // parent
        //
        int idCmdParent = idCmd;
        
        if (_punkSite)
        {
            UINT uFlags = 0;
            ASSERT(_pcm3Parent == NULL);
            if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcm3Parent))))
            {
                uFlags |= CMF_ICM3;
            }

            hresT = _punkSite->QueryInterface(IID_PPV_ARG(IContextMenu, &pcmParent));
            if (SUCCEEDED(hresT))
            {
                // APPCOMPAT: fix parents and kids to handle...
                // we'd like to pass in -1 but not everyone handles that.
                // workaround: use _FixMenuIndex...
                hresT = pcmParent->QueryContextMenu(hmenu, _FixMenuIndex(hmenu, -1), idCmd, 0x7fff, uFlags);

                ASSERT(SUCCEEDED(hresT));
                idCmd += HRESULT_CODE(hresT);
            }
        }

        //
        // do it
        //
        {
            HWND hwndParent = GetParent(_hwnd);
            if (!hwndParent)
                hwndParent = _hwnd;
            idCmd = TrackPopupMenu(hmenu,
                                   TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                                   pt.x, pt.y, 0, hwndParent, NULL);
        }

        if (idCmd)
        {
            // must test from smallest to largest
            ASSERT(idCmdBS1 <= idCmdChild);
            ASSERT(idCmdChild <= idCmdBS2);    // o.w. test in wrong order
            ASSERT(idCmdBS2 <= idCmdParent);

            if ((idCmd>= idCmdBS1) && (idCmd < idCmdChild))
            {
                idCmd -= idCmdBS1;
                hres = _OnBSCommand(idCmd, idBandActive, pbid);
            }
            else if ((idCmd>= idCmdBS2) && (idCmd < idCmdParent))
            {
                idCmd -= idCmdBS2;
                hres = _OnBSCommand(idCmd, idBandActive, pbid);
            }
            else
            {
                // A parent or child command
                if (idCmd < idCmdParent)
                {
                    pcm = pcmChild;
                    idCmd -= idCmdChild;
                }
                else
                {
                    pcm = pcmParent;
                    idCmd -= idCmdParent;
                }

                ASSERT(pcm);

                //
                // Call InvokeCommand
                //
                CMINVOKECOMMANDINFOEX ici =
                {
                    sizeof(CMINVOKECOMMANDINFOEX),
                    0L,
                    _hwnd,
                    (LPSTR)MAKEINTRESOURCE(idCmd),
                    NULL, NULL,
                    SW_NORMAL,
                };

                hres = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
            }
        }

        if (pbid)
            pbid->Release();

        ATOMICRELEASE(_pcm3Parent);

        if (pcmParent)
            pcmParent->Release();
        if (pcmChild)
            pcmChild->Release();
        
        DestroyMenu(hmenu);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent

         Processes messages passed on from the bar.  Forward
         messages to the bands as appropriate.

*/
HRESULT CBandSite::OnWinEvent(HWND h, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    HRESULT hres = E_FAIL;
    HWND hwnd = HWND_BROADCAST;
    
    switch (uMsg)
    {
    case WM_WININICHANGE:
        _UpdateAllBands(FALSE, FALSE);
        goto L_WM_SYSCOLORCHANGE;

    case WM_SYSCOLORCHANGE:
    case WM_PALETTECHANGED:
    L_WM_SYSCOLORCHANGE:
        // propagate to rebar
        if (_hwnd)
            SendMessage(_hwnd, uMsg, wParam, lParam);

        // by not returning here, it will get forwarded to the bands also... 
        break;
        
    case WM_CONTEXTMENU:
        // if it came from the keyboard, wParam is somewhat useless.  it's always out hwnd
        if (IS_WM_CONTEXTMENU_KEYBOARD(lParam))
            hwnd = GetFocus();
        else
            hwnd = (HWND)wParam;
        break;

    case WM_COMMAND:
        hwnd = GET_WM_COMMAND_HWND(wParam, lParam);
        break;
            
    case WM_NOTIFY:
        if (lParam)
            hwnd = ((LPNMHDR)lParam)->hwndFrom;
        break;

    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_MENUCHAR:
        if (_pcm3Parent)
        {
            //
            // If _pcm3Parent, then we've got a context menu up and 
            // an ICM3 client who might care about this message.
            //
            hwnd = _hwnd;
        }
        break;

    default:
        return E_FAIL;
    }
    
    LRESULT lres = 0;
    
    if (hwnd)
    {
        if (_hwnd == hwnd)
        {
            // a message for us
            switch (uMsg)
            {
            case WM_NOTIFY:
                lres = _OnNotify((LPNMHDR)lParam);
                hres = S_OK;
                break;

            case WM_COMMAND:
                switch (GET_WM_COMMAND_CMD(wParam, lParam))
                {
                case IDM_DRAGDROP:
                    _DoDragDrop();
                    break;
                }
                break;

            case WM_INITMENUPOPUP:
            case WM_MEASUREITEM:
            case WM_DRAWITEM:
            case WM_MENUCHAR:
                ASSERT(_pcm3Parent);
                hres = _pcm3Parent->HandleMenuMsg2(uMsg, wParam, lParam, &lres);
                break;
            }
        }
        else
        {
            if (_SendToToolband(hwnd, uMsg, wParam, lParam, &lres))
                hres = S_OK;
        }
    }
    
    
    switch (uMsg)
    {
    case WM_WININICHANGE:
        SendMessage(_hwnd, WM_SIZE, 0, 0);
        break;

    case WM_CONTEXTMENU:
        if (!lres)
            return _OnContextMenu(wParam, lParam);
        break;
    }

    if (plres)
        *plres = lres;
    
    return hres;
}

HRESULT CBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CBandSite *pbs = new CBandSite(pUnkOuter);
    if (pbs)
    {
        *ppunk = pbs->_GetInner();
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

//*** CBandSite::IPersistStream*::* {
//

HRESULT CBandSite::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_RebarBandSite;
    return S_OK;
}

HRESULT CBandSite::IsDirty(void)
{
    ASSERT(0);
    return S_FALSE; // FEATURE: never be dirty?
}

HRESULT CBandSite::_AddBand(IUnknown* punk)
{
    if (_pbsOuter)
    {
        // Give the outer guy first crack
        return _pbsOuter->AddBand(punk);
    }
    else
    {
        return AddBand(punk);
    }
}

//
// Persisted CBandSite, use types that have fixes sizes
//
struct SBandSite
{
    DWORD   cbSize;
    DWORD   cbVersion;
    DWORD   cBands;
    // ...followed by length-preceded bands
};

#define SBS_WOADMIN_VERSION 3   // Before we added admin settings.
#define SBS_VERSION 8

//***   CBandSite::Load, Save -- 
// DESCRIPTION
//  for each band...
//  Load            Read (i); OLFS(obj)+AddBand; Read (rbbi); RB_SBI
//  Save    RB_GBI; Write(i); OSTS(obj)+nil    ; Write(rbbi)
// NOTES
//  FEATURE: needs error recovery
//  WARNING: we might have done a CreateBand w/o an AddBand; if so our
//  assumption about the rebar bands and the iunknowns being 'parallel'
//  is bogus.

HRESULT CBandSite::Load(IStream *pstm)
{
    HRESULT hres;
    SBandSite sfoo;

    hres = IStream_Read(pstm, &sfoo, sizeof(sfoo));     // pstm->Read
    if (hres == S_OK)
    {
        if (!(sfoo.cbSize == sizeof(SBandSite) &&
          (sfoo.cbVersion == SBS_VERSION || sfoo.cbVersion == SBS_WOADMIN_VERSION)))
        {
            hres = E_FAIL;
        }

        IBandSiteHelper *pbsh;
        hres = QueryInterface(IID_PPV_ARG(IBandSiteHelper, &pbsh)); // QI self for aggregation stuff?
        if (SUCCEEDED(hres))
        {
            BOOL_PTR fRedraw = SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);
            for (DWORD i = 0; i < sfoo.cBands && SUCCEEDED(hres); ++i)
            {
                DWORD j;
                hres = IStream_Read(pstm, &j, sizeof(j));   // pstm->Read
                if (hres == S_OK)
                {
                    if (j == i)             // for sanity check
                    {
                        IUnknown* punk;
                        hres = pbsh->LoadFromStreamBS(pstm, IID_PPV_ARG(IUnknown, &punk));
                        if (SUCCEEDED(hres))
                        {
                            hres = _AddBand(punk);
                            if (SUCCEEDED(hres))
                            {
                                hres = _LoadBandInfo(pstm, i, sfoo.cbVersion);
                            }
                            punk->Release();
                        }
                    }
                    else
                    {
                        hres = E_FAIL;
                    }
                }
            }
            SendMessage(_hwnd, WM_SETREDRAW, fRedraw, 0);
            pbsh->Release();
        }
        _UpdateAllBands(FALSE, TRUE);     // force refresh
    }

    return hres;
}

HRESULT CBandSite::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hres;
    SBandSite sfoo;
    
    TraceMsg(DM_PERSIST, "cbs.s enter(this=%x pstm=%x) tell()=%x", this, pstm, DbStreamTell(pstm));

    sfoo.cbSize = sizeof(SBandSite);
    sfoo.cbVersion = SBS_VERSION;
    sfoo.cBands = _GetBandItemCount();
    TraceMsg(DM_PERSIST, "cdb.s: cbands=%d", sfoo.cBands);

    hres = pstm->Write(&sfoo, sizeof(sfoo), NULL);
    if (SUCCEEDED(hres))
    {
        for (DWORD i = 0; i < sfoo.cBands; i++) 
        {
            // FEATURE: put seek ptr so can resync after bogus streams
            hres = pstm->Write(&i, sizeof(i), NULL);    // for sanity check
            if (SUCCEEDED(hres))
            {
                CBandItemData *pbid = _GetBandItem(i);
                if (pbid)
                {
                    if (pbid->pdb)
                    {
                        IBandSiteHelper *pbsh;
                        hres = QueryInterface(IID_PPV_ARG(IBandSiteHelper, &pbsh));
                        if (SUCCEEDED(hres)) 
                        {
                            hres = pbsh->SaveToStreamBS(SAFECAST(pbid->pdb, IUnknown*), pstm);
                            pbsh->Release();
                        }
                    }
                    pbid->Release();
                }

                hres = _SaveBandInfo(pstm, i);
                ASSERT(SUCCEEDED(hres));
            }
        }
    }

    TraceMsg(DM_PERSIST, "cbs.s leave tell()=%x", DbStreamTell(pstm));
    return hres;
}

HRESULT CBandSite::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    // this is supposed to be an UPPER bound but we're returning a lower bound...
    static const ULARGE_INTEGER cbMax = { sizeof(SBandSite), 0 };
    *pcbSize = cbMax;
    return S_OK;
}

BOOL CBandSite::_IsHeightReasonable(UINT cy)
{
    static UINT s_cyMon = 0;
    if (s_cyMon == 0)
    {
        HMONITOR hmon = MonitorFromWindow(_hwnd, MONITOR_DEFAULTTONEAREST);
        if (hmon)
        {
            RECT rc;
            if (GetMonitorRect(hmon, &rc))
            {
                s_cyMon = RECTHEIGHT(rc);
            }
        }
    }

    return (s_cyMon != 0) ? (cy < 4 * s_cyMon) : TRUE;
}

// returns: IStream::Read() semantics, S_OK means complete read

HRESULT CBandSite::_LoadBandInfo(IStream *pstm, int i, DWORD dwVersion)
{
    PERSISTBANDINFO bi;
    HRESULT hres;
    DWORD dwSize = sizeof(bi);
    bi.dwAdminSettings = BAND_ADMIN_NORMAL;     // Assume Normal since it's not specified

    COMPILETIME_ASSERT(sizeof(PERSISTBANDINFO_V3) <= sizeof(PERSISTBANDINFO));
    if (SBS_WOADMIN_VERSION == dwVersion)
        dwSize = sizeof(PERSISTBANDINFO_V3);

    hres = IStream_Read(pstm, &bi, dwSize);     // pstm->Read
    if (hres == S_OK)
    {
        //
        // Sanity-check the height specified by PERSISTBANDINFO before proceeding.
        // Some people are hitting a stress scenario where a bad height gets
        // persisted out.  If the height is not reasonable, then just discard
        // the sizing values (leaving the defaults in place).
        //
        if (_IsHeightReasonable(bi.cyChild))
        {
            REBARBANDINFO rbbi = { 0 };

            rbbi.cbSize = sizeof(rbbi);
            rbbi.fMask = RBBIM_XPERSIST;
            rbbi.cx = bi.cx;
            rbbi.fStyle = bi.fStyle;
            
            // these things can change from instantiation to instantiation.
            // we want to restore the visual state, not the sizing rules.
            // the sizing rules re retreived each time in getbandinfo
            rbbi.cyMinChild = -1;
            rbbi.cyMaxChild = -1;
            rbbi.cyIntegral = -1;
            rbbi.cxMinChild = -1;

            if (rbbi.fStyle & RBBS_VARIABLEHEIGHT)
            {
                rbbi.cyChild = bi.cyChild;
            }
            else
            {
                rbbi.cyMinChild = bi.cyMinChild;
            }

            SendMessage(_hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
        }

        CBandItemData *pbid = _GetBandItem(i);
        if (pbid)
        {
            pbid->dwAdminSettings = bi.dwAdminSettings;
            pbid->fNoTitle = bi.fNoTitle;
            pbid->Release();
        }
    }
    return hres;
}

HRESULT CBandSite::_SaveBandInfo(IStream *pstm, int i)
{
    REBARBANDINFO rbbi = {0};
    PERSISTBANDINFO bi = {0};

    rbbi.cbSize = sizeof(rbbi);
    rbbi.fMask = RBBIM_XPERSIST;
    SendMessage(_hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi);

    ASSERT((rbbi.fMask & RBBIM_XPERSIST) == RBBIM_XPERSIST);

    bi.cx = rbbi.cx;
    bi.fStyle = rbbi.fStyle;
    bi.cyMinChild = rbbi.cyMinChild;
    bi.cyChild = rbbi.cyChild;

    CBandItemData *pbid = _GetBandItem(i);
    if (pbid)
    {
        bi.dwAdminSettings = pbid->dwAdminSettings;
        bi.fNoTitle = pbid->fNoTitle;
        pbid->Release();
    }

    return pstm->Write(&bi, sizeof(bi), NULL);
}

void CBandSite::_CacheActiveBand(IUnknown *ptb)
{
    if (ptb == _ptbActive)
        return;

    if (SHIsSameObject(ptb, _ptbActive))
        return;

    ATOMICRELEASE(_ptbActive);

    if (ptb != NULL) 
    {
#ifdef DEBUG
        // better be an IInputObject or else why did you call us?
        IInputObject *pio;
        if (EVAL(SUCCEEDED(ptb->QueryInterface(IID_PPV_ARG(IInputObject, &pio)))))
            pio->Release();

        // overly strict, but in our case it's true...
        IDeskBand *pdb;
        if (EVAL(SUCCEEDED(ptb->QueryInterface(IID_PPV_ARG(IDeskBand, &pdb)))))
            pdb->Release();
#endif
        _ptbActive = ptb;
        _ptbActive->AddRef();
    }

    return;
}

DWORD CBandSite::_BandIDFromPunk(IUnknown* punk)
{
    DWORD dwBandID = -1;
    DWORD dwBandIDTest;
    int cBands = EnumBands(-1, NULL);
    IUnknown* punkTest;

    if (punk)
    {
        for (int i = 0; i < cBands; i++)
        {
            if (SUCCEEDED(EnumBands(i, &dwBandIDTest)))
            {
                if (SUCCEEDED(GetBandObject(dwBandIDTest, IID_PPV_ARG(IUnknown, &punkTest))))
                {
                    BOOL fEq = SHIsSameObject(punk, punkTest);

                    punkTest->Release();

                    if (fEq)
                    {
                        dwBandID = dwBandIDTest;
                        break;
                    }
                }
            }
        }
    }

    return dwBandID;
}

//*** IInputObjectSite methods ***

HRESULT CBandSite::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    if (_ptbActive)
    {
        if (!SHIsSameObject(_ptbActive, punk))
        {
            // Deactivate current band since the current band is 
            // not the caller
            TraceMsg(TF_ACCESSIBILITY, "CBandSite::OnFocusChangeIS (hwnd=0x%08X) deactivate band", _hwnd);
            UIActivateIO(FALSE, NULL);
        }
    }

    if (fSetFocus)
        _CacheActiveBand(punk);

    return IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), fSetFocus);
}


//*** IInputObject methods ***

HRESULT CBandSite::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT hres = E_FAIL;

    TraceMsg(TF_ACCESSIBILITY, "CBandSite::UIActivateIO (hwnd=0x%08X) fActivate=%d", _hwnd, fActivate);
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    if (_ptbActive)
    {
        hres = IUnknown_UIActivateIO(_ptbActive, fActivate, lpMsg);
    }
    else
    {
        hres = OnFocusChangeIS(NULL, fActivate);
    }

    if (fActivate)
    {
        if (!_ptbActive)
        {
            if (IsVK_TABCycler(lpMsg))
                hres = _CycleFocusBS(lpMsg);
            else
                hres = S_OK;
        }
    }
    else
    {
        _CacheActiveBand(NULL);
    }

    return hres;
}

HRESULT CBandSite::HasFocusIO()
{
    // Rebar should never get focus
    // NT #288832 Is one case where (GetFocus() == _hwnd)
    //    which is caused when the "Folder Bar" disappears.
    //    CExplorerBand::ShowDW() calls ShowWindow(hwndTreeView, SW_HIDE)
    //    which by default sets focus to the parent (us).
    //    This is ok because when this function is called,
    //    it will return E_FAIL which the caller will treat
    //    as S_FALSE and give the focus to the next deserving
    //    dude in line.
    return IUnknown_HasFocusIO(_ptbActive);
}

HRESULT CBandSite::TranslateAcceleratorIO(LPMSG lpMsg)
{
    TraceMsg(TF_ACCESSIBILITY, "CBandSite::TranslateAcceleratorIO (hwnd=0x%08X) key=%d", _hwnd, lpMsg->wParam);
    if (IUnknown_TranslateAcceleratorIO(_ptbActive, lpMsg) == S_OK)
    {
        TraceMsg(TF_ACCESSIBILITY, "CBandSite::TranslateAcceleratorIO (hwnd=0x%08X) key=%d; handled by active band", _hwnd, lpMsg->wParam);
        // active band handled it
        return S_OK;
    }
    else if (IsVK_TABCycler(lpMsg))
    {
        TraceMsg(TF_ACCESSIBILITY, "CBandSite::TranslateAcceleratorIO (hwnd=0x%08X) cycle focus", _hwnd);
        // it's a tab; cycle focus
        return _CycleFocusBS(lpMsg);
    }

    return S_FALSE;
}

int CBandSite::_BandIndexFromPunk(IUnknown *punk)
{
    for (int i = 0; i < _GetBandItemCount(); i++)
    {
        CBandItemData *pbid = _GetBandItem(i);
        if (pbid)
        {
            BOOL fSame = SHIsSameObject(pbid->pdb, punk);
            pbid->Release();
            if (fSame)
            {
                return i;
            }
        }
    }

    return -1;
}

BOOL CBandSite::_IsBandTabstop(CBandItemData *pbid)
{
    // A band is a tabstop if it is visible and has WS_TABSTOP

    if (pbid->fShow && pbid->hwnd && IsWindowVisible(pbid->hwnd))
    {
        if (WS_TABSTOP & GetWindowStyle(pbid->hwnd))
            return TRUE;
    }

    return FALSE;
}

#define INCDEC(i, fDec)   (fDec ? i - 1 : i + 1)

IUnknown* CBandSite::_GetNextTabstopBand(IUnknown* ptb, BOOL fBackwards)
{
    // Find the first tabstop candidate
    int iBandCount = _GetBandItemCount();
    int iBand = _BandIndexFromPunk(ptb);
    
    if (iBand == -1)
    {
        // Start at the end/beginning
        if (fBackwards)
            iBand = iBandCount - 1;
        else
            iBand = 0;
    }
    else
    {
        // Start one off the current band
        iBand = INCDEC(iBand, fBackwards);
    }

    IUnknown *punkRet = NULL;
    BOOL fDone = FALSE;
    // Loop til we find a tabstop band or we run off the end
    while (!fDone && 0 <= iBand && iBand < iBandCount)
    {
        CBandItemData *pbid = _GetBandItem(iBand);
        if (pbid)
        {
            if (_IsBandTabstop(pbid))
            {
                punkRet = pbid->pdb;
                fDone = TRUE;
            }
            pbid->Release();
        }

        // Try the next band
        iBand = INCDEC(iBand, fBackwards);
    }

    return punkRet;
}

HRESULT CBandSite::_CycleFocusBS(LPMSG lpMsg)
{
    HRESULT hr = S_FALSE;

    IUnknown* ptbSave = NULL;

    if (_ptbActive)
    {
        // Save off the active band in ptbSave
        ptbSave = _ptbActive;
        ptbSave->AddRef();

        // Deactivate active band and clear cache
        IUnknown_UIActivateIO(_ptbActive, FALSE, NULL);
        _CacheActiveBand(NULL);
    }

    if (ptbSave && IsVK_CtlTABCycler(lpMsg))
    {
        // If ctl-tab and a band was active, then reject focus
        ASSERT(hr == S_FALSE);
    }
    else
    {
        BOOL fShift = (GetKeyState(VK_SHIFT) < 0);

        // Loop til we find a tabstop and successfully activate it
        // or til we run out of bands.

        // FEATURE: todo -- call SetFocus if UIActivateIO fails?

        IUnknown* ptbNext = ptbSave;
        while (ptbNext = _GetNextTabstopBand(ptbNext, fShift))
        {
            if (IUnknown_UIActivateIO(ptbNext, TRUE, lpMsg) == S_OK)
            {
                hr = S_OK;
                break;
            }
        }
    }

    ATOMICRELEASE(ptbSave);

    return hr;
}

//*** CBandSite::IBandSiteHelper::* {

// stuff to make it possible to overload the OleLoad/Save stuff so the
// taskbar band does not have to be CoCreat able. kinda a hack...

HRESULT CBandSite::LoadFromStreamBS(IStream *pstm, REFIID riid, void **ppv)
{
    return OleLoadFromStream(pstm, riid, ppv);
}

HRESULT CBandSite::SaveToStreamBS(IUnknown *punk, IStream *pstm)
{
    IPersistStream *ppstm;
    HRESULT hres = punk->QueryInterface(IID_PPV_ARG(IPersistStream, &ppstm));
    if (SUCCEEDED(hres)) 
    {
        hres = OleSaveToStream(ppstm, pstm);
        ppstm->Release();
    }
    return hres;
}

// }


// *** IDropTarget *** {

HRESULT CBandSite::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    TraceMsg(TF_BANDDD, "CBandSite::DragEnter %d %d", pt.x, pt.y);

    if (!_fDragSource)
    {
        FORMATETC fmte = {g_cfDeskBand, NULL, 0, -1, TYMED_ISTREAM};
        _dwDropEffect = DROPEFFECT_NONE;
        
        if (pdtobj->QueryGetData(&fmte) == S_OK)
        {
            _dwDropEffect = DROPEFFECT_MOVE;
        }
        else
        {

            LPITEMIDLIST pidl;

            if (SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0)))
            {
                ASSERT(pidl && IS_VALID_PIDL(pidl));

                DWORD dwAttrib = SFGAO_FOLDER | SFGAO_BROWSABLE;
                IEGetAttributesOf(pidl, &dwAttrib);
                ILFree(pidl);

                DWORD   dwRAction;
        
                if (FAILED(IUnknown_HandleIRestrict(_punkSite, &RID_RDeskBars, RA_DROP, NULL, &dwRAction)))
                    dwRAction = RR_ALLOW;

                if (dwRAction == RR_DISALLOW)
                    _dwDropEffect = DROPEFFECT_NONE;
                else
                {                
                    // if it's not a folder nor a browseable object, we can't host it.
                    if ((dwAttrib & SFGAO_FOLDER) ||
                        (dwAttrib & SFGAO_BROWSABLE) && (grfKeyState & (MK_CONTROL | MK_SHIFT)) == (MK_CONTROL | MK_SHIFT)) 
                        _dwDropEffect = DROPEFFECT_LINK | DROPEFFECT_COPY;

                    _dwDropEffect |= GetPreferedDropEffect(pdtobj);
                }
            }
        }
        *pdwEffect &= _dwDropEffect;
    }
    
    return S_OK;
}

HRESULT CBandSite::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    TraceMsg(TF_BANDDD, "CBandSite::DragOver %d %d", ptl.x, ptl.y);
    if (_fDragSource)
    {
        RECT rc;
        POINT pt;
        pt.x = ptl.x;
        pt.y = ptl.y;
        GetWindowRect(_hwnd, &rc);
        if (PtInRect(&rc, pt))
            SendMessage(_hwnd, RB_DRAGMOVE, 0, (LPARAM)-1);
    }
    else
    {
        *pdwEffect &= _dwDropEffect;
    }
    return S_OK;    
}

HRESULT CBandSite::DragLeave(void)
{
    return S_OK;
}

HRESULT CBandSite::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hres = E_FAIL;
    
    TraceMsg(TF_BANDDD, "CBandSite::Drop");
    if (_fDragSource)
    {
        SendMessage(_hwnd, RB_ENDDRAG, 0, 0);
        *pdwEffect = DROPEFFECT_NONE;
        hres = S_OK;
    }
    else
    {
        FORMATETC fmte = {g_cfDeskBand, NULL, 0, -1, TYMED_ISTREAM};
        STGMEDIUM stg;
        IUnknown *punk = NULL;
        LPITEMIDLIST pidl;
        
        // if it was an object of our type, create it!
        if ((*pdwEffect & DROPEFFECT_MOVE) &&
            SUCCEEDED(pdtobj->GetData(&fmte, &stg)))
        {

            hres = OleLoadFromStream(stg.pstm, IID_PPV_ARG(IUnknown, &punk));
            if (SUCCEEDED(hres))
            {
                *pdwEffect = DROPEFFECT_MOVE;
            }

            ReleaseStgMedium(&stg);
        } 
        else if ((*pdwEffect & (DROPEFFECT_COPY | DROPEFFECT_LINK)) &&
                 SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0)))
        {

            hres = SHCreateBandForPidl(pidl, &punk, (grfKeyState & (MK_CONTROL | MK_SHIFT)) == (MK_CONTROL | MK_SHIFT));
            ILFree(pidl);

            if (SUCCEEDED(hres))
            {
                if (*pdwEffect & DROPEFFECT_LINK)
                    *pdwEffect = DROPEFFECT_LINK;
                else
                    *pdwEffect = DROPEFFECT_COPY;
            }
        }
    
        if (punk)
        {
            hres = _AddBand(punk);

            if (SUCCEEDED(hres))
            {
                DWORD dwState;

                dwState = IDataObject_GetDeskBandState(pdtobj);
                SetBandState(ShortFromResult(hres), BSSF_NOTITLE, dwState & BSSF_NOTITLE);
            }

            punk->Release();
        }
    }
    
    if (FAILED(hres)) 
        *pdwEffect = DROPEFFECT_NONE;
    return hres;
}

// }

//***   ::_MergeBS -- merge two bandsites into one
// ENTRY/EXIT
//  pdtDst  [INOUT] destination DropTarget (always from bandsite)
//  pbsSrc  [INOUT] source bandsite; deleted if all bands moved successfully
//  ret     S_OK if all bands moved; S_FALSE if some moved; E_* o.w.
// NOTES
//  note that if all the bands are moved successfully, pbsSrc will be deleted
//  as a side-effect.
//  pdtDst is assumed to accept multiple drops (bandsite does).
//  pdtDst may be from marshal/unmarshal (tray bandsite).
HRESULT _MergeBS(IDropTarget *pdtDst, IBandSite *pbsSrc)
{
    HRESULT hres = E_FAIL;
    DWORD idBand;

    pbsSrc->AddRef();           // don't go away until we're all done!

    // drag each band in turn
    while (SUCCEEDED(pbsSrc->EnumBands(0, &idBand)))
    {
        // note our (bogus?) assumption that bands which can't be
        // dragged will percolate down to a contiguous range of
        // iBands 0..n.  if that's bogus i'm not sure how we can
        // keep track of where we are.

        IDataObject *pdoSrc;
        hres = pbsSrc->GetBandObject(idBand, IID_PPV_ARG(IDataObject, &pdoSrc));
        if (SUCCEEDED(hres))
        {
            DWORD dwEffect = DROPEFFECT_MOVE | DROPEFFECT_COPY;
            hres = SHSimulateDrop(pdtDst, pdoSrc, 0, NULL, &dwEffect);
            pdoSrc->Release();

            if (SUCCEEDED(hres) && (dwEffect & DROPEFFECT_MOVE))
            {
                hres = pbsSrc->RemoveBand(idBand);
                ASSERT(SUCCEEDED(hres));
            }
        }

        // we failed to move the band, bail

        if (FAILED(hres))
        {
            ASSERT(0);
            break;
        }
    }

    pbsSrc->Release();

    TraceMsg(DM_DRAG, "dba.ms: ret hres=%x", hres);
    return hres;
}


void CBandSite::_BandItemEnumCallback(int dincr, PFNBANDITEMENUMCALLBACK pfnCB, void *pv)
{
    UINT iFirst = 0;

    ASSERT(dincr == 1 || dincr == -1);
    if (dincr < 0)
    {
        iFirst = _GetBandItemCount() - 1;  // start from last
    }

    for (UINT i = iFirst; i < (UINT) _GetBandItemCount(); i += dincr)
    {
        CBandItemData *pbid = _GetBandItem(i);
        if (pbid)
        {
            BOOL fStop = !pfnCB(pbid, pv);
            pbid->Release();
            if (fStop)
                break;
        }
    }
}

void CBandSite::_DeleteAllBandItems()
{
    for (int i = _GetBandItemCount() - 1; i >= 0; i--)
    {
        CBandItemData *pbid = _GetBandItem(i);

        // Release the banditem data first, while it can still
        // receive cleanup notifications from its control.  *Then*
        // delete the band item.
        if (pbid)
        {
            _ReleaseBandItemData(pbid, i);
            pbid->Release();
        }

        // REARCHITECT: chrisfra 5/13/97 if you skip deleting, rebar can
        // rearrange on delete, moving a band so that it is never seen
        // and consequently we leak BrandBand and much else
        _DeleteBandItem(i);    // unhook from host (rebar)
    }
}

CBandItemData *CBandSite::_GetBandItem(int i)
{
    REBARBANDINFO rbbi = { 0 };
    rbbi.cbSize = sizeof(rbbi);
    rbbi.fMask = RBBIM_LPARAM;
    rbbi.lParam = NULL; // in case of failure below

    if (_hwnd)
        SendMessage(_hwnd, RB_GETBANDINFO, i, (LPARAM)&rbbi);

    CBandItemData *pbid = (CBandItemData *)rbbi.lParam;
    if (pbid)
    {
        pbid->AddRef();
    }
    return pbid;
}

int CBandSite::_GetBandItemCount()
{
    int cel = 0;

    if (_hwnd)
    {
        ASSERT(IS_VALID_HANDLE(_hwnd, WND));

        cel = (int)SendMessage(_hwnd, RB_GETBANDCOUNT, 0, 0);
    }
    return cel;
}

void CBandSite::_GetBandInfo(CBandItemData *pbid, DESKBANDINFO *pdbi)
{
    pdbi->dwMask = DBIM_MINSIZE | DBIM_MAXSIZE | DBIM_INTEGRAL | DBIM_ACTUAL | DBIM_TITLE | DBIM_MODEFLAGS | DBIM_BKCOLOR;
                 
    pdbi->ptMinSize = pbid->ptMinSize;
    pdbi->ptMaxSize = pbid->ptMaxSize;
    pdbi->ptIntegral = pbid->ptIntegral;
    pdbi->ptActual = pbid->ptActual;
    StrCpyNW(pdbi->wszTitle, pbid->szTitle, ARRAYSIZE(pdbi->wszTitle));
    pdbi->dwModeFlags = pbid->dwModeFlags;
    pdbi->crBkgnd = pbid->crBkgnd;
    
    if (pbid->pdb)
    {
        pbid->pdb->GetBandInfo(pbid->dwBandID, _dwMode, pdbi);
    }
    if (pdbi->wszTitle[0] == 0)
    {
        pdbi->dwMask &= ~DBIM_TITLE;
    }

    pbid->ptMinSize = pdbi->ptMinSize;
    pbid->ptMaxSize = pdbi->ptMaxSize;
    pbid->ptIntegral = pdbi->ptIntegral;
    pbid->ptActual = pdbi->ptActual;
    StrCpyNW(pbid->szTitle, pdbi->wszTitle, ARRAYSIZE(pbid->szTitle));
    pbid->dwModeFlags = pdbi->dwModeFlags;
    pbid->crBkgnd = pdbi->crBkgnd;

    if (!(pdbi->dwMask & DBIM_TITLE))   // title not supported
        pbid->fNoTitle = TRUE;

    ASSERT(pdbi->dwModeFlags & DBIMF_VARIABLEHEIGHT ? pbid->ptIntegral.y : TRUE);
}

void CBandSite::_BandInfoFromBandItem(REBARBANDINFO *prbbi, CBandItemData *pbid, BOOL fBSOnly)
{
    // REVIEW: could be optimized more
    DESKBANDINFO dbi;

    if (!fBSOnly)
        _GetBandInfo(/*INOUT*/ pbid, &dbi);

    // now add the view as a band in the rebar
    // add links band
    prbbi->fMask = RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_STYLE | RBBIM_ID | RBBIM_IDEALSIZE | RBBIM_TEXT;
    if (fBSOnly)
        prbbi->fMask = RBBIM_STYLE|RBBIM_TEXT;

    // clear the bits the are band settable
    prbbi->fStyle |= RBBS_FIXEDBMP;
    prbbi->fStyle &= ~(RBBS_NOGRIPPER | RBBS_GRIPPERALWAYS | RBBS_VARIABLEHEIGHT | RBBS_USECHEVRON);

    if (_dwStyle & BSIS_NOGRIPPER)    
        prbbi->fStyle |= RBBS_NOGRIPPER;
    else if (_dwStyle & BSIS_ALWAYSGRIPPER)    
        prbbi->fStyle |= RBBS_GRIPPERALWAYS;
    else
    {
        // BSIS_AUTOGRIPPER...
        if (!(prbbi->fStyle & RBBS_FIXEDSIZE) &&
            !(_dwMode & DBIF_VIEWMODE_FLOATING))
            prbbi->fStyle |= RBBS_GRIPPERALWAYS;
    }

    if (pbid->dwModeFlags & DBIMF_VARIABLEHEIGHT) 
        prbbi->fStyle |= RBBS_VARIABLEHEIGHT;

    if (pbid->dwModeFlags & DBIMF_USECHEVRON)
        prbbi->fStyle |= RBBS_USECHEVRON;

    if (pbid->dwModeFlags & DBIMF_BREAK)
        prbbi->fStyle |= RBBS_BREAK;

    if (pbid->dwModeFlags & DBIMF_TOPALIGN)
        prbbi->fStyle |= RBBS_TOPALIGN;

    if (!fBSOnly)
    {
        prbbi->hwndChild = pbid->hwnd;
        prbbi->wID = pbid->dwBandID;

        // set up the geometries
        prbbi->cxMinChild = pbid->ptMinSize.x;
        prbbi->cyMinChild = pbid->ptMinSize.y;
        prbbi->cyMaxChild = pbid->ptMaxSize.y;
        prbbi->cyIntegral = pbid->ptIntegral.y;

        if (_dwMode & (DBIF_VIEWMODE_FLOATING | DBIF_VIEWMODE_VERTICAL)) 
        {
            // after we're up, it's the "ideal" point
            prbbi->cxIdeal = pbid->ptActual.y;
        } 
        else 
        {
            // after we're up, it's the "ideal" point
            prbbi->cxIdeal = pbid->ptActual.x;
        }

        if (prbbi->cxIdeal == (UINT)-1)
            prbbi->cxIdeal = 0;

        if (pbid->dwModeFlags & DBIMF_BKCOLOR)
        {
            if (dbi.dwMask & DBIM_BKCOLOR)
            {
                prbbi->fMask |= RBBIM_COLORS;
                prbbi->clrFore = CLR_DEFAULT;
                prbbi->clrBack = dbi.crBkgnd;
            }
        }
        ASSERT(pbid->fNoTitle || (dbi.dwMask & DBIM_TITLE));    // pbid in sync?
    }

    SHUnicodeToTChar(pbid->szTitle, prbbi->lpText, prbbi->cch);
    if (!pbid->fNoTitle && _IsEnableTitle(pbid) && !(_dwStyle & BSIS_NOCAPTION))
    {
        prbbi->fStyle &= ~RBBS_HIDETITLE;
    }
    else
    {
        // No text please
        prbbi->fStyle |= RBBS_HIDETITLE;
    }
        

    // Make this band a tabstop.  Itbar will override v_SetTabstop
    // since for the browser we don't want every band to be a tabstop.
    v_SetTabstop(prbbi);
}

void CBandSite::v_SetTabstop(LPREBARBANDINFO prbbi)
{
    // We specify that a band should be a tabstop by setting the WS_TABSTOP
    // bit.  Never make RBBS_FIXEDSIZE bands (i.e., the brand) tabstops.
    if (prbbi && prbbi->hwndChild && !(prbbi->fStyle & RBBS_FIXEDSIZE))
        SHSetWindowBits(prbbi->hwndChild, GWL_STYLE, WS_TABSTOP, WS_TABSTOP);
}

//***   cbs::_IsEnableTitle -- should we enable (ungray) title
// DESCRIPTION
//  used for handing back title and for enabling menu
// NOTES
//  pbid unused...
//
#ifndef UNIX
_inline
#endif
BOOL CBandSite::_IsEnableTitle(CBandItemData *pbid)
{
    ASSERT(pbid);
    return (/*pbid && !pbid->fNoTitle &&*/
      !((_dwMode & DBIF_VIEWMODE_FLOATING) && _GetBandItemCount() <= 1));
}

BOOL CBandSite::_UpdateBandInfo(CBandItemData *pbid, BOOL fBSOnly)
{
    REBARBANDINFO rbbi = {sizeof(rbbi)};
    int iRB = _BandIDToIndex(pbid->dwBandID);

    // now update the info
    rbbi.fMask = RBBIM_ID | RBBIM_CHILDSIZE | RBBIM_SIZE | RBBIM_STYLE;
    if (fBSOnly)
        rbbi.fMask = RBBIM_STYLE;

    SendMessage(_hwnd, RB_GETBANDINFO, iRB, (LPARAM)&rbbi);

    if (!fBSOnly)
    {
        if (_dwMode & (DBIF_VIEWMODE_FLOATING | DBIF_VIEWMODE_VERTICAL)) 
        {
            pbid->ptActual.x = rbbi.cyChild;
            pbid->ptActual.y = rbbi.cxIdeal;
        } 
        else 
        {
            pbid->ptActual.x = rbbi.cxIdeal;
            pbid->ptActual.y = rbbi.cyChild;
        }
        pbid->ptMinSize.x = rbbi.cxMinChild;
        pbid->ptMinSize.y = rbbi.cyMinChild;
        pbid->ptMaxSize.y = rbbi.cyMaxChild;
    }

    TCHAR szBand[40];
    rbbi.lpText = szBand;
    rbbi.cch = ARRAYSIZE(szBand);

    _BandInfoFromBandItem(&rbbi, pbid, fBSOnly);
    
    return BOOLFROMPTR(SendMessage(_hwnd, RB_SETBANDINFO, (UINT)iRB, (LPARAM)&rbbi));
}

BOOL CBandSite::_AddBandItem(CBandItemData *pbid)
{
    REBARBANDINFO rbbi = {sizeof(rbbi)};

    pbid->ptActual.x = -1;
    pbid->ptActual.y = -1;

    TCHAR szBand[40];
    rbbi.lpText = szBand;
    rbbi.cch = ARRAYSIZE(szBand);

    _BandInfoFromBandItem(&rbbi, pbid, FALSE);

    rbbi.cyChild = pbid->ptActual.y;
    rbbi.fMask |= RBBIM_LPARAM;
    rbbi.lParam = (LPARAM)pbid;

    ASSERT(rbbi.fMask & RBBIM_ID);

    return BOOLFROMPTR(SendMessage(_hwnd, RB_INSERTBAND, (UINT) (pbid->dwModeFlags & DBIMF_ADDTOFRONT) ? 0 : -1, (LPARAM)&rbbi));
}

void CBandSite::_DeleteBandItem(int i)
{
    SendMessage(_hwnd, RB_DELETEBAND, i, 0);
}

DWORD CBandSite::_IndexToBandID(int i)
{
    REBARBANDINFO rbbi = {sizeof(rbbi)};
    rbbi.fMask = RBBIM_ID;

    if (SendMessage(_hwnd, RB_GETBANDINFO, i, (LPARAM)&rbbi))
        return rbbi.wID;
    else
        return -1;
}


/*----------------------------------------------------------
Purpose: Given the band ID, returns the internal band index.

*/
int CBandSite::_BandIDToIndex(DWORD dwBandID)
{
    int nRet = -1;

    if (_hwnd)
        nRet = (int)SendMessage(_hwnd, RB_IDTOINDEX, (WPARAM) dwBandID, (LPARAM) 0);
    return nRet;
}


/*----------------------------------------------------------
Purpose: The Parent Site may want to override what the admin
         specified.

Return Values:
    S_OK: Do lock band.
    S_FALSE: Do NOT Lock band.

*/
HRESULT CBandSite::_IsRestricted(DWORD dwBandID, DWORD dwRestrictAction, DWORD dwBandFlags)
{
    HRESULT hr;
    DWORD dwRestrictionAction;

    hr = IUnknown_HandleIRestrict(_punkSite, &RID_RDeskBars, dwRestrictAction, NULL, &dwRestrictionAction);
    if (RR_NOCHANGE == dwRestrictionAction)    // If our parent didn't handle it, we will.
        dwRestrictionAction = IsFlagSet(_GetAdminSettings(dwBandID), dwBandFlags) ? RR_DISALLOW : RR_ALLOW;

    if (RR_DISALLOW == dwRestrictionAction)
        hr = S_OK;
    else
        hr = S_FALSE;

    ASSERT(SUCCEEDED(hr));  // FAIL(hr) other than hr == E_NOTIMPLE; is not good.
    return hr;
}

BOOL ConfirmRemoveBand(HWND hwnd, UINT uID, LPCTSTR pszName)
{
    TCHAR szTemp[1024], szTitle[80];
    BOOL bRet = TRUE;

    MLLoadString(IDS_CONFIRMCLOSETITLE, szTitle, ARRAYSIZE(szTitle));

    // Calling FormatMessage with FORMAT_MESSAGE_FROM_HMODULE fails
    MLLoadString(uID, szTemp, ARRAYSIZE(szTemp));

    DWORD cchLen = lstrlen(szTemp) + lstrlen(pszName) + 1;
    LPTSTR pszTemp2 = (TCHAR *)LocalAlloc(LPTR, cchLen * sizeof(TCHAR));
    if (pszTemp2 != NULL)
    {
        _FormatMessage(szTemp, pszTemp2, cchLen, pszName);

        MLLoadString(IDS_CONFIRMCLOSETEXT, szTemp, ARRAYSIZE(szTemp));

        cchLen = lstrlen(szTemp) + lstrlen(pszTemp2) + 1;
        LPTSTR pszStr = (TCHAR *)LocalAlloc(LPTR, cchLen * sizeof(TCHAR));
        if (pszStr != NULL)
        {
            _FormatMessage(szTemp, pszStr, cchLen, pszTemp2);

            bRet = (IDOK == SHMessageBoxCheck(hwnd, pszStr, szTitle, MB_OKCANCEL, IDOK, TEXT("WarnBeforeCloseBand")));

            LocalFree(pszStr);
        }

        LocalFree(pszTemp2);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\brand.h ===
#ifndef __BRANDBAR_H__
#define __BRANDBAR_H__

#include "bands.h"

void Brand_InitBrandContexts();

#endif // __BRANDBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\browband.cpp ===
#include "priv.h"
#include "sccls.h"
#include "bands.h"
#include "util.h"
#include "resource.h"
#include "dhuihand.h"
#include "droptgt.h"
#include "iface.h"
#include "isfband.h"
#include "itbdrop.h"
#include "browband.h"
#include <varutil.h>
#include "legacy.h"
#include "mnbandid.h"

#include "mluisupp.h"

#include "inetsmgr.h"

#define DM_PERSIST      0           // trace IPS::Load, ::Save, etc.
#define DM_MENU         0           // menu code
#define DM_FOCUS        0           // focus
#define DM_FOCUS2       0           // like DM_FOCUS, but verbose

//***   CBrowserBand {
//

////////////////
///  BrowserOC band

CBrowserBand::CBrowserBand() :
    CToolBand()
{
    _fBlockSIDProxy = TRUE;
    _dwModeFlags = DBIMF_FIXEDBMP | DBIMF_VARIABLEHEIGHT;
    _sizeMin.cx = _sizeMin.cy = 0;
    _sizeMax.cx = _sizeMax.cy = 32000;
    _fCustomTitle = FALSE;
    return;
}

CBrowserBand::~CBrowserBand()
{
    if (_pidl)
        ILFree(_pidl);

}

HRESULT CBrowserBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CBrowserBand, IContextMenu),          // IID_IContextMenu
        QITABENT(CBrowserBand, IWinEventHandler),      // IID_IWinEventHandler
        QITABENT(CBrowserBand, IDispatch),             // IID_IDispatch
        QITABENT(CBrowserBand, IPersistPropertyBag),   // IID_IPersistPropertyBag
        QITABENT(CBrowserBand, IBrowserBand),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
        hres = CToolBand::QueryInterface(riid, ppvObj);

    return hres;
}

HRESULT CBrowserBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CBrowserBand * p = new CBrowserBand();
    if (p) 
    {
        *ppunk = SAFECAST(p, IDeskBand *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

HRESULT SHCreateBandForPidl(LPCITEMIDLIST pidl, IUnknown** ppunk, BOOL fAllowBrowserBand)
{
    IDeskBand *ptb = NULL;
    BOOL fBrowserBand;    
    DWORD dwAttrib = SFGAO_FOLDER | SFGAO_BROWSABLE;
    
    // if it's on the file system, we still might want to create a browser
    // band if it's a docobj (including .htm file)
    IEGetAttributesOf(pidl, &dwAttrib);    
    switch (dwAttrib & (SFGAO_FOLDER | SFGAO_BROWSABLE))
    {  
    case (SFGAO_FOLDER | SFGAO_BROWSABLE):
        TraceMsg(TF_WARNING, "SHCreateBandForPidl() Find out what the caller wants.  Last time we checked, nobody would set this - what does the caller want?");
    case SFGAO_BROWSABLE:
        fBrowserBand = TRUE;
        break;

    case SFGAO_FOLDER:
        fBrowserBand = FALSE;
        break;
        
    default:
        // if it's not a folder nor a browseable object, we can't host it.
        // Happens when use drags a text file and we want to turn off the
        // drop to create a band.
        return E_FAIL;

    }
    
    // this was a drag of a link or folder
    if (fBrowserBand)
    {
        if (fAllowBrowserBand)
        {
            // create browser to show web sites                        
            ptb = CBrowserBand_Create(pidl);
        }
    }
    else
    {
        // create an ISF band to show folders as hotlinks
        CISFBand_CreateEx(NULL, pidl, IID_PPV_ARG(IDeskBand, &ptb));
    }

    *ppunk = ptb;

    if (ptb)
        return S_OK;

    return E_OUTOFMEMORY;

}


HRESULT CBrowserBand::CloseDW(DWORD dw)
{
    _Connect(FALSE);
    
    return CToolBand::CloseDW(dw);
}

void CBrowserBand::_Connect(BOOL fConnect)
{
    ConnectToConnectionPoint(SAFECAST(this, IDeskBand*), DIID_DWebBrowserEvents2, fConnect, 
                             _pauto, &_dwcpCookie, NULL);
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch::Invoke
/////////////////////////////////////////////////////////////////////////////
HRESULT CBrowserBand::Invoke
(
    DISPID          dispidMember,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    UINT *          puArgErr
)
{
    ASSERT(pdispparams);
    if(!pdispparams)
        return E_INVALIDARG;

    //
    // NOTES: If we have a custom title, we don't need to process this call.
    //  This code assumes DISPID_TITLECHANGE is the only id we support.
    //  If somebody add any other, move this check below. 
    //  
    if (_fCustomTitle)
        return (S_OK);

    switch (dispidMember)
    {
    case DISPID_TITLECHANGE:
    {
        int iArg = pdispparams->cArgs -1;
        if (iArg == 0 &&
            (pdispparams->rgvarg[iArg].vt == VT_BSTR)) {

            BSTR pTitle = pdispparams->rgvarg[iArg].bstrVal;
            StringCchCopy(_wszTitle, ARRAYSIZE(_wszTitle), pTitle);
            _BandInfoChanged();
        }
        break;
    }
    }

    return S_OK;
}


/////  impl of IServiceProvider
HRESULT CBrowserBand::QueryService(REFGUID guidService,
                                  REFIID riid, void **ppvObj)
{
    *ppvObj = NULL; // assume error

    if (_fBlockSIDProxy && IsEqualGUID(guidService, SID_SProxyBrowser)) {
        return E_FAIL;
    } 
    else if (IsEqualGUID(guidService, SID_STopFrameBrowser)) {
        // block this so SearchBand doesn't end up in global history
        return E_FAIL;
    }
    else if (_fBlockDrop && IsEqualGUID(guidService, SID_SDropBlocker))
    {
        return QueryInterface(riid, ppvObj);
    }

    return CToolBand::QueryService(guidService, riid, ppvObj);
}


HRESULT CBrowserBand::SetSite(IUnknown* punkSite)
{
    
    CToolBand::SetSite(punkSite);

    if (punkSite != NULL) {
        
        if (!_hwnd)
            _CreateOCHost();
    } else {

        ATOMICRELEASE(_pauto);
        ATOMICRELEASE(_poipao);
    }

    return S_OK;
}

//***   CBrowserBand::IInputObject::* {

HRESULT CBrowserBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
#ifdef DEBUG
    if (lpMsg && lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_F12) {
        // temp debug test code
        _DebugTestCode();
    }
#endif

    if (_poipao)
        return _poipao->TranslateAccelerator(lpMsg);

    return S_FALSE;
}

HRESULT CBrowserBand::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    int iVerb = fActivate ? OLEIVERB_UIACTIVATE : OLEIVERB_INPLACEACTIVATE;

    HRESULT hr = OCHost_DoVerb(_hwnd, iVerb, lpMsg);

    // OCHost UIActivate is different than IInputObject::UIActivateIO.  It
    // doesn't do anything with the lpMsg parameter.  So, we need to pass
    // it to them via TranslateAccelerator.  Since the only case we care
    // about is when they're getting tabbed into (we want them to highlight
    // the first/last link), just do this in the case of a tab.  However,
    // don't give it to them if it's a ctl-tab.  The rule is that you shouldn't
    // handle ctl-tab when UI-active (ctl-tab switches between contexts), and
    // since Trident is always UI-active (for perf?), they'll always reject
    // ctl-tab.

    if (IsVK_TABCycler(lpMsg) && !IsVK_CtlTABCycler(lpMsg) && _poipao)
        hr = _poipao->TranslateAccelerator(lpMsg);

    return hr;
}

// }

//***   CBrowserBand::IOleCommandTarget::* {

HRESULT CBrowserBand::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return MayQSForward(_pauto, OCTD_DOWN, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

HRESULT CBrowserBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    //  These are broadcast messages to the TRIDENT doc for GUID CGID_MSTHML
    if (pguidCmdGroup && IsEqualGUID(CGID_ExplorerBarDoc, *pguidCmdGroup))
    {
        if (_pauto)
        {
            LPTARGETFRAME2 ptgf;

            if (SUCCEEDED(_pauto->QueryInterface(IID_PPV_ARG(ITargetFrame2, &ptgf))))
            {
                LPOLECONTAINER pocDoc;
                if (SUCCEEDED(ptgf->GetFramesContainer(&pocDoc)) && pocDoc)
                {
                    IUnknown_Exec(pocDoc, &CGID_MSHTML, nCmdID, nCmdexecopt, 
                                    pvarargIn, pvarargOut);
                    pocDoc->Release();
                }
                ptgf->Release();
            }
        }
        return S_OK;
    }
    else
    {
        return MayExecForward(_pauto, OCTD_DOWN, pguidCmdGroup, nCmdID, nCmdexecopt,
            pvarargIn, pvarargOut);
    }
}

// }

HRESULT CBrowserBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                DESKBANDINFO* pdbi) 
{

    _dwBandID = dwBandID;

    // nt5:192868 make sure can't size to smaller than title/scrollbars
    // n.b. virt pdbi->pt.x,y is really phys y,x (i.e. phys long,short)
    pdbi->ptMinSize.x = _sizeMin.cx;
    pdbi->ptMinSize.y = max(16, _sizeMin.cy);   // FEATURE: 16 is bogus
#ifdef DEBUG
    if (pdbi->ptMinSize.x != 0 || pdbi->ptMinSize.y != 0)
        TraceMsg(DM_TRACE, "cbb.gbi: ptMinSize.(x,y)=%x,%x", pdbi->ptMinSize.x, pdbi->ptMinSize.y);
#endif
    pdbi->ptMaxSize.x = _sizeMax.cx;
    pdbi->ptMaxSize.y = _sizeMax.cy;
    pdbi->dwModeFlags = _dwModeFlags;

    pdbi->ptActual.y = -1;
    pdbi->ptActual.x = -1;
    pdbi->ptIntegral.y = 1;
    
    if (_wszTitle[0]) {
        StringCchCopy(pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle), _wszTitle);
    } else if ( _fCustomTitle) {
        pdbi->dwMask &= ~DBIM_TITLE;
    }    
    else{
        SHGetNameAndFlagsW(_pidl, SHGDN_NORMAL, pdbi->wszTitle, SIZECHARS(pdbi->wszTitle), NULL);
    }
    
    return S_OK;
} 


void CBrowserBand::_InitBrowser(void)
{
    ASSERT(IsWindow(_hwnd));

    OCHost_QueryInterface(_hwnd, IID_PPV_ARG(IWebBrowser2, &_pauto));
    OCHost_SetOwner(_hwnd, SAFECAST(this, IContextMenu*));

    if (EVAL(_pauto))
    {
        LPTARGETFRAME2 ptgf;

        if (SUCCEEDED(_pauto->QueryInterface(IID_PPV_ARG(ITargetFrame2, &ptgf))))
        {
            DWORD dwOptions;

            if (SUCCEEDED(ptgf->GetFrameOptions(&dwOptions)))
            {
                dwOptions |= FRAMEOPTIONS_BROWSERBAND | FRAMEOPTIONS_SCROLL_AUTO;
                ptgf->SetFrameOptions(dwOptions);
            }
            ptgf->Release();
        }

        _pauto->put_RegisterAsDropTarget(VARIANT_FALSE);

        // BUG do OCHost_QI
        // note only 1 active object (proxy)
        _pauto->QueryInterface(IID_PPV_ARG(IOleInPlaceActiveObject, &_poipao));
        ASSERT(_poipao != NULL);
        
        // set up the connection point
        _Connect(TRUE);
    }
}

HRESULT CBrowserBand::_NavigateOC()
{
    HRESULT hres = E_FAIL;
    if (_hwnd)
    {
        ASSERT(IsWindow(_hwnd));
        if (!_pidl) {
            if (_pauto) {
                hres = _pauto->GoHome();
            }
        } else {
            IServiceProvider* psp = NULL;

            OCHost_QueryInterface(_hwnd, IID_PPV_ARG(IServiceProvider, &psp));
            if (psp)
            {
                IShellBrowser* psb;
                if (EVAL(SUCCEEDED(psp->QueryService(SID_SShellBrowser, IID_PPV_ARG(IShellBrowser, &psb)))))
                {
                    hres = psb->BrowseObject(_pidl, SBSP_SAMEBROWSER);
                    psb->Release();
                }
                psp->Release();
            }

        }
    }

    return hres;
}


HRESULT CBrowserBand::_CreateOCHost()
{
    HRESULT hres = E_FAIL; // assume error

    // Register the OCHost window class
    SHDRC shdrc = {sizeof(SHDRC), SHDRCF_OCHOST};
    shdrc.cbSize = sizeof (SHDRC);
    shdrc.dwFlags |= SHDRCF_OCHOST;
    if (DllRegisterWindowClasses(&shdrc))
    {
        // Create an OCHost window
        _hwnd = CreateWindow(OCHOST_CLASS, NULL,
            WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_TABSTOP,
            0, 0, 1, 1,
            _hwndParent, NULL, HINST_THISDLL, NULL);

        if (_hwnd)
        {
            OCHINITSTRUCT ocs;
            ocs.cbSize = SIZEOF(OCHINITSTRUCT);   
            ocs.clsidOC  = CLSID_WebBrowser;
            ocs.punkOwner = SAFECAST(this, IDeskBand*);

            hres = OCHost_InitOC(_hwnd, (LPARAM)&ocs);        

            _InitBrowser();
            _NavigateOC();
            OCHost_DoVerb(_hwnd, OLEIVERB_INPLACEACTIVATE, FALSE);
        }
    }
    return hres;
}

//***   CBrowserBand::IWinEventHandler::* {

HRESULT CBrowserBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    switch (uMsg) {
    case WM_NOTIFY:
        _OnNotify((LPNMHDR)lParam);
        return S_OK;
        
    default:
        break;
    }

    return E_FAIL;
}

HRESULT CBrowserBand::IsWindowOwner(HWND hwnd)
{
    HRESULT hres;

    hres = SHIsChildOrSelf(_hwnd, hwnd);
    ASSERT(hwnd != NULL || hres == S_FALSE);
    ASSERT(_hwnd != NULL || hres == S_FALSE);
    return hres;
}

#if 0
static void HackFocus(HWND hwndFrom)
{
    TraceMsg(DM_FOCUS, "HackFocus: GetFocus()=%x hwndOCHost=%x", GetFocus(), hwndFrom);
    hwndFrom = GetWindow(hwndFrom, GW_CHILD);   // OCHost->shembed
    TraceMsg(DM_FOCUS, "HackFocus: hwndShEmbed=%x", hwndFrom);
    hwndFrom = GetWindow(hwndFrom, GW_CHILD);   // shembed->shdocvw
    TraceMsg(DM_FOCUS, "HackFocus: hwndShDocVw=%x", hwndFrom);
    hwndFrom = GetWindow(hwndFrom, GW_CHILD);   // shdocvw->iesvr
    TraceMsg(DM_FOCUS, "HackFocus: hwndIESvr=%x", hwndFrom);
    if (hwndFrom != 0) {
        TraceMsg(DM_FOCUS, "HackFocus: SetFocus(%x)", hwndFrom);
        SetFocus(hwndFrom);
    }
    return;
}
#endif

LRESULT CBrowserBand::_OnNotify(LPNMHDR pnm)
{
    switch (pnm->code)
    {
    case OCN_ONUIACTIVATE:  // UIActivate
        ASSERT(SHIsSameObject(((LPOCNONUIACTIVATEMSG)pnm)->punk, _poipao));
        
        // n.b. we pass up 'this' not pnm->punk, since we always want to
        // be the intermediary (e.g. for UIActivateIO calls to us)

        IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
        return OCNONUIACTIVATE_HANDLED;

    case OCN_ONSETSTATUSTEXT:
        {
            HRESULT hr = E_FAIL;
            IShellBrowser *psb;

            hr = QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
            if (SUCCEEDED(hr)) {
                hr = psb->SetStatusTextSB(((LPOCNONSETSTATUSTEXTMSG)pnm)->pwszStatusText);
                psb->Release();
            }
        }
        break;

    case OCN_ONPOSRECTCHANGE:
        {
            LPCRECT lprcPosRect = ((LPOCNONPOSRECTCHANGEMSG)pnm)->prcPosRect;
            _sizeMin.cx = lprcPosRect->right - lprcPosRect->left;
            _sizeMin.cy = lprcPosRect->bottom - lprcPosRect->top;

            _BandInfoChanged();

            break;
        }

    default:
        break;
    }

    ASSERT(OCNONUIACTIVATE_HANDLED != 0);
    return 0;
}

// }

//***   CBrowserBand::IPersistStream::* {

HRESULT CBrowserBand::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_BrowserBand;

    return S_OK;
}


// mask flags for BrowserBand persistence
//
#define BB_ILSTREAM   0x00000001
#define BB_PIDLASLINK 0x00000002

// FEATURE: REVIEW: it seems to me like we should let the WebBrowserOC
// persist it's location, not us...
//
HRESULT CBrowserBand::Load(IStream *pstm)
{
    if (_pidl)
    {
        ILFree(_pidl);
    }

    DWORD dw;
    HRESULT hr = pstm->Read(&dw, sizeof(dw), NULL);
    if (SUCCEEDED(hr))
    {
        if (dw & BB_PIDLASLINK)
        {
            hr = LoadPidlAsLink(_punkSite, pstm, &_pidl);
        }
        else if (dw & BB_ILSTREAM) // for backwards compat
        {
            hr = ILLoadFromStream(pstm, &_pidl);
        }
    }
        
    if (SUCCEEDED(hr))
        _NavigateOC();
    
    return hr;
}

HRESULT CBrowserBand::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hres;
    DWORD dw = 0;
    BSTR bstrUrl = NULL;

    if (_pauto && SUCCEEDED(_pauto->get_LocationURL(&bstrUrl)) && bstrUrl) {
        TraceMsg(DM_PERSIST, "cbb.s: current/new url=%s", bstrUrl);
        if (_pidl) {
            ILFree(_pidl);
            _pidl = NULL;       // paranoia
        }
        IECreateFromPath(bstrUrl, &_pidl);
        SysFreeString(bstrUrl);
    }

    if (_pidl)
        dw |= BB_PIDLASLINK;

    hres = pstm->Write(&dw, SIZEOF(DWORD), NULL);

    if (SUCCEEDED(hres) && (dw & BB_PIDLASLINK))
        hres = SavePidlAsLink(_punkSite, pstm, _pidl);
    
    return hres;
}

// }

//***   CBrowserBand::IPersistPropertyBag::* {

HRESULT CBrowserBand::Load(IPropertyBag *pPBag, IErrorLog *pErrLog)
{
    TraceMsg(DM_TRACE, "cbb.l(bag): enter");

    if (_pidl)
    {
        ILFree(_pidl);
    }

    TCHAR szUrl[MAX_URL_STRING];
    HRESULT hr = SHPropertyBag_ReadStr(pPBag, L"Url", szUrl, ARRAYSIZE(szUrl));
    if (SUCCEEDED(hr))
    {
        PCTSTR  pszFinalUrl = szUrl;
        TCHAR   szPlug[MAX_PATH];
        TCHAR   szMuiPath[MAX_PATH];

        hr = SHPropertyBag_ReadStr(pPBag, L"Pluggable", szPlug, ARRAYSIZE(szPlug));

        if (SUCCEEDED(hr) && !StrCmpNI(TEXT("yes"), szPlug, ARRAYSIZE(szPlug)))
        {
            // if this is loading html out of the windows\web folder
            // then we need to call SHGetWebFolderFilePath in order
            // to support pluggable UI

            hr = SHGetWebFolderFilePath(PathFindFileName(szUrl), szMuiPath, ARRAYSIZE(szMuiPath));
            if (SUCCEEDED(hr))
            {
                pszFinalUrl = szMuiPath;
            }
        }

        hr = IECreateFromPath(pszFinalUrl, &_pidl);
        if (SUCCEEDED(hr))
        {
            _NavigateOC();
        }
    }
    
    return hr;
}

// }

//***   CBrowserBand::IContextMenu::* {

HRESULT CBrowserBand::QueryContextMenu(HMENU hmenu,
    UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    int i = 0;
    HMENU hmenuMe = LoadMenuPopup_PrivateNoMungeW(MENU_BROWBAND);

    i += Shell_MergeMenus(hmenu, hmenuMe, indexMenu, idCmdFirst + i, idCmdLast, MM_ADDSEPARATOR) - (idCmdFirst + i);
    DestroyMenu(hmenuMe);

    // aka (S_OK|i)
    return MAKE_HRESULT(ERROR_SUCCESS, FACILITY_NULL, i);
}

HRESULT CBrowserBand::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    TraceMsg(DM_MENU, "cbb.ic");

    HRESULT hres;
    int idCmd = -1;

    // FEATURE: todo: id -= _idCmdFirst ???

    if (!HIWORD(pici->lpVerb))
        idCmd = LOWORD(pici->lpVerb);

    //
    // Low memory paranoia safety check
    //
    if (!_pauto) {
        TraceMsg(DM_ERROR, "CBrowserBand::InvokeCommand: _pauto IS NULL");
        return E_OUTOFMEMORY;
    }

    switch (idCmd) {
    case IDM_BROWBAND_REFRESH:
#ifdef DEBUG
        if (GetKeyState(VK_SHIFT) < 0)
            hres = _pauto->GoHome();
        else
#endif
        hres = _pauto->Refresh();
        break;
    case IDM_BROWBAND_OPENNEW:   // clone window into 'real' browser
        {
        BSTR bstrURL = NULL;

        // n.b. this clones the *current page* into a 'real' browser,
        // not the link.

        // FEATURE: todo: we'd really rather get and navigate to
        // a PIDL, but that isn't supported yet in ie4.
        hres = _pauto->get_LocationURL(&bstrURL);
        if (SUCCEEDED(hres)) {
            VARIANT varFlags;

            VariantInit(&varFlags);
            varFlags.vt = VT_I4;
            varFlags.lVal = (navOpenInNewWindow|navNoHistory);

            // n.b. we drop the post data etc. on the floor, oh well...
            hres = _pauto->Navigate(bstrURL, /*flags*/&varFlags, /*targ*/NULL, /*post*/NULL, /*hdrs*/NULL);

            VariantClear(&varFlags);
        }

        if (bstrURL)
            SysFreeString(bstrURL);

        ASSERT(SUCCEEDED(hres));

        break;
        }
    default:
        TraceMsg(DM_ERROR, "cbb::ic cmd=%d not handled", idCmd);
        break;
    }

    return S_OK;
}

// }

SIZE CBrowserBand::_GetCurrentSize()
{
    SIZE size;

    RECT rc;
    GetWindowRect(_hwnd, &rc);

    size.cx = RECTWIDTH(rc);
    size.cy = RECTHEIGHT(rc);

    return size;
}

// *** IBrowserBand methods ***
HRESULT CBrowserBand::GetObjectBB(REFIID riid, LPVOID *ppv)
{
    return _pauto ? _pauto->QueryInterface(riid, ppv) : E_UNEXPECTED;
}

#ifdef DEBUG
void CBrowserBand::_DebugTestCode()
{
    DWORD dwMask = 0x10000000;  // non-NULL bogus mask

    BROWSERBANDINFO bbi;
    bbi.cbSize = SIZEOF(BROWSERBANDINFO);

    GetBrowserBandInfo(dwMask, &bbi);
}
#endif // DEBUG

void CBrowserBand::_MakeSizesConsistent(LPSIZE psizeCur)
{
    // _sizeMin overrules _sizeMax

    if (_dwModeFlags & DBIMF_FIXED) {
        // if they specified a current size, use that instead
        // of min size
        if (psizeCur)
            _sizeMin = *psizeCur;
        _sizeMax = _sizeMin;
    } else {
        _sizeMax.cx = max(_sizeMin.cx, _sizeMax.cx);
        _sizeMax.cy = max(_sizeMin.cy, _sizeMax.cy);

        if (psizeCur) {
            psizeCur->cx = max(_sizeMin.cx, psizeCur->cx);
            psizeCur->cy = max(_sizeMin.cy, psizeCur->cy);

            psizeCur->cx = min(_sizeMax.cx, psizeCur->cx);
            psizeCur->cy = min(_sizeMax.cy, psizeCur->cy);
        }
    }
}

HRESULT CBrowserBand::SetBrowserBandInfo(DWORD dwMask, PBROWSERBANDINFO pbbi)
{
    if (!pbbi || pbbi->cbSize != SIZEOF(BROWSERBANDINFO))
        return E_INVALIDARG;

    if (!dwMask || (dwMask & BBIM_MODEFLAGS))
        _dwModeFlags = pbbi->dwModeFlags;

    if (!dwMask || (dwMask & BBIM_TITLE)) {
        if (pbbi->bstrTitle) {
            _fCustomTitle = TRUE;
            // Change the internal _wszTitle used by Browser band
            StringCchCopy(_wszTitle,  ARRAYSIZE(_wszTitle), pbbi->bstrTitle);
        } else {
            _fCustomTitle = FALSE;
        }
    }

    if (!dwMask || (dwMask & BBIM_SIZEMIN))
        _sizeMin = pbbi->sizeMin;

    if (!dwMask || (dwMask & BBIM_SIZEMAX))
        _sizeMax = pbbi->sizeMax;

    if (!dwMask || (dwMask & BBIM_SIZECUR)) {
        SIZE sizeCur = pbbi->sizeCur;
        _MakeSizesConsistent(&sizeCur);

        // HACKHACK: the only way to tell bandsite to change the height of a horizontal
        // band is to give it a new min/max height pair at the desired height.  the same
        // holds for setting the width of a vertical band.  so we temporarily give bandsite
        // new min/max size info, then restore old min/max.

        SIZE sizeMinOld = _sizeMin;
        SIZE sizeMaxOld = _sizeMax;
        _sizeMin = _sizeMax = sizeCur;

        _BandInfoChanged();

        _sizeMin = sizeMinOld;
        _sizeMax = sizeMaxOld;
    } else {
        _MakeSizesConsistent(NULL);
    }

    _BandInfoChanged();

    return S_OK;
}

// we don't have a client to test BBIM_TITLE, so leave it unimplemented for now.
#define BBIM_INVALIDFLAGS (~(BBIM_SIZEMIN | BBIM_SIZEMAX | BBIM_SIZECUR | BBIM_MODEFLAGS))

HRESULT CBrowserBand::GetBrowserBandInfo(DWORD dwMask, PBROWSERBANDINFO pbbi)
{
    if (!pbbi || pbbi->cbSize != SIZEOF(BROWSERBANDINFO))
        return E_INVALIDARG;

    if (dwMask & BBIM_INVALIDFLAGS)
        return E_INVALIDARG;

    pbbi->dwModeFlags = _dwModeFlags;
    pbbi->sizeMin = _sizeMin;
    pbbi->sizeMax = _sizeMax;
    pbbi->sizeCur =_GetCurrentSize();

    return S_OK;
}

IDeskBand* CBrowserBand_Create(LPCITEMIDLIST pidl)
{
    CBrowserBand *p = new CBrowserBand();
    if(p) {
        if (pidl)
            p->_pidl = ILClone(pidl);
    }
    return p;
}

// }

class CSearchSecurityMgrImpl : public CInternetSecurityMgrImpl 
{
    // *** IID_IInternetSecurityManager ***
    
    virtual STDMETHODIMP ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy,
                                  BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
    {
        HRESULT hres = INET_E_DEFAULT_ACTION;

        switch (dwAction)
        {
            case URLACTION_ACTIVEX_RUN:
            case URLACTION_SCRIPT_RUN:
            case URLACTION_SCRIPT_SAFE_ACTIVEX:
            case URLACTION_HTML_SUBMIT_FORMS:
                if (_IsSafeUrl(pwszUrl))
                {
                    if (cbPolicy >= SIZEOF(DWORD))
                    {
                        *(DWORD *)pPolicy = URLPOLICY_ALLOW;
                        hres = S_OK;
                    }
                    else
                    {
                        hres = S_FALSE;
                    }
                }
                break;
        }
        
        return hres;
    }
};

class CCustomizeSearchHelper : public CInternetSecurityMgrImpl,
                               public IServiceProvider
{
public:

    CCustomizeSearchHelper() : _cRef(1) { }
    
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IID_IInternetSecurityManager ***
    virtual STDMETHODIMP ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy,
                                  BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);

    // *** IServiceProvider ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObject);

    virtual BOOL _IsSafeUrl(LPCWSTR pwszUrl) { return TRUE; }

private:
    ~CCustomizeSearchHelper() {};
    
    ULONG   _cRef;
};

STDMETHODIMP_(ULONG) CCustomizeSearchHelper::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CCustomizeSearchHelper::Release(void)
{
    if( 0L != --_cRef )
        return _cRef;

    delete this;
    return 0L;
}

HRESULT CCustomizeSearchHelper::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CCustomizeSearchHelper, IServiceProvider),
        QITABENT(CCustomizeSearchHelper, IInternetSecurityManager),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CCustomizeSearchHelper::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, 
                                                 DWORD cbPolicy, BYTE *pContext, DWORD cbContext, 
                                                 DWORD dwFlags, DWORD dwReserved)
{
   HRESULT hres = INET_E_DEFAULT_ACTION;

    switch (dwAction)
    {
        case URLACTION_ACTIVEX_RUN:
        case URLACTION_SCRIPT_RUN:
        case URLACTION_SCRIPT_SAFE_ACTIVEX:
        case URLACTION_HTML_SUBMIT_FORMS:
            if (cbPolicy >= SIZEOF(DWORD))
            {
                *(DWORD *)pPolicy = URLPOLICY_ALLOW;
                hres = S_OK;
            }
            else
            {
                hres = S_FALSE;
            }
            break;
    }
    
    return hres;
}

STDMETHODIMP CCustomizeSearchHelper::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    if (IID_IInternetSecurityManager == guidService)
    {
        return QueryInterface(riid, ppvObject);
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
}


//***   CSearchBand {
//

////////////////
///  Search (BrowserOC) band

//  If you change this, change shdocvw also.
const WCHAR c_wszThisBandIsYourBand[] = L"$$SearchBand$$";

#define SEARCH_MENUID_OFFSET    100

class CSearchBand : public CBrowserBand, 
                    public IBandNavigate,
                    public ISearchBandTBHelper,
                    public CSearchSecurityMgrImpl
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IPersistStream methods ***
    // (others use base class implementation) 
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // *** IBandNavigate ***
    virtual STDMETHODIMP Select(LPCITEMIDLIST pidl);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);

    // *** ISearchBandTBHelper methods ***
    virtual STDMETHODIMP AddNextMenuItem(LPCWSTR pwszText, int idItem);
    virtual STDMETHODIMP ResetNextMenu();
    virtual STDMETHODIMP SetOCCallback(IOleCommandTarget *pOleCmdTarget);
    virtual STDMETHODIMP NavigateToPidl(LPCITEMIDLIST pidl);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IWinEventHandler ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

protected:
    CSearchBand();
    virtual ~CSearchBand();

    virtual void _Connect(BOOL fConnect);
    virtual void _InitBrowser(void);
    virtual HRESULT _NavigateOC();
    
    void _AddButtons(BOOL fAdd);
    void _OnNextButtonSelect(int x, int y);
    void _OnNew();
    void _DoNext(int newPos);
    void _OnNextButtonClick();
    void _OnCustomize();
    void _OnHelp();
    void _NavigateToUrl(LPCTSTR pszUrl);
    void _EnsureImageListsLoaded();
    void _EnableNext(BOOL bEnable);
    void _NavigateToSearchUrl();

    virtual BOOL _IsSafeUrl(LPCWSTR pwszUrl);
    
    BOOL _fStrsAdded;
    LONG_PTR _lStrOffset;

    IOleCommandTarget *_pOCCmdTarget;

    HIMAGELIST  _himlNormal;
    HIMAGELIST  _himlHot;

    friend HRESULT CSearchBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);       // for ctor
    friend IDeskBand* CSearchBand_Create();

    HMENU _hmenuNext;
    HWND _hwndParent;
    int _nextPos;

    BOOL _bNewUrl; // set to true when we are QS'd for IInternetSecurityMgr, i.e. when pane is renavigated
    BOOL _bUseDefault; // true if we should not use our security mgr
    WCHAR _wszCache[MAX_URL_STRING];
    DWORD _nCmpLength;
    BOOL  _bIsCacheSafe;
};

CSearchBand::CSearchBand() :
    CBrowserBand()
{
    _fBlockSIDProxy = FALSE;
    _fBlockDrop = TRUE;
    _bNewUrl    = TRUE;
    ASSERT(_wszCache[0] == TEXT('\0'));
    ASSERT(_nCmpLength == 0);  
    ASSERT(_bIsCacheSafe == FALSE);
}

CSearchBand::~CSearchBand()
{
    ResetNextMenu();

    if (NULL != _himlNormal)
    {
        ImageList_Destroy(_himlNormal);
    }
    
    if (NULL != _himlHot)  
    {
        ImageList_Destroy(_himlHot);
    }

    ATOMICRELEASE(_pOCCmdTarget);
}

void CSearchBand::_NavigateToUrl(LPCTSTR pszUrl)
{
    if (NULL != _pidl)
    {
        ILFree(_pidl);
    }

    IECreateFromPath(pszUrl, &_pidl);
    _NavigateOC();
}

void CSearchBand::_NavigateToSearchUrl()
{
    TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
    BOOL bFound;
    BOOL bWebSearch = FALSE;
    IBrowserService2 *pbs;
        
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IBrowserService2, &pbs))))
    {
        ITEMIDLIST *pidl;

        if (SUCCEEDED(pbs->GetPidl(&pidl)))
        {
            // FEATURE: This code should be using IShellFolder2::GetDefaultSearchGUID() and
            //     keying off SRCID_SWebSearch (vs. SRCID_SFileSearch/SRCID_SFindComputer/SRCID_SFindPrinter)
            bWebSearch = ILIsWeb(pidl);
            ILFree(pidl);
        }
        pbs->Release();
    }

    ResetNextMenu();

    if (bWebSearch)
    {
        bFound = GetDefaultInternetSearchUrl(szUrl, ARRAYSIZE(szUrl), TRUE);
    }
    else
    {
        bFound = GetSearchAssistantUrl(szUrl, ARRAYSIZE(szUrl), TRUE, FALSE);
    }

    if (bFound)
    {
        _NavigateToUrl(szUrl);
    }
}

void CSearchBand::_OnNew()
{
    VARIANT var;
    var.vt = VT_BOOL;
    var.boolVal = VARIANT_FALSE;

    if (NULL != _pOCCmdTarget)
    {
        HRESULT hr = _pOCCmdTarget->Exec(NULL, SBID_SEARCH_NEW, 0, NULL, &var);
        
        if (FAILED(hr))
        {
            var.boolVal = VARIANT_FALSE;
        }
    }

    if ((var.vt != VT_BOOL) || (!var.boolVal))
    {
        _NavigateToSearchUrl();
    }
}

void CSearchBand::_OnNextButtonSelect(int x, int y)
{
    HWND hwnd;

    if (SUCCEEDED(IUnknown_GetWindow(_punkSite, &hwnd)))
    {
        int idItem = TrackPopupMenu(_hmenuNext, TPM_RETURNCMD, x, y, 0, hwnd, NULL);

        if (0 != idItem)
        {
            _DoNext(GetMenuPosFromID(_hmenuNext, idItem));
        }        
    }
}

void CSearchBand::_DoNext(int newPos)
{
    if (NULL != _pOCCmdTarget)
    {
        CheckMenuItem(_hmenuNext, _nextPos, MF_BYPOSITION | MF_UNCHECKED);

        _nextPos = newPos;

        CheckMenuItem(_hmenuNext, _nextPos, MF_BYPOSITION | MF_CHECKED);

        VARIANT var;
        
        var.vt = VT_I4;
        var.lVal = GetMenuItemID(_hmenuNext, _nextPos) - SEARCH_MENUID_OFFSET;
        
        HRESULT hr = _pOCCmdTarget->Exec(NULL, SBID_SEARCH_NEXT, 0, &var, NULL);
        
        ASSERT(SUCCEEDED(hr));
    }
}

void CSearchBand::_OnNextButtonClick()
{
    int newPos = _nextPos + 1;
    
    if (newPos >= GetMenuItemCount(_hmenuNext))
    {
        newPos = 0;
    }

    _DoNext(newPos);
}

void CSearchBand::_OnCustomize()
{
    TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
    HWND hwnd;

    IUnknown_GetWindow(_punkSite, &hwnd);

    if (GetSearchAssistantUrl(szUrl, ARRAYSIZE(szUrl), TRUE, TRUE))
    {
        if (InternetGoOnline(szUrl, hwnd, 0))
        {
            IMoniker *pmk;

            if (SUCCEEDED(CreateURLMoniker(NULL, szUrl, &pmk)))
            {
                IHostDialogHelper *pTridentAPI;
                
                if (SUCCEEDED(CoCreateInstance(CLSID_HostDialogHelper, NULL, CLSCTX_INPROC_SERVER,
                                               IID_PPV_ARG(IHostDialogHelper, &pTridentAPI))))
                {
                    IUnknown *punkCustHelper = NULL;

                    if (_IsSafeUrl(szUrl))
                    {
                        punkCustHelper = (IUnknown *)(IServiceProvider *)new CCustomizeSearchHelper;
                    }

                    pTridentAPI->ShowHTMLDialog(hwnd, pmk, NULL, L"help:no;resizable:1", NULL, punkCustHelper);

                    if (NULL != punkCustHelper)
                    {
                        punkCustHelper->Release();
                    }

                    pTridentAPI->Release();
                }

                pmk->Release();
            }
        }
    }
}

void CSearchBand::_OnHelp()
{
    HWND hwnd;

    IUnknown_GetWindow(_punkSite, &hwnd);


    SHHtmlHelpOnDemandWrap(hwnd, TEXT("iexplore.chm > iedefault"), 0, (DWORD_PTR) TEXT("srchasst.htm"), ML_CROSSCODEPAGE);

}

HRESULT CSearchBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup && IsEqualGUID(CGID_SearchBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SBID_SEARCH_NEW:
            _OnNew();
            return S_OK;

        case SBID_SEARCH_NEXT:
            if (nCmdexecopt == OLECMDEXECOPT_PROMPTUSER)
            {
                if ((NULL != pvarargIn) && (pvarargIn->vt == VT_I4))
                {
                    ASSERT(NULL != _hmenuNext);
                    _OnNextButtonSelect(GET_X_LPARAM(pvarargIn->lVal), GET_Y_LPARAM(pvarargIn->lVal));
                }
            }
            else
            {
                _OnNextButtonClick();
            }
            return S_OK;

        case SBID_SEARCH_CUSTOMIZE:
            _OnCustomize();
            return S_OK;

        case SBID_SEARCH_HELP:
            _OnHelp();
            return S_OK;

        case SBID_HASPIDL:
            // Simply return whether or not the band has a pidl
            if (_pidl)
                return S_OK;
            else
                return S_FALSE;
            
        case SBID_GETPIDL:
            {
                HRESULT hres = E_INVALIDARG;
                
                if (pvarargOut)
                {
                    hres = E_OUTOFMEMORY;
                    VariantInit(pvarargOut); // zero init it
                    if (!_pidl || SUCCEEDED(InitVariantFromIDList(pvarargOut, _pidl)))
                        hres = S_OK;
                }
                return hres;
            }
        }
    }
    return CBrowserBand::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

#define INDEX_NEXT          1
#define INDEX_CUSTOMIZE     3
static const TBBUTTON c_tbSearch[] =
{
    {  0,           SBID_SEARCH_NEW,       TBSTATE_ENABLED,   BTNS_AUTOSIZE | BTNS_SHOWTEXT,                 {0, 0}, 0, 0},
    {  1,           SBID_SEARCH_NEXT,      0,                 BTNS_AUTOSIZE | BTNS_DROPDOWN | BTNS_SHOWTEXT, {0, 0}, 0, 1},
    {  0,           0,                     TBSTATE_ENABLED,   BTNS_SEP,                                      {0, 0}, 0, 0},
    {  I_IMAGENONE, SBID_SEARCH_CUSTOMIZE, TBSTATE_ENABLED,   BTNS_AUTOSIZE | BTNS_SHOWTEXT,                 {0, 0}, 0, 2}
};

void CSearchBand::_EnableNext(BOOL bEnable)
{
    IExplorerToolbar* piet;

    if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IExplorerToolbar, &piet))))
    {
        UINT state;

        if (SUCCEEDED(piet->GetState(&CGID_SearchBand, SBID_SEARCH_NEXT, &state)))
        {
            if (bEnable)
            {
                state |= TBSTATE_ENABLED;
            }
            else
            {
                state &= ~TBSTATE_ENABLED;
            }
            piet->SetState(&CGID_SearchBand, SBID_SEARCH_NEXT, state);
        }

        piet->Release();
    }
}

void CSearchBand::_AddButtons(BOOL fAdd)
{
    IExplorerToolbar* piet;

    if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IExplorerToolbar, &piet))))
    {
        if (fAdd)
        {
            piet->SetCommandTarget((IUnknown*)SAFECAST(this, IOleCommandTarget*), &CGID_SearchBand, 0);

            if (!_fStrsAdded)
            {
                LONG_PTR   cbOffset;
                piet->AddString(&CGID_SearchBand, MLGetHinst(), IDS_SEARCH_BAR_LABELS, &cbOffset);
                _lStrOffset = cbOffset;
                _fStrsAdded = TRUE;
            }

            _EnsureImageListsLoaded();
            piet->SetImageList(&CGID_SearchBand, _himlNormal, _himlHot, NULL);

            TBBUTTON tbSearch[ARRAYSIZE(c_tbSearch)];
            UpdateButtonArray(tbSearch, c_tbSearch, ARRAYSIZE(c_tbSearch), _lStrOffset);

            if (SHRestricted2(REST_NoSearchCustomization, NULL, 0))
            {
                tbSearch[INDEX_CUSTOMIZE].fsState &= ~TBSTATE_ENABLED;
            }

            if (NULL != _hmenuNext)
            {
                tbSearch[INDEX_NEXT].fsState |= TBSTATE_ENABLED;
            }

            piet->AddButtons(&CGID_SearchBand, ARRAYSIZE(tbSearch), tbSearch);
        }
        else
            piet->SetCommandTarget(NULL, NULL, 0);

        piet->Release();
    }
}

void CSearchBand::_EnsureImageListsLoaded()
{
    if (_himlNormal == NULL)
    {
        _himlNormal = ImageList_LoadImage(HINST_THISDLL, 
                                          MAKEINTRESOURCE(IDB_SEARCHBANDDEF), 
                                          18, 
                                          0, 
                                          RGB(255, 0, 255),
                                          IMAGE_BITMAP, 
                                          LR_CREATEDIBSECTION);
    }

    if (_himlHot == NULL)
    {
        _himlHot = ImageList_LoadImage(HINST_THISDLL, 
                                       MAKEINTRESOURCE(IDB_SEARCHBANDHOT), 
                                       18, 
                                       0, 
                                       RGB(255, 0, 255),
                                       IMAGE_BITMAP, 
                                       LR_CREATEDIBSECTION);
    }
}

HRESULT CSearchBand::AddNextMenuItem(LPCWSTR pwszText, int idItem)
{
    if (NULL == _hmenuNext)
    {
        _hmenuNext = CreatePopupMenu();
    }

    ASSERT(NULL != _hmenuNext);

    if (NULL != _hmenuNext)
    {

#ifdef DEBUG
        //  Check to see if an item with this ID has already been added
        MENUITEMINFO dbgMii = { sizeof(dbgMii) };
        dbgMii.fMask = MIIM_STATE;
        if (GetMenuItemInfo(_hmenuNext, idItem + SEARCH_MENUID_OFFSET, FALSE, &dbgMii))
        {
            TraceMsg(DM_ERROR, "Adding duplicate menu item in CSearchBand::AddNextMenuItem");
        }
#endif

        int nItems = GetMenuItemCount(_hmenuNext);
        
        MENUITEMINFOW mii = { sizeof(mii) };

        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.wID = (WORD)idItem + SEARCH_MENUID_OFFSET;
        mii.fType = MFT_RADIOCHECK | MFT_STRING;
        mii.dwTypeData = (LPWSTR)pwszText;
        mii.cch = lstrlenW(pwszText);

        BOOL result = InsertMenuItemW(_hmenuNext, nItems, TRUE, &mii);

        if (result)
        {
            if (0 == nItems)
            {
                CheckMenuItem(_hmenuNext, 0, MF_BYPOSITION | MF_CHECKED);
                _EnableNext(TRUE);
            }
        }
    }
    
    return S_OK;
}

HRESULT CSearchBand::ResetNextMenu()
{
    if (NULL != _hmenuNext)
    {
        _nextPos = 0;
        _EnableNext(FALSE);
        DestroyMenu(_hmenuNext);
        _hmenuNext = NULL;
    }
    return S_OK;
}

HRESULT CSearchBand::SetOCCallback(IOleCommandTarget *pOleCmdTarget)
{
    ResetNextMenu();

    ATOMICRELEASE(_pOCCmdTarget);

    _pOCCmdTarget = pOleCmdTarget;

    if (NULL != _pOCCmdTarget)
    {
        _pOCCmdTarget->AddRef();
    }
    
    return S_OK;
}

//
// CSearchBand::NavigateToPidl
//
// Implements ISearchBandTBHelper::NavigateToPidl
//
// This is *almost* the same as CSearchBand::Select, except that it always navigates, whereas
// CSearchBand::Select will skip navigation if the search band is already displaying that pidl.
// We need that function to retain that behavior so that the search pane retains its results when
// opened.
//
HRESULT CSearchBand::NavigateToPidl(LPCITEMIDLIST pidl)
{
    ILFree(_pidl);
    _pidl = ILClone(pidl);
    return _NavigateOC();
}

HRESULT CSearchBand::ShowDW(BOOL fShow)
{

    HRESULT hres = CBrowserBand::ShowDW(fShow);
    _AddButtons(fShow);
    return hres;
}

HRESULT CSearchBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    // aggregation checking is handled in class factory
    HRESULT hr = CreateFromRegKey(REGSTR_PATH_EXPLORER, TEXT("WebFindBandHook"), IID_PPV_ARG(IUnknown, ppunk));
    if (FAILED(hr))
    {
        CSearchBand *p = new CSearchBand();
        if (p)
        {
            *ppunk = SAFECAST(p, IDeskBand*);
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

IDeskBand* CSearchBand_Create()
{
    IDeskBand* pistb = NULL;

    IUnknown *punk;
    HRESULT hr = CSearchBand_CreateInstance(NULL, &punk, NULL);
    if (SUCCEEDED(hr))
    {
        punk->QueryInterface(IID_PPV_ARG(IDeskBand, &pistb));
        ASSERT(pistb);
        punk->Release();
    }
    return pistb;
}

HRESULT CSearchBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CSearchBand, IContextMenu),
        QITABENT(CSearchBand, IBandNavigate),
        QITABENT(CSearchBand, ISearchBandTBHelper),
        QITABENT(CSearchBand, IServiceProvider),
        QITABENT(CSearchBand, IInternetSecurityManager),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
        hres = CBrowserBand::QueryInterface(riid, ppvObj);

    return hres;
}

ULONG CSearchBand::AddRef()
{
    return CBrowserBand::AddRef();
}

ULONG CSearchBand::Release()
{
    return CBrowserBand::Release();
}

void CSearchBand::_Connect(BOOL fConnect)
{
    CBrowserBand::_Connect(fConnect);

    //  Now we need to expose ourselves so the control in the search assistant
    //  can talk to us.

    if (_pauto) 
    {
        IWebBrowserApp *pWebBrowserApp;
        HRESULT hr = _pauto->QueryInterface(IID_PPV_ARG(IWebBrowserApp, &pWebBrowserApp));

        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pWebBrowserApp);
            
            BSTR bstrProp = SysAllocString(c_wszThisBandIsYourBand);
    
            if (NULL != bstrProp)
            {
                VARIANT varThis;
    
                if (fConnect)
                {
                    varThis.vt = VT_UNKNOWN;
                    varThis.punkVal = (IBandNavigate *)this;
                }
                else
                {
                    varThis.vt = VT_EMPTY;
                }           
    
                pWebBrowserApp->PutProperty(bstrProp, varThis);
                
                SysFreeString(bstrProp);
            }
    
            pWebBrowserApp->Release();
        }
    }
}

void CSearchBand::_InitBrowser(void)
{
    CBrowserBand::_InitBrowser();
}

HRESULT CSearchBand::_NavigateOC()
{
    HRESULT hres = E_FAIL;

    if (_pidl) // don't want search pane to be navigated to home.
        return CBrowserBand::_NavigateOC();

    return hres;
}

HRESULT CSearchBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                DESKBANDINFO* pdbi) 
{
    _dwBandID = dwBandID;
    pdbi->dwModeFlags = DBIMF_FIXEDBMP | DBIMF_VARIABLEHEIGHT;
    
    pdbi->ptMinSize.x = 16;
    pdbi->ptMinSize.y = 0;
    pdbi->ptMaxSize.x = 32000; // random
    pdbi->ptMaxSize.y = 32000; // random
    pdbi->ptActual.y = -1;
    pdbi->ptActual.x = -1;
    pdbi->ptIntegral.y = 1;

    MLLoadStringW(IDS_BAND_SEARCH, pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
    
    return S_OK;
} 

//***   CSearchBand::IPersistStream::* {

HRESULT CSearchBand::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_SearchBand;

    return S_OK;
}

HRESULT CSearchBand::Load(IStream *pstm)
{
    _NavigateOC();
    
    return S_OK;
}

HRESULT CSearchBand::Save(IStream *pstm, BOOL fClearDirty)
{
    return S_OK;
}

HRESULT CSearchBand::Select(LPCITEMIDLIST pidl)
{
    HRESULT hres = S_OK;
    IServiceProvider *psp = NULL;
    LPITEMIDLIST pidlTemp = NULL;

    OCHost_QueryInterface(_hwnd, IID_PPV_ARG(IServiceProvider, &psp));
    if (psp)
    {
        IBrowserService * pbs;
        if (EVAL(SUCCEEDED(psp->QueryService(SID_SShellBrowser, IID_PPV_ARG(IBrowserService, &pbs)))))
        {
            pbs->GetPidl(&pidlTemp);
            pbs->Release();
        }
        psp->Release();
    }

    if ((!pidlTemp) || (!ILIsEqual(pidlTemp, pidl)))
    {
        ILFree(_pidl);
        _pidl = ILClone(pidl);
        hres = _NavigateOC();
    }
    ILFree(pidlTemp);
    return hres;
}

STDMETHODIMP CSearchBand::QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj)
{
    HRESULT hres;
    
    if (IsEqualGUID(guidService, SID_SInternetSecurityManager))
    {
        _bNewUrl = TRUE;
        hres = QueryInterface(riid, ppvObj);
    }
    else
        hres = CBrowserBand::QueryService(guidService, riid, ppvObj);

    return hres;
}

HRESULT CSearchBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    if ((WM_WININICHANGE == uMsg) && lParam &&
        ((0 == StrCmpW((LPCWSTR)lParam, SEARCH_SETTINGS_CHANGEDW)) ||
         (0 == StrCmpA((LPCSTR) lParam, SEARCH_SETTINGS_CHANGEDA))))
    {
        _NavigateToSearchUrl();
    }   

    return CBrowserBand::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
}



BOOL CSearchBand::_IsSafeUrl(LPCWSTR pwszUrl)
{
    BOOL bRet = FALSE;
    HKEY hkey;

    if (_bNewUrl || !_bUseDefault)
    {
        WCHAR wsz[MAX_URL_STRING];
        DWORD cch = ARRAYSIZE(wsz);

        if (SUCCEEDED(UrlCanonicalizeW(pwszUrl, wsz, &cch, 0)) && cch > 0)
        {
            // the first time this f-n is called, url passed in is the url of
            // the top most frame -- if that's not one of our 'safe' urls we
            // don't want to use this security mgr because it is possible 
            // that the outer frame hosts iframe w/ 'safe' site and scripts
            // shell dispatch from the outside thus being able to do anything
            // it wants.
            if (_wszCache[0] != L'\0')
            {
                if ((_nCmpLength && StrCmpNIW(wsz, _wszCache, _nCmpLength) == 0)
                || (!_nCmpLength && StrCmpIW(wsz, _wszCache) == 0))
                    return _bIsCacheSafe;
            }
            
            if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SafeSites", 0, KEY_READ, &hkey) == ERROR_SUCCESS)
            {        
                WCHAR wszValue[MAX_PATH];
                WCHAR wszData[MAX_URL_STRING];
                DWORD cbData = SIZEOF(wszData);
                DWORD cchValue = ARRAYSIZE(wszValue);

                for (int i=0; RegEnumValueW(hkey, i, wszValue, &cchValue, NULL, NULL, (LPBYTE)wszData, &cbData) == ERROR_SUCCESS; i++)
                {
                    if (SHExpandEnvironmentStringsW(wszData, _wszCache, ARRAYSIZE(_wszCache)) > 0)
                    {
                        cchValue = ARRAYSIZE(_wszCache);
                        if (SUCCEEDED(UrlCanonicalizeW(_wszCache, _wszCache, &cchValue, 0)) && (cchValue > 0))
                        {
                            if (_wszCache[cchValue - 1] == L'*')
                            {
                                _nCmpLength = cchValue - 1;
                                bRet = StrCmpNIW(wsz, _wszCache, _nCmpLength) == 0;
                            }
                            else
                            {
                                _nCmpLength = 0;
                                bRet = StrCmpIW(wsz, _wszCache) == 0;
                            }

                            _bIsCacheSafe = bRet;
                            if (bRet)
                                break;
                        }
                        cbData = SIZEOF(_wszCache);
                        cchValue = ARRAYSIZE(wszValue);
                    }
                }
                RegCloseKey(hkey);        
            }

            // we did not find the url in the list of 'safe' sites
            // _wszCache now point to the last url read from the registry
            // ajdust it to point pwszUrl, _bIsCacheSafe is correct already
            if (!bRet)
                StringCchCopy(_wszCache,  ARRAYSIZE(_wszCache), wsz);

            if (_bNewUrl)
            {
                _bNewUrl = FALSE;
                _bUseDefault = !bRet;
            }
        }
    }
        
    return bRet;
}



//***   CCommBand {
//

////////////////
///  Comm (BrowserOC) band

class CCommBand : public CBrowserBand
{

public:    
    // *** IPersistStream methods ***
    // (others use base class implementation) 
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);

protected:
    CCommBand();
    virtual ~CCommBand();

    friend HRESULT CCommBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);       // for ctor

};

CCommBand::CCommBand() :
    CBrowserBand()
{
    _fBlockSIDProxy = FALSE;
    _fBlockDrop = TRUE;
    _fCustomTitle = TRUE;
    _wszTitle[0] = L'\0';

    _dwModeFlags = DBIMF_VARIABLEHEIGHT;

    return;
}

CCommBand::~CCommBand()
{
}

HRESULT CCommBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    *ppunk = NULL;
    LPITEMIDLIST pidlNew;
    HRESULT hr = IECreateFromPath(L"about:blank", &pidlNew);
    if (SUCCEEDED(hr))
    {
        CCommBand *p = new CCommBand();
        if (p)
        {
            p->_pidl = pidlNew;
            *ppunk = SAFECAST(p, IDeskBand*);
            hr = S_OK;
        }
        else
        {
            ILFree(pidlNew);
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}



//***   CCommBand::IPersistStream::* {

HRESULT CCommBand::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_CommBand;

    return S_OK;
}

HRESULT CCommBand::Load(IStream *pstm)
{
//    _NavigateOC();
    
    return S_OK;
}

HRESULT CCommBand::Save(IStream *pstm, BOOL fClearDirty)
{
    return S_OK;
}

HRESULT CCommBand::ShowDW(BOOL fShow)
{
    // so that the contained Browser OC event gets fired
    if (_pauto) {
        _pauto->put_Visible(fShow);
    }

    return CBrowserBand::ShowDW(fShow);
}

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\browband.h ===
#ifndef _BROWBAND_H_
#define _BROWBAND_H_


class CBrowserBand :
    public CToolBand
    ,public IContextMenu
    ,public IWinEventHandler
    ,public IDispatch
    ,public IBrowserBand
    ,public IPersistPropertyBag
{

public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) { return CToolBand::Release(); };

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    
    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi) ;

    // *** IPersistPropertyBag methods ***
    virtual STDMETHODIMP InitNew()
        { return E_NOTIMPL; };
    virtual STDMETHODIMP Load(IPropertyBag* pPBag, IErrorLog *pErrLog);
    virtual STDMETHODIMP Save(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
        { return E_NOTIMPL; };

    // *** IPersistStream methods ***
    // (others use base class implementation) 
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IContextMenu methods ***
    STDMETHOD(QueryContextMenu)(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);

    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) { return E_NOTIMPL; };

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo){return(E_NOTIMPL);}
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo){return(E_NOTIMPL);}
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid){return(E_NOTIMPL);}
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                  DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr);

    // *** IBrowserBand methods ***
    STDMETHOD(GetObjectBB)(THIS_ REFIID riid, LPVOID *ppv);
    STDMETHOD(SetBrowserBandInfo)(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi);
    STDMETHOD(GetBrowserBandInfo)(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi);

protected:
    CBrowserBand();
    virtual ~CBrowserBand();

    friend HRESULT CBrowserBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);       // for ctor
    friend IDeskBand* CBrowserBand_Create(LPCITEMIDLIST pidl);

    virtual void _Connect(BOOL fConnect);
    HRESULT _CreateOCHost();
    virtual void _InitBrowser(void);
    virtual HRESULT _NavigateOC();
    LRESULT _OnNotify(LPNMHDR pnm);
    SIZE _GetCurrentSize();

#ifdef DEBUG
    void _DebugTestCode();
#endif
    void _MakeSizesConsistent(LPSIZE psizeCur);

    IWebBrowser2 * _pauto;
    IOleInPlaceActiveObject * _poipao;
    LPITEMIDLIST _pidl;
    DWORD _dwcpCookie;
    WCHAR _wszTitle[40];
    BOOL    _fBlockSIDProxy:1; // SID_SProxyBrowser
    BOOL    _fBlockDrop:1;     // should we block drop on contents

    BOOL    _fCustomTitle:1;
    DWORD   _dwModeFlags;
    SIZE    _sizeMin;
    SIZE    _sizeMax;
};


#endif // _BROWBAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\brand.cpp ===
#include "priv.h"
#include "sccls.h"
#include "legacy.h"
#include "itbar.h"
#include "itbdrop.h"
#include "brand.h"
#include "theater.h"
#include "resource.h"
#include <tb_ids.h>

#include "mluisupp.h"

typedef struct {
    HPALETTE    hpal;
    HBITMAP     hbm;

    int         cyBrand;
    int         cxBrandExtent;
    int         cyBrandExtent;
    int         cyBrandLeadIn;

    COLORREF    clrBkStat;
    COLORREF    clrBkAnim;

    LPTSTR      pszBitmap;
    LPTSTR      pszStaticBitmap;
} BRANDCONTEXT;    

class CBrandBand :  public CToolBand,
                    public IWinEventHandler,
                    public IDispatch
{
public:
    // IUnknown
    virtual STDMETHODIMP_(ULONG) AddRef(void)   { return CToolBand::AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void)  { return CToolBand::Release(); }
    virtual STDMETHODIMP         QueryInterface(REFIID riid, LPVOID * ppvObj);

    // IObjectWithSite
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    
    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi);
    // IOleCommandTarget
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);
    
    // IPersist
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistStream
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // IWinEventHandler
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plre);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // IDispatch
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo){return(E_NOTIMPL);}
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo){return(E_NOTIMPL);}
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid){return(E_NOTIMPL);}
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                  DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr);

    // IServiceProvider
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void ** ppvObj);
    
protected:    
    CBrandBand();
    virtual ~CBrandBand();

    friend HRESULT CBrandBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);    // for ctor

    BITBOOL        _fVertical:1;
    BITBOOL        _fAnimating:1;
    BITBOOL        _fMinAlways:1;
    BITBOOL        _fTheater :1;

    BOOL _fShellView;
    
    BRANDCONTEXT *_pbc;
    int         _yOrg;
    
    static HDC          s_hdc;
    static BRANDCONTEXT s_bcWebSmall;     // BrandContext for the small web view bitmap
    static BRANDCONTEXT s_bcWebLarge;     // BrandContext for the large web view bitmap
    static BRANDCONTEXT s_bcWebMicro;     // BrandContext for the micro web view bitmap
    static BRANDCONTEXT s_bcShellSmall;   // BrandContext for the small shell view bitmap
    static BRANDCONTEXT s_bcShellLarge;   // BrandContext for the large shell view bitmap
    

    IWebBrowserApp *    _pdie;          // Used when Navigating a Browser Window with a URL String
    IBrowserService *   _pbs;           // Only valid when we are in a Browser Windows Toolbar. (Not Toolband)
    IWebBrowser2 *      _pwb2;          // Only valid when we are a Toolband (not toolbar).
    DWORD               _dwcpCookie;    // ConnectionPoint cookie for DWebBrowserEvents from the Browser Window.

    DWORD               _dwCookieServiceBrandBand;    // Service cookie for SID_SBrandBand

    LONG                _lAnimateCount; // Keep track of how many StartAnimation/StopAnimation were requested

    // Helper functions
    void _UpdateCompressedSize();
    HRESULT _CreateBrandBand();
    HRESULT _LoadBrandingBitmap();
    void    _DrawBranding(HDC hdc);
    int     _GetLinksExtent();
    void    _OnTimer(WPARAM id);
    void    _StartAnimation();
    void    _StopAnimation();

    static void _InitGlobals();
    static void _InitBrandContexts();
    static void _InitBrandContext(BRANDCONTEXT* pbc, LPCTSTR pszBrandLeadIn, LPCTSTR pszBrandHeight,
        LPCTSTR pszBrandBitmap, LPCTSTR pszBitmap, int idBrandBitmap);

    HRESULT _ConnectToBrwsrWnd(IUnknown* punk);        
    HRESULT _ConnectToBrwsrConnectionPoint(BOOL fConnect);

    static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend void CBrandBand_CleanUp();
    friend void Brand_InitBrandContexts();

    static void _GetBrandContextHeight(BRANDCONTEXT* pbc, LPCTSTR pszBrandLeadIn, LPCTSTR pszBrandHeight, 
        LPCTSTR pszBrandBitmap, LPCTSTR pszBitmap, int idBrandBitmap);

private:
};


#define SUPERCLASS  CToolBand

#define BM_BANDINFOCHANGED  (WM_USER + 1)

#ifdef DEBUG
extern unsigned long DbStreamTell(IStream *pstm);
#else
#define DbStreamTell(pstm)      ((ULONG) 0)
#endif
extern HRESULT VariantClearLazy(VARIANTARG *pvarg);

#define ANIMATION_TIMER         5678

#define MICROBITMAPID()     (IDB_IEMICROBRAND)
#define SMALLBITMAPID()     (IDB_IESMBRAND)
#define LARGEBITMAPID()     (IDB_IEBRAND)


BRANDCONTEXT CBrandBand::s_bcWebMicro   = {NULL};   // BrandContext for the micro web view bitmap
BRANDCONTEXT CBrandBand::s_bcWebSmall   = {NULL};   // BrandContext for the small web view bitmap
BRANDCONTEXT CBrandBand::s_bcWebLarge   = {NULL};   // BrandContext for the large web view bitmap
BRANDCONTEXT CBrandBand::s_bcShellSmall = {NULL};   // BrandContext for the small shell view bitmap
BRANDCONTEXT CBrandBand::s_bcShellLarge = {NULL};   // BrandContext for the large shell view bitmap


// The heights of the bitmaps (each frame!) stored is this module's resources

// ** NOTE **
// If you change the animated brands that are stored in browseui:
// MAKE SURE THESE HEIGHTS are correct!!
// ** - dsheldon - **

#define BRANDHEIGHT_WEBLARGE    38
#define BRANDHEIGHT_WEBSMALL    26
#define BRANDHEIGHT_WEBMICRO    22

HDC CBrandBand::s_hdc = NULL;
BOOL g_fUseMicroBrand = TRUE;
UINT g_cySmBrand = 0;
static const TCHAR szRegKeyIE20[]           = TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main");

static const TCHAR szValueLargeBitmap[]     = TEXT("BigBitmap");
static const TCHAR szValueSmallBitmap[]     = TEXT("SmallBitmap");
static const TCHAR szValueBrandBitmap[]     = TEXT("BrandBitmap");
static const TCHAR szValueBrandHeight[]     = TEXT("BrandHeight");
static const TCHAR szValueBrandLeadIn[]     = TEXT("BrandLeadIn");
static const TCHAR szValueSmBrandBitmap[]   = TEXT("SmBrandBitmap");
static const TCHAR szValueSmBrandHeight[]   = TEXT("SmBrandHeight");
static const TCHAR szValueSmBrandLeadIn[]   = TEXT("SmBrandLeadIn");

static const TCHAR szValueSHLargeBitmap[]     = TEXT("SHBigBitmap");
static const TCHAR szValueSHSmallBitmap[]     = TEXT("SHSmallBitmap");
static const TCHAR szValueSHBrandBitmap[]     = TEXT("SHBrandBitmap");
static const TCHAR szValueSHBrandHeight[]     = TEXT("SHBrandHeight");
static const TCHAR szValueSHBrandLeadIn[]     = TEXT("SHBrandLeadIn");
static const TCHAR szValueSHSmBrandBitmap[]   = TEXT("SHSmBrandBitmap");
static const TCHAR szValueSHSmBrandHeight[]   = TEXT("SHSmBrandHeight");
static const TCHAR szValueSHSmBrandLeadIn[]   = TEXT("SHSmBrandLeadIn");

static const TCHAR szRegKeyCoolbar[]        = TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar");
    // NOTE: szRegKeyCoolbar is duplicated from itbar.cpp!

void CBrandBand_CleanUp()
{
    if (CBrandBand::s_hdc)
    {
        HDC     hdcT;
        HBITMAP hbmT, * pbmp = NULL;

        // pick out any old bitmap to flush dc with
        if (CBrandBand::s_bcWebLarge.hbm)
            pbmp = &CBrandBand::s_bcWebLarge.hbm;
        else if (CBrandBand::s_bcWebSmall.hbm)
            pbmp = &CBrandBand::s_bcWebSmall.hbm;        

        // We need to get rid of the branding bitmap from the s_hdc
        // before we delete it else we leak. Do this the hard way since
        // we don't have a stock bitmap available to us.
        if (pbmp)
        {
            hdcT = CreateCompatibleDC(NULL);

            if (hdcT)
            {
                hbmT = (HBITMAP)SelectObject(hdcT, *pbmp);
                SelectObject(CBrandBand::s_hdc, hbmT);
                SelectObject(hdcT, hbmT);
                DeleteDC(hdcT);
            }
        }
        
        DeleteDC(CBrandBand::s_hdc);
    }

    // no palette to delete as we use the global one..
    // delete the shared palette
    
    if (CBrandBand::s_bcWebSmall.hbm)
        DeleteObject(CBrandBand::s_bcWebSmall.hbm);

    if (CBrandBand::s_bcWebLarge.hbm)
        DeleteObject(CBrandBand::s_bcWebLarge.hbm);

    if (!g_fUseMicroBrand) {
        if (CBrandBand::s_bcShellSmall.hbm)
            DeleteObject(CBrandBand::s_bcShellSmall.hbm);

        if (CBrandBand::s_bcShellLarge.hbm)
            DeleteObject(CBrandBand::s_bcShellLarge.hbm);
    } else {
        if (CBrandBand::s_bcWebMicro.hbm)
            DeleteObject(CBrandBand::s_bcWebMicro.hbm);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CBrandBand
/////////////////////////////////////////////////////////////////////////////
HRESULT CBrandBand_CreateInstance( IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // Aggregation checking is handled in class factory

    HRESULT hr;

    *ppunk = NULL;

    CBrandBand * p = new CBrandBand();
    if (p != NULL) 
    {
        *ppunk = SAFECAST(p, IDeskBand *);
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

CBrandBand::CBrandBand() : SUPERCLASS()
{
    ASSERT(_fAnimating == FALSE);
    ASSERT(_hwnd == NULL);
    _pbc = &s_bcShellLarge;
}

CBrandBand::~CBrandBand()
{
    ASSERT(!_pdie || !_pwb2 || !_pbs);

    if (IsWindow(_hwnd))
    {
        DestroyWindow(_hwnd);
    }
}

// IUnknown::QueryInterface
HRESULT CBrandBand::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IWinEventHandler))
    {
        *ppvObj = SAFECAST(this, IWinEventHandler*);
    }
    else if (IsEqualIID(riid, IID_IPersistStream))
    {
        *ppvObj = SAFECAST(this, IPersistStream*);
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = SAFECAST(this, IDispatch*);
    }
    else
    {
        return SUPERCLASS::QueryInterface(riid, ppvObj);
    }

    AddRef();
    return S_OK;
}

// IDockingWindow::SetSite
HRESULT CBrandBand::SetSite(IUnknown * punkSite)
{
    if (_pdie || _pwb2 || _pbs)
        _ConnectToBrwsrWnd(NULL);    // On-connect from Browser Window.

    // Make sure we proffer the service only once
    // This is important since we get created multiple times,
    IUnknown *punk = NULL;

    // Check if we need to revoke our service, or if our service was already proffered by
    // another instance of CBrandBand
    if ((!punkSite && _dwCookieServiceBrandBand) || 
            (punkSite && FAILED(IUnknown_QueryService(punkSite, SID_SBrandBand, IID_IUnknown, (void **)&punk))))
    {
        // Proffer or Revoke BrandBand service as appropriate
        IUnknown_ProfferService(punkSite ? punkSite : _punkSite, 
                                SID_SBrandBand, 
                                punkSite ? SAFECAST(this, IServiceProvider *) : NULL, 
                                &_dwCookieServiceBrandBand);
        // Failure here does not require special handling
    }
    ATOMICRELEASE(punk);

    SUPERCLASS::SetSite(punkSite);

    if (punkSite)
    {
        _CreateBrandBand();

        // This call will fail if the host doesn't have a Browser Window.
        _ConnectToBrwsrWnd(punkSite);
    }

    return S_OK;
}

// IDeskBand::GetBandInfo
HRESULT CBrandBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi) 
{
    _dwBandID = dwBandID;

    _fVertical = ((fViewMode & DBIF_VIEWMODE_VERTICAL) != 0);

    _LoadBrandingBitmap();
    pdbi->dwModeFlags = DBIMF_FIXEDBMP;
    if (!_fMinAlways)
        pdbi->dwModeFlags |= DBIMF_VARIABLEHEIGHT;

    int cxWidth = _fTheater ? CX_FLOATERSHOWN : _GetLinksExtent();
    
    pdbi->ptMinSize.x = max(s_bcWebSmall.cxBrandExtent, max(s_bcShellSmall.cxBrandExtent, cxWidth));
    pdbi->ptMaxSize.x = max(s_bcWebLarge.cxBrandExtent, max(s_bcShellLarge.cxBrandExtent, cxWidth));
    
    pdbi->ptMaxSize.y = max(s_bcWebLarge.cyBrand, s_bcShellLarge.cyBrand);
    
    if (g_fUseMicroBrand)
        pdbi->ptMinSize.y = s_bcWebMicro.cyBrand;
    else
        pdbi->ptMinSize.y = max(s_bcWebSmall.cyBrand, s_bcShellSmall.cyBrand);
    
    pdbi->ptIntegral.y = -1;


    return S_OK;
}

// IWinEventHandler::OnWinEvent
HRESULT CBrandBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    *plres = 0;
    
    switch (uMsg)
    {
    case WM_WININICHANGE:
        if (SHIsExplorerIniChange(wParam, lParam))
        {
            _InitBrandContexts();
            InvalidateRect(_hwnd, NULL, TRUE);
        }
        *plres = SendMessage(_hwnd, uMsg, wParam, lParam);
        break;
    }
    
    return S_OK;
} 

// IWinEventHandler::IsWindowOwner
HRESULT CBrandBand::IsWindowOwner(HWND hwnd)
{
    if (hwnd == _hwnd)
        return S_OK;
    
    return S_FALSE;
}

// IPersistStream::GetClassID
HRESULT CBrandBand::GetClassID(CLSID * pClassID)
{
    *pClassID = CLSID_BrandBand;
    return S_OK;
}

// IPersistStream::Load
HRESULT CBrandBand::Load(IStream *pstm)
{
    return S_OK;
}

// IPersistStream::Load
HRESULT CBrandBand::Save(IStream *pstm, BOOL fClearDirty)
{
    return S_OK;
}

#define ANIMATION_PERIOD       30
#define ANIMATION_PERIOD_FAST  15

// IDispatch::Invoke
HRESULT CBrandBand::Invoke
(
    DISPID          dispidMember,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    UINT *          puArgErr
)
{
    ASSERT(pdispparams);
    if (!pdispparams)
        return E_INVALIDARG;

    switch (dispidMember)
    {
        case DISPID_DOWNLOADBEGIN:
        {
            _StartAnimation();
            break;
        }

        case DISPID_DOWNLOADCOMPLETE:
        {
            _StopAnimation();
            break;
        }

        default:
            return E_INVALIDARG;
    }
    
    return S_OK;
}

void CBrandBand::_InitGlobals()
{
    if (!s_hdc) {
        ENTERCRITICAL;
        if (!s_hdc)
        {
            s_hdc = CreateCompatibleDC(NULL);
            if (s_hdc && GetDeviceCaps(s_hdc, RASTERCAPS) & RC_PALETTE)
            {
                // share the global palette ....
                ASSERT( g_hpalHalftone );
                s_bcWebMicro.hpal = g_hpalHalftone;
                s_bcWebSmall.hpal = s_bcShellSmall.hpal = g_hpalHalftone;
                s_bcWebLarge.hpal = s_bcShellLarge.hpal = g_hpalHalftone;
            }   
        }        
        LEAVECRITICAL;
    }
}

HRESULT CBrandBand::_CreateBrandBand()
{
    HRESULT hr;

    ASSERT(_hwndParent);        // Call us after SetSite()
    if (!_hwndParent)
    {
        // The caller hasn't called SetSite(), so we can't
        // create our window because we can't find out our parent's
        // HWND.
        return E_FAIL;
    }

    // create branding window
    _hwnd = SHCreateWorkerWindow(WndProc, _hwndParent, 0, WS_CHILD, NULL, this);
    if (_hwnd)
    {
        _InitGlobals();
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceMsg(TF_ERROR, "CBrandBand::_CreateBrandBand() - Could not create Brand Band!");
    }

    return hr;
}

void Brand_InitBrandContexts()
{
    CBrandBand::_InitGlobals();
    CBrandBand::_InitBrandContexts();
}

void CBrandBand::_InitBrandContexts()
{
    // note: these calls set g_fUseMicroBrand
    _GetBrandContextHeight(&s_bcWebSmall, szValueSmBrandLeadIn, szValueSmBrandHeight,
            szValueSmBrandBitmap, szValueSmallBitmap, SMALLBITMAPID());
    _GetBrandContextHeight(&s_bcWebLarge, szValueBrandLeadIn, szValueBrandHeight,
            szValueBrandBitmap, szValueLargeBitmap, LARGEBITMAPID());

    // if no third party brands found
    if (g_fUseMicroBrand) {
        // init micro brand
        _GetBrandContextHeight(&s_bcWebMicro, NULL, NULL,
            NULL, NULL, MICROBITMAPID());
    } else {
        // init shell brands
        _GetBrandContextHeight(&s_bcShellSmall, szValueSHSmBrandLeadIn, szValueSHSmBrandHeight,
                szValueSHSmBrandBitmap, szValueSHSmallBitmap, SMALLBITMAPID());
        _GetBrandContextHeight(&s_bcShellLarge, szValueSHBrandLeadIn, szValueSHBrandHeight,
                szValueSHBrandBitmap, szValueSHLargeBitmap, LARGEBITMAPID());
    }
}


/****************************************************************************
CBrandBand::_GetBrandContextHeight

  Sets the cyBrand member of the supplied brand context. This function
  uses the height information stored in the registry if it is available.
  If an alternate source for bitmaps is found and the height information
  is available in the registry, it is assumed we will not be using our
  micro brand (g_fUseMicroBrand = FALSE).

  Otherwise, it is assumed that no custom bitmaps are available and
  the cyBrand will be set to constant values representing the height
  of our standard branding.

  Note that if it appears that there are custom bitmaps available but the
  height cannot be read, we will attempt to read the custom bitmaps and
  determine the height that way (by delegating to _InitBrandContext)
****************************************************************************/
void CBrandBand::_GetBrandContextHeight(BRANDCONTEXT* pbc, LPCTSTR pszBrandLeadIn, LPCTSTR pszBrandHeight, 
    LPCTSTR pszBrandBitmap, LPCTSTR pszBitmap, int idBrandBitmap)
{
    HKEY hKey;
    DWORD cbData;
    DWORD dwType;
    BOOL fThirdPartyBitmap = FALSE;
    TCHAR szScratch[MAX_PATH];
    szScratch[0] = 0;

    // try to determine if there is a third party bitmap available for the specified
    // brand... Check if the anitmated bitmap exists
    if (pszBrandBitmap && ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szRegKeyCoolbar, 0, KEY_QUERY_VALUE, &hKey))
    {
        // See if an alternate file was specified for the animated bmp
        cbData = sizeof(szScratch);
        if ((ERROR_SUCCESS == SHQueryValueEx(hKey, pszBrandBitmap, NULL, &dwType,
            (LPBYTE)szScratch, &cbData)))
        {
            if (szScratch[0] != 0)
                fThirdPartyBitmap = TRUE;
        }


        // It appears there are third party bitmaps

        // try to find the height of the animated bitmap
        if (pszBrandHeight && fThirdPartyBitmap)
        {
            cbData = sizeof(pbc->cyBrand);

            if (ERROR_SUCCESS == SHQueryValueEx(hKey, pszBrandHeight, NULL, &dwType,
                (LPBYTE)&pbc->cyBrand, &cbData))
            {
                // Third party brands probably exist
                g_fUseMicroBrand = FALSE;
            }
            else
            {
                // In this case, we know there should be 3rd party bitmaps but no
                // height was specified in the registry. We have to bite the bullet
                // and load the bitmaps now: Delegate to _InitBrandContext()
                _InitBrandContext(pbc, pszBrandLeadIn, pszBrandHeight, 
                    pszBrandBitmap, pszBitmap, idBrandBitmap);
            }
        }

        RegCloseKey(hKey);
    }

    if (!fThirdPartyBitmap && pszBitmap && 
        ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szRegKeyCoolbar, 0, KEY_QUERY_VALUE, &hKey))
    {
        // See if an alternate file was specified for the static bmp
        cbData = sizeof(szScratch);
        if ((ERROR_SUCCESS == SHQueryValueEx(hKey, pszBitmap, NULL, &dwType,
            (LPBYTE)szScratch, &cbData)))
        {
            if (szScratch[0] != 0)
            {
                // In this case, we know there is a 3rd party static bitmap but no
                // animated bitmap was specified in the registry. We have to bite the bullet
                // and load the bitmaps now: Delegate to _InitBrandContext()
                fThirdPartyBitmap = TRUE;
                _InitBrandContext(pbc, pszBrandLeadIn, pszBrandHeight, 
                    pszBrandBitmap, pszBitmap, idBrandBitmap);
            }
        }

        RegCloseKey(hKey);
    }

    // If we didn't find any third party bitmaps, we need to set it the height 
    // to the size of the bitmaps in this module's resources
    if (!fThirdPartyBitmap)
    {
        // Set the height based on which bitmap ID is requested
        switch (idBrandBitmap)
        {
        case IDB_IEMICROBRAND:
            pbc->cyBrand = BRANDHEIGHT_WEBMICRO;
            break;
        case IDB_IESMBRAND:
            pbc->cyBrand = BRANDHEIGHT_WEBSMALL;
            break;
        case IDB_IEBRAND:
            pbc->cyBrand = BRANDHEIGHT_WEBLARGE;
            break;
        default:
            // bad ID passed in!
            ASSERT(FALSE);
        }
    }
}

void CBrandBand::_InitBrandContext(BRANDCONTEXT* pbc, LPCTSTR pszBrandLeadIn, LPCTSTR pszBrandHeight, 
    LPCTSTR pszBrandBitmap, LPCTSTR pszBitmap, int idBrandBitmap)
{
    ENTERCRITICAL;

    HKEY        hKey = NULL;
    DWORD       dwType = 0;
    TCHAR       szScratch[MAX_PATH];
    DWORD       dwcbData;

    BOOL        fBitmapInvalid = !pbc->hbm;
    LPTSTR      pszNewBitmap = NULL;
    LPTSTR      pszOldBitmap = pbc->pszBitmap;
    HBITMAP     hbmp = NULL;
    BOOL        fExternalAnimatedBitmap = FALSE;
    BOOL        fUseWindowsXPBranding = FALSE;

    // process animated brand bitmap
    
    // see if the location spec for the bitmap has been changed    
    if (pszBrandBitmap && ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szRegKeyCoolbar, 0, KEY_QUERY_VALUE, &hKey))
    {
        dwcbData = SIZEOF(szScratch);
        if ((ERROR_SUCCESS == SHQueryValueEx(hKey, pszBrandBitmap, NULL, &dwType,
            (LPBYTE)szScratch, &dwcbData)))
        {               
            pszNewBitmap = szScratch;
            fExternalAnimatedBitmap = TRUE;
        }
    }

    if (!(pszNewBitmap == pszOldBitmap || (pszNewBitmap && pszOldBitmap && !lstrcmpi(pszNewBitmap, pszOldBitmap))))
        fBitmapInvalid = TRUE;

    if (fBitmapInvalid) {
        Str_SetPtr(&pbc->pszBitmap, pszNewBitmap);

        if (pszNewBitmap) {
            if (pszNewBitmap[0]) {    // not empty string

                hbmp = (HBITMAP) LoadImage(NULL, szScratch, IMAGE_BITMAP, 0, 0, 
                                           LR_DEFAULTSIZE | LR_CREATEDIBSECTION | LR_LOADFROMFILE);
            }
        }

        if (!hbmp) 
        {
            if (hKey != NULL)
            {
                RegCloseKey(hKey); 
                hKey = NULL;
            }

            HINSTANCE hInstDll = HINST_THISDLL;
            INT iBitmapID = idBrandBitmap;

            if (GetUIVersion() > 5)
            {
                BOOL bHighColor = (SHGetCurColorRes() > 8) ? TRUE : FALSE;

                if (idBrandBitmap == MICROBITMAPID())
                {
                    if (bHighColor)
                        iBitmapID = IDB_BRAND_BITMAP_MICRO;
                    else
                        iBitmapID = IDB_BRAND256_BITMAP_MICRO;

                    fUseWindowsXPBranding = TRUE;
                }
                else if (idBrandBitmap == SMALLBITMAPID())
                {
                    if (bHighColor)
                        iBitmapID = IDB_BRAND_BITMAP_SMALL;
                    else
                        iBitmapID = IDB_BRAND256_BITMAP_SMALL;

                    fUseWindowsXPBranding = TRUE;
                }
                else if (idBrandBitmap == LARGEBITMAPID())
                {
                    if (bHighColor)
                        iBitmapID = IDB_BRAND_BITMAP_LARGE;
                    else
                        iBitmapID = IDB_BRAND256_BITMAP_LARGE;

                    fUseWindowsXPBranding = TRUE;
                }

                if (fUseWindowsXPBranding)
                {
                    hInstDll = GetModuleHandle (TEXT("shell32.dll"));
                }
            }

            hbmp = (HBITMAP) LoadImage(hInstDll, MAKEINTRESOURCE(iBitmapID), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION);
        } else
            g_fUseMicroBrand = FALSE;

        if (!hbmp) goto ErrorDone;

        if (pbc->hbm) DeleteObject(pbc->hbm);
        pbc->hbm = hbmp;

        // set the background to be the first pixel
        SelectObject(s_hdc, pbc->hbm);
        pbc->clrBkAnim = GetPixel(s_hdc, 0, 0);

        if (fUseWindowsXPBranding)
        {
            pbc->clrBkStat = pbc->clrBkAnim;
        }

        DIBSECTION  dib;
        GetObject(pbc->hbm, sizeof(DIBSECTION), &dib);
        pbc->cxBrandExtent = dib.dsBm.bmWidth;
        pbc->cyBrandExtent = dib.dsBm.bmHeight;

        dwcbData = sizeof(DWORD);

        // APPCOMPAT:: hkey is not setup when the second instance calls in
        if (!hKey || (ERROR_SUCCESS != SHQueryValueEx(hKey, pszBrandHeight, NULL, &dwType,
            (LPBYTE)&pbc->cyBrand, &dwcbData)))
            pbc->cyBrand = pbc->cxBrandExtent;

#define EXTERNAL_IMAGE_OFFSET   4
#define INTERNAL_IMAGE_OFFSET   0

        if (!hKey || (ERROR_SUCCESS != SHQueryValueEx(hKey, pszBrandLeadIn, NULL, &dwType,
            (LPBYTE)&pbc->cyBrandLeadIn, &dwcbData)))
        {
#ifndef UNIX
            if (fExternalAnimatedBitmap)
                // use old 4-image offset for back compat
                pbc->cyBrandLeadIn = EXTERNAL_IMAGE_OFFSET;
            else                
                pbc->cyBrandLeadIn = INTERNAL_IMAGE_OFFSET;
#else
            // IEUNIX : We use a different branding bitmap.   
            pbc->cyBrandLeadIn = EXTERNAL_IMAGE_OFFSET;
#endif
        }

        pbc->cyBrandLeadIn *= pbc->cyBrand;
    }

    if (hKey)
        RegCloseKey(hKey);

    // process the static bitmap

    pszNewBitmap = NULL;
    pszOldBitmap = pbc->pszStaticBitmap;
    hbmp = NULL;

    // see if the location spec for the bitmap has been changed
    dwcbData = SIZEOF(szScratch);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, szRegKeyCoolbar, pszBitmap, &dwType, szScratch, &dwcbData))
    {
        pszNewBitmap = szScratch;
    }

    if (!(pszNewBitmap == pszOldBitmap || (pszNewBitmap && pszOldBitmap && !lstrcmpi(pszNewBitmap, pszOldBitmap))))
        fBitmapInvalid = TRUE;

    if (fBitmapInvalid) {
        Str_SetPtr(&pbc->pszStaticBitmap, pszNewBitmap);

        if (pszNewBitmap) {
            if (pszNewBitmap[0]) {    // not empty string

                hbmp = (HBITMAP) LoadImage(NULL, szScratch, IMAGE_BITMAP, 0, 0, 
                                           LR_DEFAULTSIZE | LR_CREATEDIBSECTION | LR_LOADFROMFILE);
            }
        }

        if (hbmp) {

            DIBSECTION  dib;

            HDC hdcOld = CreateCompatibleDC(s_hdc);

            if (hdcOld)
            {
                SelectObject(s_hdc, pbc->hbm);
                GetObject(hbmp, sizeof(DIBSECTION), &dib);
                SelectObject(hdcOld, hbmp);
                // Set background to color of first pixel
                pbc->clrBkStat = GetPixel(hdcOld, 0, 0);
                StretchBlt(s_hdc, 0, 0, pbc->cxBrandExtent, pbc->cyBrand, hdcOld, 0, 0,
                           dib.dsBm.bmWidth, dib.dsBm.bmHeight, SRCCOPY);
                DeleteDC(hdcOld);
            }

            DeleteObject(hbmp);
            
            // If there was a custom brand, we can't use our micro brand
            g_fUseMicroBrand = FALSE;
        }        

        if (pbc == &s_bcShellSmall)
            g_cySmBrand = pbc->cyBrand;       
    }

ErrorDone:
    LEAVECRITICAL;
}

void CBrandBand::_UpdateCompressedSize()
{
    RECT rc;
    BOOL fCompressed = FALSE;
    BRANDCONTEXT *pbcOld = _pbc;

    GetClientRect(_hwnd, &rc);
    if (RECTHEIGHT(rc) < max(s_bcWebLarge.cyBrand, s_bcShellLarge.cyBrand)) {
        if (g_fUseMicroBrand && RECTHEIGHT(rc) < s_bcWebSmall.cyBrand)
        {
            if (s_bcWebMicro.hbm == NULL)
            {
                _InitBrandContext(&s_bcWebMicro, NULL, NULL,
                    NULL, NULL, MICROBITMAPID());
            }
            _pbc = &s_bcWebMicro;

        }
        else
        {
            if (_fShellView)
            {
                if (s_bcShellSmall.hbm == NULL)
                {
                    if (g_fUseMicroBrand)
                    {
                        // In this case, the shell and web bitmaps are always the same;
                        // load the web bitmap and use it for the shell also
                        if (s_bcWebSmall.hbm == NULL)
                        {
                            _InitBrandContext(&s_bcWebSmall, szValueSmBrandLeadIn, szValueSmBrandHeight,
                                szValueSmBrandBitmap, szValueSmallBitmap, SMALLBITMAPID());
                        }

                        s_bcShellSmall = s_bcWebSmall;
                    }
                    else
                    {
                        // We have different web and shell bitmaps; load the shell one
                        _InitBrandContext(&s_bcShellSmall, szValueSHSmBrandLeadIn, szValueSHSmBrandHeight,
                                szValueSHSmBrandBitmap, szValueSHSmallBitmap, SMALLBITMAPID());
                    }
                }

                _pbc = &s_bcShellSmall;
            }
            else
            {
                // We are in web view mode
                if (s_bcWebSmall.hbm == NULL)
                {
                    _InitBrandContext(&s_bcWebSmall, szValueSmBrandLeadIn, szValueSmBrandHeight,
                        szValueSmBrandBitmap, szValueSmallBitmap, SMALLBITMAPID());
                }

                _pbc = &s_bcWebSmall;
            }
        }
    } 
    else
    {
        if (_fShellView)
        {
            if (s_bcShellLarge.hbm == NULL)
            {
                if (g_fUseMicroBrand)
                {
                    // Shell and Web bitmaps are the same. Load the web one and copy it
                    if (s_bcWebLarge.hbm == NULL)
                    {
                        _InitBrandContext(&s_bcWebLarge, szValueBrandLeadIn, szValueBrandHeight,
                            szValueBrandBitmap, szValueLargeBitmap, LARGEBITMAPID());
                    }
                    s_bcShellLarge = s_bcWebLarge;
                }
                else
                {
                    // Need to load the shell bitmap separately
                    _InitBrandContext(&s_bcShellLarge, szValueSHBrandLeadIn, szValueSHBrandHeight,
                        szValueSHBrandBitmap, szValueSHLargeBitmap, LARGEBITMAPID());
                }
            }
            _pbc = &s_bcShellLarge;
        }
        else
        {
            // We're in web view
            if (s_bcWebLarge.hbm == NULL)
            {
                _InitBrandContext(&s_bcWebLarge, szValueBrandLeadIn, szValueBrandHeight,
                    szValueBrandBitmap, szValueLargeBitmap, LARGEBITMAPID());
            }
            _pbc = &s_bcWebLarge;
        }
    }

    if (_pbc != pbcOld) {
        MSG msg;
        
        _yOrg = 0;
        InvalidateRect(_hwnd, NULL, TRUE);
        if (!PeekMessage(&msg, _hwnd, BM_BANDINFOCHANGED, BM_BANDINFOCHANGED, PM_NOREMOVE))
            PostMessage(_hwnd, BM_BANDINFOCHANGED, 0, 0);                   
    }
}

HRESULT CBrandBand::_LoadBrandingBitmap()
{
    if (_pbc->hbm)
        return S_OK;    // Nothing to do, already loaded.

    _yOrg = 0;

    _InitBrandContexts();

    return(S_OK);
}

void CBrandBand::_DrawBranding(HDC hdc)
{
    HPALETTE    hpalPrev;
    RECT        rcPaint;
    COLORREF    clrBk = _fAnimating? _pbc->clrBkAnim : _pbc->clrBkStat;
    int         x, y, cx, cy;
    int         yOrg = 0;
    DWORD       dwRop = SRCCOPY;

    if (_fAnimating)
        yOrg = _yOrg;

    if (_pbc->hpal)
    {
        // select in our palette so the branding will get mapped to 
        // whatever the current system palette is. Note we do not
        // pass FALSE, so we will no actually select this palette into
        // system palette FG. Otherwise the branding will flash the
        // palette
        hpalPrev = SelectPalette(hdc, _pbc->hpal, TRUE);
        RealizePalette(hdc);
    }

    GetClientRect(_hwnd, &rcPaint);

    x  = rcPaint.left;
    cx = RECTWIDTH(rcPaint);
    y  = rcPaint.top;
    cy = RECTHEIGHT(rcPaint);
    
    if (cx > _pbc->cxBrandExtent)
    {
        RECT rc = rcPaint;
        int dx = ((cx - _pbc->cxBrandExtent) / 2) + 1;
        rc.right = rc.left + dx;
        SHFillRectClr(hdc, &rc, clrBk);
        rc.right = rcPaint.right;
        rc.left = rc.right - dx;
        SHFillRectClr(hdc, &rc, clrBk);        
    }
    if (cy > _pbc->cyBrand)
    {
        RECT rc = rcPaint;
        int dy = ((cy - _pbc->cyBrand) / 2) + 1;
        rc.bottom = rc.top + dy;
        SHFillRectClr(hdc, &rc, clrBk);
        rc.bottom = rcPaint.bottom;
        rc.top = rc.bottom - dy;
        SHFillRectClr(hdc, &rc, clrBk);
    }
    
    // center it
    if (cx > _pbc->cxBrandExtent)
        x += (cx - _pbc->cxBrandExtent) / 2;
    if (cy > _pbc->cyBrand)     
        y += (cy - _pbc->cyBrand) / 2;    

    //
    // To prevent the transform from flipping
    // calculations should be based on the bm width
    // when the DC is Right-To-Left mirrored and
    // not to flip the IE logo bitmap [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(_hwnd))
    {
        // Actual width
        cx = _pbc->cxBrandExtent;

        // Don't flip the logo here
        dwRop |= DONTMIRRORBITMAP;
    }


    ENTERCRITICAL;
    SelectObject(s_hdc, _pbc->hbm);
    BitBlt(hdc, x, y, cx, _pbc->cyBrand, s_hdc, 0, yOrg, dwRop);
    LEAVECRITICAL;

    if (_pbc->hpal)
    {
        // reselect in the old palette
        SelectPalette(hdc, hpalPrev, TRUE);
        RealizePalette(hdc);
    }
}

int CBrandBand::_GetLinksExtent()
{
    return 0x26;
}

void CBrandBand::_OnTimer(WPARAM id)
{
    _yOrg += _pbc->cyBrand;
    if (_yOrg >= _pbc->cyBrandExtent)
        _yOrg = _pbc->cyBrandLeadIn;
    RedrawWindow(_hwnd, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
}

void CBrandBand::_StartAnimation()
{
    // We need to be called on the UI thread, as we are not thread-safe.
    ASSERT(GetWindowThreadProcessId(_hwnd, NULL) == GetCurrentThreadId());

    if (++_lAnimateCount == 1)
    {
        // The timer does a invalidate of _hwnd which in cases
        // of no toolbar showing caused the entire desktop to
        // repaint and repaint and...
        if (_hwnd)
        {
            if (GetUIVersion() > 5)
                SetTimer(_hwnd, ANIMATION_TIMER, ANIMATION_PERIOD, NULL);
             else
                SetTimer(_hwnd, ANIMATION_TIMER, ANIMATION_PERIOD_FAST, NULL);
        }
        _yOrg = 0;
        _fAnimating = TRUE;
    
        IUnknown_Exec(_punkSite, &CGID_Theater, THID_ACTIVATE, 0, NULL, NULL);
    }
}

void CBrandBand::_StopAnimation()
{
    // We need to be called on the UI thread, as we are not thread-safe.
    ASSERT(GetWindowThreadProcessId(_hwnd, NULL) == GetCurrentThreadId());

    if (--_lAnimateCount == 0)
    {
        _fAnimating = FALSE;

        KillTimer(_hwnd, ANIMATION_TIMER);
        InvalidateRect(_hwnd, NULL, FALSE);
        UpdateWindow(_hwnd);
        IUnknown_Exec(_punkSite, &CGID_Theater, THID_DEACTIVATE, 0, NULL, NULL);
    }
}



// The IUnknown parameter needs to point to an object that supports the
// IBrowserService and IWebBrowserApp interfaces.
HRESULT CBrandBand::_ConnectToBrwsrWnd(IUnknown * punk)
{
    HRESULT hr = S_OK;

    if (_pdie)
    {
        // Remove the tie from the AddressBand to the Browser Window
        _ConnectToBrwsrConnectionPoint(FALSE);
        ATOMICRELEASE(_pdie);
    }
    
    ATOMICRELEASE(_pwb2);
    ATOMICRELEASE(_pbs);

    if (punk)
    {
        // Tie the AddressBand to the Browser Window passed in.
        IServiceProvider*   psp     = NULL;
        hr = punk->QueryInterface(IID_IServiceProvider, (void **)&psp);

        if (SUCCEEDED(hr))
        {
            // NOTE: We are either a Toolbar, in which case _pbs is valid
            //       and _pwb2 is NULL, or we are a Toolband and _pbs is
            //       NULL and _pwb2 is valid. Both will be NULL when the
            //       Toolband has yet to create a Browser Window.

            if (FAILED(psp->QueryService(SID_STopLevelBrowser, IID_IBrowserService, (void**)&_pbs)))
                hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**)&_pwb2);
            hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&_pdie);
            psp->Release();

            if (_pdie && (_pwb2 || _pbs))
                _ConnectToBrwsrConnectionPoint(TRUE);
            else
            {
                ATOMICRELEASE(_pdie);
                ATOMICRELEASE(_pwb2);
                ATOMICRELEASE(_pbs);

                hr = E_FAIL;
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Connect to Browser Window's ConnectionPoint that will provide events
// to let us keep up to date.
/////////////////////////////////////////////////////////////////////////////
HRESULT CBrandBand::_ConnectToBrwsrConnectionPoint(BOOL fConnect)
{
    return ConnectToConnectionPoint(SAFECAST(this, IDeskBand*), 
        DIID_DWebBrowserEvents, fConnect, _pdie, &_dwcpCookie, NULL);
}


LRESULT CALLBACK CBrandBand::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBrandBand * ptc= (CBrandBand *)GetWindowPtr0(hwnd);   // GetWindowLong(hwnd, 0)

    switch (uMsg)
    {
        case WM_TIMER:
            ptc->_OnTimer(wParam);
            break;

        case WM_ERASEBKGND:
        {
            HDC hdc = (HDC)wParam;
            RECT rc;
            GetClientRect(hwnd, &rc);
            SHFillRectClr(hdc, &rc, ptc->_fAnimating ? ptc->_pbc->clrBkAnim : ptc->_pbc->clrBkStat);
            break;
        }
            
        case WM_PAINT:
            ptc->_UpdateCompressedSize();
            if (GetUpdateRect(hwnd, NULL, FALSE))
            {
                PAINTSTRUCT ps;

                BeginPaint(hwnd, &ps);
                ptc->_DrawBranding(ps.hdc);
                EndPaint(hwnd, &ps);
            }
            break;
            
        case WM_SIZE:
            InvalidateRect(ptc->_hwnd, NULL, TRUE);
            ptc->_UpdateCompressedSize();
            break;

        case BM_BANDINFOCHANGED:
            ptc->_BandInfoChanged();
            break;

        default:
            return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }
 
    return 0;       
}

HRESULT CBrandBand::Exec(const GUID *pguidCmdGroup,
                         DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;  // assume failure
    if (pguidCmdGroup) {
        
        if (IsEqualGUID(CGID_PrivCITCommands, *pguidCmdGroup))
        {
            hr = S_OK;
            switch (nCmdID)
            {
            case CITIDM_BRANDSIZE:
                if (pvarargIn && pvarargIn->vt == VT_I4) {
                    BOOL fMin = BOOLIFY(pvarargIn->lVal);
                    if (fMin != BOOLIFY(_fMinAlways)) {
                        _fMinAlways = fMin;
                        _BandInfoChanged();
                    }
                }
                break;

            case CITIDM_ONINTERNET:
                switch (nCmdexecopt)
                {                
                case CITE_SHELL:
                    _fShellView = TRUE;
                    if (_pbs)
                    {
                        LPITEMIDLIST pidl;
                        
                        hr = _pbs->GetPidl(&pidl);
                        if (SUCCEEDED(hr))
                        {
                            // We may really be an IShellView for an internet NSE (like FTP)
                            // Find out if they want this feature
                            _fShellView = !IsBrowserFrameOptionsPidlSet(pidl, BFO_USE_IE_LOGOBANDING);
                            ILFree(pidl);
                        }
                    }
                    break;

                case CITE_INTERNET:
                    _fShellView = FALSE;
                    break;
                }
                _UpdateCompressedSize();
                break;
            
            case CITIDM_THEATER:
                switch(nCmdexecopt) {
                case THF_ON:
                    _fTheater = TRUE;
                    break;

                case THF_OFF:
                    _fTheater = FALSE;
                    break;

                default:
                    goto Bail;
                }

                _BandInfoChanged();
                break;                       
            
            case CITIDM_GETDEFAULTBRANDCOLOR:
                if (pvarargOut && pvarargOut->vt == VT_I4)
                    pvarargOut->lVal = g_fUseMicroBrand ? s_bcWebSmall.clrBkStat : s_bcShellSmall.clrBkStat;
                break;
            }
        }
        else if (IsEqualGUID(CGID_BrandCmdGroup, *pguidCmdGroup))
        {
            hr = S_OK;
            switch (nCmdID)
            {
            case CBRANDIDM_STARTGLOBEANIMATION:
                _StartAnimation();
                break;

            case CBRANDIDM_STOPGLOBEANIMATION:
                _StopAnimation();
                break;

            default:
                hr = OLECMDERR_E_NOTSUPPORTED;
                break;
            }
        }
    }
Bail:
    return hr;
}


// IQueryService implementation
HRESULT CBrandBand::QueryService(REFGUID guidService, REFIID riid, void ** ppvObj)
{
    HRESULT hres = E_NOTIMPL;

    if (IsEqualIID(guidService, SID_SBrandBand))
    {
        hres = QueryInterface(riid, ppvObj);
    }
    else
    {
        hres = CToolBand::QueryService(guidService, riid, ppvObj);
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\browbs.h ===
#ifndef _browbs_h
#define _browbs_h

#define WANT_CBANDSITE_CLASS
#include "bandsite.h"

class CBrowserBandSite :
    public CBandSite,
    public IExplorerToolbar
{
public:
    CBrowserBandSite();
    virtual ~CBrowserBandSite();

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj) { return CBandSite::QueryInterface(riid, ppvObj);};
    STDMETHODIMP_(ULONG) AddRef(void) { return CBandSite::AddRef();};
    STDMETHODIMP_(ULONG) Release(void) { return CBandSite::Release();};

    // *** IOleCommandTarget ***
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IWinEventHandler ***
    STDMETHODIMP OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
    STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IInputObject methods ***
    STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    STDMETHODIMP HasFocusIO();

    // *** IBandSite methods ***
    STDMETHODIMP SetBandSiteInfo(const BANDSITEINFO * pbsinfo);

    // *** IDeskBarClient methods ***
    STDMETHODIMP SetModeDBC(DWORD dwMode);

    // *** IExplorerToolbar ***
    STDMETHODIMP SetCommandTarget(IUnknown* punkCmdTarget, const GUID* pguidButtonGroup, DWORD dwFlags);
    STDMETHODIMP AddStdBrowserButtons(void) { return E_NOTIMPL; };
    STDMETHODIMP AddButtons(const GUID* pguidButtonGroup, UINT nButtons, const TBBUTTON* lpButtons);
    STDMETHODIMP AddString(const GUID * pguidButtonGroup, HINSTANCE hInst, UINT_PTR uiResID, LONG_PTR *pOffset);
    STDMETHODIMP GetButton(const GUID* pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton);
    STDMETHODIMP GetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT* pfState);
    STDMETHODIMP SetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT fState);
    STDMETHODIMP AddBitmap(const GUID* pguidButtonGroup, UINT uiBMPType, UINT uiCount, TBADDBITMAP* ptb,
                                    LRESULT* pOffset, COLORREF rgbMask) { return E_NOTIMPL; };
    STDMETHODIMP GetBitmapSize(UINT* uiID) { return E_NOTIMPL; };
    STDMETHODIMP SendToolbarMsg(const GUID* pguidButtonGroup, UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, LRESULT *plRes) { return E_NOTIMPL; };
    STDMETHODIMP SetImageList(const GUID* pguidCmdGroup, HIMAGELIST himlNormal, HIMAGELIST himlHot, HIMAGELIST himlDisabled);
    STDMETHODIMP ModifyButton( const GUID* pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton) { return E_NOTIMPL; };
   
protected:

    virtual void _OnCloseBand(DWORD dwBandID);
    virtual LRESULT _OnBeginDrag(NMREBAR* pnm);            
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual HRESULT _Initialize(HWND hwndParent);
    virtual IDropTarget* _WrapDropTargetForBand(IDropTarget* pdtBand);
    virtual HRESULT v_InternalQueryInterface(REFIID riid, void **ppvObj);
    virtual DWORD _GetWindowStyle(DWORD* pdwExStyle);
    virtual HMENU _LoadContextMenu();
    LRESULT _OnCDNotify(LPNMCUSTOMDRAW pnm);
    virtual void _Close();
    HRESULT _TrySetFocusTB(int iDir);
    virtual HRESULT _CycleFocusBS(LPMSG lpMsg);
    LRESULT _OnHotItemChange(LPNMTBHOTITEM pnmtb);
    LRESULT _OnNotifyBBS(LPNMHDR pnm);
    virtual void _BandInfoFromBandItem(REBARBANDINFO *prbbi, CBandItemData *pbid, BOOL fBSOnly);
    virtual void _ShowBand(CBandItemData *pbid, BOOL fShow);
    virtual void _UpdateAllBands(BOOL fBSOnly, BOOL fNoAutoSize);

    virtual int _ContextMenuHittest(LPARAM lParam, POINT* ppt);

    HFONT   _GetTitleFont(BOOL fForceRefresh);
    virtual void  _CalcHeights();
    void    _InitLayout();
    void    _UpdateLayout();
    void    _UpdateToolbarFont();

    void _CreateTBRebar();
    void _InsertToolbarBand();
    void _UpdateToolbarBand();
    void _CreateTB();
    void _RemoveAllButtons();

    void _UpdateHeaderHeight(int iBand);

    virtual void _PositionToolbars(LPPOINT ppt);
    void _CreateOptionsTB();
    virtual void _PrepareOptionsTB();
    virtual void _SizeOptionsTB();

    void _DrawEtchline(HDC hdc, LPRECT prc, int iOffset, BOOL fVertical);

    BITBOOL _fTheater:1;
    BITBOOL _fNoAutoHide:1;
    BITBOOL _fToolbar:1;    // do we have a toolbar for the current band?

    HWND                _hwndTBRebar;
    HWND                _hwndTB;
    HWND                _hwndOptionsTB;
    IOleCommandTarget*  _pCmdTarget;
    GUID                _guidButtonGroup;

    HFONT   _hfont;
    UINT    _uTitle;
    UINT    _uToolbar;
    DWORD   _dwBandIDCur;   // the currently visible band
};

#define BROWSERBAR_ICONWIDTH 16
#define BROWSERBAR_FONTSIZE 18

#ifndef UNIX
#define BROWSERBAR_TITLEHEIGHT 22
#else
#define BROWSERBAR_TITLEHEIGHT 24
#endif

#define BROWSERBAR_TOOLBARHEIGHT 24

#endif // _browbs_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\browbar.h ===
// coming soon: new deskbar (old deskbar moved to browbar base class)
#ifndef BROWBAR_H_
#define BROWBAR_H_

#include "dockbar.h"

class CBrowserBar : public CDockingBar
{
public:
    // *** IPersistStreamInit ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);

        // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    
protected:
    virtual BOOL _CheckForwardWinEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    virtual void _HandleWindowPosChanging(LPWINDOWPOS pwp) ;
    virtual void _GetChildPos(LPRECT prc);
    virtual void _GetStyleForMode(UINT eMode, LONG* plStyle, LONG *plExStyle, HWND* phwndParent);
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _StopCurrentBand();

    CLSID _clsidCurrentBand;
    int   _idBar;                //vertical or horizontal bar

public:
    void SetIdBar(int idBar) { _idBar = idBar; };
    UINT _PersistState(HWND hwnd, BOOL bSetNewRect);
};

class CBrowserBarPropertyBag : public CDockingBarPropertyBag
{
};

HRESULT BrowserBar_Init(CBrowserBar* pdb, IUnknown** ppbs, int idBar);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\browmenu.cpp ===
#include "priv.h"
#include "browmenu.h"
#include "resource.h"
#include "uemapp.h"
#include "mluisupp.h"
#include <varutil.h>
#include "legacy.h"

#define UEM_NEWITEMCOUNT 2
// Exported by shdocvw
STDAPI GetLinkInfo(IShellFolder* psf, LPCITEMIDLIST pidlItem, BOOL* pfAvailable, BOOL* pfSticky);

#define REG_STR_MAIN TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main")

BOOL AreIntelliMenusEnbaled()
{
    // This is only garenteed to work on version 5 shell because the session 
    // incrementer is located in the tray
    if (GetUIVersion() >= 5)
    {
        DWORD dwRest = SHRestricted(REST_INTELLIMENUS);
        if (dwRest != RESTOPT_INTELLIMENUS_USER)
            return (dwRest == RESTOPT_INTELLIMENUS_ENABLED);

        return SHRegGetBoolUSValue(REG_STR_MAIN, TEXT("FavIntelliMenus"),
                                   FALSE, FALSE); // Don't ignore HKCU, Disable Menus by default
    }
    else
        return FALSE;
}


CFavoritesCallback::CFavoritesCallback() : _cRef(1)
{
    _fOffline = BOOLIFY(SHIsGlobalOffline());
}

CFavoritesCallback::~CFavoritesCallback()
{
    ASSERT(_punkSite == NULL);

    ASSERT(_psmFavCache == NULL);
}

/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface method

*/
STDMETHODIMP CFavoritesCallback::QueryInterface (REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CFavoritesCallback, IShellMenuCallback),
        QITABENT(CFavoritesCallback, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


/*----------------------------------------------------------
Purpose: IUnknown::AddRef method

*/
STDMETHODIMP_(ULONG) CFavoritesCallback::AddRef ()
{
    return ++_cRef;
}

/*----------------------------------------------------------
Purpose: IUnknown::Release method

*/
STDMETHODIMP_(ULONG) CFavoritesCallback::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if( _cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

/*----------------------------------------------------------
Purpose: IObjectWithSite::SetSite method

*/
STDMETHODIMP CFavoritesCallback::SetSite(IUnknown* punk)
{
    ATOMICRELEASE(_punkSite);
    _punkSite = punk;
    if (_punkSite)
    {
        _punkSite->AddRef();
    }
    else if (_psmFavCache)
    {
        // Since the top level menu is being destroyed, they are removing
        // our site. We should cleanup.
        DWORD dwFlags;
        UINT uId;
        UINT uIdA;

        _psmFavCache->GetMenuInfo(NULL, &uId, &uIdA, &dwFlags);

        // Tell menuband we're no longer caching it. We need to do this so ClowseDW
        // cleans up the menus.
        dwFlags &= ~SMINIT_CACHED;
        _psmFavCache->Initialize(NULL, uId, uIdA, dwFlags); 

        IDeskBand* pdesk;
        if (SUCCEEDED(_psmFavCache->QueryInterface(IID_IDeskBand, (LPVOID*)&pdesk)))
        {
            pdesk->CloseDW(0);
            pdesk->Release();
        }

        ATOMICRELEASE(_psmFavCache);
    }

    return NOERROR;

}

/*----------------------------------------------------------
Purpose: IShellMenuCallback::CallbackSM method

*/
STDMETHODIMP CFavoritesCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = S_FALSE;
    switch (uMsg)
    {
    case SMC_INITMENU:
        hres = _Init(psmd->hmenu, psmd->uIdParent, psmd->punk);
        break;

    case SMC_EXITMENU:
        hres = _Exit();
        break;

    case SMC_CREATE:
        if (psmd->uIdParent == FCIDM_MENU_FAVORITES)
            _fExpandoMenus = AreIntelliMenusEnbaled();
        break;

     case SMC_DEMOTE:
         hres = _Demote(psmd);
         break;
 
     case SMC_PROMOTE:
         hres = _Promote(psmd);
         break;
 
     case SMC_NEWITEM:
         hres = _HandleNew(psmd);
         break;

    case SMC_SFEXEC:
        hres = SHNavigateToFavorite(psmd->psf, psmd->pidlItem, _punkSite, SBSP_DEFBROWSER | SBSP_DEFMODE);
        break;

    case SMC_GETINFO:
        hres = _GetHmenuInfo(psmd->hmenu, psmd->uId, (SMINFO*)lParam);
        break;

    case SMC_SFSELECTITEM:
        hres = _SelectItem(psmd->pidlFolder, psmd->pidlItem);
        break;

    case SMC_GETOBJECT:
        hres = _GetObject(psmd, (GUID)*((GUID*)wParam), (void**)lParam);
        break;

    case SMC_DEFAULTICON:
        hres = _GetDefaultIcon((LPTSTR)wParam, (int*)lParam);
        break;

    case SMC_GETSFINFO:
        hres = _GetSFInfo(psmd, (SMINFO*)lParam);
        break;

    case SMC_SHCHANGENOTIFY:
        {
            PSMCSHCHANGENOTIFYSTRUCT pshf = (PSMCSHCHANGENOTIFYSTRUCT)lParam;
            hres = _ProcessChangeNotify(psmd, pshf->lEvent, pshf->pidl1, pshf->pidl2);
        }
        break;

    case SMC_REFRESH:
        _fExpandoMenus = AreIntelliMenusEnbaled();
        break;

    case SMC_CHEVRONGETTIP:
        hres = _GetTip((LPTSTR)wParam, (LPTSTR)lParam);
        break;

    case SMC_CHEVRONEXPAND:
        {
            if (_fShowingTip)
            {
                LPTSTR pszExpanded = TEXT("NO");

                SHRegSetUSValue(REG_STR_MAIN, TEXT("FavChevron"),
                    REG_SZ, pszExpanded, lstrlen(pszExpanded) * sizeof(TCHAR), SHREGSET_FORCE_HKCU);
            }

            _fShowingTip = FALSE;

            hres = S_OK;
        }
        break;

    case SMC_DISPLAYCHEVRONTIP:

        // Should we show the tip?
        _fShowingTip = SHRegGetBoolUSValue(REG_STR_MAIN, TEXT("FavChevron"), FALSE, TRUE);    // Default to YES.

        if (_fShowingTip)
        {
            hres = S_OK;
        }
        break;

    case SMC_SFDDRESTRICTED:
        hres = _AllowDrop((IDataObject*)wParam, (HWND)lParam) ? S_FALSE : S_OK;
        break;
    }

    return hres;
}


HRESULT CFavoritesCallback::_Init(HMENU hMenu, UINT uIdParent, IUnknown* punk)
{
#ifdef DEBUG
    if (GetAsyncKeyState(VK_SHIFT) < 0)
    {
        UEMFireEvent(&UEMIID_BROWSER, UEME_CTLSESSION, UEMF_XEVENT, TRUE, -1);
    }
#endif

    HRESULT hres = S_FALSE;

    if (SUCCEEDED(IUnknown_QueryServiceExec(_punkSite, SID_STopLevelBrowser, &CGID_MenuBand, MBANDCID_ENTERMENU, 0, NULL, NULL)))
        hres = S_OK;

    // Only do this for the favorites dropdown. This was causing 
    // the chevron menu to be invalidated before it was created. This caused some
    // resize problems because the metrics were unavailable.
    if (uIdParent == FCIDM_MENU_FAVORITES)
    {
        // If we switched between online and offline, we need to re-init the menu
        BOOL fOffline = BOOLIFY(SHIsGlobalOffline());
        if (fOffline ^ _fOffline || _fRefresh)
        {
            _fOffline = fOffline;
            IShellMenu* psm;
            if (SUCCEEDED(punk->QueryInterface(IID_IShellMenu, (void**)&psm)))
            {
                psm->InvalidateItem(NULL, SMINV_REFRESH);
                psm->Release();
            }
            _fRefresh = FALSE;
        }
    }
    return hres;
}


HRESULT CFavoritesCallback::_Exit()
{
    HRESULT hr = IUnknown_QueryServiceExec(_punkSite, SID_STopLevelBrowser, &CGID_MenuBand, MBANDCID_EXITMENU, 0, NULL, NULL);

    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}

HRESULT CFavoritesCallback::_GetHmenuInfo(HMENU hMenu, UINT uId, SMINFO* psminfo)
{
    if (uId == FCIDM_MENU_FAVORITES)
    {
        if (psminfo->dwMask & SMIM_FLAGS)
            psminfo->dwFlags |= SMIF_DROPCASCADE;
    }
    else
    {
        if (psminfo->dwMask & SMIM_FLAGS)
            psminfo->dwFlags |= SMIF_TRACKPOPUP;
    }

    // No item has icons
    if (psminfo->dwMask & SMIM_ICON)
        psminfo->iIcon = -1;
    
    return S_OK;
}


HRESULT CFavoritesCallback::_GetSFInfo(SMDATA* psmd, SMINFO* psminfo)
{
    BOOL fAvailable;

    //
    // If we are offline and the item is not available, we set the
    // SMIF_ALTSTATE so that the menu item is greyed
    //
    if (psminfo->dwMask & SMIM_FLAGS)
    {
        if (_fOffline &&
            SUCCEEDED(GetLinkInfo(psmd->psf, psmd->pidlItem, &fAvailable, NULL)) &&
            fAvailable == FALSE)
        {
            // Not available, so grey the item
            psminfo->dwFlags |= SMIF_ALTSTATE;
        }

        if (_fExpandoMenus)
            psminfo->dwFlags |= _GetDemote(psmd);
    }
    return S_OK;
}

HRESULT CFavoritesCallback::_SelectItem(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl)
{
    HRESULT hres = S_FALSE;
    LPITEMIDLIST pidlFull = ILCombine(pidlFolder, pidl);
    if (pidlFull)
    {
        VARIANTARG vargIn;
        hres = InitVariantFromIDList(&vargIn, pidlFull);
        if (SUCCEEDED(hres))
        {
            hres = IUnknown_QueryServiceExec(_punkSite, SID_SMenuBandHandler,
                &CGID_MenuBandHandler, MBHANDCID_PIDLSELECT, 0, &vargIn, NULL);
            VariantClearLazy(&vargIn);
        }
        ILFree(pidlFull);
    }
    return hres;
}

void CFavoritesCallback::_RefreshItem(HMENU hmenu, int idCmd, IShellMenu* psm)
{
    SMDATA smd;
    smd.dwMask = SMDM_HMENU;
    smd.hmenu = hmenu;
    smd.uId = idCmd;

    psm->InvalidateItem(&smd, SMINV_ID | SMINV_REFRESH);
}

HRESULT CFavoritesCallback::_GetObject(LPSMDATA psmd, REFIID riid, void** ppvOut)
{
    HRESULT hres = S_FALSE;
    *ppvOut = NULL;

    if (IsEqualIID(IID_IShellMenu, riid))
    {
        if (psmd->uId == FCIDM_MENU_FAVORITES)
        {
            // Do we have a cached Favorites menu?
            if (_psmFavCache)
            {
                // Yes we do, return it
                _psmFavCache->AddRef();
                *ppvOut = (LPVOID)_psmFavCache;
                hres = S_OK;
            }
            else
            {
                // Nope; We need to create one...
                hres = CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC, 
                    IID_IShellMenu, (void**)&_psmFavCache);

                if (SUCCEEDED(hres))
                {
                    HMENU hmenu = NULL;
                    HWND hwnd;

                    _psmFavCache->Initialize(this, FCIDM_MENU_FAVORITES, ANCESTORDEFAULT, 
                        SMINIT_CACHED | SMINIT_VERTICAL); 

                    // We need to grab the Top HMENU portion of the Favorites menu from the current band
                    IShellMenu* psm;
                    if (SUCCEEDED(psmd->punk->QueryInterface(IID_IShellMenu, (LPVOID*)&psm)))
                    {
                        psm->GetMenu(&hmenu, &hwnd, NULL);

                        hmenu = GetSubMenu(hmenu, GetMenuPosFromID(hmenu, FCIDM_MENU_FAVORITES));

                        // Delete the placeholder item (there to keep the separator from getting
                        // lost during shbrowse menu merging, which deletes trailing separators).
                        int iPos = GetMenuPosFromID(hmenu, FCIDM_FAVPLACEHOLDER);
                        if (iPos >= 0)
                            DeleteMenu(hmenu, iPos, MF_BYPOSITION);

                        psm->Release();
                    }

                    if (hmenu)
                    {
                        hres = _psmFavCache->SetMenu(hmenu, hwnd, SMSET_TOP | SMSET_DONTOWN);
                    }
 
                    LPITEMIDLIST pidlFav;
                    if (SUCCEEDED(hres) &&
                        SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &pidlFav)))
                    {
                        IShellFolder* psf;
                        if (SUCCEEDED(IEBindToObject(pidlFav, &psf)))
                        {
                            HKEY hMenuKey;
                            DWORD dwDisp;

                            RegCreateKeyEx(HKEY_CURRENT_USER, STRREG_FAVORITES, NULL, NULL,
                                REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                                NULL, &hMenuKey, &dwDisp);

                            hres = _psmFavCache->SetShellFolder(psf, pidlFav, hMenuKey, 
                                SMSET_BOTTOM | SMSET_USEBKICONEXTRACTION | SMSET_HASEXPANDABLEFOLDERS);
                            psf->Release();
                        }
                        ILFree(pidlFav);
                    }

                    if (SUCCEEDED(hres))
                    {
                        _psmFavCache->AddRef(); // We're caching this.
                        *ppvOut = _psmFavCache;
                    }
                }
            }
        }
    }
    else if (IsEqualIID(IID_IShellMenuCallback, riid))
    {
        IShellMenuCallback* psmcb = (IShellMenuCallback*) new CFavoritesCallback;

        if (psmcb)
        {
            *ppvOut = (LPVOID)psmcb;
            hres = S_OK;
        }
    }

    return hres;
}


// Short circuit the looking up of a default icon. We're going to assume that all of them
// are URLs, even folders, for the sake of speed. It gives the user feedback directly, then
// we asyncronously render the real icons.
HRESULT CFavoritesCallback::_GetDefaultIcon(TCHAR* psz, int* piIndex)
{
    HRESULT hr;
    DWORD cchSize = MAX_PATH;
    
    if (SUCCEEDED(hr = AssocQueryString(0, ASSOCSTR_DEFAULTICON, TEXT("InternetShortcut"), NULL, psz, &cchSize)))
        *piIndex = PathParseIconLocation(psz);
        
    return hr;
}

DWORD CFavoritesCallback::_GetDemote(SMDATA* psmd)
{
    UEMINFO uei;
    DWORD dwFlags = 0;
    if (_fExpandoMenus)
    {
        uei.cbSize = SIZEOF(uei);
        uei.dwMask = UEIM_HIT;
        if (SUCCEEDED(UEMQueryEvent(&UEMIID_BROWSER, UEME_RUNPIDL, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem, &uei)))
        {
            if (uei.cHit == 0) 
            {
                dwFlags |= SMIF_DEMOTED;
            }
        }
    }

    return dwFlags;
}

HRESULT CFavoritesCallback::_Demote(LPSMDATA psmd)
{
    HRESULT hres = S_FALSE;

    if (_fExpandoMenus)
    {
        UEMINFO uei;
        uei.cbSize = SIZEOF(uei);
        uei.dwMask = UEIM_HIT;
        uei.cHit = 0;
        hres = UEMSetEvent(&UEMIID_BROWSER, UEME_RUNPIDL, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem, &uei);
    }
    return hres;
}

HRESULT CFavoritesCallback::_Promote(LPSMDATA psmd)
{
    if (_fExpandoMenus) 
    {
        UEMFireEvent(&UEMIID_BROWSER, UEME_RUNPIDL, UEMF_XEVENT, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem);
    }
    return S_OK;
}

HRESULT CFavoritesCallback::_HandleNew(LPSMDATA psmd)
{
    HRESULT hres = S_FALSE;
    if (_fExpandoMenus)
    {
        UEMINFO uei;
        uei.cbSize = SIZEOF(uei);
        uei.dwMask = UEIM_HIT;
        uei.cHit = UEM_NEWITEMCOUNT;
        hres = UEMSetEvent(&UEMIID_BROWSER, UEME_RUNPIDL, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem, &uei);
    }

    return hres;
}

HRESULT CFavoritesCallback::_GetTip(LPTSTR pstrTitle, LPTSTR pstrTip)
{
    MLLoadString(IDS_CHEVRONTIPTITLE, pstrTitle, MAX_PATH);
    MLLoadString(IDS_CHEVRONTIP, pstrTip, MAX_PATH);

    // Why would this fail?
    if (EVAL(pstrTitle[0] != TEXT('\0') && pstrTip[0] != TEXT('\0')))
        return S_OK;

    return S_FALSE;
}

// There is a duplicate of this helper in shell32\unicpp\startmnu.cpp
//                   When modifying this, rev that one as well.
void UEMRenamePidl(const GUID *pguidGrp1, IShellFolder* psf1, LPCITEMIDLIST pidl1,
                   const GUID *pguidGrp2, IShellFolder* psf2, LPCITEMIDLIST pidl2)
{
    UEMINFO uei;
    uei.cbSize = SIZEOF(uei);
    uei.dwMask = UEIM_HIT | UEIM_FILETIME;
    if (SUCCEEDED(UEMQueryEvent(pguidGrp1, 
                                UEME_RUNPIDL, (WPARAM)psf1, 
                                (LPARAM)pidl1, &uei)) &&
                                uei.cHit > 0)
    {
        UEMSetEvent(pguidGrp2, 
            UEME_RUNPIDL, (WPARAM)psf2, (LPARAM)pidl2, &uei);

        uei.cHit = 0;
        UEMSetEvent(pguidGrp1, 
            UEME_RUNPIDL, (WPARAM)psf1, (LPARAM)pidl1, &uei);
    }
}

// There is a duplicate of this helper in shell32\unicpp\startmnu.cpp
//                   When modifying this, rev that one as well.
void UEMDeletePidl(const GUID *pguidGrp, IShellFolder* psf, LPCITEMIDLIST pidl)
{
    UEMINFO uei;
    uei.cbSize = SIZEOF(uei);
    uei.dwMask = UEIM_HIT;
    uei.cHit = 0;
    UEMSetEvent(pguidGrp, UEME_RUNPIDL, (WPARAM)psf, (LPARAM)pidl, &uei);
}

HRESULT CFavoritesCallback::_ProcessChangeNotify(SMDATA* psmd, LONG lEvent, 
                                                 LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    switch (lEvent)
    {
    case SHCNE_RENAMEFOLDER:
    case SHCNE_RENAMEITEM:
        {
            LPITEMIDLIST pidlFavorites;
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &pidlFavorites)))
            {
                if (ILIsParent(pidlFavorites, pidl1, FALSE))
                {
                    IShellFolder* psfFrom;
                    LPCITEMIDLIST pidlFrom;
                    if (SUCCEEDED(IEBindToParentFolder(pidl1, &psfFrom, &pidlFrom)))
                    {
                        if (ILIsParent(pidlFavorites, pidl2, FALSE))
                        {
                            IShellFolder* psfTo;
                            LPCITEMIDLIST pidlTo;

                            if (SUCCEEDED(IEBindToParentFolder(pidl2, &psfTo, &pidlTo)))
                            {
                                // Then we need to rename it
                                UEMRenamePidl(&UEMIID_BROWSER, psfFrom, pidlFrom, 
                                              &UEMIID_BROWSER, psfTo, pidlTo);
                                psfTo->Release();
                            }
                        }
                        else
                        {
                            // Otherwise, we delete it.
                            UEMDeletePidl(&UEMIID_BROWSER, psfFrom, pidlFrom);
                        }

                        psfFrom->Release();
                    }
                }

                ILFree(pidlFavorites);
            }
        }
        break;

    case SHCNE_DELETE:
    case SHCNE_RMDIR:
        {
            IShellFolder* psf;
            LPCITEMIDLIST pidl;

            if (SUCCEEDED(IEBindToParentFolder(pidl1, &psf, &pidl)))
            {
                UEMDeletePidl(&UEMIID_BROWSER, psf, pidl);
                psf->Release();
            }

        }
        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        {
            IShellFolder* psf;
            LPCITEMIDLIST pidl;

            if (SUCCEEDED(IEBindToParentFolder(pidl1, &psf, &pidl)))
            {
                UEMINFO uei;
                uei.cbSize = SIZEOF(uei);
                uei.dwMask = UEIM_HIT;
                uei.cHit = UEM_NEWITEMCOUNT;
                UEMSetEvent(&UEMIID_BROWSER, 
                    UEME_RUNPIDL, (WPARAM)psf, (LPARAM)pidl, &uei);
            }

        }
        break;
    case SHCNE_EXTENDED_EVENT:
        {
            // We get this event when we are offline and the cache was changed.
            // We need to refresh the favorites menu when we next show it so the 
            // correct items are greyed.

            SHChangeDWORDAsIDList UNALIGNED * pdwidl = (SHChangeDWORDAsIDList UNALIGNED *)pidl1;

            int iEvent = pdwidl->dwItem1;

            if (iEvent == SHCNEE_WININETCHANGED &&
                (pdwidl->dwItem2 & (CACHE_NOTIFY_ADD_URL |
                        CACHE_NOTIFY_DELETE_URL |   
                        CACHE_NOTIFY_DELETE_ALL |
                        CACHE_NOTIFY_URL_SET_STICKY |
                        CACHE_NOTIFY_URL_UNSET_STICKY)))
            {
                _fRefresh = TRUE;
            }
        }
        break;
    }

    return S_FALSE;
}

//
// _Disallow drop returns S_OK if the drop shold not be allowed.  S_FALSE if
// the drop should be allowed.
//
BOOL CFavoritesCallback::_AllowDrop(IDataObject* pIDataObject, HWND hwnd)
{
    ASSERT(NULL == hwnd || IsWindow(hwnd));

    BOOL fRet = True;  // Allow drop.

    if (hwnd && pIDataObject)
    {
        LPITEMIDLIST pidl;

        if (SUCCEEDED(SHPidlFromDataObject(pIDataObject, &pidl, NULL, 0)))
        {
            fRet = IEIsLinkSafe(hwnd, pidl, ILS_ADDTOFAV);
            ILFree(pidl);
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\browbar.cpp ===
// coming soon: new deskbar (old deskbar moved to browbar base class)

#include "priv.h"
#include "sccls.h"
#include "resource.h"
#include "browbs.h"
#include "browbar.h"
#include "theater.h"
#include "shbrows2.h"
#include "varutil.h"

#ifdef UNIX
#include <mainwin.h>
#endif

#define SUPERCLASS  CDockingBar

static const WCHAR c_szExplorerBars[]  = TEXT("Software\\Microsoft\\Internet Explorer\\Explorer Bars\\");

//***   CBrowserBar_CreateInstance --
//
STDAPI CBrowserBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CBrowserBar *pwbar = new CBrowserBar();
    if (pwbar) {
        *ppunk = SAFECAST(pwbar, IDockingWindow*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//***
// NOTES
// this creates the BrowserBar (infobar) and sets up it's specific style
// such as captionless rebar and such
HRESULT BrowserBar_Init(CBrowserBar* pdb, IUnknown** ppbs, int idBar)
{
    HRESULT hr;
    
    if (ppbs)
        *ppbs = NULL;
    
    CBrowserBandSite *pcbs = new CBrowserBandSite();
    if (pcbs)
    {
        IDeskBarClient *pdbc = SAFECAST(pcbs, IDeskBarClient*);
        
        BANDSITEINFO bsinfo;
        
        bsinfo.dwMask = BSIM_STYLE;
        bsinfo.dwStyle = BSIS_NOGRIPPER | BSIS_LEFTALIGN;
        
        pcbs->SetBandSiteInfo(&bsinfo);
        
        hr = pdb->SetClient(pdbc);
        if (SUCCEEDED(hr))
        {
            if (ppbs) 
            {
                *ppbs = pdbc;
                pdbc->AddRef();
            }
        }
        pdbc->Release();
        
        ASSERT(idBar == IDBAR_VERTICAL || idBar == IDBAR_HORIZONTAL);
        pdb->SetIdBar(idBar);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//*** CBrowserBar::IPersistStream*::* {

HRESULT CBrowserBar::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_BrowserBar;
    return S_OK;
}

HRESULT CBrowserBar::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (!pguidCmdGroup)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        return IUnknown_Exec(_punkChild, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    else if (IsEqualGUID(CGID_DeskBarClient, *pguidCmdGroup))
    {
        switch (nCmdID) {
        case DBCID_EMPTY:
            if (_ptbSite) {
                // if we have no bands left, hide
                VARIANT var = {VT_UNKNOWN};
                var.punkVal = SAFECAST(this, IDeskBar*);
                AddRef();

                _StopCurrentBand();
                
                IUnknown_Exec(_ptbSite, &CGID_Explorer, SBCMDID_TOOLBAREMPTY, nCmdexecopt, &var, NULL);
                VariantClearLazy(&var);
            }
            break;

        case DBCID_RESIZE:
            goto ForwardUp;
            break;

        case DBCID_CLSIDOFBAR:
            ASSERT(nCmdexecopt == 0 || nCmdexecopt == 1);
            
            if (nCmdexecopt == 0)
            {
                //bar is being hidden
                _StopCurrentBand();
                _clsidCurrentBand = GUID_NULL;
            }
            else if (pvarargIn && pvarargIn->vt == VT_BSTR)
            {
                CLSID clsidTemp;

                GUIDFromString(pvarargIn->bstrVal, &clsidTemp);

                //if given a clsid and it's a new one, save the old one's settings
                //then set it as the current clsid
                if (!IsEqualIID(clsidTemp, _clsidCurrentBand))
                {
                    _PersistState(_hwnd, TRUE);
                    _StopCurrentBand();
                }
                _clsidCurrentBand = clsidTemp;

                if (_hwnd && IsWindow(_hwnd))
                {
                    UINT uiNewWidthOrHeight = _PersistState(_hwnd, FALSE);
                    RECT rc = {0};

                    GetWindowRect(_hwnd, &rc);
        
                    if (_idBar == IDBAR_VERTICAL)
                        rc.right = rc.left + uiNewWidthOrHeight;
                    else
                        rc.top = rc.bottom - uiNewWidthOrHeight;
                    SetWindowPos(_hwnd, NULL, 0, 0, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
                }
            }
            else if (!pvarargIn && pvarargOut)
            {
                return InitBSTRVariantFromGUID(pvarargOut, _clsidCurrentBand);
            }
            else
                ASSERT(FALSE);
            break;
        }
        return S_OK;
    } 
    else if (IsEqualGUID(CGID_Theater, *pguidCmdGroup)) {
        switch (nCmdID) {
        case THID_ACTIVATE:
            // if we're on a small monitor, start off as autohide
            _fTheater = TRUE;
            ResizeBorderDW(NULL, NULL, FALSE);
            _OnSize();

            // pass back pin button's state
            pvarargOut->vt = VT_I4;
            pvarargOut->lVal = !_fNoAutoHide;

            break;

        case THID_DEACTIVATE:
            _fTheater = FALSE;
            // if we're on a small monitor, restore to theater default width
            _szChild.cx = _iTheaterWidth;
            _AdjustToChildSize();
            break;

        case THID_SETBROWSERBARAUTOHIDE:
            // pvarargIn->lVal contains new _fAutoHide.
            // fake message pin button was pressed only when _fNoAutoHide == pvarargIn->lVal
            // which means new _fNoAutoHide != old _fNoAutoHide
            if ((_fNoAutoHide && pvarargIn->lVal) || !(_fNoAutoHide || pvarargIn->lVal)) {
                // first update state and change bitmap
                _fNoAutoHide = !pvarargIn->lVal;

                // then notify theater mode manager because it owns the msg hook and does 
                // the hiding
                IUnknown_Exec(_ptbSite, &CGID_Theater, THID_SETBROWSERBARAUTOHIDE, 0, pvarargIn, NULL);

                // negotiate with the browser for space
                _Recalc();
                _PersistState(_hwnd, FALSE);
            }
            break;
                
        default:
            goto ForwardUp;
        }
        
        IUnknown_Exec(_punkChild, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    }
    
ForwardUp:
    
    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

#define ABS(i)  (((i) < 0) ? -(i) : (i))

void CBrowserBar::_HandleWindowPosChanging(LPWINDOWPOS pwp)
{
    if (_fDragging) {
        int cxMin = GetSystemMetrics(SM_CXVSCROLL) * 4;
        
        if (pwp->cx < cxMin)
            pwp->cx = cxMin;
    }
}

LRESULT CBrowserBar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
    case WM_NCHITTEST:
    {
        LRESULT lres = _OnNCHitTest(wParam, lParam);
#ifdef DEBUG
        // non-LHS bar useful for testing discussion bar etc. stuff
        // so allow drag to get it there
        if (0)
#endif
        {
            // don't allow drag in browbar
            if (lres == HTCAPTION)
                lres = HTCLIENT;
        }
        return lres;
    }
        
    case WM_ERASEBKGND:
        if (_fTheater) {
            HDC hdc = (HDC) wParam;
            RECT rc;
            GetClientRect(hwnd, &rc);
            SHFillRectClr(hdc, &rc, RGB(0,0,0));
            return 1;
        }
        break;
        
    case WM_EXITSIZEMOVE:
        {  // save explorer bar's new width to registry
            _PersistState(hwnd, TRUE);
        }
        break;

    case WM_SIZE:
        {
            // browser bandsite needs to hear about resizing
            LRESULT lres;
            _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);
        }
        break;
    } 
    return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
}

BOOL CBrowserBar::_CheckForwardWinEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HWND hwnd = NULL;

    switch (uMsg) {
    case WM_SIZE:
        {
            // HACKHACK: munge the size so that width is browbandsite's 
            // new width.  bbs needs to hear about resizing so that it
            // can reposition its close/autohide window.
            POINT pt = {LOWORD(lParam), HIWORD(lParam)};
            pt.x -= 4 * GetSystemMetrics(SM_CXEDGE);
            lParam = MAKELONG(pt.x, pt.y);
            hwnd = _hwndChild;
            break;
        }
    }

    if (hwnd && _pWEH && _pWEH->IsWindowOwner(hwnd) == S_OK) {
        _pWEH->OnWinEvent(_hwnd, uMsg, wParam, lParam, plres);
        return TRUE;
    }
    return SUPERCLASS::_CheckForwardWinEvent(uMsg, wParam, lParam, plres);
}

void CBrowserBar::_GetChildPos(LPRECT prc)
{
    GetClientRect(_hwnd, prc);
    if (_fTheater)
        prc->right--;
    else 
    {
        // Make room for the resizing bar and make sure the right scrollbar is
        // tucked under the right edge of the parent if we are on the top or bottom
        switch(_uSide)
        {
            case ABE_TOP:
                prc->bottom -= GetSystemMetrics(SM_CYFRAME);
                prc->right += GetSystemMetrics(SM_CXFRAME);
                break;
            case ABE_BOTTOM:
                prc->top += GetSystemMetrics(SM_CYFRAME);
                prc->right += GetSystemMetrics(SM_CXFRAME);
                break;
            case ABE_LEFT:
                prc->right -= GetSystemMetrics(SM_CXFRAME);
                break;
            case ABE_RIGHT:
                prc->left += GetSystemMetrics(SM_CXFRAME);
                break;
        }
    }

    if (prc->left > prc->right)
        prc->right = prc->left;
    if (prc->top > prc->bottom)
        prc->bottom = prc->top;
}

void CBrowserBar::_GetStyleForMode(UINT eMode, LONG* plStyle, LONG *plExStyle, HWND* phwndParent)
{
    *plStyle = WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS;
    *plExStyle= 0;
    *phwndParent = PARENT_BBTMMOST();
}


// bSetNewRect controls whether we override the current rect or autohide setting
UINT CBrowserBar::_PersistState(HWND hwnd, BOOL bSetNewRect)
{
    BROWBARSAVE bbs = {0};
    RECT rc = {0};
    UINT retval = 0;

    if (IsEqualIID(_clsidCurrentBand, GUID_NULL))
    {
        //FEATURE: this assert is getting hit, why?
        //ASSERT(FALSE);  //do we even need to check this anymore?
        return 0;
    }

    // use current uiWidthOrHeight and fAutoHide in case there is no value in registry yet
    if (hwnd)
    {
        GetWindowRect(hwnd, &rc); // bad hack
        if (_idBar == IDBAR_VERTICAL)
            bbs.uiWidthOrHeight = RECTWIDTH(rc);
        else
            bbs.uiWidthOrHeight = RECTHEIGHT(rc);
    }
    bbs.fAutoHide = !_fNoAutoHide; 

    WCHAR wszClsid[GUIDSTR_MAX];
    DWORD dwType = REG_BINARY;
    DWORD cbSize = SIZEOF(BROWBARSAVE);
    SHStringFromGUID(_clsidCurrentBand, wszClsid, ARRAYSIZE(wszClsid));

    WCHAR wszKeyPath[MAX_PATH];
    StrCpyN(wszKeyPath, c_szExplorerBars, ARRAYSIZE(wszKeyPath));
    StrCatBuff(wszKeyPath, wszClsid, ARRAYSIZE(wszKeyPath));
    
    SHRegGetUSValueW(wszKeyPath, L"BarSize", &dwType, (LPBYTE)&bbs, &cbSize, FALSE, NULL, 0);

    //if there is no window yet and no saved size, pick a reasonable default
    if (bbs.uiWidthOrHeight == 0)
        bbs.uiWidthOrHeight = (IDBAR_VERTICAL == _idBar) ? COMMBAR_HEIGHT : INFOBAR_WIDTH;

    if (bSetNewRect)
    {
        if (_idBar == IDBAR_VERTICAL)
        {
            bbs.uiWidthOrHeight = RECTWIDTH(rc);
            retval = RECTWIDTH(rc);
        }
        else
        {
            bbs.uiWidthOrHeight = RECTHEIGHT(rc);
            retval = RECTHEIGHT(rc);
        }
    }        
    else
    {
        bbs.fAutoHide = !_fNoAutoHide;
        retval = bbs.uiWidthOrHeight;
    }

    if (bSetNewRect)
        SHRegSetUSValueW(wszKeyPath, L"BarSize", dwType, (LPBYTE)&bbs, cbSize, SHREGSET_FORCE_HKCU);

    return retval;
}

void CBrowserBar::_StopCurrentBand()
{
    //stop any streaming content or navigations, except for the search band if we stop it
    // then we could have incompletely loaded ui
    if (!IsEqualGUID(CLSID_SearchBand, _clsidCurrentBand))
    {
        IUnknown_Exec(_punkChild, NULL, OLECMDID_STOP, 0, NULL, NULL);
    }
}


// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\browbs.cpp ===
#include "priv.h"
#include "theater.h"
#include "browbs.h"
#include "resource.h"
#include "legacy.h"
#include "uxtheme.h"        // needed for Margin.
#include "mluisupp.h"
#include "apithk.h"

#define SUPERCLASS CBandSite

TCHAR GetAccelerator(LPCTSTR psz, BOOL bUseDefault);

#define ABS(x) (((x) < 0) ? -(x) : (x))
#define CX_TEXTOFFSET   6
#define CY_TEXTOFFSET   4
#define CX_TBOFFSET     1
#define CY_TBPADDING    1
#define CY_ETCH         2
#define CY_FLUFF        7


// *** IInputObject methods ***
HRESULT CBrowserBandSite::HasFocusIO()
{
    HWND hwnd = GetFocus();
    if (hwnd && (hwnd == _hwndTB || hwnd == _hwndOptionsTB))
        return S_OK;
    else
        return SUPERCLASS::HasFocusIO();
}

// *** IDeskBarClient methods ***
HRESULT CBrowserBandSite::SetModeDBC(DWORD dwMode)
{
    if ((dwMode ^ _dwMode) & DBIF_VIEWMODE_VERTICAL) {
        // switching horizontal/vertical; need to toggle toolbar
        // since we hide toolbar for horizontal bars
        if (_hwndTBRebar) {
            if (dwMode & DBIF_VIEWMODE_VERTICAL) {
                ShowWindow(_hwndTBRebar, SW_SHOW);
                _fToolbar = _pCmdTarget ? TRUE : FALSE;
            } else {
                ShowWindow(_hwndTBRebar, SW_HIDE);
                _fToolbar = FALSE;
            }
        }
    }

    return SUPERCLASS::SetModeDBC(dwMode);
}

HRESULT CBrowserBandSite::TranslateAcceleratorIO(LPMSG lpMsg)
{
    TraceMsg(TF_ACCESSIBILITY, "CBrowserBandSite::TranslateAcceleratorIO (hwnd=0x%08X) key=%d", _hwnd, lpMsg->wParam);

    HRESULT hr = S_FALSE;

    ASSERT((lpMsg->message >= WM_KEYFIRST) && (lpMsg->message <= WM_KEYLAST));

#if 0   //Disabled until a better key combination can be determined
    // check for Control-Shift arrow keys and resize if necessary
    if ((GetKeyState(VK_SHIFT) < 0)  && (GetKeyState(VK_CONTROL) < 0))
    {
        switch (lpMsg->wParam)
        {
            case VK_UP:
            case VK_DOWN:
            case VK_LEFT:
            case VK_RIGHT:
                IUnknown_Exec(_punkSite, &CGID_DeskBarClient, DBCID_RESIZE, (DWORD)lpMsg->wParam, NULL, NULL);
                return S_OK;
        }
    }
#endif

    if (!g_fRunningOnNT && (lpMsg->message == WM_SYSCHAR))
    {
        // See AnsiWparamToUnicode for why this character tweak is needed
        
        lpMsg->wParam = AnsiWparamToUnicode(lpMsg->wParam);
    }

    //  Give toolbar a crack
    if (hr != S_OK && _hwndTB && SendMessage(_hwndTB, TB_TRANSLATEACCELERATOR, 0, (LPARAM)lpMsg))
        return S_OK;
    else if (hr != S_OK && SendMessage(_hwndOptionsTB, TB_TRANSLATEACCELERATOR, 0, (LPARAM)lpMsg))
        return S_OK;

    // to get a mapping, forward system characters to toolbar (if any) or xBar
    if (WM_SYSCHAR == lpMsg->message)
    {
        if (hr == S_OK)
        {
            return S_OK;
        }

        if ((NULL != _hwndTB) && (NULL != _pCmdTarget))
        {
            UINT idBtn;

            if (SendMessage(_hwndTB, TB_MAPACCELERATOR, lpMsg->wParam, (LPARAM)&idBtn))
            {
                TCHAR szButtonText[MAX_PATH];

                //  comctl says this one is the one, let's make sure we aren't getting
                //  one of the unwanted "use the first letter" accelerators that it
                //  will return.
                UINT cch = (UINT)SendMessage(_hwndTB, TB_GETBUTTONTEXT, idBtn, NULL);
                if (cch != 0 && cch < ARRAYSIZE(szButtonText))
                {
                    if ((SendMessage(_hwndTB, TB_GETBUTTONTEXT, idBtn, (LPARAM)szButtonText) > 0) &&
                        (GetAccelerator(szButtonText, FALSE) != (TCHAR)-1))
                    {
                        //  (tnoonan) - it feels kinda cheesy to send mouse messages, but
                        //  I don't know of a cleaner way which will accomplish what we
                        //  want (like deal with split buttons, mutually exclusive
                        //  buttons, etc.).

                        RECT rc;

                        SendMessage(_hwndTB, TB_GETRECT, idBtn, (LPARAM)&rc);

                        SendMessage(_hwndTB, WM_LBUTTONDOWN, MK_LBUTTON, MAKELONG(rc.left, rc.top));
                        SendMessage(_hwndTB, WM_LBUTTONUP, 0, MAKELONG(rc.left, rc.top));

                        hr = S_OK;
                    }
                }
            }
        }
    }

    if (hr != S_OK)
        hr = SUPERCLASS::TranslateAcceleratorIO(lpMsg);

    return hr;
}

HRESULT CBrowserBandSite::_TrySetFocusTB(int iDir)
{
    HRESULT hres = S_FALSE;
    if (_hwndTB)
    {
        int cBtns = (int) SendMessage(_hwndTB, TB_BUTTONCOUNT, 0, 0);
        if (cBtns > 0)
        {
            // Set focus on tb.  This will also set the first button to hottracked,
            // generating a hot item change notify, but _OnHotItemChange will ignore
            // the notify as neither HICF_RESELECT, HICF_ARROWKEYS nor HICF_ACCELERATOR will be set.
            SetFocus(_hwndTB);

            // If going back, make rightmost button hottracked,
            // else make first button hottracked.
            int iHotPos = (iDir == -1) ? cBtns - 1 : 0;

            // Pass HICF_RESELECT so that if we're reselecting the same item, another notify
            // is generated, and so that the filter in _OnHotItemChange will let the notification
            // through (and pop down the chevron menu if necessary).
            SendMessage(_hwndTB, TB_SETHOTITEM2, iHotPos, HICF_RESELECT);

            hres = S_OK;
        }
    }
    return hres;
}

HRESULT CBrowserBandSite::_CycleFocusBS(LPMSG lpMsg)
{
    //
    // Tab order goes: (out)->_hwndOptionsTB->bands->(out)
    //
    // The order is reversed when shift is pressed.
    // 
    // When control is pressed, and we have focus (i.e., have already been tabbed
    // into), we reject focus since ctl-tab is supposed to tab between contexts.
    //
    // Once _hwndOptionsTB gets focus, user can arrow over to _hwndTB.  If
    // that happens, replace _hwndOptionsTB with _hwndTB in order above.
    //

    BOOL fHasFocus = (HasFocusIO() == S_OK);
    ASSERT(fHasFocus || !_ptbActive);

    if (fHasFocus && IsVK_CtlTABCycler(lpMsg))
    {
        // Bail on ctl-tab if one of our guys already has focus
        return S_FALSE;
    }

    HWND hwnd = GetFocus();
    BOOL fHasTBFocus = (hwnd && (hwnd == _hwndTB || hwnd == _hwndOptionsTB));
    BOOL fShift = (GetKeyState(VK_SHIFT) < 0);
    HRESULT hres = S_FALSE;

    // hidden options toolbar, bandsite cannot set focus to it (e.g. iBar)
    BOOL fStdExplorerBar = IsWindowVisible(_hwndOptionsTB); 

    if (fHasTBFocus)
    {
        if (!fShift)
            hres = SUPERCLASS::_CycleFocusBS(lpMsg);
    }
    else
    {
        // Here, since !fHasTBFocus, fHasFocus => a band has focus

        if (fHasFocus || fShift || (!fHasFocus && !fStdExplorerBar))
            hres = SUPERCLASS::_CycleFocusBS(lpMsg);

        if (hres != S_OK && (!fHasFocus || (fHasFocus && fShift)))
        {
            // try passing focus to options toolbar if visible;
            if (fStdExplorerBar)
            {
                SetFocus(_hwndOptionsTB);
                TraceMsg(TF_ACCESSIBILITY, "CBrowserBandSite::_CycleFocusBS (hwnd=0x%08X) setting focus to optionsTB (=0x%08X)", _hwnd, _hwndOptionsTB);
                hres = S_OK;
            }
        }
    }

    return hres;
}

// this class subclasses the CBandSite class and adds functionality specific to
// being hosted in the browser....
//
// it implements close as hide 
// it has its own title drawing

void CBrowserBandSite::_OnCloseBand(DWORD dwBandID)
{
    int iIndex = _BandIDToIndex(dwBandID);
    CBandItemData *pbid = _GetBandItem(iIndex);
    if (pbid)
    {
        _ShowBand(pbid, FALSE);
        if (_pct) 
        {
            BOOL fShowing = FALSE;

            for (int i = _GetBandItemCount() - 1; i >= 0; i--)
            {
                CBandItemData *pbidLoop = _GetBandItem(i);
                if (pbidLoop)
                {
                    fShowing |= pbid->fShow;
                    pbidLoop->Release();
                }
            }    
            if (!fShowing)
            {
                _pct->Exec(&CGID_DeskBarClient, DBCID_EMPTY, 0, NULL, NULL);
            }
        }
        pbid->Release();
    }
}

// don't allow d/d of any band in here
LRESULT CBrowserBandSite::_OnBeginDrag(NMREBAR* pnm)
{
    return 1;
}

CBrowserBandSite::CBrowserBandSite() : CBandSite(NULL)
{
    _dwBandIDCur = -1;
}

CBrowserBandSite::~CBrowserBandSite()
{
    ATOMICRELEASE(_pCmdTarget);
}


HFONT CBrowserBandSite::_GetTitleFont(BOOL fForceRefresh)
{
    if (_hfont && fForceRefresh)
        DeleteObject(_hfont);

    if (!_hfont || fForceRefresh) {
        // create our font to use for title & toolbar text
        // use A version for win9x compat
        NONCLIENTMETRICSA ncm;

        ncm.cbSize = sizeof(ncm);
        SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

        if (!(_dwMode & DBIF_VIEWMODE_VERTICAL)) {
            // horizontal band w/ vertical caption, so rotate the font
            ncm.lfMenuFont.lfEscapement = 900;  // rotate by 90 degrees
            ncm.lfMenuFont.lfOutPrecision = OUT_TT_ONLY_PRECIS; // TT can be rotated
        }

        _hfont = CreateFontIndirectA(&ncm.lfMenuFont);
    }

    return _hfont;
}

void CBrowserBandSite::_InitLayout()
{
    // force update font
    _GetTitleFont(TRUE);
 
    // update toolbar font
    _UpdateToolbarFont();

    // recalc title and toolbar heights
    _CalcHeights();

    _UpdateLayout();
}

void CBrowserBandSite::_UpdateAllBands(BOOL fBSOnly, BOOL fNoAutoSize)
{
    if (!fBSOnly && !fNoAutoSize)
        _InitLayout();

    SUPERCLASS::_UpdateAllBands(fBSOnly, fNoAutoSize);
}

HRESULT CBrowserBandSite::_Initialize(HWND hwndParent)
{
    HRESULT hres = SUPERCLASS::_Initialize(hwndParent);
    SendMessage(_hwnd, CCM_SETUNICODEFORMAT, DLL_IS_UNICODE, 0);

    _CreateOptionsTB();
    _InitLayout();

    return hres;
}

void CBrowserBandSite::_CalcHeights()
{
    // calc title height
    // calc height of captionless bandsites, too, needed to calc toolband height
    // HACKHACK: use height of 'All Folders' as standard title height
    TCHAR szTitle[64];

    if (MLLoadStringW(IDS_TREETITLE, szTitle, ARRAYSIZE(szTitle))) {
        HDC hdc = GetDC(_hwnd);

        if (hdc)
        {
            HFONT hfont = _GetTitleFont(FALSE);
            HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);

            int iLen = lstrlen(szTitle);

            SIZE size;
            GetTextExtentPoint32(hdc, szTitle, iLen, &size);
            _uTitle = size.cy;

            // make space for etch line + space
            _uTitle += CY_ETCH + CY_FLUFF;

            SelectObject(hdc, hfontOld);

            ReleaseDC(_hwnd, hdc);
        }
    } else {
        // no string; use a default height
        _uTitle = BROWSERBAR_TITLEHEIGHT;
    }

    // calc toolbar height
    _uToolbar = _uTitle + (2 * CY_TBPADDING) + CY_ETCH;

    if (_dwStyle & BSIS_NOCAPTION)
    {
        // rebar has no caption
        _uTitle = 0;
    }
}

void CBrowserBandSite::_UpdateToolbarFont()
{
    if (_hwndTB && (_dwMode & DBIF_VIEWMODE_VERTICAL)) {
        // use same font for title and toolbar
        HFONT hfont = _GetTitleFont(FALSE);
        if (hfont)
            SendMessage(_hwndTB, WM_SETFONT, (WPARAM)hfont, TRUE);
    }
}

void CBrowserBandSite::_ShowBand(CBandItemData *pbid, BOOL fShow)
{
    if (fShow && (_dwBandIDCur != pbid->dwBandID)) {
        _dwBandIDCur = pbid->dwBandID;
        _UpdateLayout();
    } else if (!fShow && _dwBandIDCur == pbid->dwBandID) {
        _dwBandIDCur = -1;
    }

    SUPERCLASS::_ShowBand(pbid, fShow);
}

void CBrowserBandSite::_UpdateLayout()
{
    // update toolbar button size
    if (_hwndTB && SendMessage(_hwndTB, TB_BUTTONCOUNT, 0, 0) > 0)
    {
        // try to set button height to title height
        LONG lSize = MAKELONG(0, _uTitle);
        SendMessage(_hwndTB, TB_SETBUTTONSIZE, 0, lSize);

        // see what toolbar actually gave us
        RECT rc;
        SendMessage(_hwndTB, TB_GETITEMRECT, 0, (LPARAM)&rc);

        // calc toolbar height (final version)
        _uToolbar = RECTHEIGHT(rc) + CY_ETCH + 2 * CY_TBPADDING;
    }

    // update header height for the current band
    if (_dwBandIDCur != -1)
    {
        REBARBANDINFO rbbi;
        rbbi.cbSize = sizeof(rbbi);
        rbbi.fMask = RBBIM_HEADERSIZE;
        rbbi.cxHeader = _uTitle + (_fToolbar ? _uToolbar : 0);
        SendMessage(_hwnd, RB_SETBANDINFO, _BandIDToIndex(_dwBandIDCur), (LPARAM)&rbbi);
    }

    // update toolbar size
    _UpdateToolbarBand();

    // reposition toolbars
    _PositionToolbars(NULL);
}

void CBrowserBandSite::_BandInfoFromBandItem(REBARBANDINFO *prbbi, CBandItemData *pbid, BOOL fBSOnly)
{
    SUPERCLASS::_BandInfoFromBandItem(prbbi, pbid, fBSOnly);
    if (prbbi) 
    {
        // we override header width so we can fit browbs's fancy ui (title,
        // toolbar, close & autohide buttons) in the band's header area.
        prbbi->cxHeader = _uTitle + (_fToolbar ? _uToolbar : 0);
    }
}

void CBrowserBandSite::_DrawEtchline(HDC hdc, LPRECT prc, int iOffset, BOOL fVertEtch)
{
    RECT rc;
    CopyRect(&rc, prc);

    if (fVertEtch) {
        rc.left += iOffset - CY_ETCH;
        rc.right = rc.left + 1;
    } else {
        rc.top += iOffset - CY_ETCH;
        rc.bottom = rc.top + 1;
    }
    SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNSHADOW));

    if (fVertEtch) {
        rc.left++;
        rc.right++;
    } else {
        rc.bottom++;
        rc.top++;
    }
    SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNHILIGHT));
}

LRESULT CBrowserBandSite::_OnCDNotify(LPNMCUSTOMDRAW pnm)
{
    switch (pnm->dwDrawStage) {
    case CDDS_PREPAINT:
        return CDRF_NOTIFYITEMDRAW;

    case CDDS_PREERASE:
        return CDRF_NOTIFYITEMDRAW;

    case CDDS_ITEMPREPAINT:
        if (!(_dwStyle & BSIS_NOCAPTION))
        {
            // horz bar has vert caption and vice versa
            BOOL fVertCaption = (_dwMode&DBIF_VIEWMODE_VERTICAL) ? FALSE:TRUE;
        
            CBandItemData *pbid = (CBandItemData *)pnm->lItemlParam;
            if (pbid)
            {
                int iLen;
                HFONT hfont, hfontOld = NULL;
                LPCTSTR pszTitle;
                SIZE size;
                USES_CONVERSION;

                hfont = _GetTitleFont(FALSE);
                hfontOld = (HFONT)SelectObject(pnm->hdc, hfont);
                pszTitle = pbid->szTitle;
                iLen = lstrlen(pszTitle);
                GetTextExtentPoint32(pnm->hdc, pszTitle, iLen, &size);

                // center text inside caption and draw edge at bottom/right.
                if (!fVertCaption) 
                {
                    // vertical bar, has horizontal text
                    int x = pnm->rc.left + CX_TEXTOFFSET;
                    int y = pnm->rc.top + ((_uTitle - CY_ETCH) - size.cy) / 2;
                    ExtTextOut(pnm->hdc, x, y, NULL, NULL, pszTitle, iLen, NULL);

                    _DrawEtchline(pnm->hdc, &pnm->rc, RECTHEIGHT(pnm->rc), fVertCaption);
                    if (_fToolbar)
                        _DrawEtchline(pnm->hdc, &pnm->rc, _uTitle, fVertCaption);
                }
                else 
                {
                    // horizontal bar, has vertical text
                    UINT nPrevAlign = SetTextAlign(pnm->hdc, TA_BOTTOM);
                    int x = pnm->rc.right - ((_uTitle - CY_ETCH) - size.cy) / 2;
                    int y = pnm->rc.bottom - CY_TEXTOFFSET;
                    ExtTextOut(pnm->hdc, x, y, NULL, NULL, pszTitle, iLen, NULL);
                    SetTextAlign(pnm->hdc, nPrevAlign);

                    _DrawEtchline(pnm->hdc, &pnm->rc, RECTWIDTH(pnm->rc), fVertCaption);
                    ASSERT(!_fToolbar);
                }

                if (hfontOld)
                    SelectObject(pnm->hdc, hfontOld);
            }
        }
        return CDRF_SKIPDEFAULT;
    }
    return CDRF_DODEFAULT;
}

LRESULT CBrowserBandSite::_OnNotify(LPNMHDR pnm)
{
    switch (pnm->idFrom) 
    {
    case FCIDM_REBAR:
        switch (pnm->code) 
        {
        case NM_CUSTOMDRAW:
            return _OnCDNotify((LPNMCUSTOMDRAW)pnm);

        case NM_NCHITTEST:
            {
                NMMOUSE *pnmMouse = (NMMOUSE*)pnm;
                RECT rc;
                GetClientRect(_hwnd, &rc);
                if (pnmMouse->dwItemSpec == (DWORD)-1) {
Lchktrans:      
                    //
                    // Edges are mirrored if the window is mirrored. [samera]
                    //
                    if (IS_WINDOW_RTL_MIRRORED(_hwnd)) {
                        int iTmp = rc.right;
                        rc.right = rc.left;
                        rc.left  = iTmp;
                    }

                    // gotta check all 4 edges or non-left-side bars (e.g.
                    // commbar) won't work.
                    // (we separate this into 2 checks to give a trace,
                    // since the old code only checked the right side)
                    if (pnmMouse->pt.x > rc.right)  {
                        return HTTRANSPARENT;
                    }
                    if (pnmMouse->pt.x < rc.left ||
                        pnmMouse->pt.y > rc.bottom || pnmMouse->pt.y < rc.top) {
                        return HTTRANSPARENT;
                    }
                } else if (pnmMouse->dwHitInfo == RBHT_CLIENT) {
                    InflateRect(&rc, -(GetSystemMetrics(SM_CXFRAME)),
                        -(GetSystemMetrics(SM_CYFRAME)));
                    goto Lchktrans;
                }

                return SUPERCLASS::_OnNotify(pnm);
            }

        default:
            return SUPERCLASS::_OnNotify(pnm);
        }

    default:
        return SUPERCLASS::_OnNotify(pnm);
    }

    return 0;
}


IDropTarget* CBrowserBandSite::_WrapDropTargetForBand(IDropTarget* pdtBand)
{
    pdtBand->AddRef();
    return pdtBand;
}


HRESULT CBrowserBandSite::v_InternalQueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBrowserBandSite, IExplorerToolbar),
        { 0 },
    };
    HRESULT hr;
    if (IsEqualIID(riid, IID_IDropTarget))
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    else
    {
        hr = QISearch(this, qit, riid, ppv);
        if (FAILED(hr))
            hr = SUPERCLASS::v_InternalQueryInterface(riid, ppv);
    }
    return hr;
}


DWORD CBrowserBandSite::_GetWindowStyle(DWORD *pdwExStyle)
{
    *pdwExStyle = 0;
    return RBS_REGISTERDROP |
            RBS_VERTICALGRIPPER | 
            RBS_VARHEIGHT | RBS_DBLCLKTOGGLE |
            WS_VISIBLE |  WS_CHILD | WS_CLIPCHILDREN | WS_BORDER |
            WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NORESIZE | CCS_NOPARENTALIGN;
}

// *** IOleCommandTarget ***

HRESULT CBrowserBandSite::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) 
    {
        
    } 
#ifdef UNIX
    // IEUNIX: Special case to handle the case where the band wants to
    // close itself. Used in Cache Warning pane (msgband.cpp)
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
        case SBCMDID_MSGBAND: 
            {
                IDockingWindow * pdw;
                if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IDockingWindow, &pdw)))) 
                {
                    pdw->ShowDW((BOOL)nCmdexecopt);
                    pdw->Release();
                }
            }
        }
    }
#endif
    else if (IsEqualGUID(CGID_Theater, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
        case THID_ACTIVATE:
            _fTheater = TRUE;
            SHSetWindowBits(_hwnd, GWL_EXSTYLE, WS_EX_CLIENTEDGE, 0);
            // fall through
        case THID_SETBROWSERBARAUTOHIDE:
            if (pvarargIn && pvarargIn->vt == VT_I4)
                _fNoAutoHide = !(pvarargIn->lVal);
            SendMessage(_hwndOptionsTB, TB_CHANGEBITMAP, IDM_AB_AUTOHIDE, _fNoAutoHide ? 2 : 0);
            break;

        case THID_DEACTIVATE:
            _fTheater = FALSE;
            SHSetWindowBits(_hwnd, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);
            break;
        }
        SetWindowPos(_hwnd, NULL, 0,0,0,0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);
        _SizeOptionsTB();

        return S_OK;
    }

    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

#define BBSC_REBAR      0x00000001
#define BBSC_TOOLBAR    0x00000002

void CBrowserBandSite::_CreateTBRebar()
{
    ASSERT(!_hwndTBRebar);

    _hwndTBRebar = CreateWindowEx(WS_EX_TOOLWINDOW, REBARCLASSNAME, NULL,
                           WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN |
                           WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN,
                           0, 0, 100, 36,
                           _hwnd, (HMENU) BBSC_REBAR, HINST_THISDLL, NULL);

    if (_hwndTBRebar)
        SendMessage(_hwndTBRebar, CCM_SETVERSION, COMCTL32_VERSION, 0);
}

void CBrowserBandSite::_InsertToolbarBand()
{
    if (_hwndTBRebar && _hwndTB)
    {
        // Assert that we haven't added the toolbar band yet
        ASSERT(SendMessage(_hwndTBRebar, RB_GETBANDCOUNT, 0, 0) == 0);

        // Assert that we've calculated toolbar height
        ASSERT(_uToolbar);

        REBARBANDINFO rbbi;
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_STYLE;

        // RBBIM_CHILD
        rbbi.hwndChild = _hwndTB;

        // RBBIM_CHILDSIZE
        rbbi.cxMinChild = 0;
        rbbi.cyMinChild = _uToolbar - (CY_ETCH + 2 * CY_TBPADDING);

        // RBBIM_STYLE
        rbbi.fStyle = RBBS_NOGRIPPER | RBBS_USECHEVRON;

        SendMessage(_hwndTBRebar, RB_INSERTBAND, -1, (LPARAM)&rbbi);
    }
}

void CBrowserBandSite::_UpdateToolbarBand()
{
    if (_hwndTBRebar && _hwndTB)
    {
        // Assert that we've added the toolbar band
        ASSERT(SendMessage(_hwndTBRebar, RB_GETBANDCOUNT, 0, 0) == 1);

        // Assert that we've calculated toolbar height
        ASSERT(_uToolbar);

        REBARBANDINFO rbbi;
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_CHILDSIZE;

        SIZE size = {0, _uToolbar};
        if (SendMessage(_hwndTB, TB_GETIDEALSIZE, FALSE, (LPARAM)&size))
        {
            // RBBIM_IDEALSIZE
            rbbi.fMask |= RBBIM_IDEALSIZE;
            rbbi.cxIdeal = size.cx;
        }

        // RBBIM_CHILDSIZE
        rbbi.cxMinChild = 0;
        rbbi.cyMinChild = _uToolbar - (CY_ETCH + 2 * CY_TBPADDING);

        SendMessage(_hwndTBRebar, RB_SETBANDINFO, 0, (LPARAM)&rbbi);
    }
}

void CBrowserBandSite::_CreateTB()
{
    ASSERT(!_hwndTB);

    // Create a rebar too so we get the chevron
    _CreateTBRebar();

    if (_hwndTBRebar)
    {
        _hwndTB = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
                        WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | TBSTYLE_TOOLTIPS |
                        TBSTYLE_FLAT | TBSTYLE_LIST | CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NORESIZE,
                        0, 0, 0, 0,
                        _hwndTBRebar, (HMENU) BBSC_TOOLBAR, HINST_THISDLL, NULL);
    }

    if (_hwndTB)
    {
        SendMessage(_hwndTB, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
        SendMessage(_hwndTB, CCM_SETVERSION, COMCTL32_VERSION, 0);

        // FEATURE: use TBSTYLE_EX_HIDECLIPPEDBUTTONS here?  looks kinda goofy so i'm leaving it out for now.
        SendMessage(_hwndTB, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_DRAWDDARROWS | TBSTYLE_EX_MIXEDBUTTONS);

        SendMessage(_hwndTB, TB_SETMAXTEXTROWS, 1, 0L);

        _UpdateToolbarFont();

        _InsertToolbarBand();
    }
}

void CBrowserBandSite::_RemoveAllButtons()
{
    if (!_hwndTB || !_hwndTBRebar)
        return;

    ShowWindow(_hwndTBRebar, SW_HIDE);
    _fToolbar = FALSE;

    INT_PTR nCount = SendMessage(_hwndTB, TB_BUTTONCOUNT, 0, 0L);
    while (nCount-- > 0)
        SendMessage(_hwndTB, TB_DELETEBUTTON, nCount, 0L);

    _UpdateLayout();
}

void CBrowserBandSite::_Close()
{
    ATOMICRELEASE(_pCmdTarget);

    //
    // Destroying _hwndTBRebar will take care of _hwndTB too
    //
    ASSERT(!_hwndTB || IsChild(_hwndTBRebar, _hwndTB));

    DESTROY_OBJ_WITH_HANDLE(_hwndTBRebar, DestroyWindow);
    DESTROY_OBJ_WITH_HANDLE(_hwndOptionsTB, DestroyWindow);

    DESTROY_OBJ_WITH_HANDLE(_hfont, DeleteObject);

    SUPERCLASS::_Close();
}

LRESULT CBrowserBandSite::_OnHotItemChange(LPNMTBHOTITEM pnmtb)
{
    LRESULT lres = 0;

    // We might want to drop down the chevron menu if the hot item change
    // flags has these characteristics:
    //
    //  - not HICF_LEAVING, since if HICF_LEAVING, the hot item should instead wrap to _hwndClose
    //  - and not HICF_MOUSE, since we only drop down on keyboard hot item change
    //  - HICF_ACCELERATOR | HICF_ARROWKEYS, since we only drop down on keyboard hot item change
    //  - or HICF_RESELECT, since we force a reselect in _TrySetFocusTB
    //
    if (!(pnmtb->dwFlags & (HICF_LEAVING | HICF_MOUSE)) &&
        (pnmtb->dwFlags & (HICF_RESELECT | HICF_ACCELERATOR | HICF_ARROWKEYS)))
    {
        // Check to see if new hot button is clipped.  If it is,
        // then we pop down the chevron menu.
        RECT rc;
        GetClientRect(_hwndTB, &rc);

        int iButton = (int)SendMessage(_hwndTB, TB_COMMANDTOINDEX, pnmtb->idNew, 0);

        if (SHIsButtonObscured(_hwndTB, &rc, iButton))
        {
            // Clear hot item
            SendMessage(_hwndTB, TB_SETHOTITEM, -1, 0);

            // Figure out whether to highlight first or last item in menu
            UINT uSelect;
            int cButtons = (int)SendMessage(_hwndTB, TB_BUTTONCOUNT, 0, 0);
            if (iButton == cButtons - 1)
                uSelect = DBPC_SELECTLAST;
            else
                uSelect = DBPC_SELECTFIRST;

            // Pop it down
            SendMessage(_hwndTBRebar, RB_PUSHCHEVRON, 0, uSelect);

            lres = 1;
        }
    }

    return lres;
}

LRESULT CBrowserBandSite::_OnNotifyBBS(LPNMHDR pnm)
{
    switch (pnm->code)
    {
    case TBN_DROPDOWN:
        if (EVAL(_pCmdTarget))
        {
            LPNMTOOLBAR pnmtoolbar = (LPNMTOOLBAR)pnm;
            VARIANTARG  var;
            RECT rc = pnmtoolbar->rcButton;
            
            var.vt = VT_I4;
            MapWindowPoints(_hwndTB, HWND_DESKTOP, (LPPOINT)&rc, 2);
            var.lVal = MAKELONG(rc.left, rc.bottom);
            
            _pCmdTarget->Exec(&_guidButtonGroup, pnmtoolbar->iItem, OLECMDEXECOPT_PROMPTUSER, &var, NULL);
        }
        break;

    case TBN_WRAPHOTITEM:
        {
            LPNMTBWRAPHOTITEM pnmwh = (LPNMTBWRAPHOTITEM) pnm;

            if (pnmwh->nReason & HICF_ARROWKEYS) {
                if (pnm->hwndFrom == _hwndOptionsTB) {
                    if (_TrySetFocusTB(pnmwh->iDir) != S_OK)
                        return 0;
                } else {
                    ASSERT(pnm->hwndFrom == _hwndTB);
                    SetFocus(_hwndOptionsTB);
                }
                return 1;
            }
        }
        break;

    case TBN_HOTITEMCHANGE:
        if (pnm->hwndFrom == _hwndTB)
            return _OnHotItemChange((LPNMTBHOTITEM)pnm);
        break;

    case TBN_GETINFOTIP:
        //  [scotthan] We'll ask the toolbar owner for tip text via
        //  IOleCommandTarget::QueryStatus, like we do w/ defview for itbar buttons
        if (_pCmdTarget && pnm->hwndFrom == _hwndTB)
        {
            NMTBGETINFOTIP* pgit = (NMTBGETINFOTIP*)pnm ;

            OLECMDTEXTV<MAX_TOOLTIP_STRING> cmdtv;
            OLECMDTEXT *pcmdText = &cmdtv;
 
            pcmdText->cwBuf    = MAX_TOOLTIP_STRING;
            pcmdText->cmdtextf = OLECMDTEXTF_NAME;
            pcmdText->cwActual = 0;
 
            OLECMD rgcmd = {pgit->iItem, 0};
 
            HRESULT hr = _pCmdTarget->QueryStatus(&_guidButtonGroup, 1, &rgcmd, pcmdText);
            if (SUCCEEDED(hr) && (pcmdText->cwActual))
            {
                SHUnicodeToTChar(pcmdText->rgwz, pgit->pszText, pgit->cchTextMax);
                return 1;
            }
        }
        break ;

    case RBN_CHEVRONPUSHED:
        LPNMREBARCHEVRON pnmch = (LPNMREBARCHEVRON) pnm;

        MapWindowPoints(pnmch->hdr.hwndFrom, HWND_DESKTOP, (LPPOINT)&pnmch->rc, 2);
        ToolbarMenu_Popup(_hwnd, &pnmch->rc, NULL, _hwndTB, 0, (DWORD)pnmch->lParamNM);

        return 1;
    }

    return 0;
}

// *** IWinEventHandler ***
HRESULT CBrowserBandSite::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    switch (uMsg)
    {
    case WM_COMMAND:
        {
            HWND hwndControl = GET_WM_COMMAND_HWND(wParam, lParam);
            UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);

            if (hwndControl && hwndControl == _hwndTB)
            {
                if (EVAL(_pCmdTarget))
                {
                    RECT rc;
                    VARIANTARG var;

                    var.vt = VT_I4;
                    SendMessage(_hwndTB, TB_GETRECT, idCmd, (LPARAM)&rc);
                    MapWindowPoints(_hwndTB, HWND_DESKTOP, (LPPOINT)&rc, 2);
                    var.lVal = MAKELONG(rc.left, rc.bottom);

                    _pCmdTarget->Exec(&_guidButtonGroup, idCmd, 0, &var, NULL);
                }
                return S_OK;
            }
            else if (hwndControl == _hwndOptionsTB) {
                switch (idCmd) {
                case IDM_AB_CLOSE:
                    IUnknown_Exec(_punkSite, &CGID_DeskBarClient, DBCID_EMPTY, 0, NULL, NULL);
                    break;

                case IDM_AB_AUTOHIDE:
                    { 
                        VARIANTARG v = {0};
                        v.vt = VT_I4;
                        v.lVal = _fNoAutoHide;
                        IUnknown_Exec(_punkSite, &CGID_Theater, THID_SETBROWSERBARAUTOHIDE, 0, &v, NULL);

                        break;
                    }
                }
                return S_OK;
            }
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnm = (LPNMHDR)lParam;
            if (pnm && (pnm->hwndFrom == _hwndTB || pnm->hwndFrom == _hwndOptionsTB || pnm->hwndFrom == _hwndTBRebar)) {
                *plres = _OnNotifyBBS(pnm);
                return S_OK;
            }
        }
        break;

    case WM_SIZE:
        {
            POINT pt = {LOWORD(lParam), HIWORD(lParam)};
            _PositionToolbars(&pt);
        }
        break;
    }

    return SUPERCLASS::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
}

HRESULT CBrowserBandSite::IsWindowOwner(HWND hwnd)
{
    if (hwnd && (hwnd == _hwndTB) || (hwnd == _hwndOptionsTB) || (hwnd == _hwndTBRebar))
        return S_OK;

    return SUPERCLASS::IsWindowOwner(hwnd);
}

// *** IBandSite ***
HRESULT CBrowserBandSite::SetBandSiteInfo(const BANDSITEINFO * pbsinfo)
{
    // recompute our layout if vertical viewmode is changing
    BOOL fUpdate = ((pbsinfo->dwMask & BSIM_STATE) && 
                    ((pbsinfo->dwState ^ _dwMode) & DBIF_VIEWMODE_VERTICAL));
    // ...or if caption is turned on or off
    BOOL fCaptionStyleChanged = (   (pbsinfo->dwMask & BSIM_STYLE)
                                 && ((pbsinfo->dwStyle ^ _dwStyle) & BSIS_NOCAPTION));

    HRESULT hres = SUPERCLASS::SetBandSiteInfo(pbsinfo);

    if (fCaptionStyleChanged && _hwndOptionsTB)
    {
        if (_fToolbar) {
            // don't know if "new" band requires buttons or not, expect band to add buttons again if needed
            _RemoveAllButtons();
        }
        // show or hide close/hide toolbar; is always created since bandsites get reused!
        ::ShowWindow(_hwndOptionsTB, (_dwStyle & BSIS_NOCAPTION) ? SW_HIDE : SW_SHOW);
    }

    if (fUpdate || fCaptionStyleChanged) {
        _InitLayout();
    }

    return hres;
}


// *** IExplorerToolbar ***
HRESULT CBrowserBandSite::SetCommandTarget(IUnknown* punkCmdTarget, const GUID* pguidButtonGroup, DWORD dwFlags)
{
    HRESULT hres = S_OK;
    BOOL fRemoveButtons = TRUE;

    // dwFlags is not used
    ASSERT(!(dwFlags));

    ATOMICRELEASE(_pCmdTarget);
    if (punkCmdTarget && pguidButtonGroup)
    {
        hres = punkCmdTarget->QueryInterface(IID_IOleCommandTarget, (void**)&(_pCmdTarget));

        if (!_hwndTB)
        {
            _CreateTB();
        }
        else if (_fToolbar && IsEqualGUID(_guidButtonGroup, *pguidButtonGroup))
        {
            fRemoveButtons = FALSE;
            hres = S_FALSE;
        }

        _guidButtonGroup = *pguidButtonGroup;
    }
    else
        ASSERT(!punkCmdTarget);

    if (fRemoveButtons)
        _RemoveAllButtons();

    ASSERT(SUCCEEDED(hres));
    return hres;
}

// client should have already called AddString
HRESULT CBrowserBandSite::AddButtons(const GUID* pguidButtonGroup, UINT nButtons, const TBBUTTON* lpButtons)
{
    if (!_hwndTB || !nButtons)
        return E_FAIL;

    _RemoveAllButtons();

    if (SendMessage(_hwndTB, TB_ADDBUTTONS, nButtons, (LPARAM)lpButtons))
    {
        ShowWindow(_hwndTBRebar, SW_SHOW);
        _fToolbar = TRUE;

        _UpdateLayout();

        return S_OK;
    }

    return E_FAIL;
}

HRESULT CBrowserBandSite::AddString(const GUID* pguidButtonGroup, HINSTANCE hInst, UINT_PTR uiResID, LRESULT* pOffset)
{
    *pOffset = -1;
    if (!_hwndTB)
        return E_FAIL;

    *pOffset = SendMessage(_hwndTB, TB_ADDSTRING, (WPARAM)hInst, (LPARAM)uiResID);

    if (*pOffset != -1)
        return S_OK;

    return E_FAIL;
}

HRESULT CBrowserBandSite::GetButton(const GUID* pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton)
{
    if (!_hwndTB)
        return E_FAIL;

    UINT_PTR uiIndex = SendMessage(_hwndTB, TB_COMMANDTOINDEX, uiCommand, 0L);
    if (SendMessage(_hwndTB, TB_GETBUTTON, uiIndex, (LPARAM)lpButton))
        return S_OK;

    return E_FAIL;
}

HRESULT CBrowserBandSite::GetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT* pfState)
{
    if (!_hwndTB)
        return E_FAIL;

    *pfState = (UINT)SendMessage(_hwndTB, TB_GETSTATE, uiCommand, 0L);
    return S_OK;
}

HRESULT CBrowserBandSite::SetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT fState)
{
    if (!_hwndTB)
        return E_FAIL;

    UINT_PTR uiState = SendMessage(_hwndTB, TB_GETSTATE, uiCommand, NULL);
    uiState ^= fState;
    if (uiState)
        SendMessage(_hwndTB, TB_SETSTATE, uiCommand, (LPARAM)fState);

    return S_OK;
}

HRESULT CBrowserBandSite::SetImageList( const GUID* pguidCmdGroup, HIMAGELIST himlNormal, HIMAGELIST himlHot, HIMAGELIST himlDisabled)
{
    if (IsEqualGUID(*pguidCmdGroup, _guidButtonGroup)) {
        SendMessage(_hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himlNormal);
        SendMessage(_hwndTB, TB_SETHOTIMAGELIST, 0, (LPARAM)himlHot);
        SendMessage(_hwndTB, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)himlDisabled);
    }
    return S_OK;
};

BYTE TBStateFromIndex(HWND hwnd, int iIndex)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(TBBUTTONINFO);
    tbbi.dwMask = TBIF_BYINDEX | TBIF_STATE;
    tbbi.fsState = 0;
    SendMessage(hwnd, TB_GETBUTTONINFO, iIndex, (LPARAM)&tbbi);

    return tbbi.fsState;
}

int CBrowserBandSite::_ContextMenuHittest(LPARAM lParam, POINT* ppt)
{
    if (lParam == (LPARAM)-1)
    {
        //
        // Keyboard activation.  If one of our toolbars has
        // focus, and it has a hottracked button, put up the
        // context menu below that button.
        //
        HWND hwnd = GetFocus();
        if (hwnd && (hwnd == _hwndTB || hwnd == _hwndOptionsTB))
        {
            INT_PTR iHot = SendMessage(hwnd, TB_GETHOTITEM, 0, 0);
            if (iHot == -1)
            {
                // couldn't find a hot item, just use the first visible button
                iHot = 0;
                while (TBSTATE_HIDDEN & TBStateFromIndex(hwnd, (int)iHot))
                    iHot++;

                ASSERT(iHot < SendMessage(hwnd, TB_BUTTONCOUNT, 0, 0));
            }

            RECT rc;
            SendMessage(hwnd, TB_GETITEMRECT, iHot, (LPARAM)&rc);

            ppt->x = rc.left;
            ppt->y = rc.bottom;

            MapWindowPoints(hwnd, HWND_DESKTOP, ppt, 1);

            return -1;
        }
    }

    return SUPERCLASS::_ContextMenuHittest(lParam, ppt);
}

HMENU CBrowserBandSite::_LoadContextMenu()
{
    HMENU hmenu = SUPERCLASS::_LoadContextMenu();
    DeleteMenu(hmenu, BSIDM_SHOWTITLEBAND, MF_BYCOMMAND);
    return hmenu;
}

// create the options (close/hide) buttons
void CBrowserBandSite::_CreateOptionsTB()
{
    // create toolbar for close/hide button always since band site is reused
    // for captionless band sites (iBar), this toolbar is only hidden
    _hwndOptionsTB = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
                                WS_VISIBLE | 
                                WS_CHILD | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS |
                                WS_CLIPCHILDREN |
                                WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOMOVEY | CCS_NOPARENTALIGN |
                                CCS_NORESIZE,
                                0, 0, 30, 18, _hwnd, 0, HINST_THISDLL, NULL);

    _PrepareOptionsTB();
}

// init as toolbar and load bitmaps
void CBrowserBandSite::_PrepareOptionsTB()
{
    if (_hwndOptionsTB)
    {
        static const TBBUTTON c_tb[] =
        {
            { 0, IDM_AB_AUTOHIDE, TBSTATE_ENABLED, TBSTYLE_CHECK, {0,0}, 0, 0 },
            { 1, IDM_AB_CLOSE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 1 }
        };

        SendMessage(_hwndOptionsTB, TB_BUTTONSTRUCTSIZE,    sizeof(TBBUTTON), 0);
        SendMessage(_hwndOptionsTB, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(_hwndOptionsTB, TB_SETBITMAPSIZE, 0, (LPARAM) MAKELONG(13, 11));
        TBADDBITMAP tbab = { HINST_THISDLL, IDB_BROWSERTOOLBAR };
        SendMessage(_hwndOptionsTB, TB_ADDBITMAP, 3, (LPARAM)&tbab);

        LONG_PTR cbOffset = SendMessage(_hwndOptionsTB, TB_ADDSTRING, (WPARAM)MLGetHinst(), (LPARAM)IDS_BANDSITE_CLOSE_LABELS);
        TBBUTTON tb[ARRAYSIZE(c_tb)];
        UpdateButtonArray(tb, c_tb, ARRAYSIZE(c_tb), cbOffset);

        SendMessage(_hwndOptionsTB, TB_SETMAXTEXTROWS, 0, 0);

        SendMessage(_hwndOptionsTB, TB_ADDBUTTONS, ARRAYSIZE(tb), (LPARAM)tb);

        SendMessage(_hwndOptionsTB, TB_SETINDENT, (WPARAM)0, 0);
        
        _SizeOptionsTB();
    }    
}

void CBrowserBandSite::_PositionToolbars(LPPOINT ppt)
{
    RECT rc;

    if (ppt) 
    {
        rc.left = 0;
        rc.right = ppt->x;
    } 
    else 
    {
        GetClientRect(_hwnd, &rc);
    }

    if (_hwndOptionsTB) 
    {
        // always put the close restore at the top right of the floater window
        int x;

        if (_dwMode & DBIF_VIEWMODE_VERTICAL) 
        {
            RECT rcTB;
            GetWindowRect(_hwndOptionsTB, &rcTB);
            x = rc.right - RECTWIDTH(rcTB) - 1;
        }
        else
        {
            x = rc.left;
        }

        MARGINS mBorders = {0, 1, 0, 0};        // 1 mimics old behavior downlevel.
        Comctl32_GetBandMargins(_hwnd, &mBorders);

        SetWindowPos(_hwndOptionsTB, HWND_TOP, x - mBorders.cxRightWidth, mBorders.cyTopHeight, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
    }

    if (_hwndTBRebar)
    {
        if (_fToolbar) 
        {
            // toolbar goes on its own line below title
            SetWindowPos(_hwndTBRebar, HWND_TOP, 
                            rc.left + CX_TBOFFSET,
                            _uTitle + CX_TBOFFSET,
                            rc.right - 2 * CX_TBOFFSET,
                            _uToolbar,
                            SWP_SHOWWINDOW);

        } 
        else 
        {
            ASSERT(!IsWindowVisible(_hwndTBRebar));
        }
    }
}

// sets the size of the toolbar.  if we're in theater mode, we need to show the pushpin.
// otherwise just show the close
void CBrowserBandSite::_SizeOptionsTB()
{
    RECT rc;
    GetWindowRect(_hwndOptionsTB, &rc);
    LRESULT lButtonSize = SendMessage(_hwndOptionsTB, TB_GETBUTTONSIZE, 0, 0L);
    SetWindowPos(_hwndOptionsTB, NULL, 0, 0, LOWORD(lButtonSize) * (_fTheater ? 2 : 1),
                 RECTHEIGHT(rc), SWP_NOMOVE | SWP_NOACTIVATE);

    DWORD_PTR dwState = SendMessage(_hwndOptionsTB, TB_GETSTATE, IDM_AB_AUTOHIDE, 0);
    dwState &= ~(TBSTATE_HIDDEN | TBSTATE_CHECKED);
    if (!_fTheater)
        dwState |= TBSTATE_HIDDEN;
    if (_fNoAutoHide)
        dwState |= TBSTATE_CHECKED;
    SendMessage(_hwndOptionsTB, TB_SETSTATE, IDM_AB_AUTOHIDE, dwState);
    _PositionToolbars(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\browmenu.h ===
#ifndef _BROWMENU_H_
#define _BROWMENU_H_

#include "cowsite.h"

// IShellMenuCallback implementation
class CFavoritesCallback : public IShellMenuCallback,
                           public CObjectWithSite
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // *** CObjectWithSite methods (override)***
    STDMETHODIMP SetSite(IUnknown* punk);

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA smd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    CFavoritesCallback();
private:
    virtual ~CFavoritesCallback();
    int     _cRef;
    BOOL    _fOffline;
    BOOL    _fRefresh;
    BOOL    _fExpandoMenus;
    BOOL    _fShowingTip;

    HRESULT _GetHmenuInfo(HMENU hMenu, UINT uId, SMINFO* psminfo);
    HRESULT _SelectItem(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl);
    HRESULT _Init(HMENU hMenu, UINT uIdParent, IUnknown* punk);
    HRESULT _Exit();
    HRESULT _GetObject(LPSMDATA psmd, REFIID riid, void** ppvObj);
    HRESULT _GetDefaultIcon(TCHAR* psz, int* piIndex);
    HRESULT _GetSFInfo(SMDATA* psmd, SMINFO* psminfo);
    HRESULT _Demote(LPSMDATA psmd);
    HRESULT _Promote(LPSMDATA psmd);
    HRESULT _HandleNew(LPSMDATA psmd);
    DWORD   _GetDemote(SMDATA* psmd);
    HRESULT _GetTip(LPTSTR pstrTitle, LPTSTR pstrTip);
    HRESULT _ProcessChangeNotify(SMDATA* psmd, LONG lEvent, 
                                 LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    BOOL _AllowDrop(IDataObject* pIDataObject, HWND hwnd);

    IShellMenu* _psmFavCache;

    void _RefreshItem(HMENU hmenu, int idCmd, IShellMenu* psm);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\bsmenu.cpp ===
#include "priv.h"

#include "sccls.h"
#include "bands.h"
#include "bsmenu.h"
#include "isfband.h"
#include "legacy.h"
#include "resource.h"
#include "uemapp.h"
#include "enumband.h"

#include "mluisupp.h"

static const CLSID g_clsidNull = {0};

#define DPA_SafeGetPtrCount(hdpa)   (hdpa ? DPA_GetPtrCount(hdpa) : 0)

HRESULT CBandSiteMenu_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CBandSiteMenu *p = new CBandSiteMenu();
    if (p)
    {
        *ppunk = SAFECAST(p, IShellService*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

CBandSiteMenu::CBandSiteMenu() : _cRef(1)
{
    DllAddRef();
}

CBandSiteMenu::~CBandSiteMenu()
{
    DPA_DestroyCallback(_hdpaBandClasses, _DPA_FreeBandClassInfo, 0);
    _hdpaBandClasses = NULL;
    SetOwner(NULL);
    DllRelease();
}

int CBandSiteMenu::_DPA_FreeBandClassInfo(LPVOID p, LPVOID d)
{
    BANDCLASSINFO *pbci = (BANDCLASSINFO*)p;

    // req'd
    ASSERT(pbci->pszName || (*(int *)&pbci->clsid == 0));
    
    if (pbci->pszName)
        LocalFree(pbci->pszName);

    // optional
    if (pbci->pszIcon != NULL)
        LocalFree(pbci->pszIcon);
    if (pbci->pszMenu != NULL)
        LocalFree(pbci->pszMenu);
    if (pbci->pszHelp != NULL)
        LocalFree(pbci->pszHelp);
    if (pbci->pszMenuPUI != NULL)
        LocalFree(pbci->pszMenuPUI);
    if (pbci->pszHelpPUI != NULL)
        LocalFree(pbci->pszHelpPUI);

    LocalFree(pbci);

    return 1;
}


ULONG CBandSiteMenu::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CBandSiteMenu::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CBandSiteMenu::SetOwner(IUnknown* punk)
{
    ATOMICRELEASE(_pbs);
    
    if (punk)
    {
        punk->QueryInterface(IID_IBandSite, (LPVOID*)&_pbs);
    }
    
    return S_OK;
}

HRESULT CBandSiteMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg, wParam, lParam, NULL);
}

UINT CBandSiteMenu::_IDToInternal(UINT uID)
{
    if (uID != -1)
    {
        uID -= _idCmdFirst;
    }

    return uID;
}

UINT CBandSiteMenu::_IDToExternal(UINT uID)
{
    if (uID != -1)
    {
        uID += _idCmdFirst;
    }

    return uID;
}

LRESULT CBandSiteMenu::_OnInitMenuPopup(HMENU hmenu, UINT uPos)
{
    //
    // Is this is the "Toolbars >" submenu (which we populate
    // lazily), and has it not yet been populated?
    //
    UINT uID = GetMenuItemID(hmenu, 0);
    uID = _IDToInternal(uID);
    if (uID == DBIDM_DESKTOPBAND)
    {
        // Yes
        _PopulateSubmenu(hmenu);
    }

    return 0;
}

HRESULT CBandSiteMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    LRESULT lres = 0;

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        lres = _OnInitMenuPopup((HMENU)wParam, LOWORD(lParam));
        break;
    }

    if (plres)
        *plres = lres;

    return S_OK;
}

HRESULT CBandSiteMenu::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CBandSiteMenu, IContextMenu3),
        QITABENTMULTI(CBandSiteMenu, IContextMenu2, IContextMenu3),
        QITABENTMULTI(CBandSiteMenu, IContextMenu, IContextMenu3),
        QITABENT(CBandSiteMenu, IShellService),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
    {
        if (IsEqualIID(riid, CLSID_BandSiteMenu))
        {
            *ppvObj = (void *) this;
            AddRef();
            return S_OK;
        }
    }

    return hres;
} 

#define MAX_BANDS  50

void CBandSiteMenu::_PopulateSubmenu(HMENU hmenuSub)
{
    // the start id is the last of the fixed bands.
    // when we do the Shell_MergeMenus below, it will be incremented by idCmdFirst

    ASSERT(hmenuSub);

    CATID catid = CATID_DeskBand;

    if (_hdpaBandClasses)
    {
        DPA_DestroyCallback(_hdpaBandClasses, _DPA_FreeBandClassInfo, 0);
        _hdpaBandClasses = NULL;
    }

    LoadFromComCat(&catid);

    // Kick off an asynchronous update of the comcat cache
    SHWriteClassesOfCategories(1, &catid, 0, NULL, TRUE, FALSE, NULL);

    _idCmdEnumFirst = CreateMergeMenu(hmenuSub, MAX_BANDS, 0, _IDToExternal(DBIDM_NEWBANDFIXEDLAST), 0, FALSE);

    _AddEnumMenu(hmenuSub, GetMenuItemCount(hmenuSub) - 2); // -2 to go before "New Toolbar" and separator
    
    int iIndex = GetMenuItemCount(hmenuSub);
    if (SHRestricted(REST_NOCLOSE_DRAGDROPBAND) || SHRestricted(REST_CLASSICSHELL))
    {
        // We also need to disable turning On or Off the Bands.
        // In classic mode, don't allow them either.
        int nIter;
        for (nIter = 0; nIter < iIndex; nIter++)
            EnableMenuItem(hmenuSub, nIter, MF_BYPOSITION | MF_GRAYED);
    }

    if (SHRestricted(REST_CLASSICSHELL))
    {
        // Disable New Toolbar menu also.
        EnableMenuItem(hmenuSub, DBIDM_NEWFOLDERBAND, MF_BYCOMMAND | MF_GRAYED);
    }
}

HRESULT CBandSiteMenu::QueryContextMenu(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags)
{
    if (!_pbs)
        return E_FAIL;

    if (SHRestricted(REST_NOTOOLBARSONTASKBAR))
    {
        return E_FAIL;
    }

    HMENU hmenuSrc = LoadMenuPopup_PrivateNoMungeW(MENU_DESKBARAPP);
    if (hmenuSrc)
    {
        _idCmdFirst = idCmdFirst;

        Shell_MergeMenus(hmenu, hmenuSrc, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
        DestroyMenu(hmenuSrc);

        if (_SHIsMenuSeparator(hmenu, indexMenu))
        {
            //
            // Adjust indexMenu to point to the spot where the Toolbars
            // submenu was actually inserted.
            //
            indexMenu++;
        }

        if (!(uFlags & CMF_ICM3))
        {
            //
            // Caller doesn't speak ICM3, so won't give us a chance to
            // populate submenu on WM_INITMENUPOPUP.  Thus we need to
            // populate it now.
            //
            HMENU hmenuSub = GetSubMenu(hmenu, indexMenu);

            if (hmenuSub)
                _PopulateSubmenu(hmenuSub);
        }
#ifdef DEBUG
        else
        {
            //
            // _OnInitMenuPopup assumes DBIDM_DESKTOPBAND is the first item
            // in the "Toolbars >" submenu.  If that assumption breaks (and
            // you see this ASSERT rip), be sure to fix up the code there.
            //
            HMENU hmenuSub = GetSubMenu(hmenu, indexMenu);
            ASSERT(GetMenuItemID(hmenuSub, 0) == _IDToExternal(DBIDM_DESKTOPBAND));
        }
#endif

        //
        // Assert that our caller gave us enough room to accomodate
        // the worst-case count.
        //
        ASSERT((idCmdFirst + DBIDM_NEWBANDFIXEDLAST + MAX_BANDS) < idCmdLast);

        return idCmdFirst + DBIDM_NEWBANDFIXEDLAST + MAX_BANDS;
    }

    return E_FAIL;
}

BOOL CBandSiteMenu::_CheckUnique(IDeskBand* pdb, HMENU hmenu) 
{
    // check to see if this band is unique. (not already added by comcat list or
    // hard coded list
    // if it is unique, return TRUE.
    // if it's not, check the other menu item
    CLSID clsid;
    DWORD dwPrivID;
    BOOL fRet = TRUE;
    UINT idCmd = (UINT)-1;
    
    if (SUCCEEDED(_GetBandIdentifiers(pdb, &clsid, &dwPrivID)))
    {
        // check the comcat list
        if (dwPrivID == (DWORD)-1)
        {
            for (int i = 0; i < DPA_SafeGetPtrCount(_hdpaBandClasses) ; i++)
            {
                BANDCLASSINFO *pbci = (BANDCLASSINFO*)DPA_GetPtr(_hdpaBandClasses, i);
                if (IsEqualGUID(clsid, pbci->clsid))
                {
                    idCmd = i + DBIDM_NEWBANDFIXEDLAST;
                    goto FoundIt;
                }
            }
        }
        else if (IsEqualGUID(clsid, CLSID_ISFBand))
        {
            // check our hardcoded list

            switch (dwPrivID)
            {
            case CSIDL_DESKTOP:
                idCmd = DBIDM_DESKTOPBAND;
                break;
                
            case CSIDL_APPDATA:
                idCmd = DBIDM_LAUNCHBAND;
                break;
                
            }
        }
    }

FoundIt:
    if (idCmd != (UINT)-1)
    {
        // we found a menu for this already.... if it wasn't already checked,
        // check it now and it will represent us
        if (!(GetMenuState(hmenu, _IDToExternal(idCmd), MF_BYCOMMAND) & MF_CHECKED))
        {
            CheckMenuItem(hmenu, _IDToExternal(idCmd), MF_BYCOMMAND | MF_CHECKED);
            fRet = FALSE;
        }
    }
    return fRet;
}

void CBandSiteMenu::_AddEnumMenu(HMENU hmenu, int iInsert)
{
    DWORD dwID;

    int iMax = MAX_BANDS - (_IDToInternal(_idCmdEnumFirst) - DBIDM_NEWBANDFIXEDLAST);

    for (int i = 0; i < iMax && SUCCEEDED(_pbs->EnumBands(i, &dwID)); i++)
    {
        HRESULT hr;
        WCHAR szName[80];
        DWORD dwFlags = MF_BYPOSITION;
        DWORD dwState;
        IDeskBand *pdb;

        hr = _pbs->QueryBand(dwID, &pdb, &dwState, szName, ARRAYSIZE(szName));
        if (EVAL(SUCCEEDED(hr)))
        {
            if (_CheckUnique(pdb, hmenu))
            {
                if (dwState & BSSF_VISIBLE)
                    dwFlags |= MF_CHECKED;

                if (!(dwState & BSSF_UNDELETEABLE))
                {
                    InsertMenu(hmenu, iInsert, dwFlags, _idCmdEnumFirst + i, szName);
                    iInsert++;
                }
            }
        }
        
        if (pdb)
            pdb->Release();
    }
}

HRESULT CBandSiteMenu::_GetBandIdentifiers(IUnknown *punk, CLSID* pclsid, DWORD* pdwPrivID)
{
    HRESULT hr = E_FAIL;
    IPersist* pp;

    if (SUCCEEDED(punk->QueryInterface(IID_IPersist, (LPVOID*)&pp)))
    {
        pp->GetClassID(pclsid);

        VARIANTARG v = {0};
        *pdwPrivID = (DWORD) -1;
        if (SUCCEEDED(IUnknown_Exec(punk, &CGID_ISFBand, ISFBID_PRIVATEID, 0, NULL, &v)))
        {
            if (v.vt == VT_I4)
            {
                *pdwPrivID = (DWORD)v.lVal;
            }
        }
        hr = S_OK;
        pp->Release();
    }
    return hr;
}

// we use IPersist to find the class id of bands.
// we have a few special case bands (such as Quick Launch and Desktop) that are 
// the same band, but pointing to different objects.
HRESULT CBandSiteMenu::_FindBand(const CLSID* pclsid, DWORD dwPrivID, DWORD* pdwBandID)
{
    int i = 0;
    BOOL fFound = FALSE;
    HRESULT hr = E_FAIL;
    DWORD dwBandID = -1;

    while (hr == E_FAIL && SUCCEEDED(_pbs->EnumBands(i, &dwBandID)))
    {
        IDeskBand* pdb;

        if (SUCCEEDED(_pbs->QueryBand(dwBandID, &pdb, NULL, NULL, 0)))
        {
            CLSID clsid;
            DWORD dwPrivData;
            if (SUCCEEDED(_GetBandIdentifiers(pdb, &clsid, &dwPrivData)))
            {
                // special case for differentiating between all of the isfbands
                // find out if the private id this holds is the same as what we're asking for
                if (IsEqualIID(clsid, *pclsid) && (dwPrivData == dwPrivID))
                {
                    hr = S_OK;
                }
            }
            pdb->Release();
        }
        i++;
    }
    
    if (pdwBandID)
        *pdwBandID = dwBandID;
    return hr;
}

HRESULT CBandSiteMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    int idCmd;
    
    if (!_pbs)
        return E_FAIL;
    
    if (!HIWORD(pici->lpVerb))
        idCmd = LOWORD(pici->lpVerb);
    else
        return E_FAIL;

    //
    // N.B.: Caller has mapped idCmd to internal for us
    //

    int idCmdEnumFirstInt = _IDToInternal(_idCmdEnumFirst);

    if (idCmd >= idCmdEnumFirstInt)
    {
        // these are the bands that they're turning on and off
        
        DWORD dwID;
        if (SUCCEEDED(_pbs->EnumBands(idCmd - idCmdEnumFirstInt, &dwID)))
        {
            _pbs->RemoveBand(dwID);
        }
    }
    else
    {
        // these are our merged menus from MENU_DESKBARAPP
        switch (idCmd)
        {
        case DBIDM_NEWFOLDERBAND:
            _BrowseForNewFolderBand();
            break;
            
        case DBIDM_DESKTOPBAND:
            _ToggleSpecialFolderBand(CSIDL_DESKTOP, NULL, FALSE);
            break;
            
        case DBIDM_LAUNCHBAND:
        {
            TCHAR szSubDir[MAX_PATH];
            MLLoadString(IDS_QLAUNCHAPPDATAPATH, szSubDir, ARRAYSIZE(szSubDir));
            // Microsoft\\Internet Explorer\\Quick Launch
            _ToggleSpecialFolderBand(CSIDL_APPDATA, szSubDir, TRUE);
            break;
        }
            
        default:
            ASSERT(idCmd >= DBIDM_NEWBANDFIXEDLAST);
            _ToggleComcatBand(idCmd - DBIDM_NEWBANDFIXEDLAST);
            break;
        }
    }
    return S_OK;
}

HRESULT CBandSiteMenu::_BandClassEnum(REFCATID rcatid, REFCLSID rclsid, LPARAM lParam)
{
    TCHAR szName[128],
          szRegName[128],
          szClass[GUIDSTR_MAX];
    DWORD cbName;

    HDPA  hdpa = (HDPA)lParam;
    ASSERT(NULL != hdpa);

    // IE4 introduced this band, suppress it since we cut support for it in IE6
    if (IsEqualCLSID(CLSID_ChannelBand, rclsid))
    {
        return S_OK;
    }

    BANDCLASSINFO *pbci = (BANDCLASSINFO*)LocalAlloc(LPTR, sizeof(*pbci));
    if (NULL == pbci)
    {
        return E_OUTOFMEMORY;
    }

    pbci->clsid = rclsid;
    pbci->catid = rcatid;
    // now that we have the clsid, 
    // look in the registry for the display name
    SHStringFromGUID(pbci->clsid, szClass, ARRAYSIZE(szClass));
    StringCchPrintf(szRegName, ARRAYSIZE(szRegName), TEXT("CLSID\\%s"), szClass);

    cbName = ARRAYSIZE(szName);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, szRegName, NULL, NULL, szName, &cbName))
    {
        HKEY hkey;

        pbci->pszName = StrDup(szName);
        if (NULL == pbci->pszName)
        {
            return E_OUTOFMEMORY;
        }

        if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, szRegName, &hkey))
        {
            const struct regstrs rstab[] =
            {
                { TEXT("DefaultIcon"), FIELD_OFFSET(BANDCLASSINFO, pszIcon)    },
                { TEXT("MenuText")   , FIELD_OFFSET(BANDCLASSINFO, pszMenu)    },
                { TEXT("HelpText")   , FIELD_OFFSET(BANDCLASSINFO, pszHelp)    },
                { TEXT("MenuTextPUI"), FIELD_OFFSET(BANDCLASSINFO, pszMenuPUI) },
                { TEXT("HelpTextPUI"), FIELD_OFFSET(BANDCLASSINFO, pszHelpPUI) },
                { 0, 0 },
            };

            // szBuf big enough for "path,-32767" or for status text
            TCHAR szBuf[MAX_PATH+7];

            Reg_GetStrs(hkey, rstab, szBuf, (int)ARRAYSIZE(szBuf), (LPVOID)pbci);
            RegCloseKey(hkey);
        }

        DPA_AppendPtr(hdpa, pbci);
    }

    return S_OK;
}

//***
//  Collect band class info from registry...
int CBandSiteMenu::LoadFromComCat(const CATID *pcatid )
{
    if (NULL == _hdpaBandClasses)
    {
        _hdpaBandClasses = DPA_Create(4);
    }

    if (NULL != _hdpaBandClasses && NULL != pcatid)
    {
        SHEnumClassesImplementingCATID(*pcatid, CBandSiteMenu::_BandClassEnum, (LPARAM)_hdpaBandClasses);
    }

    return DPA_SafeGetPtrCount(_hdpaBandClasses);
}


int CBandSiteMenu::CreateMergeMenu(HMENU hmenu, UINT cMax, UINT iPosition, UINT idCmdFirst, UINT iStart, BOOL fMungeAllowed)
{
    int j = 0;
    int iMax = DPA_SafeGetPtrCount(_hdpaBandClasses);

    for (int i = iStart; i < iMax; i++)
    {
        if ((UINT)j >= cMax)
        {
            TraceMsg(DM_WARNING, "cbsm.cmm: cMax=%u menu overflow, truncated", cMax);
            break;
        }

        BANDCLASSINFO *pbci = (BANDCLASSINFO*)DPA_GetPtr(_hdpaBandClasses, i);
        DWORD         dwFlags = IsEqualCLSID(g_clsidNull,pbci->clsid) ? MF_BYPOSITION|MF_SEPARATOR : MF_BYPOSITION;
        LPTSTR        pszMenuText = pbci->pszMenuPUI ? pbci->pszMenuPUI : (pbci->pszMenu ? pbci->pszMenu : pbci->pszName) ;

        if (pszMenuText && *pszMenuText)
        {
            BOOL fInsert;

            if (fMungeAllowed)
            {
                fInsert = InsertMenu(hmenu, iPosition + j, dwFlags, idCmdFirst + j, pszMenuText);
            }
            else
            {
                fInsert = InsertMenu_PrivateNoMungeW(hmenu, iPosition + j, dwFlags, idCmdFirst + j, pszMenuText);
            }

            if (fInsert)
            {
                //  update menuitem cmd ID:
                pbci->idCmd = idCmdFirst + j;
                j++;
            }
        }
    }

    return j + idCmdFirst;
}


BANDCLASSINFO * CBandSiteMenu::GetBandClassDataStruct(UINT uBand)
{
    BANDCLASSINFO * pbci = (BANDCLASSINFO *)DPA_GetPtr(_hdpaBandClasses, uBand);
    return pbci;
}

BOOL CBandSiteMenu::DeleteBandClass( REFCLSID rclsid )
{
    if( _hdpaBandClasses )
    {
        for( int i = 0, cnt = GetBandClassCount( NULL, FALSE ); i< cnt; i++ )
        {
            BANDCLASSINFO * pbci = (BANDCLASSINFO *)DPA_GetPtr( _hdpaBandClasses, i );
            ASSERT( pbci );
        
            if( IsEqualCLSID( rclsid, pbci->clsid ) )
            {
                EVAL( DPA_DeletePtr( _hdpaBandClasses, i ) == (LPVOID)pbci );

                if( pbci->pszName )
                    LocalFree(pbci->pszName);
                LocalFree( pbci );
                return TRUE;
            }

        }
    }
    return FALSE;
}

int CBandSiteMenu::GetBandClassCount(const CATID* pcatid /*NULL*/, BOOL bMergedOnly /*FALSE*/)
{
    int cRet = 0; 

    if( _hdpaBandClasses != NULL )
    {
        int cBands = DPA_GetPtrCount(_hdpaBandClasses);
    
        if( pcatid || bMergedOnly ) // filter request
        {
            for( int i = 0; i < cBands; i++ )
            {
                BANDCLASSINFO * pbci = (BANDCLASSINFO *)DPA_FastGetPtr( _hdpaBandClasses, i );

                if( pbci->idCmd || !bMergedOnly )
                {
                    if( pcatid )
                    {
                        if( IsEqualGUID( pbci->catid, *pcatid )  )
                            cRet++;    
                    }
                    else
                        cRet++;
                }
            }
        }
        else
            cRet = cBands;
    }
    return cRet;
}

void CBandSiteMenu::_AddNewFSBand(LPCITEMIDLIST pidl, BOOL fNoTitleText, DWORD dwPrivID)
{
    IDeskBand *ptb = NULL;
    BOOL fISF = FALSE;

    // this was a drag of a link or folder
    // FEATURE: We should use a different test:
    //    DWORD dwAttrib = (SFGAO_FOLDER | SFGAO_BROWSABLE);
    //    IEGetAttributesOf(pidl, &dwAttrib);
    //    if (SFGAO_BROWSABLE != dwAttrib) 
    //    or we could reuse SHCreateBandForPidl().
    if (IsURLChild(pidl, TRUE))
    {
        // create browser to show web sites                        
        ptb = CBrowserBand_Create(pidl);
    }
    else
    {
        IFolderBandPriv *pfbp;
        // create an ISF band to show folders as hotlinks
        fISF = TRUE;
        ASSERT(pidl);       // o.w. CISFBand_CreateEx will fail
        if (FAILED(CISFBand_CreateEx(NULL, pidl, IID_PPV_ARG(IFolderBandPriv, &pfbp))))
        {
            // we need to give a pretty
            // generic message: "can't create toolbar for %1".
            TCHAR szName[MAX_URL_STRING];
            
            szName[0] = 0;
            SHGetNameAndFlags(pidl, SHGDN_NORMAL, szName, SIZECHARS(szName), NULL);
            MLShellMessageBox(NULL,
                MAKEINTRESOURCE(IDS_CANTISFBAND),
                MAKEINTRESOURCE(IDS_WEBBARTITLE),
                MB_OK|MB_ICONERROR, szName);
        }
        else
        {
            pfbp->SetNoText(fNoTitleText);
            if (SUCCEEDED(pfbp->QueryInterface(IID_PPV_ARG(IDeskBand, &ptb))))
            {
                if (dwPrivID != -1)
                {
                    VARIANTARG v;
                    v.vt = VT_I4;
                    v.lVal = dwPrivID;
                    // find out if the private id this holds is the same as what we're asking for
                    IUnknown_Exec(ptb, &CGID_ISFBand, ISFBID_PRIVATEID, 0, &v, NULL);
                    // qlaunch and qlinks get logged
                    // (should we key off of host or CSIDL or both?) 
                    // FEATURE: UASSIST todo: qlinks NYI
                    if (dwPrivID == CSIDL_APPDATA)
                    {
                        ASSERT(v.vt == VT_I4);
                        v.lVal = UEMIND_SHELL;  // UEMIND_SHELL/BROWSER
                        IUnknown_Exec(ptb, &CGID_ShellDocView, SHDVID_UEMLOG, 0, &v, NULL);
                    }
                }
            }
            pfbp->Release();
        }
    }

    if (ptb)
    {
        HRESULT hr = _pbs->AddBand(ptb);
        if (SUCCEEDED(hr) && fISF)
            _pbs->SetBandState(ShortFromResult(hr), BSSF_NOTITLE, fNoTitleText ? BSSF_NOTITLE : 0);
        ptb->Release();
    }
}

void CBandSiteMenu::_ToggleSpecialFolderBand(int iFolder, LPTSTR pszSubPath, BOOL fNoTitleText)
{

    DWORD dwBandID;
    if (SUCCEEDED(_FindBand(&CLSID_ISFBand, iFolder, &dwBandID)))
    {
        _pbs->RemoveBand(dwBandID);
    }
    else
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, iFolder, &pidl)))
        {
            if (pszSubPath)
            {
                TCHAR szPath[MAX_PATH];
                SHGetPathFromIDList(pidl, szPath);
                PathCombine(szPath, szPath, pszSubPath);
                ILFree(pidl);
                pidl = ILCreateFromPath(szPath);
                ASSERT(pidl);       // o.w. AddNewFSBand will fail
            }
            _AddNewFSBand(pidl, fNoTitleText, iFolder);
            ILFree(pidl);
        }
    }
}

int CALLBACK SetCaptionCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch (uMsg) 
    {
    case BFFM_INITIALIZED:
        TCHAR szTitle[80];
        MLLoadShellLangString(IDS_NEWFSBANDCAPTION, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(hwnd, szTitle);
        break;
    
    case BFFM_VALIDATEFAILEDA:
    case BFFM_VALIDATEFAILEDW:
        MLShellMessageBox(hwnd,
            uMsg == BFFM_VALIDATEFAILEDA ? MAKEINTRESOURCE(IDS_ERROR_GOTOA)
                                         : MAKEINTRESOURCE(IDS_ERROR_GOTOW),
            MAKEINTRESOURCE(IDS_WEBBARTITLE),
            MB_OK|MB_ICONERROR, (LPVOID)lParam);
        return 1;   // 1:leave dialog up for another try...
        /*NOTREACHED*/

    }

    return 0;
}


void CBandSiteMenu::_BrowseForNewFolderBand()
{
    BROWSEINFO bi = {0};
    LPITEMIDLIST pidl;
    TCHAR szTitle[256];
    TCHAR szPath[MAX_URL_STRING];

    if (_pbs)
        IUnknown_GetWindow(_pbs, &bi.hwndOwner);

    ASSERT(bi.pidlRoot == NULL);

    MLLoadShellLangString(IDS_NEWFSBANDTITLE, szTitle, ARRAYSIZE(szTitle));
    bi.lpszTitle = szTitle;

    bi.pszDisplayName = szPath;
    bi.ulFlags = (BIF_EDITBOX | BIF_VALIDATE | BIF_USENEWUI | BIF_BROWSEINCLUDEURLS);
    bi.lpfn = SetCaptionCallback;

    pidl = SHBrowseForFolder(&bi);
    if (pidl) 
    {
        _AddNewFSBand(pidl, FALSE, -1);
        ILFree(pidl);
    }
}

void CBandSiteMenu::_ToggleComcatBand(UINT idCmd)
{
    BANDCLASSINFO* pbci = (BANDCLASSINFO*)DPA_GetPtr(_hdpaBandClasses, idCmd);
    IUnknown* punk;
    DWORD dwBandID;
    
    if (SUCCEEDED(_FindBand(&pbci->clsid, -1, &dwBandID)))
    {
        _pbs->RemoveBand(dwBandID);
    }
    else if (S_OK == CoCreateInstance(pbci->clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID*)&punk))
    {
        // Language returns S_FALSE and doesn't initialize punk leave us to fault
        IPersistStreamInit * ppsi;

        // Some Bands don't work if IPersistStreamInit::InitNew() isn't called.
        // This includes the QuickLinks Band.
        if (SUCCEEDED(punk->QueryInterface(IID_IPersistStreamInit, (LPVOID*)&ppsi)))
        {
            ppsi->InitNew();
            ppsi->Release();
        }

        _pbs->AddBand(punk);
        punk->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\browseui.inc ===
#
# Common makefile include for this project
#

C_DEFINES       = $(C_DEFINES) \
                  -DIN_SHDOCVW \
                  -DFAVORITESTOSHDOCVW \
                  -DMLUI_SUPPORT \
                  -DMLUI_MESSAGEBOX \

# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) \
                  -DVSTF
!endif

# We don't define _ATL_MIN_CRT because we implement the functions ourselves
# (crtfree.h).

# Define _MERGE_PROXYSTUB to merge the proxy/stub code into the DLL
#C_DEFINES       = $(C_DEFINES) -D_MERGE_PROXYSTUB

# Bring in the ATL headers
USE_STATIC_ATL = 1

# Bring in the WTL headers
USE_WTL=1
WTL_VER=10

!if !defined(TARGET_WIN95)
USE_NEW_COMMCTRL = 1
!endif

!if defined(USE_NEW_COMMCTRL)
C_DEFINES       = $(C_DEFINES) -DUXCTRL_VERSION=0x0100
!endif

!include $(CCSHELL_DIR)\common.inc

LINKER_FLAGS    = $(LINKER_FLAGS) -MERGE:.CRT=.data

USE_MSVCRT      = 1

# be careful here-- browseui has to run downlevel. Don't add anything to
# the delayload line that you absolutely depend on having downlevel!
DELAYLOAD       = mpr.dll;shell32.dll;imm32.dll;wininet.dll;urlmon.dll;\
                  shdocvw.dll;msimg32.dll;oleaut32.dll;uxtheme.dll

!if !$(386)
DELAYLOAD       = $(DELAYLOAD);\
                  winmm.dll
!endif

DLOAD_ERROR_HANDLER = shlwapi

#BUGBUG (reinerf) - I promised bryant that I would fix these
LINKER_FLAGS    = $(LINKER_FLAGS) -ignore:4217 

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

#
# Skip these files when checking for dependencies
#
CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
                  emdef.h    \
                  emrule.h   \
                  mso.h      \
                  msoem.h    \
                  statreg.h  \
                  statreg.cpp \

INCLUDES=$(INCLUDES) \
    $(INETCORE_INC_PATH);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\chanbar.h ===
#ifndef _CHANBAR_H
#define _CHANBAR_H

#include "dbapp.h"

#define SZ_REGKEY_CHANBAR   TEXT("Software\\Microsoft\\Internet Explorer\\Channels")
#define SZ_REGVALUE_CHANBAR TEXT("window_placement")

typedef struct tagCISSTRUCT {
    UINT iVer; 
    RECT rc; 
} CISSTRUCT;

class CChannelDeskBarApp : public CDeskBarApp
{
public:
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);


    // *** IPersistPropertyBag ***
    virtual HRESULT STDMETHODCALLTYPE Load(IPropertyBag *pPropBag,
                                           IErrorLog *pErrorLog);
protected:
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static  LRESULT CALLBACK DummyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnCommand(UINT msg, WPARAM wparam, LPARAM lparam);
    virtual void _OnDisplayChange();
    virtual void _OnCreate();
    virtual void _OnSize(void);
    virtual void _UpdateCaptionTitle();
    void _CreateToolbar();
    void _PositionTB();
    void _SizeTB();
    void _PersistState();

    CChannelDeskBarApp();
    ~CChannelDeskBarApp();
    
    BOOL _OnCloseBar(BOOL fConfirm);
    
    HWND _hwndTB;
    HWND _hwndDummy; // for propagating WM_PALETTE* messages

    LONG _cxScreen, _cyScreen;   // the screen resolution

    friend HRESULT ChannelDeskBarApp_Create(IUnknown** ppunk, IUnknown** ppbs);
} ;

HRESULT ChannelDeskBarApp_Create(IUnknown** ppunk, IUnknown** ppbs);
void ChanBarSetAutoLaunchRegValue(BOOL);
void DesktopChannel();


#endif // _CHANBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\chanbar.cpp ===
#include "priv.h"
#ifdef ENABLE_CHANNELS
#include "sccls.h"
#include "resource.h"
#include "mshtmhst.h"
#include "deskbar.h"
#include "bands.h"
#define WANT_CBANDSITE_CLASS
#include "bandsite.h"

#include "chanbar.h"

#ifdef UNIX
#include <mainwin.h>
#endif

#include "mluisupp.h"

#define TBHEIGHT 20 // default height of the toolbar inside channel bar
#define TBWIDTH  20 // default width  of the toolbar inside channel bar


CChannelDeskBarApp::CChannelDeskBarApp() : _hwndDummy(NULL)
{
}

CChannelDeskBarApp::~CChannelDeskBarApp()
{
    if (IsWindow(_hwndDummy))
    {
        DestroyWindow(_hwndDummy);
    }
}

void CChannelDeskBarApp::_OnCreate()
{
    CDeskBarApp::_OnCreate();

    // remember screen resolution
    _cxScreen = GetSystemMetrics(SM_CXSCREEN);
    _cyScreen = GetSystemMetrics(SM_CYSCREEN);

    // create the dummy for receiving and forwarding broadcast messages 
    if (!_hwndDummy)
    {
        _hwndDummy = SHCreateWorkerWindow(DummyWndProc, 0, 0, 0, 0, this);
    }

    if (_hwndDummy)
    {
        // make sure we so a select a realize of a palette in this 
        // window so that we will get palette change notifications..
        HDC hdc = GetDC( _hwndDummy );
        if (hdc)
        {
            HPALETTE hpal = SHCreateShellPalette( hdc );

            if (hpal)
            {
                HPALETTE hpalOld = SelectPalette( hdc, hpal, TRUE );
                RealizePalette( hdc );

                // now select the old one back in
                SelectPalette( hdc, hpalOld, TRUE );
                DeletePalette( hpal );
            }

            ReleaseDC( _hwndDummy, hdc );
        }
    }
        
}

void CChannelDeskBarApp::_OnDisplayChange()
{
    // do not use lParam, since it may give us (0,0).
    UINT cxScreen = GetSystemMetrics(SM_CXSCREEN);
    UINT cyScreen = GetSystemMetrics(SM_CYSCREEN);
    UINT cxOldScreen = _cxScreen;
    UINT cyOldScreen = _cyScreen;
    
    _cxScreen = cxScreen;
    _cyScreen = cyScreen;
    
    if (_hwnd) {
        RECT rc;
        
        GetWindowRect(_hwnd, &rc);
        if (cxOldScreen) 
            rc.left = (rc.left * _cxScreen) / cxOldScreen;
        if (cyOldScreen)
            rc.top  = (rc.top  * _cyScreen) / cyOldScreen;

        SetWindowPos(_hwnd, NULL, rc.left, rc.top, 0, 0, 
                     SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

        // we need to change the cached pos/size. 
        OffsetRect(&_rcFloat, rc.left - _rcFloat.left, rc.top - _rcFloat.top);

    }
}

LRESULT CChannelDeskBarApp::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = 0;
    
    switch (uMsg) {
    case WM_CONTEXTMENU:    // disable context menu MENU_DESKBARAPP
    case WM_NCRBUTTONUP:    // disable context menu MENU_WEBBAR
        break;

    case WM_GETMINMAXINFO:  // prevent it from getting too small
        ((MINMAXINFO *)lParam)->ptMinTrackSize.x = TBWIDTH  + 10;
        ((MINMAXINFO *)lParam)->ptMinTrackSize.y = TBHEIGHT + 10;
        break;
        
    default:

        lRes = CDeskBarApp::v_WndProc(hwnd, uMsg, wParam, lParam);

        if (_hwnd) { // If our window is still alive
            switch (uMsg) {
            case WM_DISPLAYCHANGE:
                _OnDisplayChange(); // reposition when window resolution changes
                break;

            case WM_EXITSIZEMOVE:
                _PersistState();    // persist pos/size
                break;
            }
        }
    }
    
    return lRes;
}

LRESULT CALLBACK CChannelDeskBarApp::DummyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CChannelDeskBarApp* pcba = (CChannelDeskBarApp*)GetWindowPtr0(hwnd);
    
    switch (uMsg) {

        case WM_PALETTECHANGED :
            return SendMessage(pcba->_hwnd, uMsg, wParam, lParam );
            
        case WM_DISPLAYCHANGE  :
            // this message must be sent to the channel bar itself
            PostMessage(pcba->_hwnd, uMsg, wParam, lParam);
            // fall through ;
        
        case WM_WININICHANGE   :
        case WM_SYSCOLORCHANGE :
            PropagateMessage(pcba->_hwnd, uMsg, wParam, lParam, InSendMessage());
            // fall through ;
        default:
            return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }
}    

// overload CDeskBarApp::_UpdateCaptionTitle() to set title to "ChanApp"
void CChannelDeskBarApp::_UpdateCaptionTitle()
{
    SetWindowText(_hwnd, TEXT("ChanApp"));
}

// create the close button
void CChannelDeskBarApp::_CreateToolbar()
{
    _hwndTB = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                WS_VISIBLE | 
                                WS_CHILD | TBSTYLE_FLAT | TBSTYLE_TRANSPARENT | TBSTYLE_CUSTOMERASE |
                                WS_CLIPCHILDREN |
                                WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOMOVEY | CCS_NOPARENTALIGN |
                                CCS_NORESIZE,
                                0, 2, TBWIDTH, TBHEIGHT, _hwnd, 0, HINST_THISDLL, NULL);

    if (_hwndTB) {
        static const TBBUTTON tb[] =
        {
            { 1, IDM_AB_CLOSE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 0 }
        };

#ifndef UNIX
        HIMAGELIST himl = ImageList_LoadImage(HINST_THISDLL,
                                              MAKEINTRESOURCE(IDB_BROWSERTOOLBAR),
                                              13, 0, RGB(255,0,255),
                                              IMAGE_BITMAP, LR_CREATEDIBSECTION);
#else
        HIMAGELIST himl;
        COLORREF crTextColor = GetSysColor( COLOR_BTNTEXT );
        crTextColor = MwGetTrueRGBValue( crTextColor );

        himl = ImageList_LoadImage(HINST_THISDLL,
                                   crTextColor == RGB(255,255,255) ?
                                     MAKEINTRESOURCE(IDB_WHITEBROWSERTOOLBAR) :
                                     MAKEINTRESOURCE(IDB_BROWSERTOOLBAR),
                                   13, 0, RGB(255,0,255),
                                   IMAGE_BITMAP, LR_CREATEDIBSECTION);
#endif        
        ImageList_SetBkColor(himl, RGB(0,0,0));

        SendMessage(_hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);
        SendMessage(_hwndTB, TB_BUTTONSTRUCTSIZE,    SIZEOF(TBBUTTON), 0);
        SendMessage(_hwndTB, TB_ADDBUTTONS, ARRAYSIZE(tb), (LPARAM)tb);
        SendMessage(_hwndTB, TB_SETINDENT, (WPARAM)0, 0);

        _SizeTB();
    }    
}

HRESULT CChannelDeskBarApp::ShowDW(BOOL fShow)
{
    if (fShow && !_hwndTB) {
        _CreateToolbar();
    }
    
    HRESULT hres = CDeskBarApp::ShowDW(fShow);
    return hres;
}

void CChannelDeskBarApp::_PositionTB()
{
    // position the toolbar 
    if (_hwndTB) {
        // always put the close restore at the top right of the floater window

        RECT rc;
        RECT rcTB;
        GetClientRect(_hwnd, &rc);
        GetWindowRect(_hwndTB, &rcTB);

        rc.left = rc.right - RECTWIDTH(rcTB) - 2;
        SetWindowPos(_hwndTB, HWND_TOP, rc.left, 2, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
    }
}


void CChannelDeskBarApp::_SizeTB()
{
    RECT rc;
    GetWindowRect(_hwndTB, &rc);
    LRESULT lButtonSize = SendMessage(_hwndTB, TB_GETBUTTONSIZE, 0, 0L);
    SetWindowPos(_hwndTB, NULL, 0, 0, LOWORD(lButtonSize),
                 RECTHEIGHT(rc), SWP_NOMOVE | SWP_NOACTIVATE);
    _PositionTB();
}

void CChannelDeskBarApp::_OnSize()
{
    RECT rc, rcTB;

    if (!_hwndChild)
        return;

    ASSERT(IsWindow(_hwndChild));

    GetClientRect(_hwnd, &rc);
    if (_hwndTB) {
        GetWindowRect(_hwndTB, &rcTB);
        SetWindowPos(_hwndTB, HWND_TOP, rc.right - RECTWIDTH(rcTB) - 2, 2, 0, 0,
                     SWP_NOSIZE | SWP_NOACTIVATE);
        SetWindowPos(_hwndChild, 0, rc.left, rc.top + RECTHEIGHT(rcTB) + 3,
                     RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOACTIVATE|SWP_NOZORDER);
    }
    else {
        // how could there be no toolbar? 
        ASSERT(0);
        SetWindowPos(_hwndChild, 0, rc.left, rc.top + TBHEIGHT + 3,
                     RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOACTIVATE|SWP_NOZORDER);
    }

    rc.bottom = rc.top + TBHEIGHT + 3; 
    InvalidateRect(_hwnd, &rc, TRUE);
}

#define ABS(i)  (((i) < 0) ? -(i) : (i))

LRESULT CChannelDeskBarApp::_OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    HWND hwnd = GET_WM_COMMAND_HWND(wParam, lParam);
    
    if (hwnd == _hwndTB) {
        switch (idCmd) {
        case IDM_AB_CLOSE:
            Exec(&CGID_DeskBarClient, DBCID_EMPTY, 0, NULL, NULL);
            break;
        }
        
    } else {
        return CDeskBarApp::_OnCommand(uMsg, wParam, lParam);
    }
    return 0;
}


BOOL CChannelDeskBarApp::_OnCloseBar(BOOL fConfirm)
{
    return CDeskBarApp::_OnCloseBar(FALSE);
}

HRESULT CChannelDeskBarApp::CloseDW(DWORD dwReserved)
{
    // close the toolbar window
    if (_hwndTB) {
        HIMAGELIST himl = (HIMAGELIST)SendMessage(_hwndTB, TB_SETIMAGELIST, 0, 0);
        ImageList_Destroy(himl);

        DestroyWindow(_hwndTB);
        _hwndTB = NULL;
    }

    if (_hwnd) {
        CDeskBarApp::CloseDW(dwReserved);
        
        // Check the active desktop is ON. If so, do not ask for the confirmation.
        // we need to kill the channel bar silently.
        if (WhichPlatform() == PLATFORM_INTEGRATED)    // SHGetSetSettings is not supported in IE3
        {
            SHELLSTATE ss = { 0 };

            SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE); // Get the setting
            if (ss.fDesktopHTML)  //Active desktop is ON. Die silently.
                return S_OK;
        }

        // set AutoLaunch reg value -- 
        // decide whether to launch channel bar when machine is rebooted next time 
        int iRes = MLShellMessageBox(_hwnd,
                                     MAKEINTRESOURCE(IDS_CHANBAR_SHORTCUT_MSG),
                                     MAKEINTRESOURCE(IDS_CHANBAR_SHORTCUT_TITLE),
                                     MB_YESNO | MB_SETFOREGROUND);
        ChanBarSetAutoLaunchRegValue(iRes == IDYES);
    }
    
    return S_OK;
}

// store position and size to registry
void CChannelDeskBarApp::_PersistState()
{
    if (_hwnd) {
        CISSTRUCT cis;
        cis.iVer = 1;
        GetWindowRect(_hwnd, &cis.rc);
        SHRegSetUSValue(SZ_REGKEY_CHANBAR, SZ_REGVALUE_CHANBAR, REG_BINARY, 
                        (LPVOID)&cis, sizeof(CISSTRUCT), SHREGSET_HKCU | SHREGSET_FORCE_HKCU );
    }
}



void ChanBarSetAutoLaunchRegValue(BOOL fAutoLaunch)
{
    SHRegSetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), 
                    TEXT("Show_ChannelBand"), REG_SZ, 
                    fAutoLaunch ? TEXT("yes") : TEXT("no"),
                    sizeof(fAutoLaunch ? TEXT("yes") : TEXT("no")), 
                    SHREGSET_HKCU | SHREGSET_FORCE_HKCU);
}

//***
// NOTES
//  REARCHITECT: nuke this, fold it into CChannelDeskBarApp_CreateInstance
HRESULT ChannelDeskBarApp_Create(IUnknown** ppunk, IUnknown** ppbs)
{
    HRESULT hres;

    *ppunk = NULL;
    if (ppbs)
        *ppbs = NULL;
    
    CChannelDeskBarApp *pdb = new CChannelDeskBarApp();
    if (!pdb)
        return E_OUTOFMEMORY;
    
    CBandSite *pcbs = new CBandSite(NULL);
    if (pcbs)
    {

        IDeskBarClient *pdbc = SAFECAST(pcbs, IDeskBarClient*);
        hres = pdb->SetClient(pdbc);
        if (SUCCEEDED(hres))
        {
            if (ppbs) {
                *ppbs = pdbc;
                pdbc->AddRef();
            }
            
            pdb->_pbs = pcbs;
            pcbs->AddRef();
            
            *ppunk = SAFECAST(pdb, IDeskBar*);
        }
    
        pdbc->Release();
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    if (FAILED(hres))
    {
        pdb->Release();
    }

    return hres;
}



HRESULT CChannelDeskBarApp::Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog)
{
    HRESULT hres = CDeskBarApp::Load(pPropBag, pErrorLog);

    BANDSITEINFO bsinfo;
    bsinfo.dwMask = BSIM_STYLE;
    bsinfo.dwStyle = BSIS_NOGRIPPER | BSIS_NODROPTARGET;
    _pbs->SetBandSiteInfo(&bsinfo);
    
    return hres;
}

#endif  // ENABLE_CHANNELS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\bsmenu.h ===
#ifndef _BSMENU_H
#define _BSMENU_H

#include "comcatex.h"

typedef struct {
    CLSID  clsid;
    CATID  catid;
    UINT   idCmd;
    LPTSTR pszName;
    LPTSTR pszIcon;
    LPTSTR pszMenu;
    LPTSTR pszHelp;
    LPTSTR pszMenuPUI;
    LPTSTR pszHelpPUI;
} BANDCLASSINFO;

class CBandSiteMenu : 
        public IContextMenu3,
        public IShellService
{
public:
    CBandSiteMenu();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);
    
    
    // *** IContextMenu3 methods ***
    STDMETHOD(QueryContextMenu)(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);

    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) { return E_NOTIMPL; };

    STDMETHOD(SetOwner)(IUnknown* punk);
    STDMETHOD(HandleMenuMsg)(UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);
    STDMETHOD(HandleMenuMsg2)(UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam,
                              LRESULT* plres);


    BOOL GetMergeMenu() { return (_hdpaBandClasses ? TRUE:FALSE) ; }
    int  LoadFromComCat(const CATID *pcatid);
    int  GetBandClassCount(const  CATID* pcatid, BOOL bMergedOnly );
    BANDCLASSINFO * GetBandClassDataStruct(UINT uBand);
    BOOL DeleteBandClass( REFCLSID rclsid );
    int CreateMergeMenu(HMENU hmenu, UINT cMax, UINT iPosition, UINT idCmdFirst, UINT iStart, BOOL fMungeAllowed = TRUE);

protected:
    ~CBandSiteMenu();
    
    HDPA _hdpaBandClasses; // what bands are insertable here?
    int _idCmdEnumFirst;    // this is in EXTERNAL units
    UINT _idCmdFirst;
    UINT _cRef;
    IBandSite* _pbs;
    
    static int _DPA_FreeBandClassInfo(LPVOID p, LPVOID d);
    
    BOOL _CheckUnique(IDeskBand* pdb, HMENU hmenu) ;
    HRESULT _GetBandIdentifiers(IUnknown *punk, CLSID* pcslid, DWORD* pdwPrivID);
    void _AddNewFSBand(LPCITEMIDLIST pidl, BOOL fNoTitle, DWORD dwPrivID);
    void _ToggleSpecialFolderBand(int i, LPTSTR pszSubPath, BOOL fNoTitle);
    void _BrowseForNewFolderBand();
    void _ToggleComcatBand(UINT idCmd);
    void _AddEnumMenu(HMENU hmenu, int iInsert);

    static HRESULT _BandClassEnum(REFCATID rcatid, REFCLSID rclsid, LPARAM lParam);

    HRESULT _FindBand(const CLSID* pclsid, DWORD dwPrivID, DWORD* pdwBandID);

    UINT _IDToInternal(UINT uID);
    UINT _IDToExternal(UINT uID);

    LRESULT _OnInitMenuPopup(HMENU hmenu, UINT uPos);

    void _PopulateSubmenu(HMENU hmenuSub);
};

#endif  // _BSMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\comcatex.h ===
#ifndef __COMCATEX_H__
#define __COMCATEX_H__

#include <comcat.h>

//-------------------------------------------------------------------------//
//  Retrieves cache-aware enumerator over classes which require or 
//  implement the specified component catagory(ies).
//  See docs on ICatInformation::EnumClassesOfCategories() for more information
//  on arguments and usage.
STDMETHODIMP SHEnumClassesOfCategories(
      ULONG cImplemented,       //Number of category IDs in the rgcatidImpl array
      CATID rgcatidImpl[],      //Array of category identifiers
      ULONG cRequired,          //Number of category IDs in the rgcatidReq array
      CATID rgcatidReq[],       //Array of category identifiers
      IEnumGUID** ppenumGUID ) ;//Address to receive a pointer to an IEnumGUID interface

//-------------------------------------------------------------------------//
//  Determines whether a cache exists for the indicated CATID.
//  If bImplementing is TRUE, the function checks for a cache of
//  implementing classes; otherwise the function checks for a cache of
//  requiring classes.  Returns S_OK if the cache exists, S_FALSE if
//  it does not exist, or an error indicating a failure occurred.
STDMETHODIMP SHDoesComCatCacheExist( REFCATID refcatid, BOOL bImplementing ) ;

//-------------------------------------------------------------------------//
//  Caches implementing and/or requiring classes for the specified categories
//  See docs on ICatInformation::EnumClassesOfCategories() for more information
//  on arguments.
STDMETHODIMP SHWriteClassesOfCategories( 
      ULONG cImplemented,       //Number of category IDs in the rgcatidImpl array
      CATID rgcatidImpl[],      //Array of category identifiers
      ULONG cRequired,          //Number of category IDs in the rgcatidReq array
      CATID rgcatidReq[],       //Array of category identifiers
      BOOL  bForceUpdate,       //TRUE: Unconditionally update the cache; 
                                //otherwise create cache iif doesn't exist.
      BOOL  bWait,              //If FALSE, the function returns immediately and the
                                //   caching occurs asynchronously; otherwise
                                //   the function returns only after the caching
                                //   operation has completed.
      HANDLE hEvent ) ;         //(optional) Event to be signalled when cache update is done

#endif __COMCATEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\comcatex.cpp ===
#include "priv.h"
#include "comcatex.h"
#include "runtask.h"


//------------------//
//  Misc constants
static LPCTSTR
#ifdef _WIN64
    REGKEY_COMCATEX              = STRREG_DISCARDABLE STRREG_POSTSETUP TEXT("\\Component Categories64"),
#else
    REGKEY_COMCATEX              = STRREG_DISCARDABLE STRREG_POSTSETUP TEXT("\\Component Categories"),
#endif
    REGKEY_COMCATEX_ENUM         = TEXT("Enum"),        // HKCR\ComponentClasses\{catid}\Enum
    REGVAL_COMCATEX_IMPLEMENTING = TEXT("Implementing"),// HKCR\ComponentClasses\{catid}\Enum\Implementing
    REGVAL_COMCATEX_REQUIRING    = TEXT("Requiring");   // HKCR\ComponentClasses\{catid}\Enum\Requiring

static const ULONG 
    COMCAT_CACHE_CURRENTVERSION = MAKELONG(1,0); // current cache version.

//-------------//
//  Cache header
typedef struct {
    ULONG       cbStruct;      // structure size
    ULONG       ver;           // version string (COMCAT_CACHE_CURRENTVERSION)
    SYSTEMTIME  stLastUpdate;  // UTC date, time of last update.
    ULONG       cClsid;        // number of CLSIDs to follow
    CLSID       clsid[];       // array of CLSIDs
} COMCAT_CACHE_HEADER;

//----------------//
//  Impl helpers
STDMETHODIMP _EnumerateGuids( IN IEnumGUID* pEnumGUID, OUT HDSA* phdsa );
STDMETHODIMP _ComCatCacheFromDSA( IN HDSA hdsa, OUT LPBYTE* pBuf, OUT LPDWORD pcbBuf );
STDMETHODIMP _DSAFromComCatCache( IN LPBYTE pBuf, IN ULONG cbBuf, OUT HDSA* phdsa );
STDMETHODIMP _MakeComCatCacheKey( IN REFCATID refcatid, OUT LPTSTR pszKey, IN ULONG cchKey );
STDMETHODIMP _ReadClassesOfCategory( IN REFCATID refcatid, OUT HDSA* phdsa, LPCTSTR pszRegValueName );
STDMETHODIMP _WriteImplementingClassesOfCategory( IN REFCATID refcatid, IN HDSA hdsa );
STDMETHODIMP _WriteRequiringClassesOfCategory( IN REFCATID refcatid, IN HDSA hdsa );
STDMETHODIMP _WriteClassesOfCategories( IN ULONG, IN CATID [], IN ULONG, IN CATID [], BOOL );
STDMETHODIMP _BuildCacheIfNecessary( IN REFCATID refcatid, BOOL fImplementing);
STDAPI       _CComCatCache_CommonCreateInstance( BOOL, OUT void**);

//-----------------------//
//  Higher-level methods
STDMETHODIMP SHReadImplementingClassesOfCategory( REFCATID refcatid, OUT HDSA* phdsa );
STDMETHODIMP SHReadRequiringClassesOfCategory( REFCATID refcatid, OUT HDSA* phdsa );
STDMETHODIMP SHWriteImplementingClassesOfCategory( REFCATID refcatid );
STDMETHODIMP SHWriteRequiringClassesOfCategory( REFCATID refcatid );

#define SAFE_DESTROY_CLSID_DSA(hdsa) \
    if((hdsa)) { DSA_Destroy((hdsa)); (hdsa)=NULL; }

//-------------------------------------------------------------------------//
//  Cache-aware component categories enumerator object
class CSHEnumClassesOfCategories : public IEnumGUID
//-------------------------------------------------------------------------//
{
public:
    //  IUnknown methods
    STDMETHOD_ (ULONG, AddRef)()    { 
        return InterlockedIncrement( &_cRef );
    }
    STDMETHOD_ (ULONG, Release)()   { 
        ASSERT( 0 != _cRef );
        ULONG cRef = InterlockedDecrement( &_cRef );
        if( 0 == cRef ) {
            delete this;
        }
        return cRef; 
    }
    STDMETHOD  (QueryInterface)( REFIID riid, void **ppvObj);

    //  IEnum methods
    STDMETHOD (Next)( ULONG celt, GUID* rgelt, ULONG* pceltFetched );
    STDMETHOD (Skip)( ULONG celt );
    STDMETHOD (Reset)();
    STDMETHOD (Clone)( IEnumGUID ** ppenum );

protected:
    CSHEnumClassesOfCategories();
    virtual ~CSHEnumClassesOfCategories();

    STDMETHOD (Initialize)( ULONG cImpl, CATID rgcatidImpl[], ULONG cReq, CATID rgcatidReq[]); 
        // invoke immediately after construction for arg validation.
    
    LONG      _cRef,        // ref count
              _iEnum;      // enumerator index
    HDSA      _hdsa;       // CLSID DSA handle

    ULONG     _cImpl,        // count of catids to enumerate for implementing classes
              _cReq;        // count of catids to enumerate for requiring classes
    CATID     *_rgcatidImpl, // catids to enumerate for implementing classes
              *_rgcatidReq; // catids to enumerate for requiring classes
              
    friend STDMETHODIMP SHEnumClassesOfCategories( ULONG, CATID[], ULONG, CATID[], IEnumGUID**);
};

//-------------------------------------------------------------------------//
//  IRunnableTask derivative for asynchronous update of 
//  component categories cache.
class CComCatCacheTask : public CRunnableTask
//-------------------------------------------------------------------------//
{
public:
    CComCatCacheTask();
    virtual ~CComCatCacheTask();

    STDMETHOD   (Initialize)( ULONG cImplemented,
                              CATID rgcatidImpl[],
                              ULONG cRequired,
                              CATID rgcatidReq[],
                              BOOL  bForceUpdate,
                              HANDLE hEvent );

    STDMETHOD   (Go)();

protected:
    STDMETHOD   (RunInitRT)()
    {
        HRESULT hr = _WriteClassesOfCategories( _cImpl, _rgcatidImpl,
                                          _cReq, _rgcatidReq, _bForceUpdate );
        if (_hEvent)
            SetEvent(_hEvent);
        return hr;
    }

    ULONG _cImpl, _cReq;
    CATID *_rgcatidImpl,
          *_rgcatidReq;
    BOOL  _bForceUpdate;
    HANDLE _hEvent;

    friend HRESULT _CComCatCache_CommonCreateInstance( BOOL, OUT void**);
};

//-------------------------------------------------------------------------//
//  Entrypoint: retrieves cache-aware enumerator over classes which require or 
//  implement the specified component catagory(ies).
STDMETHODIMP SHEnumClassesOfCategories(
      ULONG cImplemented,       //Number of category IDs in the rgcatidImpl array
      CATID rgcatidImpl[],        //Array of category identifiers
      ULONG cRequired,          //Number of category IDs in the rgcatidReq array
      CATID rgcatidReq[],         //Array of category identifiers
      IEnumGUID** ppenumGUID )  //Location in which to return an IEnumGUID interface
{
    HRESULT hr = S_OK;
    CSHEnumClassesOfCategories* pEnum = NULL;
    
    if( NULL == ppenumGUID )
        return E_INVALIDARG;

    *ppenumGUID = NULL;

    //  Construct and initialize enumerator object
    if( NULL == (pEnum = new CSHEnumClassesOfCategories) )
        return E_OUTOFMEMORY;

    if( FAILED( (hr = pEnum->Initialize( 
                    cImplemented, rgcatidImpl, cRequired, rgcatidReq )) ) )
    {
        pEnum->Release();
        return hr;
    }

    *ppenumGUID = pEnum;
    return hr;
}

//-------------------------------------------------------------------------//
//  Determines whether a cache exists for the indicated CATID.
//  If bImplementing is TRUE, the function checks for a cache of
//  implementing classes; otherwise the function checks for a cache of
//  requiring classes.
STDMETHODIMP SHDoesComCatCacheExist( REFCATID refcatid, BOOL bImplementing )
{
    TCHAR szKey[MAX_PATH];
    HRESULT hr;

    if( SUCCEEDED( (hr = _MakeComCatCacheKey( refcatid, szKey, ARRAYSIZE(szKey) )) ) )
    {
        HKEY  hkeyCache;
        
        DWORD dwRet = RegOpenKeyEx( HKEY_CURRENT_USER, szKey, 0L, KEY_READ, &hkeyCache );
        hr = S_FALSE;

        if( ERROR_SUCCESS == dwRet )
        {
            DWORD   dwType, cbData = 0;

            dwRet = RegQueryValueEx( hkeyCache, 
                                     bImplementing ? REGVAL_COMCATEX_IMPLEMENTING : 
                                                     REGVAL_COMCATEX_REQUIRING,
                                     0L, &dwType, NULL, &cbData );

            //  We'll confirm only on value type and size of data.
            if( ERROR_SUCCESS == dwRet && 
                dwType == REG_BINARY &&  
                sizeof(COMCAT_CACHE_HEADER) <= cbData )
            {
                hr = S_OK;
            }

            RegCloseKey( hkeyCache );
        }
    }
    return hr;
}

//-------------------------------------------------------------------------//
//  Entrypoint: Caches implementing and requiring classes for the 
//  specified categories with asynchronous option.
STDMETHODIMP SHWriteClassesOfCategories( 
      ULONG cImplemented,       //Number of category IDs in the rgcatidImpl array
      CATID rgcatidImpl[],      //Array of category identifiers
      ULONG cRequired,          //Number of category IDs in the rgcatidReq array
      CATID rgcatidReq[],       //Array of category identifiers
      BOOL  bForceUpdate,       // TRUE: Unconditionally update the cache; FALSE: create cache iif doesn't exist.
      BOOL  bWait,              //If FALSE, the function returns immediately and the
                                //   caching occurs asynchronously; otherwise
                                //   the function returns only after the caching
                                //   operation has completed.
      HANDLE hEvent             //(optional) Event to be signalled when cache update is done
)
{
    HRESULT hr;

    if( bWait )
    {
        //  Synchronous update
        hr = _WriteClassesOfCategories( cImplemented, rgcatidImpl, cRequired, rgcatidReq, bForceUpdate );
        if (hEvent)
            SetEvent(hEvent);
    }
    else
    {
        //  Asynchronous update
        CComCatCacheTask* pTask = new CComCatCacheTask();
        if (pTask)
        {
            //  Initialize with caller's args:
            if( SUCCEEDED( (hr = pTask->Initialize( 
                    cImplemented, rgcatidImpl, cRequired, rgcatidReq, bForceUpdate, hEvent )) ) )
            {
                hr = pTask->Go();
            }
        
            pTask->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

//-------------------------------------------------------------------------//
//  CSHEnumClassesOfCategories class implementation
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
inline CSHEnumClassesOfCategories::CSHEnumClassesOfCategories()
    :   _cImpl(0), _rgcatidImpl(NULL),
        _cReq(0), _rgcatidReq(NULL),
        _cRef(1),  _iEnum(0), _hdsa(NULL)
{
    DllAddRef();
}

//-------------------------------------------------------------------------//
CSHEnumClassesOfCategories::~CSHEnumClassesOfCategories()
{
    delete [] _rgcatidImpl;
    delete [] _rgcatidReq;
    SAFE_DESTROY_CLSID_DSA( _hdsa );
    DllRelease();
}

//-------------------------------------------------------------------------//
STDMETHODIMP CSHEnumClassesOfCategories::QueryInterface( REFIID riid, void **ppvObj )
{
    static const QITAB qit[] = {
        QITABENT(CSHEnumClassesOfCategories, IEnumGUID),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

//-------------------------------------------------------------------------//
STDMETHODIMP CSHEnumClassesOfCategories::Initialize(
    ULONG cImplemented, 
    CATID rgcatidImpl[], 
    ULONG cRequired, 
    CATID rgcatidReq[]
)
{
    //  Disallow multiple initialization.
    if( _hdsa || _rgcatidImpl || _rgcatidReq )
        return S_FALSE;
    
    //  Superficial arg validation:
    if( (0==cImplemented && 0==cRequired) ||
        (cImplemented && NULL == rgcatidImpl) ||
        (cRequired && NULL == rgcatidReq) )
    {
        return E_INVALIDARG;
    }

    //  Allocate and make copies of CATID arrays
    if( cImplemented )
    {
        if( NULL == (_rgcatidImpl = new CATID[cImplemented]) )
            return E_OUTOFMEMORY;
        CopyMemory( _rgcatidImpl, rgcatidImpl, sizeof(CATID) * cImplemented );
    }
    _cImpl = cImplemented;

    if( cRequired )
    {
        if( NULL == (_rgcatidReq = new CATID[cRequired]) )
            return E_OUTOFMEMORY;
        CopyMemory( _rgcatidReq, rgcatidReq, sizeof(CATID) * cRequired );
    }
    _cReq = cRequired;

    return S_OK;
}

//-------------------------------------------------------------------------//
//  Iterates implementing and/or requiring classes for the caller-specified
//  component categories.
STDMETHODIMP CSHEnumClassesOfCategories::Next( 
    ULONG celt, 
    GUID* rgelt, 
    ULONG* pceltFetched )
{
    if( pceltFetched )
        *pceltFetched = 0;
    
    HRESULT hr = S_FALSE;
    ULONG celtFetched = 0;

    //  Have we assembled our collection?
    if( NULL == _hdsa )
    {
        _iEnum = 0;

        ULONG i;
        for( i=0; SUCCEEDED( hr ) && i < _cImpl; i++ )
        {
            //  Try reading implementing classes from cache
            if( FAILED( (hr = SHReadImplementingClassesOfCategory( _rgcatidImpl[i], &_hdsa )) ) )
            {
                //  Uncached; try caching and then re-read.
                if( FAILED( (hr = SHWriteImplementingClassesOfCategory( _rgcatidImpl[i] )) ) ||
                    FAILED( (hr = SHReadImplementingClassesOfCategory( _rgcatidImpl[i], &_hdsa )) ) )
                    break;
            }
        }

        for( i=0; SUCCEEDED( hr ) && i < _cReq; i++ )
        {
            //  Try reading requiring classes from cache
            if( FAILED( (hr = SHReadRequiringClassesOfCategory( _rgcatidReq[i], &_hdsa )) ) )
            {
                //  Uncached; try caching and then re-read.
                if( FAILED( (hr = SHWriteRequiringClassesOfCategory( _rgcatidReq[i] )) ) ||
                    FAILED( (hr = SHReadRequiringClassesOfCategory( _rgcatidReq[i], &_hdsa )) ) )
                    break;
            }
        }
    }

    if( NULL != _hdsa )
    {
        LONG count = DSA_GetItemCount( _hdsa );
        while( celtFetched < celt && _iEnum < count  )
        {
            if( DSA_GetItem( _hdsa, _iEnum, &rgelt[celtFetched] ) )
                celtFetched++;

            _iEnum++;
        }

        return celtFetched == celt ? S_OK : S_FALSE;
    }

    return SUCCEEDED( hr ) ? S_FALSE : hr;
}

//-------------------------------------------------------------------------//
inline STDMETHODIMP CSHEnumClassesOfCategories::Skip( ULONG celt )      
{ 
    InterlockedExchange( &_iEnum, _iEnum + celt );
    return S_OK; 
}

//-------------------------------------------------------------------------//
inline STDMETHODIMP CSHEnumClassesOfCategories::Reset( void )      
{ 
    InterlockedExchange( &_iEnum, 0 );
    return S_OK; 
}

//-------------------------------------------------------------------------//
inline STDMETHODIMP CSHEnumClassesOfCategories::Clone( IEnumGUID ** ppenum )
{
    return E_NOTIMPL;
}

//-------------------------------------------------------------------------//
//  CComCatCacheTask class implementation
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
STDAPI CComCatConditionalCacheTask_CreateInstance( IN IUnknown*, OUT void** ppOut, LPCOBJECTINFO )
{
    return _CComCatCache_CommonCreateInstance( FALSE /* iif not exists */, ppOut );
}

//-------------------------------------------------------------------------//
STDAPI CComCatCacheTask_CreateInstance( IN IUnknown*, OUT void** ppOut, LPCOBJECTINFO poi )
{
    return _CComCatCache_CommonCreateInstance( TRUE /* unconditionally update */, ppOut );
}

//-------------------------------------------------------------------------//
STDAPI _CComCatCache_CommonCreateInstance( 
    BOOL bForceUpdate, 
    OUT void** ppOut )
{
    CComCatCacheTask* pTask;
    if( NULL == (pTask = new CComCatCacheTask) )
        return E_OUTOFMEMORY;

    HRESULT hr = S_OK;

    //  We're being CoCreated without args, so we'll use
    //  a hard-coded list of likely suspects (catids) to cache.
    static CATID rgcatid[2];
    rgcatid[0] = CATID_InfoBand;
    rgcatid[1] = CATID_CommBand;
    if( FAILED( (hr = pTask->Initialize( ARRAYSIZE(rgcatid), rgcatid, 0, NULL, bForceUpdate, NULL )) ) )
    {
        pTask->Release();
        return hr;
    }

    *ppOut = SAFECAST( pTask, IRunnableTask*);
    return hr;
}

//-------------------------------------------------------------------------//
inline CComCatCacheTask::CComCatCacheTask()
    :  CRunnableTask( RTF_DEFAULT ), 
       _cImpl(0), _cReq(0), _rgcatidImpl(NULL), _rgcatidReq(NULL), _bForceUpdate(TRUE)
{
}

//-------------------------------------------------------------------------//
inline CComCatCacheTask::~CComCatCacheTask()
{
    delete [] _rgcatidImpl;
    delete [] _rgcatidReq;
    if (_hEvent)
        CloseHandle(_hEvent);
}

//-------------------------------------------------------------------------//
STDMETHODIMP CComCatCacheTask::Initialize(
    ULONG cImplemented,
    CATID rgcatidImpl[],
    ULONG cRequired,
    CATID rgcatidReq[],
    BOOL  bForceUpdate,
    HANDLE hEvent)
{
    //  Superficial arg validation:
    if( (0==cImplemented && 0==cRequired) ||
        (cImplemented && NULL == rgcatidImpl) ||
        (cRequired && NULL == rgcatidReq) )
    {
        return E_INVALIDARG;
    }

    //  Disallow multiple initialization.
    if( _rgcatidImpl || _rgcatidReq )
        return S_FALSE;

    //  Allocate and make copies of CATID arrays
    if( cImplemented )
    {
        if( NULL == (_rgcatidImpl = new CATID[cImplemented]) )
            return E_OUTOFMEMORY;
        CopyMemory( _rgcatidImpl, rgcatidImpl, sizeof(CATID) * cImplemented );
    }
    _cImpl = cImplemented;

    if( cRequired )
    {
        if( NULL == (_rgcatidReq = new CATID[cRequired]) )
            return E_OUTOFMEMORY;
        CopyMemory( _rgcatidReq, rgcatidReq, sizeof(CATID) * cRequired );
    }
    _cReq = cRequired;

    _bForceUpdate = bForceUpdate;

    if (hEvent)
    {
        HANDLE hProcess = GetCurrentProcess();
        DuplicateHandle(hProcess, hEvent, hProcess, &_hEvent, 0, FALSE, DUPLICATE_SAME_ACCESS);
    }

    return S_OK;
}

//-------------------------------------------------------------------------//
//  Initiates asynchronous update of component categories cache.
STDMETHODIMP CComCatCacheTask::Go()
{
    //  Run the task from the shared thread pool
    IShellTaskScheduler* pScheduler;
    HRESULT hr = CoCreateInstance( CLSID_SharedTaskScheduler, NULL, CLSCTX_INPROC_SERVER, 
                                   IID_IShellTaskScheduler, (LPVOID*)&pScheduler );

    if( SUCCEEDED( hr ) )
    {
        hr = pScheduler->AddTask( this, CLSID_ComCatCacheTask, 0L, ITSAT_DEFAULT_PRIORITY );
        
        // heap alloc'd memory belongs to scheduler thread.
        pScheduler->Release(); // OK to release shared scheduler before task has completed.
    }
    return hr;
}

//-------------------------------------------------------------------------//
//  Component cache implementation
//-------------------------------------------------------------------------//

STDMETHODIMP _BuildCacheIfNecessary(
    IN REFCATID refcatid, 
    BOOL fImplementing)
{
    HRESULT hr = S_OK;

    if (S_OK != SHDoesComCatCacheExist(refcatid, fImplementing))
    {
        hr = fImplementing ? SHWriteImplementingClassesOfCategory(refcatid)
                           : SHWriteRequiringClassesOfCategory(refcatid);
    }

    return hr;
}

//-------------------------------------------------------------------------//
//  Reads a series of CLSIDs from a registry-based cache of
//  implementing classes for the specified component category into a DSA.
//  If the DSA is NULL, a new DSA is created; otherwise the CLSIDS are appended to
//  the provided DSA.
inline STDMETHODIMP SHReadImplementingClassesOfCategory( 
    IN REFCATID refcatid, 
    OUT HDSA* phdsa )
{
    HRESULT hr = _BuildCacheIfNecessary(refcatid, TRUE);
    if (SUCCEEDED(hr))
    {
        hr = _ReadClassesOfCategory( refcatid, phdsa, REGVAL_COMCATEX_IMPLEMENTING );
    }

    return hr;
}

//-------------------------------------------------------------------------//
//  Reads a series of CLSIDs from a registry-based cache of
//  requiring classes for the specified component category into a DSA.
//  If the DSA is NULL, a new DSA is created; otherwise the CLSIDS are appended to
//  the provided DSA.
inline STDMETHODIMP SHReadRequiringClassesOfCategory( 
    IN REFCATID refcatid, 
    OUT HDSA* phdsa )
{
    HRESULT hr = _BuildCacheIfNecessary(refcatid, FALSE);
    if (SUCCEEDED(hr))
    {
        hr = _ReadClassesOfCategory( refcatid, phdsa, REGVAL_COMCATEX_REQUIRING );
    }

    return hr;
}

//-------------------------------------------------------------------------//
//  Caches a list of classes which implement the indicated component category.
STDMETHODIMP SHWriteImplementingClassesOfCategory( IN REFCATID refcatid )
{
    HRESULT hr;
    
    //  Retrieve OLE component category manager
    ICatInformation* pci;
    if( SUCCEEDED( (hr = CoCreateInstance( CLSID_StdComponentCategoriesMgr, 
                                           NULL, CLSCTX_INPROC_SERVER, 
                                           IID_ICatInformation, (LPVOID*)&pci)) ) )
    {
        //  Retrieve enumerator over classes that implement the category
        IEnumGUID* pEnumGUID;
        if( SUCCEEDED( (hr = pci->EnumClassesOfCategories( 1, (CATID*)&refcatid, 
                                                           0, NULL, &pEnumGUID )) ) )
        {
            HDSA  hdsa = NULL;
            if( SUCCEEDED( (hr = _EnumerateGuids( pEnumGUID, &hdsa )) ) )
            {
                //  Write to cache
                hr = _WriteImplementingClassesOfCategory( refcatid, hdsa );
                SAFE_DESTROY_CLSID_DSA( hdsa );
            }
            pEnumGUID->Release();
        }
        pci->Release();
    }        
    return hr;
}

//-------------------------------------------------------------------------//
//  Caches a list of classes which require the indicated component category.
STDMETHODIMP SHWriteRequiringClassesOfCategory( IN REFCATID refcatid )
{
    HRESULT hr;
    
    //  Retrieve OLE component category manager
    ICatInformation* pci;
    if( SUCCEEDED( (hr = CoCreateInstance( CLSID_StdComponentCategoriesMgr, 
                                           NULL, CLSCTX_INPROC_SERVER, 
                                           IID_ICatInformation, (LPVOID*)&pci)) ) )
    {
        //  Retrieve enumerator over classes that require the category
        IEnumGUID* pEnumGUID;
        if( SUCCEEDED( (hr = pci->EnumClassesOfCategories( 0, NULL, 1, 
                                                           (CLSID*)&refcatid, 
                                                           &pEnumGUID )) ) )
        {
            HDSA  hdsa = NULL;
            if( SUCCEEDED( (hr = _EnumerateGuids( pEnumGUID, &hdsa )) ) )
            {
                //  Write to cache
                hr = _WriteRequiringClassesOfCategory( refcatid, hdsa );
                SAFE_DESTROY_CLSID_DSA( hdsa );
            }
            pEnumGUID->Release();
        }
        pci->Release();
    }        
    return hr;
}

//-------------------------------------------------------------------------//
//  Accepts a valid GUID enumerator and constructs an HDSA containing the GUIDS.
//  The caller is responsible for freeing the HDSA which may or may not
//  have been allocated.
STDMETHODIMP _EnumerateGuids( IEnumGUID* pEnumGUID, OUT HDSA* phdsa )
{
    ASSERT( pEnumGUID );
    ASSERT( phdsa );
    
    ULONG   celtFetched;
    CLSID   clsid;
    HRESULT hr;

    while( SUCCEEDED( (hr = pEnumGUID->Next( 1, &clsid, &celtFetched )) ) &&
           celtFetched > 0 )
    {
        if( NULL == *phdsa &&
            NULL == (*phdsa = DSA_Create( sizeof(CLSID), 4 )) )
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        DSA_AppendItem( *phdsa, &clsid );
    }

    // translate S_FALSE.
    return SUCCEEDED( hr ) ? S_OK : hr;
}     

//-------------------------------------------------------------------------//
//  Generates a persistable cache of CLSIDs derived from the CLSID* DSA.
STDMETHODIMP _ComCatCacheFromDSA( IN HDSA hdsa, OUT LPBYTE* pBuf, OUT LPDWORD pcbBuf )
{
    ASSERT( pBuf );
    ASSERT( pcbBuf );

    ULONG   cClsid = hdsa ? DSA_GetItemCount( hdsa ) : 0,
            cbBuf = sizeof(COMCAT_CACHE_HEADER) + (cClsid * sizeof(CLSID));
    HRESULT hr = S_OK;

    //  Allocate blob
    *pcbBuf = 0;
    if( NULL != (*pBuf = new BYTE[cbBuf]) )
    {
        //  Initialize header
        COMCAT_CACHE_HEADER* pCache = (COMCAT_CACHE_HEADER*)(*pBuf);
        pCache->cbStruct = sizeof(*pCache);
        pCache->ver      = COMCAT_CACHE_CURRENTVERSION;
        pCache->cClsid   = 0;
        GetSystemTime( &pCache->stLastUpdate );

        //  Copy CLSIDs
        for( ULONG i = 0; i< cClsid; i++ )
            DSA_GetItem( hdsa, i, &pCache->clsid[pCache->cClsid++] );

        //  Adjust output size.
        *pcbBuf = sizeof(*pCache) + (pCache->cClsid * sizeof(CLSID));
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//-------------------------------------------------------------------------//
//  Appends CLSIDS from the cache buffer to the specified DSA.  If the DSA is
//  NULL, a new DSA is created.
STDMETHODIMP _DSAFromComCatCache( IN LPBYTE pBuf, IN ULONG cbBuf, OUT HDSA* phdsa )
{
    ASSERT( pBuf );
    ASSERT( phdsa );

    HRESULT hr = S_OK;
    COMCAT_CACHE_HEADER* pCache = (COMCAT_CACHE_HEADER*)pBuf;

    //  Validate header
    if( !( sizeof(*pCache) <= cbBuf && 
           sizeof(*pCache) == pCache->cbStruct &&
           COMCAT_CACHE_CURRENTVERSION == pCache->ver ) )
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

    //  Create the DSA if necessary
    if( 0 == pCache->cClsid )
        return S_FALSE;

    if( NULL == *phdsa && NULL == (*phdsa = DSA_Create( sizeof(CLSID), 4 )) )
        return E_OUTOFMEMORY;

    //  Copy CLSIDs from the cache to the DSA.
    for( ULONG i = 0; i< pCache->cClsid; i++ )
        DSA_AppendItem( *phdsa, &pCache->clsid[i] );

    return hr;
}

//-------------------------------------------------------------------------//
//  Constructs a component category registry cache key based on the 
//  specified CATID.
STDMETHODIMP _MakeComCatCacheKey( 
    IN REFCATID refcatid, 
    OUT LPTSTR pszKey, 
    IN ULONG cchKey )
{
    TCHAR szCLSID[GUIDSTR_MAX];
    
    if( SHStringFromGUID( refcatid, szCLSID, ARRAYSIZE(szCLSID) )<=0 )
        return E_INVALIDARG;

    ASSERT( cchKey > (ULONG)(lstrlen( REGKEY_COMCATEX ) + GUIDSTR_MAX) );

    //  "Component Categories\{clsid}\Enum"
    if( wnsprintf( pszKey, cchKey, TEXT("%s\\%s\\%s"),
                   REGKEY_COMCATEX, szCLSID, REGKEY_COMCATEX_ENUM ) > 0 )
        return S_OK;

    return E_FAIL;
}

//-------------------------------------------------------------------------//
//  Reads a cache of implementing or requiring classes info a CLSID DSA.
STDMETHODIMP _ReadClassesOfCategory( 
    IN REFCATID refcatid, 
    OUT HDSA* phdsa, 
    LPCTSTR pszRegValueName /*REGVAL_COMCATEX_IMPLEMENTING/REQUIRING*/ )
{
    TCHAR szKey[MAX_PATH];
    HRESULT hr;
    //  Create/Open key HKCR\Component Categories\{catid}\Enum
    if( SUCCEEDED( (hr = _MakeComCatCacheKey( refcatid, szKey, ARRAYSIZE(szKey) )) ) )
    {
        HKEY hkeyCache = NULL;
        DWORD dwRet = RegOpenKeyEx( HKEY_CURRENT_USER, szKey, 0L, KEY_READ, &hkeyCache );
        hr = HRESULT_FROM_WIN32( dwRet );

        if( SUCCEEDED( hr ) )
        {
            //  Determine required buffer size.
            LPBYTE  pBuf = NULL;
            ULONG   cbBuf = 0,
                    dwType,
                    dwRet = RegQueryValueEx( hkeyCache, pszRegValueName, 0L,
                                             &dwType, NULL, &cbBuf );

            hr = HRESULT_FROM_WIN32( dwRet );

            if (SUCCEEDED(hr))
            {
                //  Allocate buffer and read
                if( NULL != (pBuf = new BYTE[cbBuf]) )
                {
                    dwRet = RegQueryValueEx( hkeyCache, pszRegValueName, 0L,
                                             &dwType, pBuf, &cbBuf );
                    hr = HRESULT_FROM_WIN32( dwRet );
                }
                else
                    hr = E_OUTOFMEMORY;
            }

            if( SUCCEEDED( hr ) )
            {
                //  Gather CLSIDs into the DSA
                hr = REG_BINARY == dwType ? 
                     _DSAFromComCatCache( pBuf, cbBuf, phdsa ) : E_ABORT;
            }
                
            if( pBuf ) delete [] pBuf;
            RegCloseKey( hkeyCache );
        }
    }
    return hr;
}

//-------------------------------------------------------------------------//
//  Writes a series of CLSIDs from a DSA to a registry-based cache of
//  implementing classes for the specified component category.
STDMETHODIMP _WriteImplementingClassesOfCategory( 
    IN REFCATID refcatid, 
    IN HDSA hdsa )
{
    
    TCHAR szKey[MAX_PATH];
    HRESULT hr;

    //  Create/Open key HKCR\Component Categories\{catid}\Enum
    if( SUCCEEDED( (hr = _MakeComCatCacheKey( refcatid, szKey, ARRAYSIZE(szKey) )) ) )
    {
        HKEY hkeyCache = NULL;
        ULONG dwRet, dwDisposition;

        dwRet = RegCreateKeyEx( HKEY_CURRENT_USER, szKey, 0L, 
                                NULL, 0L, KEY_WRITE, NULL,
                                &hkeyCache, &dwDisposition );
        hr = HRESULT_FROM_WIN32( dwRet );

        if( SUCCEEDED( hr ) )
        {
            //  Construct a blob containing cache data.
            LPBYTE pBuf;
            ULONG  cbBuf;
            if( SUCCEEDED( (hr = _ComCatCacheFromDSA( hdsa, &pBuf, &cbBuf )) ) )
            {
                //  Write it to 'Implementing' reg value
                hr = RegSetValueEx( hkeyCache, REGVAL_COMCATEX_IMPLEMENTING, 0L,
                                    REG_BINARY, pBuf, cbBuf );
                if( pBuf )
                    delete [] pBuf;
            }
            RegCloseKey( hkeyCache );
        }
    }
    return hr;
}

//-------------------------------------------------------------------------//
//  Writes a series of CLSIDs from a DSA to a registry-based cache of
//  requiring classes for the specified component category.
STDMETHODIMP _WriteRequiringClassesOfCategory( 
    IN REFCATID refcatid, 
    IN HDSA hdsa )
{
    
    TCHAR szKey[MAX_PATH];
    HRESULT hr;

    //  Create/Open key HKCR\Component Categories\{catid}\Enum
    if( SUCCEEDED( (hr = _MakeComCatCacheKey( refcatid, szKey, ARRAYSIZE(szKey) )) ) )
    {
        HKEY hkeyCache = NULL;
        ULONG dwRet, 
              dwDisposition;

        dwRet = RegCreateKeyEx( HKEY_CURRENT_USER, szKey, 0L, 
                                NULL, 0L, KEY_WRITE, NULL,
                                &hkeyCache, &dwDisposition );
        hr = HRESULT_FROM_WIN32( dwRet ); 

        if( SUCCEEDED( hr ) )
        {
            //  Construct a blob containing cache data.
            LPBYTE pBuf;
            ULONG  cbBuf;
            if( SUCCEEDED( (hr = _ComCatCacheFromDSA( hdsa, &pBuf, &cbBuf )) ) )
            {
                //  Write it to 'Requirng' reg value
                hr = RegSetValueEx( hkeyCache, REGVAL_COMCATEX_REQUIRING, 0L,
                                    REG_BINARY, pBuf, cbBuf );
                if( pBuf )
                    delete [] pBuf;
            }
            RegCloseKey( hkeyCache );
        }
    }
    return hr;
}

//-------------------------------------------------------------------------//
//  Does work of caching implementing and requiring classes for the specified categories
STDMETHODIMP _WriteClassesOfCategories( 
      ULONG cImplemented,       //Number of category IDs in the rgcatidImpl array
      CATID rgcatidImpl[],      //Array of category identifiers
      ULONG cRequired,          //Number of category IDs in the rgcatidReq array
      CATID rgcatidReq[],       //Array of category identifiers
      BOOL  bForceUpdate )      //TRUE: unconditionally update the cache; otherwise
                                // update iif the cache doesn't exist.
{
    HRESULT hr = S_OK;
    ULONG   i;

    //  Cache implementing classes of each category.
    for( i = 0; i< cImplemented; i++ )
    {
        if( bForceUpdate || S_OK != SHDoesComCatCacheExist( rgcatidImpl[i], TRUE ) )
        {
            HRESULT hrCatid;
            if( FAILED( (hrCatid = SHWriteImplementingClassesOfCategory( rgcatidImpl[i] )) ) )
                hr = hrCatid;
        }
    }

    //  Cache requiring classes of each category.
    for( i = 0; i< cRequired; i++ )
    {
        if( bForceUpdate || S_OK != SHDoesComCatCacheExist( rgcatidReq[i], FALSE ) )
        {
            HRESULT hrCatid;
            if( FAILED( (hrCatid = SHWriteRequiringClassesOfCategory( rgcatidReq[i] )) ) )
                hr = hrCatid;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\commonsb.cpp ===
#include "priv.h"

#include "sccls.h"

#include "resource.h"

#include "commonsb.h"
#include "dockbar.h"        // for DRAG_MOVE etc.

#include "mluisupp.h"

#define DM_HTTPEQUIV        TF_SHDNAVIGATE
#define DM_NAV              TF_SHDNAVIGATE
#define DM_ZONE             TF_SHDNAVIGATE
#define DM_IEDDE            DM_TRACE
#define DM_CANCELMODE       0
#define DM_UIWINDOW         0
#define DM_ENABLEMODELESS   TF_SHDNAVIGATE
#define DM_EXPLORERMENU     0
#define DM_BACKFORWARD      0
#define DM_PROTOCOL         0
#define DM_ITBAR            0
#define DM_STARTUP          0
#define DM_AUTOLIFE         0
#define DM_PALETTE          0
#define DM_PERSIST          0       // trace IPS::Load, ::Save, etc.
#define DM_VIEWSTREAM       DM_TRACE
#define DM_FOCUS            0
#define DM_FOCUS2           0           // like DM_FOCUS, but verbose
#define DM_ACCELERATOR      0
#define TF_PERF             TF_CUSTOM2
#define DM_MISC             DM_TRACE    // misc/tmp stuff

PZONEICONNAMECACHE g_pZoneIconNameCache = NULL;
DWORD g_dwZoneCount = 0;

//***   create, ctor/init/dtor, QI/AddRef/Release {

// So CDesktopBrowser can access us...
HRESULT CCommonBrowser_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CCommonBrowser *pcb = new CCommonBrowser(punkOuter);
    if (pcb)
    {
        *ppunk = pcb->_GetInner();
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

CCommonBrowser::CCommonBrowser(IUnknown* punkAgg) :
   CAggregatedUnknown(punkAgg)
{
    // cache "out" pointers
    _QueryOuterInterface(IID_PPV_ARG(IBrowserService2, &_pbsOuter));

    // warning: can't call SUPER/_psbInner until _Initialize has been called
    // (since that's what does the aggregation)
}

HRESULT CCommonBrowser::_Initialize(HWND hwnd, IUnknown *pauto)
{
    //  I hope we have an IBrowserService2 to talk to.
    if (!_pbsOuter) 
    {
        return E_FAIL;
    }

    IUnknown* punk;
    HRESULT hr = CoCreateInstance(CLSID_CBaseBrowser, SAFECAST(this, IShellBrowser*), CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr)) 
    {
        hr = SetInner(punk);  // paired w/ Release in outer (TBS::Release)
        if (EVAL(SUCCEEDED(hr))) 
        {
            hr = _pbsInner->_Initialize(hwnd, pauto);
        }
    }

    EVAL(FDSA_Initialize(sizeof(TOOLBARITEM), ITB_CGROW, &_fdsaTBar, _aTBar, ITB_CSTATIC));

    return hr;
}

CCommonBrowser::~CCommonBrowser()
{
    // First, release outer interfaces, since the
    // outer object is in the process of destroying itself.
    RELEASEOUTERINTERFACE(_pbsOuter);
    RELEASEOUTERINTERFACE(_pbsOuter3);

    // Second, release the inner guy so it knows to clean up
    // Note: this should come third, but the inner guy's cached
    // outer interfaces are already dead (they point to our
    // aggregator) and we don't have the compiler to fix up
    // the vtables for us...
    // (I have no idea what that comment means -raymondc)
    RELEASEINNERINTERFACE(_GetOuter(), _pbsInner);
    RELEASEINNERINTERFACE(_GetOuter(), _pbsInner3);
    RELEASEINNERINTERFACE(_GetOuter(), _psbInner);
    RELEASEINNERINTERFACE(_GetOuter(), _pdtInner);
    RELEASEINNERINTERFACE(_GetOuter(), _pspInner);
    RELEASEINNERINTERFACE(_GetOuter(), _pctInner);
    RELEASEINNERINTERFACE(_GetOuter(), _piosInner);   // FEATURE: split: nuke this

    // _punkInner goes last because it is the one that really destroys
    // the inner.
    ATOMICRELEASE(_punkInner);   // paired w/ CCI aggregation
    
    // Last, clean up our stuff. Better make sure
    // none of the below use any of the above vtables...
    _CloseAndReleaseToolbars(FALSE);

    SetAcceleratorMenu(NULL);

    FDSA_Destroy(&_fdsaTBar);

}

HRESULT CCommonBrowser::v_InternalQueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        // perf: last tuned 980728
        QITABENT(CCommonBrowser, IServiceProvider),     // IID_IServiceProvider
        QITABENT(CCommonBrowser, IOleCommandTarget),    // IID_IOleCommandTarget
        QITABENTMULTI(CCommonBrowser, IBrowserService, IBrowserService3), // IID_IBrowserService
        QITABENTMULTI(CCommonBrowser, IBrowserService2, IBrowserService3), // IID_IBrowserService2
        QITABENT(CCommonBrowser, IBrowserService3),     // IID_IBrowserService3
        QITABENT(CCommonBrowser, IShellBrowser),        // IID_IShellBrowser
        QITABENT(CCommonBrowser, IShellBrowserService), // IID_IShellBrowserService
        QITABENTMULTI(CCommonBrowser, IOleWindow, IShellBrowser),     // rare IID_IOleWindow
        QITABENT(CCommonBrowser, IDockingWindowSite),   // rare IID_IDockingWindowSite
        QITABENT(CCommonBrowser, IDockingWindowFrame),  // rare IID_IDockingWindowFrame
        QITABENT(CCommonBrowser, IInputObjectSite),     // rare IID_IInputObjectSite
        QITABENT(CCommonBrowser, IDropTarget),          // rare IID_IDropTarget

        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hr))
    {
        if (_punkInner)
        {
            return _punkInner->QueryInterface(riid, ppvObj);
        }
    }
    return hr;
}

//
//  Accept punk as our inner (contained) object to which we forward a lot of
//  things we don't want to deal with.
//
//  Warning!  The refcount on the punk is *transferred* to us through this
//  method.  This is contrary to OLE convention.
//
HRESULT CCommonBrowser::SetInner(IUnknown* punk)
{
    HRESULT hres;

    //
    //  It's okay to shove the interesting things directly into
    //  our members, because if any of them go wrong, we fail
    //  the _Initialize and our destructor will release them all.

#define INNERCACHE(iid, p) do { \
    hres = SHQueryInnerInterface(_GetOuter(), punk, iid, (void **)&p); \
    if (!EVAL(SUCCEEDED(hres))) return E_FAIL; \
    } while (0)

    // Do not AddRef; the caller is tranferring the ref to us
    _punkInner = punk;

    INNERCACHE(IID_IBrowserService2, _pbsInner);
    INNERCACHE(IID_IBrowserService3, _pbsInner3);
    INNERCACHE(IID_IShellBrowser, _psbInner);
    INNERCACHE(IID_IDropTarget, _pdtInner);
    INNERCACHE(IID_IServiceProvider, _pspInner);
    INNERCACHE(IID_IOleCommandTarget, _pctInner);
    INNERCACHE(IID_IInputObjectSite, _piosInner);

#undef INNERCACHE

    _pbsInner->GetBaseBrowserData(&_pbbd);
    if (!EVAL(_pbbd)) 
        return E_FAIL; // o.w. zillions-o-GPFs on _pbbd->foo

    return S_OK;
}

// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _pbsInner-> _function _args ; }                                            

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)
 

// *** IBrowserService2 specific methods ***
CALL_INNER_HRESULT(GetParentSite, ( IOleInPlaceSite** ppipsite), ( ppipsite));
CALL_INNER_HRESULT(SetTitle, (IShellView* psv, LPCWSTR pszName), (psv, pszName));
CALL_INNER_HRESULT(GetTitle, (IShellView* psv, LPWSTR pszName, DWORD cchName), (psv, pszName, cchName));
CALL_INNER_HRESULT(GetOleObject, ( IOleObject** ppobjv), ( ppobjv));

// think about this one.. I'm not sure we want to expose this -- Chee
// NOTE:: Yep soon we should have interface instead.
// My impression is that we won't document this whole interface???
CALL_INNER_HRESULT(GetTravelLog, (ITravelLog** pptl), (pptl));

CALL_INNER_HRESULT(ShowControlWindow, (UINT id, BOOL fShow), (id, fShow));
CALL_INNER_HRESULT(IsControlWindowShown, (UINT id, BOOL *pfShown), (id, pfShown));
CALL_INNER_HRESULT(IEGetDisplayName, (LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags), (pidl, pwszName, uFlags));
CALL_INNER_HRESULT(IEParseDisplayName, (UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut), (uiCP, pwszPath, ppidlOut));
CALL_INNER_HRESULT(DisplayParseError, (HRESULT hres, LPCWSTR pwszPath), (hres, pwszPath));
CALL_INNER_HRESULT(NavigateToPidl, (LPCITEMIDLIST pidl, DWORD grfHLNF), (pidl, grfHLNF));

CALL_INNER_HRESULT(SetNavigateState, (BNSTATE bnstate), (bnstate));
CALL_INNER_HRESULT(GetNavigateState,  (BNSTATE *pbnstate), (pbnstate));

CALL_INNER_HRESULT(NotifyRedirect,  ( IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse), ( psv, pidl, pfDidBrowse));
CALL_INNER_HRESULT(UpdateWindowList,  (), ());

CALL_INNER_HRESULT(UpdateBackForwardState,  (), ());

CALL_INNER_HRESULT(SetFlags, (DWORD dwFlags, DWORD dwFlagMask), (dwFlags, dwFlagMask));
CALL_INNER_HRESULT(GetFlags, (DWORD *pdwFlags), (pdwFlags));

// Tells if it can navigate now or not.
CALL_INNER_HRESULT(CanNavigateNow,  (), ());

CALL_INNER_HRESULT(GetPidl,  (LPITEMIDLIST *ppidl), (ppidl));
CALL_INNER_HRESULT(SetReferrer,  (LPITEMIDLIST pidl), (pidl));
CALL_INNER(DWORD,  GetBrowserIndex ,(), ());
CALL_INNER_HRESULT(GetBrowserByIndex, (DWORD dwID, IUnknown **ppunk), (dwID, ppunk));
CALL_INNER_HRESULT(GetHistoryObject, (IOleObject **ppole, IStream **pstm, IBindCtx **ppbc), (ppole, pstm, ppbc));
CALL_INNER_HRESULT(SetHistoryObject, (IOleObject *pole, BOOL fIsLocalAnchor), (pole, fIsLocalAnchor));

CALL_INNER_HRESULT(CacheOLEServer, (IOleObject *pole), (pole));

CALL_INNER_HRESULT(GetSetCodePage, (VARIANT* pvarIn, VARIANT* pvarOut), (pvarIn, pvarOut));
CALL_INNER_HRESULT(OnHttpEquiv, (IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut), (psv, fDone, pvarargIn, pvarargOut));

CALL_INNER_HRESULT(GetPalette, ( HPALETTE * hpal), ( hpal));

CALL_INNER_HRESULT(RegisterWindow, (BOOL fUnregister, int swc), (fUnregister, swc));
CALL_INNER(LRESULT,  WndProcBS ,(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam), (hwnd, uMsg, wParam, lParam));
CALL_INNER_HRESULT(OnSize, (WPARAM wParam), (wParam));
CALL_INNER_HRESULT(OnCreate, (LPCREATESTRUCT pcs), (pcs));
CALL_INNER(LRESULT,  OnCommand, (WPARAM wParam, LPARAM lParam), (wParam, lParam));
CALL_INNER_HRESULT(OnDestroy, (), ());
CALL_INNER(LRESULT,  OnNotify, (NMHDR * pnm), (pnm));
CALL_INNER_HRESULT(OnSetFocus, (), ());
CALL_INNER_HRESULT(GetBaseBrowserData,(LPCBASEBROWSERDATA* ppbd), (ppbd));
CALL_INNER(LPBASEBROWSERDATA, PutBaseBrowserData,(), ());
CALL_INNER_HRESULT(CreateViewWindow, (IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd), (psvNew, psvOld, prcView, phwnd));;
CALL_INNER_HRESULT(SetTopBrowser, (), ());
CALL_INNER_HRESULT(OnFrameWindowActivateBS, (BOOL fActive), (fActive));
CALL_INNER_HRESULT(ReleaseShellView, (), ());
CALL_INNER_HRESULT(ActivatePendingView, (), ());
CALL_INNER_HRESULT(InitializeDownloadManager, (), ());
CALL_INNER_HRESULT(InitializeTransitionSite, (), ());
CALL_INNER_HRESULT(Offline, (int iCmd), (iCmd));
CALL_INNER_HRESULT(AllowViewResize, (BOOL f), (f));
CALL_INNER_HRESULT(SetActivateState, (UINT u), (u));
CALL_INNER_HRESULT(UpdateSecureLockIcon, (int eSecureLock), (eSecureLock));
CALL_INNER_HRESULT(CreateBrowserPropSheetExt, (REFIID riid, void **ppvOut), (riid, ppvOut));

CALL_INNER_HRESULT(SetAsDefFolderSettings,(), ());
CALL_INNER_HRESULT(GetViewRect,(RECT* prc), (prc));
CALL_INNER_HRESULT(GetViewWindow,(HWND * phwnd), (phwnd));
CALL_INNER_HRESULT(InitializeTravelLog,(ITravelLog* ptl, DWORD dw), (ptl, dw));

CALL_INNER_HRESULT(_UIActivateView, (UINT uState), (uState));

CALL_INNER_HRESULT(_UpdateViewRectSize,(), ());

CALL_INNER_HRESULT(_GetEffectiveClientArea, (LPRECT prcBorder, HMONITOR hmon), (prcBorder, hmon));
CALL_INNER_HRESULT(_ResizeView,(), ());

    // BEGIN REVIEW:  review names and need of each.  
    // 
    // this first set could be basebrowser only members.  no one overrides
CALL_INNER_HRESULT(_CancelPendingNavigationAsync, (), ());
CALL_INNER_HRESULT(_MaySaveChanges, (), ()); 
CALL_INNER_HRESULT(_PauseOrResumeView, (BOOL fPaused), (fPaused));
CALL_INNER_HRESULT(_DisableModeless, (), ());
    
    // rethink these... are all of these necessary?
CALL_INNER_HRESULT(_NavigateToPidl, (LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags), (pidl, grfHLNF, dwFlags));
CALL_INNER_HRESULT(_TryShell2Rename, (IShellView* psv, LPCITEMIDLIST pidlNew), (psv, pidlNew));
CALL_INNER_HRESULT(_SwitchActivationNow, () , ());
CALL_INNER_HRESULT(_CancelPendingView, (), ());

    //END REVIEW:

// overridden by cdesktopbrowser
CALL_INNER(IStream*, v_GetViewStream, (LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName), (pidl, grfMode, pwszName));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _pbsInner3-> _function _args ; }                                            

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

CALL_INNER_HRESULT(_PositionViewWindow, (HWND hwnd, LPRECT prc), (hwnd, prc));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _psbInner-> _function _args ; }                                            

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IShellBrowser (same as IOleInPlaceFrame)
    // IOleWindow
CALL_INNER_HRESULT(GetWindow, (HWND * lphwnd), (lphwnd));
CALL_INNER_HRESULT(ContextSensitiveHelp, (BOOL fEnterMode), (fEnterMode));

CALL_INNER_HRESULT(InsertMenusSB, (HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths), (hmenuShared, lpMenuWidths));
CALL_INNER_HRESULT(SetMenuSB, (HMENU hmenuShared, HOLEMENU holemenu, HWND hwnd), (hmenuShared, holemenu, hwnd));
CALL_INNER_HRESULT(RemoveMenusSB, (HMENU hmenuShared), (hmenuShared));
CALL_INNER_HRESULT(SetStatusTextSB, (LPCOLESTR lpszStatusText), (lpszStatusText));
CALL_INNER_HRESULT(EnableModelessSB, (BOOL fEnable), (fEnable));
CALL_INNER_HRESULT(BrowseObject, (LPCITEMIDLIST pidl, UINT wFlags), (pidl, wFlags));
CALL_INNER_HRESULT(GetControlWindow, (UINT id, HWND * lphwnd), (id, lphwnd));
CALL_INNER_HRESULT(SendControlMsg, (UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret), (id, uMsg, wParam, lParam, pret));
CALL_INNER_HRESULT(QueryActiveShellView, (struct IShellView ** ppshv), (ppshv));
CALL_INNER_HRESULT(OnViewWindowActive, (struct IShellView * ppshv), (ppshv));
CALL_INNER_HRESULT(SetToolbarItems, (LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags), (lpButtons, nButtons, uFlags));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _pdtInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // *** IDropTarget ***
CALL_INNER_HRESULT(DragEnter, (IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect), (pdtobj, grfKeyState, pt, pdwEffect));
CALL_INNER_HRESULT(DragOver, (DWORD grfKeyState, POINTL pt, DWORD *pdwEffect), (grfKeyState, pt, pdwEffect));
CALL_INNER_HRESULT(DragLeave, (void), ());
CALL_INNER_HRESULT(Drop, (IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect), (pdtobj, grfKeyState, pt, pdwEffect));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _pspInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IServiceProvider
CALL_INNER_HRESULT(QueryService, (REFGUID guidService, REFIID riid, void **ppvObj), (guidService, riid, ppvObj));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _pctInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IOleCommandTarget
CALL_INNER_HRESULT(QueryStatus, (const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext), (pguidCmdGroup, cCmds, rgCmds, pcmdtext));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

HRESULT CCommonBrowser::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup)) 
    {
        if (nCmdID == SBCMDID_CACHEINETZONEICON)
        {
            if (!pvarargIn || pvarargIn->vt != VT_BOOL || !pvarargOut)
                return ERROR_INVALID_PARAMETER;
            pvarargOut->vt = VT_UI4;
            ENTERCRITICAL;
            pvarargOut->ulVal = _CacheZonesIconsAndNames(pvarargIn->boolVal);
            LEAVECRITICAL;
            return S_OK;
        }    
    }

    return _pctInner->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _piosInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)


#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }


HRESULT CCommonBrowser::TranslateAcceleratorSB(LPMSG lpmsg, WORD wID)
{
    HRESULT hres = S_FALSE;
    
    TraceMsg(0, "ief TR CCommonBrowser::TranslateAcceleratorSB called");

    if (!_CanHandleAcceleratorNow())
    {
        TraceMsg(0, "Ignoring TranslateAccelerator, not active");
        return S_FALSE;
    }
    
    // If we're NOT top level, assume virtual TranslateAcceleratorSB
    // handles this request. (See CVOCBrowser.)

    // CDefView may call this before it passes it down to extended view
    if (_hacc && ::TranslateAcceleratorWrap(_pbbd->_hwnd, _hacc, lpmsg)) 
    {
        TraceMsg(DM_ACCELERATOR, "CSB::TranslateAcceleratorSB TA(_hacc) ate %x,%x",
                 lpmsg->message, lpmsg->wParam);

        // We don't want to eat this escape because some controls on the
        // page rely on ESC getting dispatched. Besides, dispatching it won't
        // hurt us...
        if (lpmsg->wParam != VK_ESCAPE)
            hres = S_OK;
    }

    return hres;
}
//////////////////////////////////////////////////////////////////////////////////
//
// Code to get the ViewStateStream of the "Explorer" OCX
//
//////////////////////////////////////////////////////////////////////////////////

HRESULT CCommonBrowser::GetViewStateStream(DWORD grfMode, IStream **ppstm)
{
    // NOTE: We can't use _pidlCur or _pidlPending here. Both are NULL
    // when we goto a new directory. _pidlPending is initialized later in
    // _CreateNewShellView. So, we use for which the NewShellView is created.
    LPCITEMIDLIST pidl = _pbbd->_pidlNewShellView;
    
    if (!pidl)
        pidl = _pbbd->_pidlPending;
    
    if (!pidl)
        pidl = _pbbd->_pidlCur;

    *ppstm = _pbsOuter->v_GetViewStream(pidl, grfMode, L"ViewView2");

    // If getting the new one (for read) failed, try the old one.
    if ((grfMode == STGM_READ) && (!*ppstm || SHIsEmptyStream(*ppstm)))
    {
        if (*ppstm)
            (*ppstm)->Release();
        *ppstm = _pbsOuter->v_GetViewStream(pidl, grfMode, L"ViewView");
        TraceMsg(DM_VIEWSTREAM, "CBB::GetViewStateStream tried old stream (%x)", *ppstm);
    }
    
    return *ppstm ? S_OK : E_OUTOFMEMORY;
}

//
// Returns the border rectangle for the shell view.
//
HRESULT CCommonBrowser::_GetViewBorderRect(RECT* prc)
{
    _pbsOuter->_GetEffectiveClientArea(prc, NULL);  // FEATURE: hmon?
    
    //
    // Extract the border taken by all "frame" toolbars
    //
    for (int i=0; i < _GetToolbarCount(); i++) 
    {
        TOOLBARITEM *ptbi = _GetToolbarItem(i);
        prc->left += ptbi->rcBorderTool.left;
        prc->top += ptbi->rcBorderTool.top;
        prc->right -= ptbi->rcBorderTool.right;
        prc->bottom -= ptbi->rcBorderTool.bottom;
    }
    
    return S_OK;
}

// NOTE: these toolbar functions are still part of CBaseBrowser2
// so they keep working. right now they are in IBrowserService2 and
// forwarded down.

void CCommonBrowser::_ReleaseToolbarItem(int itb, BOOL fClose)
{
    // grab it and NULL it out to eliminate race condition.
    // (actually, there's still a v. small window btwn the 2 statements).
    //
    // e.g. if you close a WebBar and then quickly shutdown windows,
    // the close destroys the window etc. but then the shutdown code
    // does _SaveToolbars which tries to do ->Save on that destroyed guy.
    //
    // note however that this now means that the entry is marked
    // 'free' so someone else might grab it out from under us and start
    // trashing it.
    TOOLBARITEM *ptbi = _GetToolbarItem(itb);
    IDockingWindow *ptbTmp = ptbi->ptbar;
    ptbi->ptbar = NULL;

    if (fClose)
    {
        ptbTmp->CloseDW(0);
    }

    IUnknown_SetSite(ptbTmp, NULL);

    // Check for NULL for BoundsChecker with Pageheap enabled functionality.
    if ( ptbi->pwszItem )
    {
        LocalFree(ptbi->pwszItem);
        ptbi->pwszItem = NULL;
    }

    ptbTmp->Release();
}


//***   CBB::_AllocToolbarItem -- find/create free slot in _aTBar toolbar array
// ENTRY/EXIT
//  hres    [out] S_OK|itb on success; o.w. E_FAIL
//  _aTBar  [inout] possibly grown
int CCommonBrowser::_AllocToolbarItem()
{
    TOOLBARITEM *ptbi;

    // try to recycle a dead one
    int iCount = FDSA_GetItemCount(&_fdsaTBar);
    for (int itb = 0; itb < iCount; ++itb) 
    {
        ptbi = (LPTOOLBARITEM)FDSA_GetItemPtr(&_fdsaTBar, itb, TOOLBARITEM);
        ASSERT(ptbi != NULL);
        if (ptbi && ptbi->ptbar == NULL) 
        {
            ASSERT(itb < ITB_MAX);
            return itb;
        }
    }

    // no luck recycling, create a new one
    static TOOLBARITEM tbiTmp /*=0*/;
    int i = FDSA_AppendItem(&_fdsaTBar, &tbiTmp);
    if (i == -1) 
    {
        TraceMsg(DM_WARNING, "cbb._ati: ret=-1");
        return -1;  // warning: same as ITB_VIEW (!)
    }
    ASSERT(i == itb);
#ifdef DEBUG
    {
        ptbi = (LPTOOLBARITEM) FDSA_GetItemPtr(&_fdsaTBar, itb, TOOLBARITEM);
        ASSERT(ptbi != NULL);
        for (int j = 0; j < sizeof(*ptbi); ++j)
            ASSERT(*(((char *)ptbi) + j) == 0);
    }
#endif

    ASSERT(i < ITB_MAX);
    return i;
}

HRESULT CCommonBrowser::_CloseAndReleaseToolbars(BOOL fClose)
{
    for (int itb = 0; itb < _GetToolbarCount(); itb++)
    {
        TOOLBARITEM *ptbi = _GetToolbarItem(itb);
        if (ptbi->ptbar)
        {
            _ReleaseToolbarItem(itb, fClose);
        }
    }

    return S_OK;
}

//
// Implementation of CBaseBrowser2::ShowToolbar
//
// Make toolbar visible or not and update our conception of whether it
// should be shown
//
// Returns: S_OK, if successfully done.
//          E_INVALIDARG, duh.
//
HRESULT CCommonBrowser::ShowToolbar(IUnknown* punkSrc, BOOL fShow)
{
    UINT itb = _FindTBar(punkSrc);
    if (itb == (UINT)-1) 
    {
        return E_INVALIDARG;
    }

    TOOLBARITEM *ptbi = _GetToolbarItem(itb);

    // The _FindTBar function should assure us that ptbi->ptbar is non-NULL.
    ASSERT(ptbi->ptbar);

    ptbi->ptbar->ShowDW(fShow);
    ptbi->fShow = fShow;

    return S_OK;
}

//***   IDockingWindowFrame::* {

//
// Implementation of IDockingWindowFrame::AddToolbar
//
//  Add the specified toolbar (as punkSrc) to this toolbar site and
// make it visible.
//
// Returns: S_OK, if successfully done.
//          E_FAIL, if failed (exceeded maximum).
//          E_NOINTERFACE, the toolbar does not support an approriate interface.
//
HRESULT CCommonBrowser::AddToolbar(IUnknown* punk, LPCWSTR pszItem, DWORD dwAddFlags)
{
    HRESULT hr = E_FAIL;
    int itb = _AllocToolbarItem();  // Find the first empty spot. 
    if (itb != -1) 
    {
        TOOLBARITEM *ptbi = _GetToolbarItem(itb);
        ASSERT(ptbi != NULL);

        ASSERT(ptbi->ptbar == NULL);

        hr = punk->QueryInterface(IID_PPV_ARG(IDockingWindow, &ptbi->ptbar));
        if (SUCCEEDED(hr)) 
        {
            if (pszItem) 
            {
                ptbi->pwszItem = StrDupW(pszItem);
                if (NULL == ptbi->pwszItem) 
                {
                    hr = E_OUTOFMEMORY;
                    ATOMICRELEASE(ptbi->ptbar);
                    return hr;
                }
            }

            ptbi->fShow = (! (dwAddFlags & DWFAF_HIDDEN)); // shown
            IUnknown_SetSite(ptbi->ptbar, SAFECAST(this, IShellBrowser*));
            ptbi->ptbar->ShowDW(ptbi->fShow);
        } 
        else 
        {
            // ERROR: all toolbars should implement IDockingWindow
            // call tjgreen if this rips
            ASSERT(0);
        }
    }

    return hr;
}

//
// Implementation of IDockingWindowFrame::RemoveToolbar
//
HRESULT CCommonBrowser::RemoveToolbar(IUnknown* punkSrc, DWORD dwRemoveFlags)
{
    UINT itb = _FindTBar(punkSrc);
    if (itb == (UINT)-1) 
    {
        return E_INVALIDARG;
    }

    _ReleaseToolbarItem(itb, TRUE);

    // Clear the rect and resize the inner ones (including the view).
    // note the semi-hoaky post-release partying on rcBorderTool
    SetRect(&_GetToolbarItem(itb)->rcBorderTool, 0, 0, 0, 0);
    _pbsOuter->_ResizeNextBorder(itb + 1);

    return S_OK;
}

//
// Implementation of IDockingWindowFrame::FindToolbar
//
HRESULT CCommonBrowser::FindToolbar(LPCWSTR pwszItem, REFIID riid, void **ppvObj)
{
    HRESULT hr = E_INVALIDARG;
    *ppvObj = NULL;

    if (pwszItem)
    {
        hr = S_FALSE;
        for (int itb = 0; itb < _GetToolbarCount(); itb++)
        {
            TOOLBARITEM *ptbi = _GetToolbarItem(itb);
            if (ptbi->pwszItem && StrCmpIW(ptbi->pwszItem, pwszItem)==0)
            {
                if (ptbi->ptbar)
                {
                    hr = ptbi->ptbar->QueryInterface(riid, ppvObj);
                }
                else
                {
                    TraceMsg(TF_WARNING, "ptbi->ptbar is NULL in FindToolbar");
                    hr = E_FAIL;
                }
                break;
            }
        }
    }

    return hr;
}

// }

UINT CCommonBrowser::_FindTBar(IUnknown* punkSrc)
{
#ifdef DEBUG
    static long nQuick = 0;
    static long nSlow = 0;
#endif

    ASSERT(punkSrc);

    // Quick check without QI
    TOOLBARITEM *ptbi;
    for (int i=0; i < _GetToolbarCount(); i++) 
    {
        ptbi = _GetToolbarItem(i);
        if (punkSrc==ptbi->ptbar) 
        {
#ifdef DEBUG
            // I wonder if we ever hit this case...
            InterlockedIncrement(&nQuick);
            TraceMsg(TF_PERF, "_FindTBar QUICK=%d SLOW=%d", nQuick, nSlow);
#endif            
            return i;
        }
    }

    // If failed, do the real COM object identity check. 
    for (i=0; i < _GetToolbarCount(); i++) 
    {
        ptbi = _GetToolbarItem(i);
        if (ptbi->ptbar) 
        {
            if (SHIsSameObject(ptbi->ptbar, punkSrc)) 
            {
#ifdef DEBUG        
                InterlockedIncrement(&nSlow);
                TraceMsg(TF_PERF, "_FindTBar QUICK=%d SLOW=%d", nQuick, nSlow);
#endif            
                return i;
            }
        }
    }

    return (UINT)-1;
}

HRESULT CCommonBrowser::v_ShowHideChildWindows(BOOL fChildOnly)
{
    for (UINT itb = 0; itb < (UINT)_GetToolbarCount(); itb++) 
    {
        TOOLBARITEM *ptbi = _GetToolbarItem(itb);
        if (ptbi->ptbar) 
        {
            ptbi->ptbar->ShowDW(ptbi->fShow);
        }
    }

    if (!fChildOnly) 
    {
        _pbsInner->v_ShowHideChildWindows(fChildOnly);
    }

    return S_OK;
}

//***   _Load/_SaveToolbars {
#ifdef DEBUG
extern unsigned long DbStreamTell(IStream *pstm);
#else
#define DbStreamTell(pstm)      ((ULONG) 0)
#endif

const static DWORD c_BBSVersion = 0x00000011; // Increment when the stream is changed.

#define MAX_ITEMID 128 // enough for item id

HRESULT CCommonBrowser::_SaveToolbars(IStream* pstm)
{
    HRESULT hres = S_OK;
    DWORD count = 0;

    TraceMsg(DM_PERSIST, "cbb.stb enter(this=%x pstm=%x) tell()=%x", this, pstm, DbStreamTell(pstm));
    if (pstm==NULL) 
    {
        for (UINT itb = 0; itb < (UINT)_GetToolbarCount(); itb++) 
        {
            TOOLBARITEM *ptbi = _GetToolbarItem(itb);
            if (ptbi->ptbar) 
            {
                IPersistStream* ppstm;
                HRESULT hresT = ptbi->ptbar->QueryInterface(IID_PPV_ARG(IPersistStream, &ppstm));
                if (SUCCEEDED(hresT)) 
                {
                    ppstm->Release();
                    count++;
                }
            }
        }
        TraceMsg(DM_PERSIST, "cbb.stb leave count=%d", count);
        return (count>0) ? S_OK : S_FALSE;
    }

    ULARGE_INTEGER liStart;

    pstm->Write(&c_BBSVersion, sizeof(c_BBSVersion), NULL);

    // Remember the current location, where we writes count. 
    pstm->Seek(c_li0, STREAM_SEEK_CUR, &liStart);
    TraceMsg(DM_PERSIST, "cbb.stb seek(count)=%x", liStart.LowPart);

    hres = pstm->Write(&count, sizeof(count), NULL);
    if (hres==S_OK) 
    {
        for (UINT itb = 0; itb < (UINT)_GetToolbarCount(); itb++) 
        {
            TOOLBARITEM *ptbi = _GetToolbarItem(itb);
            if (ptbi->ptbar) 
            {
                IPersistStream* ppstm;
                HRESULT hresT = ptbi->ptbar->QueryInterface(IID_PPV_ARG(IPersistStream, &ppstm));
                if (SUCCEEDED(hresT)) 
                {
                    DWORD cchName = ptbi->pwszItem ? lstrlenW(ptbi->pwszItem) : 0;
                    if (cchName > 0 && cchName < MAX_ITEMID)
                    {
                        TraceMsg(DM_PERSIST, "cbb.stb pwszItem=<%ls>", ptbi->pwszItem);
                        pstm->Write(&cchName, sizeof(cchName), NULL);
                        pstm->Write(ptbi->pwszItem, cchName*sizeof(WCHAR), NULL);
                    } 
                    else 
                    {
                        TraceMsg(DM_PERSIST, "cbb.stb lstrlenW(pwszItem)=%d", cchName);
                        pstm->Write(&cchName, sizeof(cchName), NULL);
                    }

                    TraceMsg(DM_PERSIST, "cbb.stb enter OleSaveToStream tell()=%x", DbStreamTell(pstm));
                    hres = OleSaveToStream(ppstm, pstm);
                    TraceMsg(DM_PERSIST, "cbb.stb leave OleSaveToStream tell()=%x", DbStreamTell(pstm));
                    ppstm->Release();
    
                    if (FAILED(hres)) 
                    {
                        break;
                    }
                    count++;
                }
            }
        }

        // Remember the end
        ULARGE_INTEGER liEnd;
        pstm->Seek(c_li0, STREAM_SEEK_CUR, &liEnd);
        TraceMsg(DM_PERSIST, "cbb.stb seek(end save)=%x", DbStreamTell(pstm));

        // Seek back to the original location
        TraceMsg(DM_PERSIST, "cbb.stb fix count=%d", count);
        LARGE_INTEGER liT;
        liT.HighPart = 0;
        liT.LowPart = liStart.LowPart; 
        pstm->Seek(liT, STREAM_SEEK_SET, NULL);
        hres = pstm->Write(&count, sizeof(count), NULL);

        // Seek forward to the end
        liT.LowPart = liEnd.LowPart;
        pstm->Seek(liT, STREAM_SEEK_SET, NULL);

        TraceMsg(DM_PERSIST, "cbb.stb seek(end restore)=%x", DbStreamTell(pstm));
    }

    TraceMsg(DM_PERSIST, "cbb.stb leave tell()=%x", DbStreamTell(pstm));
    return hres;
}

HRESULT IUnknown_GetClientDB(IUnknown *punk, IUnknown **ppdbc)
{
    *ppdbc = NULL;

    IDeskBar *pdb;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IDeskBar, &pdb));
    if (SUCCEEDED(hr)) 
    {
        hr = pdb->GetClient(ppdbc);
        pdb->Release();
    }
    return hr;
}

HRESULT CCommonBrowser::_LoadToolbars(IStream* pstm)
{
    DWORD dwVersion;

    TraceMsg(DM_PERSIST, "cbb.ltb enter(this=%x pstm=%x) tell()=%x", this, pstm, DbStreamTell(pstm));
    HRESULT hres = pstm->Read(&dwVersion, sizeof(dwVersion), NULL);

    if (hres == S_OK && dwVersion == c_BBSVersion) 
    {
        DWORD count;
        hres = pstm->Read(&count, sizeof(count), NULL);
        if (hres == S_OK) 
        {
            for (UINT i=0; i<count && SUCCEEDED(hres); i++) 
            {
                DWORD cchName = 0;
                hres = pstm->Read(&cchName, sizeof(cchName), NULL);
                if (hres == S_OK)
                {
                    WCHAR wszName[MAX_ITEMID];
                    wszName[0] = 0;
                    // if cchName >= ARRAYSIZE(wszName) then we're misaligned in the stream!
                    if (cchName)
                    {
                        if (cchName<ARRAYSIZE(wszName)) 
                        {
                            hres = pstm->Read(wszName, cchName*sizeof(WCHAR), NULL);
                        }
                        else
                        {
                            hres = E_FAIL; // We are missaligned in the stream, let's stop attempting to load
                        }
                    }
                    TraceMsg(DM_PERSIST, "cbb.ltb name=<%ls>", wszName);
    
                    if (hres==S_OK) 
                    {
                        IDockingWindow* pstb;
                        TraceMsg(DM_PERSIST, "cbb.ltb enter OleLoadFromStream tell()=%x", DbStreamTell(pstm));
                        hres = OleLoadFromStream(pstm, IID_PPV_ARG(IDockingWindow, &pstb));
                        TraceMsg(DM_PERSIST, "cbb.ltb leave OleLoadFromStream tell()=%x", DbStreamTell(pstm));
                        if (SUCCEEDED(hres)) 
                        {
                            IUnknown *pDbc = NULL;

                            // nt5:216944: turn off size negotiation during
                            // load.  o.w. persisted size gets nuked.
                            IUnknown_GetClientDB(pstb, &pDbc);
                            if (pDbc)
                                DBC_ExecDrag(pDbc, DRAG_MOVE);

                            hres = AddToolbar(pstb, wszName[0] ? wszName : NULL, NULL);
                            if (pDbc) 
                            {
                                DBC_ExecDrag(pDbc, 0);
                                pDbc->Release();
                            }
                            pstb->Release();
                        }
                    }
                }
            }
        }
    } 
    else 
    {
        hres = E_FAIL;
    }

    TraceMsg(DM_PERSIST, "cbb.ltb leave tell()=%x", DbStreamTell(pstm));
    return hres;
}

// }

//  *** IDockingWindowSite methods ***

HRESULT CCommonBrowser::_GetBorderDWHelper(IUnknown* punkSrc, LPRECT prcBorder, BOOL bUseHmonitor)
{
    UINT itb = _FindTBar(punkSrc);
    if (itb == (UINT)-1)
    {
        RIPMSG(0, "GetBorderDW: invalid punkSrc");
        return E_INVALIDARG;
    }
    else if (!prcBorder)
    {
        RIPMSG(0, "GetBorderDW: invalid prcBorder");
        return E_INVALIDARG;
    }

    TOOLBARITEM *ptbThis = _GetToolbarItem(itb);
    if (bUseHmonitor && ptbThis && ptbThis->hMon)
    {
        _pbsOuter->_GetEffectiveClientArea(prcBorder, ptbThis->hMon);
    }
    else
    {
        _pbsOuter->_GetEffectiveClientArea(prcBorder, NULL);
    }

    //
    // Subtract border area taken by "outer toolbars"
    //
    for (UINT i = 0; i < itb; i++)
    {
        TOOLBARITEM *ptbi = _GetToolbarItem(i);
        if (!bUseHmonitor || (ptbThis && (ptbi->hMon == ptbThis->hMon)))
        {
            prcBorder->left += ptbi->rcBorderTool.left;
            prcBorder->top += ptbi->rcBorderTool.top;
            prcBorder->right -= ptbi->rcBorderTool.right;
            prcBorder->bottom -= ptbi->rcBorderTool.bottom;
        }
    }

    return S_OK;
}

//
// This is an implementation of IDockingWindowSite::GetBorderDW.
//
//  This function returns a bounding rectangle for the specified toolbar
// (by punkSrc). It gets the effective client area, then subtract border
// area taken by "outer" toolbars. 
// 
HRESULT CCommonBrowser::GetBorderDW(IUnknown* punkSrc, LPRECT prcBorder)
{
    return _GetBorderDWHelper(punkSrc, prcBorder, FALSE);
}


HRESULT CCommonBrowser::RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pbw)
{
    RIP(IS_VALID_READ_PTR(pbw, BORDERWIDTHS));
    return S_OK;
}

HRESULT CCommonBrowser::SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pbw)
{
    UINT itb = _FindTBar(punkSrc);
    if (itb == (UINT)-1)
    {
        RIPMSG(0, "GetBorderDW: invalid punkSrc");
        return E_INVALIDARG;
    }

    _GetToolbarItem(itb)->rcBorderTool = *pbw;
    _pbsOuter->_ResizeNextBorder(itb + 1);

    return S_OK;
}

HRESULT CCommonBrowser::_ResizeNextBorderHelper(UINT itb, BOOL bUseHmonitor)
{
    //
    // Starting with itb, look for the next toolbar on the same
    // monitor (if we care about the monitor).
    //
    IDockingWindow* ptbarNext = NULL;

    if ((int) itb < _GetToolbarCount())
    {
        TOOLBARITEM *ptbThis = _GetToolbarItem(itb);
        for (int i = itb; i < _GetToolbarCount(); i++)
        {
            TOOLBARITEM *ptbi = _GetToolbarItem(i);
            if (ptbi->ptbar && (!bUseHmonitor || (ptbi->hMon == ptbThis->hMon)))
            {
                //
                // Found it, we're done
                //
                ptbarNext = ptbi->ptbar;
                break;
            }
        }
    }

    if (ptbarNext)
    {
        //
        // Get the toolbar's docking window rect and resize the
        // border to that.
        //
        RECT rc;

        GetBorderDW(ptbarNext, &rc);
        ptbarNext->ResizeBorderDW(&rc, (IShellBrowser*)this, TRUE);
    }
    else
    {
        //
        // We didn't find a toolbar, so we must be at the end
        // of the list.  Finish up by resizing the view.
        //
        _pbsOuter->_ResizeView();
    }

    return S_OK;
} 

HRESULT CCommonBrowser::_ResizeNextBorder(UINT itb)
{
    _ResizeNextBorderHelper(itb, FALSE);
    return S_OK;
}


//
// Hack alert!
//
// IE grabs the focus via _FixToolbarFocus when it shouldn't.  For example if a
// java app in a seperate window contains an edit control and the address bar
// had focus before the java app.  In this scenario the first time a user types
// in the edit control IE grabs back the focus.  IE bug#59007.
//
// To prevent IE from incorrectly grabbing the focus this fuction checks that
// top level parent of the toolbar is the same as the top level parent of the 
// window that has focus.
// 

BOOL CCommonBrowser::_TBWindowHasFocus(UINT itb)
{
    ASSERT(itb < ITB_MAX);

    BOOL fRet = TRUE;

    HWND hwndFocus = GetFocus();

    while (GetWindowLong(hwndFocus, GWL_STYLE) & WS_CHILD)
        hwndFocus = GetParent(hwndFocus);

    if (hwndFocus)
    {
        TOOLBARITEM *pti = _GetToolbarItem(itb);

        if (pti && pti->ptbar)
        {
            HWND hwndTB;
            if (SUCCEEDED(pti->ptbar->GetWindow(&hwndTB)) && hwndTB)
            {
                fRet = (S_OK == SHIsChildOrSelf(hwndFocus, hwndTB));
            }
        }
    }

    return fRet;
}

void DestroyZoneIconNameCache(void)
{
    if (g_pZoneIconNameCache)
    {
        PZONEICONNAMECACHE pzinc = g_pZoneIconNameCache;
        for (DWORD i = 0; i < g_dwZoneCount; i++)
        {
            if (pzinc->hiconZones)
                DestroyIcon((HICON)pzinc->hiconZones);
            pzinc++;
        }
        LocalFree(g_pZoneIconNameCache);
        g_pZoneIconNameCache = NULL;
        g_dwZoneCount = 0;
    }
}

DWORD CCommonBrowser::_CacheZonesIconsAndNames(BOOL fRefresh)
{
    ASSERTCRITICAL;
    if (g_pZoneIconNameCache)      // If we've already cached the zones, just return the zone count unless we want to refresh cache
    {
        if (fRefresh)
        {
            DestroyZoneIconNameCache();
        }
        else
            return(g_dwZoneCount);
    }

    // Create ZoneManager
    if (!_pizm)
        CoCreateInstance(CLSID_InternetZoneManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IInternetZoneManager, &_pizm));

    if (_pizm)
    {
        DWORD dwZoneEnum;

        if (SUCCEEDED(_pizm->CreateZoneEnumerator(&dwZoneEnum, &g_dwZoneCount, 0)))
        {
            if ((g_pZoneIconNameCache = (PZONEICONNAMECACHE)LocalAlloc(LPTR, g_dwZoneCount * sizeof(ZONEICONNAMECACHE))) == NULL)
            {
                g_dwZoneCount = 0;
                return 0;
            }
                
            for (int nIndex=0; (DWORD)nIndex < g_dwZoneCount; nIndex++)
            {
                DWORD           dwZone;
                ZONEATTRIBUTES  za = {sizeof(ZONEATTRIBUTES)};

                _pizm->GetZoneAt(dwZoneEnum, nIndex, &dwZone);

                // get the zone attributes for this zone
                _pizm->GetZoneAttributes(dwZone, &za);

                StringCchCopyW(g_pZoneIconNameCache[nIndex].szZonesName, ARRAYSIZE(g_pZoneIconNameCache[nIndex].szZonesName), za.szDisplayName);
                StringCchCopyW(g_pZoneIconNameCache[nIndex].szIconPath, ARRAYSIZE(g_pZoneIconNameCache[nIndex].szIconPath), za.szIconPath);
                g_pZoneIconNameCache[nIndex].hiconZones = 0; // Load the hIcon on demand
            }
            _pizm->DestroyZoneEnumerator(dwZoneEnum);
        }
    }

    return g_dwZoneCount;
}

// zero's out pIcon & pszName on failure
BOOL CCommonBrowser::_GetCachedZoneIconAndName(DWORD lZone, HICON *pIcon, LPTSTR pszName, DWORD cch)
{
    BOOL bRet = FALSE;

    *pIcon = NULL;
    pszName[0] = 0;

    ENTERCRITICAL;
    if (lZone < _CacheZonesIconsAndNames(FALSE))
    {
        ZONEICONNAMECACHE *pzinc = &g_pZoneIconNameCache[lZone];

        // if we haven't yet cached the icon for this zone, extract it now
        // REVIEW: worth pulling the extraction outside the critsec?
        if (!pzinc->hiconZones)
        {
            // Zone icons are in two formats.
            // wininet.dll#1200 where 1200 is the res id.
            // or foo.ico directly pointing to an icon file.
            // search for the '#'
            // # is a valid filename character
            LPWSTR pwsz = StrChrW(pzinc->szIconPath, TEXTW('#'));
            WORD iIcon = 0;

            if (pwsz)
            {
                // if we found it, then we have the foo.dll#00001200 format
                pwsz[0] = TEXTW('\0');
                iIcon = (WORD)StrToIntW(pwsz+1);
                ExtractIconExW(pzinc->szIconPath,(UINT)(-1*iIcon), NULL, &pzinc->hiconZones, 1);
            }
            else
                pzinc->hiconZones = (HICON)ExtractAssociatedIconExW(HINST_THISDLL, pzinc->szIconPath, (LPWORD)&iIcon, &iIcon);

            // If mirrored system, mirror icon so that it get unmirrored again when displayed
            if (IS_BIDI_LOCALIZED_SYSTEM())
            {        
               MirrorIcon(&pzinc->hiconZones, NULL);
            }                    

        }

        *pIcon = CopyIcon(pzinc->hiconZones);
        StringCchCopyW(pszName, cch, pzinc->szZonesName); // truncation ok (currently only used for display)
        bRet = TRUE;
    }
    LEAVECRITICAL;

    return bRet;
}


BOOL _QITest(IUnknown* punk, REFIID riid);

BOOL CCommonBrowser::_ShouldTranslateAccelerator(MSG* pmsg)
{
    //
    // We should only translate an acclerator if
    //
    // (a) the window is the frame or a child of the frame
    //     or a child of a defview window (NT5 Bug # 357186).
    //     (need to check this because you can have, for
    //     example, a toplevel java applet window running
    //     on our thread)
    //
    //     and
    //
    // (b) it's on our thread (need to check this because
    //     old-style OLE controls on a web page can run
    //     on the desktop thread)
    //

    BOOL fTranslate = FALSE;

    fTranslate = (SHIsChildOrSelf(_pbbd->_hwnd, pmsg->hwnd) == S_OK);

    if (!fTranslate) 
    {
       HWND hwnd = NULL;

       if (_pbbd->_psv && (_QITest(SAFECAST(_pbbd->_psv, IUnknown*), IID_CDefView))
            &&  SUCCEEDED(_pbbd->_psv->GetWindow(&hwnd)))
       {
          fTranslate = (SHIsChildOrSelf(hwnd, pmsg->hwnd) == S_OK);
       }
    }
    

    if (fTranslate)
    {
        DWORD dwThread = GetWindowThreadProcessId(_pbbd->_hwnd, NULL);

        HWND hwndMsg = pmsg->hwnd;
        while (GetWindowLong(hwndMsg, GWL_STYLE) & WS_CHILD)
        {
            hwndMsg = GetParent(hwndMsg);
        }
        DWORD dwMsgThread = hwndMsg ? GetWindowThreadProcessId(hwndMsg, NULL) : 0;

        if (dwThread == dwMsgThread)
        {
            return TRUE;
        }
    }

    return FALSE;
}

HRESULT CCommonBrowser::v_MayTranslateAccelerator(MSG* pmsg)
{
    if (!(WM_KEYFIRST <= pmsg->message && pmsg->message <= WM_KEYLAST))
        return S_FALSE;

    BOOL fToolbarHasFocus = _HasToolbarFocus();

    if (fToolbarHasFocus)
    {
        ASSERT(_get_itbLastFocus() < (UINT)_GetToolbarCount());
        // toolbar has focus -- give it first chance to translate
        //
        // Notes:
        //  Notice that we don't give a chance to translate its accelerators
        // to other toolbars. This is by-design right now. We might want to
        // change it later, but it will be tricky to do it right. 
        //
        if (IUnknown_TranslateAcceleratorIO(_GetToolbarItem(_get_itbLastFocus())->ptbar, pmsg) == S_OK)
            return(S_OK);

    }
    else
    {
        UINT itbLastFocus = _get_itbLastFocus();

        if (itbLastFocus != ITB_VIEW && _TBWindowHasFocus(itbLastFocus))
        {
            // view got focus back, update cache
            _FixToolbarFocus();
        }

        // view has focus -- give it first chance to translate
        // View doesn't necessarily have focus.  Added a check.
        //
        if (_pbbd->_psv)                 // If we have a shell view
        {
            HWND hwnd;

            // Note: Not everyone supports GetWindow (go figure)
            // In which case, we try the GetFocus() window.
            if (FAILED(_pbbd->_psv->GetWindow(&hwnd)))
            {
                hwnd = GetFocus();
            }

            // check if view or its child has focus
            // before it checked for browser or a child but if user
            // clicked on Show Desktop in quick launch
            // defview is deparented from the desktop and this call
            // fails which prevents tabbing to Active Desktop
            // (done in CDefView::TranslateAccelerator
            if (SHIsChildOrSelf(hwnd, pmsg->hwnd) == S_OK)
            {
                if (_pbbd->_psv->TranslateAccelerator(pmsg) == S_OK)  // and the shell view translated the message
                {
                    return S_OK;
                }
            }
        }
    }

    // Then, handle our own accelerators (with special code for TAB key).
    if (_ShouldTranslateAccelerator(pmsg))
    {
        if (IsVK_TABCycler(pmsg))
            return _CycleFocus(pmsg);

        BOOL fFwdItbar = FALSE;

        // FEATURE: Why not just include F4 and Alt-D in ACCEL_MERGE,
        // which gets localized?


        if (pmsg->message == WM_KEYDOWN && pmsg->wParam == VK_F4)
        {
            fFwdItbar = TRUE;
        }

        if (pmsg->message == WM_SYSCHAR)
        {
            static CHAR szAccel[2] = "\0";
            CHAR   szChar [2] = "\0";
            
            
            if ('\0' == szAccel[0])
                MLLoadStringA(IDS_ADDRBAND_ACCELLERATOR, szAccel, ARRAYSIZE(szAccel));

            szChar[0] = (CHAR)pmsg->wParam;
            
            if (lstrcmpiA(szChar,szAccel) == 0)
            {
                fFwdItbar = TRUE;
            }    
        }

        if (fFwdItbar)
        {
            IDockingWindow *ptbar = _GetToolbarItem(ITB_ITBAR)->ptbar;
            if (IUnknown_TranslateAcceleratorIO(ptbar, pmsg) == S_OK)
                return S_OK;
        } 

        if (TranslateAcceleratorSB(pmsg, 0) == S_OK)
            return S_OK;
    }

    // If a toolbar has focus, we ask the view last. 
    if (fToolbarHasFocus)
    {
        if (_pbbd->_psv && _pbbd->_psv->TranslateAccelerator(pmsg) == S_OK)
            return S_OK;
    }

    return S_FALSE;
}

HRESULT CCommonBrowser::_CycleFocus(LPMSG lpMsg)
{
    UINT citb = 1;

    if (GetKeyState(VK_SHIFT) < 0)
    {
        // go backward
        citb = (UINT)-1;
    }

    UINT itbCur = _get_itbLastFocus();

    //
    //  Find the next visible toolbar and set the focus to it. Otherwise,
    // set the focus to the view window.
    //
    HWND hwndFocusNext;
    TOOLBARITEM *ptbi;

    if (_pbsOuter->v_MayGetNextToolbarFocus(lpMsg, itbCur, citb, &ptbi, &hwndFocusNext) == S_OK)
    {
        // Found a toolbar to take focus, nothing more to do.
        // FEATURE: do we (or caller) need to do SetStatusTextSB?
        // It looks like no one is doing it right now.
        return S_OK;
    }

    if (!(hwndFocusNext && IsWindowVisible(hwndFocusNext)))
    {
        // Didn't find anyone.  Set focus on the view.
        hwndFocusNext = _pbbd->_hwndView;
    }

    _SetFocus(ptbi, hwndFocusNext, lpMsg);

    return S_OK;
}

//***   _MayUIActTAB -- attempt TAB-activation of IOleWindow/IInputObject
// ENTRY/EXIT
//  powEtc      IOleWindow/IInputObject pair.
//  lpMsg       msg causing activation (may be NULL) (typically TAB)
//  fShowing    currently showing?
//  phwnd       [OUT] hwnd for object
//  hr          [RET] UIActivateIO result, plus E_FAIL
// DESCRIPTION
//  when TABing we only want to activate certain guys, viz. those who are
// currently showing, visible, and willing to accept activation.
HRESULT _MayUIActTAB(IOleWindow *pow, LPMSG lpMsg, BOOL fShowing, HWND *phwnd)
{
    HRESULT hr = E_FAIL;
    HWND hwnd = 0;

    if (pow && fShowing)
    {
        hr = pow->GetWindow(&hwnd);
        if (IsWindowVisible(hwnd))
            hr = IUnknown_UIActivateIO(pow, TRUE, lpMsg);
    }

    if (phwnd)
        *phwnd = hwnd;

    return hr;
}

//***   v_MayGetNextToolbarFocus -- get next in TAB order (and maybe SetFocus)
// ENTRY/EXIT
//  hres    E_FAIL for no candidate, S_FALSE for candidate, S_OK for 100% done
//          (S_OK only used by derived class for now)
HRESULT CCommonBrowser::v_MayGetNextToolbarFocus(LPMSG lpMsg,
    UINT itbCur, int citb,
    TOOLBARITEM ** pptbi, HWND * phwnd)
{
    HWND hwnd = 0;
    TOOLBARITEM *ptbi = NULL;

    if (itbCur == ITB_VIEW)
    {
        ASSERT(citb == 1 || citb == -1);
        if (citb == 1)
            itbCur = 0;
        else
            itbCur = _GetToolbarCount() - 1;
    }
    else
    {
        itbCur += citb;
    }

    // (semi-tricky: loop on an unsigned so get 0..n or n..0 w/ single loop)
    for (UINT i = itbCur; i < (UINT)_GetToolbarCount(); i += citb)
    {
        ptbi = _GetToolbarItem(i);
        // NOTE: _MayUIActTAB checks ptbi->ptbar for NULL
        if (_MayUIActTAB(ptbi->ptbar, lpMsg, ptbi->fShow, &hwnd) == S_OK)
        {
            *pptbi = ptbi;
            *phwnd = hwnd;
            return S_FALSE;
        }
    }

    *pptbi = NULL;
    *phwnd = 0;
    return E_FAIL;
}

BOOL _QITest(IUnknown* punk, REFIID riid)
{
    ASSERT(punk);

    BOOL fRet = FALSE;

    if (SUCCEEDED(punk->QueryInterface(riid, (void**)&punk)))
    {
        punk->Release();
        fRet = TRUE;
    }

    return fRet;
}

__inline BOOL _IsV4DefView(IShellView* psv)
{
    if (GetUIVersion() < 5)
        return _QITest(SAFECAST(psv, IUnknown*), IID_CDefView);

    return FALSE;
}

__inline BOOL _IsOldView(IShellView* psv)
{
    //
    // Current CDocObjectView and v4 and greater CDefView
    // implement IShellView2
    //
    return (FALSE == _QITest(SAFECAST(psv, IUnknown*), IID_IShellView2));
}

HRESULT CCommonBrowser::_SetFocus(TOOLBARITEM *ptbi, HWND hwnd, LPMSG lpMsg)
{
    // Clear the upper layer of status text
    SetStatusTextSB(NULL);

    if (hwnd == _pbbd->_hwndView)
    {
        if (_pbbd->_psv)
        {
            BOOL fTranslate = TRUE, fActivate = TRUE;

            if (!lpMsg)
            {
                // NULL message, so nothing to translate
                fTranslate = FALSE;
            }
            else if (_IsV4DefView(_pbbd->_psv) || _IsOldView(_pbbd->_psv))
            {
                // These views expect only to be UI-activated
                fTranslate = FALSE;
            }
            else if (IsVK_CtlTABCycler(lpMsg))
            {
                // Don't let trident translate ctl-tab.  Since it's always
                // UI-active, it will reject focus.
                fTranslate = FALSE;
            }
            else
            {
                // Normal case - do not activate the view.  TranslateAccelerator will do the right thing.
                fActivate = FALSE;
            }

            if (fActivate)
                _UIActivateView(SVUIA_ACTIVATE_FOCUS);

            if (fTranslate)
                _pbbd->_psv->TranslateAccelerator(lpMsg);
        }
        else
        {
            // IE3 compat (we used to do for all hwnd's)
            SetFocus(hwnd);
        }

        // Update our cache
        _OnFocusChange(ITB_VIEW);
    }

    return S_OK;
}

HRESULT CCommonBrowser::_FindActiveTarget(REFIID riid, void **ppvOut)
{
    HRESULT hres = E_FAIL;
    *ppvOut = NULL;

    BOOL fToolbarHasFocus = _HasToolbarFocus();
    if (fToolbarHasFocus) 
    {
        hres = _GetToolbarItem(_get_itbLastFocus())->ptbar->QueryInterface(riid, ppvOut);
    }
    else if (_pbbd->_psv) 
    {
        if (_get_itbLastFocus() != ITB_VIEW) 
        {
            // view got focus back, update cache
            _FixToolbarFocus();
        }

        if (_pbbd->_psv != NULL)
        {
            hres = _pbbd->_psv->QueryInterface(riid, ppvOut);
        }
    }

    return hres;
}

BOOL CCommonBrowser::_HasToolbarFocus(void)
{
    UINT uLast = _get_itbLastFocus();
    if (uLast < ITB_MAX)
    {
        TOOLBARITEM *ptbi = _GetToolbarItem(uLast);
        if (ptbi)
        {
            // NOTE: IUnknown_HasFocusIO checks ptbi->ptbar for NULL
            return (IUnknown_HasFocusIO(ptbi->ptbar) == S_OK);
        }
    }
    return FALSE;
}

//***   _FixToolbarFocus -- fake a UIActivate from the view
// NOTES
//  The view never goes 'truly' non-UIActive so we never get notified when 
//  it goes 'truly' UIActive.  we fake it here by mucking w/ our cache.
//
HRESULT CCommonBrowser::_FixToolbarFocus(void)
{
    _OnFocusChange(ITB_VIEW);               // ... and update cache
    _UIActivateView(SVUIA_ACTIVATE_FOCUS);  // steal the focus

    return S_OK;
}

HRESULT CCommonBrowser::_OnFocusChange(UINT itb)
{
    UINT itbPrevFocus = _get_itbLastFocus();

    if (itbPrevFocus != itb)
    {
        //
        //  If the view is losing the focus (within the explorer),
        // we should let it know. We should update _itbLastFocus before
        // calling UIActivate, because it will call our InsertMenu back.
        //
        _put_itbLastFocus(itb);

        if (itbPrevFocus == ITB_VIEW)
        {
            // DocHost will ignore this (since deactivating the view is taboo).
            // ShellView will respect it (so menu merge works).
            _UIActivateView(SVUIA_ACTIVATE_NOFOCUS);
        }
        else
        {
            IDockingWindow *ptb;

            // FEATURE: uh-oh not sure what we do if NULL
            // we do get NULL the 1st time we click on the SearchBand
            ptb = _GetToolbarItem(itbPrevFocus)->ptbar;

            IUnknown_UIActivateIO(ptb, FALSE, NULL);
        }
    }

    return S_OK;
}

HRESULT CCommonBrowser::OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus)
{
    UINT itb = _FindTBar(punkSrc);
    if (itb == ITB_VIEW)
    {
        return E_INVALIDARG;
    }

    //
    //  Note that we keep track of which toolbar got the focus last.
    // We can't reliably monitor the kill focus event because OLE's
    // window procedure hook (for merged menu dispatching code) changes
    // focus around. 
    //
    if (fSetFocus)
    {
        _OnFocusChange(itb);

        // Then, notify it to the shellview. 
        if (_pbbd->_pctView)
        {
            _pbbd->_pctView->Exec(NULL, OLECMDID_ONTOOLBARACTIVATED, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
        }
    }
    else if (itb == _get_itbLastFocus())
    {
        //
        // The toolbar which currently has focus is giving it up.
        // Move focus to the view when this happens.
        //
        _FixToolbarFocus();
    }

    return S_OK;
}

//***   toolbar/view broadcast {

//***   _ExecChildren -- broadcast Exec to view and toolbars
// NOTES
//  we might do *both* punkBar and fBroadcast if we want to send stuff
//  to both the view and to all toolbars, e.g. 'stop' or 'refresh'.
//
//  NOTE: n.b. the tray isn't a real toolbar, so it won't get called (sigh...).
HRESULT CCommonBrowser::_ExecChildren(IUnknown *punkBar, BOOL fBroadcast, const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt,
    VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    // 1st, send to specified guy (if requested)
    if (punkBar != NULL) 
    {
        // send to specified guy
        _pbsInner->_ExecChildren(punkBar, FALSE, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }

    // 2nd, broadcast to all (if requested)
    if (fBroadcast) 
    {
        for (int itb = 0; itb<_GetToolbarCount(); itb++) 
        {
            TOOLBARITEM *ptbi = _GetToolbarItem(itb);
            // NOTE: IUnknown_Exec checks ptbi->ptbar for NULL
            IUnknown_Exec(ptbi->ptbar, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
    }

    return S_OK;
}

HRESULT CCommonBrowser::_SendChildren(HWND hwndBar, BOOL fBroadcast, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // 1st, send to specified guy (if requested)
    if (hwndBar != NULL) 
    {
        // send to specified guy
        _pbsInner->_SendChildren(hwndBar, FALSE, uMsg, wParam, lParam);
    }

    // 2nd, broadcast to all (if requested)
    if (fBroadcast) 
    {
        for (int itb = 0; itb < _GetToolbarCount(); itb++) 
        {
            HWND hwndToolbar;
            TOOLBARITEM *ptbi = _GetToolbarItem(itb);
            if (ptbi->ptbar && SUCCEEDED(ptbi->ptbar->GetWindow(&hwndToolbar)))
                SendMessage(hwndToolbar, uMsg, wParam, lParam);
        }
    }

    return S_OK;
}

LRESULT CCommonBrowser::ForwardViewMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
     return _pbbd->_hwndView ? SendMessage(_pbbd->_hwndView, uMsg, wParam, lParam) : 0;
}

// }

TOOLBARITEM *CCommonBrowser::_GetToolbarItem(int itb)
{
    ASSERT(itb != ITB_VIEW);
    ASSERT(itb < ITB_MAX);
    // ==0 for semi-bogus CBB::_OnFocusChange code
    ASSERT(itb < FDSA_GetItemCount(&_fdsaTBar) || itb == 0);

    TOOLBARITEM *ptbi = FDSA_GetItemPtr(&_fdsaTBar, itb, TOOLBARITEM);

    ASSERT(ptbi != NULL);

    return ptbi;
}

HRESULT CCommonBrowser::SetAcceleratorMenu(HACCEL hacc)
{
    if (hacc != _hacc)
    {
        if (_hacc)
        {
            DestroyAcceleratorTable(_hacc);
        }
        _hacc = hacc;
    }
    return S_OK;
}

HRESULT _ConvertPathToPidl(IBrowserService2 *pbs, HWND hwnd, LPCTSTR pszPath, LPITEMIDLIST * ppidl)
{
    HRESULT hres = E_FAIL;
    WCHAR wszCmdLine[MAX_URL_STRING]; // must be with pszPath
    TCHAR szParsedUrl[MAX_URL_STRING] = {'\0'};
    TCHAR szFixedUrl[MAX_URL_STRING];
    DWORD dwUrlLen = ARRAYSIZE(szParsedUrl);
    LPCTSTR pUrlToUse = pszPath;

    // Copy the command line into a temporary buffer
    // so we can remove the surrounding quotes (if 
    // they exist)
    hres = StringCchCopy(szFixedUrl, ARRAYSIZE(szFixedUrl), pszPath);
    if (SUCCEEDED(hres))
    {
        PathUnquoteSpaces(szFixedUrl);
    
        if (ParseURLFromOutsideSource(szFixedUrl, szParsedUrl, &dwUrlLen, NULL))
            pUrlToUse = szParsedUrl;
    
        SHTCharToUnicode(pUrlToUse, wszCmdLine, ARRAYSIZE(wszCmdLine));
    
        hres = pbs->IEParseDisplayName(CP_ACP, wszCmdLine, ppidl);
        pbs->DisplayParseError(hres, wszCmdLine);
    }
    else
    {
        *ppidl = NULL;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\cwndproc.cpp ===
#include "priv.h"
#include "..\inc\cwndproc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\cwndproc.h ===
#include "..\inc\cwndproc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\dbapp.h ===
#ifndef _DBAPP_H
#define _DBAPP_H

class CDeskBarApp : public CDeskBar
                    ,public IContextMenu3
{
public:
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) {return CDeskBar::AddRef();};
    STDMETHODIMP_(ULONG) Release(void) { return CDeskBar::Release();};
    
    STDMETHOD(QueryService)(REFGUID guidService,
                                 REFIID riid, void **ppvObj);

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IPersistStreamInit methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP IsDirty(void);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);
    virtual STDMETHODIMP InitNew(void);

    // *** IPersistPropertyBag ***
    virtual HRESULT STDMETHODCALLTYPE Load(IPropertyBag *pPropBag,
                                           IErrorLog *pErrorLog);

    // *** IContextMenu3 methods ***
    STDMETHOD(QueryContextMenu)(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);

    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax);
    STDMETHOD(HandleMenuMsg)(UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);
    STDMETHOD(HandleMenuMsg2)(UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam,
                              LRESULT* plres);


    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    
protected:
    virtual void _SetModeSide(UINT eMode, UINT uSide, HMONITOR hMon, BOOL fNoMerge);
    virtual void _UpdateCaptionTitle();
    virtual void _NotifyModeChange(DWORD dwMode);
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void _LeaveSide();

    virtual ~CDeskBarApp();
    void _CreateBandSiteMenu();


    BOOL _OnCloseBar(BOOL fConfirm); // Override dockbar's _OnCloseBar to add UI confirmation


    HRESULT _MergeSide(IBandSite *pdbDst);

    IContextMenu3* _pcm;
    
    // this class explicitely knows about CBandSite.  this is the distinction between deskbar and dbapp.
    CBandSite* _pbs;
    UINT    _eInitLoaded:2;
    int _idCmdDeskBarFirst;
    

    friend HRESULT DeskBarApp_Create(IUnknown** ppunk);
};

extern HRESULT DeskBarApp_Create(IUnknown** ppunk, IUnknown** ppbs);

#endif // _DBAPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\dbapp.cpp ===
#include "priv.h"
#include "sccls.h"
#include "resource.h"
#include "mshtmhst.h"
#include "deskbar.h"
#include "bands.h"
#define WANT_CBANDSITE_CLASS
#include "bandsite.h"

#include <trayp.h>      // TM_*
#include <desktray.h>   // IDeskTray

#include "dbapp.h"

#include "mluisupp.h"

/*
 this virtual app implments DeskBars that you have on the desktop.
 it has the glue that combines CDeskBar with CBandSite and populates the 
 bands (as well as persistance and such)
 
 -Chee
 */

#define DM_INIT         0       
#define DM_PERSIST      0               // trace IPS::Load, ::Save, etc.
#define DM_MENU         0               // menu code
#define DM_DRAG         0               // drag&drop
#define DM_TRAY         0               // tray: marshal, side, etc.

#ifdef DEBUG
extern unsigned long DbStreamTell(IStream *pstm);
#else
#define DbStreamTell(pstm)      ((ULONG) 0)
#endif


#define SUPERCLASS CDeskBar

/* 
 Instead of just 4 Deskbars on the whole desktop, we now have 4 deskbars for
 each monitor, however, this brings problem whenever a monitor goes away, we 
 need to clean up the following datastructure.  
 - dli
 */

// FEATURE: (dli) maybe this should be moved into multimon.h
// however, people should not get into the habbit of depending on this. 
// and it's really not used anywhere else, so, keep it here for now. 
#define DSA_MONITORSGROW 1

typedef struct DeskBarsPerMonitor {
    HMONITOR        hMon; 
    IDeskBar*       Deskbars[4];
} DESKBARSPERMONITOR, *LPDESKBARSPERMONITOR;

HDSA g_hdsaDeskBars = NULL;

enum ips_e {
    IPS_FALSE,    // reserved, must be 0 (FALSE)
    IPS_LOAD,
    IPS_INITNEW
};

CASSERT(IPS_FALSE == 0);

CDeskBarApp::~CDeskBarApp()
{
    _LeaveSide();
    
    if (_pbs)
        _pbs->Release();
    
    if (_pcm)
        _pcm->Release();
    
}

LRESULT CDeskBarApp::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);

    if (!_hwnd) {
        return lres;                        // destroyed by superclass
    }

    if (_eMode == WBM_BFLOATING) {
        switch (uMsg) {
        case WM_NOTIFY:
        {
            //
            // override the hittest value to be HTCAPTION if we're docked browser based
            //
            NMHDR* pnm = (NMHDR*)lParam;
            
            if (pnm->code == NM_NCHITTEST && 
                pnm->hwndFrom == _hwndChild) {
                //
                // in the floating bug docked int he browser, we don't do
                // mdi child stuff, so we make the gripper work as the caption
                // 
                NMMOUSE* pnmm = (NMMOUSE*)pnm;
                if (pnmm->dwHitInfo == RBHT_CAPTION ||
                    pnmm->dwHitInfo == RBHT_GRABBER) 
                    lres = HTTRANSPARENT;
            }
        }
        break;
        
        case WM_NCHITTEST:
            // all "client" areas are captions in this mode
            if (lres == HTCLIENT)
                lres = HTCAPTION;
            break;
        
        case WM_SETCURSOR:
            DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
            return TRUE;
        }
    }
    
    return lres;
}

BOOL CDeskBarApp::_OnCloseBar(BOOL fConfirm)
{
    // if we are closing a bar with no bands in it, don't pop up the dialog
    if ((_pbs && (_pbs->EnumBands(-1,NULL)==0)) ||
        (!fConfirm || ConfirmRemoveBand(_hwnd, IDS_CONFIRMCLOSEBAR, TEXT(""))) )
        return SUPERCLASS::_OnCloseBar(FALSE);
    return FALSE;
}

// Gets the Deskbars on a specific monitor 
// DBPM -- DeskBars Per Monitor 
LPDESKBARSPERMONITOR GetDBPMWithMonitor(HMONITOR hMon, BOOL fCreate)
{
    int ihdsa;
    LPDESKBARSPERMONITOR pdbpm;

    if (!g_hdsaDeskBars) {
        if (fCreate)
            g_hdsaDeskBars = DSA_Create(SIZEOF(DESKBARSPERMONITOR), DSA_MONITORSGROW);
    }

    if (!g_hdsaDeskBars)
        return NULL;
    
    // If we find the DBPM with this HMONITOR, return it. 
    for (ihdsa = 0; ihdsa < DSA_GetItemCount(g_hdsaDeskBars); ihdsa++) {
        pdbpm = (LPDESKBARSPERMONITOR)DSA_GetItemPtr(g_hdsaDeskBars, ihdsa);
        if (pdbpm->hMon == hMon)
            return pdbpm;
    }

    if (fCreate) {
        DESKBARSPERMONITOR dbpm = {0};
        // This monitor is not setup, so set it, and set us the
        // the ownder of _uSide
        dbpm.hMon = hMon;
        ihdsa = DSA_AppendItem(g_hdsaDeskBars, &dbpm);
        pdbpm = (LPDESKBARSPERMONITOR)DSA_GetItemPtr(g_hdsaDeskBars, ihdsa);
        return pdbpm;
    }
    
    // When all else fails, return NULL
    return NULL;
}
    
void CDeskBarApp::_LeaveSide()
{
    if (ISABE_DOCK(_uSide) && !ISWBM_FLOAT(_eMode)) {
        // remove ourselves from the array list of where we were
        LPDESKBARSPERMONITOR pdbpm = GetDBPMWithMonitor(_hMon, FALSE);
        if (pdbpm && (pdbpm->Deskbars[_uSide] == this)) {
            ASSERT(pdbpm->hMon);
            ASSERT(pdbpm->hMon == _hMon);
            pdbpm->Deskbars[_uSide] = NULL;
        }
    }
}

//***
// NOTES
//  FEATURE: should we create/use IDeskTray::AppBarGetState?
UINT GetTraySide(HMONITOR * phMon)
{
    LRESULT lTmp;
    APPBARDATA abd;
    
    abd.cbSize = sizeof(APPBARDATA);
    abd.hWnd = GetTrayWindow();
    if (phMon)
        Tray_GetHMonitor(abd.hWnd, phMon);

    abd.uEdge = (UINT)-1;
    //lTmp = g_pdtray->AppBarGetTaskBarPos(&abd);
    lTmp = SHAppBarMessage(ABM_GETTASKBARPOS, &abd);
    ASSERT(lTmp);
    TraceMsg(DM_TRAY, "gts: ret=ABE_%d", abd.uEdge);
    return abd.uEdge;
}

//***
// ENTRY/EXIT
//  fNoMerge    is for the IPS::Load case
// NOTES
//  warning: be careful of reentrancy!  fNoMove is how we guard against it.
void CDeskBarApp::_SetModeSide(UINT eMode, UINT uSide, HMONITOR hMonNew, BOOL fNoMerge) 
{
    BOOL fNoMove;

    // make sure we don't merge etc. on NOOP moves.
    // we do such moves to force refresh (e.g. for autohide and IPS::Load);
    // also happens w/ drags which end up back where they started
    fNoMove = (eMode == _eMode && uSide == _uSide && hMonNew == _hMon);

    if (!fNoMove)
        _LeaveSide();
    
    // warning: this may call (e.g.) AppBarRegister, which causes a
    // resize, which calls back to us.  careful of reentrancy!!!
    // if we do reenter we end up w/ nt5:155043, where entry #1 has
    // fNoMove==0, then we get a recalc, entry #2 has fNoMove==1,
    // and we set our side array to us, then return back to entry
    // #1 which merges into itself!
    SUPERCLASS::_SetModeSide(eMode, uSide, hMonNew, fNoMerge);

    if (!fNoMove) {
        if (ISABE_DOCK(_uSide) && !ISWBM_FLOAT(_eMode)) {
            LPDESKBARSPERMONITOR pdbpm = GetDBPMWithMonitor(hMonNew, TRUE);
            HMONITOR hMonTray = NULL;
            if (pdbpm) {
                if (fNoMerge) {
                    if (!pdbpm->Deskbars[_uSide]) {
                        // 1st guy on an edge owns it
                        // if we don't do this, when we load persisted state on logon
                        // we end up w/ *no* edge owner (since fNoMerge), so we don't
                        // merge on subsequent moves.
                        goto Lsetowner;
                    }
                }
                else if (pdbpm->Deskbars[_uSide]) {
                    // if someone already there, try merging into them
#ifdef DEBUG
                    // alt+drag suppresses merge
                    // DEBUG only since don't track >1 per side, but useful
                    // for testing appbars and toolbars anyway
                    if (!(GetKeyState(VK_MENU) < 0))
#endif
                    {
                        extern IBandSite* _GetBandSite(IDeskBar * pdb);
                        IBandSite *pbs;
                        
                        pbs = _GetBandSite(pdbpm->Deskbars[_uSide]);
                        // nt5:215952: should 'never' have pbs==0 but somehow
                        // it does happen (during deskbar automation tests).
                        // call andyp or tjgreen if you hit this assert so
                        // we can figure out why.
                        if (TPTR(pbs)) {
                            _MergeSide(pbs);            // dst=pbs, src=this
                            pbs->Release();
                        }
                    }
                }
                else if ((GetTraySide(&hMonTray) == _uSide) && (hMonTray == _hMon) && !(GetKeyState(VK_SHIFT) < 0)) {
                    // ditto for tray (but need to marshal/unmarshal)
#ifdef DEBUG
                    // alt+drag suppresses merge
                    // DEBUG only since don't track >1 per side, but useful
                    // for testing appbars and toolbars anyway
                    if (!(GetKeyState(VK_MENU) < 0))
#endif
                    {
                        _MergeSide((IBandSite *)1);     // dst=pbs, src=this
                    }
                }
                else {
                    // o.w. nobody there yet, set ourselves as owner
                    ASSERT(pdbpm->hMon);
                    ASSERT(pdbpm->hMon == hMonNew);
Lsetowner:
                    TraceMsg(DM_TRAY, "cdba._sms: 1st side owner this=0x%x", this);
                    pdbpm->Deskbars[_uSide] = this;
                }
            }
        }
    }
}

void CDeskBarApp::_UpdateCaptionTitle()
{
    if (ISWBM_FLOAT(_eMode)) {
        int iCount = (int)_pbs->EnumBands((UINT)-1, NULL);
        if (iCount == 1) {
            DWORD dwBandID;
            if (SUCCEEDED(_pbs->EnumBands(0, &dwBandID))) {
                WCHAR wszTitle[80];
                if (SUCCEEDED(_pbs->QueryBand(dwBandID, NULL, NULL, wszTitle, ARRAYSIZE(wszTitle)))) {
                    SetWindowText(_hwnd, wszTitle);
                }
            }
        }
        else {
            TCHAR szTitle[80];
            szTitle[0] = 0;
            MLLoadString(IDS_WEBBARSTITLE,szTitle,ARRAYSIZE(szTitle));
            SetWindowText(_hwnd, szTitle);
        }
    }
}


void CDeskBarApp::_NotifyModeChange(DWORD dwMode)
{
    SUPERCLASS::_NotifyModeChange(dwMode);
    _UpdateCaptionTitle();
}

//***   GetTrayIface -- get iface from tray (w/ marshal/unmarshal)
//
HRESULT GetTrayIface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_FAIL;
    HWND hwndTray;
    IStream *pstm;

    TraceMsg(DM_TRAY, "gtif: marshal!");

    *ppvObj = NULL;

    hwndTray = GetTrayWindow();
    if (hwndTray) {
        pstm = (IStream *) SendMessage(hwndTray, TM_MARSHALBS, (WPARAM)(GUID *)&riid, 0);

        if (EVAL(pstm)) {
            // paired w/ matching Marshal in explorer (TM_MARSHALBS)
            hr = CoGetInterfaceAndReleaseStream(pstm, riid, ppvObj);
            ASSERT(SUCCEEDED(hr));
        }
    }

    return hr;
}

//***   _MergeSide -- merge two deskbars into one
// ENTRY/EXIT
//  this    [INOUT] destination deskbar (ptr:1 if tray)
//  pdbSrc  [INOUT] source deskbar; deleted if all bands moved successfully
//  ret     S_OK if all bands moved; S_FALSE if some moved; E_* o.w.
HRESULT CDeskBarApp::_MergeSide(IBandSite *pbsDst)
{
    extern HRESULT _MergeBS(IDropTarget *pdtDst, IBandSite *pbsSrc);
    HRESULT hr;
    IDropTarget *pdtDst;

    AddRef();   // make sure we don't disappear partway thru operation

    if (pbsDst == (IBandSite *)1) {
        // get (marshal'ed) iface from tray
        hr = GetTrayIface(IID_IDropTarget, (void **)&pdtDst);
        ASSERT(SUCCEEDED(hr));
    }
    else {
        // don't merge into ourself!
        ASSERT(pbsDst != _pbs);
        ASSERT(!SHIsSameObject(pbsDst, SAFECAST(_pbs, IBandSite*)));

        hr = pbsDst->QueryInterface(IID_IDropTarget, (void **)&pdtDst);
        ASSERT(SUCCEEDED(hr));
    }
    ASSERT(SUCCEEDED(hr) || pdtDst == NULL);

    if (pdtDst) {
        hr = _MergeBS(pdtDst, _pbs);
        pdtDst->Release();
    }

    Release();

    return hr;
}

void CDeskBarApp::_CreateBandSiteMenu()
{
    CoCreateInstance(CLSID_BandSiteMenu, NULL,CLSCTX_INPROC_SERVER, 
                     IID_PPV_ARG(IContextMenu3, &_pcm));
    if (_pcm)
    {
        IShellService* pss;
        
        _pcm->QueryInterface(IID_IShellService, (LPVOID*)&pss);
        if (pss)
        {
            pss->SetOwner((IBandSite*)_pbs);
            pss->Release();
        }
    }
}

HRESULT CDeskBarApp::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IContextMenu) ||
        IsEqualIID(riid, IID_IContextMenu2) ||
        IsEqualIID(riid, IID_IContextMenu3))
    {
        if (!_pcm)
        {
            _CreateBandSiteMenu();
        }
        
        // only return out our pointer if we got the one we're going
        // to delegate to
        if (_pcm)
        {
            *ppvObj = SAFECAST(this, IContextMenu3*);
            AddRef();
            return S_OK;
        }
    }
    return SUPERCLASS::QueryInterface(riid, ppvObj);
}

HRESULT CDeskBarApp::QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService,SID_SBandSite)) {
        return QueryInterface(riid, ppvObj);
    }
    
    return SUPERCLASS::QueryService(guidService, riid, ppvObj);
}


HRESULT CDeskBarApp::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    int idCmd = -1;

    if (!HIWORD(pici->lpVerb))
        idCmd = LOWORD(pici->lpVerb);

    if (idCmd >= _idCmdDeskBarFirst)
    {
        _AppBarOnCommand(idCmd - _idCmdDeskBarFirst);
        return S_OK;
    }
    
    return _pcm->InvokeCommand(pici);
    
}

HRESULT CDeskBarApp::GetCommandString(  UINT_PTR    idCmd,
                                        UINT        uType,
                                        UINT       *pwReserved,
                                        LPSTR       pszName,
                                        UINT        cchMax)
{
    return _pcm->GetCommandString(idCmd, uType, pwReserved, pszName, cchMax);
}

HRESULT CDeskBarApp::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return _pcm->HandleMenuMsg(uMsg, wParam, lParam);
}

HRESULT CDeskBarApp::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    return _pcm->HandleMenuMsg2(uMsg, wParam, lParam, plres);
}

HRESULT CDeskBarApp::QueryContextMenu(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags)
{
    HRESULT hr = _pcm->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
    if (SUCCEEDED(hr))
    {
        int i = hr;
        HMENU hmenuSrc;

        _idCmdDeskBarFirst = i;
        hmenuSrc = _GetContextMenu();

        // off-by-1 and by idCmdFirst+i, i think...
        i += Shell_MergeMenus(hmenu, hmenuSrc, (UINT)-1, idCmdFirst + i, idCmdLast, MM_ADDSEPARATOR) - (idCmdFirst + i);
        DestroyMenu(hmenuSrc);

        return ResultFromShort(i);   // potentially off-by-1, but who cares...
    }
    return hr;
}


//***
// NOTES
//  FEATURE: nuke this, fold it into CDeskBarApp_CreateInstance
HRESULT DeskBarApp_Create(IUnknown** ppunk)
{
    HRESULT hres;

    *ppunk = NULL;
    
    CDeskBarApp *pdb = new CDeskBarApp();
    if (!pdb)
        return E_OUTOFMEMORY;
    
    CBandSite *pcbs = new CBandSite(NULL);
    if (pcbs)
    {
        IDeskBarClient *pdbc = SAFECAST(pcbs, IDeskBarClient*);
        hres = pdb->SetClient(pdbc);
        if (SUCCEEDED(hres))
        {
            pdb->_pbs = pcbs;
            pcbs->AddRef();
            *ppunk = SAFECAST(pdb, IDeskBar*);
        }
    
        pdbc->Release();
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    if (FAILED(hres))
        pdb->Release();
        
    return hres;
}


STDAPI CDeskBarApp_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hres;
    IUnknown *punk;

    // aggregation checking is handled in class factory

    hres = DeskBarApp_Create(&punk);
    if (SUCCEEDED(hres)) {
        *ppunk = SAFECAST(punk, IDockingWindow*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//*** CDeskBarApp::IInputObject*::* {
//

HRESULT CDeskBarApp::TranslateAcceleratorIO(LPMSG lpMsg)
{
    if (lpMsg->message == WM_SYSKEYDOWN) {
        if (lpMsg->wParam == VK_F4) {
            // ie4:28819: need to trap VK_F4 here, o.w. CBaseBrowser::TA
            // does a last-chance (winsdk)::TA (to IDM_CLOSE) and doing a
            // shutdown!
            PostMessage(_hwnd, WM_CLOSE, 0, 0);
            return S_OK;
        }
    }

    return SUPERCLASS::TranslateAcceleratorIO(lpMsg);
}

// }

//*** CDeskBarApp::IPersistStream*::* {
//

HRESULT CDeskBarApp::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_DeskBarApp;
    return S_OK;
}

HRESULT CDeskBarApp::IsDirty(void)
{
    return S_FALSE; // Never be dirty
}


//
// Persisted CDeskBarApp
//
#define STC_VERSION     1

struct SThisClass
{
    DWORD   cbSize;
    DWORD   cbVersion;
};

HRESULT CDeskBarApp::Load(IStream *pstm)
{
    SThisClass stc;
    ULONG cbRead;
    HRESULT hres;

    TraceMsg(DM_PERSIST, "cdba.l enter(this=%x pstm=%x) tell()=%x", this, pstm, DbStreamTell(pstm));

    ASSERT(!_eInitLoaded);
    _eInitLoaded = IPS_LOAD;

    hres = pstm->Read(&stc, SIZEOF(stc), &cbRead);
#ifdef DEBUG
    // just in case we toast ourselves (offscreen or something)...
    static BOOL fNoPersist = FALSE;
    if (fNoPersist)
        hres = E_FAIL;
#endif
    if (hres==S_OK && cbRead==SIZEOF(stc)) {
        if (stc.cbSize==SIZEOF(SThisClass) && stc.cbVersion==STC_VERSION) {
            _eInitLoaded = IPS_LOAD;    // FEATURE: what if OLFS of bands fails?

            hres = SUPERCLASS::Load(pstm);

            TraceMsg(DM_INIT, "cdba::Load succeeded");
        } else {
            TraceMsg(DM_ERROR, "cdba::Load failed stc.cbSize==SIZEOF(SThisClass) && stc.cbVersion==SWB_VERSION");
            hres = E_FAIL;
        }
    } else {
        TraceMsg(DM_ERROR, "cdba::Load failed (hres==S_OK && cbRead==SIZEOF(_adEdge)");
        hres = E_FAIL;
    }
    TraceMsg(DM_PERSIST, "cdba.l leave tell()=%x", DbStreamTell(pstm));
    
    // after loading this, if we find that we're supposed to be browser docked,
    // make our bandsite always have a gripper
    if (_eMode == WBM_BFLOATING)
    {
        BANDSITEINFO bsinfo;

        bsinfo.dwMask = BSIM_STYLE;
        bsinfo.dwStyle = BSIS_ALWAYSGRIPPER;

        _pbs->SetBandSiteInfo(&bsinfo);
    }
    return hres;
}

HRESULT CDeskBarApp::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hres;
    SThisClass stc;

    TraceMsg(DM_PERSIST, "cdba.s enter(this=%x pstm=%x) tell()=%x", this, pstm, DbStreamTell(pstm));
    stc.cbSize = SIZEOF(SThisClass);
    stc.cbVersion = STC_VERSION;

    hres = pstm->Write(&stc, SIZEOF(stc), NULL);
    if (SUCCEEDED(hres)) {
        SUPERCLASS::Save(pstm, fClearDirty);
    }
    
    TraceMsg(DM_PERSIST, "cdba.s leave tell()=%x", DbStreamTell(pstm));
    return hres;
}

HRESULT CDeskBarApp::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ULARGE_INTEGER cbMax = { SIZEOF(SThisClass), 0 };
    *pcbSize = cbMax;
    return S_OK;
}

HRESULT CDeskBarApp::InitNew(void)
{
    HRESULT hres;

    ASSERT(!_eInitLoaded);
    _eInitLoaded = IPS_INITNEW;
    TraceMsg(DM_INIT, "CDeskBarApp::InitNew called");

    hres = SUPERCLASS::InitNew();
    if (FAILED(hres))
        return hres;

    // can't call _InitPos4 until set site in SetSite

    return hres;
}


HRESULT CDeskBarApp::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) {
        /*NOTHING*/
    } 
    else if (IsEqualGUID(CGID_DeskBarClient, *pguidCmdGroup)) {
        switch (nCmdID) {
        case DBCID_EMPTY:
            if (_pbs) {
                // if we have no bands left, close
                PostMessage(_hwnd, WM_CLOSE, 0, 0);
            }
            return S_OK;
        }
    }
    else if (IsEqualIID(*pguidCmdGroup, CGID_DeskBand)) {
        switch (nCmdID) {
        case DBID_BANDINFOCHANGED:
            _UpdateCaptionTitle();
            return S_OK;
        }
    }
    else if (IsEqualIID(*pguidCmdGroup, CGID_BandSite)) {
        switch (nCmdID) {
        case BSID_BANDADDED:
        case BSID_BANDREMOVED:
            _UpdateCaptionTitle();
            return S_OK;
        }
    }

    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

HRESULT CDeskBarApp::Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog)
{
    HRESULT hres;

    ASSERT(!_eInitLoaded);
    _eInitLoaded = IPS_LOAD;
    TraceMsg(DM_INIT, "CDeskBarApp::Load(bag) called");

    hres = SUPERCLASS::Load(pPropBag, pErrorLog);
    
    // after loading this, if we find that we're supposed to be browser docked,
    // make our bandsite always have a gripper
    if (_eMode == WBM_BFLOATING)
    {
        BANDSITEINFO bsinfo;

        bsinfo.dwMask = BSIM_STYLE;
        bsinfo.dwStyle = BSIS_ALWAYSGRIPPER;

        _pbs->SetBandSiteInfo(&bsinfo);
    }
    return hres;
}

IBandSite * _GetBandSite(IDeskBar * pdb)
{
    IBandSite* pbs = NULL;
    
    if (pdb) {
        IUnknown* punkClient;
        
        pdb->GetClient(&punkClient);
        if (punkClient) {
            punkClient->QueryInterface(IID_IBandSite, (LPVOID*)&pbs);
            punkClient->Release();
        }
    }
    
    return pbs;
}

        
IBandSite* DeskBarApp_GetBandSiteOnEdge(UINT uEdge)
{
    // APPCOMPAT: (dli) if no HMONITOR is passed in, use the primary monitor
    // should make sure that there is always a valid HMONITOR passed in
    HMONITOR hMon = GetPrimaryMonitor();
    // --------------------------------------------------------------

    LPDESKBARSPERMONITOR pdbpm = GetDBPMWithMonitor(hMon, FALSE);
    if (pdbpm) {
        ASSERT(pdbpm->hMon);
        ASSERT(pdbpm->hMon == hMon);
        return _GetBandSite(pdbpm->Deskbars[uEdge]);
    }
    return NULL;
}



IBandSite* DeskBarApp_GetBandSiteAtPoint(LPPOINT ppt)
{
    HWND hwnd = WindowFromPoint(*ppt);
    HMONITOR hMon = MonitorFromPoint(*ppt, MONITOR_DEFAULTTONULL);
    if (hwnd && hMon) {
        LPDESKBARSPERMONITOR pdbpm = GetDBPMWithMonitor(hMon, FALSE);
        if (pdbpm) {
            ASSERT(pdbpm->hMon);
            ASSERT(pdbpm->hMon == hMon);
            int i;
            for (i = 0; i < 4; i++) {
                if (pdbpm->Deskbars[i]) {
                    HWND hwndDeskbar;
                    pdbpm->Deskbars[i]->GetWindow(&hwndDeskbar);
            
                    if (hwndDeskbar == hwnd) {
                        return _GetBandSite(pdbpm->Deskbars[i]); 
                    }
                }
            }
        }
    }
    return NULL;
}

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\commonsb.h ===
#ifndef COMMONSB_INC_
#define COMMONSB_INC_

#include "caggunk.h"
#include "fldset.h"

#define ITB_ITBAR       0               // index to the Internet Toolbar


typedef struct _ZONESICONNAMECACHE  // Cache for zones icons and display names
{
    HICON hiconZones;
    WCHAR szZonesName[MAX_ZONE_DESCRIPTION];
    WCHAR szIconPath[MAX_ZONE_PATH];  // we'll initially load the path, then cache the icon on demand
} ZONEICONNAMECACHE, *PZONEICONNAMECACHE;


class CCommonBrowser : 
    public CAggregatedUnknown
   ,public IShellBrowser
   ,public IBrowserService3
   ,public IServiceProvider
   ,public IOleCommandTarget
   ,public IDockingWindowSite
   ,public IDockingWindowFrame
   ,public IInputObjectSite
   ,public IDropTarget
   ,public IShellBrowserService
{
public:

    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) {return CAggregatedUnknown::QueryInterface(riid, ppvObj);};
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CAggregatedUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { return CAggregatedUnknown::Release();};


    // *** IBrowserService specific methods ***
    virtual STDMETHODIMP GetParentSite(  IOleInPlaceSite** ppipsite) ;
    virtual STDMETHODIMP SetTitle( IShellView* psv, LPCWSTR pszName) ;
    virtual STDMETHODIMP GetTitle( IShellView* psv, LPWSTR pszName, DWORD cchName) ;
    virtual STDMETHODIMP GetOleObject(  IOleObject** ppobjv) ;

    // think about this one.. I'm not sure we want to expose this -- Chee
    // Yep soon we should have interface instead.
    // My impression is that we won't document this whole interface???
    // I am sure this has shipped at least once, looks like it is here to stay - justmann 2000-01-27
    virtual STDMETHODIMP GetTravelLog( ITravelLog** pptl) ;

    virtual STDMETHODIMP ShowControlWindow( UINT id, BOOL fShow) ;
    virtual STDMETHODIMP IsControlWindowShown( UINT id, BOOL *pfShown) ;
    virtual STDMETHODIMP IEGetDisplayName( LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags) ;
    virtual STDMETHODIMP IEParseDisplayName( UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut) ;
    virtual STDMETHODIMP DisplayParseError( HRESULT hres, LPCWSTR pwszPath) ;
    virtual STDMETHODIMP NavigateToPidl( LPCITEMIDLIST pidl, DWORD grfHLNF) ;

    virtual STDMETHODIMP SetNavigateState( BNSTATE bnstate) ;
    virtual STDMETHODIMP GetNavigateState ( BNSTATE *pbnstate) ;

    virtual STDMETHODIMP NotifyRedirect (  IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse) ;
    virtual STDMETHODIMP UpdateWindowList () ;

    virtual STDMETHODIMP UpdateBackForwardState () ;

    virtual STDMETHODIMP SetFlags( DWORD dwFlags, DWORD dwFlagMask) ;
    virtual STDMETHODIMP GetFlags( DWORD *pdwFlags) ;

    // Tells if it can navigate now or not.
    virtual STDMETHODIMP CanNavigateNow () ;

    virtual STDMETHODIMP GetPidl ( LPITEMIDLIST *ppidl) ;
    virtual STDMETHODIMP SetReferrer ( LPITEMIDLIST pidl) ;
    virtual STDMETHODIMP_(DWORD) GetBrowserIndex() ;
    virtual STDMETHODIMP GetBrowserByIndex( DWORD dwID, IUnknown **ppunk) ;
    virtual STDMETHODIMP GetHistoryObject( IOleObject **ppole, IStream **pstm, IBindCtx **ppbc) ;
    virtual STDMETHODIMP SetHistoryObject( IOleObject *pole, BOOL fIsLocalAnchor) ;

    virtual STDMETHODIMP CacheOLEServer( IOleObject *pole) ;

    virtual STDMETHODIMP GetSetCodePage( VARIANT* pvarIn, VARIANT* pvarOut) ;
    virtual STDMETHODIMP OnHttpEquiv( IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut) ;
    virtual STDMETHODIMP GetPalette(  HPALETTE * hpal ) ;
    virtual STDMETHODIMP RegisterWindow( BOOL fUnregister, int swc) ;
    virtual STDMETHODIMP_(LRESULT) WndProcBS( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) ;
    virtual STDMETHODIMP OnSize(WPARAM wParam);
    virtual STDMETHODIMP OnCreate(LPCREATESTRUCT pcs);
    virtual STDMETHODIMP_(LRESULT) OnCommand(WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP OnDestroy();
    virtual STDMETHODIMP_(LRESULT) OnNotify(NMHDR * pnm);
    virtual STDMETHODIMP OnSetFocus();
    virtual STDMETHODIMP OnFrameWindowActivateBS(BOOL fActive);
    virtual STDMETHODIMP ReleaseShellView( ) ;
    virtual STDMETHODIMP ActivatePendingView( ) ;
    virtual STDMETHODIMP CreateViewWindow(IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd);
    virtual STDMETHODIMP GetBaseBrowserData( LPCBASEBROWSERDATA* ppbd );
    virtual STDMETHODIMP_(LPBASEBROWSERDATA) PutBaseBrowserData();
    virtual STDMETHODIMP SetTopBrowser();
    virtual STDMETHODIMP UpdateSecureLockIcon(int eSecureLock);
    virtual STDMETHODIMP Offline(int iCmd);
    virtual STDMETHODIMP InitializeDownloadManager();
    virtual STDMETHODIMP InitializeTransitionSite();
    virtual STDMETHODIMP GetFolderSetData(struct tagFolderSetData* pfsd) { *pfsd = _fsd; return S_OK; };
    virtual STDMETHODIMP CreateBrowserPropSheetExt(REFIID, LPVOID *);
    virtual STDMETHODIMP SetActivateState(UINT uActivate);
    virtual STDMETHODIMP AllowViewResize(BOOL f);
    virtual STDMETHODIMP _Initialize(HWND hwnd, IUnknown *pauto);
    
    // Temporarily in interface, needs to be brought local
    virtual STDMETHODIMP_(UINT) _get_itbLastFocus() {return _itbLastFocus; };
    virtual STDMETHODIMP _put_itbLastFocus(UINT itbLastFocus) {_itbLastFocus = itbLastFocus; return S_OK;};
    virtual STDMETHODIMP _UIActivateView(UINT uState) ;

    // BEGIN REVIEW:  review names and need of each.  
    // 
    // this first set could be basebrowser only members.  no one overrides
    virtual STDMETHODIMP _CancelPendingNavigationAsync() ;

    virtual STDMETHODIMP _MaySaveChanges() ; 
    virtual STDMETHODIMP _PauseOrResumeView( BOOL fPaused) ;
    virtual STDMETHODIMP _DisableModeless() ;
    
    // rethink these... are all of these necessary?
    virtual STDMETHODIMP _NavigateToPidl( LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags);
    virtual STDMETHODIMP _TryShell2Rename( IShellView* psv, LPCITEMIDLIST pidlNew);
    virtual STDMETHODIMP _SwitchActivationNow( );
    virtual STDMETHODIMP _CancelPendingView() ;

    
    virtual STDMETHODIMP v_MayTranslateAccelerator( MSG* pmsg);
    virtual STDMETHODIMP _CycleFocus( LPMSG lpMsg) ;
    virtual STDMETHODIMP v_MayGetNextToolbarFocus(LPMSG lpMsg, UINT itbNext, int citb, LPTOOLBARITEM * pptbi, HWND * phwnd);
    virtual STDMETHODIMP _SetFocus(LPTOOLBARITEM ptbi, HWND hwnd, LPMSG lpMsg);
    virtual STDMETHODIMP_(BOOL) _HasToolbarFocus(void) ;
    virtual STDMETHODIMP _FixToolbarFocus(void) ;

    // this belongs with the toolbar set.
    virtual STDMETHODIMP _ExecChildren(IUnknown *punkBar, BOOL fBroadcast,
        const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    virtual STDMETHODIMP _SendChildren(HWND hwndBar, BOOL fBroadcast,
        UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP _GetViewBorderRect(RECT* prc);

    virtual STDMETHODIMP _UpdateViewRectSize();
    virtual STDMETHODIMP _ResizeNextBorder(UINT itb);
    virtual STDMETHODIMP _ResizeView();

    virtual STDMETHODIMP _GetBorderDWHelper(IUnknown* punkSrc, LPRECT prcBorder, BOOL bUseHmonitor);

    virtual STDMETHODIMP _GetEffectiveClientArea(LPRECT prcBorder, HMONITOR hmon);

    virtual STDMETHODIMP _PositionViewWindow(HWND hwnd, LPRECT prc);

    //END REVIEW:

    // for CShellBrowser split
    virtual STDMETHODIMP SetAsDefFolderSettings();
    virtual STDMETHODIMP GetViewRect(RECT* prc);
    virtual STDMETHODIMP GetViewWindow(HWND * phwndView);
    virtual STDMETHODIMP InitializeTravelLog(ITravelLog* ptl, DWORD dw);

    // Desktop needs to override these:
    virtual STDMETHODIMP_(IStream*) v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName);
    
    // Desktop needs access to these:
    virtual STDMETHODIMP_(LRESULT) ForwardViewMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP SetAcceleratorMenu(HACCEL hacc);

    // Shell browser overrides this.
    virtual STDMETHODIMP v_CheckZoneCrossing(LPCITEMIDLIST pidl) {return S_OK;};

    // *** IDropTarget (delegate to basesb) ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IOleWindow
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);
    
    // IShellBrowser (same as IOleInPlaceFrame)
    virtual STDMETHODIMP InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    virtual STDMETHODIMP SetMenuSB(HMENU hmenuShared, HOLEMENU holemenu, HWND hwnd);
    virtual STDMETHODIMP RemoveMenusSB(HMENU hmenuShared);
    virtual STDMETHODIMP SetStatusTextSB(LPCOLESTR lpszStatusText);
    virtual STDMETHODIMP EnableModelessSB(BOOL fEnable);
    virtual STDMETHODIMP TranslateAcceleratorSB(LPMSG lpmsg, WORD wID);
    virtual STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);
    virtual STDMETHODIMP GetViewStateStream(DWORD grfMode, LPSTREAM  *ppStrm);
    virtual STDMETHODIMP GetControlWindow(UINT id, HWND * lphwnd);
    virtual STDMETHODIMP SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    virtual STDMETHODIMP QueryActiveShellView(struct IShellView ** ppshv);
    virtual STDMETHODIMP OnViewWindowActive(struct IShellView * ppshv);
    virtual STDMETHODIMP SetToolbarItems(LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags);

    // IServiceProvider
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IDockingWindowFrame (also IOleWindow(?))
    virtual STDMETHODIMP AddToolbar(IUnknown* punkSrc, LPCWSTR pwszItem, DWORD dwReserved);
    virtual STDMETHODIMP RemoveToolbar(IUnknown* punkSrc, DWORD dwFlags);
    virtual STDMETHODIMP FindToolbar(LPCWSTR pwszItem, REFIID riid, LPVOID* ppvObj);

    // IDockingWindowSite (also IOleWindow(?))
    virtual STDMETHODIMP GetBorderDW(IUnknown* punkSrc, LPRECT prcBorder);
    virtual STDMETHODIMP RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pbw);
    virtual STDMETHODIMP SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pbw);

    // IInputObjectSite
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);

    //IShellBrowserService
    virtual STDMETHODIMP GetPropertyBag(DWORD dwFlags, REFIID riid, void** ppv) {return E_FAIL;}

    // This is the QueryInterface the aggregator implements
    virtual HRESULT v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj);

protected:
    CCommonBrowser(IUnknown* punkAgg);
    virtual ~CCommonBrowser();
    
    friend HRESULT CCommonBrowser_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

    //
    // Notes: 
    //  The values in the _arcBorderTools array indicates the size of
    // the border space taken by each toolbar on each side of the
    // containing rectangle.
    //
    virtual STDMETHODIMP_(LPTOOLBARITEM) _GetToolbarItem(int itb);
    virtual STDMETHODIMP_(int) _GetToolbarCount() { return FDSA_GetItemCount(&_fdsaTBar); }
    virtual STDMETHODIMP_(int) _AllocToolbarItem();
    void        _ReleaseToolbarItem(int itb, BOOL fClose);
    
    // Helper function for toolbar negotiation
    virtual STDMETHODIMP_(UINT) _FindTBar(IUnknown* punkSrc);
    virtual STDMETHODIMP _OnFocusChange(UINT itb);
    virtual STDMETHODIMP _CloseAndReleaseToolbars(BOOL fClose = TRUE);

    virtual STDMETHODIMP v_ShowHideChildWindows(BOOL fChildOnly);
    virtual STDMETHODIMP ShowToolbar(IUnknown* punkSrc, BOOL fShow) ;
    virtual STDMETHODIMP _SaveToolbars(IStream* pstm);
    virtual STDMETHODIMP _LoadToolbars(IStream* pstm);

    BOOL _TBWindowHasFocus(UINT itb);
    BOOL _ShouldTranslateAccelerator(MSG* pmsg);

    DWORD _CacheZonesIconsAndNames(BOOL fRefresh);
    BOOL _GetCachedZoneIconAndName(DWORD lZone, HICON *pIcon, LPTSTR pszName, DWORD cch);

    IInternetZoneManager * _pizm;

    virtual STDMETHODIMP _ResizeNextBorderHelper(UINT itb, BOOL bUseHmonitor);

    
    virtual BOOL _CanHandleAcceleratorNow(void) {return TRUE;}
    
    FDSA            _fdsaTBar;
    TOOLBARITEM     _aTBar[ITB_CSTATIC];
    UINT            _itbLastFocus;   // last one called OnFocusChange (can be -1)

    HRESULT _FindActiveTarget(REFIID riid, LPVOID* ppvOut);

    IUnknown* _punkInner;

    // implementations in basesb
    IBrowserService2* _pbsInner;
    IBrowserService3* _pbsInner3;
    IShellBrowser* _psbInner;
    IDropTarget* _pdtInner;             // TODO: non-cached?
    IServiceProvider* _pspInner;
    IOleCommandTarget* _pctInner;
    IInputObjectSite* _piosInner;

    // desktop overrides some of these methods
    IBrowserService2* _pbsOuter;
    IBrowserService2* _pbsOuter3;
    
    LPCBASEBROWSERDATA _pbbd;

    HACCEL _hacc;
    
    // for view set information
    struct tagFolderSetData _fsd;
    
    virtual HRESULT SetInner(IUnknown* punk);
};


HRESULT     _ConvertPathToPidl(IBrowserService2* pbs, HWND hwnd, LPCTSTR pszPath, LPITEMIDLIST * ppidl);

#endif // COMMONSB_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\debdump.cpp ===
#include "priv.h"
#include "resource.h"   // IDM_AB_* fir this!
#include "shbrows2.h"
#include "browbar.h"
#include "menuband.h"
#include "mnbase.h"
#include "menusite.h"
#include "menubar.h"
#include "browmenu.h"
#include "mnstatic.h"
#include "mnfolder.h"


#ifdef DEBUG // {

#define DM_FIXME    0       // trace/break when hit unknown guy

struct DBClassInfo {
    int     cbSize;
    TCHAR * pszName;
};

//
// EXTERNALOBJECTS is a macro which simply expands to X(C,0) X(D,1)
// X(E, 2)...
// where C, D, E, ... are classes whose sizes are defined externally.
//

#define EXTERNALOBJECTS 
//    X(CSDWindows, 0)  \
//    X(CDesktopBrowser, 1)  \

#define TABENT(c)   { SIZEOF(c), TEXT(#c) }
#define X(c, n)  { 0, TEXT(#c) },
struct DBClassInfo DBClassInfoTab[] =
{
    // REARCHITECT: tons of table entries missing
    // maybe drive off same file as debug extensions dumpers?
    TABENT(CSHELLBROWSER),  // 0
    TABENT(CBrowserBar),    // 1
    TABENT(CMenuBand),
    TABENT(CMenuDeskBar),
    TABENT(CMenuSite),
    TABENT(CFavoritesCallback),
    TABENT(CMenuSFToolbar),
    TABENT(CMenuStaticToolbar),
    TABENT(CMenuData),

    #define NUM_INTERNAL_OBJECTS 11

    EXTERNALOBJECTS // 3...
    { 0 },
};
#undef  TABENT
#undef  X

#define X(c, n) extern "C" extern const int SIZEOF_##c;
EXTERNALOBJECTS
#undef X

//***   DBGetClassSymbolic -- map size to class name (guess)
// NOTES
//  we just take the 1st hit, so if there are multiple classes w/ the
//  same size you get the wrong answer.  if that turns out to be a pblm
//  we can add special-case heuristics for the relevant classes.
//
//  FEATURE: TODO: should use a generic DWORD value/data pair lookup
//  helper func.
//

TCHAR *DBGetClassSymbolic(int cbSize)
{
    struct DBClassInfo *p;

#define X(c, n) \
    DBClassInfoTab[NUM_INTERNAL_OBJECTS+n].cbSize = SIZEOF_##c;
    EXTERNALOBJECTS
#undef X

    for (p = DBClassInfoTab; p->cbSize != 0; p++) {
        if (p->cbSize == cbSize)
            return p->pszName;
    }
    if (DM_FIXME) {
        TraceMsg(DM_FIXME, "DBgcs: cbSize=%d  no entry", cbSize);
        ASSERT(0);
    }
    return NULL;
}

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\debug.c ===
//
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"
//#include <windows.h>
//#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "browseui"
#define SZ_MODULE           "BROWSEUI"
#define DECLARE_DEBUG
#include <debug.h>

// Include the standard helper functions to dump common ADTs
#include "..\inc\dump.c"


#ifdef DEBUG

void DumpMsg(LPCTSTR pszLabel, MSG * pmsg)
{
    ASSERT(IS_VALID_STRING_PTR(pszLabel, -1));
    ASSERT(pmsg);

    switch (pmsg->message)
    {
    case WM_LBUTTONDOWN:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_LBUTTONDOWN hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        break;

    case WM_LBUTTONUP:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_LBUTTONUP   hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        break;

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYUP:
        BLOCK
        {
            LPTSTR pcsz = TEXT("(unknown)");
            switch (pmsg->message)
            {
                STRING_CASE(WM_KEYDOWN);
                STRING_CASE(WM_SYSKEYDOWN);
                STRING_CASE(WM_KEYUP);
                STRING_CASE(WM_SYSKEYUP);
            }

            TraceMsg(TF_ALWAYS, "%s: msg = %s     hwnd = %#08lx",
                     pszLabel, pcsz, pmsg->hwnd);
            TraceMsg(TF_ALWAYS, "            vk = %#04lx  count = %u  flags = %#04lx",
                     pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        }
        break;

    case WM_CHAR:
    case WM_SYSCHAR:
        BLOCK
        {
            LPTSTR pcsz = TEXT("(unknown)");
            switch (pmsg->message)
            {
                STRING_CASE(WM_CHAR);
                STRING_CASE(WM_SYSCHAR);
            }

            TraceMsg(TF_ALWAYS, "%s: msg = %s     hwnd = %#08lx",
                     pszLabel, pcsz, pmsg->hwnd);
            TraceMsg(TF_ALWAYS, "            char = '%c'  count = %u  flags = %#04lx",
                     pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        }
        break;

    case WM_MOUSEMOVE:
#if 0
        TraceMsg(TF_ALWAYS, "%s: msg = WM_MOUSEMOVE hwnd = %#08lx  x=%d  y=%d",
                 pszLabel, pmsg->hwnd, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
#endif
        break;

    case WM_TIMER:
#if 0
        TraceMsg(TF_ALWAYS, "%s: msg = WM_TIMER       hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              id = %#08lx",
                 pmsg->wParam);
#endif
        break;

    case WM_MENUSELECT:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_MENUSELECT  hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              uItem = %#04lx  flags = %#04lx  hmenu = %#08lx",
                 GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_FLAGS(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam));
        break;

    default:
        if (WM_USER > pmsg->message)
        {
            TraceMsg(TF_ALWAYS, "%s: msg = %#04lx    hwnd=%#04lx wP=%#08lx lP=%#08lx",
                     pszLabel, pmsg->message, pmsg->hwnd, pmsg->wParam, pmsg->lParam);
        }
        break;
    }
}    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\desktop.h ===
/* desktop.cpp */

#include <desktopp.h>
#include "hnfblock.h"

#define PROGMAN             TEXT("Program Manager")
#define DESKTOPCLASS        TEXT(STR_DESKTOPCLASS)
#define DESKTOPPROXYCLASS   TEXT("Proxy Desktop")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\deskbar.h ===
// coming soon: new deskbar (old deskbar moved to browbar base class)
#ifndef DESKBAR_H_
#define DESKBAR_H_

#include "dockbar.h"

#ifndef NOCDESKBAR

class CDeskBar : public CDockingBar
               , public IRestrict
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void)   { return CDockingBar::AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void)  { return CDockingBar::Release(); }
    virtual STDMETHODIMP         QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IPersistStreamInit ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IRestrict ***
    virtual STDMETHODIMP IsRestricted(const GUID * pguidID, DWORD dwRestrictAction, VARIANT * pvarArgs, DWORD * pdwRestrictionResult);
    
    CDeskBar();

protected:
    BITBOOL _fRestrictionsInited :1;        // Have we read in the restrictions?
    BITBOOL _fRestrictDDClose :1;           // Restrict: Add, Close, Drag & Drop
    BITBOOL _fRestrictMove :1;              // Restrict: Move
};

#endif

class CDeskBarPropertyBag : public CDockingBarPropertyBag
{
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\deskbar.cpp ===
// coming soon: new deskbar (old deskbar moved to browbar base class)

#include "priv.h"
#include "sccls.h"
#include "resource.h"
#include "deskbar.h"

#define SUPERCLASS  CDockingBar

//***   CDeskBar_CreateInstance --
//
STDAPI CDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CDeskBar *pwbar = new CDeskBar();
    if (pwbar) {
        *ppunk = SAFECAST(pwbar, IDockingWindow*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//***
// NOTES
//  REARCHITECT: nuke this, fold it into CDeskBar_CreateInstance
HRESULT DeskBar_Create(IUnknown** ppunk, IUnknown** ppbs)
{
    HRESULT hres;

    *ppunk = NULL;
    if (ppbs)
        *ppbs = NULL;
    
    CDeskBar *pdb = new CDeskBar();
    if (!pdb)
        return E_OUTOFMEMORY;
    
    IDeskBarClient *pdbc;
    hres = CoCreateInstance(CLSID_RebarBandSite, NULL, CLSCTX_INPROC_SERVER, 
                            IID_IDeskBarClient, (LPVOID*)&pdbc);
    if (SUCCEEDED(hres))
    {
        hres = pdb->SetClient(pdbc);
        if (SUCCEEDED(hres))
        {
            if (ppbs) {
                *ppbs = pdbc;
                pdbc->AddRef();
            }
        
            *ppunk = SAFECAST(pdb, IDeskBar*);
        }
    
        pdbc->Release();
    }

    if (FAILED(hres))
    {
        pdb->Release();
    }

    return hres;
}


CDeskBar::CDeskBar() : SUPERCLASS()
{
    // We assume this object was ZERO-INITed on the heap.
    ASSERT(!_fRestrictionsInited);
}


//*** CDeskBar::IUnknown::* {

HRESULT CDeskBar::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDeskBar, IRestrict),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);

    return hres;
}

// }


//*** CDeskBar::IPersistStream*::* {

HRESULT CDeskBar::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_DeskBar;
    return S_OK;
}

// }



//*** CDeskBar::IRestrict::* {

HRESULT CDeskBar::IsRestricted(const GUID * pguidID, DWORD dwRestrictAction, VARIANT * pvarArgs, DWORD * pdwRestrictionResult)
{
    HRESULT hr = S_OK;

    if (!EVAL(pguidID) || !EVAL(pdwRestrictionResult))
        return E_INVALIDARG;

    *pdwRestrictionResult = RR_NOCHANGE;
    if (IsEqualGUID(RID_RDeskBars, *pguidID))
    {
        if (!_fRestrictionsInited)
        {
            _fRestrictionsInited = TRUE;
            if (SHRestricted(REST_NOCLOSE_DRAGDROPBAND))
                _fRestrictDDClose = TRUE;
            else
                _fRestrictDDClose = FALSE;

            if (SHRestricted(REST_NOMOVINGBAND))
                _fRestrictMove = TRUE;
            else
                _fRestrictMove = FALSE;
        }

        switch(dwRestrictAction)
        {
        case RA_DRAG:
        case RA_DROP:
        case RA_ADD:
        case RA_CLOSE:
            if (_fRestrictDDClose)
                *pdwRestrictionResult = RR_DISALLOW;
            break;
        case RA_MOVE:
            if (_fRestrictMove)
                *pdwRestrictionResult = RR_DISALLOW;
            break;
        }
    }

    if (RR_NOCHANGE == *pdwRestrictionResult)    // If we don't handle it, let our parents have a wack at it.
        hr = IUnknown_HandleIRestrict(_ptbSite, pguidID, dwRestrictAction, pvarArgs, pdwRestrictionResult);

    return hr;
}

// }



//*** CDeskBar::IServiceProvider::* {

HRESULT CDeskBar::QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj)
{
    if (ppvObj)
        *ppvObj = NULL;

    if (IsEqualGUID(guidService, SID_SRestrictionHandler))
    {
        return QueryInterface(riid, ppvObj);
    }
    
    return SUPERCLASS::QueryService(guidService, riid, ppvObj);
}

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\dhuihand.cpp ===
#include "priv.h"

#include "dhuihand.h"


#define DM_DOCHOSTUIHANDLER 0

//==========================================================================
// IDocHostUIHandler implementation
//==========================================================================

HRESULT CDocHostUIHandler::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::ShowContextMenu called");

    //
    // LATER: WebBand in a DesktBar/BrowserBar needs to hook this event
    // to popup a customized context menu.
    //
    return S_FALSE; // Host did not display any UI. 
}

HRESULT CDocHostUIHandler::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetHostInfo called");

// Trident does not initialize it. It's defined as [in] parameter. 
#if 0
    if (pInfo->cbSize < SIZEOF(DOCHOSTUIINFO)) {
        return E_INVALIDARG;
    }
#endif
    pInfo->cbSize = SIZEOF(DOCHOSTUIINFO);
    pInfo->dwFlags = DOCHOSTUIFLAG_BROWSER;
// Disable double buffering if low memory machine.
//    if (SHIsLowMemoryMachine(ILMM_IE4))
//        pInfo->dwFlags = pInfo->dwFlags | DOCHOSTUIFLAG_DISABLE_OFFSCREEN;
    
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;     // default
    return S_OK;
}

HRESULT CDocHostUIHandler::ShowUI( 
    DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
    IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
    IOleInPlaceUIWindow *pDoc)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::ShowUI called");

    // Host did not display its own UI. Trident will proceed to display its own. 
    return S_FALSE;
}

HRESULT CDocHostUIHandler::HideUI(void)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::HideUI called");
    // This one is paired with ShowUI
    return S_FALSE;
}

HRESULT CDocHostUIHandler::UpdateUI(void)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::UpdateUI called");
    // LATER: Isn't this equivalent to OLECMDID_UPDATECOMMANDS?
    return S_FALSE;
}

HRESULT CDocHostUIHandler::EnableModeless(BOOL fEnable)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::EnableModeless called");
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::OnDocWindowActivate(BOOL fActivate)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::OnFrameWindowActivate(BOOL fActivate)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::ResizeBorder( 
LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::TranslateAccelerator( 
LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_FALSE; // The message was not translated
}

HRESULT CDocHostUIHandler::GetOptionKeyPath(BSTR *pbstrKey, DWORD dw)
{
    // Trident will default to its own user options.
    *pbstrKey = NULL;
    return S_FALSE;
}

HRESULT CDocHostUIHandler::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetDropTarget called");

    return E_NOTIMPL;
}

HRESULT CDocHostUIHandler::GetAltExternal(IDispatch **ppDisp)
{
    HRESULT hr = E_FAIL;
    
    IDocHostUIHandler *pDocHostUIHandler;
    IOleObject        *pOleObject;
    IOleClientSite    *pOleClientSite;

    *ppDisp = NULL;

    //  * QI ourselves for a service provider
    //  * QS for the top level browser's service provider
    //  * Ask for an IOleObject
    //  * Ask the IOleObject for an IOleClientSite
    //  * QI the IOleClientSite for an IDocHostUIHandler
    //  * Call GetExternal on the IDocHostUIHandler to get the IDispatch

    if (SUCCEEDED(IUnknown_QueryServiceForWebBrowserApp(this, IID_PPV_ARG(IOleObject, &pOleObject))))
    {
        if (SUCCEEDED(pOleObject->GetClientSite(&pOleClientSite)))
        {
            if (SUCCEEDED(pOleClientSite->QueryInterface(IID_IDocHostUIHandler,
                                                         (void **)&pDocHostUIHandler)))
            {
                hr = pDocHostUIHandler->GetExternal(ppDisp);
                pDocHostUIHandler->Release();
            }
            pOleClientSite->Release();
        }
        pOleObject->Release();
    }

    return hr;
}


HRESULT CDocHostUIHandler::GetExternal(IDispatch **ppDisp)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetExternal called");

    HRESULT hr;

    if (ppDisp)
    {
        IDispatch *psuihDisp;
        IDispatch *pAltExternalDisp;

        *ppDisp = NULL;

        GetAltExternal(&pAltExternalDisp);

        hr = CShellUIHelper_CreateInstance2((IUnknown **)&psuihDisp, IID_IDispatch,
                                           (IUnknown *)this, pAltExternalDisp);
        if (SUCCEEDED(hr))
        {
            *ppDisp = psuihDisp;

            if (pAltExternalDisp)
            {
                //  Don't hold a ref - the ShellUIHelper will do it
                pAltExternalDisp->Release();
            }
        }
        else if (pAltExternalDisp)
        {
            //  Couldn't create a ShellUIHelper but we got our host's
            //  external.
            *ppDisp = pAltExternalDisp;
            hr = S_OK;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    ASSERT((SUCCEEDED(hr) && (*ppDisp)) || (FAILED(hr)));
    return hr;
}


HRESULT CDocHostUIHandler::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::TranslateUrl called");

    return S_FALSE;
}


HRESULT CDocHostUIHandler::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::FilterDataObject called");

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\dhuihand.h ===
#ifndef _DHUIHAND_H
#define _DHUIHAND_H

class CDocHostUIHandler : 
   public IDocHostUIHandler
{
   public:

       // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    
    // IDocHostUIHandler
    virtual HRESULT STDMETHODCALLTYPE ShowContextMenu( 
        DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
    virtual HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO *pInfo);
    virtual HRESULT STDMETHODCALLTYPE ShowUI( 
        DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
        IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
        IOleInPlaceUIWindow *pDoc);
    virtual HRESULT STDMETHODCALLTYPE HideUI(void);
    virtual HRESULT STDMETHODCALLTYPE UpdateUI(void);
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL fEnable);
    virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE ResizeBorder( 
        LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
        LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
    virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath(BSTR *pbstrKey, DWORD dw);
    virtual HRESULT STDMETHODCALLTYPE GetDropTarget( 
        IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
    virtual HRESULT STDMETHODCALLTYPE GetExternal(IDispatch **ppDisp);
    virtual HRESULT STDMETHODCALLTYPE TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    virtual HRESULT STDMETHODCALLTYPE FilterDataObject(IDataObject *pDO, IDataObject **ppDORet);

protected:
    HRESULT GetAltExternal(IDispatch **ppDisp);

};

#endif  _DHUIHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\droptgt.cpp ===
#include "priv.h"

#include "..\inc\droptgt.h"
#include "..\inc\droptgt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\enumband.h ===
#ifndef _ENUMBAND_H_
#define _ENUMBAND_H_

// e.g. STDMETHODIMP Foo(REFCATID rcatid, REFCLSID rclsid, LPARAM lParam)
typedef HRESULT (CALLBACK* PFNENUMCATIDCLASSES)(REFCATID rcatid, REFCLSID rclsid, LPARAM lParam);

STDMETHODIMP SHEnumClassesImplementingCATID(REFCATID rcatid, PFNENUMCATIDCLASSES pfnEnum, LPARAM lParam);

#endif  // _ENUMBAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\enumband.cpp ===
#include "priv.h"
#include "comcatex.h"
#include "enumband.h"

// Private forward decalarations
typedef HRESULT (CALLBACK* PFNENUMCLSIDPROC)(REFGUID rguid, LPARAM lParam);

typedef struct tagADDCATIDENUM
{
    PFNENUMCATIDCLASSES pfnEnum;
    const CATID*        pcatid;
    LPARAM              lParam;
} ADDCATIDENUM, *PADDCATIDENUM;


STDMETHODIMP _SHEnumGUIDsWithCallback(IEnumCLSID* peclsid, PFNENUMCLSIDPROC pfnEnum, LPARAM lParam);

STDMETHODIMP _AddCATIDEnum(REFCLSID rclsid, LPARAM lParam);


STDMETHODIMP SHEnumClassesImplementingCATID(REFCATID rcatid, PFNENUMCATIDCLASSES pfnEnum, LPARAM lParam)
{
    ADDCATIDENUM params;
    params.pcatid  = &rcatid;
    params.pfnEnum = pfnEnum;
    params.lParam  = lParam;

    IEnumCLSID *peclsid;
    HRESULT hr = SHEnumClassesOfCategories(1, (CATID*)&rcatid, 0, NULL, &peclsid);
    if (SUCCEEDED(hr))
    {
        hr = _SHEnumGUIDsWithCallback(peclsid, _AddCATIDEnum, (LPARAM)&params);
        peclsid->Release();
    }
    return hr;
}


STDMETHODIMP _SHEnumGUIDsWithCallback(IEnumCLSID* peclsid, PFNENUMCLSIDPROC pfnEnum, LPARAM lParam)
{
    CLSID   clsid;
    HRESULT hr;
    ULONG   i;

    if (NULL == peclsid || NULL == pfnEnum)
    {
        return E_INVALIDARG;
    }

    hr = S_OK;

    peclsid->Reset();
    while (S_OK == peclsid->Next(1, &clsid, &i))
    {
        hr = pfnEnum(clsid, lParam);
        if (S_OK != hr)
        {
            break;
        }
    }

    return hr;
}

STDMETHODIMP _AddCATIDEnum(REFCLSID rclsid, LPARAM lParam)
{
    PADDCATIDENUM p = (PADDCATIDENUM)lParam;
    ASSERT(NULL != p);
    ASSERT(NULL != p->pfnEnum);
    return (*p->pfnEnum)(*p->pcatid, rclsid, p->lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\dockbar.h ===
#ifndef DOCKBAR_H_
#define DOCKBAR_H_

#include "basebar.h"
//      local macros
//
// configurable constants

#define XXX_NEW         0       // 1=turn on work-in-progress
#define XXX_BROWSEROWNED    0   // 1:browser deskbar is owned (proto)
#define XXX_CHEEDESK    0       // 1:chee's desktop (vs. _fDesktop)
#define XXX_BTMFLOAT    0       // 0=allow dragging from non-desk-btm->float
#define XXX_HIDE        1       // 1=turn on autohide (work-in-progress)
#define XXX_HIDEALL     1       // 1=enable autohide in browsers (non-topmost)


#define XXX_CANCEL      0       // 1=use experimental CANCEL code
#define XXX_NEWSLIDE    0       // 1=use new SlideWindow code

#ifndef UNREFERENCED_PARM
#define UNREFERENCED_PARM(p)    (p)      // ARGUSED
#endif

//***   _PM, _PX -- lazy shorthands
// DESCRIPTION
//      _PM     check for p==NULL before doing p->m
//      _PX     check for p==NULL before doing EXPR(p)
//
#define _PM(p, m)       ((p) ? (p)->m : (-1))
#define _PX(p, x)       ((p) ? (x) : (-1))

#define BITS_SET(v, m)  (((v) & (m)) == (m))

//***   IN, OUT, INOUT --
//
#define IN
#define OUT
#define INOUT

#ifndef NOCDESKBAR
#include "dhuihand.h"

//========================================================================
// class CDeskBar (CDeskBar* pwbar)
// NOTES
//  we don't use CObjectWithSite because we want _ptbSite not _punkSite.
//========================================================================
class CDockingBar : public CBaseBar
                ,public IDockingWindow
                ,public IObjectWithSite     // n.b. *not* CObjectWithSite
                ,public IPersistStreamInit
                ,public IPersistPropertyBag
                ,public CDocHostUIHandler
{
public:
    // *** IUnknown -- disambiguate ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return CBaseBar::AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CBaseBar::Release(); }

    // *** IOleWindow -- disambiguate ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd)
        { return CBaseBar::GetWindow(lphwnd); }
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode)
        { return CBaseBar::ContextSensitiveHelp(fEnterMode); }

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved) { return CBaseBar::CloseDW(dwReserved); }
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
        IUnknown* punkToolbarSite, BOOL fReserved);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    // NOTE: I sure hope E_NOTIMPL is ok?
    virtual STDMETHODIMP GetSite(REFIID riid, void** ppvSite) { ASSERT(0); *ppvSite = NULL; return E_NOTIMPL; };

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IPersistStreamInit ***
    //virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP IsDirty(void);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);
    virtual STDMETHODIMP InitNew(void);

    // *** IPersistPropertyBag ***
    virtual STDMETHODIMP Load(IPropertyBag *pPropBag,
                                           IErrorLog *pErrorLog);
    virtual STDMETHODIMP Save(IPropertyBag *pPropBag,
                        BOOL fClearDirty, BOOL fSaveAllProperties);

    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);
    
    // *** IDocHostUIHandler methods ***
    virtual STDMETHODIMP ShowContextMenu(DWORD dwID,
        POINT* ppt, IUnknown* cmdtReserved, IDispatch* pdispReserved);

protected:
    // Constructor & Destructor
    CDockingBar();
    virtual ~CDockingBar();
    
    void _Initialize();         // 2nd-phase ctor
    virtual void _SetModeSide(UINT eMode, UINT uSide, HMONITOR hMon, BOOL fNoMerge);
    virtual void _OnPostedPosRectChange();
    virtual void _GetChildPos(LPRECT prc);
    virtual void _GetStyleForMode(UINT eMode, LONG* plStyle, LONG* plExStyle, HWND* phwndParent);
    
    friend HRESULT CDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    friend HRESULT CDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    friend HRESULT BrowserBar_Create(IUnknown** ppunk, IUnknown** ppbs);

    // Private members
    HMENU _GetContextMenu();

    virtual LRESULT _OnCommand(UINT msg, WPARAM wparam, LPARAM lparam);
    void _ChangeTopMost(UINT eModeNew);
    void _ChangeWindowStateAndParent(UINT eModeNew);
    void _ChangeZorder();
    void _ResetZorder();
    virtual void _OnRaise(UINT flags);
#if XXX_BTMFLOAT && 0
    void _MayReWindow(BOOL fToFloat);
#endif
    
    virtual void _NotifyModeChange(DWORD dwMode);
    void _GetBorderRect(HMONITOR hMon, RECT* prc);
    HRESULT _NegotiateBorderRect(RECT* prcOut, RECT* prcReq, BOOL fCommit);
    virtual void _OnSize(void);
    void _InitPos4(BOOL fCtor);
    void _ProtoRect(RECT* prcOut, UINT eModeNew, UINT uSideNew, HMONITOR hMonNew, POINT* ptXY);
    void _NegotiateRect(UINT eModeNew, UINT uSideNew, HMONITOR hMonNew, RECT* rcReq, BOOL fCommit);
    void _MoveSizeHelper(UINT eModeNew, UINT eSideNew, HMONITOR hMonNew,
        POINT* ptTrans, RECT* rcFeed, BOOL fCommit, BOOL fMove);
    void _SetVRect(RECT* rcNew);
    void _Recalc(void);

    LRESULT _CalcHitTest(WPARAM wParam, LPARAM lParam);

    void _DragEnter(UINT uMsg, int xCursor, int yCursor, RECT* rcFeed);
    void _DragTrack(UINT uMsg, int xCursor, int yCursor, RECT* rcFeed, int eState);
    void _DragLeave(int x, int y, BOOL fCommit);
    void _ExecDrag(int eDragging);

    void _TrackSliding(int x, int y, RECT* rcFeed,
        BOOL fCommit, BOOL fMove);
    UINT _CalcDragPlace(POINT& pt, HMONITOR * hMon);
    void _SmoothDragPlace(UINT eModeNew, UINT eSideNew, HMONITOR hMonNew, INOUT POINT* pt, RECT* rcFeed);
    void _RemoveToolbar(DWORD dwFlags);

    HRESULT _TrackPopupMenu(const POINT* ppt);
    HMONITOR _SetNewMonitor(HMONITOR hMonNew);

    void _HideRegister(BOOL fToHide);
    void _DoHide(UINT uOpMask);
    virtual void _HandleWindowPosChanging(LPWINDOWPOS pwp);
    virtual void _GrowShrinkBar(DWORD dwDirection);

#if 0
    void _DoManHide(UINT uOpMask);
#endif
        // for _DoHide and _DoManHide
        enum aho {
            AHO_KILLDO  = 0x01,
            AHO_SETDO   = 0x02,
            AHO_KILLUN  = 0x04,
            AHO_SETUN   = 0x08,
            AHO_REG     = 0x10,
            AHO_UNREG   = 0x20,
            AHO_MOVEDO  = 0x40,
            AHO_MOVEUN  = 0x80
        };

        #define AHO_MNE         TEXT("ksKSrRmM")

    void _AppBarRegister(BOOL fRegister);
    void _AppBarOnSize();
    void _AppBarOnCommand(UINT idCmd);
    void _AppBarOnWM(UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _AppBarOnPosChanged(PAPPBARDATA pabd);
    void _AppBarCallback(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    int AppBarQueryPos(RECT* prcOut, UINT uEdge, HMONITOR hMon, const RECT* prcReq, PAPPBARDATA pabd, BOOL fCommit);
    void AppBarSetPos(UINT uEdge, const RECT* prcReq, PAPPBARDATA pabd);
    void AppBarSetPos0(UINT uEdge, const RECT* prcReq, PAPPBARDATA pabd);
    void AppBarQuerySetPos(RECT* prcOut, UINT uEdge, HMONITOR hMon, const RECT* prcReq, PAPPBARDATA pabd, BOOL fCommit);
    LRESULT _OnNCHitTest(WPARAM wParam, LPARAM lParam);

    void _AdjustToChildSize();

    // Window procedure
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnActivate(WPARAM wParam, LPARAM lParam);

    virtual BOOL _OnCloseBar(BOOL fConfirm);


#define RX_EDGE         0x01
#define RX_OPPOSE       0x02
#define RX_ADJACENT     0x04
#define RX_GETWH        0x08
#define RX_HIDE         0x10

    //
    // We need to do a get window in side this function so that we
    // can mirror the edges. I changed them to non-static. [samera]
    //
    int RectXform(RECT* prcOut, UINT uRxMask,
        const RECT* prcIn, RECT* prcBound, int iWH, UINT uSide, HMONITOR hMon);
    
    int RectGetWH(const RECT* prcReq, UINT uSide) {
        return RectXform(NULL, RX_GETWH, prcReq, NULL, -1, uSide, NULL);
    }

    void RectSetWH(RECT* prcReq, int iWH, UINT uSide) {
        RectXform(prcReq, RX_OPPOSE, prcReq, NULL, iWH, uSide, NULL);
        return;
    }

    // Member variables
    IDockingWindowSite*  _ptbSite;           // owner
    INT             _adEdge[4];             // edges' widths (or heights)
    RECT            _rcFloat;               // floating position
    HMONITOR        _hMon;                  // the monitor I am on
    POINT           _ptIdtUnHide;           // unhide hysteresis cursor pos

    // Variable initialized IPersistPropertyBag::Load
    // ...

    // Bit fields
    UINT            _uSide:3;               // edge we're on (ABE_*)
    // 3 states to initialization (4 w/ ctor)
    BITBOOL         _fInitSited:1;          // SetSite done
    UINT            _eInitLoaded:2;         // Load (or InitNew) done
    BITBOOL         _fInitShowed:1;         // Show done
#if ! XXX_CHEEDESK
    BITBOOL         _fDesktop:1;            // 1:hosted by desktop (vs. browser)
#endif
    UINT            _fDragging:2;           // we're dragging
    BITBOOL         _fWantHide:1;           // 1:autohide requested (in UI)
    BITBOOL         _fDeleteable:1;         // when we close we should signal our parent to delete our info
    BITBOOL         _fAppRegistered:1;      // Registered as an appbar

    // Member variables (drag&drop, sizing, ...)
    UINT            _uSidePending:3;        // ...
    BITBOOL         _fCanHide:1;            // 1:autohide granted (registered)
    BOOL            _fHiding:2;             // hide mode (HIDE_*)
    BITBOOL         _fIdtDoHide:1;          // 1:IDT_AUTOHIDE running
    BITBOOL         _fIdtUnHide:1;          // 1:IDT_AUTOUNHIDE running

    UINT            _eMode;               // mode we're in (WBM_*)
    UINT            _eModePending;        // pending drag state
    
    LPARAM          _xyPending;             // pending drag state
    RECT            _rcPending;             // ...
    HMONITOR        _hMonPending;           // pending monitor 
#ifdef DEBUG
    // temporary until we make browser tell us about activation
    BOOL            _fActive:1;             // 1:window is active
#endif

    
    // MOVE TO CBROWSERBAR    
    BITBOOL _fTheater :1;
    BITBOOL _fNoAutoHide :1;
    int _iTheaterWidth;
    // END MOVE TO CBROWSERBAR
};

#define WBM_IS_TOPMOST() (_eMode & WBM_TOPMOST)

#endif //NOCDESKBAR

//***   CASSERT -- compile-time assert
// DESCRIPTION
//      Like Assert, but checked at compile-time, and generates no code
//      Note that the expr must of course be constant...
#ifndef UNIX
#define CASSERT(e)      extern int dummy_array[(e)]
#else
#define CASSERT(e)      
#endif

//***   ABE_* -- helpers, etc. for ABE_*'s
//

//***   ABE_X* -- extended ABE_*'s
// DESCRIPTION
//      ABE_NIL: distinguished value (unused?).
//
//      ABE_XFLOATING: normally we carry around a (mode,side) pair.  this
//      works fine but is a pain in the (rare) case that we want to return
//      a pair.  so we have a 'special' side which means we're really
//      floating.  (alternatives considered included combining the two via
//      bit magic, or passing by reference.  none stood out as a great
//      sol'n, and we only use it one place.  a hack?  perhaps...)
#define ABE_NIL         ((UINT) 0x07)   // nil (-1 as a 3-bit field) (ugh!)
#define ABE_XFLOATING   ((UINT) 4)      // floating (undocked)
CASSERT((ABE_LEFT|ABE_RIGHT|ABE_TOP|ABE_BOTTOM) == 3);  // 0..3

#define ISABE_DOCK(abe) ((UINT)(abe) <= 3)

#define ABE_TO_IDM(abe) (IDM_AB_LEFT + (abe))
#define IDM_TO_ABE(abe) ((abe) - IDM_AB_LEFT)
CASSERT(IDM_AB_BOTTOM - IDM_AB_LEFT == 3);      // make sure LEFT is 0th

//***   ABE_HORIZ -- is ABE_* horizontal?
// #define ABE_HORIZ(e) ((e) == ABE_TOP || (e) == ABE_BOTTOM)
#define ABE_HORIZ(e)    ((e) & 1)
CASSERT(ABE_HORIZ(ABE_TOP) && ABE_HORIZ(ABE_BOTTOM));
CASSERT(! ABE_HORIZ(ABE_LEFT) && ! ABE_HORIZ(ABE_RIGHT));


#define APPBAR_CALLBACK (WM_USER + 73)  // REARCHITECT: bad bad bad, I don't know why this is bad but it's previous tagname was unacceptable, perhaps someone should look at this someday - justmann


//***   WS_*, etc. -- window bits, etc. for various modes
// NOTES
//      REVIW Don't use SM_CAPTION because it doesn't work properly yet.
//      WS_XTOPMOST w/ an 'X' to avoid collision w/ WS_TOPMOST...

#define WS_NIL          (WS_POPUP|WS_CLIPCHILDREN|WS_CLIPSIBLINGS)
#define WS_EX_NIL       (WS_EX_TOOLWINDOW /*|WS_EX_WINDOWEDGE*/)
#define PARENT_NIL      (HWND_DESKTOP)

#define WS_XTOPMOST     (WS_POPUP|WS_THICKFRAME|WS_CLIPCHILDREN|WS_CLIPSIBLINGS)
#define WS_EX_XTOPMOST  (WS_EX_TOOLWINDOW|WS_EX_WINDOWEDGE)
#define PARENT_XTOPMOST (HWND_DESKTOP)

#define WS_BTMMOST      (WS_POPUP|WS_THICKFRAME|WS_CLIPCHILDREN|WS_CLIPSIBLINGS)
#define WS_EX_BTMMOST   (WS_EX_TOOLWINDOW|WS_EX_WINDOWEDGE)
#define PARENT_BTMMOST() HWND_DESKTOP

#if 0
// 970208 keep this around for 1 week in case the autosize bug isn't fixed
#define WS_BTMMOST      WS_BBTMMOST
#define WS_EX_BTMMOST   WS_EX_BBTMMOST
#define PARENT_BTMMOST() PARENT_BBTMMOST()
#endif

#define WS_BFLOATING     ((/*WS_POPUP*/WS_OVERLAPPED | WS_SYSMENU | WS_THICKFRAME |WS_THICKFRAME|WS_CLIPCHILDREN|WS_CLIPSIBLINGS) & ~(WS_MINIMIZEBOX|WS_MAXIMIZEBOX))
#define WS_EX_BFLOATING  (/*WS_EX_PALETTEWINDOW | */ WS_EX_TOOLWINDOW | WS_EX_WINDOWEDGE)


#define WS_FLOATING     ((/*WS_POPUP*/WS_TILEDWINDOW|WS_THICKFRAME|WS_CLIPCHILDREN|WS_CLIPSIBLINGS) & ~(WS_MINIMIZEBOX|WS_MAXIMIZEBOX))
#define WS_EX_FLOATING  (WS_EX_PALETTEWINDOW | WS_EX_WINDOWEDGE)
#define PARENT_FLOATING (HWND_DESKTOP)

#if XXX_BROWSEROWNED
#define WS_BBTMMOST     WS_FLOATING
#define WS_EX_BBTMMOST  (WS_EX_FLOATING|WS_EX_TOOLWINDOW)
#define PARENT_BBTMMOST PARENT_FLOATING
#else
// non-topmost
#define WS_BBTMMOST     (WS_CHILD/*|WS_BORDER|WS_THICKFRAME*/|WS_CLIPSIBLINGS | WS_CLIPCHILDREN)
#define WS_EX_BBTMMOST  (WS_EX_CLIENTEDGE /*|WS_EX_WINDOWEDGE*/)
#define PARENT_BBTMMOST() (_hwndSite)
#endif

#define ISWSX_EDGELESS(ws, wsx) \
    (!(((ws)&WS_THICKFRAME) || ((wsx)&WS_EX_WINDOWEDGE)))

#define ISWBM_EDGELESS(eMode) \
    ((eMode==WBM_BBOTTOMMOST && ISWSX_EDGELESS(WS_BBTMMOST, WS_EX_BBTMMOST)) \
    || (eMode==WBM_BOTTOMMOST && ISWSX_EDGELESS(WS_BTMMOST, WS_EX_BTMMOST)))

#define XY_NIL          ((LPARAM) (-1))

// drag state
#define DRAG_NIL        0       // nil
#define DRAG_MOVE       1       // moving
#define DRAG_SIZE       2       // sizing

extern void DBC_ExecDrag(IUnknown *pDbc, int eDragging);

#define WBMF_BROWSER    (0x0001000)        // hosted by browser (vs. by desktop)
#define WBM_BBOTTOMMOST (WBMF_BROWSER|WBM_BOTTOMMOST)
//#define WBM_BTOPMOST    (WBMF_BROWSER|WBM_TOPMOST)
#define WBM_BFLOATING   (WBMF_BROWSER|WBM_FLOATING)
#define WBM_BNIL        *** error! ***


//***   ISWBM_* -- check mode
#define ISWBM_FLOAT(eMode) \
                           (eMode & WBM_FLOATING)

#define ISWBM_BOTTOM(eMode) \
    ((eMode) == WBM_BOTTOMMOST || (eMode) == WBM_BBOTTOMMOST)

#if XXX_CHEEDESK
#define ISWBM_DESKTOP()     (!(_eMode & WBMF_BROWSER))
#else
#define ISWBM_DESKTOP()     (_fDesktop)
#endif

#if XXX_BROWSEROWNED
#define ISWBM_OWNED(eMode) ((!ISWBM_DESKTOP()) && \
    ((eMode) == WBM_BFLOATING || (eMode) == WBM_BBOTTOMMOST))
#else
#define ISWBM_OWNED(eMode) ((eMode) == WBM_BFLOATING)
#endif

#if XXX_HIDE
#if XXX_HIDEALL
#define ISWBM_HIDEABLE(eMode)   (((eMode) & ~WBMF_BROWSER) != WBM_FLOATING)
#else
#define ISWBM_HIDEABLE(eMode)   ((eMode) == WBM_TOPMOST)
#endif
#endif

#define CHKWBM_CHANGE(eModeNew, eModeCur) \
    (((eModeNew) & WBMF_BROWSER) == ((eModeCur) & WBMF_BROWSER) \
        || (eModeNew) == WBM_NIL || (eModeCur) == WBM_NIL) 


//***   timer stuff
#define IDT_POPUI       10
#define IDT_AUTOHIDE    11
#define IDT_AUTOUNHIDE  12

#define DLY_AUTOHIDE    500
#define DLY_AUTOUNHIDE  50

//***   hide state (_fHiding)
#define HIDE_FALSE      0       // must be FALSE
#define HIDE_AUTO       1       // currently hidden (due to autohide)
#define HIDE_MANUAL     2       // currently hidden (due to manual hide)

CASSERT(! HIDE_FALSE);


#if 0
//***   MKMS, MSTO* -- make/crack combined mode+side
//
#define MSTOMODE(ms)    (((UINT) (ms)) >> 8)
#define MSTOSIDE(ms)    (((UINT) (ms)) & 0x7)
#define MKMS(m, s)      ((((UINT) (m)) << 8) | (UINT) (s))
#endif

#if WEBBAR_APP
HMENU LoadMenuPopup(UINT id);
extern HINSTANCE        g_hinst;
#define HINST_THISDLL   g_hinst
#endif

// REARCHITECT we can replace these once the portability layer is up and running.
#define Command_GetNotifyCode(wp,lp)    HIWORD(wp)
#define Command_GetHwndCtl(lp)          ((HWND)lp)
#define Command_GetID(wp)               LOWORD(wp)


CASSERT((ABE_LEFT|ABE_RIGHT|ABE_TOP|ABE_BOTTOM) == 3);  // must fit in _uSide:2

//***   MoveRect -- move left-top corner of rect to (x,y)
//
#define MoveRect(prc, x, y) \
    OffsetRect((prc), (x) - (prc)->left, (y) - (prc)->top)

#define AB_THEIGHT(rc)  (RECTHEIGHT(rc) * 10 / 100)     // 10%
#define AB_BHEIGHT(rc)  (RECTHEIGHT(rc) * 10 / 100)     // 10%
#define AB_LWIDTH(rc)   (40)                            // fixed width 40
#define AB_RWIDTH(rc)   ( RECTWIDTH(rc) * 35 / 100)     // 30%

void SlideWindow(HWND hwnd, RECT *prc, HMONITOR hMonClip, BOOL fShow);


class PropDataSet {
public:
    BOOL _fSet;
    DWORD _dwData;
};

class CDockingBarPropertyBag :
      public IPropertyBag
    , public IDockingBarPropertyBagInit
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IPropertyBag ***
    virtual HRESULT STDMETHODCALLTYPE Read( 
                                           /* [in] */ LPCOLESTR pszPropName,
                                           /* [out][in] */ VARIANT *pVar,
                                           /* [in] */ IErrorLog *pErrorLog);

    virtual HRESULT STDMETHODCALLTYPE Write( 
                                            /* [in] */ LPCOLESTR pszPropName,
                                            /* [in] */ VARIANT *pVar) {return E_NOTIMPL;};

    // *** IDockingBarPropertyBagInit
    virtual STDMETHODIMP SetDataDWORD(ENUMPROPDATA e, DWORD dwData) { _props[e]._fSet = TRUE; _props[e]._dwData = dwData; return S_OK; }
    
protected:
    CDockingBarPropertyBag() { _cRef = 1; };
    friend HRESULT CDockingBarPropertyBag_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

    UINT _cRef;
    
    PropDataSet _props[PROPDATA_COUNT];
    
}; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\dockbar.cpp ===
#include "priv.h"
#include "sccls.h"
#include "resource.h"
#include "mshtmhst.h"
#include "desktopp.h"   // DTRF_RAISE etc.

#define WANT_CBANDSITE_CLASS
#include "bandsite.h"

#include "deskbar.h"
#include "theater.h"

#include "mluisupp.h"

#define SUPERCLASS CBaseBar

#define DM_PERSIST      0               // trace IPS::Load, ::Save, etc.
#define DM_POPUI        0               // expando-UI (proto)
#define DM_MENU         0               // trace menu code
#define DM_DRAG         0               // drag move/size (terse)
#define DM_DRAG2        0               // ... (verbose)
#define DM_API          0               // trace API calls
#define DM_HIDE         DM_TRACE               // autohide
#define DM_HIDE2        DM_TRACE               // autohide (verbose)
#define DM_APPBAR       0               // SHAppBarMessage calls
#define DM_OLECT        0               // IOleCommandTarget calls
#define DM_FOCUS        0               // focus change
#define DM_RES          DM_WARNING      // resolution

#define ABS(i)  (((i) < 0) ? -(i) : (i))

#define RECTGETWH(uSide, prc)   (ABE_HORIZ(uSide) ? RECTHEIGHT(*prc) : RECTWIDTH(*prc))

//***   CDB_INITED -- has CDockingBar::_Initialize been called
//
#define CDB_INITED()   (_eInitLoaded && _fInitSited && _fInitShowed)

enum ips_e {
    IPS_FALSE,    // reserved, must be 0 (FALSE)
    IPS_LOAD,
    IPS_LOADBAG,
    IPS_INITNEW,
    IPS_LAST
};

CASSERT(IPS_FALSE == 0);
CASSERT(((IPS_LAST - 1) & 0x03) == (IPS_LAST - 1)); // 2-bit _eInitLoaded


//***   CXFLOAT -- distance from edge to 'float' zone 
// NOTES
//  pls forgive the lousy hungarian...
#define CXFLOAT()   GetSystemMetrics(SM_CXICON)
#define CYFLOAT()   GetSystemMetrics(SM_CYICON)
#define CXYHIDE(uSide)  2       // FEATUE: GetSystemMetrics(xxx), we need an appropriate system metric

#ifdef DEBUG
#if 0   // turn on to debug autohide boundary cases
int g_cxyHide = 8;
#undef  CXYHIDE
#define CXYHIDE(uSide)  g_cxyHide
#endif
#endif

#define CXSMSIZE()  GetSystemMetrics(SM_CXSMSIZE)
#define CYSMSIZE()  GetSystemMetrics(SM_CYSMSIZE)


#ifdef DEBUG
extern unsigned long DbStreamTell(IStream *pstm);
extern BOOL DbCheckWindow(HWND hwnd, RECT *prcExp, HWND hwndClient);
TCHAR *DbMaskToMneStr(UINT uMask, TCHAR *szMnemonics);
#else
#define DbStreamTell(pstm) 0
#define DbCheckWindow(hwnd, prcExp, hwndClient) 0
#define DbMaskToMneStr(uMask, szMnemonics) szMnemonics
#endif

//***   autohide -- design note
//
// here's an overview of how we do autohide.  see the code for details.
//
// only a few routines really know about it.  their behavior is driven
// by '_fHiding'.  when FALSE, they behave normally.  when TRUE, they
// do alternate 'fake' behavior.
//
// a 'real' or 'normal' rect is the full-size rect we display when not hidden.
// a 'fake' or 'tiny' rect is the very thin rect we display when hidden.
// (plus there's a '0-width' rect we register w/ the system when we're hidden).
//
// more specifically,
//
// when fHiding is TRUE, a few routines have alternate 'fake' behavior:
//      _ProtoRect      returns a 'tiny' rect rather than the 'real' rect
//      _NegotiateRect  is a NOOP (so we don't change the 'tiny' rect) 
//      _SetVRect       is a NOOP (so we don't save   the 'tiny' rect)
//      AppBarSetPos    is a NOOP (so we don't set    the 'tiny' rect)
// plus, a few routines handle transitions (and setup):
//      _DoHide         hide/unhide helper
//      _MoveSizeHelper detects and handles transitions
//      _HideReg        register autohide appbar w/ 0-width rect
// and finally, a few messages trigger the transitions:
//      unhide          WM_NCHITTEST on the 'tiny' rect starts the unhide.
//              actually it starts a timer (IDT_AUTOUNHIDE) so there's a
//              bit of hysteresis.
//      hide            WM_ACTIVATE(deact) starts a timer (IDT_AUTOHIDE)
//              which we use to poll for mouse leave events.  again, there
//              is some hysteresis, plus some additional heuristics for hiding.
//              WM_ACTIVATE(act) stops the timer.
//
// #if 0
// we also have 'manual hide'.  manual hide differs from autohide as follows:
//     autohide never negotiates space(*)   , manual hide always does
//     autohide is focus- and cursor- driven, manual hide is UI-driven
//     (*) actually it negotiates space of '0'.
// e.g. 'manual hide' is used for the BrowserBar (e.g. search results).
// however for now at least 'manual hide' is simply a ShowDW(FALSE).
// #endif

void CDockingBar::_AdjustToChildSize()
{
    if (_szChild.cx)
    {
        RECT rc, rcChild;
    
        GetWindowRect(_hwnd, &rc);
        GetClientRect(_hwndChild, &rcChild);

        // we need to change rc by the delta of prc-rcChild
        rc.right += _szChild.cx - RECTWIDTH(rcChild);
        rc.bottom += _szChild.cy - RECTHEIGHT(rcChild);

        _SetVRect(&rc);
    
        _Recalc();  // _MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);

        _szChild.cx = 0;
    }
}

void CDockingBar::_OnPostedPosRectChange()
{
    if (_ptbSite) {
        if (!_fDragging) {
            _AdjustToChildSize();
        }
    }
}

HMENU CDockingBar::_GetContextMenu()
{
    HMENU hmenu = LoadMenuPopup(MENU_WEBBAR);
    if (hmenu) {

        // _eMode
        if (!ISWBM_DESKTOP())
        {
            EnableMenuItem(hmenu, IDM_AB_TOPMOST, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hmenu, IDM_AB_AUTOHIDE, MF_BYCOMMAND | MF_GRAYED);
        }
        CheckMenuItem(hmenu, IDM_AB_TOPMOST, WBM_IS_TOPMOST() ? (MF_BYCOMMAND | MF_CHECKED) : (MF_BYCOMMAND | MF_UNCHECKED));

        // hide
        // we use _fWantHide (not _fCanHide) to reflect what user asked
        // for, not what he got.  o.w. you can't tell what the state is
        // unless you actually get it.
        CheckMenuItem(hmenu, IDM_AB_AUTOHIDE,
            MF_BYCOMMAND | (_fWantHide ? MF_CHECKED : MF_UNCHECKED));

        CASSERT(PARENT_XTOPMOST == HWND_DESKTOP);   // for WM_ACTIVATE
        CASSERT(PARENT_BTMMOST() == HWND_DESKTOP);  // for WM_ACTIVATE
        if (_eMode & WBM_FLOATING)
        {
            // (for now) only desktop btm/topmost does autohide
            EnableMenuItem(hmenu, IDM_AB_AUTOHIDE, MF_BYCOMMAND | MF_GRAYED);
        }

#ifdef DEBUG
        // FEATURE temporary until we make browser tell us about activation
        CheckMenuItem(hmenu, IDM_AB_ACTIVATE,
            MF_BYCOMMAND | (_fActive ? MF_CHECKED : MF_UNCHECKED));
#endif

    }
    return hmenu;
}

HRESULT CDockingBar::_TrackPopupMenu(const POINT* ppt)
{
    HRESULT hres = S_OK;

    HMENU hmenu = _GetContextMenu();
    if (hmenu)
    {
        TrackPopupMenu(hmenu, /*TPM_LEFTALIGN|*/TPM_RIGHTBUTTON,
            ppt->x, ppt->y, 0, _hwnd, NULL);
        DestroyMenu(hmenu);
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

void CDockingBar::_HandleWindowPosChanging(LPWINDOWPOS pwp)
{
}

/***
 */
LRESULT CDockingBar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    POINT pt;
    DWORD pos;
    RECT rc;

    switch (uMsg) {
    case WM_CLOSE:
        _AppBarOnCommand(IDM_AB_CLOSE);   // _RemoveToolbar(0)
        break;

    case WM_DESTROY:
        if (_fAppRegistered)
            _AppBarRegister(FALSE);
        break;

    case APPBAR_CALLBACK:
        _AppBarCallback(hwnd, uMsg, wParam, lParam);
        return 0;

    case WM_CONTEXTMENU:
        if (_CheckForwardWinEvent(uMsg, wParam, lParam, &lres))
            break;
            
        if ((LPARAM)-1 == lParam)
        {
            GetClientRect(_hwnd, &rc);
            MapWindowRect(_hwnd, HWND_DESKTOP, &rc);
            pt.x = rc.left + (rc.right - rc.left) / 2;
            pt.y = rc.top + (rc.bottom - rc.top) / 2;
        }
        else
        {
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
        }
        _TrackPopupMenu(&pt);
        break;

    case WM_ENTERSIZEMOVE:
        ASSERT(_fDragging == 0);
        _fDragging = 0;         // reset if busted
        _xyPending = XY_NIL;
#if XXX_CANCEL
        GetWindowRect(hwnd, &_rcCapture);      // to detect cancel
#endif
        break;

    case WM_SYSCHAR:
        if (wParam == TEXT(' '))
        {
            HMENU hmenu;

            hmenu = GetSystemMenu(hwnd, FALSE);
            if (hmenu) {
                EnableMenuItem(hmenu, SC_RESTORE, MFS_GRAYED | MF_BYCOMMAND);
                EnableMenuItem(hmenu, SC_MAXIMIZE, MFS_GRAYED | MF_BYCOMMAND);
                EnableMenuItem(hmenu, SC_MINIMIZE, MFS_GRAYED | MF_BYCOMMAND);
            }
        }
        goto DoDefault;

    case WM_SIZING:     // goto DoDefault? I doubt it.
    case WM_MOVING:
        {
            LPRECT prc = (RECT*)lParam;

            pos = GetMessagePos();
            if (_fDragging == 0)
            {
                // 1st time
                _DragEnter(uMsg, GET_X_LPARAM(pos), GET_Y_LPARAM(pos), prc);
                ASSERT(_fDragging != 0);
            }
            else
            {
                // 2nd..Nth time
                _DragTrack(uMsg, GET_X_LPARAM(pos), GET_Y_LPARAM(pos), prc, 0);
            }
        }
        return 1;

    case WM_MOVE:       // xLeft , yTop
    case WM_SIZE:       // xWidth, yHeight
        if (_fDragging)
        {
            RECT rcTmp;

            CopyRect(&rcTmp, &_rcPending);
            _DragTrack(uMsg, GET_X_LPARAM(_xyPending), GET_Y_LPARAM(_xyPending),
                &rcTmp, 1);
        }

        _OnSize();    // PERF: only needed for WM_SIZE? At worst this might cause a sligth flicker.
        break;
        
    case WM_EXITSIZEMOVE:
        _DragLeave(-1, -1, TRUE);
        ASSERT(_fDragging == 0);

        break;

    case WM_CHILDACTIVATE:
        if (_eMode == WBM_BFLOATING)
            SendMessage(_hwnd, WM_MDIACTIVATE, (WPARAM)_hwnd, 0);
        goto DoDefault;
        
    case WM_WINDOWPOSCHANGING:
        _HandleWindowPosChanging((LPWINDOWPOS)lParam);
        break;

    case WM_WINDOWPOSCHANGED:
Lfwdappbar:
        if (_fAppRegistered)
            _AppBarOnWM(uMsg, wParam, lParam);
        goto DoDefault;        // fwd on so we'll get WM_SIZE etc.

    case WM_TIMER:
        switch (wParam) {

        case IDT_AUTOHIDE:
            {
                ASSERT(_fWantHide && _fCanHide);

                GetCursorPos(&pt);
                GetWindowRect(hwnd, &rc);
                // add a bit of fudge so we don't hide when trying to grab the edge
                InflateRect(&rc, GetSystemMetrics(SM_CXEDGE) * 4,
                    GetSystemMetrics(SM_CYEDGE)*4);

                HWND hwndAct = GetActiveWindow();

                if (!PtInRect(&rc, pt) && hwndAct != hwnd &&
                  (hwndAct == NULL || ::GetWindowOwner(hwndAct) != hwnd))
                  {
                    // to hide, we need to be outside the inflated window,
                    // and we can't be active (for keyboard users).
                    // (heuristics stolen from tray.c)
                    // FEATURE: tray.c also checks TM_SYSMENUCOUNT == 0

                    _DoHide(AHO_KILLDO|AHO_MOVEDO);
                }
            }
            break;

        case IDT_AUTOUNHIDE:    // FEATURE: share code w/ IDT_AUTOHIDE
            ASSERT(_fWantHide && _fCanHide);

            if (_fHiding)
            {
                ASSERT(_fHiding == HIDE_AUTO);
                GetCursorPos(&pt);
                GetWindowRect(hwnd, &rc);
                if (PtInRect(&rc, pt))
                    _DoHide(AHO_KILLUN|AHO_MOVEUN|AHO_SETDO);
                else
        Lkillun:
                    _DoHide(AHO_KILLUN);
            }
            else
            {
                // if we mouse-over and then TAB very quickly, we can end
                // up getting a WM_ACT followed by a WM_TIMER (despite the
                // KillTimer inside OnAct).  if so we need to be careful
                // not to do an AHO_SETDO.  just to be safe we do an
                // AHO_KILLUN as well.
                TraceMsg(DM_HIDE, "cwb.WM_T: !_fHiding (race!) => AHO_KILLUN");
                goto Lkillun;
            }
            break;

        default:
            goto DoDefault;
        }

        break;

    case WM_NCLBUTTONDOWN:
    case WM_LBUTTONDOWN:
        goto DoDefault;


    case WM_ACTIVATE:
        _OnActivate(wParam, lParam);
        goto Lfwdappbar;

    case WM_GETMINMAXINFO:  // prevent it from getting too small
        // n.b. below stuff works for scheme 'win standard large'
        // but not for v. large edges.  not sure why, but we'll
        // have to fix it or the original bug will still manifest
        // on accessibility-enabled machines.

        // nt5:149535: resize/drag of v. small deskbar.
        // APPCOMPAT workaround USER hittest bug for v. small windows.
        // DefWndProc(WM_NCHITTEST) gives wrong result (HTLEFT) when
        // window gets too small.  so stop it from getting v. small.
        //
        // the below calc actually gives us slightly *more* than the
        // min size, but what the heck.  e.g. it gives 8+15+1=24,
        // whereas empirical tests give 20.  not sure why there's a
        // diff, but we'll use the bigger # to be safe.
        {
            RECT rcTmp = {100,100,100,100}; // arbitrary 0-sized rect
            LONG ws, wsx;
            HWND hwndTmp;

            _GetStyleForMode(_eMode, &ws, &wsx, &hwndTmp);
            AdjustWindowRectEx(&rcTmp, ws, FALSE, wsx);

            ((MINMAXINFO *)lParam)->ptMinTrackSize.x = RECTWIDTH(rcTmp)  + CXSMSIZE() + 1;
            ((MINMAXINFO *)lParam)->ptMinTrackSize.y = RECTHEIGHT(rcTmp) + CYSMSIZE() + 1;
            if (ISWBM_FLOAT(_eMode))
            {
                // nt5:169734 'close' button on v. small floating deskbar.
                // APPCOMPAT workaround USER 'close' button bug for v. small windows.
                // the button on a v. small TOOLWINDOW doesn't work.
                // empirically the below adjustment seems to work.
                ((MINMAXINFO *)lParam)->ptMinTrackSize.x += (CXSMSIZE() + 1) * 3 / 2;
                ((MINMAXINFO *)lParam)->ptMinTrackSize.y += (CYSMSIZE() + 1) * 3 / 2;
            }
            TraceMsg(DM_TRACE, "cwb.GMMI: x=%d", ((MINMAXINFO *)lParam)->ptMinTrackSize.x);
        }
        break;

    case WM_NCHITTEST:
        return _OnNCHitTest(wParam, lParam);

    case WM_WININICHANGE:
        // Active Desktop *broadcasts* a WM_WININICHANGE SPI_SETDESKWALLPAPER
        // message when starting up. If this message gets processed during
        // startup at just the right time, then the bands will notify their
        // preferred state, and we lose the persisted state.  Since the desktop
        // wallpaper changing is really of no interest to us, we filter it out here.
        //
        // REVIEW CDTURNER: Would we get a perf win by punting a larger class
        // of these wininichange messages? It seems like most won't affect
        // the contents of a deskbar...
        //
        if (SPI_SETDESKWALLPAPER == wParam)
            break;

        goto DoDefault;
        
    default:
DoDefault:
        return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
    }

    return lres;
}

LRESULT CDockingBar::_OnNCHitTest(WPARAM wParam, LPARAM lParam)
{
    if (_fHiding)
        _DoHide(AHO_SETUN);

    // get 'pure' hittest...
    LRESULT lres = _CalcHitTest(wParam, lParam);

    // ... and perturb it based on where we're docked
    BOOL fSizing = FALSE;
    if (ISWBM_FLOAT(_eMode)) {
        // standard sizing/moving behavior
        return lres;
    }
    else {
        // opposing edge sizes; any other edge moves
        ASSERT(ISABE_DOCK(_uSide));
        switch (_uSide) {
        case ABE_LEFT:
            //  
            // Mirror the edges (since we are dealing with screen coord)
            // if the docked-window parent is mirrored. [samera]
            //
            if (IS_WINDOW_RTL_MIRRORED(GetParent(_hwnd)))
                fSizing = (lres==HTLEFT);
            else
                fSizing = (lres==HTRIGHT);
            break;
        case ABE_RIGHT:
            //  
            // Mirror the edges (since we are dealing with screen coord)
            // if the docked-window parent is mirrored.
            //
            if (IS_WINDOW_RTL_MIRRORED(GetParent(_hwnd)))
                fSizing = (lres==HTRIGHT);
            else
                fSizing = (lres==HTLEFT);
            break;
        case ABE_TOP:
            fSizing = (lres==HTBOTTOM);
            break;
        case ABE_BOTTOM:
            fSizing = (lres==HTTOP);
            break;

        default: 
            ASSERT(0); 
            break;
        }
    }

    if (!fSizing) {
        lres = HTCAPTION;
    }
    return lres;
}

//***   _OnActivate --
//
void CDockingBar::_OnActivate(WPARAM wParam, LPARAM lParam)
{
    TraceMsg(DM_HIDE, "cwb.WM_ACTIVATE wParam=%x", wParam);
    if (_fCanHide) {
        ASSERT(_fHiding != HIDE_MANUAL);
        if (LOWORD(wParam) != WA_INACTIVE) {
            // activate
            TraceMsg(DM_HIDE, "cdb._oa:  WM_ACT(act) _fHiding=%d", _fHiding);
            // turn off timers for perf
            // nash:40992: unhide if hidden (e.g. TABed to hidden)
            _DoHide(AHO_KILLDO|AHO_MOVEUN);
        }
        else {
            // deactivate
            _DoHide(AHO_SETDO);         // restore
        }
    }

    return;
}

/***
 */
CDockingBar::CDockingBar() : _eMode(WBM_NIL), _uSide(ABE_RIGHT)
{
    ASSERT(_fIdtUnHide == FALSE);
    ASSERT(_fIdtDoHide == FALSE);
    _ptIdtUnHide.x = _ptIdtUnHide.y = -1;

    // set up worst-case defaults.  we'll end up using them for:
    //     - some of them for Load(bag)
    //     - all  of them for InitNew()
    // note that we might call _InitPos4 again in SetSite.
    _InitPos4(TRUE);

    return;
}

//***   _Initialize -- 2nd-phase ctor
// NOTES
//  we need any IPS::Load settings and also a site before we can init
//  ourself, so most initialization waits until here.
void CDockingBar::_Initialize()
{
    ASSERT(!_fInitShowed);
    ASSERT(_fInitSited && _eInitLoaded);
    ASSERT(!CDB_INITED());

    _fInitShowed = TRUE;

    // warning: delicate phase-ordering here...
    UINT eModeNew = _eMode;
    _eMode = WBM_NIL;
    UINT uSideNew = _uSide;
    _uSide = ABE_NIL;
    HMONITOR hMonNew = _hMon;
    _hMon = NULL;
    // 48463: beta reports fault on boot when we have deskbar+taskbar on
    // same edge (non-merged).  i'm guessing (no proof) that shdocvw isn't
    // init'ed enough early on during boot to handle doing a MergeBS, or
    // alternately that there's a race btwn the tray and desktop threads.
    //
    // plus in any case we shouldn't do the merge just because the guy did
    // a logoff/logon!
    _SetModeSide(eModeNew, uSideNew, hMonNew, /*fNoMerge*/_eInitLoaded == IPS_LOAD);

    _NotifyModeChange(0);

    // if we have a bar on the right and we drag a band from it to
    // the top, we end up getting a sequence:
    //      create deskbar; AddBand; SetSite; _Initialize
    // the AddBand of the (1st) band tries to do an autosize but
    // there's no site yet, so nothing happens.
    //
    // so we need to force it here.
    _AdjustToChildSize();

    if (_fWantHide) {
        _fWantHide = FALSE;
        _AppBarOnCommand(IDM_AB_AUTOHIDE);
    }

    ASSERT(CDB_INITED());

    return;
}

/***
 */
CDockingBar::~CDockingBar()
{
    ASSERT(!_fAppRegistered);   // make sure _ChangeTopMost(WBM_NIL) was called

    // make sure SetSite(NULL); was called
    ASSERT(!_ptbSite);
    return;
}


void CDockingBar::_GetChildPos(LPRECT prc)
{
    GetClientRect(_hwnd, prc);
}

//***   _OnSize -- compute size for OC, leaving room for toolbar (caption?)
//
void CDockingBar::_OnSize(void)
{
    RECT rc;

    if (!_hwndChild || !_eInitLoaded)
        return;

    ASSERT(IsWindow(_hwndChild));

    // don't resize on a hide (it's temporary and we don't want things
    // to jerk around or worse still do a destructive reformat)
    // APPCOMPAT: should suppress resizing here in theater mode autohide
    // too (see theater.cpp)
    if (_fHiding)
        return;

    _GetChildPos(&rc);
    // (used to do ISWBM_EDGELESS 'fake edge' adjustments here, someone
    // nuked them, but should be o.k. now that visuals are frozen *provided*
    // we don't go back to edgeless)

    SetWindowPos(_hwndChild, 0,
            rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
            SWP_NOACTIVATE|SWP_NOZORDER);
    //ASSERT(DbCheckWindow(_hwndChild, &rc, xxx));
}

//***   _CalcHitTest --
// NOTES
//      really only has to return an int (win16?)
LRESULT CDockingBar::_CalcHitTest(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet;

    if (!(ISWBM_BOTTOM(_eMode) && ISWBM_EDGELESS(_eMode))) {
        // For non-btmmost, we can ask USER to perform the default
        // hit testing.
        lRet = DefWindowProcWrap(_hwnd, WM_NCHITTEST, wParam, lParam);
    } else {
        // For btmmost, we need to do it.
        // (possibly dead code if bottom is never edgeless)
        // (if so, compiler should optimize it out)

        //TraceMsg(DM_WARNING, "cdb.ro: edgeless!");

        RECT rc;
        GetWindowRect(_hwnd, &rc);
        UINT x = GET_X_LPARAM(lParam);
        UINT y = GET_Y_LPARAM(lParam);
        // actually SM_C?SIZEFRAME is too big, but we get away w/ it
        // since we've been initiated by a WM_NCHITTEST so we know
        // we're on *some* edge
        UINT cx = GetSystemMetrics(SM_CXSIZEFRAME);
        UINT cy = GetSystemMetrics(SM_CYSIZEFRAME);
        if (_eMode == WBM_BBOTTOMMOST)
            cx *= 2;

        lRet = HTCAPTION;
        if (x > rc.right-cx) {
            lRet = HTRIGHT;
        } else if (x < rc.left+cx) {
            lRet = HTLEFT;
        } else if (y < rc.top+cy) {
            lRet = HTTOP;
        } else if (y > rc.bottom-cy) {
            lRet = HTBOTTOM;
        }
    }

    return lRet;
}

//***
//
void CDockingBar::_DragEnter(UINT uMsg, int x, int y, RECT* rcFeed)
{
    ASSERT(_fDragging == 0);

    if ((!(_eMode & WBM_FLOATING)) && uMsg == WM_MOVING)
    {
        // APPCOMPAT workaround USER non-full-drag drag rect bug
        // by forcing rcFeed back to exact current location (rather than
        // leaving at initial offset that USER gave us).
        //
        // w/o this code a drag from right to top in non-full-drag mode
        // will leave drag-rect droppings at the top of the original
        //
        // APPCOMPAT but, this seems to make things *worse* if !ISWBM_DESKTOP(),
        // so we don't do it in that case...  (sigh).
        _MoveSizeHelper(_eMode, _uSide, _hMon, NULL, rcFeed, FALSE, FALSE);
    }

    _eModePending = _eMode;
    _uSidePending = _uSide;
    _xyPending = MAKELPARAM(x, y);
    _hMonPending = _hMon;
    ASSERT(rcFeed != 0);
    if (rcFeed != 0)
        CopyRect(&_rcPending, rcFeed);

#if XXX_CANCEL
    RECT rcTmp;

    GetWindowRect(_hwnd, &rcTmp);
    TraceMsg(DM_DRAG2,
        "cwb.de: rcTmp=(%d,%d,%d,%d) (%dx%d) _rcCapture=(%d,%d,%d,%d) (%dx%d)",
        rcTmp.left, rcTmp.top, rcTmp.right, rcTmp.bottom,
        RECTWIDTH(rcTmp), RECTHEIGHT(rcTmp),
        _rcCapture.left, _rcCapture.top, _rcCapture.right, _rcCapture.bottom,
        RECTWIDTH(_rcCapture), RECTHEIGHT(_rcCapture));
#endif

    switch (uMsg) {
    case WM_MOVING: _fDragging = DRAG_MOVE; break;
    case WM_SIZING: _fDragging = DRAG_SIZE; break;

    default: ASSERT(0); break;
    }

    if (_fDragging == DRAG_MOVE) {
        // turn off size negotiation to prevent horz/vert pblms.
        //
        // e.g. when we drag a floating guy to horz/vert, there's
        // a period of time during which we have a horz/vert size,
        // but still think we're floating, which screws up size
        // negotiation royally.
        _ExecDrag(DRAG_MOVE);
    }

    return;
}

//***
//
void CDockingBar::_DragTrack(UINT uMsg, int x, int y, RECT* rcFeed, int eState)
{
#if DM_API
    TraceMsg(DM_DRAG2,
        "cwb.dt: API s=%d xy=(%d,%d) rc=(%d,%d,%d,%d) (%dx%d)",
        eState, x, y,
        _PM(rcFeed,left), _PM(rcFeed,right), _PM(rcFeed,bottom), _PM(rcFeed,right),
        _PX(rcFeed,RECTWIDTH(*rcFeed)), _PX(rcFeed,RECTHEIGHT(*rcFeed)));
#endif

    ASSERT(_fDragging != 0);

    switch (eState) {
    case 0:     // WM_MOVING
        {
            BOOL fImmediate = ((!_fDesktop) && uMsg == WM_SIZING) ? TRUE:FALSE;

            // remember for eventual commit
            _xyPending = MAKELPARAM(x, y);
            ASSERT(rcFeed != NULL);
            CopyRect(&_rcPending, rcFeed);

            // snap and give feedback
            _TrackSliding(x, y, rcFeed, fImmediate, fImmediate);

            break;
        }
    case 1:     // WM_MOVE
        TraceMsg(DM_DRAG2,
            "cwb.dt: %s _xyPend=(%d,%d) xy=(%d,%d)",
            (_xyPending != MAKELPARAM(x, y)) ? "noop/cancel" : "commit",
            GET_X_LPARAM(_xyPending), GET_Y_LPARAM(_xyPending), x, y);

        break;

    default: ASSERT(0); break;
    }

    return;
}

//***
//
void CDockingBar::_DragLeave(int x, int y, BOOL fCommit)
{
#if DM_API
    TraceMsg(DM_DRAG,
        "cwb.dl: API xy=(%d,%d) fCommit=%d",
        x, y, fCommit);
#endif

    if (_fDragging == 0) {
        // when we're inside a browser and you move the browser window
        // we get WM_ENTERSIZEMOVE/ WM_EXITSIZEMOVE but never any
        // WM_MOVING/WM_MOVE/WM_SIZING/WM_SIZE
        return;
    }

    switch (_fDragging) {
    case DRAG_MOVE:
    case DRAG_SIZE:
        break;
    default: ASSERT(0); break;
    }

#if XXX_CANCEL
    RECT rcTmp;

    GetWindowRect(_hwnd, &rcTmp);
    TraceMsg(DM_DRAG2,
        "cwb.dl: rcTmp=(%d,%d,%d,%d) (%dx%d) _rcCapture=(%d,%d,%d,%d) (%dx%d)",
        rcTmp.left, rcTmp.top, rcTmp.right, rcTmp.bottom,
        RECTWIDTH(rcTmp), RECTHEIGHT(rcTmp),
        _rcCapture.left, _rcCapture.top, _rcCapture.right, _rcCapture.bottom,
        RECTWIDTH(_rcCapture), RECTHEIGHT(_rcCapture));
    TraceMsg(DM_DRAG2, "cwb.dl: %s",
        EqualRect(&rcTmp, &_rcCapture) ? "noop/cancel" : "commit");
#endif

    BOOL fCancel = FALSE;       // FEATURE: todo: cancel NYI

    if (!fCancel) {
        if (_fDragging == DRAG_MOVE) {
            // nt5:187720 do this *before* the final move.
            // o.w. addr band ends up w/ 80-high default rather than
            // snapped to correct/negotiated size.
            //
            // why are we able to turn this on here when in general it
            // had to be off during the drag?  well, the preview of the
            // drag went thru MoveSizeHelper which did a NotifyModeChange
            // which told our client what its orientation really is.  so
            // by now things should be in sync.

            // size negotiation had been turned off (to prevent horz/vert
            // pblms).  turn it on before the final move so that we'll
            // recalc correctly.
            _ExecDrag(0);
        }

        // (we're done w/ _rcPending so o.k. to pass it in and trash it)
        // fMove==TRUE even though USER has already done the move for us,
        // since it's only done the move not the resize (?).  if we use
        // fMove==FALSE we end up in the new location but w/ the old size,
        // despite the fact that rcFeed has been updated along the way.
        // this is because USER sets SWP_NOSIZE when it does the move.
        _TrackSliding(GET_X_LPARAM(_xyPending), GET_Y_LPARAM(_xyPending),
            &_rcPending, TRUE, TRUE);

        // if we got a preferred child sizewhild dragging, set ourselves to that now.
        // sizing up   (cx > min), _szChild.cx == 0 and call a noop.
        // sizing down (cx < min), _szChild.cx != 0 and call does something.
        //ASSERT(_szChild.cx == 0);   // 0 => _AdjustToChildSize is nop
        _AdjustToChildSize();
    }
    else {
        _MoveSizeHelper(_eMode, _uSide, _hMon, NULL, NULL, TRUE, FALSE);   // FEATURE: fMove?
    }

    _fDragging = 0;
    
    return;
}

#ifdef DEBUG
int g_dbNoExecDrag = 0;     // to play w/ ExecDrag w/o recompiling
#endif

void DBC_ExecDrag(IUnknown *pDBC, int eDragging)
{
    VARIANTARG vaIn = {0};      // VariantInit

    ASSERT(eDragging == DRAG_MOVE || eDragging == 0);

#ifdef DEBUG
    if (g_dbNoExecDrag)
        return;
#endif

    vaIn.vt = VT_I4;
    vaIn.lVal = eDragging;      // n.b. currently only 0/1 is supported 
    IUnknown_Exec(pDBC, &CGID_DeskBarClient, DBCID_ONDRAG, OLECMDEXECOPT_DONTPROMPTUSER, &vaIn, NULL);
    // VariantClear

    return;
}

void CDockingBar::_ExecDrag(int eDragging)
{
    DBC_ExecDrag(_pDBC, eDragging);
    return;
}

//***   _Recalc -- force recalc using current settings
//
void CDockingBar::_Recalc(void)
{
    _MoveSizeHelper(_eMode, _uSide, _hMon, NULL, NULL, TRUE, TRUE);
    return;
}

//***   _MoveSizeHelper -- shared code for menu and dragging forms of move/size
//
void CDockingBar::_MoveSizeHelper(UINT eModeNew, UINT eSideNew, HMONITOR hMonNew,
    POINT* ptTrans, RECT* rcFeed, BOOL fCommit, BOOL fMove)
{
    UINT eModeOld, eSideOld;

    RECT rcNew;

    // only desktop guys can go to TOPMOST
    ASSERT(eModeNew != WBM_TOPMOST || ISWBM_DESKTOP());

    eModeOld = _eMode;
    eSideOld = _uSide;

    ASSERT(CHKWBM_CHANGE(eModeNew, _eMode));
    _eModePending = eModeNew;   // for drag feedback, before commit
    _uSidePending = eSideNew;
    _hMonPending = hMonNew;

    if (fCommit)
    {
        // we need to be careful when we call _ChangeHide or we'll recurse
        BOOL fChangeHide = (_fWantHide &&
            (eSideNew != _uSide || eModeNew != _eMode || hMonNew != _hMon));

        if (fChangeHide)
            _DoHide(AHO_KILLDO|AHO_UNREG);

        _SetModeSide(eModeNew, eSideNew, hMonNew, FALSE);

        if (fChangeHide)
        {
            // don't do AHO_SETDO now, wait for WM_ACTIVATE(deactivate)
            _DoHide(AHO_REG);
        }
    }

    // negotiate (and possibly commit to negotiation)
    _ProtoRect(&rcNew, eModeNew, eSideNew, hMonNew, ptTrans);
    _NegotiateRect(eModeNew, eSideNew, hMonNew, &rcNew, fCommit);

    // commit
    if (fCommit)
        _SetVRect(&rcNew);

    // feedback
    if (rcFeed != 0)
    {
        CopyRect(rcFeed, &rcNew);
    }
    
    if (fMove)
    {
        // If we're in theater mode, out parent manages our width and
        // horizontal position, unless we're being forced to a new
        // size by szChild.
        if (_fTheater && !_fDragging)
        {
            RECT rcCur;
            GetWindowRect(_hwnd, &rcCur);
            rcNew.left = rcCur.left;
            rcNew.right = rcCur.right;
        }

        // aka ScreenToClient
        MapWindowPoints(HWND_DESKTOP, GetParent(_hwnd), (POINT*) &rcNew, 2);
        
        if (_fCanHide && eModeNew == eModeOld && eSideNew == eSideOld)
        {
            // if we're [un]hiding to the same state, we can do SlideWindow
            ASSERT(ISWBM_HIDEABLE(eModeNew));
            DAD_ShowDragImage(FALSE);   // unlock the drag sink if we are dragging.
            SlideWindow(_hwnd, &rcNew, _hMon, !_fHiding);
            DAD_ShowDragImage(TRUE);    // restore the lock state.
        }
        else
        {
            MoveWindow(_hwnd, rcNew.left, rcNew.top,
                       RECTWIDTH(rcNew), RECTHEIGHT(rcNew), TRUE);
        }
    }

    // WARNING: rcNew is no longer in consistent coords! (ScreenToClient)

    // notify the child of changes
    _NotifyModeChange(0);
}

void CDockingBar::_NotifyModeChange(DWORD dwMode)
{
    UINT eMode, uSide;

    eMode = ((_fDragging == DRAG_MOVE) ? _eModePending : _eMode);
    uSide = ((_fDragging == DRAG_MOVE) ? _uSidePending : _uSide);
    //hMon = ((_fDragging == DRAG_MOVE) ? _hMonPending : _hMon);

    if (ISWBM_FLOAT(eMode))
        dwMode |= DBIF_VIEWMODE_FLOATING;
    else if (!ABE_HORIZ(uSide))
        dwMode |= DBIF_VIEWMODE_VERTICAL;

    SUPERCLASS::_NotifyModeChange(dwMode);
    
}

void CDockingBar::_TrackSliding(int x, int y, RECT* rcFeed,
    BOOL fCommit, BOOL fMove)
{
    TraceMsg(DM_DRAG2,
        "cwb.ts: _TrackSliding(x=%d, y=%d, rcFeed=(%d,%d,%d,%d)(%dx%d), fCommit=%d, fMove=%d)",
        x, y,
        _PM(rcFeed,left), _PM(rcFeed,top), _PM(rcFeed,right), _PM(rcFeed,bottom),
        _PX(rcFeed,RECTWIDTH(*rcFeed)), _PX(rcFeed,RECTHEIGHT(*rcFeed)),
        fCommit, fMove);

    POINT pt = { x, y };
    UINT eModeNew, uSideNew;
    HMONITOR hMonNew;
    if (_fDragging == DRAG_MOVE) {
        // moving...

        if (fCommit) {
            // use last feedback position.
            // o.w. (if we recompute) we end up in the wrong place since
            // WM_MOVE gives us the (left,top), which often is in another
            // docking zone.
            ASSERT(x == GET_X_LPARAM(_xyPending) && y == GET_Y_LPARAM(_xyPending));
            //eModeNew = _eModePending;
            //uSideNew = _uSidePending;
        }

        //
        // figure out snap position,
        // and do a few special-case hacks to fix it up if necessary
        //
        uSideNew = _CalcDragPlace(pt, &hMonNew);
        if (uSideNew == ABE_XFLOATING) {
            // dock->float or float->float
            eModeNew = _eMode | WBM_FLOATING;
            uSideNew = _uSide;          // FEATURE: _uSidePending? This seems to work correctly as is.
        }
        else {
            // float->dock or dock->dock
            eModeNew = _eMode & ~WBM_FLOATING;
        }

        TraceMsg(DM_DRAG2,
            "cwb.ts: (m,s) _x=(%d,%d) _xPend=(%d,%d) xNew=(%d,%d)",
            _eMode, _uSide, _eModePending, _uSidePending, eModeNew, uSideNew);

        // 970725: we now allow bottom->float (for the desktop, not browser)
        if (ISWBM_FLOAT(eModeNew) && ISWBM_BOTTOM(_eMode) && !ISWBM_DESKTOP()) {
            // special case: don't allow switch from BTMMOST to FLOATING
            ASSERT(CHKWBM_CHANGE(eModeNew, _eMode));
            eModeNew = _eModePending;   // the dead zone...
            uSideNew = _uSidePending;   // QUESTION: init case?
            hMonNew = _hMonPending;
            TraceMsg(DM_DRAG2,
                "cwb.ts: (m,s) btm->flt override     xNew=(%d,%d)",
                eModeNew, uSideNew);
            ASSERT(!ISWBM_FLOAT(eModeNew));
        }

        //
        // smooth things out so we don't jump around
        //
        _SmoothDragPlace(eModeNew, uSideNew, hMonNew, &pt, rcFeed);

        //
        // now do the move
        //
        // | with _eMode & WBMF_BROWSER because dragging around doesn't change the
        // browser owned bit
        _MoveSizeHelper(eModeNew | (_eMode & WBMF_BROWSER), uSideNew, hMonNew, 
            ISWBM_FLOAT(eModeNew) ? &pt : NULL, rcFeed, fCommit, fMove);
    }
    else {
        ASSERT(_fDragging == DRAG_SIZE);

        // truncate to max size if necessary
        _SmoothDragPlace(_eMode, _uSide, _hMon, NULL, rcFeed);

        if (!fCommit) {
            // USER does everything for us
            return;
        }
        ASSERT(MAKELPARAM(x, y) != XY_NIL);

        // APPCOMPAT: we're gonna commit so just blast it in here...
        RECT rcNew;

        GetWindowRect(_hwnd, &rcNew);   // PERF: already set?
        _SetVRect(&rcNew);
        _MoveSizeHelper(_eMode, _uSide, _hMon,
            NULL, NULL,                 // FEATURE: &rcNew?
            fCommit, fMove);
    }

    return;
}

/***    _CalcDragPlace -- compute where drag will end up
 * NOTES
 *      FEATURE: prelim version
 */
UINT CDockingBar::_CalcDragPlace(POINT& pt, HMONITOR * phMon)
{
    TraceMsg(DM_DRAG2,
        "cwb.cdp: _CalcDragPlace(pt=(%d,%d))",
        pt.x, pt.y);

    SIZE screen, error;
    UINT uHorzEdge, uVertEdge, uPlace;
    RECT rcDisplay = {0};  // _GetBorderRect doesn't always set rect.

    // Get the correct hMonitor.
    ASSERT(phMon);
    *phMon = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);
    // FEATURE: todo: make hwndSite and rcDisplay args, then this can be
    // a generic helper func
    _GetBorderRect(*phMon, &rcDisplay);

    // if we're outside our 'parent' (browser or desktop), we float.
    // this really only applies to the browser case, since we'll never
    // be outside the desktop (what about multi-monitor?).
    if (!PtInRect(&rcDisplay, pt) || !_ptbSite) {
        TraceMsg(DM_DRAG2,
            "cwb.cdp: pt=(%d,%d) uSideNew=%u",
            pt.x, pt.y, ABE_XFLOATING);
        return ABE_XFLOATING;
    }

    // if we're not w/in min threshhold from edge, we float
    {
        RECT rcFloat;   // FEATURE can just use rcDisplay
        int cx = CXFLOAT();
        int cy = CYFLOAT();

        CopyRect(&rcFloat, &rcDisplay);
        InflateRect(&rcFloat, -cx, -cy);

        if (PtInRect(&rcFloat, pt)) {
            TraceMsg(DM_DRAG2,
                "cwb.cdp: pt=(%d,%d) uSideNew=%u",
                pt.x, pt.y, ABE_XFLOATING);
            return ABE_XFLOATING;
        }
    }

    //
    // re-origin at zero to make calculations simpler
    //
    screen.cx =  RECTWIDTH(rcDisplay);
    screen.cy = RECTHEIGHT(rcDisplay);
    pt.x -= rcDisplay.left;
    pt.y -= rcDisplay.top;

    //
    // are we closer to the left or right side of this display?
    //
    if (pt.x < (screen.cx / 2)) {
        uVertEdge = ABE_LEFT;
        error.cx = pt.x;
    }
    else {
        uVertEdge = ABE_RIGHT;
        error.cx = screen.cx - pt.x;
    }

    //
    // are we closer to the top or bottom side of this display?
    //
    if (pt.y < (screen.cy / 2)) {
        uHorzEdge = ABE_TOP;
        error.cy = pt.y;
    }
    else {
        uHorzEdge = ABE_BOTTOM;
        error.cy = screen.cy - pt.y;
    }

    //
    // closer to a horizontal or vertical edge?
    //
    uPlace = ((error.cy * screen.cx) > (error.cx * screen.cy))?
        uVertEdge : uHorzEdge;

    TraceMsg(DM_DRAG2,
        "cwb.cdp: pt=(%d,%d) uSideNew=%u",
        pt.x, pt.y, uPlace);

    return uPlace;
}

//***   _SmoothDragPlace -- do some magic to smooth out dragging
// ENTRY/EXIT
//      eModeNew        where we're snapping to
//      eSideNew        ...
//      [_eModePending] where we're snapping from
//      [_eSidePending] ...
//      pt              INOUT cursor position
//      rcFeed          USER's original drag feedback rect
// NOTES
//      this is the place to put excel-like heuristics.  e.g. when coming
//      back off the right side we could put the cursor at the top right of
//      the floating rect (rather than the top left) to allow us to float
//      as close as possible to the other side w/o docking.  hmm, but how
//      would we tell USER where to put the cursor...
//
void CDockingBar::_SmoothDragPlace(UINT eModeNew, UINT eSideNew, HMONITOR hMonNew,
    INOUT POINT* pt, RECT* rcFeed)
{
    if (_fDragging == DRAG_MOVE) {
        if (ISWBM_FLOAT(eModeNew) && ISWBM_FLOAT(_eModePending) && rcFeed != 0 && pt) {
            // use the feedback rect from USER to keep things smooth.
            // o.w. if we use the cursor position we'll jump at the
            // beginning (to move the left-top corner to the starting
            // cursor position).
            pt->x = rcFeed->left;
            pt->y = rcFeed->top;
        }
    }
    else {
        ASSERT(_fDragging == DRAG_SIZE);
        ASSERT(eModeNew == _eMode && eSideNew == _uSide && hMonNew == _hMon);
        if (!ISWBM_FLOAT(_eMode)) {
            // truncate to max size (1/2 of screen) if necessary

            int iWH;
            RECT rcScreen;

            // we'd like to use 1/2 of browser, not 1/2 of screen.  however
            // this causes pblms if you maximize, grow to 1/2, and restore.
            // then the 1st time you resize the bar it 'jumps' down to 1/2
            // of the *current* size from 1/2 of the old size.  kind of a
            // hack, sigh...
            //
            // also note that there's still a bug here: if you size down
            // the browser gradually, we don't go thru this logic, so you
            // end up w/ a bar width > browser width so you the right edge
            // is clipped and there's no way to size it down.  probably
            // when the browser resize is done we should re-smooth the bar.
            //_GetBorderRect(_hMon, &rcScreen);
            GetMonitorRect(_hMon, &rcScreen);   // aka GetSystemMetrics(SM_CXSCREEN)
            iWH = RECTGETWH(_uSide, &rcScreen);
            iWH /= 2;
            if (RECTGETWH(_uSide, rcFeed) > iWH) {
                TraceMsg(DM_TRACE, "cwb.sdp: truncate iWH'=%d", iWH);
                RectXform(rcFeed, RX_OPPOSE, rcFeed, NULL, iWH, _uSide, NULL);
            }
        }
    }

    return;
}

/***
 */
LRESULT CDockingBar::_OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    if (_CheckForwardWinEvent(uMsg, wParam, lParam, &lres))
        return lres;
    
    if ((Command_GetID(wParam) <= IDM_AB_LAST) &&
        (Command_GetID(wParam) >= IDM_AB_FIRST)) {
        _AppBarOnCommand(Command_GetID(wParam));
    }

    return lres;
}

/***    CDockingBar::_AppBarRegister -- register/unregister AppBar
 * DESCRIPTION
 *      updates _fAppRegistered
 *      does nothings if it's already regisrered or unregistered
 */
void CDockingBar::_AppBarRegister(BOOL fRegister)
{
    APPBARDATA abd;

    abd.cbSize = sizeof(APPBARDATA);
    abd.hWnd = _hwnd;

    if (fRegister && !_fAppRegistered) {
        abd.uCallbackMessage = APPBAR_CALLBACK;
        TraceMsg(DM_APPBAR, "cwb.abr: call ABM_NEW");
        UINT_PTR bT = SHAppBarMessage(ABM_NEW, &abd);
        ASSERT(bT);
        if (bT) {
            _fAppRegistered = TRUE;

            // fake a callback to set initial state
            // #if XXX_TASKMAN
            TraceMsg(DM_APPBAR, "cwb.abr: fake ABN_STATECHANGE");
            _AppBarCallback(_hwnd, APPBAR_CALLBACK, ABN_STATECHANGE, 0);
            // #endif
        }
    }
    else if (!fRegister && _fAppRegistered) {
        TraceMsg(DM_APPBAR, "cwb.abr: call ABM_REMOVE");
        // n.b. sensitive phase ordering, must set flag before send message
        // since the message causes a bunch of callbacks
        _fAppRegistered = FALSE;
        SHAppBarMessage(ABM_REMOVE, &abd);
    }
}

//***   _SetVRect -- set our 'virtual rect' to reflect window state
//
void CDockingBar::_SetVRect(RECT* rcNew)
{
    UINT eModeNew, uSideNew;

    //ASSERT(_fDragging == 0);  // o.w. we should look at _xxxPending

    eModeNew = _eMode;
    uSideNew = _uSide;


    if (_fHiding && ISWBM_HIDEABLE(eModeNew)) {
        TraceMsg(DM_HIDE, "cwb.svr: _fHiding => suppress rcNew=(%d,%d,%d,%d)",
            rcNew->left, rcNew->top, rcNew->right, rcNew->bottom);
        return;
    }


    if (ISWBM_FLOAT(eModeNew)) {
        CopyRect(&_rcFloat, rcNew);
    }
    else {
        _adEdge[uSideNew] = ABE_HORIZ(uSideNew) ? RECTHEIGHT(*rcNew) : RECTWIDTH(*rcNew);
    }
    return;
}

//***   _ChangeTopMost -- switch back and forth btwn TopMost and BottomMost
// ENTRY/EXIT
//      eModeNew        new mode we're switching to
//
void CDockingBar::_ChangeTopMost(UINT eModeNew)
{
    BOOL fShouldRegister = (eModeNew & WBM_TOPMOST) && !(eModeNew & WBM_FLOATING);
    
    // here's what's legal...
//              to...................
// from         btm     top     float
// ----         ---     ---     -----
// btm(desk)    -       top+    y(1)    (1) force to top
// top          top-    -       'undock'
// float        y(2)    'dock'  -       (2) force to right
// btm(app)     -       x(3)    y(4)    (3) foster child (4) 'owned' window


#if 0
    // (1,4) going from BTMMOST to FLOATING is illegal (and NYI) unless desktop
    ASSERT(eModeNew != WBM_FLOATING || _eMode != WBM_BOTTOMMOST || ISWBM_DESKTOP());
#endif

    // (3) only desktop guys can go to TOPMOST
    ASSERT(eModeNew != WBM_TOPMOST || ISWBM_DESKTOP());

    // _uSide should always be laying around (even if floating)
    ASSERT(_eMode == WBM_NIL || ISABE_DOCK(_uSide));

    // note the ordering here, make sure window bits are right
    // before doing resume new or else new will have unexpected state
    _ChangeWindowStateAndParent(eModeNew);
    _eMode = eModeNew;
    _ChangeZorder();

    // resume new
    switch (_eMode) {
    case WBM_NIL:
        // dummy state for termination
        return;

    case WBM_BOTTOMMOST:
        _ResetZorder();
#if ! XXX_BROWSEROWNED
        // fall through
    case WBM_BBOTTOMMOST:
#endif
        break;
    }
    
    _AppBarRegister(fShouldRegister);
}

//***   _ChangeZorder -- set z-order appropriately
// NOTES
//  currently doesn't account for 'raised' mode (i.e. caller must call
//  _ChangeZorder before _ResetZorder)
void CDockingBar::_ChangeZorder()
{
    BOOL fWantTopmost = BOOLIFY(WBM_IS_TOPMOST());
    BOOL fIsTopmost = BOOLIFY(GetWindowLong(_hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST);
    if (fWantTopmost != fIsTopmost)
        SetWindowPos(_hwnd, fWantTopmost ? HWND_TOPMOST : HWND_NOTOPMOST,
                     0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    return;
}

//***    _ResetZorder -- toggle DockingBars between 'normal' and 'raised' mode
// DESCRIPTION
//  queries desktop state and does appropriate '_OnRaise'
//
void CDockingBar::_ResetZorder()
{
    HRESULT hr;
    VARIANTARG vaIn = {0};      // VariantInit
    VARIANTARG vaOut = {0};     // VariantInit

    vaIn.vt = VT_I4;
    vaIn.lVal = DTRF_QUERY;
    hr = IUnknown_Exec(_ptbSite, &CGID_ShellDocView, SHDVID_RAISE, OLECMDEXECOPT_DONTPROMPTUSER,
        &vaIn, &vaOut);
    if (SUCCEEDED(hr) && vaOut.vt == VT_I4)
        _OnRaise(vaOut.lVal);
    // VariantClear
    return;
}

//***   _OnRaise -- handle desktop 'raise' command
// DESCRIPTION
//  changes DockingBar z-order depending on desktop raise state:
//      desktop     DockingBar
//      raised      force on top (so visible)
//      restored    return to normal
// NOTES
//  FEATURE: should we handle WBM_FLOATING too?
//  FEATURE: should add ZORD_xxx to deskbar.h and handle non-WBM_BOTTOMMOST
void CDockingBar::_OnRaise(UINT flags)
{
    HWND hwndZorder;

    if (_eMode != WBM_BOTTOMMOST)
        return;

    switch (flags) {
    case DTRF_RAISE:
        hwndZorder = HWND_TOPMOST;
        break;

    case DTRF_LOWER:
        hwndZorder = HWND_NOTOPMOST;
        break;
    
    default:
        ASSERT(0);
        return;
    }

    SetWindowPos(_hwnd, hwndZorder, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);

    return;
}

#if XXX_BTMFLOAT && 0 // see 'NOTES'
//***   _MayReWindow -- change/restore window state for dragging
// DESCRIPTION
//      USER won't let us drag outside of the browser unless we reparent
//      ourselves.
// NOTES
//      need to call this *before* we enter USER's move/size loop.
//      i.e. on LBUTTONDOWN and on EXITSIZEMOVE.  this gets a bit
//      tricky due to CANCEL etc., since the LBUTTONUP may come thru
//      either before or after we're done.
//
void CDockingBar::_MayReWindow(BOOL fToFloat)
{

    if (ISWBM_DESKTOP() || _eMode != WBM_BOTTOMMOST)
        return;

    // do style bits 1st or re-parenting breaks
    SHSetWindowBits(_hwnd, GWL_STYLE, WS_CHILD | WS_POPUP, fToFloat ? WS_POPUP | WS_CHILD);

    if (!fToFloat) {
        // float->btm

        // nuke owner
        SHSetParentHwnd(_hwnd, NULL);

        // parent
        SetParent(_hwnd, _hwndSite);
    }


    if (fToFloat) {
        // btm->float, set owner

        // parent
        SetParent(_hwnd, PARENT_FLOATING);

        // set owner
        ASSERT(_hwndSite != NULL);
        SHSetParentHwnd(_hwnd, _hwndSite);
    }
}
#endif


void CDockingBar::_GetStyleForMode(UINT eMode, LONG* plStyle, LONG* plExStyle, HWND* phwndParent)
{
    switch (eMode) {
    case WBM_NIL:
        *plStyle = WS_NIL;
        *plExStyle= WS_EX_NIL;
        *phwndParent = PARENT_NIL;
        break;

    case WBM_BBOTTOMMOST:
        *plStyle = WS_BBTMMOST;
        *plExStyle= WS_EX_BBTMMOST;
        *phwndParent = PARENT_BBTMMOST();
        break;

    case WBM_BOTTOMMOST:
        *plStyle = WS_BTMMOST;
        *plExStyle= WS_EX_BTMMOST;
        *phwndParent = PARENT_BTMMOST();
        break;

    case WBM_BFLOATING:
        // FEATURE: todo: FLOATING NYI
        *plStyle = WS_BFLOATING;
        *plExStyle = WS_EX_BFLOATING;
        *phwndParent = _hwndSite;
        break;

    case (WBM_FLOATING | WBM_TOPMOST):
    case WBM_FLOATING:
        // FEATURE: todo: FLOATING NYI
        *plStyle = WS_FLOATING;
        *plExStyle = WS_EX_FLOATING;
        *phwndParent = PARENT_FLOATING;
        break;

    case WBM_TOPMOST:
        *plStyle = WS_XTOPMOST;
        *plExStyle= WS_EX_XTOPMOST;
        *phwndParent = PARENT_XTOPMOST;
        break;
    }
#ifdef DEBUG // {
    if (_eMode == eMode) {
        // style, exstyle
        ASSERT(BITS_SET(GetWindowLong(_hwnd, GWL_STYLE), *plStyle));
        ASSERT(BITS_SET(GetWindowLong(_hwnd, GWL_EXSTYLE), *plExStyle & ~WS_EX_TOPMOST));

        // id
        ASSERT(GetWindowLong(_hwnd, GWL_ID) == 0);

        // parent 
        ASSERT(GetParent(_hwnd) == *phwndParent ||
               (ISWBM_OWNED(_eMode) && GetParent(_hwnd)==_hwndSite));
    }
#endif // }
}

//***   _ChangeWindowStateAndParent --
// NOTES
//      todo: make table-driven (ws1, ws2, etc.)
//
void CDockingBar::_ChangeWindowStateAndParent(UINT eModeNew)
{
    LONG ws1, wsx1, ws2, wsx2;
    HWND hwnd;

    if (eModeNew == _eMode) {
        // same mode, nothing to do
        return;
    }

    //
    // nuke old bits
    //
    _GetStyleForMode(_eMode, &ws1, &wsx1, &hwnd);


    //
    // set new bits
    //
    _GetStyleForMode(eModeNew, &ws2, &wsx2, &hwnd);

    // if it's going to be owned by the browser, 
    // override hwnd to our site's hwnd
    if (eModeNew & WBMF_BROWSER)
        hwnd = _hwndSite;

    // style, exstyle
    // (SWB can't do WS_EX_TOPMOST, we do it in caller w/ SWP)
    SHSetWindowBits(_hwnd, GWL_STYLE, ws1|ws2 , ws2);
    SHSetWindowBits(_hwnd, GWL_EXSTYLE, (wsx1|wsx2) & ~WS_EX_TOPMOST, wsx2);

    // id
    // (unchanged)
    HWND hwndParent = GetParent(_hwnd); 
    if (hwndParent != hwnd) {
        if (hwndParent != HWND_DESKTOP) {
            // float->btm, nuke owner
            SHSetParentHwnd(_hwnd, NULL);
        }

        // parent
        SetParent(_hwnd, hwnd);

        if (hwnd == _hwndSite) {
            // btm->float, set owner
            ASSERT(_hwndSite != NULL);
            SHSetParentHwnd(_hwnd, _hwndSite);
        }
    }
    //
    // force redraw
    //
    SetWindowPos(_hwnd, NULL, 0, 0, 0, 0,
        SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);

    return;
}

//***   _SetNewMonitor --
// When the Desktop is our Docking Site, set the new monitor I am on
// and return the old monitor 
HMONITOR CDockingBar::_SetNewMonitor(HMONITOR hMonNew)
{
    HMONITOR hMonOld = NULL;
    if (ISWBM_DESKTOP() && _ptbSite)
    {
        IMultiMonitorDockingSite * pdds;
        HRESULT hresT = _ptbSite->QueryInterface(IID_IMultiMonitorDockingSite, (LPVOID *)&pdds);
        if (SUCCEEDED(hresT))
        {
            HMONITOR hMon;
            ASSERT(pdds);
            if (SUCCEEDED(pdds->GetMonitor(SAFECAST(this, IDockingWindow*), &hMon)))
            {
                if (hMon != hMonNew)
                {
                    pdds->RequestMonitor(SAFECAST(this, IDockingWindow*), &hMonNew);
                    pdds->SetMonitor(SAFECAST(this, IDockingWindow*), hMonNew, &hMonOld);
                    // These two should be the same, otherwise something wierd is happening -- dli
                    ASSERT(hMonOld == hMon);
                }
            }
            pdds->Release();
        }
    }
    
    return hMonOld;
}

//***   _GetBorderRect --
// NOTES
//      result in screen coordinates
//
void CDockingBar::_GetBorderRect(HMONITOR hMon, RECT* prc)
{
    if (!ISWBM_BOTTOM(_eMode)) {
        // FEATURE: todo: should use:
        // floating: _hwndSite (not strictly correct, but good enough)
        // topmost: UnionRect of:
        //     GetWindowRect(_hwndSite);        // non-appbar rect
        //     GetWindowRect(self)              // plus my personal appbar
        ASSERT(IsWindow(_hwndSite));
        if (ISWBM_DESKTOP())
            GetMonitorRect(hMon, prc);
        else
            GetWindowRect(_hwndSite, prc);  
#ifdef DEBUG
#if 0
        RECT rcTmp;

        // these asserts often fail.  e.g. when dragging topmost right->top.
        // weird: _hwndSite ends up being PROGMAN's hwnd.
        // weird: also, the GetWindowRect fails.
        ASSERT(_hwndSite == PARENT_XTOPMOST);
        // _hwndSite is PROGMAN
        GetWindowRect(PARENT_XTOPMOST, &rcTmp);
        ASSERT(EqualRect(prc, &rcTmp));
#endif
#endif
    }
    else if (_ptbSite) {
        HMONITOR hMonOld = _SetNewMonitor(hMon);
        _ptbSite->GetBorderDW(SAFECAST(this, IDockingWindow*), prc);
        if (hMonOld)
            _SetNewMonitor(hMonOld);
        ASSERT(_hwndSite != NULL);
        //ASSERT(GetParent(_hwnd) == _hwndSite);  // FEATURE ISWBM_OWNED?
        // convert if necessary
        // aka ClientToScreen
        MapWindowPoints(_hwndSite, HWND_DESKTOP, (POINT*) prc, 2);
    }

    return;
}

//***   _HideRegister -- (un)register auto-hide w/ edge
// ENTRY/EXIT
//      fToHide         TRUE if turning AutoHide on, FALSE if turning off
//      _fCanHide       [OUT] TRUE if successfully set autohide on; o.w. FALSE 
//      other           pops up dialog if operation fails
//
void CDockingBar::_HideRegister(BOOL fToHide)
{
    BOOL fSuccess;
    APPBARDATA abd;

    if (! ISWBM_HIDEABLE(_eMode))
        return;

    // (try to) register or unregister it
    // n.b. we're allowed to do this even if we're not an AppBar
    // that's good, because we want at most one autohide deskbar 
    // on an edge regardless of mode
    abd.cbSize = SIZEOF(abd);
    abd.hWnd = _hwnd;
    abd.uEdge = _uSide;
    abd.lParam = fToHide;

    // FEATURE should we do a ABM_GETAUTOHIDEBAR at some point?
    // (tray.c does, and so does the AB sample code...)
    //ASSERT(_fAppRegistered);
    fSuccess = (BOOL) SHAppBarMessage(ABM_SETAUTOHIDEBAR, &abd);

    // set our state
    _fCanHide = BOOLIFY(fSuccess);
    // FEATURE: how handle failure?

    // init some stuff
    if (fToHide)
    {
        if (_fCanHide)
        {
            RECT rc;

            ASSERT(_fCanHide);  // so we won't SetVRect

            ASSERT(!_fHiding);  // (paranoia)

            // force a '0-width' rectangle so we don't take up any space
            RectXform(&rc, RX_EDGE|RX_OPPOSE|RX_ADJACENT, &rc, NULL,
                0, _uSide, _hMon);

            switch (_eMode) {
            case WBM_TOPMOST:
                // negotiate/commit it
                APPBARDATA abd;
                abd.cbSize = sizeof(APPBARDATA);
                abd.hWnd = _hwnd;
                ASSERT(_fCanHide);
                // we used to do:
                //  _fCanHide = FALSE;  // hack: so we surrender AppBar's space
                //  AppBarQuerySetPos(&rc, _uSide, &rc, &abd, TRUE);
                //  _fCanHide = TRUE;   // hack: restore
                // but the instant we do the ABSetPos the shell does a recalc
                // by doing a ShowDW of all toolbars, which does a _Recalc,
                // which does a MSH, which ends up doing ProtoRect w/ our
                // 'temporary' _fCanHide=0, which ends up taking space (oops!).
                //
                // so instead we call the low-level ABQueryPos/ABSetPos guys
                // directly.
                AppBarQueryPos(&rc, _uSide, _hMon, &rc, &abd, TRUE);
                AppBarSetPos0(_uSide, &rc, &abd);
                break;
            }

            // do *not* start the hide here
            // it's up to the caller, since a) might want delay or
            // immediate and b) recursion pblms w/ _MoveSizeHelper
        }
        else
        {
            // FEATURE: do PostMessage a la tray.c?
            MLShellMessageBox(_hwnd,
                MAKEINTRESOURCE(IDS_ALREADYAUTOHIDEBAR),
                MAKEINTRESOURCE(IDS_WEBBARTITLE),
                MB_OK | MB_ICONINFORMATION);
            ASSERT(!_fCanHide);
        }
    }
    else
    {
        // do *not* start the unhide here
        // it's up to the caller, since a) might want delay or
        // immediate and b) recursion pblms w/ _MoveSizeHelper

        _fCanHide = FALSE;
    }

    return;
}

//***   IsNearPoint -- am i currently near specified point?
// ENTRY/EXIT
//  pptBase     (INOUT) IN previous cursor pos, OUT updated to current if !fNear
//  fNear       (ret) TRUE if near, o.w. FALSE
// NOTES
//  heuristic stolen from explorer/tray.c!TraySetUnhideTimer
//
BOOL IsNearPoint(/*INOUT*/ POINT *pptBase)
{
    POINT ptCur;
    int dx, dy, dOff, dNear;

    GetCursorPos(&ptCur);
    dx = pptBase->x - ptCur.x;
    dy = pptBase->y - ptCur.y;
    dOff = dx * dx + dy * dy;
    dNear = GetSystemMetrics(SM_CXDOUBLECLK) * GetSystemMetrics(SM_CYDOUBLECLK);
    if (dOff <= dNear)
        return TRUE;
    TraceMsg(DM_HIDE2, "cwb.inp: ret=0 dOff=%d dNear=%d", dOff, dNear);
    *pptBase = ptCur;
    return FALSE;
}

//***   _DoHide --
// DESCRIPTION
//      AHO_KILLDO              kill timer for 'do'   operation
//      AHO_SETDO               set  timer for 'do'   operation
//      AHO_KILLUN              kill timer for 'undo' operation
//      AHO_SETUN               set  timer for 'undo' operation
//      AHO_REG                 register
//      AHO_UNREG               unregister
//      AHO_MOVEDO              do the actual hide
//      AHO_MOVEUN              do the actual unhide
// NOTES
//  the _fIdtXxHide stuff stops us from doing a 2nd SetTimer before the
// 1st one comes in, which makes us never get the 'earlier' ticks.
//  this fixes nt5:142686: drag-over doesn't unhide.  it was caused by us
// getting a bunch of WM_NCHITTESTs in rapid succession (OLE asking us on
// a fast timer?).
//  REARCHITECT: i think there's a tiny race window on _fIdtXxHide (between the
// call to Set/Kill and the shadowing in _fIdtXxHide).  not sure we can
// even hit it, but if we do, i think the worst that happens is somebody
// doesn't hide or unhide for a while.
//
void CDockingBar::_DoHide(UINT uOpMask)
{
    TraceMsg(DM_HIDE, "cwb.dh enter(uOpMask=0x%x(%s))",
        uOpMask, DbMaskToMneStr(uOpMask, AHO_MNE));

    if (!ISWBM_HIDEABLE(_eMode)) {
        TraceMsg(DM_HIDE, "cwb.dh !ISWBM_HIDEABLE(_eMode) => suppress");
        return;
    }

    // nuke old timer
    if (uOpMask & AHO_KILLDO) {
        TraceMsg(DM_HIDE, "cwb.dh: KillTimer(idt_autohide)");
        KillTimer(_hwnd, IDT_AUTOHIDE);
        _fIdtDoHide = FALSE;
    }
    if (uOpMask & AHO_KILLUN) {
        TraceMsg(DM_HIDE, "cwb.dh: KillTimer(idt_autoUNhide)");
        KillTimer(_hwnd, IDT_AUTOUNHIDE);
        _fIdtUnHide = FALSE;
        _ptIdtUnHide.x = _ptIdtUnHide.y = -1;
    }

    if (uOpMask & (AHO_REG|AHO_UNREG)) {
        _HideRegister(uOpMask & AHO_REG);
    }

    if (uOpMask & (AHO_MOVEDO|AHO_MOVEUN)) {
        // tricky, tricky...
        // all the smarts are in _MoveSizeHelper, driven by _fHiding (and _fCanHide)
        // use correct one of (tiny,real)
        _fHiding = (uOpMask & AHO_MOVEDO) ? HIDE_AUTO : FALSE;

        TraceMsg(DM_HIDE, "cwb.dh: move _fHiding=%d", _fHiding);
        ASSERT(_fCanHide);                      // suppress SetVRect
        _Recalc();  // _MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);
    }

    // start new timer
    if (_fCanHide) {
        if (uOpMask & AHO_SETDO) {
            TraceMsg(DM_HIDE, "cwb.dh: SetTimer(idt_autohide) fAlready=%d", _fIdtDoHide);
            if (!_fIdtDoHide) {
                _fIdtDoHide = TRUE;
                SetTimer(_hwnd, IDT_AUTOHIDE, DLY_AUTOHIDE, NULL);
            }
        }
        if (uOpMask & AHO_SETUN) {
            TraceMsg(DM_HIDE, "cwb.dh: SetTimer(idt_autoUNhide) fAlready=%d", _fIdtUnHide);
            // IsNearPoint hysteresis prevents us from unhiding when we happen
            // to be passed over on the way to something unrelated
            if (!IsNearPoint(&_ptIdtUnHide) || !_fIdtUnHide) {
                _fIdtUnHide = TRUE;
                SetTimer(_hwnd, IDT_AUTOUNHIDE, DLY_AUTOUNHIDE, NULL);
            }
        }
    }
    else {
#ifdef DEBUG
        if ((uOpMask & (AHO_SETDO|AHO_SETUN))) {
            TraceMsg(DM_HIDE, "cwb.dh: !_fCanHide => suppress AHO_SET*");
        }
#endif
    }

    return;
}

//***   SlideWindow -- sexy slide effect
// NOTES
//      stolen from tray.c
void SlideWindow(HWND hwnd, RECT *prc, HMONITOR hMonClip, BOOL fShow)
{
    RECT rcMonitor, rcClip;
    BOOL fRegionSet = FALSE; 

    SetRectEmpty(&rcMonitor);
    if (GetNumberOfMonitors() > 1)
    {
        GetMonitorRect(hMonClip, &rcMonitor);
        // aka ScreenToClient
        MapWindowPoints(HWND_DESKTOP, GetParent(hwnd), (LPPOINT)&rcMonitor, 2);     }

    // Future: We could loop on the following code for the slide effect 
    IntersectRect(&rcClip, &rcMonitor, prc);
    if (!IsRectEmpty(&rcClip))
    {
        HRGN hrgnClip;

        // Change the clip region to be relative to the upper left corner of prc
        // NOTE: this is not converting rcClip to prc client coordinate
        OffsetRect(&rcClip, -prc->left, -prc->top);
        
        hrgnClip = CreateRectRgnIndirect(&rcClip);
        // LINTASSERT(hrgnClip || !hgnClip);    // 0 semi-ok for SetWindowRgn
        // nt5:149630: always repaint, o.w. auto-unhide BitBlt's junk
        // from hide position
        fRegionSet = SetWindowRgn(hwnd, hrgnClip, /*fRepaint*/TRUE);
    }
    MoveWindow(hwnd, prc->left, prc->top, RECTWIDTH(*prc), RECTHEIGHT(*prc), TRUE);

    // Turn off the region stuff if we don't hide any more
    if (fRegionSet && fShow)
        SetWindowRgn(hwnd, NULL, TRUE);

    return;
}

/***    AppBarQueryPos -- negotiate position
 * ENTRY/EXIT
 *      return  width (height) from docked edge to opposing edge
 */
int CDockingBar::AppBarQueryPos(RECT* prcOut, UINT uEdge, HMONITOR hMon, const RECT* prcReq,
    PAPPBARDATA pabd, BOOL fCommit)
{
    int iWH;

    ASSERT(ISWBM_DESKTOP());

    // snap to edge (in case another AppBar disappeared w/o us knowing),
    // readjust opposing side to reflect that snap,
    // and max out adjacent sides to fill up full strip.
    iWH = RectGetWH(prcReq, uEdge);
    
    RectXform(&(pabd->rc), RX_EDGE|RX_OPPOSE|RX_ADJACENT|(_fHiding ? RX_HIDE : 0), prcReq, NULL, iWH, uEdge, hMon);

    ASSERT(EqualRect(&(pabd->rc), prcReq));     // caller guarantees?

    // negotiate
    // if we're dragging we might not be registered yet (floating->docked)
    // in that case we'll just use the requested size (w/o negotiating).
    // ditto for if we're in the middle of a top/non-top mode switch.
    if (_fAppRegistered) {
        pabd->uEdge = uEdge;
        TraceMsg(DM_APPBAR, "cwb.abqp: call ABM_QUERYPOS");
        SHAppBarMessage(ABM_QUERYPOS, pabd);
    }

    // readjust opposing side to reflect the negotiation (which only
    // adjusts the moved edge-most side, not the opposing edge).
    // FEATURE: (dli) need to find the right hmonitor to pass  in
    RectXform(prcOut, RX_OPPOSE, &(pabd->rc), NULL, iWH, uEdge, hMon);

    return RectGetWH(prcOut, uEdge);
}

//***   AppBarSetPos --
// NOTES
//      does *not* do _SetVRect and MoveWindow, that's up to caller
//
void CDockingBar::AppBarSetPos(UINT uEdge, const RECT* prcReq, PAPPBARDATA pabd)
{
    ASSERT(_eMode == WBM_TOPMOST);

    if (!_fCanHide && _fAppRegistered)
        AppBarSetPos0(uEdge, prcReq, pabd);

    return;
}

void CDockingBar::AppBarSetPos0(UINT uEdge, const RECT* prcReq, PAPPBARDATA pabd)
{
    CopyRect(&(pabd->rc), prcReq);
    pabd->uEdge = uEdge;

    TraceMsg(DM_APPBAR, "cwb.absp: call ABM_SETPOS");
    ASSERT(_fAppRegistered);
    SHAppBarMessage(ABM_SETPOS, pabd);

    // APPCOMPAT workaround explorer bug: during dragging we get:
    //  querypos*; wm_winposchanged; querypos; setpos
    // the lack of a wm_winposchanged at the end screws up the
    // autohide bring-to-top code.
    ASSERT(pabd->cbSize == sizeof(APPBARDATA));
    ASSERT(pabd->hWnd == _hwnd);
    TraceMsg(DM_APPBAR, "cwb.absp: call ABM_WINPOSCHGED");
    SHAppBarMessage(ABM_WINDOWPOSCHANGED, pabd);

    // n.b. _SetVRect and MoveWindow done by caller

    return;
}

//***   AppBarQuerySetPos --
//
void CDockingBar::AppBarQuerySetPos(RECT* prcOut, UINT uEdge, HMONITOR hMon, const RECT* prcReq,
    PAPPBARDATA pabd, BOOL fCommit)
{
    RECT rcTmp;

    if (prcOut == NULL)
        prcOut = &rcTmp;

    AppBarQueryPos(prcOut, uEdge, hMon, prcReq, pabd, fCommit);
    if (fCommit) {
        AppBarSetPos(uEdge, prcOut, pabd);
        ASSERT(EqualRect(prcOut, &(pabd->rc))); // callers assume prcOut correct
    }

    return;
}

void CDockingBar::_AppBarOnSize()
{
    RECT rc;
    APPBARDATA abd;

    ASSERT(_eMode == WBM_TOPMOST);
    ASSERT(ISABE_DOCK(_uSide));

    if (!_fAppRegistered)
        return;

    // don't commit until done
    if (_fDragging)
        return;

    abd.cbSize = sizeof(APPBARDATA);
    abd.hWnd = _hwnd;

    GetWindowRect(_hwnd, &rc);
    AppBarQuerySetPos(NULL, _uSide, _hMon, &rc, &abd, TRUE);

    return;
}

void CDockingBar::_RemoveToolbar(DWORD dwFlags)
{
    if (_ptbSite) {
        // WM_DESTROY will do _ChangeTopMost(WBM_NIL) for us

        IDockingWindowFrame* ptbframe;
        HRESULT hresT=_ptbSite->QueryInterface(IID_IDockingWindowFrame, (LPVOID*)&ptbframe);
        if (SUCCEEDED(hresT)) {
            AddRef();   // guard against self destruction
            ptbframe->RemoveToolbar(SAFECAST(this, IDockingWindow*), dwFlags);
            ptbframe->Release();
            Release();
        }
    } else {
        CloseDW(0);
    }
}

void CDockingBar::_AppBarOnCommand(UINT idCmd)
{
    UINT eModeNew;

    switch (idCmd) {
    case IDM_AB_TOPMOST:
        eModeNew = _eMode ^ WBM_TOPMOST;
        _MoveSizeHelper(eModeNew, _uSide, _hMon, NULL, NULL, TRUE, TRUE);
        break;

    case IDM_AB_AUTOHIDE:
        if (_fWantHide)
        {
            // on->off
            _DoHide(AHO_KILLDO|AHO_UNREG);      // _ChangeHide
            _fWantHide = FALSE;
        }
        else
        {
            // off->on
            _fWantHide = TRUE;
            // don't do AHO_SETDO now, wait for WM_ACTIVATE(deactivate)
            _DoHide(AHO_REG);     // _ChangeHide
        }

        // force it to happen *now*
        // REARCHITECT potential race condition w/ the AHO_SETDO above,
        // but worst case that should cause a 2nd redraw (?).
        _Recalc();  // _MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);

        if (SHIsChildOrSelf(GetActiveWindow(), _hwnd) != S_OK)
        {
            // nt5:148444: if we're already deactive, we need to kick off
            // the hide now.  this is needed e.g. for login when we load
            // persisted auto-hide deskbars.  they come up inactive so we
            // never get the initial deact to hide them.
            _OnActivate(MAKEWPARAM(WA_INACTIVE, FALSE), (LPARAM)(HWND)0);
        }

        break;
#ifdef DEBUG
    case IDM_AB_ACTIVATE:
        // REARCHITECT temporary until we make browser tell us about activation

        // note that since we're faking this w/ a menu our (normal) assumption
        // in WM_ENTERMENU is bogus so make sure you keep the mouse over
        // the BrowserBar during activation or it will hide away out from under
        // you and the Activate won't work...
        _OnActivate(MAKEWPARAM(_fActive ? WA_INACTIVE : WA_ACTIVE, FALSE),
            (LPARAM) (HWND) 0);
        _fActive = !_fActive;
        break;
#endif

    case IDM_AB_CLOSE:
        _OnCloseBar(TRUE);
        break;

    default:
        MessageBeep(0);
        break;
    }
}

BOOL CDockingBar::_OnCloseBar(BOOL fConfirm)
{
    _RemoveToolbar(0);
    return TRUE;
}

void CDockingBar::_AppBarOnWM(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
    case WM_WINDOWPOSCHANGED:
    case WM_ACTIVATE:
        {
            APPBARDATA abd;

            abd.cbSize = sizeof(APPBARDATA);
            abd.hWnd = _hwnd;
            abd.lParam = (long) NULL;
            if (uMsg == WM_WINDOWPOSCHANGED) {
                TraceMsg(DM_APPBAR, "cwb.WM_WPC: call ABM_WINPOSCHGED");
                SHAppBarMessage(ABM_WINDOWPOSCHANGED, &abd);
            }
            else {
                //if (LOWORD(wParam) != WA_INACTIVE)
                // just do it always, doesn't hurt...
                TraceMsg(DM_APPBAR, "cwb.WM_ACT: call ABM_ACTIVATE");
                SHAppBarMessage(ABM_ACTIVATE, &abd);
            }
        }
        break;

    default:
        ASSERT(0);
        break;
    }

    return;
}

// try to preserve our thinkness
void CDockingBar::_AppBarOnPosChanged(PAPPBARDATA pabd)
{
    RECT rcWindow;

    ASSERT(_eMode == WBM_TOPMOST);

    GetWindowRect(pabd->hWnd, &rcWindow);
    RectXform(&rcWindow, RX_EDGE|RX_OPPOSE, &rcWindow, NULL, RectGetWH(&rcWindow, _uSide), _uSide, _hMon);

    _Recalc();  // _MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);
    return;
}

/***    _InitPos4 -- initialize edge positions
 * ENTRY/EXIT
 *  fCtor       TRUE if called from constructor; o.w. FALSE
 */
void CDockingBar::_InitPos4(BOOL fCtor)
{
    RECT rcSite;

    TraceMsg(DM_PERSIST, "cdb.ip4(fCtor=%d) enter", fCtor);

    if (fCtor)
    {
        // set some worst-case defaults for the Load(bag) case
        _adEdge[ABE_TOP]    = 80;
        _adEdge[ABE_BOTTOM] = 80;
        _adEdge[ABE_LEFT]   = 80;
        _adEdge[ABE_RIGHT]  = 80;

        SetRect(&_rcFloat, 10, 10, 310, 310);       // FEATURE: todo: NYI
        _hMon = GetPrimaryMonitor();
    }
    else
    {
        // set up semi-reasonable defaults for the InitNew case
        ASSERT(_eInitLoaded == IPS_INITNEW);    // not req'd, but expected
        ASSERT(IsWindow(_hwndSite));
        GetWindowRect(_hwndSite, &rcSite);

        _adEdge[ABE_TOP]    = AB_THEIGHT(rcSite);
        _adEdge[ABE_BOTTOM] = AB_BHEIGHT(rcSite);
        _adEdge[ABE_LEFT]   = AB_LWIDTH(rcSite);
        _adEdge[ABE_RIGHT]  = AB_RWIDTH(rcSite);
        
        // FEATURE: (dli) should we ask _hwndSite for it's hmonitor?
        // This current implementation already seems acceptable -justmann
        _hMon = MonitorFromRect(&rcSite, MONITOR_DEFAULTTONULL);
        if (!_hMon)
        {
            POINT ptCenter;
            ptCenter.x = (rcSite.left + rcSite.right) / 2;
            ptCenter.y = (rcSite.top + rcSite.bottom) / 2;
            _hMon = MonitorFromPoint(ptCenter, MONITOR_DEFAULTTONEAREST);
        }

    }

    return;
}

/***    RectXform -- transform RECT
 * ENTRY/EXIT
 *      prcOut
 *      uRxMask
 *      prcIn           initial rect
 *      prcBound        bounding rect specifying min/max dimensions
 *      iWH
 *      uSide
 * DESCRIPTION
 *      RX_EDGE         set edgemost side  to extreme (0 or max)
 *      RX_OPPOSE       set opposing side  to edge + width
 *      RX_ADJACENT     set adjacent sides to extremes (0 and max)
 *      RX_GETWH        get distance to opposing side
 *
 *      Two common calls are:
 *      ...
 * NOTES
 *      Note that rcOut, rcIn, and rcSize can all be the same.
 */
int CDockingBar::RectXform(RECT* prcOut, UINT uRxMask,
    const RECT* prcIn, RECT* prcBound, int iWH, UINT uSide, HMONITOR hMon)
{
    RECT rcDef;
    int  iRet = 0;
    BOOL bMirroredWnd=FALSE;

    if (prcOut != prcIn && prcOut != NULL) {
        ASSERT(prcIn != NULL);  // used to do SetRect(prcOut,0,0,0,0)
        CopyRect(prcOut, prcIn);
    }

#ifdef DEBUG
    if (! (uRxMask & (RX_OPPOSE|RX_GETWH))) {
        ASSERT(iWH == -1);
        iWH = -1;       // try to force something to go wrong...
    }
#endif

    if (uRxMask & (RX_EDGE|RX_ADJACENT)) {
        if (prcBound == NULL) {
            prcBound = &rcDef;
            ASSERT(hMon);
            GetMonitorRect(hMon, prcBound);     // aka GetSystemMetrics(SM_CXSCREEN)
        }

        #define iXMin (prcBound->left)
        #define iYMin (prcBound->top)
        #define iXMax (prcBound->right);
        #define iYMax (prcBound->bottom);
    }

    if (uRxMask & (RX_EDGE|RX_OPPOSE|RX_HIDE|RX_GETWH)) {

        //
        // If docking is happening on a horizontal size, then...
        // 
        if ((ABE_LEFT == uSide) || (ABE_RIGHT == uSide)) {
            bMirroredWnd = (IS_WINDOW_RTL_MIRRORED(GetParent(_hwnd)));
        }

        switch (uSide) {
        case ABE_TOP:
            if (prcOut)
            {
                if (uRxMask & RX_EDGE)
                    prcOut->top = iYMin;
                if (uRxMask & RX_OPPOSE)
                    prcOut->bottom = prcOut->top + iWH;
                if (uRxMask & RX_HIDE)
                    MoveRect(prcOut, prcOut->left, prcOut->top - iWH + CXYHIDE(uSide));
            }
            if (uRxMask & RX_GETWH)
                iRet = RECTHEIGHT(*prcIn);

            break;
        case ABE_BOTTOM:
            if (prcOut)
            {
                if (uRxMask & RX_EDGE)
                    prcOut->bottom = iYMax;
                if (uRxMask & RX_OPPOSE)
                    prcOut->top = prcOut->bottom - iWH;
                if (uRxMask & RX_HIDE)
                    MoveRect(prcOut, prcOut->left, prcOut->bottom - CXYHIDE(uSide));
            }
            if (uRxMask & RX_GETWH)
                iRet = RECTHEIGHT(*prcIn);

            break;
        case ABE_LEFT:
            if (prcOut)
            {
                if (uRxMask & RX_EDGE)
                    prcOut->left = iXMin;
                if (uRxMask & RX_OPPOSE) {
                    //
                    // If the parent of this docked window is mirrored, then it is placed and
                    // aligned to the right. [samera]
                    //
                    if (bMirroredWnd)
                        prcOut->left = prcOut->right - iWH;
                    else
                        prcOut->right = prcOut->left + iWH;
                }
                if (uRxMask & RX_HIDE)
                    MoveRect(prcOut, prcOut->left - iWH + CXYHIDE(uSide), prcOut->top);
            }
            if (uRxMask & RX_GETWH)
                iRet = RECTWIDTH(*prcIn);

            break;
        case ABE_RIGHT:
            if (prcOut)
            {
                if (uRxMask & RX_EDGE)
                    prcOut->right = iXMax;
                if (uRxMask & RX_OPPOSE) {
                    //
                    // If the parent of this docked window is mirrored, then it is placed and
                    // aligned to the left
                    //
                    if (bMirroredWnd)
                        prcOut->right = prcOut->left + iWH;
                    else
                        prcOut->left = prcOut->right - iWH;
                }
                if (uRxMask & RX_HIDE)
                    MoveRect(prcOut, prcOut->right - CXYHIDE(uSide), prcOut->top);
            }
            if (uRxMask & RX_GETWH)
                iRet = RECTWIDTH(*prcIn);

            break;
        }
    }

    if ((uRxMask & RX_ADJACENT) && prcOut)
    {
        if (uSide == ABE_LEFT || uSide == ABE_RIGHT) {
            prcOut->top    = iYMin;
            prcOut->bottom = iYMax;
        }
        else {
            prcOut->left   = iXMin;
            prcOut->right  = iXMax;
        }
    }

    return iRet;
}

//***   _ProtoRect -- create best-guess proto rect for specified location
//
void CDockingBar::_ProtoRect(RECT* prcOut, UINT eModeNew, UINT uSideNew, HMONITOR hMonNew, POINT* ptXY)
{
    if (ISWBM_FLOAT(eModeNew))
    {
        // start at last position/size, and move to new left-top if requested
        CopyRect(prcOut, &_rcFloat);
        if (ptXY != NULL)
            MoveRect(prcOut, ptXY->x, ptXY->y);

        // if we're (e.g.) floating on the far right and the display shrinks,
        // we need to reposition ourselves
        // PERF: wish we could do this at resolution-change time but
        // WM_DISPLAYCHANGE comes in too early (before our [pseudo] parent
        // has changed).
        if (eModeNew == WBM_FLOATING)
        {
            // make sure we're still visible
            // FEATURE todo: multi-mon
            RECT rcTmp;

            _GetBorderRect(hMonNew, &rcTmp);

            if (prcOut->left > rcTmp.right || prcOut->top > rcTmp.bottom)
            {
                // WARNING note we don't explicitly account for other toolbars
                // this may be a bug (though other apps seem to behave the
                // same way)
                MoveRect(prcOut,
                    prcOut->left <= rcTmp.right ? prcOut->left :
                        rcTmp.right - CXFLOAT(),
                    prcOut->top  <= rcTmp.bottom ? prcOut->top  :
                        rcTmp.bottom - CYFLOAT()
                );
            }

        }
    }
    else
    {
        ASSERT(ISABE_DOCK(uSideNew));
        if (_fCanHide && ISWBM_HIDEABLE(eModeNew))
        {
            // force a 'tiny' rectangle
            // (WARNING prcBound==NULL bogus for XXX_HIDEALL && XXX_BROWSEROWNED)
            RectXform(prcOut, RX_EDGE|RX_OPPOSE|RX_ADJACENT|(_fHiding ? RX_HIDE : 0),
                prcOut, NULL, _adEdge[uSideNew], uSideNew, hMonNew);
        }
        else
        {
            // get current rect, adjust opposing side per request
            _GetBorderRect(hMonNew, prcOut);    
            RectXform(prcOut, RX_OPPOSE, prcOut, NULL, _adEdge[uSideNew], uSideNew, hMonNew);

        }
    }

    return;
}

//***   _NegotiateRect --
// NOTES
//      will only return an approximate result in the non-commit case.
//
void CDockingBar::_NegotiateRect(UINT eModeNew, UINT uSideNew, HMONITOR hMonNew,
    RECT* rcReq, BOOL fCommit)
{
    switch (eModeNew) {
    case WBM_TOPMOST:
        APPBARDATA abd;
        abd.cbSize = sizeof(APPBARDATA);
        abd.hWnd = _hwnd;

        AppBarQuerySetPos(rcReq, uSideNew, hMonNew, rcReq, &abd, fCommit);
        if (_fCanHide)
        {
            // we did a query to adjust the adjacent sides (e.g. so we don't
            // cover up the 'start' menu when we unhide).  however that may
            // have also moved us in from the edge, which we don't want.
            // so snap back to edge.
            int iWH;

            iWH = RectGetWH(rcReq, uSideNew);
            RectXform(rcReq, RX_EDGE|RX_OPPOSE|(_fHiding ? RX_HIDE : 0), rcReq, NULL, iWH, uSideNew, hMonNew);
        }
        goto Ldefault;

    default:
    Ldefault:
        // everyone else just gives us what we want

        // but, we need to free up border
        _NegotiateBorderRect(NULL, NULL, fCommit);     // free up space

        break;

    case WBM_BOTTOMMOST:
    case WBM_BBOTTOMMOST:
        _NegotiateBorderRect(rcReq, rcReq, fCommit);
        break;
    }


    return;
}

void CDockingBar::_AppBarCallback(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    APPBARDATA abd;

    ASSERT(_eMode == WBM_TOPMOST);

    abd.cbSize = sizeof(abd);
    abd.hWnd = hwnd;

    switch (wParam) {
    case ABN_FULLSCREENAPP:
        // when 1st  app goes   full-screen, move ourselves to BOTTOM;
        // when last app leaves full-screen, move ourselves back
        // todo: FullScreen(flg)
        {
            BOOL fIsTopmost = BOOLIFY(GetWindowLong(_hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST);
            if (!lParam != fIsTopmost)
            {
                SetWindowPos(hwnd,
                    lParam ? HWND_BOTTOM : HWND_TOPMOST,
                    0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
            }
        }
        break;

    case ABN_POSCHANGED:
        TraceMsg(DM_APPBAR, "cwb.abcb: ABN_POSCHANGED");

        // note that we do this even if _fHiding.  while we want
        // to stay snapped to the edge as a 'tiny' rect, a change
        // in someone else *should* effect our adjacent edges.
        //
        // FEATURE: unfortunately this currently causes 'jiggle' of a hidden
        // guy when another appbar moves (due to a SlideWindow of a 0-width
        // hidden guy and a rounded-up 8-pixel wide guy).  when we switch
        // to explorer's new offscreen hide that should go away.
        _AppBarOnPosChanged(&abd);
        break;
    }

    return;
}

HRESULT CDockingBar::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDockingBar, IDockingWindow),        // IID_IDockingWindow
        QITABENT(CDockingBar, IObjectWithSite),       // IID_IObjectWithSite
        QITABENT(CDockingBar, IPersistStreamInit),    // IID_IPersistStreamInit
        QITABENTMULTI(CDockingBar, IPersistStream, IPersistStreamInit), // IID_IPersistStream
        QITABENTMULTI(CDockingBar, IPersist, IPersistStreamInit), // IID_IPersist
        QITABENT(CDockingBar, IPersistPropertyBag),   // IID_IPersistPropertyBag
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);

    return hres;
}

HRESULT CDockingBar::QueryService(REFGUID guidService,
                                REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL; // assume error

    //  Block IID_ITargetFrame, so we don't look like a frame of the
    //  window we are attached to
    if (IsEqualGUID(guidService, IID_ITargetFrame)
        ||IsEqualGUID(guidService, IID_ITargetFrame2)) {
        return hres;
    }

    hres = SUPERCLASS::QueryService(guidService, riid, ppvObj);
    if (FAILED(hres))
    {
        const GUID* pguidService = &guidService;
    
        if (IsEqualGUID(guidService, SID_SProxyBrowser)) {
            pguidService = &SID_STopLevelBrowser;
        }
    
        if (_ptbSite) {
            hres = IUnknown_QueryService(_ptbSite, *pguidService, riid, ppvObj);
        }
    }

    return hres;
}

void CDockingBar::_GrowShrinkBar(DWORD dwDirection)
{
    RECT    rcNew, rcOld;
    int     iMin;

    iMin = GetSystemMetrics(SM_CXVSCROLL) * 4;

    GetWindowRect(_hwnd, &rcNew);   
    rcOld = rcNew;
    
    switch(_uSide)
    {
        case ABE_TOP:
            if (VK_DOWN == dwDirection)
                rcNew.bottom += GetSystemMetrics(SM_CYFRAME);

            if (VK_UP == dwDirection)
                rcNew.bottom -= GetSystemMetrics(SM_CYFRAME);

            if ((rcNew.bottom - rcNew.top) < iMin)
                rcNew.bottom = rcNew.top + iMin;
            break;

        case ABE_BOTTOM:
            if (VK_UP == dwDirection)
                rcNew.top -= GetSystemMetrics(SM_CYFRAME);

            if (VK_DOWN == dwDirection)
                rcNew.top += GetSystemMetrics(SM_CYFRAME);

            if ((rcNew.bottom - rcNew.top) < iMin)
                rcNew.top = rcNew.bottom - iMin;
            break;

        case ABE_LEFT:
            if (VK_RIGHT == dwDirection)
                rcNew.right += GetSystemMetrics(SM_CXFRAME);

            if (VK_LEFT == dwDirection)
                rcNew.right -= GetSystemMetrics(SM_CXFRAME);

            if ((rcNew.right - rcNew.left) < iMin)
                rcNew.right = rcNew.left + iMin;
            break;
            
        case ABE_RIGHT:
            if (VK_LEFT == dwDirection)
                rcNew.left -= GetSystemMetrics(SM_CXFRAME);

            if (VK_RIGHT == dwDirection)
                rcNew.left += GetSystemMetrics(SM_CXFRAME);

            if ((rcNew.right - rcNew.left) < iMin)
                rcNew.left = rcNew.right - iMin;
            break;

    }

    if (!EqualRect(&rcOld, &rcNew))
    {
        int iWH;
        RECT rcScreen;

        // don't let the new size get > MonitorRect/2
        GetMonitorRect(_hMon, &rcScreen);   // aka GetSystemMetrics(SM_CXSCREEN)
        iWH = RECTGETWH(_uSide, &rcScreen);
        iWH /= 2;
        if (RECTGETWH(_uSide, &rcNew) > iWH) 
        {
            RectXform(&rcNew, RX_OPPOSE, &rcNew, NULL, iWH, _uSide, NULL);
        }

        _SetVRect(&rcNew);
        _Recalc();
    }
}


//*** CDockingBar::IOleCommandTarget::* {

HRESULT CDockingBar::Exec(const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt,
    VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) {
        /*NOTHING*/
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup)) {
        switch (nCmdID) {
        case SHDVID_RAISE:
            ASSERT(pvarargIn && pvarargIn->vt == VT_I4);
            if (pvarargIn->vt == VT_I4 && pvarargIn->lVal != DTRF_QUERY) {
                _OnRaise(pvarargIn->lVal);
                return S_OK;
            }
            break;  // e.g. DTRF_QUERY
        default:
            // note that this means we may get OLECMDERR_E_UNKNOWNGROUP
            // rather than OLECMDERR_E_NOTSUPPORTED for unhandled guys...
            break;
        }
    } 
    else if (IsEqualGUID(CGID_DeskBarClient, *pguidCmdGroup)) 
    {
        if (DBCID_RESIZE == nCmdID)
        {
            _GrowShrinkBar(nCmdexecopt);
            return S_OK;
        }
    }
    
    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt,
        pvarargIn, pvarargOut);
}
// }

//*** CDockingBar::IDockingWindow::* {
//

HRESULT CDockingBar::SetSite(IUnknown* punkSite)
{
    ATOMICRELEASE(_ptbSite);

    if (punkSite)
    {
        HRESULT hresT;
        hresT = punkSite->QueryInterface(IID_IDockingWindowSite, (LPVOID*)&_ptbSite);

        IUnknown_GetWindow(punkSite, &_hwndSite);

        //
        // Check if we are under the desktop browser or not and set
        // the initial state correctly. (Always on top for Desktop)
        //
        IUnknown* punkT;
        hresT = punkSite->QueryInterface(SID_SShellDesktop, (LPVOID*)&punkT);
        if (SUCCEEDED(hresT))
        {
            _fDesktop = TRUE;
            punkT->Release();
        }

        if (!_fInitSited)
        {
            if (!_eInitLoaded)
            {
                // if we haven't initialized, do it now.
                InitNew();
                _eMode = WBM_BOTTOMMOST;
            }
                
            ASSERT(_eInitLoaded);
            if (_eInitLoaded == IPS_INITNEW)
            {
                _InitPos4(FALSE);
                _eMode = _fDesktop ? WBM_TOPMOST : WBM_BBOTTOMMOST;
            }
        }
        ASSERT(_eMode != WBM_NIL);
        // WARNING actually we could also be owned floating...
        ASSERT(ISWBM_DESKTOP() == _fDesktop);
        ASSERT(_fDesktop || _eMode == WBM_BBOTTOMMOST);
        ASSERT(ISWBM_DESKTOP() == _fDesktop);
        ASSERT(ISWBM_DESKTOP() || _eMode == WBM_BBOTTOMMOST);
    }

    _fInitSited = TRUE;     // done w/ 1st-time init

    return S_OK;
}

HRESULT CDockingBar::ShowDW(BOOL fShow)
{
    fShow = BOOLIFY(fShow);     // so comparisons and assigns to bitfields work

    // we used to early out if BOOLIFY(_fShow) == fShow.
    // however we now count on ShowDW(TRUE) to force a refresh
    // (e.g. when screen resolution changes CBB::v_ShowHideChildWindows
    // calls us)
    if (BOOLIFY(_fShow) == fShow)
        return S_OK;

    _fShow = fShow;

    if (!_fInitShowed)
    {
        ASSERT(_fInitSited && _eInitLoaded);
        _Initialize();
        ASSERT(_fInitShowed);
    }

    if (_fShow)
    {
        // FEATURE: switch to using _ChangeTopMost, it already does this... 
        // Tell itself to resize.

        // use _MoveSizeHelper (not just _NegotiateBorderRect) since we might
        // actually be moving to a new position...
        _Recalc();  // _MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);
        // _NegotiateBorderRect(NULL, NULL, FALSE)

        if (_pDBC)
            _pDBC->UIActivateDBC(DBC_SHOW);

        // nt5:148444: SW_SHOWNA (vs. SW_SHOW) so we don't unhide on create
        // this fix will cause a new bug -- newly created bars don't have
        // focus (e.g. drag a band to floating, the new floating bar won't
        // have focus) -- but that should be the lesser of evils.
        //ShowWindow(_hwnd, ISWBM_FLOAT(_eMode) ? SW_SHOWNORMAL : SW_SHOWNA);
        ShowWindow(_hwnd, SW_SHOWNA);
        _OnSize();
    }
    else
    {
        ShowWindow(_hwnd, SW_HIDE);
        if (EVAL(_pDBC))
            _pDBC->UIActivateDBC(DBC_SHOWOBSCURE);
        UIActivateIO(FALSE, NULL);
        
        // Tell itself to resize.

        // don't call MoveSizeHelper here since it will do (e.g.)
        // negotiation, which will cause flicker and do destructive stuff.
        //_Recalc();  //_MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);
        _NegotiateBorderRect(NULL, NULL, TRUE);     // hide=>0 border space
    }

    return S_OK;
}

HRESULT CDockingBar::ResizeBorderDW(LPCRECT prcBorder,
    IUnknown* punkToolbarSite, BOOL fReserved)
{
    _Recalc();  // _MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);
    return S_OK;    // FEATURE _NegotiateBorderRect()?
}

HRESULT CDockingBar::_NegotiateBorderRect(RECT* prcOut, RECT* prcReq, BOOL fCommit)
{
    UINT eMode, uSide;
    HMONITOR hMon;
    int iWH;

    // FEATURE: should be params like MSH etc.
    eMode = ((_fDragging == DRAG_MOVE) ? _eModePending : _eMode);
    uSide = ((_fDragging == DRAG_MOVE) ? _uSidePending : _uSide);
    hMon = ((_fDragging == DRAG_MOVE) ? _hMonPending : _hMon);

    if (prcOut != prcReq && prcOut != NULL && prcReq != NULL)
        CopyRect(prcOut, prcReq);

    if (_ptbSite) {
        RECT rcRequest = { 0, 0, 0, 0 };

        if (_fShow && ISWBM_BOTTOM(eMode)) {

            if (prcReq)
            {
                iWH = RectGetWH(prcReq, uSide);
                ASSERT(iWH == _adEdge[uSide]);
                if ((!_fCanHide) && uSide != ABE_NIL)
                    ((int*)&rcRequest)[uSide] = iWH;
            }
                
            if (_fTheater) {
                // MOVE TO CBROWSERBAR

                
                // we override the left that we request from the browser, but
                // we need to notify theater what the user has requested for the expaneded width
                VARIANTARG v = { 0 };
                v.vt = VT_I4;
                v.lVal = rcRequest.left;
                IUnknown_Exec(_ptbSite, &CGID_Theater, THID_SETBROWSERBARWIDTH, 0, &v, NULL);
                _iTheaterWidth = v.lVal;
                
                // if we're in theater mode, we can only be on the left and we only grab left border
                ASSERT(uSide == ABE_LEFT);

                // if we're in autohide mode, we request no space
                if (!_fNoAutoHide)
                    rcRequest.left = 0;

                // END MOVE TO CBROWSERBAR                
            }
        }

        // FEATURE: leave alone (at 0 from HideRegister?) if _fHiding==HIDE_AUTO
        HMONITOR hMonOld = _SetNewMonitor(hMon);  

        _ptbSite->RequestBorderSpaceDW(SAFECAST(this, IDockingWindow*), &rcRequest);
        if (fCommit) {
            RECT rcMirRequest;
            LPRECT lprcRequest = &rcRequest; 

            if (IS_WINDOW_RTL_MIRRORED(_hwnd) && 
                !IS_WINDOW_RTL_MIRRORED(GetParent(_hwnd))) {
                // Swap left and right.
                rcMirRequest.left   = rcRequest.right;
                rcMirRequest.right  = rcRequest.left;
                rcMirRequest.top    = rcRequest.top;
                rcMirRequest.bottom = rcRequest.bottom;

                lprcRequest = &rcMirRequest;
            }
            _ptbSite->SetBorderSpaceDW(SAFECAST(this, IDockingWindow*), lprcRequest);
        }

        if (_fShow && ISWBM_BOTTOM(eMode) && !_fTheater) {
            // were'd we end up (as a real rect not just a size)?
            // start w/ our full border area, then apply negotiated width.
            // however that may have also moved us in from the edge, which
            // we don't want if we're autohide, so snap back to edge if so.
            _ptbSite->GetBorderDW(SAFECAST(this, IDockingWindow*), prcOut);

            // aka ClientToScreen
            if (prcOut)
                MapWindowPoints(_hwndSite, HWND_DESKTOP, (POINT*) prcOut, 2);

            if ((!_fCanHide) && uSide != ABE_NIL)
                iWH = ((int*)&rcRequest)[uSide];
            
            RectXform(prcOut, (_fCanHide ? RX_EDGE : 0)|RX_OPPOSE|(_fHiding ? RX_HIDE : 0), prcOut, NULL, iWH, uSide, hMon);
        }
        
        if (hMonOld)
            _SetNewMonitor(hMonOld);

    }

    return S_OK;
}

// }

//*** CDockingBar::IPersistStream*::* {
//

HRESULT CDockingBar::IsDirty(void)
{
    return S_FALSE; // Never be dirty
}

//
// Persisted CDockingBar
//
struct SWebBar
{
    DWORD   cbSize;
    DWORD   cbVersion;
    UINT    uSide : 3;
    UINT    fWantHide :1;
    INT     adEdge[4];  // FEATURE: wordsize dependent
    RECT    rcFloat;    
    POINT   ptSiteCenter; // Center of the docking site -- in case of multiple docking sites

    UINT    eMode;
    UINT    fAlwaysOnTop;

    RECT    rcChild;
};

#define SWB_VERSION 8

HRESULT CDockingBar::Load(IStream *pstm)
{
    SWebBar swb = {0};
    ULONG cbRead;

    TraceMsg(DM_PERSIST, "cwb.l enter(this=%x pstm=%x) tell()=%x", this, pstm, DbStreamTell(pstm));

    ASSERT(!_eInitLoaded);
    HRESULT hres = pstm->Read(&swb, SIZEOF(swb), &cbRead);
#ifdef DEBUG
    // just in case we toast ourselves (offscreen or something)...
    static BOOL fNoPersist = FALSE;
    if (fNoPersist)
        hres = E_FAIL;
#endif
    
    if (hres==S_OK && cbRead==SIZEOF(swb)) {
        // REARCHITECT: this is not forward compatible!
        if (swb.cbSize==SIZEOF(SWebBar) && swb.cbVersion==SWB_VERSION) {

            _eMode = swb.eMode;
            _uSide = swb.uSide;
            _hMon  = MonitorFromPoint(swb.ptSiteCenter, MONITOR_DEFAULTTONEAREST);
            // don't call _SetModeSide, _MoveSizeHelper, etc. until *after* _Initialize
            _fWantHide = swb.fWantHide;
            memcpy(_adEdge, swb.adEdge, SIZEOF(_adEdge));
            _rcFloat = swb.rcFloat;
            _NotifyModeChange(0);

            // child (e.g. bandsite)
            ASSERT(_pDBC != NULL);
            if (_pDBC != NULL) {
                // require IPersistStreamInit?
                IPersistStream *ppstm;
                hres = _pDBC->QueryInterface(IID_IPersistStream, (LPVOID*)&ppstm);
                if (SUCCEEDED(hres)) {

                    // set the child size first because initialization layout might depend on it
                    SetWindowPos(_hwndChild, 0,
                                 swb.rcChild.left, swb.rcChild.top, RECTWIDTH(swb.rcChild), RECTHEIGHT(swb.rcChild),
                                 SWP_NOACTIVATE|SWP_NOZORDER);
                    
                    ppstm->Load(pstm);
                    ppstm->Release();
                }
            }

            _eInitLoaded = IPS_LOAD;    // what if OLFS of bands fails?
            TraceMsg(DM_PERSIST, "CDockingBar::Load succeeded");
        } else {
            TraceMsg(DM_ERROR, "CWB::Load failed swb.cbSize==SIZEOF(SWebBar) && swb.cbVersion==SWB_VERSION");
            hres = E_FAIL;
        }
    } else {
        TraceMsg(DM_ERROR, "CWB::Load failed (hres==S_OK && cbRead==SIZEOF(_adEdge)");
        hres = E_FAIL;
    }
    TraceMsg(DM_PERSIST, "cwb.l leave tell()=%x", DbStreamTell(pstm));
    return hres;
}

HRESULT CDockingBar::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hres;
    SWebBar swb = {0};
    RECT rcMonitor;

    swb.cbSize = SIZEOF(SWebBar);
    swb.cbVersion = SWB_VERSION;
    swb.uSide = _uSide;
    swb.eMode = _eMode;
    swb.fWantHide = _fWantHide;
    memcpy(swb.adEdge, _adEdge, SIZEOF(_adEdge));
    swb.rcFloat = _rcFloat;
    GetWindowRect(_hwndChild, &swb.rcChild);
    MapWindowRect(HWND_DESKTOP, _hwnd, &swb.rcChild);

    ASSERT(_hMon);
    GetMonitorRect(_hMon, &rcMonitor);
    swb.ptSiteCenter.x = (rcMonitor.left + rcMonitor.right) / 2;
    swb.ptSiteCenter.y = (rcMonitor.top + rcMonitor.bottom) / 2;
    
    hres = pstm->Write(&swb, SIZEOF(swb), NULL);
    if (SUCCEEDED(hres))
    {
        IPersistStream* ppstm;
        hres = _pDBC->QueryInterface(IID_IPersistStream, (LPVOID*)&ppstm);
        if (SUCCEEDED(hres))
        {
            hres = ppstm->Save(pstm, TRUE);
            ppstm->Release();
        }
    }
    
    return hres;
}

HRESULT CDockingBar::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ULARGE_INTEGER cbMax = { SIZEOF(SWebBar), 0 };
    *pcbSize = cbMax;
    return S_OK;
}

HRESULT CDockingBar::InitNew(void)
{
    ASSERT(!_eInitLoaded);
    _eInitLoaded = IPS_INITNEW;
    TraceMsg(DM_PERSIST, "CDockingBar::InitNew called");

    // can't call _InitPos4 until set site in SetSite
    // don't call _SetModeSide, _MoveSizeHelper, etc. until *after* _Initialize

    // derived class (e.g. CBrowserBarApp) does the _Populate...

    // on first creation, before bands are added, but the bandsite IS created, we need to notify the bandsite of the new position
    _NotifyModeChange(0);
    return S_OK;
}

HRESULT CDockingBar::Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog)
{
    ASSERT(!_eInitLoaded);

    _eInitLoaded = IPS_LOADBAG;

    // TODO: We'll read following properties.
    //
    //  URL = "..."
    //  Mode = 0 - TopMost, 1 - Bottom, 2 - Undocked
    //  Side = 0 - Right, 1 - Top, 2 - Left, 3 - Bottom
    //  Left/Right/Top/Bottom = Initial docked size
    //


    UINT uSide;
    UINT eMode = _eMode;

    if (WBM_NIL == eMode)
        eMode = WBM_BOTTOMMOST;
    
    eMode = PropBag_ReadInt4(pPropBag, L"Mode", eMode);
    uSide = PropBag_ReadInt4(pPropBag, L"Side", _uSide);
    _adEdge[ABE_LEFT] = PropBag_ReadInt4(pPropBag, L"Left", _adEdge[ABE_LEFT]);
    _adEdge[ABE_RIGHT] = PropBag_ReadInt4(pPropBag, L"Right", _adEdge[ABE_RIGHT]);
    _adEdge[ABE_TOP] = PropBag_ReadInt4(pPropBag, L"Top", _adEdge[ABE_TOP]);
    _adEdge[ABE_BOTTOM] = PropBag_ReadInt4(pPropBag, L"Bottom", _adEdge[ABE_BOTTOM]);

    int x = PropBag_ReadInt4(pPropBag, L"X", _rcFloat.left);
    int y = PropBag_ReadInt4(pPropBag, L"Y", _rcFloat.top);
    OffsetRect(&_rcFloat, x - _rcFloat.left, y - _rcFloat.top);

    int cx = PropBag_ReadInt4(pPropBag, L"CX", RECTWIDTH(_rcFloat));
    int cy = PropBag_ReadInt4(pPropBag, L"CY", RECTHEIGHT(_rcFloat));
    _rcFloat.right = _rcFloat.left + cx;
    _rcFloat.bottom = _rcFloat.top + cy;

    // set up vars for eventual CDockingBar::_Initialize call
    ASSERT(!CDB_INITED());
    _eMode = eMode;
    _uSide = uSide;
    
    POINT pt = {x, y};
    // (dli) compute the new hMonitor 
    _hMon = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);

    // don't call _SetModeSide, _MoveSizeHelper, etc. until *after* _Initialize

    // derived class (e.g. CBrowserBarApp) does the _Populate...

    // on first creation, before bands are added, but the bandsite IS created, we need to notify the bandsite of the new position
    _NotifyModeChange(0);
    return S_OK;
}

HRESULT CDockingBar::Save(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    // We don't need to support this for now.
    return E_NOTIMPL;
}

// }

//*** CDockingBar::IDocHostUIHandler::* {
//

HRESULT CDockingBar::ShowContextMenu(DWORD dwID,
    POINT* ppt,
    IUnknown* pcmdtReserved,
    IDispatch* pdispReserved)
{
    if (dwID==0) {
        TraceMsg(DM_MENU, "cdb.scm: intercept");
        return _TrackPopupMenu(ppt);
    }
    return S_FALSE;
}


// }


void CDockingBar::_SetModeSide(UINT eMode, UINT uSide, HMONITOR hMonNew, BOOL fNoMerge) 
{
    _ChangeTopMost(eMode);
    _uSide = uSide;
    _hMon = hMonNew;
    _SetNewMonitor(hMonNew);
}


// *** IInputObjectSite methods ***

HRESULT CDockingBar::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return IUnknown_OnFocusChangeIS(_ptbSite, SAFECAST(this, IInputObject*), fSetFocus);
}


////////////////////////////////////////////////////////////////
//
//  A deskbar property bag
//////
HRESULT CDockingBarPropertyBag_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CDockingBarPropertyBag* p = new CDockingBarPropertyBag();
    if (p != NULL)
    {
        *ppunk = SAFECAST(p, IPropertyBag*);
        return S_OK;
    }

    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

ULONG CDockingBarPropertyBag::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CDockingBarPropertyBag::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDockingBarPropertyBag::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDockingBarPropertyBag, IPropertyBag),     // IID_IPropertyBag
        QITABENT(CDockingBarPropertyBag, IDockingBarPropertyBagInit),     // IID_IDockingBarPropertyBagInit
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


const WCHAR * const c_szPropNames[] = {
    L"Side",
    L"Mode",
    L"Left",
    L"Top",
    L"Right",
    L"Bottom",
    L"Deleteable",
    L"X",
    L"Y",
    L"CX",
    L"CY"
};


HRESULT CDockingBarPropertyBag::Read( 
                    /* [in] */ LPCOLESTR pszPropName,
                    /* [out][in] */ VARIANT *pVar,
                    /* [in] */ IErrorLog *pErrorLog)
{
    int epropdata;

    for (epropdata = 0; epropdata < (int)PROPDATA_COUNT; epropdata++) {
        if (!StrCmpW(pszPropName, c_szPropNames[epropdata])) {
            break;
        }
    }

    if (epropdata < PROPDATA_COUNT && 
        _props[epropdata]._fSet) {
        pVar->lVal = _props[epropdata]._dwData;
        pVar->vt = VT_I4;
        return S_OK;
    }
    
    return E_FAIL;
}




#ifdef DEBUG
//***   DbCheckWindow --
// NOTES
//  FEATURE: Its a bad idea, why break working code, but here is the suggestion:
//  nuke the 'hwndClient' param and just use GetParent (but what
//  about 'owned' windows, does GetParent give the correct answer?)
BOOL DbCheckWindow(HWND hwnd, RECT *prcExp, HWND hwndClient)
{
    RECT rcAct;

    GetWindowRect(hwnd, &rcAct);
    hwndClient = GetParent(hwnd);   // nuke this param
    if (hwndClient != NULL) {
        // aka ClientToScreen
        MapWindowPoints(HWND_DESKTOP, hwndClient, (POINT*) &rcAct, 2);
    }
    if (!EqualRect(&rcAct, prcExp)) {
        TraceMsg(DM_TRACE,
            "cwb.dbcw: !EqualRect rcAct=(%d,%d,%d,%d) (%dx%d) rcExp=(%d,%d,%d,%d) (%dx%d) hwndClient=0x%x",
            rcAct.left, rcAct.top, rcAct.right, rcAct.bottom,
            RECTWIDTH(rcAct), RECTHEIGHT(rcAct),
            prcExp->left, prcExp->top, prcExp->right, prcExp->bottom,
            RECTWIDTH(*prcExp), RECTHEIGHT(*prcExp),
            hwndClient);
        return FALSE;
    }
    return TRUE;
}

//***   DbStreamTell -- get position in stream (low part only)
//
unsigned long DbStreamTell(IStream *pstm)
{
    if (pstm == 0)
        return (unsigned long) -1;

    ULARGE_INTEGER liEnd;

    pstm->Seek(c_li0, STREAM_SEEK_CUR, &liEnd);
    if (liEnd.HighPart != 0)
        TraceMsg(DM_TRACE, "DbStreamTell: hi!=0");
    return liEnd.LowPart;
}

//***   DbMaskToMneStr -- pretty-print a bit mask in mnemonic form
// ENTRY/EXIT
//  uMask       bit mask
//  szMne       mnemonics, sz[0] for bit 0 .. sz[N] for highest bit
//  return      ptr to *static* buffer
// NOTES
//  n.b.: non-reentrant!!!
TCHAR *DbMaskToMneStr(UINT uMask, TCHAR *szMnemonics)
{
    static TCHAR buf[33];       // FEATURE: non-reentrant!!!
    TCHAR *p;

    p = &buf[ARRAYSIZE(buf) - 1];       // point at EOS
    ASSERT(*p == '\0');
    for (;;) {
        if (*szMnemonics == 0) {
            ASSERT(uMask == 0);
            break;
        }

        --p;
        *p = (uMask & 1) ? *szMnemonics : TEXT('-');

        ++szMnemonics;
        uMask >>= 1;
    }

    return p;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\dllreg.cpp ===
// dllreg.c -- autmatic registration and unregistration
//
#include "priv.h"
#include <advpub.h>
#include <comcat.h>
#include <winineti.h>
#include "resource.h"
#include "regkeys.h"
#include "DllRegHelper.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

void AddNotepadToOpenWithList();

//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//
#define GUID_STR_LEN    40


// ISSUE/010429/davidjen      need to register typelib LIBID_BrowseUI
// before checkin in verify if this typelib already gets registered by setup!!!!!!!
#ifndef ATL_ENABLED
#define ATL_ENABLED
#endif

//=--------------------------------------------------------------------------=
// UnregisterTypeLibrary
//=--------------------------------------------------------------------------=
// blows away the type library keys for a given libid.
//
// Parameters:
//    REFCLSID        - [in] libid to blow away.
//
// Output:
//    BOOL            - TRUE OK, FALSE bad.
//
// Notes:
//    - WARNING: this function just blows away the entire type library section,
//      including all localized versions of the type library.  mildly anti-
//      social, but not killer.
//
#ifdef ATL_ENABLED
BOOL UnregisterTypeLibrary
(
    const CLSID* piidLibrary
)
{
    TCHAR szScratch[GUID_STR_LEN];
    HKEY hk;

    // convert the libid into a string.
    //
    SHStringFromGUID(*piidLibrary, szScratch, ARRAYSIZE(szScratch));
    if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_CLASSES_ROOT, "TypeLib", 0, KEY_WRITE, &hk))
    {
        SHDeleteKey(hk, szScratch);
        RegCloseKey(hk);
    }

    return TRUE;
}
#endif

#ifdef ATL_ENABLED
HRESULT SHRegisterTypeLib(void)
{
    HRESULT hr = S_OK;
    ITypeLib *pTypeLib;
    DWORD dwPathLen;
    WCHAR wzModuleName[MAX_PATH];

    // Load and register our type library.
    //
    dwPathLen = GetModuleFileName(HINST_THISDLL, wzModuleName, ARRAYSIZE(wzModuleName));

#ifdef UNIX
    dwPathLen = ConvertModuleNameToUnix( wzModuleName );
#endif

    hr = LoadTypeLib(wzModuleName, &pTypeLib);

    if (SUCCEEDED(hr))
    {
        // call the unregister type library as we had some old junk that
        // was registered by a previous version of OleAut32, which is now causing
        // the current version to not work on NT...
        UnregisterTypeLibrary(&LIBID_BrowseUI);
        hr = RegisterTypeLib(pTypeLib, wzModuleName, NULL);

        if (FAILED(hr))
        {
            TraceMsg(DM_WARNING, "sccls: RegisterTypeLib failed (%x)", hr);
        }
        pTypeLib->Release();
    }
    else
    {
        TraceMsg(DM_WARNING, "sccls: LoadTypeLib failed (%x)", hr);
    }

    return hr;
}
#endif


void SetBrowseNewProcess(void)
// We want to enable browse new process by default on high capacity
// machines.  We do this in the per user section so that people can
// disable it if they want.
{
    static const TCHAR c_szBrowseNewProcessReg[] = REGSTR_PATH_EXPLORER TEXT("\\BrowseNewProcess");
    static const TCHAR c_szBrowseNewProcess[] = TEXT("BrowseNewProcess");
    
    // no way if less than ~30 meg (allow some room for debuggers, checked build etc)
    MEMORYSTATUS ms;
    SYSTEM_INFO  si;

    ms.dwLength=sizeof(MEMORYSTATUS);
    GlobalMemoryStatus(&ms);
    GetSystemInfo(&si);

    if (!g_fRunningOnNT && ((si.dwProcessorType == PROCESSOR_INTEL_486) ||
                            (si.dwProcessorType == PROCESSOR_INTEL_386)))
    {
        // Bail if Win9x and 386 or 486 cpu
        return;
    }
        

    if (ms.dwTotalPhys < 30*1024*1024)
        return;
    
    SHRegSetUSValue(c_szBrowseNewProcessReg, c_szBrowseNewProcess, REG_SZ, TEXT("yes"), SIZEOF(TEXT("yes")), SHREGSET_FORCE_HKLM);
}


/*----------------------------------------------------------
Purpose: Queries the registry for the location of the path
         of Internet Explorer and returns it in pszBuf.

Returns: TRUE on success
         FALSE if path cannot be determined

Cond:    --
*/

#define SIZE_FLAG   sizeof(" -nohome")

BOOL
GetIEPath(
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf,
    IN  BOOL  bInsertQuotes)
{
    BOOL bRet = FALSE;
    HKEY hkey;

    *pszBuf = '\0';

    // Get the path of Internet Explorer 
    if (NO_ERROR != RegOpenKeyExA(HKEY_LOCAL_MACHINE, SZ_REGKEY_IEXPLOREA, 0, KEY_QUERY_VALUE, &hkey))
    {
        TraceMsg(TF_ERROR, "GetIEPath(): RegOpenKey( %s ) Failed", c_szIexploreKey) ;
    }
    else
    {
        DWORD cbBrowser;
        DWORD dwType;

        if (bInsertQuotes)
            StringCchCatA(pszBuf, cchBuf, "\"");

        cbBrowser = CbFromCchA(cchBuf - SIZE_FLAG - 4);
        if (NO_ERROR != RegQueryValueExA(hkey, "", NULL, &dwType, 
                                         (LPBYTE)&pszBuf[bInsertQuotes?1:0], &cbBrowser))
        {
            TraceMsg(TF_ERROR, "GetIEPath(): RegQueryValueEx() for Iexplore path failed");
        }
        else
        {
            bRet = TRUE;
        }

        if (bInsertQuotes)
            StringCchCatA(pszBuf, cchBuf, "\"");

        RegCloseKey(hkey);
    }

    return bRet;
}


//
// The actual functions called
//


/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.
*/
HRESULT 
CallRegInstall(
    LPSTR pszSection,
    BOOL bUninstall)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibraryA("ADVPACK.DLL");

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szIEPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "MSIEXPLORE", szIEPath },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            // Get the location of iexplore from the registry
            if ( !GetIEPath(szIEPath, SIZECHARS(szIEPath), TRUE) )
            {
                // Failed, just say "iexplore"
                StringCchCatA(szIEPath, ARRAYSIZE(szIEPath), "iexplore.exe");
                AssertMsg(0, TEXT("IE.INF either hasn't run or hasn't set the AppPath key.  NOT AN IE BUG.  Look for changes to IE.INX."));
            }

            if (g_fRunningOnNT)
            {
                // If on NT, we want custom action for %25% %11%
                // so that it uses %SystemRoot% in writing the
                // path to the registry.
                stReg.cEntries += 2;
            }

            hr = pfnri(g_hinst, pszSection, &stReg);
            if (bUninstall)
            {
                // ADVPACK will return E_UNEXPECTED if you try to uninstall 
                // (which does a registry restore) on an INF section that was 
                // never installed.  We uninstall sections that may never have
                // been installed, so ignore this error
                hr = ((E_UNEXPECTED == hr) ? S_OK : hr);
            }
        }
        else
            TraceMsg(DM_ERROR, "DLLREG CallRegInstall() calling GetProcAddress(hinstAdvPack, \"RegInstall\") failed");

        FreeLibrary(hinstAdvPack);
    }
    else
        TraceMsg(DM_ERROR, "DLLREG CallRegInstall() Failed to load ADVPACK.DLL");

    return hr;
}

const CATID * const c_InfoBandClasses[] =
{
    &CLSID_SearchBand,
    &CLSID_MediaBand,
    NULL
};

void RegisterCategories(BOOL fRegister)
{
    enum DRH_REG_MODE eRegister = fRegister ? CCR_REG : CCR_UNREG;

    DRH_RegisterOneCategory(&CATID_InfoBand, IDS_CATINFOBAND, c_InfoBandClasses, eRegister);
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr = S_OK;
    HRESULT hrExternal = S_OK;  //used to return the first failure
    TraceMsg(DM_TRACE, "DLLREG DllRegisterServer() Beginning");

#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllRegisterServer");
        DEBUG_BREAK;
    }
#endif

    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    // (The inf engine doesn't guarantee DelReg/AddReg order, that's
    // why we explicitly unreg and reg here.)
    //
    HINSTANCE hinstAdvPack = LoadLibraryA("ADVPACK.DLL");
    hr = THR(CallRegInstall("InstallControls", FALSE));
    if (SUCCEEDED(hrExternal))
        hrExternal = hr;

    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

#ifdef ATL_ENABLED
    // registers object, typelib and all interfaces in typelib
    hr = SHRegisterTypeLib();
    if (SUCCEEDED(hrExternal))
        hrExternal = hr;
#endif

    return hrExternal;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    TraceMsg(DM_TRACE, "DLLREG DllUnregisterServer() Beginning");

    // UnInstall the registry values
    hr = THR(CallRegInstall("UnInstallControls", TRUE));

    return hr;
}

void ImportQuickLinks();
/*----------------------------------------------------------
Purpose: Install/uninstall user settings

Description: Note that this function has special error handling.
             The function will keep hrExternal with the worse error
             but will only stop executing util the internal error (hr)
             gets really bad.  This is because we need the external
             error to catch incorrectly authored INFs but the internal
             error to be robust in attempting to install other INF sections
             even if one doesn't make it.
*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;
    HRESULT hrExternal = S_OK;

    HRESULT hrInit = SHCoInitialize();
    if (bInstall)
    {
        // "U" means it's the per user install call
        if (pszCmdLine && (lstrcmpiW(pszCmdLine, L"U") == 0))
        {
            ImportQuickLinks();
            if (GetUIVersion() >= 5)
                hr = THR(CallRegInstall("InstallPerUser_BrowseUIShell", FALSE));
        }
        else
        {
            SetBrowseNewProcess();
            // Backup current associations because InstallPlatformRegItems() may overwrite.
            if (GetUIVersion() < 5)
                hr = THR(CallRegInstall("InstallBrowseUINonShell", FALSE));
            else
                hr = THR(CallRegInstall("InstallBrowseUIShell", FALSE));
            if (SUCCEEDED(hrExternal))
                hrExternal = hr;

            if (!IsOS(OS_WHISTLERORGREATER))
            {
                hr = THR(CallRegInstall("InstallBrowseUIPreWhistler", FALSE));
                if (SUCCEEDED(hrExternal))
                    hrExternal = hr;
            }
        
            if (IsOS(OS_NT))
            {
                hr = THR(CallRegInstall("InstallBrowseUINTOnly", FALSE));
                if (SUCCEEDED(hrExternal))
                    hrExternal = hr;
            }

            RegisterCategories(TRUE);

#ifdef ATL_ENABLED
            SHRegisterTypeLib();
#endif
        }

        // Add Notepad to the OpenWithList for .htm files
        AddNotepadToOpenWithList();
    }
    else
    {
        hr = THR(CallRegInstall("UnInstallBrowseUI", TRUE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

#ifdef ATL_ENABLED
        UnregisterTypeLibrary(&LIBID_BrowseUI);
#endif
        RegisterCategories(FALSE);
    }

    SHCoUninitialize(hrInit);
    return hrExternal;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\explore2.cpp ===
#include "priv.h"

#ifndef UNIX

#include "sccls.h"
#include "explore2.h"
#include <iethread.h>
#include "resource.h"
#include "itbar.h"

#include "mluisupp.h"

#define DM_FOCUS    DM_TRACE

#define SUPERCLASS CSHELLBROWSER

TCHAR const c_szSettings[] = TEXT("Settings");
TCHAR const c_szCabinetExpView[]    = TEXT("ExpView");

CExplorerBrowser::CExplorerBrowser()
{
    // warning: can't call SUPERCLASS until _Initialize has been called
    // (since that's what does the aggregation)
}

CExplorerBrowser::~CExplorerBrowser()
{
    if (GetUIVersion() < 5) {
        if (_hmenuTemplate)
            DestroyMenu(_hmenuTemplate);

        if (_hmenuFull)
            DestroyMenu(_hmenuFull);
    }
}

HRESULT CExplorerBrowser::_Initialize(HWND hwnd, IUnknown *pauto)
{
    HRESULT hr;
    SHELLSTATE ss = {0};

    hr = SUPERCLASS::_Initialize(hwnd, pauto);
    if (SUCCEEDED(hr)) {
        _fSubclassed = TRUE;
    }

    return hr;
}

void CExplorerBrowser::v_InitMembers()
{
    if (GetUIVersion() < 5) {
        _hmenuTemplate = _MenuTemplate(MENU_TEMPLATE, TRUE);
        _hmenuFull = _MenuTemplate(MENU_FULL, TRUE);
        _hmenuCur = _hmenuTemplate;
    } else {
        // explorer/non-explorer shell menus same on nt5
        SUPERCLASS::v_InitMembers();
    }
}

HRESULT CExplorerBrowser_CreateInstance(HWND hwnd, LPVOID* ppsb)
{
    HRESULT hr;
    CExplorerBrowser *psb = new CExplorerBrowser();

    if (psb) {
        hr = psb->_Initialize(hwnd, NULL);      // aggregation, etc.
        if (FAILED(hr)) {
            ASSERT(0);    // shouldn't happen
            ATOMICRELEASE(psb);
        }
    } else {
        // low mem
        hr = E_OUTOFMEMORY;
    }

    *ppsb = (LPVOID)psb;
    return hr;
}

IStream* CExplorerBrowser::_GetITBarStream(BOOL fWebBrowser, DWORD grfMode)
{
    return GetITBarStream(ITBS_EXPLORER, grfMode);
}

HRESULT CExplorerBrowser::OnCreate(LPCREATESTRUCT pcs)
{
    HRESULT hres = SUPERCLASS::OnCreate(pcs);
    v_ShowControl(FCW_TREE, SBSC_SHOW);
    return hres;
}

DWORD CExplorerBrowser::v_ShowControl(UINT iControl, int iCmd)
{
    int iShowing = -1;
    
    switch (iControl) {
    case FCW_TREE:
    {
        // get the current state
        iShowing = (IsControlWindowShown(FCW_TREE, NULL) == S_OK) ? SBSC_SHOW : SBSC_HIDE;
        
        if (iCmd != SBSC_QUERY) {
            // turn it on/off as requested
            VARIANTARG v = {0};
            v.vt = VT_I4;
            v.lVal = SBSC_SHOW ? 1 : 0;
            Exec(&CGID_Explorer, SBCMDID_EXPLORERBAR, 0, &v, NULL);
        }
        break;
    }
 
    default:
        return SUPERCLASS::v_ShowControl(iControl, iCmd);
    }
    
    return iShowing;
}


// FEATURE: should go to cshellbrowser
void CExplorerBrowser::_EnableMenuItemsByAttribs(HMENU hmenu)
{    
    if (_pbbd->_pidlCur) {
        DWORD dwAttrib = SFGAO_CANDELETE | SFGAO_CANRENAME | SFGAO_HASPROPSHEET;
        
        IEGetAttributesOf(_pbbd->_pidlCur, &dwAttrib);

        _EnableMenuItem(hmenu, FCIDM_DELETE, (dwAttrib & SFGAO_CANDELETE));
        _EnableMenuItem(hmenu, FCIDM_RENAME, (dwAttrib & SFGAO_CANRENAME));
        _EnableMenuItem(hmenu, FCIDM_PROPERTIES, (dwAttrib & SFGAO_HASPROPSHEET));
        
    }
}

BOOL CExplorerBrowser::_ExplorerTreeHasFocus()
{
    BOOL bRet = FALSE;
    IInputObject* pio;
    if (SUCCEEDED(_QIExplorerBand(IID_IInputObject, (void**)&pio)))
    {
        bRet = (pio->HasFocusIO() == S_OK);
        pio->Release();
    }
    return bRet;
}


LRESULT CExplorerBrowser::v_OnInitMenuPopup(HMENU hmenuPopup, int nIndex, BOOL fSystemMenu)
{
    if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_FILE)) 
    {
        if (_ExplorerTreeHasFocus())
            _EnableMenuItemsByAttribs(hmenuPopup);
    }
    
    return SUPERCLASS::v_OnInitMenuPopup(hmenuPopup, nIndex, fSystemMenu);
}

HRESULT CExplorerBrowser::InsertMenusSB(HMENU hmenuShared,
                            LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    SUPERCLASS::InsertMenusSB(hmenuShared, lpMenuWidths);

    if (GetUIVersion() < 5) {
        if (lpMenuWidths->width[4] == 1)
            lpMenuWidths->width[4] = 2;  // we have tools AND help for explorer mode
    }

    return S_OK;
}

void CExplorerBrowser::v_GetDefaultSettings(IETHREADPARAM *piei)
{
    if (GetUIVersion() < 5)
    {
        // set the flags
        piei->fs.fFlags = 0;

        piei->fs.ViewMode = FVM_LIST;

        ASSERT(DFS_VID_Default == VID_WebView);
#if 0 // If DFS_VID_Default differs from VID_WebView, then turn these lines back on
        piei->m_vidRestore = VID_List;
        piei->m_dwViewPriority = VIEW_PRIORITY_NONE; // let anyone override the VID_List default
#endif

        piei->wv.bStatusBar = g_dfs.bDefStatusBar;
        piei->wp.length = 0;
        piei->wHotkey = 0;
    }
    else
        SUPERCLASS::v_GetDefaultSettings(piei);
}

void CExplorerBrowser::v_ParentFolder()
{
    if (_ShouldAllowNavigateParent()) {
        BrowseObject(NULL, SBSP_PARENT | SBSP_SAMEBROWSER);
    }
}

HRESULT CExplorerBrowser::BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    // turn non-explore to newbrowser
    if ((GetUIVersion() < 5) && (wFlags & SBSP_OPENMODE))
    {
        wFlags &= ~(SBSP_DEFBROWSER | SBSP_SAMEBROWSER);
        wFlags |= SBSP_NEWBROWSER;
    }
    
    return SUPERCLASS::BrowseObject(pidl, wFlags);
}

DWORD CExplorerBrowser::v_RestartFlags()
{
    return COF_CREATENEWWINDOW | COF_EXPLORE;
}

void CExplorerBrowser::v_GetAppTitleTemplate(LPTSTR pszBuffer, size_t cchBuffer, LPTSTR szFullName)
{
    if (GetUIVersion() < 5) {
        // "exploring - la de da"
        TCHAR szBuffer[80];
        MLLoadString(IDS_EXPLORING, szBuffer, ARRAYSIZE(szBuffer));
        StringCchPrintf(pszBuffer, cchBuffer, TEXT("%s - %%s"), szBuffer);
    } else {
        SUPERCLASS::v_GetAppTitleTemplate(pszBuffer, cchBuffer, szFullName);
    }
}

void CExplorerBrowser::_UpdateFolderSettings(LPCITEMIDLIST pidl)
{
    if (GetUIVersion() < 5)
    {
        // Explorer always inherits the view a la win95
        _pbbd->_psv->GetCurrentInfo(&_fsd._fs);
    }
    else
        SUPERCLASS::_UpdateFolderSettings(pidl);
}

LPSTREAM CExplorerBrowser::v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode,
        LPCWSTR pwszName)
{
    // if it's asking for general browser info, give it the one browser info.
    // otherwise give do what our superclass does

    if ((GetUIVersion() < 5) && (StrCmpW(pwszName, L"CabView") == 0))
    {
        HKEY hk = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, NULL, FALSE);
        if (hk)
        {
            IStream *pstm = OpenRegStream(hk, c_szCabinetExpView, c_szSettings, grfMode);
            RegCloseKey(hk);
            return pstm;
        }
    }

    return SUPERCLASS::v_GetViewStream(pidl, grfMode, pwszName);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\explore2.h ===
#ifndef _explore2_H
#define _explore2_H

#include "shbrows2.h"

class CExplorerBrowser : public CSHELLBROWSER
{
public:
    // IOleInPlaceUIWindow (also IOleWindow)
    
    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)
    virtual STDMETHODIMP InsertMenusSB(HMENU hmenuShared,
                LPOLEMENUGROUPWIDTHS lpMenuWidths);
    virtual STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);


    // IBrowserService
    virtual STDMETHODIMP OnCreate(LPCREATESTRUCT pcs);
    virtual STDMETHODIMP _Initialize(HWND hwnd, IUnknown *pauto);

protected:
    CExplorerBrowser();
    virtual ~CExplorerBrowser();

    friend HRESULT CExplorerBrowser_CreateInstance(HWND hwnd, void **ppsb);
    
    // topmost CExplorerBrowser in a frameset (IE3/AOL/CIS/VB)


    // CSHELLBROWSER virtuals
    virtual void _UpdateFolderSettings(LPCITEMIDLIST pidl);
    virtual DWORD       v_ShowControl(UINT iControl, int iCmd);
    virtual void        v_GetAppTitleTemplate(LPTSTR pszBuffer, size_t cchBuffer, LPTSTR pszAppTitle);
    virtual LRESULT     v_OnInitMenuPopup(HMENU hmenuPopup, int nIndex, BOOL fSystemMenu);
    virtual void        v_GetDefaultSettings(IETHREADPARAM *piei);
    virtual STDMETHODIMP_(IStream *) v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName);
    virtual DWORD       v_RestartFlags();
    virtual void        v_ParentFolder();
    virtual IStream *   _GetITBarStream(BOOL fWebBrowser, DWORD grfMode);
    virtual void        v_InitMembers();
    friend LRESULT CALLBACK IEFrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend void CALLBACK BrowserThreadProc(IETHREADPARAM* piei);
    friend LRESULT CALLBACK DrivesWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    
    BOOL _ExplorerTreeHasFocus();
    void _EnableMenuItemsByAttribs(HMENU hmenu);
        
    friend int CALLBACK _export HTIList_FolderIDCompare(HTREEITEM hItem1, HTREEITEM hItem2, LPARAM lParam);
        
    HTREEITEM           _htiCut;
    HWND                _hwndNextViewer;
    
    UINT                _nSelChangeTimer;
    BITBOOL             _fPostCloseLater        :1;
    BITBOOL             _fInteractive           :1;
    BITBOOL             _fNoInteractive         :1; // huh?  why do we have both?
    BITBOOL             _fShowTitles            :1;    
};

#endif // _explore2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\globals.h ===
////////////////////////////////////////////////////////////////
//
// this file is for global macros and global variables
// macros in the first section, variables (and macros associated with those variabls in the second
// (look for BEGIN GLOBALS
//
////////////////////////////////////////////////////////////////





// Map KERNEL32 unicode string functions to SHLWAPI
#define lstrcmpW    StrCmpW
#define lstrcmpiW   StrCmpIW
#define lstrcpyW    StrCpyW
#define lstrcpynW   StrCpyNW
#define lstrcatW    StrCatW


#define c_szNULL        TEXT("")
#define c_szHelpFile     TEXT("iexplore.hlp")
#define MAX_TOOLTIP_STRING 80

// status bar pane numbers actually used to create the controls - in left-to-right order
#define STATUS_PANES            6
#define STATUS_PANE_NAVIGATION  0
#define STATUS_PANE_PROGRESS    1
#define STATUS_PANE_OFFLINE     2
#define STATUS_PANE_PRINTER     2         // printer and offline share a spot
#define STATUS_PANE_PRIVACY     3
#define STATUS_PANE_SSL         4
#define STATUS_PANE_ZONE        5

#define ZONES_PANE_WIDTH        220

// logical defines for grfKeyState bits
#define FORCE_COPY (MK_CONTROL | MK_LBUTTON)    // means copy
#define FORCE_LINK (MK_LBUTTON | MK_CONTROL | MK_SHIFT)     // means link

// the only place ITB_MAX is really used is to make sure we don't have
// one of the distinguished values (e.g. ITB_VIEW, for both correctness
// and perf).  technically that means we can have ITB_MAX = (INT_MAX - 1),
// but 32000 ought to be plenty big enough and it's probably a bit safer
// in terms of collisions w/ ITB_VIEW.
#define ITB_MAX         32000           // max #
#define ITB_CSTATIC     2               // statically allocated guys
#define ITB_CGROW       2               // dynamic guys chunk size
// CASSERT(ITB_CSTATIC % ITB_CGROW == 0);

#define ISVISIBLE(hwnd)  ((GetWindowStyle(hwnd) & WS_VISIBLE) == WS_VISIBLE)

// this is for the file menus recently visited list.  
//  it represents the count of entries both back and forward 
//  that should be on the menu.
#define CRECENTMENU_MAXEACH     5

// shorthand
#ifndef ATOMICRELEASE
#ifdef __cplusplus
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#else
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#endif

// doing this as a function instead of inline seems to be a size win.
//
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else
#   ifdef __cplusplus
#       define ATOMICRELEASE(p) IUnknown_SafeReleaseAndNullPtr(p)
#   else
#       define ATOMICRELEASE(p) IUnknown_AtomicRelease((LPVOID*)&p)
#   endif
#endif
#endif //ATOMICRELEASE

#ifdef SAFERELEASE
#undef SAFERELEASE
#endif
#define SAFERELEASE(p) ATOMICRELEASE(p)


#ifdef  UNICODE

   typedef WCHAR TUCHAR, *PTUCHAR;

#else   /* UNICODE */

   typedef unsigned char TUCHAR, *PTUCHAR;

#endif /* UNICODE */

#define LoadMenuPopup(id) SHLoadMenuPopup(MLGetHinst(), id)   
#define PropagateMessage SHPropagateMessage
#define MenuIndexFromID  SHMenuIndexFromID
#define Menu_RemoveAllSubMenus SHRemoveAllSubMenus
#define _EnableMenuItem SHEnableMenuItem
#define _CheckMenuItem SHCheckMenuItem

#define REGSTR_PATH_EXPLORERA    "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"
#define REGSTR_KEY_STREAMMRUA    REGSTR_PATH_EXPLORERA "\\StreamMRU"

#ifdef UNICODE
#define REGSTR_KEY_STREAMMRU        TEXT(REGSTR_PATH_EXPLORERA) TEXT("\\StreamMRU")
#else // UNICODE
#define REGSTR_KEY_STREAMMRU        REGSTR_KEY_STREAMMRUA
#endif // UNICODE
   
///////////////////////////////////////////////////////////////////////////////
///// BEGIN GLOBALS 
   
#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */
   
extern HINSTANCE g_hinst;
#define HINST_THISDLL g_hinst

extern BOOL g_fRunningOnNT;
extern BOOL g_bRunOnNT5;
extern BOOL g_bRunOnMemphis;
extern BOOL g_fRunOnFE;
extern BOOL g_fRunOnWhistler;
extern BOOL g_fIE;

//
// Is Mirroring APIs enabled (BiDi Memphis and NT5 only)
//
extern BOOL g_bMirroredOS;


extern HINSTANCE g_hinst;
#define HINST_THISDLL g_hinst

#define SID_SDropBlocker CLSID_SearchBand

#define FillExecInfo(_info, _hwnd, _verb, _file, _params, _dir, _show) \
        (_info).hwnd            = _hwnd;        \
        (_info).lpVerb          = _verb;        \
        (_info).lpFile          = _file;        \
        (_info).lpParameters    = _params;      \
        (_info).lpDirectory     = _dir;         \
        (_info).nShow           = _show;        \
        (_info).fMask           = 0;            \
        (_info).cbSize          = sizeof(SHELLEXECUTEINFO);

extern LCID g_lcidLocale;

//
// Globals (per-process)
//
extern LONG g_cThreads;
extern LONG g_cModelessDlg;
extern UINT g_tidParking;           // parking thread
extern HWND g_hDlgActive;
extern UINT g_msgMSWheel;
extern BOOL g_fShowCompColor;
extern COLORREF g_crAltColor;
extern HPALETTE g_hpalHalftone;


extern const GUID CGID_PrivCITCommands;


#ifdef __cplusplus
};                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\gfldset.cpp ===
// gfldset.cpp
//
//  A class that manages global folder settings.

#include "priv.h"
#include "sccls.h"

class CGlobalFolderSettings : public IGlobalFolderSettings
{
    public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)(THIS);
    STDMETHOD_(ULONG,Release)(THIS);

    // *** IGlobalFolderSettings meTHODs ***
    STDMETHOD(Get)(THIS_ DEFFOLDERSETTINGS *pdfs, int cbDfs);
    STDMETHOD(Set)(THIS_ const DEFFOLDERSETTINGS *pdfs, int cbDfs, UINT flags);

    protected:
        friend HRESULT CGlobalFolderSettings_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

        CGlobalFolderSettings();
        ~CGlobalFolderSettings();

        LONG            m_cRef;
};

STDAPI CGlobalFolderSettings_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // class factory will take care of denying aggregation and giving a null
    // back on failure
    ASSERT(pUnkOuter == NULL);

    CGlobalFolderSettings* pid = new CGlobalFolderSettings();

    if (pid)
    {
        *ppunk = SAFECAST(pid, IGlobalFolderSettings*);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
CGlobalFolderSettings::CGlobalFolderSettings() : m_cRef(1)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
CGlobalFolderSettings::~CGlobalFolderSettings()
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CGlobalFolderSettings::QueryInterface ( REFIID riid, LPVOID * ppvObj )
{
    if ( riid == IID_IUnknown || riid == IID_IGlobalFolderSettings)
    {
        *ppvObj = SAFECAST( this, IGlobalFolderSettings *);
        AddRef();
    }
    else
    {
        return E_NOINTERFACE;
    }

    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CGlobalFolderSettings:: AddRef ()
{
    return InterlockedIncrement( &m_cRef );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CGlobalFolderSettings:: Release ()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement( &m_cRef );
    if ( 0 == cRef )
    {
        delete this;
    }

    return cRef;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CGlobalFolderSettings::Get(DEFFOLDERSETTINGS *pdfs, int cbDfs)
{
    if (cbDfs < sizeof(DEFFOLDERSETTINGS_W2K))
    {
        return E_INVALIDARG;
    }
    else if (cbDfs > sizeof(DEFFOLDERSETTINGS))
    {
        ZeroMemory(pdfs, cbDfs);
    }

    CopyMemory(pdfs, &g_dfs, min(cbDfs, sizeof(g_dfs)));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CGlobalFolderSettings::Set(const DEFFOLDERSETTINGS *pdfs, int cbDfs, UINT flags)
{
    if (flags & ~GFSS_VALID) {
        ASSERT(!"Invalid flags passed to CGlobalFolderSettings::Set");
        return E_INVALIDARG;
    }

    //
    //  Special hack:  If you pass (NULL, 0) then it means "reset to
    //  default".
    //
    if (pdfs == NULL)
    {
        if (cbDfs == 0)
        {
            static DEFFOLDERSETTINGS dfs = INIT_DEFFOLDERSETTINGS;
            dfs.vid = g_bRunOnNT5 ? VID_LargeIcons : DFS_VID_Default;
            pdfs = &dfs;
            cbDfs = sizeof(dfs);
        }
        else
        {
            return E_INVALIDARG;
        }
    }
    else if (cbDfs < sizeof(DEFFOLDERSETTINGS_W2K))
    {
        ASSERT(!"Invalid cbDfs passed to CGlobalFolderSettings::Set");
        return E_INVALIDARG;
    }

    // Preserve the dwDefRevCount, otherwise we'll never be able
    // to tell if the structure has been revised!
    DWORD dwDefRevCount = g_dfs.dwDefRevCount;
    CopyMemory(&g_dfs, pdfs, min(cbDfs, sizeof(g_dfs)));
    g_dfs.dwDefRevCount = dwDefRevCount;
    SaveDefaultFolderSettings(flags);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\hnfblock.h ===
#ifndef HNFBLOCK_H_
#define HNFBLOCK_H_

#include <iethread.h>

DECLARE_HANDLE(HNFBLOCK);

STDAPI_(HNFBLOCK) ConvertNFItoHNFBLOCK(IETHREADPARAM* pInfo, LPCTSTR pszPath, DWORD dwProcId);
STDAPI_(IETHREADPARAM *) ConvertHNFBLOCKtoNFI(HNFBLOCK hBlock);


#endif // HNFBLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\iethread.cpp ===
#include "priv.h"
#include <iethread.h>
#include "hnfblock.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

BOOL _GetToken(LPCWSTR *ppszCmdLine, LPWSTR szToken, UINT cchMax)
{
    LPCWSTR pszCmdLine = *ppszCmdLine;

    WCHAR chTerm = L' ';
    if (*pszCmdLine == L'"') {
        chTerm = L'"';
        pszCmdLine++;
    }

    UINT ichToken = 0;
    WCHAR ch;
    while((ch=*pszCmdLine) && (ch != chTerm)) {
        if (ichToken < cchMax-1) {
            szToken[ichToken++] = ch;
        }
        pszCmdLine++;
    }

    szToken[ichToken] = L'\0';

    if (chTerm == L'"' && ch == L'"') {
        pszCmdLine++;
    }

    // skip trailing spaces
    while(*pszCmdLine == L' ')
        pszCmdLine++;

    *ppszCmdLine = pszCmdLine;

    TraceMsgW(TF_SHDAUTO, "_GetToken returning %s (+%s)", szToken, pszCmdLine);

    return szToken[0];
}

BOOL _CheckForOptionOnCmdLine(LPCWSTR *ppszCmdLine, LPCWSTR pszOption)
{
    LPCWSTR pszCmdLine = *ppszCmdLine;
    int cch = lstrlenW(pszOption);

    if (0 == StrCmpNIW(pszCmdLine, pszOption, cch))
    {
        pszCmdLine+= cch;
        while(*pszCmdLine == L' ')
            pszCmdLine++;

        *ppszCmdLine = pszCmdLine;
        return TRUE;
    }
    return FALSE;
}

BOOL IsCalleeIEAK()
{
    // APPCOMPAT: this is hack so as to allow IEAK CD install to continue without
    // any security restrictions. If the IEAK CD install window name changes
    // the name change should also reflect here.
    return (FindWindow(TEXT("IECD"), NULL) != NULL);
}

BOOL SHParseIECommandLine(LPCWSTR *ppwszCmdLine, IETHREADPARAM * piei)
{
    ASSERT(ppwszCmdLine);
    ASSERT(*ppwszCmdLine);
    LPCWSTR pszCmdLine = *ppwszCmdLine;

#ifdef UNIX
    if( CheckForInvalidOptions( *ppwszCmdLine ) == FALSE )
    {
        piei->fShouldStart = FALSE;
        return FALSE;
    }

    // Options valid.
    piei->fShouldStart = TRUE;
#endif

    TraceMsg(TF_SHDAUTO, "SHParseIECommandLine called with %s", pszCmdLine);

    BOOL fDontLookForPidl = FALSE; // A flag option is set, so don't go looking for an open window 
                                   // with the same pidl
                                   // FEATURE: (dli) what if there is a window opened with the same flags?
    while (*pszCmdLine == L'-')
    {
        fDontLookForPidl = TRUE;
        
        //Note: (dli)These flags are supposed to be set to FALSE at initialization
        // check if -nohome was passed in!
        //
        if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-slf") && !IsOS(OS_WIN2000ORGREATER) && IsCalleeIEAK())
            piei->fNoLocalFileWarning = TRUE;
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-nohome"))
            piei->fDontUseHomePage = TRUE;
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-k"))
        {
            piei->fFullScreen = TRUE;
            piei->fNoDragDrop = TRUE;
        }
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-embedding"))
        {
            piei->fAutomation = TRUE;
            // if we're started as an embedding, we don't want to go to our start page
            piei->fDontUseHomePage = TRUE;
        } 
#ifndef UNIX
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-channelband"))
        {
            piei->fDesktopChannel = TRUE;
        } 
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-e")) 
        {
            piei->uFlags |= COF_EXPLORE;

        } 
#else
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-help"))
        {
            piei->fShouldStart = FALSE;
            PrintIEHelp();
            break;
        } 
        else if  (_CheckForOptionOnCmdLine(&pszCmdLine, L"-v") || 
                  _CheckForOptionOnCmdLine(&pszCmdLine, L"-version")) 
        {
            piei->fShouldStart = FALSE;
            PrintIEVersion();
            break;
        } 
#endif
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-root")) 
        {
            ASSERT(piei->pidlRoot==NULL);
            WCHAR szRoot[MAX_PATH];
            if (_GetToken(&pszCmdLine, szRoot, ARRAYSIZE(szRoot))) 
            {
                CLSID clsid, *pclsid = NULL;
                
                TraceMsgW(TF_SHDAUTO, "SHParseIECommandLine got token for /root %s", szRoot);

                if (GUIDFromString(szRoot, &clsid))
                {
                    pclsid = &clsid;
                    _GetToken(&pszCmdLine, szRoot, ARRAYSIZE(szRoot));
                }

                if (szRoot[0]) 
                {
                    LPITEMIDLIST pidlRoot = ILCreateFromPathW(szRoot);
                    if (pidlRoot) 
                    {
                        piei->pidl = ILRootedCreateIDList(pclsid, pidlRoot);
                        ILFree(pidlRoot);
                    } 
                }
            }
        }
        else
        {
#ifdef UNIX
            piei->fShouldStart = FALSE;
#endif
            // unknown option..
            fDontLookForPidl = FALSE;
            break;
        }
    }

    *ppwszCmdLine = pszCmdLine;
    
    return fDontLookForPidl;
}

IETHREADPARAM* SHCreateIETHREADPARAM(LPCWSTR pszCmdLineIn, int nCmdShowIn, ITravelLog *ptlIn, IEFreeThreadedHandShake* piehsIn)
{
    IETHREADPARAM *piei = (IETHREADPARAM *)LocalAlloc(LPTR, sizeof(IETHREADPARAM));
    if (piei)
    {
        piei->pszCmdLine = pszCmdLineIn;    // careful, aliased pointer
        piei->nCmdShow = nCmdShowIn;
        piei->ptl = ptlIn;
        piei->piehs = piehsIn;

        if (piehsIn)
            piehsIn->AddRef();

        if (ptlIn)
            ptlIn->AddRef();
#ifdef UNIX
        piei->fShouldStart = TRUE;
#endif
#ifdef NO_MARSHALLING
        piei->fOnIEThread = TRUE;
#endif 
    }

    return piei;
}

IETHREADPARAM* SHCloneIETHREADPARAM(IETHREADPARAM* pieiIn)
{
    IETHREADPARAM *piei = (IETHREADPARAM *)LocalAlloc(LPTR, sizeof(IETHREADPARAM));
    if (piei)
    {
        *piei = *pieiIn;

        // convert aliased pointers into refs

        if (piei->pidl)
            piei->pidl = ILClone(piei->pidl);
    
        if (piei->pidlSelect)
            piei->pidlSelect = ILClone(piei->pidlSelect);
    
        if (piei->pidlRoot)
            piei->pidlRoot = ILClone(piei->pidlRoot);
    
        if (piei->psbCaller)
            piei->psbCaller->AddRef();
    
        if (piei->ptl)
            piei->ptl->Clone(&piei->ptl);
    }
    return piei;

}

void SHDestroyIETHREADPARAM(IETHREADPARAM* piei)
{
    if (piei)
    {
        if (piei->pidl)
            ILFree(piei->pidl);
    
        if (piei->pidlSelect)
            ILFree(piei->pidlSelect);
    
        if (((piei->uFlags & COF_HASHMONITOR) == 0) && piei->pidlRoot)
            ILFree(piei->pidlRoot);
    
        if (piei->piehs)
            piei->piehs->Release();   // note, this is not a COM object, don't ATOMICRELEASE();

        ATOMICRELEASE(piei->psbCaller);
        ATOMICRELEASE(piei->pSplash);
        ATOMICRELEASE(piei->ptl);
        ATOMICRELEASE(piei->punkRefProcess);

        LocalFree(piei);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\iaccess.h ===
#ifndef _IAccessible_h
#define _IAccessible_h

#include "oleacc.h"
#include "mnbase.h"
#include "menuband.h"

#define CHILDID_SELF 0

#define MB_STATE_TRACK 1
#define MB_STATE_MENU  2
#define MB_STATE_ITEM  4

#define TOOLBAR_MASK 0x80000000

// BUGBUG (lamadio): The designers of the Accessibility interface did not know
// the rule about COM identity. They allow a QI for the external object IEnumVariant

class CAccessible : public IAccessible, public IEnumVARIANT, public IOleWindow
{
    int             _cRef;
    // IDispatch Support
    ITypeInfo*      _pTypeInfo;
    BOOL            _LoadTypeLib();


    // Track menu popup Support
    IAccessible*    _pInnerAcc;
    HWND            _hwndMenuWindow;
    HMENU           _hMenu;
    WORD            _wID;

    // Menuband Support
    CMenuToolbarBase* _pmtbBottom;
    CMenuToolbarBase* _pmtbTop;
    IShellMenuAcc*    _psma;
    IMenuBand*        _pmb;

    // Menuband Item Support
    CMenuToolbarBase*  _pmtbItem;

    int               _iAccIndex;
    int               _iIndex;  
    int               _iEnumIndex;
    int               _idCmd;


    // Object info
    BITBOOL         _fInitialized: 1;
    BITBOOL         _fState: 3;

    HRESULT _GetVariantFromChildIndex(HWND hwnd, int iIndex, VARIANT* pvarChild);
    HRESULT _GetChildFromVariant(VARIANT* pvarChild, CMenuToolbarBase** ppmtb, int* iIndex);
    HRESULT _GetAccessibleItem(int iIndex, IDispatch** ppdisp);
    HRESULT _GetAccName(BSTR* pbstr);
    HRESULT _Navigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);


public:
    CAccessible(HMENU, WORD);
    CAccessible(IMenuBand*);
    CAccessible(IMenuBand*, int iIndex);
    virtual ~CAccessible();
    HRESULT InitAcc();

    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT FAR* pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
        LCID lcid, DISPID FAR* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
        DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
        UINT FAR* puArgErr);


    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);


    // *** IAccessible methods ***
    virtual STDMETHODIMP get_accParent(IDispatch * FAR* ppdispParent);
    virtual STDMETHODIMP get_accChildCount(long FAR* pChildCount);
    virtual STDMETHODIMP get_accChild(VARIANT varChildIndex, IDispatch * FAR* ppdispChild);

    virtual STDMETHODIMP get_accName(VARIANT varChild, BSTR* pszName);
    virtual STDMETHODIMP get_accValue(VARIANT varChild, BSTR* pszValue);
    virtual STDMETHODIMP get_accDescription(VARIANT varChild, BSTR FAR* pszDescription);
    virtual STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    virtual STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);

    
    virtual STDMETHODIMP get_accHelp(VARIANT varChild, BSTR* pszHelp);
    virtual STDMETHODIMP get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
    virtual STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);

    virtual STDMETHODIMP get_accFocus(VARIANT FAR * pvarFocusChild);

    virtual STDMETHODIMP get_accSelection(VARIANT FAR * pvarSelectedChildren);
    
    virtual STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

    virtual STDMETHODIMP accSelect(long flagsSelect, VARIANT varChild);

    virtual STDMETHODIMP accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);

    virtual STDMETHODIMP accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
    virtual STDMETHODIMP accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);

    virtual STDMETHODIMP accDoDefaultAction(VARIANT varChild);

    virtual STDMETHODIMP put_accName(VARIANT varChild, BSTR szName);
    virtual STDMETHODIMP put_accValue(VARIANT varChild, BSTR pszValue);


    // *** IEnumVARIANT methods ***
    virtual STDMETHODIMP Next(unsigned long celt, 
                            VARIANT FAR* rgvar, 
                            unsigned long FAR* pceltFetched); 
    virtual STDMETHODIMP Skip(unsigned long celt); 
    virtual STDMETHODIMP Reset(); 
    virtual STDMETHODIMP Clone(IEnumVARIANT FAR* FAR* ppenum); 
};

extern "C"
{
    LRESULT LresultFromObject(REFIID riid, WPARAM wParam, IUnknown*);
    void WINAPI NotifyWinEvent(DWORD event, HWND hwnd,
        LONG idObject, LONG idChild);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\iaccess.cpp ===
#include "priv.h"
// BUGBUG (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include "apithk.h"
#include "resource.h"
#include "initguid.h"
#include "iaccess.h"

#include "mluisupp.h"

CAccessible::CAccessible(HMENU hmenu, WORD wID):
    _hMenu(hmenu), _wID(wID), _cRef(1)
{
    _fState = MB_STATE_TRACK;
}

CAccessible::CAccessible(IMenuBand* pmb): _cRef(1)
{
    _fState = MB_STATE_MENU;
    _pmb = pmb;
    if (_pmb)
    {
        _pmb->AddRef();
    }
}

CAccessible::CAccessible(IMenuBand* pmb, int iIndex): _cRef(1)
{
    _fState = MB_STATE_ITEM;
    _iAccIndex = iIndex;
    _pmb = pmb;
    if (_pmb)
    {
        _pmb->AddRef();
    }
}

CAccessible::~CAccessible()
{
    ATOMICRELEASE(_pTypeInfo);
    ATOMICRELEASE(_pInnerAcc);
    switch (_fState)
    {
    case MB_STATE_TRACK:
        ASSERT(!_hwndMenuWindow || IsWindow(_hwndMenuWindow));
        if (_hwndMenuWindow)
        {
            // Don't Destroy hmenu. It's part of a larger one...
            SetMenu(_hwndMenuWindow, NULL);
            DestroyWindow(_hwndMenuWindow);
            _hwndMenuWindow = NULL;
        }
        break;

    case MB_STATE_ITEM:
        ATOMICRELEASE(_pmtbItem);
        // Fall Through

    case MB_STATE_MENU:
        ATOMICRELEASE(_pmtbTop);
        ATOMICRELEASE(_pmtbBottom);
        ATOMICRELEASE(_psma);
        ATOMICRELEASE(_pmb);
        break;
    }
}

HRESULT CAccessible::InitAcc()
{
    HRESULT hres = E_FAIL;
    if (_fInitialized)
        return NOERROR;

    _fInitialized = TRUE;   // We're initialized if we fail or not...

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (EVAL(_hMenu))
        {
            _hwndMenuWindow = CreateWindow(TEXT("static"),
                TEXT("MenuWindow"), WS_POPUP, 0, 0, 0, 0, NULL,
                _hMenu, g_hinst, NULL);
            if (EVAL(_hwndMenuWindow))
            {
                IAccessible* paccChild1;
                hres = CreateStdAccessibleObject(_hwndMenuWindow, OBJID_MENU, IID_IAccessible, (void**)&paccChild1);
                if(SUCCEEDED(hres))
                {
                    VARIANT varChild;
                    varChild.vt = VT_I4;
                    varChild.lVal = _wID + 1;        //Accesibility is 1 based

                    // In order to get "On par" with the OleAcc's implementation of the HMENU wrapper,
                    // we need to do this twice. Once gets us the IAccessible for the "MenuItem" on the 
                    // "Menubar". The second gets us the "Menuitem's" child. This is what we need to emulate
                    // their heirarchy.
                    IDispatch* pdispChild1;
                    hres = paccChild1->get_accChild(varChild, &pdispChild1);

                    // OLEAcc returns a Success code (S_FALSE) while initializing the out param to zero.
                    // Explicitly test this situation.

                    // Does this have a Child?
                    if (hres == S_OK)
                    {
                        // Yes. Look for that child
                        IAccessible* paccChild2;
                        hres = pdispChild1->QueryInterface(IID_IAccessible, (void**)&paccChild2);

                        // Does this have a child?
                        if (hres == S_OK)
                        {
                            // Yep, then we store this guy's child...
                            IDispatch* pdispChild2;
                            varChild.lVal = 1;        //Get the first child
                            hres = paccChild2->get_accChild(varChild, &pdispChild2);
                            if (hres == S_OK)
                            {
                                hres = pdispChild2->QueryInterface(IID_IAccessible, (void**)&_pInnerAcc);
                                pdispChild2->Release();
                            }
                            paccChild2->Release();
                        }
                        pdispChild1->Release();
                    }
                    paccChild1->Release();
                }
            }
        }
        break;


    case MB_STATE_ITEM:
    case MB_STATE_MENU:
        hres = _pmb->QueryInterface(IID_IShellMenuAcc, (void**)&_psma);
        if (SUCCEEDED(hres))
        {
            _psma->GetTop(&_pmtbTop);
            _psma->GetBottom(&_pmtbBottom);
        }

        if (_fState == MB_STATE_ITEM)
        {
            VARIANT varChild;
            _GetVariantFromChildIndex(NULL, _iAccIndex, &varChild);
            if (SUCCEEDED(_GetChildFromVariant(&varChild, &_pmtbItem, &_iIndex)))
                _idCmd = GetButtonCmd(_pmtbItem->_hwndMB, _iIndex);
        }

        break;
    }

    return hres;
}



/*----------------------------------------------------------
Purpose: IUnknown::AddRef method

*/
STDMETHODIMP_(ULONG) CAccessible::AddRef()
{
    _cRef++;
    return _cRef;
}


/*----------------------------------------------------------
Purpose: IUnknown::Release method

*/
STDMETHODIMP_(ULONG) CAccessible::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CAccessible::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAccessible, IDispatch),
        QITABENT(CAccessible, IAccessible),
        QITABENT(CAccessible, IEnumVARIANT),
        QITABENT(CAccessible, IOleWindow),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP CAccessible::GetTypeInfoCount(UINT FAR* pctinfo)
{
    if (_pInnerAcc)
        return _pInnerAcc->GetTypeInfoCount(pctinfo);
    *pctinfo = 1;
    return NOERROR;
}

STDMETHODIMP CAccessible::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo)
{
    *pptinfo = NULL;
    if (_pInnerAcc)
        return _pInnerAcc->GetTypeInfo(itinfo, lcid, pptinfo);

    if (itinfo != 0)
        return DISP_E_BADINDEX;

    if (EVAL(_LoadTypeLib()))
    {
        *pptinfo = _pTypeInfo;
        _pTypeInfo->AddRef();
        return NOERROR;
    }
    else
        return E_FAIL;
}

/*----------------------------------------------------------
Purpose: IDispatch::GetIDsOfNames method

*/
STDMETHODIMP CAccessible::GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
        LCID lcid, DISPID FAR* rgdispid)
{
    if (_pInnerAcc)
        return _pInnerAcc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);

    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (EVAL(_LoadTypeLib()))
    {
        return _pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
    }
    else
        return E_FAIL;
}


/*----------------------------------------------------------
Purpose: IDispatch::Invoke method

*/
STDMETHODIMP CAccessible::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
    DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
    UINT FAR* puArgErr)

{
    if (_pInnerAcc)
        return _pInnerAcc->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, 
            pexcepinfo, puArgErr);
    
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (EVAL(_LoadTypeLib()))
    {
        return _pTypeInfo->Invoke(static_cast<IDispatch*>(this),
            dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
    }
    else
        return E_FAIL;
}

BOOL CAccessible::_LoadTypeLib()
{
    ITypeLib* pTypeLib;
    if (_pTypeInfo)
        return TRUE;

    if (SUCCEEDED(LoadTypeLib(L"oleacc.dll", &pTypeLib)))
    {
        pTypeLib->GetTypeInfoOfGuid(IID_IAccessible, &_pTypeInfo);
        ATOMICRELEASE(pTypeLib);
        return TRUE;
    }
    return FALSE;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accParent method

*/
STDMETHODIMP CAccessible::get_accParent(IDispatch * FAR* ppdispParent)
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accParent(ppdispParent);
        break;

    case MB_STATE_MENU:
        {
            IUnknown* punk;
            if (SUCCEEDED(_psma->GetParentSite(IID_IUnknown, (void**)&punk)))
            {
                IAccessible* pacc;
                if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                    IID_IAccessible, (void**)&pacc)))
                {
                    VARIANT varChild = {VT_I4, CHILDID_SELF};     // Init
                    hres = pacc->get_accFocus(&varChild);
                    if (SUCCEEDED(hres))
                    {
                        hres = pacc->get_accChild(varChild, ppdispParent);
                    }
                    VariantClearLazy(&varChild);
                    pacc->Release();
                }
                else
                {
                    // Another implementation headache: Accessibility requires
                    // us to return S_FALSE when there is no parent.

                    *ppdispParent = NULL;
                    hres = S_FALSE;
                }

                punk->Release();
            }

            return hres;
        }
    case MB_STATE_ITEM:
        // The parent of an item is the menuband itself
        return IUnknown_QueryService(_psma, SID_SMenuPopup, IID_IDispatch, (void**)ppdispParent);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accChildCount method

*/
STDMETHODIMP CAccessible::get_accChildCount(long FAR* pChildCount)
{   
    *pChildCount = 0;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accChildCount(pChildCount);
        break;

    case MB_STATE_MENU:
        {
            int iTopCount = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
            int iBottomCount = ToolBar_ButtonCount(_pmtbBottom->_hwndMB);
            *pChildCount = (_pmtbTop != _pmtbBottom)? iTopCount + iBottomCount : iTopCount;
        }
        break;
    case MB_STATE_ITEM:
        if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
            *pChildCount = 1;
        break;

    }
    
    return NOERROR;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accChild method

*/
STDMETHODIMP CAccessible::get_accChild(VARIANT varChildIndex, IDispatch * FAR* ppdispChild)     
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accChild(varChildIndex, ppdispChild);
        break;

    case MB_STATE_MENU:
        {
            if (varChildIndex.vt == VT_I4 && varChildIndex.lVal == CHILDID_SELF)
            {
                // So this is the ONLY menthod that is allowed to fail when something is
                // unavailable.
                *ppdispChild = NULL;
                hres = E_INVALIDARG;
            }
            else
            {
                int iIndex;
                // Since it's returing an index, we don't need to test the success case
                _GetChildFromVariant(&varChildIndex, NULL, &iIndex);
                hres = _GetAccessibleItem(iIndex, ppdispChild);
            }
        }
        break;

    case MB_STATE_ITEM:
        if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
        {
            VARIANT varChild;
            hres = _GetVariantFromChildIndex(_pmtbItem->_hwndMB, _iIndex, &varChild);
            if (SUCCEEDED(hres))
            {
                hres = _psma->GetSubMenu(&varChild, IID_IDispatch, (void**)ppdispChild);
            }
        }
        else
            hres = E_NOINTERFACE;
        break;
    }
    
    return hres;   
}

HRESULT CAccessible::_GetAccName(BSTR* pbstr)
{
    IDispatch* pdisp;
    HRESULT hres = get_accParent(&pdisp);
    // Get parent can return a success code, but still fail to return a parent.
    // This interface sucks.
    if (hres == S_OK)
    {
        IAccessible* pacc;
        hres = pdisp->QueryInterface(IID_IAccessible, (void**)&pacc);
        if (SUCCEEDED(hres))
        {
            VARIANT varChild;
            hres = pacc->get_accFocus(&varChild);
            if (SUCCEEDED(hres))
                hres = pacc->get_accName(varChild, pbstr);
        }
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accName method

*/
STDMETHODIMP CAccessible::get_accName(VARIANT varChild, BSTR* pszName)
{   
    CMenuToolbarBase* pmtb = _pmtbItem;
    int idCmd = _idCmd;

    *pszName = NULL;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accName(varChild, pszName);
        break;

    case MB_STATE_MENU:
        if (varChild.lVal == CHILDID_SELF)
        {
            if (_GetAccName(pszName) == S_FALSE)
            {
                TCHAR sz[100];
                MLLoadString(IDS_ACC_APP, sz, ARRAYSIZE(sz));
                *pszName = SysAllocStringT(sz);
                if (!*pszName)
                    return E_OUTOFMEMORY;
            }
            return NOERROR;
        }
        else
        {
            int iIndex;
            if (FAILED(_GetChildFromVariant(&varChild, &pmtb, &iIndex)))
                return DISP_E_MEMBERNOTFOUND;

            idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
        }

        // Fall Through

    case MB_STATE_ITEM:
        {
            TCHAR sz[MAX_PATH];
            int idString = 0;
            TBBUTTON tbb;
            if (ToolBar_GetButton(pmtb->_hwndMB, _iIndex, &tbb) && 
                tbb.fsStyle & BTNS_SEP)
            {
                idString = IDS_ACC_SEP;
            }
            else if (pmtb->GetChevronID() == _idCmd)
            {
                idString = IDS_ACC_CHEVRON;
            }

            if (idString != 0)
            {
                MLLoadString(idString, sz, ARRAYSIZE(sz));
                *pszName = SysAllocStringT(sz);
            }
            else
            {
                UINT cch = SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, NULL);

                if (cch != 0 && cch < ARRAYSIZE(sz))
                {
                    if (SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
                    {
                        SHStripMneumonic(sz);
                        *pszName = SysAllocString(sz);
                    }
                }
            }

            if (_fState == MB_STATE_MENU)
                pmtb->Release();

            if (!*pszName)
                return E_OUTOFMEMORY;

            return NOERROR;
        }
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accValue method

*/
STDMETHODIMP CAccessible::get_accValue(VARIANT varChild, BSTR* pszValue)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accValue(varChild, pszValue);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // This does not make sense for these.
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accDescription method

*/
STDMETHODIMP CAccessible::get_accDescription(VARIANT varChild, BSTR FAR* pszDescription)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accDescription(varChild, pszDescription);
        break;

    case MB_STATE_MENU:
        if (FAILED(_GetAccName(pszDescription)))
        {
            TCHAR sz[100];
            MLLoadString(IDS_ACC_APPMB, sz, ARRAYSIZE(sz));
            *pszDescription = SysAllocStringT(sz);
            if (!*pszDescription)
                return E_OUTOFMEMORY;
        }
        break;
    case MB_STATE_ITEM:
        return get_accName(varChild, pszDescription);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accRole method

*/
STDMETHODIMP CAccessible::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{   
    pvarRole->vt = VT_I4;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accRole(varChild, pvarRole);
        break;

    case MB_STATE_MENU:
        {
            BOOL fVertical;
            BOOL fOpen;
            _psma->GetState(&fVertical, &fOpen);
            pvarRole->lVal = ( fVertical )? ROLE_SYSTEM_MENUPOPUP : ROLE_SYSTEM_MENUBAR;
            return NOERROR;
        }

    case MB_STATE_ITEM:
        pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
        return NOERROR;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accState method

*/
STDMETHODIMP CAccessible::get_accState(VARIANT varChild, VARIANT *pvarState)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accState(varChild, pvarState);
        break;

    case MB_STATE_MENU:
        {
            // All menus can be selected, and given focus. Most will be visible.
            DWORD dwState = STATE_SYSTEM_FOCUSABLE;

            BOOL fOpen;
            BOOL fVertical;
            _psma->GetState(&fVertical, &fOpen);

            // Do we have a menu popped up?
            if (fOpen)
            {
                // Yes, then we have focus
                dwState |= STATE_SYSTEM_FOCUSED;
            }
            else if (fVertical)
            {
                // If we're a vertical menu without being popped up, then we're invisible.
                dwState |= STATE_SYSTEM_INVISIBLE;
            }


            pvarState->vt = VT_I4;
            pvarState->lVal = dwState;
        }
        return NOERROR;

    case MB_STATE_ITEM:
        {
            DWORD dwAccState = STATE_SYSTEM_FOCUSABLE;

            int idHotTracked = ToolBar_GetHotItem(_pmtbItem->_hwndMB);
            DWORD dwState = ToolBar_GetState(_pmtbItem->_hwndMB, _iIndex);

            if (dwState & TBSTATE_PRESSED)
                dwAccState |= STATE_SYSTEM_SELECTABLE | STATE_SYSTEM_FOCUSED;

            if (idHotTracked == _iIndex)
                dwAccState |= STATE_SYSTEM_HOTTRACKED;

            pvarState->vt = VT_I4;
            pvarState->lVal = dwAccState;

            return NOERROR;
        }
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accHelp method

*/
STDMETHODIMP CAccessible::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accHelp(varChild, pszHelp);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // Not implemented
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accHelpTopic method

*/
STDMETHODIMP CAccessible::get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // Not implemented
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

#define CH_PREFIX TEXT('&')

TCHAR GetAccelerator(LPCTSTR psz, BOOL bUseDefault)
{
    TCHAR ch = (TCHAR)-1;
    LPCTSTR pszAccel = psz;
    // then prefixes are allowed.... see if it has one
    do 
    {
        pszAccel = StrChr(pszAccel, CH_PREFIX);
        if (pszAccel) 
        {
            pszAccel = CharNext(pszAccel);

            // handle having &&
            if (*pszAccel != CH_PREFIX)
                ch = *pszAccel;
            else
                pszAccel = CharNext(pszAccel);
        }
    } while (pszAccel && (ch == (TCHAR)-1));

    if ((ch == (TCHAR)-1) && bUseDefault)
    {
        // Since we're unicocde, we don't need to mess with MBCS
        ch = *psz;
    }

    return ch;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accKeyboardShortcut method

*/
STDMETHODIMP CAccessible::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut)
{   
    CMenuToolbarBase* pmtb;
    int iIndex;
    HRESULT hres = DISP_E_MEMBERNOTFOUND;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
        break;

    case MB_STATE_ITEM:
        pmtb = _pmtbItem;
        pmtb->AddRef();
        iIndex = _iIndex;
        goto labelGetaccel;

    case MB_STATE_MENU:
        {

            if (varChild.lVal != CHILDID_SELF)
            {
                if (SUCCEEDED(_GetChildFromVariant(&varChild, &pmtb, &iIndex)))
                {
labelGetaccel:
                    TCHAR sz[MAX_PATH];
                    TCHAR szAccel[100] = TEXT("");
                    int idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
                    if (S_FALSE == _psma->IsEmpty())
                    {
                        UINT cch = SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, NULL);

                        if (cch != 0 && cch < ARRAYSIZE(sz))
                        {
                            if (SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
                            {
                                BOOL fVertical, fOpen;
                                _psma->GetState(&fVertical, &fOpen);
                                if (!fVertical)
                                {
                                    MLLoadString(IDS_ACC_ALT, szAccel, ARRAYSIZE(szAccel));
                                }
                                szAccel[lstrlen(szAccel)] = GetAccelerator(sz, TRUE);
                                szAccel[lstrlen(szAccel)] = TEXT('\0');
                                hres = S_OK;
                            }
                        }
                    }

                    *pszKeyboardShortcut = SysAllocStringT(szAccel);
                    if (!*pszKeyboardShortcut)
                        hres = E_OUTOFMEMORY;
                    pmtb->Release();
                }
            }

        }
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accFocus method

*/
STDMETHODIMP CAccessible::get_accFocus(VARIANT FAR * pvarFocusChild)
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accFocus(pvarFocusChild);
        break;

    case MB_STATE_MENU:
        {
            pvarFocusChild->vt = VT_I4;
            pvarFocusChild->lVal = CHILDID_SELF;

            CMenuToolbarBase* pmtbTracked;
            _psma->GetTracked(&pmtbTracked);
            if (pmtbTracked)
            {
                int iIndex = ToolBar_GetHotItem(pmtbTracked->_hwndMB);
                hres = _GetVariantFromChildIndex(pmtbTracked->_hwndMB, 
                    iIndex, pvarFocusChild);
                pmtbTracked->Release();
            }
        }
        break;

    case MB_STATE_ITEM:
        // Not implemented;
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accSelection method

*/
STDMETHODIMP CAccessible::get_accSelection(VARIANT FAR * pvarSelectedChildren)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accSelection(pvarSelectedChildren);
        break;

    case MB_STATE_MENU:
        return get_accFocus(pvarSelectedChildren);
        break;

    case MB_STATE_ITEM:
        // Not implemented;
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accDefaultAction method

*/
STDMETHODIMP CAccessible::get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction)
{   
    TCHAR sz[MAX_PATH];

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accDefaultAction(varChild, pszDefaultAction);
        break;

    case MB_STATE_MENU:
        {
            MLLoadString(IDS_ACC_CLOSE, sz, ARRAYSIZE(sz));
            *pszDefaultAction = SysAllocStringT(sz);

            if (!*pszDefaultAction)
                return E_OUTOFMEMORY;

            return NOERROR;
        }

    case MB_STATE_ITEM:
        {
            if (S_OK == _psma->IsEmpty())
            {
                sz[0] = TEXT('\0');
            }
            else
            {
                int iId = (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)? IDS_ACC_OPEN: IDS_ACC_EXEC;
                MLLoadString(iId, sz, ARRAYSIZE(sz));
            }

            *pszDefaultAction = SysAllocStringT(sz);
            if (!*pszDefaultAction)
                return E_OUTOFMEMORY;

            return NOERROR;
        }
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accSelect method

*/
STDMETHODIMP CAccessible::accSelect(long flagsSelect, VARIANT varChild)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accSelect(flagsSelect, varChild);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accLocation method

*/
STDMETHODIMP CAccessible::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{   
    CMenuToolbarBase* pmtb;
    int iIndex;
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
        break;

    case MB_STATE_ITEM:
        pmtb = _pmtbItem;
        pmtb->AddRef();
        iIndex = _iIndex;
        hres = NOERROR;
        goto labelGetRect;

    case MB_STATE_MENU:
        {
            RECT rc;
            if (varChild.vt == VT_I4)
            {
                if (varChild.lVal == CHILDID_SELF)
                {
                    IUnknown* punk;
                    hres = _psma->GetParentSite(IID_IUnknown, (void**)&punk);
                    if (SUCCEEDED(hres))
                    {
                        IOleWindow* poct;
                        hres = IUnknown_QueryService(punk, SID_SMenuPopup, 
                            IID_IOleWindow, (void**)&poct);
                        if (SUCCEEDED(hres))
                        {
                            HWND hwnd;
                            hres = poct->GetWindow(&hwnd);
                            if (SUCCEEDED(hres))
                            {
                                // Return the window rect of the menubar.
                                GetWindowRect(hwnd, &rc);
                            }

                            poct->Release();
                        }

                        punk->Release();
                    }
                }
                else
                {
                    hres = _GetChildFromVariant(&varChild, &pmtb, &iIndex);
                    if (SUCCEEDED(hres))
                    {

labelGetRect:           int idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
                        if (!ToolBar_GetRect(pmtb->_hwndMB, idCmd, &rc))  //1 based index
                            hres = E_INVALIDARG;
                        MapWindowPoints(pmtb->_hwndMB, NULL, (LPPOINT)&rc, 2);
                        pmtb->Release();
                    }
                }

                if (SUCCEEDED(hres))
                {
                    *pxLeft = rc.left;
                    *pyTop = rc.top;
                    *pcxWidth = rc.right - rc.left;
                    *pcyHeight = rc.bottom - rc.top;
                }
            }
        }
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accNavigate method

*/
STDMETHODIMP CAccessible::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)     
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accNavigate(navDir, varStart, pvarEndUpAt);
        break;

    case MB_STATE_MENU:
        return _Navigate(navDir, varStart, pvarEndUpAt);
        break;

    case MB_STATE_ITEM:
        {
            VARIANT varChild;
            _GetVariantFromChildIndex(NULL, _iAccIndex, &varChild);
            return _Navigate(navDir, varChild, pvarEndUpAt);
        }
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accHitTest method

*/
STDMETHODIMP CAccessible::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{   
    POINT pt = {xLeft, yTop};
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accHitTest(xLeft, yTop, pvarChildAtPoint);
        break;

    case MB_STATE_MENU:
        {
            if (_psma)
            {
                int iIndex;
                HWND hwnd = WindowFromPoint(pt);

                if (hwnd == _pmtbTop->_hwndMB || hwnd == _pmtbBottom->_hwndMB)
                {
                    ScreenToClient(hwnd, &pt);
                    iIndex = ToolBar_HitTest(hwnd, &pt);
                    if (iIndex >= 0)
                    {
                        pvarChildAtPoint->vt = VT_DISPATCH;
                        // This call expects the index to be an "Accessible" index which is one based
                        VARIANT varChild;
                        _GetVariantFromChildIndex(hwnd, iIndex, &varChild);

                        //Since this is just returining an index, we don't need to test success
                        _GetChildFromVariant(&varChild, NULL, &iIndex);
                        return _GetAccessibleItem(iIndex, &pvarChildAtPoint->pdispVal);
                    }
                }

                // Hmm, must be self
                pvarChildAtPoint->vt = VT_I4;
                pvarChildAtPoint->lVal = CHILDID_SELF;

                return S_OK;
            }
        }
        break;

    case MB_STATE_ITEM:
        {
            RECT rc;
            MapWindowPoints(NULL, _pmtbItem->_hwndMB, &pt, 1);

            if (ToolBar_GetRect(_pmtbItem->_hwndMB, _idCmd, &rc) &&
                PtInRect(&rc, pt))
            {
                pvarChildAtPoint->vt = VT_I4;
                pvarChildAtPoint->lVal = CHILDID_SELF;
            }
            else
            {
                pvarChildAtPoint->vt = VT_EMPTY;
                pvarChildAtPoint->lVal = (DWORD)(-1);
            }
            return NOERROR;
        }
        break;

    }
    
    return DISP_E_MEMBERNOTFOUND;
}

/*----------------------------------------------------------
Purpose: IAccessible::accDoDefaultAction method

*/
STDMETHODIMP CAccessible::accDoDefaultAction(VARIANT varChild)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accDoDefaultAction(varChild);
        break;

    case MB_STATE_MENU:
        if (_psma)
            return _psma->DoDefaultAction(&varChild);
        break;

    case MB_STATE_ITEM:
        if (SendMessage(_pmtbItem->_hwndMB, TB_SETHOTITEM2, _iIndex, 
            HICF_OTHER | HICF_RESELECT | HICF_TOGGLEDROPDOWN))
            return NOERROR;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::put_accName method

*/
STDMETHODIMP CAccessible::put_accName(VARIANT varChild, BSTR szName)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->put_accName(varChild, szName);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::put_accValue method

*/
STDMETHODIMP CAccessible::put_accValue(VARIANT varChild, BSTR pszValue)  
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
       if (_pInnerAcc)
            return _pInnerAcc->put_accValue(varChild, pszValue);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}


HRESULT CAccessible::_Navigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    ASSERT(pvarEndUpAt);
    int iIndex = 0;         // 1 based index
    int iTBIndex;
    HRESULT hres = S_FALSE;
    TBBUTTONINFO tbInfo;
    int idCmd;
    VARIANT varTemp;
    CMenuToolbarBase* pmtb;
    BOOL fVertical;
    BOOL fOpen;


    tbInfo.cbSize = sizeof(TBBUTTONINFO);

    pvarEndUpAt->vt = VT_DISPATCH;
    pvarEndUpAt->pdispVal = NULL;

    _GetChildFromVariant(&varStart, NULL, &iIndex);

    _psma->GetState(&fVertical, &fOpen);
    if (!fVertical)
    {
        static const long navMap[] = 
        {
            NAVDIR_LEFT,    // Map to Up
            NAVDIR_RIGHT,   // Map to Down
            NAVDIR_UP,      // Map to Left
            NAVDIR_DOWN,    // Map to Right
        };
        if (IsInRange(navDir, NAVDIR_UP, NAVDIR_RIGHT))
            navDir = navMap[navDir - NAVDIR_UP];
    }

    switch (navDir)
    {
    case NAVDIR_NEXT:
        {
            VARIANT varVert;
            varVert.vt = VT_BOOL;
            // For the Vertical case, Next should return an error. 

            // Is this band vertical?
            // Don't do this for anything but the menu case.
            if (_fState == MB_STATE_MENU &&
                SUCCEEDED(IUnknown_QueryServiceExec(_psma, SID_SMenuBandParent, &CGID_MenuBand, 
                          MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                varVert.boolVal == VARIANT_TRUE)
            {
                // Yes. Then punt
                hres = S_FALSE;
                break;
            }
            // Fall Through
        }
        //Fall through
    case NAVDIR_DOWN:

        hres = NOERROR;
        while (SUCCEEDED(hres))
        {
            iIndex++;
            hres = _GetVariantFromChildIndex(NULL, iIndex, &varTemp);
            if (SUCCEEDED(hres))
            {
                hres = _GetChildFromVariant(&varTemp, &pmtb, &iTBIndex);
                if (SUCCEEDED(hres))
                {
                    tbInfo.dwMask = TBIF_STATE | TBIF_STYLE;
                    idCmd = GetButtonCmd(pmtb->_hwndMB, iTBIndex);
                    ToolBar_GetButtonInfo(pmtb->_hwndMB, idCmd, &tbInfo);
                    pmtb->Release();

                    if (!(tbInfo.fsState & TBSTATE_HIDDEN) &&
                        !(tbInfo.fsStyle & TBSTYLE_SEP))
                    {
                        break;
                    }
                }
            }
        }
        break;

    case NAVDIR_FIRSTCHILD:
        if (_fState == MB_STATE_ITEM)
        {
            pvarEndUpAt->vt = VT_EMPTY;
            pvarEndUpAt->pdispVal = NULL;
            hres = S_FALSE;
            break;
        }

        iIndex = 0;
        hres = NOERROR;
        break;

    case NAVDIR_LASTCHILD:
        if (_fState == MB_STATE_ITEM)
        {
            pvarEndUpAt->vt = VT_EMPTY;
            pvarEndUpAt->pdispVal = NULL;
            hres = S_FALSE;
            break;
        }
        iIndex = -1;
        hres = NOERROR;
        break;

    case NAVDIR_LEFT:
        pvarEndUpAt->vt = VT_DISPATCH;
        return get_accParent(&pvarEndUpAt->pdispVal);
        break;

    case NAVDIR_RIGHT:
        {
            CMenuToolbarBase* pmtb = (varStart.lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
            int idCmd = GetButtonCmd(pmtb->_hwndMB, (varStart.lVal & ~TOOLBAR_MASK) - 1);
            if (pmtb->v_GetFlags(idCmd) & SMIF_SUBMENU)
            {
                IMenuPopup* pmp;
                hres = _psma->GetSubMenu(&varStart, IID_IMenuPopup, (void**)&pmp);
                if (SUCCEEDED(hres))
                {
                    IAccessible* pacc;
                    hres = IUnknown_QueryService(pmp, SID_SMenuBandChild, IID_IAccessible, (void**)&pacc);
                    if (SUCCEEDED(hres))
                    {
                        hres = pacc->accNavigate(NAVDIR_FIRSTCHILD, varStart, pvarEndUpAt);
                        pacc->Release();
                    }
                    pmp->Release();
                }
            }

                return hres;
        }
        break;

    case NAVDIR_PREVIOUS:
        {
            VARIANT varVert;
            varVert.vt = VT_BOOL;
            // For the Vertical case, Pervious should return an error. 

            // Is this band vertical?
            // Don't do this for anything but the menu case.
            if (_fState == MB_STATE_MENU &&
                SUCCEEDED(IUnknown_QueryServiceExec(_psma, SID_SMenuBandParent, &CGID_MenuBand, 
                          MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                varVert.boolVal == VARIANT_TRUE)
            {
                // Yes. Then punt
                hres = S_FALSE;
                break;
            }
            // Fall Through
        }
        //Fall through

    case NAVDIR_UP:
        hres = NOERROR;
        while (SUCCEEDED(hres))
        {
            iIndex--;
            hres = _GetVariantFromChildIndex(NULL, iIndex, &varTemp);
            if (SUCCEEDED(hres))
            {
                hres = _GetChildFromVariant(&varTemp, &pmtb, &iTBIndex);
                if (SUCCEEDED(hres))
                {
                    if (iTBIndex == 0)    
                    {   
                        hres = S_FALSE;
                        //Don't navigate to self, allow the top bar to get a whack.
                        IUnknown* punk;
                        if (SUCCEEDED(_psma->GetParentSite(IID_IOleCommandTarget, (void**)&punk)))
                        {
                            IOleCommandTarget* poct;
                            if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                                IID_IOleCommandTarget, (void**)&poct)))
                            {
                                VARIANT varVert;
                                varVert.vt = VT_BOOL;

                                if (SUCCEEDED(poct->Exec(&CGID_MenuBand, MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                                    varVert.boolVal == VARIANT_FALSE)
                                {
                                    IAccessible* pacc;
                                    if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                                        IID_IAccessible, (void**)&pacc)))
                                    {
                                        VARIANT varChild = {VT_I4, CHILDID_SELF};
                                        hres = pacc->get_accFocus(&varChild);
                                        if (SUCCEEDED(hres))
                                        {
                                            hres = pacc->get_accChild(varChild, &pvarEndUpAt->pdispVal);
                                        }

                                        VariantClearLazy(&varChild);
                                        pacc->Release();
                                    }
                                }
                                poct->Release();
                            }
                            punk->Release();
                        }
                    }   // iTBIndex == 0

                    tbInfo.dwMask = TBIF_STATE | TBIF_STYLE;
                    idCmd = GetButtonCmd(pmtb->_hwndMB, iTBIndex);
                    ToolBar_GetButtonInfo(pmtb->_hwndMB, idCmd, &tbInfo);
                    pmtb->Release();

                    if (!(tbInfo.fsState & TBSTATE_HIDDEN) &&
                        !(tbInfo.fsStyle & TBSTYLE_SEP))
                    {
                        break;
                    }
                }
            }
        }
        break;

    default:
        hres = E_INVALIDARG;
    }

    if (SUCCEEDED(hres) && S_FALSE != hres)
        hres = _GetAccessibleItem(iIndex, &pvarEndUpAt->pdispVal);

    return hres;
}

HRESULT CAccessible::_GetVariantFromChildIndex(HWND hwnd, int iIndex, VARIANT* pvarChild)
{
    // First bit: Top 1, bottom 0
    // Rest is index into that toolbar.
    pvarChild->vt = VT_I4;
    pvarChild->lVal = iIndex + 1;

    if (hwnd)
    {
        if (hwnd == _pmtbTop->_hwndMB)
        {
            pvarChild->lVal |= TOOLBAR_MASK;
        }
    }
    else
    {
        // Caller wants us to figure out based on index from top.
        int iTopCount = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
        int iBottomCount = ToolBar_ButtonCount(_pmtbBottom->_hwndMB);
        int iTotalCount = (_pmtbTop != _pmtbBottom)? iTopCount + iBottomCount : iTopCount;

        if (iIndex < iTopCount)
        {
            pvarChild->lVal |= TOOLBAR_MASK;
        }
        else
        {
            pvarChild->lVal -= iTopCount;
        }

        // This works because:
        // If there are 2 toolbars, the bottom one is represented by top bit clear.
        // If there is only one, then it doesn't matter if it's top or bottom.

        // lVal is not zero based....
        if (iIndex == -1)
            pvarChild->lVal = iTotalCount;

        if (iIndex >= iTotalCount)
            return E_FAIL;
    }

    return NOERROR;
}

HRESULT CAccessible::_GetChildFromVariant(VARIANT* pvarChild, CMenuToolbarBase** ppmtb, int* piIndex)
{
    ASSERT(_pmtbTop && _pmtbBottom);
    ASSERT(piIndex);

    if (ppmtb)
        *ppmtb = NULL;

    *piIndex = -1;

    // Passing a NULL for an HWND returns the index from the beginning of the set.
    int iAdd = 0;
    if (pvarChild->vt != VT_I4)
        return E_FAIL;

    if (pvarChild->lVal & TOOLBAR_MASK)
    {
        if (ppmtb)
        {
            *ppmtb = _pmtbTop;
        }
    }
    else
    {
        if (ppmtb)
        {
            *ppmtb = _pmtbBottom;
        }
        else
        {
            iAdd = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
        }
    }

    if (ppmtb && *ppmtb)
        (*ppmtb)->AddRef();

    *piIndex = (pvarChild->lVal & ~TOOLBAR_MASK) + iAdd - 1;

    return (ppmtb && !*ppmtb) ? E_FAIL : S_OK;
}


HRESULT CAccessible::_GetAccessibleItem(int iIndex, IDispatch** ppdisp)
{
    HRESULT hres = E_OUTOFMEMORY;
    CAccessible* pacc = new CAccessible(_pmb, iIndex);

    if (pacc)
    {
        hres = pacc->InitAcc();
        if (SUCCEEDED(hres))
        {
            hres = pacc->QueryInterface(IID_IDispatch, (void**) ppdisp);
        }
        pacc->Release();
    }
    return hres;
}

// *** IEnumVARIANT methods ***
STDMETHODIMP CAccessible::Next(unsigned long celt, 
                        VARIANT FAR* rgvar, 
                        unsigned long FAR* pceltFetched)
{

    // Picky customer complaint. Check for NULL...
    if (pceltFetched)
        *pceltFetched = 1;
    return _GetVariantFromChildIndex(NULL, _iEnumIndex++, rgvar);
}

STDMETHODIMP CAccessible::Skip(unsigned long celt)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAccessible::Reset()
{
    _iEnumIndex = 0;
    return NOERROR;
}

STDMETHODIMP CAccessible::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    return E_NOTIMPL;
}

// *** IOleWindow methods ***
STDMETHODIMP CAccessible::GetWindow(HWND * lphwnd)
{
    *lphwnd = NULL;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        *lphwnd = _hwndMenuWindow;
        break;

    case MB_STATE_ITEM:
        *lphwnd = _pmtbItem->_hwndMB;
        break;

    case MB_STATE_MENU:
        *lphwnd = _pmtbTop->_hwndMB;
        break;
    }

    if (*lphwnd)
        return NOERROR;

    return E_FAIL;
}

STDMETHODIMP CAccessible::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\imgctx.cpp ===
#include "priv.h"
#include <iimgctx.h>
#include "strsafe.h"

class CImgCtxThumb :  public IExtractImage2,
                      public IRunnableTask,
                      public IPersistFile
{
public:
    CImgCtxThumb();
    ~CImgCtxThumb();

    STDMETHOD(QueryInterface) (REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    // IExtractImage
    STDMETHOD (GetLocation) (LPWSTR pszPathBuffer,
                              DWORD cch,
                              DWORD * pdwPriority,
                              const SIZE * prgSize,
                              DWORD dwRecClrDepth,
                              DWORD *pdwFlags);

    STDMETHOD (Extract)(HBITMAP * phBmpThumbnail);

    STDMETHOD (GetDateStamp) (FILETIME * pftTimeStamp);

    // IPersistFile
    STDMETHOD (GetClassID)(CLSID *pClassID);
    STDMETHOD (IsDirty)();
    STDMETHOD (Load)(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD (Save)(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHOD (SaveCompleted)(LPCOLESTR pszFileName);
    STDMETHOD (GetCurFile)(LPOLESTR *ppszFileName);

    STDMETHOD (Run)();
    STDMETHOD (Kill)(BOOL fWait);
    STDMETHOD (Suspend)();
    STDMETHOD (Resume)();
    STDMETHOD_(ULONG, IsRunning)();

    STDMETHOD (InternalResume)();

protected:
    friend void CALLBACK OnImgCtxChange(void * pvImgCtx, void * pv);
    void CImgCtxThumb::CalcAspectScaledRect(const SIZE * prgSize,
                                             RECT * pRect);
    void CImgCtxThumb::CalculateAspectRatio(const SIZE * prgSize,
                                             RECT * pRect);

    long m_cRef;
    BITBOOL m_fAsync : 1;
    BITBOOL m_fOrigSize : 1;
    WCHAR m_szPath[MAX_PATH * 4 + 7];
    HANDLE m_hEvent;
    SIZE m_rgSize;
    DWORD m_dwRecClrDepth;
    IImgCtx * m_pImg;
    LONG m_lState;
    HBITMAP * m_phBmp;
};

STDAPI CImgCtxThumb_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    CImgCtxThumb * pExtract = new CImgCtxThumb();
    if (pExtract != NULL)
    {
        *ppunk = SAFECAST(pExtract, IPersistFile *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

CImgCtxThumb::CImgCtxThumb()
{
    m_fAsync = FALSE;
    StringCchCopyW(m_szPath, ARRAYSIZE(m_szPath), L"file://");
    m_cRef = 1;

    DllAddRef();
}


CImgCtxThumb::~CImgCtxThumb()
{
    ATOMICRELEASE(m_pImg);
    if (m_hEvent)
    {
        CloseHandle(m_hEvent);
    }
    DllRelease();
}

STDMETHODIMP CImgCtxThumb::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CImgCtxThumb, IExtractImage, IExtractImage2),
        QITABENT(CImgCtxThumb, IExtractImage2),
        QITABENT(CImgCtxThumb, IRunnableTask),
        QITABENT(CImgCtxThumb, IPersistFile),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CImgCtxThumb::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CImgCtxThumb::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CImgCtxThumb::GetLocation (LPWSTR pszPathBuffer,
                                         DWORD cch,
                                         DWORD * pdwPriority,
                                         const SIZE * prgSize,
                                         DWORD dwRecClrDepth,
                                         DWORD *pdwFlags)
{
    if (!pdwFlags || !pszPathBuffer || !prgSize)
    {
        return E_INVALIDARG;
    }

    m_rgSize = *prgSize;
    m_dwRecClrDepth = dwRecClrDepth;

    HRESULT hr = S_OK;
    if (*pdwFlags & IEIFLAG_ASYNC)
    {
        if (!pdwPriority)
        {
            return E_INVALIDARG;
        }

        hr = E_PENDING;
        m_fAsync = TRUE;
    }

    m_fOrigSize = BOOLIFY(*pdwFlags & IEIFLAG_ORIGSIZE);

    *pdwFlags = IEIFLAG_CACHE;

    hr = PathCreateFromUrlW(m_szPath, pszPathBuffer, &cch, URL_UNESCAPE);

    return hr;
}

void CALLBACK OnImgCtxChange(void * pvImgCtx, void * pv)
{
    CImgCtxThumb * pThis = (CImgCtxThumb *) pv;
    ASSERT(pThis);
    ASSERT(pThis->m_hEvent);

    // we only asked to know about complete anyway....
    SetEvent(pThis->m_hEvent);
}

// This function makes no assumption about whether the thumbnail is square, so
// it calculates the scaling ratio for both dimensions and the uses that as
// the scaling to maintain the aspect ratio.
void CImgCtxThumb::CalcAspectScaledRect(const SIZE * prgSize, RECT * pRect)
{
    ASSERT(pRect->left == 0);
    ASSERT(pRect->top == 0);

    int iWidth = pRect->right;
    int iHeight = pRect->bottom;
    int iXRatio = (iWidth * 1000) / prgSize->cx;
    int iYRatio = (iHeight * 1000) / prgSize->cy;

    if (iXRatio > iYRatio)
    {
        pRect->right = prgSize->cx;

        // work out the blank space and split it evenly between the top and the bottom...
        int iNewHeight = ((iHeight * 1000) / iXRatio);
        if (iNewHeight == 0)
        {
            iNewHeight = 1;
        }

        int iRemainder = prgSize->cy - iNewHeight;

        pRect->top = iRemainder / 2;
        pRect->bottom = iNewHeight + pRect->top;
    }
    else
    {
        pRect->bottom = prgSize->cy;

        // work out the blank space and split it evenly between the left and the right...
        int iNewWidth = ((iWidth * 1000) / iYRatio);
        if (iNewWidth == 0)
        {
            iNewWidth = 1;
        }
        int iRemainder = prgSize->cx - iNewWidth;

        pRect->left = iRemainder / 2;
        pRect->right = iNewWidth + pRect->left;
    }
}

void CImgCtxThumb::CalculateAspectRatio(const SIZE * prgSize, RECT * pRect)
{
    int iHeight = abs(pRect->bottom - pRect->top);
    int iWidth = abs(pRect->right - pRect->left);

    // check if the initial bitmap is larger than the size of the thumbnail.
    if (iWidth > prgSize->cx || iHeight > prgSize->cy)
    {
        pRect->left = 0;
        pRect->top = 0;
        pRect->right = iWidth;
        pRect->bottom = iHeight;

        CalcAspectScaledRect(prgSize, pRect);
    }
    else
    {
        // if the bitmap was smaller than the thumbnail, just center it.
        pRect->left = (prgSize->cx - iWidth) / 2;
        pRect->top = (prgSize->cy- iHeight) / 2;
        pRect->right = pRect->left + iWidth;
        pRect->bottom = pRect->top + iHeight;
    }
}

STDMETHODIMP CImgCtxThumb::Extract(HBITMAP * phBmpThumbnail)
{
    m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!m_hEvent)
    {
        return E_OUTOFMEMORY;
    }

    m_phBmp = phBmpThumbnail;

    return InternalResume();
}

STDMETHODIMP CImgCtxThumb::GetDateStamp(FILETIME * pftTimeStamp)
{
    HRESULT hr = E_FAIL;
    ASSERT(pftTimeStamp);

    WIN32_FIND_DATAW rgData;
    WCHAR szBuffer[MAX_PATH];

    DWORD dwSize = ARRAYSIZE(szBuffer);
    hr = PathCreateFromUrlW(m_szPath, szBuffer, &dwSize, URL_UNESCAPE);
    if (SUCCEEDED(hr))
    {
        HANDLE hFind = FindFirstFileW(szBuffer, &rgData);
        if (INVALID_HANDLE_VALUE != hFind)
        {
            *pftTimeStamp = rgData.ftLastWriteTime;
            FindClose(hFind);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

STDMETHODIMP CImgCtxThumb::GetClassID(CLSID *pClassID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImgCtxThumb::IsDirty()
{
    return E_NOTIMPL;
}

STDMETHODIMP CImgCtxThumb::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    if (!pszFileName)
    {
        return E_INVALIDARG;
    }

    if (lstrlenW(pszFileName) > ARRAYSIZE(m_szPath) - 6)
    {
        return E_FAIL;
    }

    DWORD dwSize = ARRAYSIZE(m_szPath);
    return UrlCreateFromPathW(pszFileName, m_szPath, &dwSize, URL_ESCAPE_UNSAFE);
}

STDMETHODIMP CImgCtxThumb::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImgCtxThumb::SaveCompleted(LPCOLESTR pszFileName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImgCtxThumb::GetCurFile(LPOLESTR *ppszFileName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImgCtxThumb::Run()
{
    return E_NOTIMPL;
}

STDMETHODIMP CImgCtxThumb::Kill(BOOL fUnused)
{
    LONG lRes = InterlockedExchange(& m_lState, IRTIR_TASK_PENDING);
    if (lRes != IRTIR_TASK_RUNNING)
    {
        m_lState = lRes;
    }

    if (m_hEvent)
        SetEvent(m_hEvent);

    return S_OK;
}

STDMETHODIMP CImgCtxThumb::Resume()
{
    if (m_lState != IRTIR_TASK_SUSPENDED)
    {
        return S_FALSE;
    }

    return InternalResume();
}

STDMETHODIMP CImgCtxThumb::Suspend()
{
    LONG lRes = InterlockedExchange(& m_lState, IRTIR_TASK_SUSPENDED);
    if (lRes != IRTIR_TASK_RUNNING)
    {
        m_lState = lRes;
    }

    if (m_hEvent)
        SetEvent(m_hEvent);

    return S_OK;
}

STDMETHODIMP_(ULONG) CImgCtxThumb::IsRunning()
{
    return m_lState;
}

STDMETHODIMP CImgCtxThumb::InternalResume()
{
    if (m_phBmp == NULL)
    {
        return E_UNEXPECTED;
    }

    m_lState = IRTIR_TASK_RUNNING;

    HRESULT hr = S_OK;
    if (!m_pImg)
    {
        hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IImgCtx, &m_pImg));
        if (SUCCEEDED(hr))
        {
            ASSERT(m_pImg);

            hr = m_pImg->Load(m_szPath, DWN_RAWIMAGE | m_dwRecClrDepth);
            if (SUCCEEDED(hr))
            {
                hr = m_pImg->SetCallback(OnImgCtxChange, this);
            }
            if (SUCCEEDED(hr))
            {
                hr = m_pImg->SelectChanges(IMGCHG_COMPLETE, 0, TRUE);
            }
            if (FAILED(hr))
            {
                ATOMICRELEASE(m_pImg);
                m_lState = IRTIR_TASK_FINISHED;
                return hr;
            }
        }
        else
        {
            m_lState = IRTIR_TASK_FINISHED;
            return hr;
        }
    }

    ULONG fState;
    SIZE  rgSize;

    m_pImg->GetStateInfo(&fState, &rgSize, TRUE);

    if (!(fState & IMGLOAD_COMPLETE))
    {
        do
        {
            DWORD dwRet = MsgWaitForMultipleObjects(1, &m_hEvent, FALSE, INFINITE, QS_ALLINPUT);

            if (dwRet != WAIT_OBJECT_0)
            {
                // check the event anyway, msgs get checked first, so
                // it could take a while for this to get fired otherwise..
                dwRet = WaitForSingleObject(m_hEvent, 0);
            }
            if (dwRet == WAIT_OBJECT_0)
            {
                break;
            }

            MSG msg;
            // empty the message queue...
            while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if ((msg.message >= WM_KEYFIRST && msg.message <= WM_KEYLAST) ||
                    (msg.message >= WM_MOUSEFIRST && msg.message <= WM_MOUSELAST  && msg.message != WM_MOUSEMOVE))
                {
                    continue;
                }

                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        } while (TRUE);

        // check why we broke out...
        if (m_lState == IRTIR_TASK_PENDING)
        {
            m_lState = IRTIR_TASK_FINISHED;
            m_pImg->Disconnect();
            ATOMICRELEASE(m_pImg);
            return E_FAIL;
        }
        if (m_lState == IRTIR_TASK_SUSPENDED)
            return E_PENDING;
        m_pImg->GetStateInfo(&fState, &rgSize, TRUE);
    }

    hr = (fState & IMGLOAD_ERROR) ? E_FAIL : S_OK;

    if (SUCCEEDED(hr))
    {
        HDC hdc = GetDC(NULL);
        // LINTASSERT(hdc || !hdc);     // 0 semi-ok
        void *lpBits;

        HDC hdcBmp = CreateCompatibleDC(hdc);
        if (hdcBmp && hdc)
        {
            struct {
                BITMAPINFOHEADER bi;
                DWORD            ct[256];
            } dib;

            dib.bi.biSize            = sizeof(BITMAPINFOHEADER);
            // On NT5 we go directly to the thumbnail with StretchBlt
            // on other OS's we make a full size copy and pass the bits
            // to ScaleSharpen2().
            if (IsOS(OS_WIN2000ORGREATER))
            {
                dib.bi.biWidth       = m_rgSize.cx;
                dib.bi.biHeight      = m_rgSize.cy;
            }
            else
            {
                dib.bi.biWidth       = rgSize.cx;
                dib.bi.biHeight      = rgSize.cy;
            }
            dib.bi.biPlanes          = 1;
            dib.bi.biBitCount        = (WORD) m_dwRecClrDepth;
            dib.bi.biCompression     = BI_RGB;
            dib.bi.biSizeImage       = 0;
            dib.bi.biXPelsPerMeter   = 0;
            dib.bi.biYPelsPerMeter   = 0;
            dib.bi.biClrUsed         = (m_dwRecClrDepth <= 8) ? (1 << m_dwRecClrDepth) : 0;
            dib.bi.biClrImportant    = 0;

            HPALETTE hpal = NULL;
            HPALETTE hpalOld = NULL;

            if (m_dwRecClrDepth <= 8)
            {
                if (m_dwRecClrDepth == 8)
                {
                    // need to get the right palette....
                    hr = m_pImg->GetPalette(& hpal);
                }
                else
                {
                    hpal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);
                }

                if (SUCCEEDED(hr) && hpal)
                {
                    hpalOld = SelectPalette(hdcBmp, hpal, TRUE);
                    // LINTASSERT(hpalOld || !hpalOld); // 0 semi-ok for SelectPalette
                    RealizePalette(hdcBmp);

                    int n = GetPaletteEntries(hpal, 0, 256, (LPPALETTEENTRY)&dib.ct[0]);

                    ASSERT(n >= (int) dib.bi.biClrUsed);
                    for (int i = 0; i < (int)dib.bi.biClrUsed; i ++)
                        dib.ct[i] = RGB(GetBValue(dib.ct[i]),GetGValue(dib.ct[i]),GetRValue(dib.ct[i]));
                }
            }

            HBITMAP hBmp = CreateDIBSection(hdcBmp, (LPBITMAPINFO)&dib, DIB_RGB_COLORS, &lpBits, NULL, 0);
            if (hBmp != NULL)
            {
                HGDIOBJ hOld = SelectObject(hdcBmp, hBmp);

                // On NT5 Go directly to the Thumbnail with StretchBlt()
                if (IsOS(OS_WIN2000ORGREATER))
                {
                    // Compute output size of thumbnail
                    RECT rectThumbnail;
                    rectThumbnail.left   = 0;
                    rectThumbnail.top    = 0;
                    
                    rectThumbnail.right  = m_rgSize.cx;
                    rectThumbnail.bottom = m_rgSize.cy;
                    
                    FillRect(hdcBmp, &rectThumbnail, (HBRUSH) (COLOR_WINDOW+1));
                    rectThumbnail.right  = rgSize.cx;
                    rectThumbnail.bottom = rgSize.cy;

                    CalculateAspectRatio (&m_rgSize, &rectThumbnail);

                    // Call DanielC for the StretchBlt
                    SetStretchBltMode (hdcBmp, HALFTONE);

                    // Create the thumbnail
                    m_pImg->StretchBlt(hdcBmp,
                                        rectThumbnail.left,
                                        rectThumbnail.top,
                                        rectThumbnail.right - rectThumbnail.left,
                                        rectThumbnail.bottom - rectThumbnail.top,
                                        0, 0,
                                        rgSize.cx,
                                        rgSize.cy,
                                        SRCCOPY);

                    SelectObject(hdcBmp, hOld);

                    *m_phBmp = hBmp;
                }
                else
                {
                    //
                    // On systems other than NT5 make a full size copy of
                    // the bits and pass the copy to ScaleSharpen2().
                    //
                    RECT rectThumbnail;
                    rectThumbnail.left   = 0;
                    rectThumbnail.top    = 0;
                    
                    rectThumbnail.right  = rgSize.cx;
                    rectThumbnail.bottom = rgSize.cy;
                    
                    FillRect(hdcBmp, &rectThumbnail, (HBRUSH) (COLOR_WINDOW+1));

                    m_pImg->StretchBlt(hdcBmp,
                                        0, 0,
                                        rgSize.cx,
                                        rgSize.cy,
                                        0, 0,
                                        rgSize.cx,
                                        rgSize.cy,
                                        SRCCOPY);

                    SelectObject(hdcBmp, hOld);

                    if (m_rgSize.cx == rgSize.cx && m_rgSize.cy == rgSize.cy)
                    {
                        *m_phBmp = hBmp;
                    }
                    else
                    {
                        SIZEL rgCur;
                        rgCur.cx = rgSize.cx;
                        rgCur.cy = rgSize.cy;

                        IScaleAndSharpenImage2 * pScale;
                        hr = CoCreateInstance(CLSID_ThumbnailScaler, NULL, CLSCTX_INPROC_SERVER,
                                               IID_PPV_ARG(IScaleAndSharpenImage2, &pScale));
                        if (SUCCEEDED(hr))
                        {
                            hr = pScale->ScaleSharpen2((BITMAPINFO *) &dib,
                                                        lpBits,
                                                        m_phBmp,
                                                        &m_rgSize,
                                                        m_dwRecClrDepth,
                                                        hpal,
                                                        20, m_fOrigSize);
                            pScale->Release();
                        }
                        DeleteObject(hBmp);
                    }
                }
            }
            if (SUCCEEDED(hr) && hpal && m_dwRecClrDepth <= 8)
            {
                (void) SelectPalette(hdcBmp, hpalOld, TRUE);
                RealizePalette(hdcBmp);
            }
            if (m_dwRecClrDepth < 8)
            {
                // we used a stock 16 colour palette
                DeletePalette(hpal);
            }
        }
        if (hdc)
        {
            ReleaseDC(NULL, hdc);
        }
        if (hdcBmp)
        {
            DeleteDC(hdcBmp);
        }
    }
    m_pImg->Disconnect();
    ATOMICRELEASE(m_pImg);
    
    m_lState = IRTIR_TASK_FINISHED;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\iface.h ===
#ifndef _IFACE_H
#define _IFACE_H

// Interfaces and IIDs defined here are private to shdocvw.dll
//


//
// IDocNavigate
//
// DocHost needs to notify the browser of certain events
//
//131A6950-7F78-11D0-A979-00C04FD705A2
#undef  INTERFACE
#define INTERFACE  IDocNavigate
DECLARE_INTERFACE_(IDocNavigate, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDocNavigate methods ***
    STDMETHOD(OnReadyStateChange)(THIS_ IShellView* psvSource, DWORD dwReadyState) PURE;
    STDMETHOD(get_ReadyState)(THIS_ DWORD * pdwReadyState) PURE;

} ;

//
// IBandNavigate
//
//  band needs to navigate its UI to a specific pidl.
//
#undef  INTERFACE
#define INTERFACE  IBandNavigate
DECLARE_INTERFACE_(IBandNavigate, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IBandNavigate methods ***
    STDMETHOD(Select)(THIS_ LPCITEMIDLIST pidl) PURE;

} ;


//
// IEFrameAuto
//
// CIEFrameAuto private interface to hold randum stuff
//
//131A6953-7F78-11D0-A979-00C04FD705A2
#undef  INTERFACE
#define INTERFACE  IEFrameAuto
DECLARE_INTERFACE_(IEFrameAuto, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IEFrameAuto methods ***
    STDMETHOD(SetOwnerHwnd)(THIS_ HWND hwndOwner) PURE;
    STDMETHOD(put_DefaultReadyState)(THIS_ DWORD dwDefaultReadyState, BOOL fUpdateBrowserReadyState) PURE;
    STDMETHOD(OnDocumentComplete)(THIS) PURE;
    STDMETHOD(OnWindowsListMarshalled)(THIS) PURE;
} ;

//
// IPrivateOleObject
//
// a cut down version of IOleObject used for the WebBrowserOC to communicate with
// objects hosted via CDocObjectView
#undef INTERFACE
#define INTERFACE IPrivateOleObject
DECLARE_INTERFACE_(IPrivateOleObject, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IPrivateOleObject
    STDMETHOD( SetExtent )( DWORD dwDrawAspect, SIZEL *psizel) PURE;
    STDMETHOD( GetExtent )( DWORD dwDrawAspect, SIZEL *psizel) PURE;
};


STDAPI AddUrlToUrlHistoryStg(LPCWSTR pwszUrl, LPCWSTR pwszTitle, LPUNKNOWN punk, 
                             BOOL fWriteToHistory, IOleCommandTarget *poctNotify, IUnknown *punkSFHistory,
                             UINT* pcodepage);

#ifdef __cplusplus

//
// LATER: Move all ITravelLog/ITravelEntry definitions here
//
// TLOG_BACKEXTERNAL -- succeeds only if the previous entry is external
//
#define TLOG_BACKEXTERNAL   -0x7fffffff

#endif // __cplusplus

#endif // _IFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\imgcache.cpp ===
#include "priv.h"
#include "strsafe.h"

HBITMAP CreateMirroredBitmap( HBITMAP hbmOrig)
{
    HDC     hdc, hdcMem1, hdcMem2;
    HBITMAP hbm = NULL, hOld_bm1, hOld_bm2;
    BITMAP  bm;
    int     IncOne = 0;

    if (!hbmOrig)
        return NULL;

    if (!GetObject(hbmOrig, sizeof(BITMAP), &bm))
        return NULL;

    // Grab the screen DC
    hdc = GetDC(NULL);

    if (hdc)
    {
        hdcMem1 = CreateCompatibleDC(hdc);

        if (!hdcMem1)
        {
            ReleaseDC(NULL, hdc);
            return NULL;
        }
    
        hdcMem2 = CreateCompatibleDC(hdc);
        if (!hdcMem2)
        {
            DeleteDC(hdcMem1);
            ReleaseDC(NULL, hdc);
            return NULL;
        }

        hbm = CreateCompatibleBitmap(hdc, bm.bmWidth, bm.bmHeight);

        if (!hbm)
        {
            ReleaseDC(NULL, hdc);
            DeleteDC(hdcMem1);
            DeleteDC(hdcMem2);
            return NULL;
        }

        //
        // Flip the bitmap
        //
        hOld_bm1 = (HBITMAP)SelectObject(hdcMem1, hbmOrig);
        hOld_bm2 = (HBITMAP)SelectObject(hdcMem2 , hbm );

        SET_DC_RTL_MIRRORED(hdcMem2);
        if (g_bRunOnMemphis)
        {
            // off-by-one on win98 or higher copying from non-mirrored to mirrored DC
            IncOne++;
        }   

        BitBlt(hdcMem2, IncOne, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCCOPY);

        SelectObject(hdcMem1, hOld_bm1 );
        SelectObject(hdcMem1, hOld_bm2 );
    
        DeleteDC(hdcMem1);
        DeleteDC(hdcMem2);

        ReleaseDC(NULL, hdc);
    }

    return hbm;
}

HICON CreateMirroredIcon(HICON hiconOrg)
{
    HDC      hdcScreen, hdcBitmap, hdcMask = NULL;
    HBITMAP  hbm, hbmMask, hbmOld,hbmOldMask;
    BITMAP   bm;
    ICONINFO ii;
    HICON    hicon = NULL;
#ifdef WINNT
#define      IPIXELOFFSET 0 
#else // !WINNT
#define      IPIXELOFFSET 2
#endif WINNT

    hdcBitmap = CreateCompatibleDC(NULL);
    if (hdcBitmap)
    {
        hdcMask = CreateCompatibleDC(NULL);

        if( hdcMask )
        {

            SET_DC_RTL_MIRRORED(hdcBitmap);
            SET_DC_RTL_MIRRORED(hdcMask);
        }
        else
        {
            DeleteDC( hdcBitmap );
            hdcBitmap = NULL;
        }
    }
         
    hdcScreen = GetDC(NULL);

    if (hdcScreen)
    {
        if (hdcBitmap && hdcMask) 
        {
            if (hiconOrg)
            {
                if (GetIconInfo(hiconOrg, &ii) &&
                    GetObject(ii.hbmColor, sizeof(BITMAP), &bm))
                {
                    //
                    // I don't want these.
                    //
                    DeleteObject( ii.hbmMask );
                    DeleteObject( ii.hbmColor );
                    ii.hbmMask = ii.hbmColor = NULL;

                    hbm = CreateCompatibleBitmap(hdcScreen, bm.bmWidth, bm.bmHeight);
                    hbmMask = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);
                    hbmOld = (HBITMAP)SelectObject(hdcBitmap, hbm);
                    hbmOldMask = (HBITMAP)SelectObject(hdcMask, hbmMask);
      
                    DrawIconEx(hdcBitmap, IPIXELOFFSET, 0, hiconOrg, bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_IMAGE);

                    DrawIconEx(hdcMask, IPIXELOFFSET, 0, hiconOrg, bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_MASK);

                    SelectObject(hdcBitmap, hbmOld);
                    SelectObject(hdcMask, hbmOldMask);

                    //
                    // create the new mirrored icon, and delete bmps
                    //
                    ii.hbmMask  = hbmMask;
                    ii.hbmColor = hbm;
                    hicon = CreateIconIndirect(&ii);

                    DeleteObject(hbm);
                    DeleteObject(hbmMask);
                }
               
            }
        }

        ReleaseDC(NULL, hdcScreen);
    }

    if (hdcBitmap)
        DeleteDC(hdcBitmap);

    if (hdcMask)
        DeleteDC(hdcMask);

    return hicon;
}

HBITMAP AddImage_PrepareBitmap(LPCIMAGECACHEINFO pInfo, HBITMAP hbmp)
{
    if (pInfo->dwMask & ICIFLAG_MIRROR)
    {
        return CreateMirroredBitmap(hbmp);
    }
    else 
    {
        return hbmp;
    }    
 }

HICON AddImage_PrepareIcon(LPCIMAGECACHEINFO pInfo, HICON hicon)
{
    if (pInfo->dwMask & ICIFLAG_MIRROR)
    {
        return CreateMirroredIcon(hicon);
    }
    else 
    {
        return hicon;
    }    
}

void AddImage_CleanupBitmap(LPCIMAGECACHEINFO pInfo, HBITMAP hbmp)
{
    if (pInfo->dwMask & ICIFLAG_MIRROR)
    {
        if (hbmp)
        {
            DeleteObject(hbmp);
        }    
    }
}

void AddImage_CleanupIcon(LPCIMAGECACHEINFO pInfo, HICON hicon)
{
    if (pInfo->dwMask & ICIFLAG_MIRROR)
    {
        if (hicon)
        {
            DestroyIcon(hicon);
        }    
    }
}

///////////////////////////////////////////////////////////////////////////////////
typedef struct 
{
    UINT        uImageIndex;  // The actual Image Index

    // USAGE COUNT
    UINT        iUsage;     // usage count....
    DWORD       dwUsage;    // usage information

    // SEARCH KEYS
    DWORD       dwFlags;    // key: flags
    int         iIndex;     // data: icon index
    FILETIME    ftDateStamp;
    WCHAR   szName[1];        // the filename of the item....
} ICONCACHE_DATA, *PICONCACHE_DATA;

#define ICD_NOUSAGE 0x0001
#define ICD_DELETED 0x0002
#define ICD_SYSTEM  0x0004

class CImageListCache : public IImageCache3
{
public:
    CImageListCache( void );
    ~CImageListCache( void );
    HRESULT Initialize ( void );

    STDMETHOD ( QueryInterface )( REFIID riid, void ** ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    STDMETHOD ( AddImage )( LPCIMAGECACHEINFO pInfo, UINT * puImageIndex );
    STDMETHOD ( FindImage )( LPCIMAGECACHEINFO pInfo, UINT * puImageIndex );
    STDMETHOD ( FreeImage )( UINT iImageIndex );
    STDMETHOD ( Flush )( BOOL fRelease );
    STDMETHOD ( ChangeImageInfo )( UINT iImageIndex, LPCIMAGECACHEINFO pInfo );
    STDMETHOD ( GetCacheSize )( UINT * puSize );
    STDMETHOD ( GetUsage )( UINT iImageIndex, UINT * puUsage );
    STDMETHOD ( GetImageList )( LPIMAGECACHEINITINFO pInfo );

    STDMETHOD ( DeleteImage )( UINT iImageIndex );
    STDMETHOD ( GetImageInfo )( UINT iImageIndex, LPIMAGECACHEINFO pInfo );

    STDMETHOD ( GetImageIndexFromCacheIndex )( UINT iCacheIndex, UINT * puImageIndex );

protected:  //internal methods.
    UINT CountFreeSlots( void );
    int FindEmptySlot( void );
    ICONCACHE_DATA * CreateDataNode( LPCIMAGECACHEINFO pInfo ) const;
    
    ICONCACHE_DATA * GetNodeFromImageIndex( UINT iImageIndex );
    UINT GetNodeIndexFromImageIndex( UINT iImageIndex );

    HDPA             m_hListData;
    HIMAGELIST       m_himlLarge;
    HIMAGELIST       m_himlSmall;
    CRITICAL_SECTION m_csLock;
    BOOL m_bLockInited;
    DWORD            m_dwFlags;
    long             m_cRef;
};

STDAPI CImageListCache_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppunk = NULL;

    CImageListCache * pCache = new CImageListCache();
    if (pCache != NULL)
    {
        hr = pCache->Initialize();
        if (SUCCEEDED(hr))
        {
            *ppunk = SAFECAST(pCache, IImageCache *);
        }
        else
        {
            delete pCache;
        }
    }

    return hr;
}

STDMETHODIMP CImageListCache::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CImageListCache, IImageCache),
        QITABENT(CImageListCache, IImageCache2),
        QITABENT(CImageListCache, IImageCache3),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CImageListCache::AddRef()
{
    return InterlockedIncrement( &m_cRef );
}

STDMETHODIMP_(ULONG) CImageListCache::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement( &m_cRef );
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

int CALLBACK DestroyEnum( void *p, void *pData )
{
    if ( p )
    {
        LocalFree((ICONCACHE_DATA *) p);
    }

    return TRUE;
}

int CALLBACK UsageEnum( void *p, void *pData )
{
    ASSERT( p);
    ICONCACHE_DATA * pNode = (ICONCACHE_DATA *) p;

    pNode->iUsage = PtrToUlong(pData);
    pNode->dwUsage = 0;
    
    return TRUE;
}

CImageListCache::CImageListCache( )
{
    m_cRef = 1;

    DllAddRef();
}

CImageListCache::~CImageListCache( )
{
    // don't bother entering the critical section, if we shouldn't be accessed
    // by multiple threads if we have reached the destructor...
    
    if ( m_himlLarge ) 
    {
        ImageList_Destroy( m_himlLarge );
    }
    if ( m_himlSmall ) 
    {
        ImageList_Destroy( m_himlSmall );
    }

    if ( m_hListData )
    {
        DPA_DestroyCallback( m_hListData, DestroyEnum, NULL );
        m_hListData = NULL;
    }

    if (m_bLockInited)
    {
        DeleteCriticalSection( &m_csLock );
    }

    DllRelease();
}

HRESULT CImageListCache::Initialize()
{
    HRESULT hr = S_OK;
    
    __try
    {
        InitializeCriticalSection(&m_csLock);
        m_bLockInited = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

ICONCACHE_DATA * CImageListCache::CreateDataNode(LPCIMAGECACHEINFO pInfo ) const
{
    UINT cbSize = sizeof( ICONCACHE_DATA );
    UINT cbName = 0;
    if ( pInfo->dwMask & ICIFLAG_NAME )
    {
        ASSERT( pInfo->pszName );
        cbName = lstrlenW( pInfo->pszName ) * sizeof( WCHAR );
        cbSize += cbName; // ICONCACHE_DATA defines szName as having one character already (for the NULL).
    }

    // zero init mem alloc
    ICONCACHE_DATA * pNode = (ICONCACHE_DATA *) LocalAlloc( LPTR, cbSize );
    if ( !pNode )
    {
        return NULL;
    }
    
    // fill in the data...
    if ( pInfo->dwMask & ICIFLAG_NAME )
    {
        ASSERT(cbName);
        HRESULT hr = StringCbCopyW( pNode->szName, cbName + sizeof(WCHAR), pInfo->pszName );
        ASSERT(SUCCEEDED(hr));  // This will not fail as we allocated enough memory above
    }
    pNode->iIndex = pInfo->iIndex;
    pNode->dwFlags = pInfo->dwFlags;
    pNode->iUsage = 1;
    pNode->ftDateStamp = pInfo->ftDateStamp;

    if ( pInfo->dwMask & ICIFLAG_NOUSAGE )
    {
        pNode->dwUsage |= ICD_NOUSAGE;
    }
    if ( pInfo->dwMask & ICIFLAG_SYSTEM )
    {
        pNode->dwUsage |= ICD_SYSTEM;
    }

    return pNode;
}

STDMETHODIMP CImageListCache::AddImage(LPCIMAGECACHEINFO pInfo, UINT * puImageIndex)
{
    if ( !pInfo || !puImageIndex || !(pInfo->dwMask & (ICIFLAG_LARGE | ICIFLAG_SMALL)) ||
                                    !(pInfo->dwMask & (ICIFLAG_BITMAP | ICIFLAG_ICON )))
    {
        return E_INVALIDARG;
    }

    ICONCACHE_DATA * pNode = CreateDataNode( pInfo );
    if ( !pNode )
    {
        return E_OUTOFMEMORY;
    }

    EnterCriticalSection( &m_csLock );
    int iImageIndex = -1;
    int iCacheIndex = FindEmptySlot();
    if (iCacheIndex != -1)
    {
        // swap for the old one...
        ICONCACHE_DATA * pOld = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iCacheIndex );
        if (m_dwFlags & ICIIFLAG_SORTBYUSED)
        {
            DPA_DeletePtr( m_hListData, iCacheIndex);
            DPA_AppendPtr( m_hListData, pNode);
            iImageIndex = pNode->uImageIndex = pOld->uImageIndex;
        }
        else
        {
            DPA_SetPtr( m_hListData, iCacheIndex, pNode);
            iImageIndex = pNode->uImageIndex = iCacheIndex;
        }
        // TraceMsg(TF_CUSTOM2, "CImageListCache::AddImage -- Replacing Image (CI:%d II:%d) ", iCacheIndex, iImageIndex);
        
        LocalFree((LPVOID) pOld );

        ASSERT(!(m_dwFlags & ICIIFLAG_LARGE) == !(pInfo->dwMask & ICIFLAG_LARGE)
               && !(m_dwFlags & ICIIFLAG_SMALL) == !(pInfo->dwMask & ICIFLAG_SMALL));
        
        if ( pInfo->dwMask & ICIFLAG_LARGE )
        {
            ASSERT( m_dwFlags & ICIIFLAG_LARGE );
            if ( pInfo->dwMask & ICIFLAG_BITMAP )
            {
                ASSERT( pInfo->hBitmapLarge );

                HBITMAP hBitmapLarge = AddImage_PrepareBitmap(pInfo, pInfo->hBitmapLarge);
                HBITMAP hMaskLarge = AddImage_PrepareBitmap(pInfo, pInfo->hMaskLarge);
                ImageList_Replace( m_himlLarge, iImageIndex, hBitmapLarge, hMaskLarge );
                AddImage_CleanupBitmap(pInfo, hBitmapLarge);
                AddImage_CleanupBitmap(pInfo, hMaskLarge);
            }
            else
            {
                ASSERT( pInfo->hIconLarge && pInfo->dwMask & ICIFLAG_ICON );

                HICON hIconLarge = AddImage_PrepareIcon(pInfo, pInfo->hIconLarge);
                ImageList_ReplaceIcon( m_himlLarge, iImageIndex, hIconLarge );
                AddImage_CleanupIcon(pInfo, hIconLarge);
            }
        }
        if ( pInfo->dwMask & ICIFLAG_SMALL )
        {
            ASSERT( m_dwFlags & ICIIFLAG_SMALL );
            if ( pInfo->dwMask & ICIFLAG_BITMAP )
            {
                ASSERT( pInfo->hBitmapSmall );

                HBITMAP hBitmapSmall = AddImage_PrepareBitmap(pInfo, pInfo->hBitmapSmall);
                HBITMAP hMaskSmall = AddImage_PrepareBitmap(pInfo, pInfo->hMaskSmall);
                ImageList_Replace( m_himlSmall, iImageIndex, hBitmapSmall, hMaskSmall );
                AddImage_CleanupBitmap(pInfo, hBitmapSmall);
                AddImage_CleanupBitmap(pInfo, hMaskSmall);
            }
            else
            {
                ASSERT( pInfo->hIconSmall && pInfo->dwMask & ICIFLAG_ICON );

                HICON hIconSmall = AddImage_PrepareIcon(pInfo, pInfo->hIconSmall);
                ImageList_ReplaceIcon( m_himlSmall, iImageIndex, hIconSmall );
                AddImage_CleanupIcon(pInfo, hIconSmall);
            }
        }
    }
    else
    {
        iCacheIndex = DPA_AppendPtr( m_hListData, pNode );
        if ( iCacheIndex >= 0 )
        {
            if ( pInfo->dwMask & ICIFLAG_BITMAP )
            {
                if ( pInfo->dwMask & ICIFLAG_LARGE )
                {
                    ASSERT( m_dwFlags & ICIIFLAG_LARGE );
                    ASSERT( pInfo->hBitmapLarge );

                    HBITMAP hBitmapLarge = AddImage_PrepareBitmap(pInfo, pInfo->hBitmapLarge);
                    HBITMAP hMaskLarge = AddImage_PrepareBitmap(pInfo, pInfo->hMaskLarge);
                    iImageIndex  = ImageList_Add( m_himlLarge, hBitmapLarge, hMaskLarge);
                    AddImage_CleanupBitmap(pInfo, hBitmapLarge);
                    AddImage_CleanupBitmap(pInfo, hMaskLarge);
                }
                if ( pInfo->dwMask & ICIFLAG_SMALL )
                {
                    ASSERT( m_dwFlags & ICIIFLAG_SMALL );
                    ASSERT( pInfo->hBitmapSmall );

                    HBITMAP hBitmapSmall = AddImage_PrepareBitmap(pInfo, pInfo->hBitmapSmall);
                    HBITMAP hMaskSmall = AddImage_PrepareBitmap(pInfo, pInfo->hMaskSmall);
                    iImageIndex  = ImageList_Add( m_himlSmall, hBitmapSmall, hMaskSmall);
                    AddImage_CleanupBitmap(pInfo, hBitmapSmall);
                    AddImage_CleanupBitmap(pInfo, hMaskSmall);
                }
            }
            else
            {
                ASSERT( pInfo->dwMask & ICIFLAG_ICON );
                if ( pInfo->dwMask & ICIFLAG_LARGE )
                {
                    ASSERT( m_dwFlags & ICIIFLAG_LARGE );
                    ASSERT( pInfo->hIconLarge );

                    HICON hIconLarge = AddImage_PrepareIcon(pInfo, pInfo->hIconLarge);
                    iImageIndex = ImageList_AddIcon( m_himlLarge, hIconLarge );
                    AddImage_CleanupIcon(pInfo, hIconLarge);
                }
                if ( pInfo->dwMask & ICIFLAG_SMALL )
                {
                    ASSERT( m_dwFlags & ICIIFLAG_SMALL );
                    ASSERT( pInfo->hIconSmall );

                    HICON hIconSmall = AddImage_PrepareIcon(pInfo, pInfo->hIconSmall);
                    iImageIndex = ImageList_AddIcon( m_himlSmall, hIconSmall );
                    AddImage_CleanupIcon(pInfo, hIconSmall);
                }
            }
            ASSERT(iCacheIndex == iImageIndex);
            pNode->uImageIndex = iImageIndex;
            //TraceMsg(TF_CUSTOM2, "CImageListCache::AddImage -- Adding Image (CI:%d II:%d) ", iCacheIndex, iImageIndex);
        }
        else
        {
            // failed to add to the list...
            LocalFree( pNode );
        }
    }

    LeaveCriticalSection( &m_csLock );
    *puImageIndex = (UINT) iImageIndex;
    
    return (iImageIndex >= 0) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CImageListCache::FindImage(LPCIMAGECACHEINFO pInfo, UINT *puImageIndex)
{
    HRESULT hr = S_FALSE;
    ASSERT( m_hListData );

    DWORD dwMatch = pInfo->dwMask & (ICIFLAG_FLAGS | ICIFLAG_NAME | ICIFLAG_INDEX | ICIFLAG_DATESTAMP);
    DWORD dwMask;
    int iCacheIndex = 0;
    ICONCACHE_DATA * pNode = NULL;
    EnterCriticalSection( &m_csLock );
    do
    {
        dwMask = 0;
        pNode = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iCacheIndex );
        if ( !pNode )
        {
            break;
        }

        if ((pNode->dwUsage & ICD_DELETED) || (pNode->iUsage == 0))
        {
            iCacheIndex ++;
            continue;
        }
        
        if (( dwMatch & ICIFLAG_NAME ) && StrCmpW( pInfo->pszName, pNode->szName ) == 0 )
        {
            // found it
            dwMask |= ICIFLAG_NAME;
        }
        if (( dwMatch& ICIFLAG_INDEX ) && pInfo->iIndex == pNode->iIndex )
        {
            dwMask |= ICIFLAG_INDEX;
        }
        if (( dwMatch & ICIFLAG_FLAGS ) && pInfo->dwFlags == pNode->dwFlags )
        {
            dwMask |= ICIFLAG_FLAGS;
        }

        if (( dwMatch & ICIFLAG_DATESTAMP ) &&
            ( pInfo->ftDateStamp.dwLowDateTime == pNode->ftDateStamp.dwLowDateTime &&
              pInfo->ftDateStamp.dwHighDateTime == pNode->ftDateStamp.dwHighDateTime ))
        {
            dwMask |= ICIFLAG_DATESTAMP;
        }

        iCacheIndex ++;
    }
    while ( dwMask != dwMatch);

    // found it, save the index... (as long as it was freed not deleted...
    if ( pNode && (dwMask == dwMatch) )
    {
        //TraceMsg(TF_CUSTOM2, "CImageListCache::FindImage *FOUND* (path=%s)", pNode->szName);
        hr = S_OK;
        *puImageIndex = (UINT) pNode->uImageIndex;
        
        // bump usage
        iCacheIndex --; // We had an extra increment at the end.
        if ( !(pNode->dwUsage & ICD_SYSTEM) )
        {
            if (m_dwFlags & ICIIFLAG_SORTBYUSED)
            {
                DPA_DeletePtr(m_hListData, iCacheIndex);
                iCacheIndex = DPA_AppendPtr(m_hListData, pNode);
                if (iCacheIndex == -1) // We failed to move the node...
                {
                    LocalFree(pNode);
                    *puImageIndex = (UINT) -1;
                    hr = E_OUTOFMEMORY;
                }            
            }
            else if ( !(pNode->dwUsage) && !(pInfo->dwMask & ICIFLAG_NOUSAGE ))
            {
                ASSERT(!(pNode->dwUsage & ICD_DELETED));
                pNode->iUsage++;
            }
        }
    }
    
    LeaveCriticalSection( &m_csLock );

    return hr;
}

STDMETHODIMP CImageListCache::Flush(BOOL fRelease)
{
    ASSERT( m_hListData );

    EnterCriticalSection( &m_csLock );
    if ( fRelease )
    {
        // simply empty the data list. The ImageList never shrinks...
        DPA_EnumCallback( m_hListData, DestroyEnum, NULL );
        DPA_DeleteAllPtrs( m_hListData );

        if ( m_himlLarge )
        {
            ImageList_RemoveAll( m_himlLarge );
        }

        if ( m_himlSmall )
        {
            ImageList_RemoveAll( m_himlSmall );
        }
    }
    else
    {
        DPA_EnumCallback( m_hListData, UsageEnum, 0 );
    }
    LeaveCriticalSection( &m_csLock );

    return S_OK;
}

STDMETHODIMP CImageListCache::FreeImage(UINT uImageIndex)
{
    ASSERT ( m_hListData );
    HRESULT hr = E_INVALIDARG;

    EnterCriticalSection(&m_csLock);
    
    ICONCACHE_DATA * pNode = GetNodeFromImageIndex(uImageIndex);
    if (pNode)
    {
        if (!pNode->dwUsage && pNode->iUsage)
        {
            hr = S_OK;
            if (m_dwFlags & ICIIFLAG_SORTBYUSED)
            {
                //TraceMsg(TF_CUSTOM2, "CImageListCache::FreeImage -- (CI::%d II::%d)", GetNodeIndexFromImageIndex(uImageIndex), uImageIndex);
                pNode->iUsage = 0;
            }
            else
            {
                pNode->iUsage--;
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    LeaveCriticalSection(&m_csLock);
    return hr;
}

STDMETHODIMP CImageListCache::DeleteImage(UINT uImageIndex)
{
    HRESULT hr = E_INVALIDARG;
    ASSERT ( m_hListData );

    EnterCriticalSection( &m_csLock );
    
    ICONCACHE_DATA * pNode = GetNodeFromImageIndex(uImageIndex);
    if (pNode)
    {
        if ( !pNode->dwUsage )
        {
            pNode->dwUsage = ICD_DELETED;
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    LeaveCriticalSection( &m_csLock );
    return hr;
}

STDMETHODIMP CImageListCache::ChangeImageInfo(UINT uImageIndex, LPCIMAGECACHEINFO pInfo)
{
    ASSERT( m_hListData );
    
    EnterCriticalSection( &m_csLock );
    UINT uCacheIndex = GetNodeIndexFromImageIndex(uImageIndex);
    if (-1 == uCacheIndex)
    {
        LeaveCriticalSection( &m_csLock );
        return E_INVALIDARG;
    }
    
    ICONCACHE_DATA * pNode = CreateDataNode( pInfo );
    if (!pNode)
    {
        LeaveCriticalSection( &m_csLock );
        return E_OUTOFMEMORY;
    }

    ICONCACHE_DATA * pOld = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, uCacheIndex );
    ASSERT( pOld );
    
    DPA_SetPtr( m_hListData, uCacheIndex, pNode );
    pNode->iUsage = pOld->iUsage;
    pNode->dwUsage = pOld->dwUsage;
    pNode->uImageIndex = pOld->uImageIndex;
    LocalFree( pOld );

    if ( pInfo->dwMask & ( ICIFLAG_BITMAP | ICIFLAG_ICON ))
    {
        // update the picture....
        if ( pInfo->dwMask & ICIFLAG_LARGE )
        {
            if ( pInfo->dwMask & ICIFLAG_BITMAP )
            {
                ASSERT( pInfo->hBitmapLarge );
                ImageList_Replace( m_himlLarge, uImageIndex, pInfo->hBitmapLarge, pInfo->hMaskLarge );
            }
            else
            {
                ASSERT( pInfo->hIconLarge && pInfo->dwMask & ICIFLAG_ICON );
                ImageList_ReplaceIcon( m_himlLarge, uImageIndex, pInfo->hIconLarge );
            }
        }
        if ( pInfo->dwMask & ICIFLAG_SMALL )
        {
            if ( pInfo->dwMask & ICIFLAG_BITMAP )
            {
                ASSERT( pInfo->hBitmapSmall );
                ImageList_Replace( m_himlSmall, uImageIndex, pInfo->hBitmapSmall, pInfo->hMaskSmall );
            }
            else
            {
                ASSERT( pInfo->hIconSmall && pInfo->dwMask & ICIFLAG_ICON );
                ImageList_ReplaceIcon( m_himlLarge, uImageIndex, pInfo->hIconSmall );
            }
        }
    }
    LeaveCriticalSection(&m_csLock);
    return S_OK;
}

UINT CImageListCache::CountFreeSlots( )
{
    ASSERT( m_hListData );
    int iSlot = 0;
    UINT uFree = 0;
    
    do
    {
        ICONCACHE_DATA * pNode = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iSlot ++ );
        if ( !pNode )
        {
            break;
        }

        if (pNode->iUsage == 0 || (pNode->dwUsage & ICD_DELETED))
        {
            uFree++;
        }
    }
    while ( TRUE );

    return uFree;
}

STDMETHODIMP CImageListCache::GetCacheSize(UINT * puSize)
{
    ASSERT( m_hListData );

    EnterCriticalSection( &m_csLock );
    *puSize = DPA_GetPtrCount( m_hListData ) - CountFreeSlots();
    LeaveCriticalSection( &m_csLock );
    return S_OK;
}

STDMETHODIMP CImageListCache::GetImageList(LPIMAGECACHEINITINFO pInfo )
{
    ASSERT( pInfo->cbSize == sizeof( IMAGECACHEINITINFO ));

    if ( !(pInfo->dwMask & (ICIIFLAG_LARGE | ICIIFLAG_SMALL)))
    {
        // must specify one or both of large or small
        return E_INVALIDARG;
    }

    if ( m_hListData )
    {
        // we have already been created, just pass back the info if they match.....
        if ((( pInfo->dwMask & ICIIFLAG_SMALL ) && !m_himlSmall ) ||
            (( pInfo->dwMask & ICIIFLAG_LARGE ) && !m_himlLarge ) ||
            ( m_dwFlags != pInfo->dwMask ))
        {
            return E_INVALIDARG;
        }

        if ( pInfo->dwMask & ICIIFLAG_SMALL )
        {
            pInfo->himlSmall = m_himlSmall;
        }
        if ( pInfo->dwMask & ICIIFLAG_LARGE )
        {
            pInfo->himlLarge = m_himlLarge;
        }

        return S_FALSE;
    }
    
    m_hListData = DPA_Create( 30 );
    if ( !m_hListData )
    {
        return E_OUTOFMEMORY;
    }
    
    if ( pInfo->dwMask & ICIIFLAG_LARGE )
    {
        m_himlLarge = ImageList_Create( pInfo->rgSizeLarge.cx, pInfo->rgSizeLarge.cy, pInfo->dwFlags,
            pInfo->iStart, pInfo->iGrow );
        if ( !m_himlLarge )
        {
            return E_OUTOFMEMORY;
        }
        pInfo->himlLarge = m_himlLarge;
    }
    if ( pInfo->dwMask & ICIIFLAG_SMALL )
    {
        m_himlSmall = ImageList_Create( pInfo->rgSizeSmall.cx, pInfo->rgSizeSmall.cy, pInfo->dwFlags,
            pInfo->iStart, pInfo->iGrow );
        if ( !m_himlSmall )
        {
            return E_OUTOFMEMORY;
        }
        pInfo->himlSmall = m_himlSmall;
    }

    m_dwFlags = pInfo->dwMask;
    
    return S_OK;
}

int CImageListCache::FindEmptySlot()
{
    // search for an element with a zero usage count...
    ASSERT( m_hListData );
    
    int iCacheIndex = 0;
    do
    {
        ICONCACHE_DATA * pNode = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iCacheIndex );
        if ( !pNode )
        {
            break;
        }

        if (pNode->iUsage == 0 || (pNode->dwUsage & ICD_DELETED))
        {
            return iCacheIndex;
        }
        iCacheIndex ++;
    } while (TRUE);
    
    return  -1;
}

STDMETHODIMP CImageListCache::GetUsage(UINT uImageIndex, UINT * puUsage)
{
    ASSERT( m_hListData );

    EnterCriticalSection( &m_csLock );

    HRESULT hr = E_INVALIDARG;
    ICONCACHE_DATA * pNode = GetNodeFromImageIndex(uImageIndex);
    if (pNode)
    {
        if (pNode->dwUsage & ICD_DELETED)
        {
            *puUsage = ICD_USAGE_DELETED;
        }
        else if (pNode->dwUsage & ICD_SYSTEM)
        {
            *puUsage = ICD_USAGE_SYSTEM;
        }
        else if (pNode->dwUsage & ICD_NOUSAGE)
        {
            *puUsage = ICD_USAGE_NOUSAGE;
        }
        else
        {
            *puUsage = pNode->iUsage;
        }
        hr = S_OK;
    }

    LeaveCriticalSection( &m_csLock );
    return hr;
}

STDMETHODIMP CImageListCache::GetImageInfo(UINT uImageIndex, LPIMAGECACHEINFO pInfo)
{
    HRESULT hr;
    ASSERT( m_hListData );

    EnterCriticalSection( &m_csLock );
    
    ICONCACHE_DATA * pNode = GetNodeFromImageIndex(uImageIndex);
    if (pNode)
    {
        hr  = E_NOTIMPL;
        if ( pInfo->dwMask & ICIFLAG_DATESTAMP )
        {
            if ( pNode->dwFlags & ICIFLAG_DATESTAMP )
            {
                pInfo->ftDateStamp = pNode->ftDateStamp;
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
        }

        if ( pInfo->dwMask & ICIFLAG_NOUSAGE )
        {
            hr = S_OK;
        }
        pInfo->dwMask = pNode->dwFlags & pInfo->dwMask;
    }
    else
        hr = E_INVALIDARG;
    
    LeaveCriticalSection(&m_csLock);
    return hr;
}

STDMETHODIMP CImageListCache::GetImageIndexFromCacheIndex( UINT iCacheIndex, UINT * puImageIndex )
{
    ASSERT( m_hListData );
    
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection( &m_csLock );
    ICONCACHE_DATA *pNode = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iCacheIndex );
    
    *puImageIndex = (UINT) -1;
    if (pNode)
    {
        *puImageIndex = (UINT) pNode->uImageIndex;
        hr = S_OK;
    }

    LeaveCriticalSection(&m_csLock);
    return hr;
}

ICONCACHE_DATA * CImageListCache::GetNodeFromImageIndex( UINT iImageIndex )
{
    UINT iCacheIndex = GetNodeIndexFromImageIndex(iImageIndex);
    return (iCacheIndex == -1) ? NULL : (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iCacheIndex );
}

UINT CImageListCache::GetNodeIndexFromImageIndex( UINT iImageIndex )
{
    UINT iCacheIndex = 0;
    ICONCACHE_DATA * pNode = NULL;

    // We must assume that we have the critical section here or else the data would be
    // meaningless upon return from this function.
    
    do
    {
        pNode = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iCacheIndex );
        if ( !pNode )
        {
            break;
        }

        if (pNode->dwUsage & ICD_DELETED)
        {
            iCacheIndex ++;
            continue;
        }

        iCacheIndex ++;
    }
    while ( pNode->uImageIndex != iImageIndex );

    return (pNode ? iCacheIndex - 1 : -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\itbar.h ===
#ifndef _ITBAR_H
#define _ITBAR_H

// initial layout information
typedef struct tagBANDSAVE
{
    UINT wID;
    UINT fStyle;
    UINT cx;
} BANDSAVE, *PBANDSAVE;

// CItnernet Toolbar - Private commands 
#define CITIDM_ONINTERNET    1  // nCmdexecopt ? Web : Shell
#define CITE_INTERNET       0
#define CITE_SHELL          1
#define CITE_QUERY          2

#define CITIDM_THEATER       2  // nCmdexecopt..
#define CITIDM_TEXTLABELS    3  // Toggle Text Labels
// the modes for theater mode
#define THF_ON  0            
#define THF_OFF 1
#define THF_UNHIDE 2 
#define THF_HIDE  3
                   
// Indicies for Coolbar bands
// These indexes are 1 based since band array is memset to 0 and ShowDW would 
// think that an unused item would belong to IDX0.

// IMPORTANT: don't change the value of anything between CBIDX_FIRST and CBIDX_LAST.
// CInternetToolbar::_LoadUpgradeSettings assumes these values haven't changed from
// version to version.
#define CBIDX_MENU              1
#define CBIDX_TOOLS             2
#define CBIDX_LINKS             3
#define CBIDX_ADDRESS           4
#define CBIDX_BRAND             5
#define CBIDX_FIRST             CBIDX_MENU
#define CBIDX_LAST              CBIDX_BRAND

#define MAXEXTERNALBANDS        16
#define CBIDX_EXTERNALFIRST     (CBIDX_LAST + 1)
#define CBIDX_EXTERNALLAST      (CBIDX_EXTERNALFIRST + MAXEXTERNALBANDS - 1)

#define CBANDSMAX               (CBIDX_LAST + MAXEXTERNALBANDS)

#define CITIDM_VIEWEXTERNALBAND_FIRST 30
#define CITIDM_VIEWEXTERNALBAND_LAST (CITIDM_VIEWEXTERNALBAND_FIRST + MAXEXTERNALBANDS - 1)

#define BandIDtoIndex(hwnd, idx) SendMessage(hwnd, RB_IDTOINDEX, idx, 0)


// Indices for Toolbar imagelists
#define IMLIST_DEFAULT          0
#define IMLIST_HOT              1

#define ITBS_SHELL    0
#define ITBS_WEB      1
#define ITBS_EXPLORER 2
IStream *GetITBarStream(BOOL fWebBrowser, DWORD grfMode);

// number of bitmaps in the IDB_IETOOLBAR strips
#define MAX_TB_BUTTONS          16

#define SHELLGLYPHS_OFFSET      MAX_TB_BUTTONS

#endif /* _ITBAR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\itbar.cpp ===
#include "priv.h"
#include "sccls.h"
#include <varutil.h>

#include "itbdrop.h"
#include <urlhist.h>
#include "autocomp.h"
#include "itbar.h"
#include "address.h"
#include <winbase.h>
#include "basebar.h"
#include "shbrowse.h"
#include "brand.h"
#include "resource.h"
#include "theater.h"
#include "browmenu.h"
#include "util.h"
#include "droptgt.h"
#include "legacy.h"
#include "apithk.h"
#include "shbrows2.h"
#include "stdenum.h"
#include "iehelpid.h"
#include <tb_ids.h>
#include "mediautil.h"

#define WANT_CBANDSITE_CLASS
#include "bandsite.h"
#include "schedule.h"
#include "uemapp.h"

#include "mluisupp.h"

#ifdef UNIX
extern "C"  const GUID  CLSID_MsgBand;
#endif

// Offset of the comctl32 default bitmaps
#define OFFSET_HIST             (MAX_TB_BUTTONS - 1 + 0)   // 15
#define OFFSET_STD              (MAX_TB_BUTTONS - 1 + 6)   // 21
#define OFFSET_VIEW             (MAX_TB_BUTTONS - 1 + 21)  // 36

// This is the offset in the toolbar for the Shell glyphs and the Shell toolbar labels
#define SHELLTOOLBAR_OFFSET     (MAX_TB_BUTTONS - 1 + 1)  // 16
#define FONTGLYPH_OFFSET        (MAX_TB_BUTTONS - 1 + 38) // 53
#define BRIEFCASEGLYPH_OFFSET   (MAX_TB_BUTTONS - 1 + 34) // 49
#define RNAUIGLYPH_OFFSET       (MAX_TB_BUTTONS - 1 + 36) // 51
#define WEBCHECKGLYPH_OFFSET    (MAX_TB_BUTTONS - 1 + 42) // 57
#define EDITGLYPH_OFFSET        (9)

#define IDT_UPDATETOOLBAR       0x1
#define TIMEOUT_UPDATETOOLBAR   400

const GUID CLSID_Separator = { 0x67077B90L, 0x4F9D, 0x11D0, 0xB8, 0x84, 0x00, 0xAA, 0x00, 0xB6, 0x01, 0x04 };

extern HRESULT VariantClearLazy(VARIANTARG *pvarg);

// How many CT_TABLE structures to allocated at a time.
#define TBBMPLIST_CHUNK     5

#define MAX_EXTERNAL_BAND_NAME_LEN 64

#define MAX_TB_COMPRESSED_WIDTH 42
// 16 is added to the the MAX_TB defines. This is added through the strings
// in the RC file. This is done so that the localization folks can increase
// or decrease the width of the toolbar buttons
#define MAX_TB_WIDTH_LORES      38
#define MAX_TB_WIDTH_HIRES      60

// Dimensions of Coolbar Glyphs ..
#define TB_SMBMP_CX               16
#define TB_SMBMP_CY               16
#define TB_BMP_CX                 20
#define TB_BMP_CY                 20
#define TB_BMP_CX_ALPHABITMAP     24
#define TB_BMP_CY_ALPHABITMAP     24

int g_iToolBarLargeIconWidth = TB_BMP_CX;
int g_iToolBarLargeIconHeight = TB_BMP_CY;


#define CX_SEPARATOR    6     // we override toolbar control's default separator width of 8

#define DM_TBSITE   0
#define DM_TBCMD    0
#define DM_TBREF    TF_SHDREF
#define DM_LAYOUT   0
#define DM_ITBAR    0

#define TF_TBCUST   0x01000000

#if CBIDX_LAST != 5
#error Expected CBIDX_LAST to have value of 5
#endif

#if (FCIDM_EXTERNALBANDS_LAST - FCIDM_EXTERNALBANDS_FIRST + 1) < MAXEXTERNALBANDS
#error Insufficient range for FCIDM_EXTERNALBANDS_FIRST to FCIDM_EXTERNALBANDS_LAST
#endif


__inline UINT EXTERNALBAND_VBF_BIT(UINT uiBandExt)
{
    ASSERT(uiBandExt < MAXEXTERNALBANDS);

    // Formula: take 1, shift left by uiBandExt + 16
    //      => a bit in range (0x80000000, 0x00010000)
    UINT uBit = 1 << (uiBandExt + 16);
    ASSERT(uBit & VBF_EXTERNALBANDS);

    return uBit;
}

__inline BOOL IS_EXTERNALBAND(int idBand)
{
    return (InRange(idBand, CBIDX_EXTERNALFIRST, CBIDX_EXTERNALLAST));
}

__inline int MAP_TO_EXTERNAL(int idBand)
{
    ASSERT(IS_EXTERNALBAND(idBand));

    // CBIDX_LAST is one-based, mapping is zero-based
    return (idBand - (1 + CBIDX_LAST));
}


// maximum number of menu items in the context menus for back and forward.
#define MAX_NAV_MENUITEMS               9

#define DEFAULT_SEARCH_GUID    SRCID_SFileSearch //SRCID_SWebSearch

#define SZ_PROP_CUSTDLG     TEXT("Itbar custom dialog hwnd")

#define REG_KEY_BANDSTATE  TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar")

// MHTML Editing
#define SZ_IE_DEFAULT_MHTML_EDITOR  "Default MHTML Editor"
#define REGSTR_PATH_DEFAULT_MHTML_EDITOR TSZIEPATH TEXT("\\") TEXT(SZ_IE_DEFAULT_MHTML_EDITOR)
#define REGSTR_KEY_DEFAULT_MHTML_EDITOR  TEXT(SZ_IE_DEFAULT_MHTML_EDITOR)

DWORD DoNetConnect(HWND hwnd);
DWORD DoNetDisconnect(HWND hwnd);


void _LoadToolbarGlyphs(HWND hwnd, IMLCACHE *pimlCache, int cx, int idBmp,
                        int iBitmapBaseIndex, BOOL bUseClassicGlyphs, HINSTANCE hInst);

BOOL _UseSmallIcons();


typedef struct tagTBBMP_LIST
{
    HINSTANCE hInst;
    UINT_PTR  uiResID;
    UINT  uiOffset;
    BITBOOL  fNormal:1;
    BITBOOL  fHot:1;
    BITBOOL  fDisabled:1;
    UINT  uiCount;
} TBBMP_LIST;

typedef struct tagCMDMAP
{
    GUID    guidButtonGroup;
    UINT    nCmdID;
    LPARAM lParam;  // app's data
} CMDMAP;

typedef struct tagCMDMAPCUSTOMIZE
{
    TBBUTTON btn;
    CMDMAP cm;
} CMDMAPCUSTOMIZE;

typedef struct {

    // the IOleCommandTarget info:
    GUID guid;
    UINT nCmdID;
    UINT fButtonState;
} BUTTONSAVEINFO;

#define TBSI_VERSION            7
typedef struct {
    int cVersion;
} TOOLBARSAVEINFO;

typedef struct {
    HDSA hdsa;
    BITBOOL fAdjust:1;
    BITBOOL fDirty:1;
} CUSTOMIZEINFO, *LPCUSTOMIZEINFO;

//Current latest version.
#define CBS_VERSION             17

// NOTE: Be very careful changing COOLBARSAVE because _LoadUpgradeSettings makes
// assumptions about the layout of the structure.  To avoid breaking that
// upgrade code, be sure you:
//
//  - don't change the order of existing members
//  - always add new members to the end of the structure.
//  - update _LoadUpgradeSettings if appropriate
//
typedef struct tagCOOLBARSAVE
{
    UINT        cbVer;
    UINT        uiMaxTBWidth;
    UINT        uiMaxQLWidth;
#ifdef UNIX
    BITBOOL     fUnUsed : 28;       // unused
#endif
    BITBOOL     fVertical : 1;      // The bar is oriented vertically
    BITBOOL     fNoText :1;         // "NoText"
    BITBOOL     fList : 1;          // toolbar is TBSTYLE_LIST (text on right) + TBSTYLE_EX_MIXEDBUTTONS
    BITBOOL     fAutoHide : 1;      // Auto hide toolbar in theater mode
    BITBOOL     fStatusBar : 1;     // Status bar in theater mode
    BITBOOL     fSaveInShellIntegrationMode : 1;     // Did we save in shell integration mode?
    UINT        uiVisible;          // "Visible bands"
    UINT        cyRebar;
    BANDSAVE    bs[CBANDSMAX];
    CLSID       aclsidExternalBands[ MAXEXTERNALBANDS ];  // Check classid
    CLSID       clsidVerticalBar;       //clsid of bar persisted within vertical band
    CLSID       clsidHorizontalBar;
} COOLBARSAVE, *LPCOOLBARSAVE;

//Flags for dwFlags passed to UpdateToolbarDisplay()
#define UTD_TEXTLABEL  0x00000001
#define UTD_VISIBLE    0x00000002

static const TCHAR c_szRegKeyCoolbar[] = TSZIEPATH TEXT("\\Toolbar");
static const TCHAR c_szValueTheater[]  = TEXT("Theater");

typedef struct tagFOLDERSEARCHITEM
{
    UINT    idCmd;
    GUID    guidSearch;
    int     iIcon;
    WCHAR   wszUrl[MAX_URL_STRING];
    WCHAR   wszName[80];           // friendly name
}FOLDERSEARCHITEM, *LPFOLDERSEARCHITEM;

BOOL _GetSearchHKEY(LPGUID lpguidSearch, HKEY *phkey);

#define REG_SZ_STATIC       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FindExtensions\\Static")
#define REG_SZ_SEARCH_GUID  TEXT("SearchGUID")
#define REG_SZ_SEARCH_URL   TEXT("SearchGUID\\Url")

#define VIEW_OFFSET (SHELLGLYPHS_OFFSET + HIST_MAX + STD_MAX)
#define VIEW_ALLFOLDERS  (VIEW_NETCONNECT + 14)

static const TBBUTTON    c_tbExplorer[] =
{
    // override default toolbar width for separators; iBitmap member of
    // TBBUTTON struct is a union of bitmap index & separator width

    { 0, TBIDM_BACK  ,      0,               BTNS_DROPDOWN | BTNS_SHOWTEXT, {0,0}, 0, 0 },
    { 1, TBIDM_FORWARD,     0,               BTNS_DROPDOWN, {0,0}, 0, 1 },

    { 2, TBIDM_STOPDOWNLOAD, TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 2 },
    { 3, TBIDM_REFRESH,      TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 3 },
    { 4, TBIDM_HOME,         TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 4 },

    { VIEW_PARENTFOLDER + VIEW_OFFSET,    TBIDM_PREVIOUSFOLDER,   TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, VIEW_PARENTFOLDER + VIEW_OFFSET },
    { VIEW_NETCONNECT + VIEW_OFFSET,      TBIDM_CONNECT,          TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, VIEW_NETCONNECT + VIEW_OFFSET },
    { VIEW_NETDISCONNECT + VIEW_OFFSET,   TBIDM_DISCONNECT,       TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, VIEW_NETDISCONNECT + VIEW_OFFSET },

    { CX_SEPARATOR, 0,          TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
    { 5, TBIDM_SEARCH,          TBSTATE_ENABLED, BTNS_SHOWTEXT, {0,0}, 0, 5 },
    { VIEW_ALLFOLDERS + VIEW_OFFSET,    TBIDM_ALLFOLDERS,         TBSTATE_ENABLED, BTNS_SHOWTEXT, {0,0}, 0, VIEW_ALLFOLDERS + VIEW_OFFSET },
    { 6, TBIDM_FAVORITES,       TBSTATE_ENABLED,  BTNS_SHOWTEXT, {0,0}, 0, 6 },
    // IF YOU CHANGE THE ORDERING OF THIS, please change AddMediaBarButton to reflect this ordering.
    { 11, TBIDM_MEDIABAR,       TBSTATE_ENABLED, BTNS_SHOWTEXT, {0,0}, 0, 11 },
    { 12, TBIDM_HISTORY,        TBSTATE_ENABLED, 0/*BTNS_SHOWTEXT*/, {0,0}, 0, 12},
    { CX_SEPARATOR,    0,       TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
#ifndef DISABLE_FULLSCREEN
    // IE UNIX : No theater mode for beta1
    { 14, TBIDM_THEATER,         TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 14 },
#endif
};

// these IDs are the array indices into c_tbExplorer above
// keep in sync, be aware there are ASSERTs to enforce them to be in sync
#define TBXID_BACK              0
#define TBXID_FORWARD           1
#define TBXID_STOPDOWNLOAD      2
#define TBXID_REFRESH           3
#define TBXID_HOME              4
#define TBXID_PREVIOUSFOLDER    5
#define TBXID_CONNECT           6
#define TBXID_DISCONNECT        7
#define TBXID_SEPARATOR1        8
#define TBXID_SEARCH            9
#define TBXID_ALLFOLDERS       10
#define TBXID_FAVORITES        11
#define TBXID_MEDIABAR         12
#define TBXID_HISTORY          13
#define TBXID_SEPARATOR2       14
#define TBXID_THEATER          15


static const BROWSER_RESTRICTIONS c_rest[] = {
    REST_BTN_BACK,
    REST_BTN_FORWARD,
    REST_BTN_STOPDOWNLOAD,
    REST_BTN_REFRESH,
    REST_BTN_HOME,
    REST_BROWSER_NONE,      // no policy for up
    REST_BROWSER_NONE,      // no policy for map drive
    REST_BROWSER_NONE,      // no policy for disconnect drive
    REST_BROWSER_NONE,      // separator
    REST_BTN_SEARCH,
    REST_BTN_ALLFOLDERS,
    REST_BTN_FAVORITES,
    REST_BTN_MEDIABAR,
    REST_BTN_HISTORY,
    REST_BROWSER_NONE,      // separator
#ifndef DISABLE_FULLSCREEN
    REST_BTN_THEATER,
#endif
};


// init flags to avoid multiple inits of toolbar and buttons
#define TBBIF_REG_PATH      TEXT("Software\\Microsoft\\Internet Explorer")
#define TBBIF_REG_KEY       TEXT("AddButtons")
// defined flags as bitfield
#define TBBIF_NONE          0
#define TBBIF_XBAR          0x1     // reserved/used to distinguish pre IE6/RC1 where PersonalBar/xBar was configured
#define TBBIF_MEDIA         0x2

#define SUPERCLASS CBaseBar

class CInternetToolbar :
   public CBaseBar,
   public IDockingWindow,
   public IObjectWithSite,  // *not* CObjectWithSite (want _ptbSite)
   public IExplorerToolbar,
   public DWebBrowserEvents,
   public IPersistStreamInit,
   public IShellChangeNotify,
   public ISearchItems
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return SUPERCLASS::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return SUPERCLASS::Release(); };

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd) { return SUPERCLASS::GetWindow(lphwnd);};
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) {return SUPERCLASS::ContextSensitiveHelp(fEnterMode);};

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    // is E_NOTIMPL ok?
    virtual STDMETHODIMP GetSite(REFIID riid, void** ppvSite) { ASSERT(0); return E_NOTIMPL; };

    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void** ppvObj);

    // *** IExplorerToolbar method ***
    virtual STDMETHODIMP SetCommandTarget(IUnknown* punkCmdTarget, const GUID* pguidButtonGroup, DWORD dwFlags);
    virtual STDMETHODIMP AddStdBrowserButtons(void);

    virtual STDMETHODIMP AddButtons(const GUID* pguidButtonGroup, UINT nButtons, const TBBUTTON * lpButtons);
    virtual STDMETHODIMP AddString(const GUID * pguidButtonGroup, HINSTANCE hInst, UINT_PTR uiResID, LONG_PTR *pOffset);
    virtual STDMETHODIMP GetButton(const GUID* pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton);
    virtual STDMETHODIMP GetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT * pfState);
    virtual STDMETHODIMP SetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT fState);
    virtual STDMETHODIMP AddBitmap(const GUID * pguidButtonGroup, UINT uiBMPType, UINT uiCount, TBADDBITMAP * ptb,
                                   LRESULT * pOffset, COLORREF rgbMask);
    virtual STDMETHODIMP GetBitmapSize(UINT * uiID);
    virtual STDMETHODIMP SendToolbarMsg(const GUID * pguidButtonGroup, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT * plRes);

    virtual STDMETHODIMP SetImageList( const GUID* pguidCmdGroup, HIMAGELIST himlNormal, HIMAGELIST himlHot, HIMAGELIST himlDisabled);
    virtual STDMETHODIMP ModifyButton( const GUID * pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton);

    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
                                     ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);

    // IPersistStreamInit
    STDMETHOD(GetClassID)(GUID *pguid);
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER  *pcbSize);

    /* IDispatch methods */
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);

    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo);

    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames,
                                       LCID lcid, DISPID * rgdispid);

    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                                DISPPARAMS * pdispparams, VARIANT * pvarResult,
                                EXCEPINFO * pexcepinfo,UINT * puArgErr);

    // IShellChangeNotify
    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    // CBaseBar overrides
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // *** ISearchItems methods ***
    virtual STDMETHODIMP GetDefaultSearchUrl(LPWSTR pwzUrl, UINT cch);

    CInternetToolbar();
protected:
    virtual ~CInternetToolbar();
    static LRESULT CALLBACK SizableWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnCommand(WPARAM wParam, LPARAM lParam);
    BOOL _SendToToolband(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    LRESULT _OnNotify(LPNMHDR pnmh);
    void _OnTooltipNeeded(LPTOOLTIPTEXT pnmTT);

    BOOL _UpEnabled();
    void _UpdateCommonButton(int iCmd, UINT nCmdID);
    void _UpdateToolbar(BOOL fForce);
    void _UpdateToolbarNow();
    void _UpdateGroup(const GUID *pguidCmdGroup, int cnt, OLECMD rgcmds[], const GUID* pguidButton, const int buttonsInternal[]);
    void _CSHSetStatusBar(BOOL fOn);
    void _StartDownload();
    void _StopDownload(BOOL fClosing);
    BOOL _CompressBands(BOOL fCompress, UINT uRowsNew, BOOL fForceUpdate);
    void _TrackSliding(int x, int y);
    void _Unadvise(void);
    LRESULT _OnBeginDrag(NMREBAR* pnm);

    void _InsertURL(LPTSTR pszURL);

    void _ShowContextMenu(HWND hwnd, LPARAM lParam, LPRECT prcExclude);
    BOOL _ShowBackForwardMenu(BOOL fForward, POINT pt, LPRECT prcExclude);
    // search helper methods
    BOOL _GetFolderSearchData();
    void _SetSearchStuff();
    BOOL _GetSearchUrl(LPWSTR pwszUrl, DWORD cch);
    HRESULT _GetFolderSearches(IFolderSearches **ppfs);


    void _ReloadButtons();
    void _UpdateToolsStyle(BOOL fList);
    void _InitBitmapDSA();
    void _ReloadBitmapDSA();
    void _InitForScreenSize();
    void _InitToolbar();
    BOOL _FoldersButtonAvailable();
    void _AdminMarkDefaultButtons(PTBBUTTON ptbb, UINT cButtons);
    void _MarkDefaultButtons(PTBBUTTON ptbb, UINT cButtons);
    void _AddCommonButtons();
    HRESULT _CreateBands();
    BOOL    _ShowBands(UINT fVisible);
    HRESULT _ShowTools(PBANDSAVE pbs);
    HRESULT _ShowAddressBand(PBANDSAVE pbs);
    HRESULT _ShowExternalBand(PBANDSAVE pbs, int idBand );
    HRESULT _ShowLinks(PBANDSAVE pbs);
    HRESULT _ShowBrand(PBANDSAVE pbs);
    HRESULT _ShowMenu(PBANDSAVE pbs);
    void _ShowBandCommon(PBANDSAVE pbs, CBandItemData *pbid, BOOL fShow);
    void _EnsureAllBandsShown();
    HRESULT _GetMinRowHeight();

    HBITMAP _LoadBackBitmap();
    void    _SetBackground();
    void    _CommonHandleFileSysChange(LONG lEvent, LPITEMIDLIST* ppidl);
    int     _ConvertHwndToID(HWND hwnd);

    HRESULT _GetPersistedBand(const CLSID clsid, REFIID riid, void ** ppiface);

    // Multiple command target
    LRESULT _AddBitmapFromForeignModule(UINT uiGetMSG, UINT uiSetMSG, UINT uiCount, HINSTANCE hinst,
                                        UINT_PTR nID, COLORREF rgbMask);

    HRESULT _LoadDefaultSettings(void);
    HRESULT _LoadUpgradeSettings(ULONG cbRead);
    HRESULT _LoadDefaultWidths(void);
    void _TryLoadIE3Settings();
    HRESULT _UpdateToolbarDisplay(DWORD dwFlags, UINT uVisibleBands, BOOL fNoText, BOOL fPersist);
    void _UpdateBrandSize();
    void _ShowVisible(DWORD dwVisible, BOOL fPersist);
    void _BuildSaveStruct(COOLBARSAVE* pcs);
    void _RestoreSaveStruct(COOLBARSAVE* pcs);
    void _GetVisibleBrowserBar(UINT idBar, CLSID *pclsidOut);
    VOID _UpdateLocking();

    CBandItemData *_AddNewBand(IDeskBand* pdb, DWORD dwID);

    void _TheaterModeLayout(BOOL fEnter);

    HBITMAP          _bmpBack; // this is the state we think the itbar is in
    static BMPCACHE  s_bmpBackShell; // this is the state of the shell bmp cache
    static BMPCACHE  s_bmpBackInternet; // this is the state of the internet bmp cache
    static IMLCACHE  s_imlTBGlyphs;

    HWND            _hwndMenu;
    HWND            _hwndAddressBand;

    IDockingWindowSite* _ptbsite;
    IOleCommandTarget*  _ptbsitect;
    IBrowserService*    _pbs;
    IBrowserService2*   _pbs2;
    IServiceProvider*   _psp;
    IBandProxy *        _pbp;

    BITBOOL            _fCreatedBandProxy:1;
    BITBOOL            _fBackEnabled:1;
    BITBOOL            _fForwardEnabled:1;
    BITBOOL            _fEditEnabled:1;
    BITBOOL            _fShow:1;
    BITBOOL            _fAnimating:1;
    BITBOOL            _fCompressed:1;
    BITBOOL            _fUserNavigated :1;
    BITBOOL            _fAutoCompInitialized :1;
    BITBOOL            _fDirty:1;
    BITBOOL            _fUsingDefaultBands:1;
    BITBOOL            _fTransitionToHTML:1;
    BITBOOL            _fInitialPidlIsWeb:1;
    BITBOOL            _fTheater: 1; // are we in theater mode?  claim no border space
    BITBOOL            _fAutoHide :1;
    BITBOOL            _fRebarDragging :1;
    BITBOOL            _fShellView:1;   // are we in shell view or web view?
    BITBOOL            _fNoShowMenu:1;    // can show menu band?
    BITBOOL            _fUpdateToolbarTimer:1;
    BITBOOL            _fNeedUpdateToolbar:1;
    BITBOOL            _fNavigateComplete:1;
    BITBOOL            _fLoading:1;     // are we still loading the bar?
    BITBOOL            _fDestroyed:1;   // Did we destroy our member varibles and are shutting down? If so, don't use the varibles. (Stress bug w/messages coming in)
    BITBOOL            _fLockedToolbar:1;

    UINT            _nVisibleBands;     // bitmask of which bands are visible: VBF_*

    IWebBrowser2*   _pdie;
    DWORD           _dwcpCookie;        // DIID_DWebBrowserEvents2
    int             _xCapture;
    int             _yCapture;
    // for multiple command target support
    HDSA            _hdsaTBBMPs;
    UINT            _uiMaxTBWidth;
    UINT            _uiTBTextRows;
    UINT            _uiTBDefaultTextRows;
    // search stuff
    HDPA            _hdpaFSI; // folder search items
    GUID            _guidCurrentSearch;
    GUID            _guidDefaultSearch;

    COOLBARSAVE     _cs;             //Coolbar layout info from registry!
    BOOL            _fDontSave;      // force ourselves not to persist out the state.

    struct EXTERNALBANDINFO {
        CLSID       clsid;          // CLSID of the band
        LPWSTR      pwszName;       // Band name
        LPWSTR      pwszHelp;       // Band help text
    };
    EXTERNALBANDINFO _rgebi[ MAXEXTERNALBANDS ];

    void _LoadExternalBandInfo();

    TBBUTTON _tbExplorer[ARRAYSIZE(c_tbExplorer)];
    int      _iButtons;


    // Variables for customizing the edit button glyph
    HIMAGELIST      _himlEdit;          // Monochrome Image list for the edit button
    HIMAGELIST      _himlEditHot;       // Hot image list for edit button
    int             _iEditIcon;         // index of current edit icon
    int             _cxEditGlyph;       // cx of glyph size
    int             _cyEditGlyph;       // cx of glyph size

    // Functions for managing a custom edit glyph
    void _InitEditButtonStyle();
    void _SetEditGlyph(int iIcon);
    void _RefreshEditGlyph();
    void _UpdateEditButton();
    static HIMAGELIST _CreateGrayScaleImagelist(HBITMAP hbmpImage, HBITMAP hbmpMask);
    static BSTR _GetEditProgID(IHTMLDocument2* pHTMLDocument);

    //
    // We can have multiple edit verbs associated with a document.  The following class
    // maintains a list of verbs.
    //
    #define FCIDM_EDITFIRST  2000
    #define FCIDM_EDITLAST   2100
    #define SZ_EDITVERB_PROP  TEXT("CEditVerb_This")
    #define IL_EDITBUTTON 2     // Index of image list used for the edit button
    #define IL_SEARCHBUTTON 3   //                   ||             search button

    // MSAA Menu Info declarations.
    // These will eventually be incorporated into oleacc.h - but for the
    // moment, we declare them privately...
    #define MSAA_MENU_SIG  0xAA0DF00DL

    class CEditVerb
    {
    public:
        CEditVerb();
        ~CEditVerb();

        // Functions for managing the verbs
        BOOL Add(LPTSTR pszProgID);
        UINT GetSize() { return _nElements; }
        void RemoveAll();

        // Functions to access the default edit verb
        int   GetIcon() { return (_nElements && _pVerb[_nDefault].fShowIcon) ? _GetVerb(_nDefault).iIcon : -1; }
        BOOL  GetToolTip(LPTSTR pszToolTip, UINT cchMax, BOOL fStripAmpersands = TRUE);
        BOOL  GetMenuText(LPTSTR pszText, UINT cchMax) { return GetToolTip(pszText, cchMax, FALSE); }
        void  Edit(LPCTSTR pszUrl) { _Edit(pszUrl, _nDefault); }

        // Pop-up menu
        BOOL ShowEditMenu(POINT pt, HWND hwnd, LPTSTR pszUrl);

        // Get default editor from the registry
        void InitDefaultEditor(HKEY hkey = NULL);

    protected:
        struct MSAAMenuInfo
        {
            DWORD m_MSAASig;  // Must be MSAA_MENU_SIG
            DWORD m_CharLen;  // Length in characters of text, excluding terminating NUL
            LPWSTR m_pWStr;   // Menu text, in UNICODE, with terminating UNICODE-NUL.
        };

        struct EDITVERB
        {
            MSAAMenuInfo m_MSAA;     // MSAA info - must be first element.
            HKEY    hkeyProgID;      // Key the we shellexec
            BITBOOL fUseOpenVerb:1;  // use open verb instead of edit
            BITBOOL fInit:1;         // true if the data below has beed initialized
            BITBOOL fShowIcon:1;     // true if icon should show up on button
            int     iIcon;           // cached icon index
            UINT    idCmd;           // menu id
            LPTSTR  pszDesc;         // executable name or document name
            LPTSTR  pszMenuText;     // Menu text
            LPTSTR  pszExe;          // Path of the exe used to edit
        };

        EDITVERB* _Add(HKEY hkeyProgID, BOOL fPermitOpenVerb, BOOL fCheckForOfficeApp, BOOL fShowIcon);
        EDITVERB& _GetVerb(UINT nIndex);
        void      _FetchInfo(UINT nIndex);
        void      _Edit(LPCTSTR pszUrl, UINT nIndex);
        LPCTSTR   _GetDescription(EDITVERB& rVerb);
        void      _SetMSAAMenuInfo(EDITVERB& rVerb);
        void      _ClearMSAAMenuInfo(EDITVERB& rVerb);
        void      _FormatMenuText(UINT nIndex);
        BOOL      _IsUnique(EDITVERB& rNewVerb);
        BOOL      _IsHtmlStub(LPCWSTR pszPath);
        LPCTSTR   _GetExePath(EDITVERB& rVerb);
        LPCTSTR   _GetDefaultEditor();
        void      _InitDefaultMHTMLEditor();

        static LRESULT CALLBACK _WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

        // Member data
        UINT        _nElements;         // number of edit verbs
        UINT        _nDefault;          // Default edit verb
        EDITVERB*   _pVerb;             // array of edit verbs
        WNDPROC     _lpfnOldWndProc;    // former wndProc
        LPWSTR      _pszDefaultEditor;  // Friendly name of default HTML editor
        BOOL        _fInitEditor;       // if we checked for a default editor
    };
    CEditVerb  _aEditVerb;

    // internal bandsite class
    class CBrowserToolsBand;
    class CITBandSite : public CBandSite
    {
        CITBandSite();

        virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
        virtual STDMETHODIMP AddBand(IUnknown *punk);
        virtual STDMETHODIMP HasFocusIO();

    protected:
        virtual void v_SetTabstop(LPREBARBANDINFO prbbi);
        BOOL _SetMinDimensions();
        friend class CInternetToolbar;
        friend class CBrowserToolsBand;

        virtual HRESULT _OnContextMenu(WPARAM wParm, LPARAM lParam);
        virtual HRESULT _Initialize(HWND hwndParent);

    };
    CITBandSite _bs;


#define TOOLSBANDCLASS CInternetToolbar::CBrowserToolsBand
    class CBrowserToolsBand : public CToolbarBand
    {
        CMDMAP* _GetCmdMapByIndex(int nIndex) { return _GetCmdMap(nIndex, TRUE);};
        CMDMAP* _GetCmdMapByID(int id)  { return _GetCmdMap(id, FALSE);};
        LRESULT _ToolsCustNotify (LPNMHDR pnmh);  // Handle TBCustomization Notify
        BOOL _SaveRestoreToolbar(BOOL fSave);
        void _FreeCustomizeInfo();
        void _FreeCmdMap(CMDMAP*);
        BOOL _RemoveAllButtons();
        int _CommandFromIndex(UINT uIndex);
        HRESULT _ConvertCmd(const GUID* pguidButtonGroup, UINT id, GUID* pguidOut, UINT * pid);
        void _OnDeletingButton(TBNOTIFY* ptbn);
        LONG_PTR _AddString(LPWSTR pwstr);
        void _PreProcessButtonString(TBBUTTON *ptbn, DWORD dwFlags);
        void _PreProcessExternalTBButton(TBBUTTON *ptbn);
        UINT _ProcessExternalButtons(PTBBUTTON ptbb, UINT cButtons);
        void _GetButtons(IOleCommandTarget* pct, const GUID* pguid, HDSA hdsa);
        void _RecalcButtonWidths();
        void _AddMediaBarButton();

        void            _UpdateTextSettings(INT_PTR ids);
        static BOOL_PTR CALLBACK _BtnAttrDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static void     _PopulateComboBox(HWND hwnd, const int iResource[], UINT cResources);
        static void     _SetComboSelection(HWND hwnd, int iCurOption);
        void            _SetDialogSelections(HWND hDlg, BOOL fSmallIcons);
        static void     _PopulateDialog(HWND hDlg);
        void            _OnBeginCustomize(LPNMTBCUSTOMIZEDLG pnm);

        BOOL _BuildButtonDSA();
        CMDMAPCUSTOMIZE* _GetCmdMapCustomize(GUID* guid, UINT nCmdID);

        virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

        virtual STDMETHODIMP GetClassID(CLSID *pClassID) {return E_NOTIMPL;};
        virtual STDMETHODIMP Load(IStream *pStm) {return E_NOTIMPL;};
        virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty) {return E_NOTIMPL;};

        // *** IUnknown ***
        virtual STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef(); };
        virtual STDMETHODIMP_(ULONG) Release(void){ return CToolBand::Release(); };
        virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);

        // *** IDeskBand methods ***
        virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi);

        // *** IWinEventHandler methods ***
        virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);

        // *** IDockingWindow methods ***
        virtual STDMETHODIMP CloseDW(DWORD dwReserved) { return S_OK;};

        // *** IInputObject methods ***
        virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    protected:
        IOleCommandTarget* _CommandTargetFromCmdMap(CMDMAP* pcm);
        LRESULT _OnToolbarDropDown(TBNOTIFY *ptbn);
        virtual LRESULT _OnNotify(LPNMHDR pnmh);
        LRESULT _OnContextMenu(LPARAM lParam, WPARAM wParam);
        CMDMAP* _GetCmdMap(int i, BOOL fByIndex);
        void _OnEndCustomize();
        LRESULT _TryShowBackForwardMenu(DWORD dwItemSpec, LPPOINT ppt, LPRECT prcExclude);
        CBrowserToolsBand();
        void _FreeBtnsAdded();

        friend class CInternetToolbar;
        friend class CITBandSite;

        GUID            _guidCurrentButtonGroup;
        IOleCommandTarget* _pctCurrentButtonGroup;
        LPTBBUTTON      _pbtnsAdded;
        int             _cBtnsAdded;
        DWORD            _nNextCommandID;
        CUSTOMIZEINFO *_pcinfo;
        BITBOOL    _fCustomize :1;
        BITBOOL    _fNeedFreeCmdMapsAdded :1;
    };

    CBrowserToolsBand _btb;

    friend class CBrowserToolsBand;
    friend class CITBandSite;
    friend void CInternetToolbar_CleanUp();
    friend void CInternetToolbar_Preload();
    friend void ITBar_LoadToolbarGlyphs(HWND hwnd);
};

//
// Gets the stream corresponding to the type of the given pidl
//     If the stream already doesn't exist, then it returns NULL.

HRESULT _GetStreamName(DWORD dwITBS, LPTSTR pszName, DWORD cchSize)
{
    HRESULT hr = S_OK;

    ASSERT(pszName);

    switch (dwITBS)
    {
    case ITBS_WEB:
        StrCpyN(pszName, TEXT("WebBrowser"), cchSize);
        break;

    case ITBS_SHELL:
        StrCpyN(pszName, TEXT("ShellBrowser"), cchSize);
        break;

    case ITBS_EXPLORER:
        StrCpyN(pszName, TEXT("Explorer"), cchSize);
        break;

    default:
        hr = E_FAIL;
        break;
    }

    if (FAILED(hr))
        pszName[0] = '\0';

    return hr;
}


//
// Gets the stream corresponding to the type of the given pidl
//     If the stream already doesn't exist, then it returns NULL.

IStream *GetRegStream(BOOL fInternet, LPCTSTR pszValue, DWORD grfMode)
{
    IStream *pstm = NULL;
    HKEY    hkToolbar;

    // read/write since grfMode could be anything
    if (RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegKeyCoolbar, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hkToolbar, NULL) == ERROR_SUCCESS)
    {
        TCHAR   szStreamName[MAX_PATH];

        if (SUCCEEDED(_GetStreamName(fInternet, szStreamName, ARRAYSIZE(szStreamName))))
            pstm = OpenRegStream(hkToolbar, szStreamName, pszValue, grfMode);

        RegCloseKey(hkToolbar);
    }

    return(pstm);
}


//
// Gets the stream corresponding to the type of the given pidl
//     If the stream already doesn't exist, then it returns NULL.

IStream *GetITBarStream(BOOL fInternet, DWORD grfMode)
{
    return GetRegStream(fInternet, TEXT("ITBarLayout"), grfMode);
}


IMLCACHE CInternetToolbar::s_imlTBGlyphs = {NULL};
BMPCACHE CInternetToolbar::s_bmpBackShell = {NULL};
BMPCACHE CInternetToolbar::s_bmpBackInternet = {NULL};
BOOL g_fSmallIcons = FALSE;

void IMLCACHE_CleanUp(IMLCACHE * pimlCache, DWORD dwFlags)
{
    for (int i = 0; i < CIMLISTS; i++)
    {
        if (pimlCache->arhimlPendingDelete[i])
            ImageList_Destroy(pimlCache->arhimlPendingDelete[i]);

        if ((dwFlags & IML_DESTROY) && pimlCache->arhiml[i])
            ImageList_Destroy(pimlCache->arhiml[i]);
    }
}

// DO NOT change the numbering of the following bitmap specs. 
// If you want to add new sizes, add them _after_ ITB_1616_HOT_HICOLOR

#define    ITB_2020_NORMAL             0
#define    ITB_2020_HOT                1
#define    ITB_1616_NORMAL             2
#define    ITB_1616_HOT                3
#define    ITB_2020_NORMAL_HICOLOR     4
#define    ITB_2020_HOT_HICOLOR        5
#define    ITB_1616_NORMAL_HICOLOR     6
#define    ITB_1616_HOT_HICOLOR        7

void ITBar_LoadToolbarGlyphs(HWND hwnd)
{
    int cx, idBmpType;
    int iBitmapBaseIndex;
    BOOL bUseClassicGlyphs = SHUseClassicToolbarGlyphs();
    HINSTANCE hInst;

    g_fSmallIcons = _UseSmallIcons();

    if (bUseClassicGlyphs)
    {
        g_iToolBarLargeIconWidth = TB_BMP_CX;
        g_iToolBarLargeIconHeight = TB_BMP_CY;

        iBitmapBaseIndex = IDB_SHSTD;
        hInst = HINST_THISDLL;
    }
    else
    {
        g_iToolBarLargeIconWidth = TB_BMP_CX_ALPHABITMAP;
        g_iToolBarLargeIconHeight = TB_BMP_CY_ALPHABITMAP;

        iBitmapBaseIndex = IDB_TB_SH_BASE;
        hInst = GetModuleHandle(TEXT("shell32.dll"));
    }

    if (g_fSmallIcons)
    {
        cx = TB_SMBMP_CX;
        idBmpType = ITB_1616_NORMAL;
    }
    else
    {
        cx = g_iToolBarLargeIconWidth;
        idBmpType = ITB_2020_NORMAL;
    }

    if (SHGetCurColorRes() > 8)
        idBmpType += DELTA_HICOLOR;

    _LoadToolbarGlyphs(hwnd, &CInternetToolbar::s_imlTBGlyphs, cx, idBmpType,
                       iBitmapBaseIndex, bUseClassicGlyphs, hInst);
}


void CInternetToolbar_Preload()
{
   ENTERCRITICAL;
   ITBar_LoadToolbarGlyphs(NULL);
   Brand_InitBrandContexts();
   LEAVECRITICAL;
}


void CInternetToolbar_CleanUp()
{
    TraceMsg(DM_ITBAR, "CInternetToolbar_CleanUp: Destroying shared GDI objects");
    if (CInternetToolbar::s_bmpBackInternet.hbmp)
        DeleteObject(CInternetToolbar::s_bmpBackInternet.hbmp);
    if (CInternetToolbar::s_bmpBackShell.hbmp)
        DeleteObject(CInternetToolbar::s_bmpBackShell.hbmp);

    IMLCACHE_CleanUp(&CInternetToolbar::s_imlTBGlyphs, IML_DESTROY);
}

STDAPI CInternetToolbar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CInternetToolbar *pitbar = new CInternetToolbar();
    if (pitbar)
    {
        *ppunk = SAFECAST(pitbar, IDockingWindow *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

LRESULT CInternetToolbar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if ( uMsg == WM_SYSCOLORCHANGE )
    {
        // refresh the back drop incase the colours have changed
        _SetBackground();
    }

    return SUPERCLASS::v_WndProc( hwnd, uMsg, wParam, lParam );
}

void CInternetToolbar::_LoadExternalBandInfo()
{
#ifdef DEBUG
    int i;
    // Should have been zero-initialized
    for (i = 0; i < ARRAYSIZE(_rgebi); i++)
    {

        ASSERT(IsEqualGUID(_rgebi[i].clsid, GUID_NULL));
        ASSERT(_rgebi[i].pwszName == NULL);
        ASSERT(_rgebi[i].pwszHelp == NULL);
    }
#endif

    if ((!SHRegGetBoolUSValue(TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main"), TEXT("Enable Browser Extensions"), FALSE, TRUE))
        || (GetSystemMetrics(SM_CLEANBOOT)!=0))
    {
        return;
    }

    HKEY hkey;
    DWORD dwClsidIndex = 0;
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_KEY_BANDSTATE, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        TCHAR tszReg[MAX_PATH];
        StrCpyN(tszReg, TEXT("CLSID\\"), ARRAYSIZE(tszReg));
        const int cchClsidPrefix = 6;      // 6 = strlen("CLSID\\")
        LPTSTR ptszClsid = tszReg + cchClsidPrefix;
        DWORD cchClsid;
        for (DWORD dwIndex = 0;
             cchClsid = ARRAYSIZE(tszReg) - cchClsidPrefix,
             dwClsidIndex < ARRAYSIZE(_rgebi) &&
             RegEnumValue( hkey, dwIndex, ptszClsid, &cchClsid, NULL, NULL, NULL, NULL ) == ERROR_SUCCESS;
             dwIndex++)
        {
            CLSID clsid;

            // We want to ignore the radio toolband {8E718888-423F-11D2-876E-00A0C9082467}
            // without affecting its existing registration. Makes uninstall easier.
            if (GUIDFromString( ptszClsid, &clsid )
                && StrCmpI(ptszClsid, TEXT("{8E718888-423F-11D2-876E-00A0C9082467}")))
            {
                HKEY hkeyClsid;
                if (RegOpenKeyEx(HKEY_CLASSES_ROOT, tszReg, 0, KEY_READ, &hkeyClsid) == ERROR_SUCCESS)
                {
                    // Don't save the CLSID until we're sure it worked
                    _rgebi[dwClsidIndex].clsid = clsid;

                    WCHAR wszBuf[MAX_PATH];

                    // Get the name; use SHLoadRegUIString so the app can localize
                    SHLoadRegUIStringW( hkeyClsid, L"", wszBuf, ARRAYSIZE(wszBuf) );
                    Str_SetPtrW( &_rgebi[dwClsidIndex].pwszName, wszBuf);

                    // Get the help; use SHLoadRegUIString so the app can localize
                    SHLoadRegUIStringW( hkeyClsid, L"HelpText", wszBuf, ARRAYSIZE(wszBuf) );
                    Str_SetPtrW( &_rgebi[dwClsidIndex].pwszHelp, wszBuf);

                    RegCloseKey(hkeyClsid);

                    dwClsidIndex++;
                }
            }
        }
        RegCloseKey( hkey );
    }
}

CInternetToolbar::CInternetToolbar() : CBaseBar(), _yCapture(-1), _iButtons(-1)
, _iEditIcon(-1), _cxEditGlyph(-1), _cyEditGlyph(-1)
{
    DllAddRef();

    if (GetSystemMetrics(SM_CXSCREEN) < 650)
        _uiMaxTBWidth = MAX_TB_WIDTH_LORES;
    else
        _uiMaxTBWidth = MAX_TB_WIDTH_HIRES;

    ASSERT(_fLoading == FALSE);
    ASSERT(_hwnd == NULL);
    ASSERT(_btb._guidCurrentButtonGroup == CLSID_NULL);
    _btb._nNextCommandID = 1000;

    DWORD dwResult = FALSE, dwType, dwcbData = sizeof(dwResult), dwDefault = TRUE;
    SHRegGetUSValue(c_szRegKeyCoolbar, TEXT("Locked"), &dwType, &dwResult, &dwcbData, FALSE, &dwDefault, sizeof(dwDefault));
    SHSetValue(HKEY_CURRENT_USER, c_szRegKeyCoolbar, TEXT("Locked"), REG_DWORD, &dwResult, sizeof(dwResult));
    _fLockedToolbar = dwResult;

    _LoadExternalBandInfo();
}

void CInternetToolbar::_Unadvise(void)
{
    if(_dwcpCookie)
    {
        ConnectToConnectionPoint(NULL, DIID_DWebBrowserEvents2, FALSE, _pdie, &_dwcpCookie, NULL);
    }
}

int CALLBACK DeleteDPAPtrCB(void *pItem, void *pData)
{
    if ( pItem )
    {
        ASSERT( ::LocalSize(pItem) == sizeof(FOLDERSEARCHITEM) );
        LocalFree(pItem);
        pItem = NULL;
    }

    return TRUE;
}

CInternetToolbar::~CInternetToolbar()
{
    ATOMICRELEASE(_pdie);

    if(_pbp && _fCreatedBandProxy)
    {
        _pbp->SetSite(NULL);
    }
    
    if (IsWindow(_hwnd))
    {
        DestroyWindow(_hwnd);
    }

    ATOMICRELEASE(_pbp);

    ASSERT(!_ptbsite && !_ptbsitect && !_psp && !_pbs && !_pbs2);
    SetSite(NULL);

    if ( _hdpaFSI )
    {
        DPA_DestroyCallback(_hdpaFSI, DeleteDPAPtrCB, NULL);
        _hdpaFSI = NULL;
    }

    for (int i = 0; i < ARRAYSIZE(_rgebi); i++)
    {
        Str_SetPtrW( &_rgebi[i].pwszName, NULL);
        Str_SetPtrW( &_rgebi[i].pwszHelp, NULL);
    }

    TraceMsg(TF_SHDLIFE, "dtor CInternetToolbar %x", this);
    DllRelease();
}

#define IID_DWebBrowserEvents DIID_DWebBrowserEvents


HRESULT CInternetToolbar::QueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        // perf: last tuned 980728
        QITABENTMULTI(CInternetToolbar, IDispatch, DWebBrowserEvents),  // IID_IDispatch
        QITABENT(CInternetToolbar, IExplorerToolbar),       // IID_IDispatch
        QITABENT(CInternetToolbar, IObjectWithSite),        // IID_IObjectWithSite
        QITABENT(CInternetToolbar, IPersistStreamInit),     // IID_IPersistStreamInit
        QITABENT(CInternetToolbar, IDockingWindow),         // IID_IDockingWindow
        QITABENT(CInternetToolbar, DWebBrowserEvents),      // IID_DWebBrowserEvents
        QITABENT(CInternetToolbar, IShellChangeNotify),     // rare IID_IShellChangeNotify
        QITABENT(CInternetToolbar, ISearchItems),           // rare IID_ISearchItems
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);

    return hres;
}

/* IDispatch methods */
HRESULT CInternetToolbar::GetTypeInfoCount(UINT *pctinfo)
{
    return(E_NOTIMPL);
}

HRESULT CInternetToolbar::GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo)
{
    return(E_NOTIMPL);
}

HRESULT CInternetToolbar::GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames,
                                        LCID lcid, DISPID * rgdispid)
{
    return(E_NOTIMPL);
}

#if 0
//  NOTE - StevePro changed it so this code isnt called
//  this is a goodness, because it calls SHVerbExists() which
//  is a TCHAR API, that is actually compiled as an ANSI API
//  and since we are UNICODE it just always fails.
//  leaving this in so that we know about the issue of
//  frontpad.exe possibly needing to be disabled.
BOOL _ShowEditForExtension(LPCTSTR pszExtension)
{
    TCHAR szBuf[MAX_PATH];
    if (SHVerbExists(pszExtension, TEXT("edit"), szBuf))
    {
        // don't show it if it's just our own
        if (StrStrI(szBuf, TEXT("frontpad.exe")))
        {
            return FALSE;
        }
        return TRUE;
    }

    return FALSE;
}
#endif

//+-------------------------------------------------------------------------
// This function scans the html document for META tags that indicate the
// program that was used to create the HTML page.  Examples are:
//
//  <meta name="ProgID" content="word.document" >
//  <meta name="ProgID" content="excel.sheet" >
//
// If a match is found, the content of the first match is returned.  This
// progid is used to edit the document.
//--------------------------------------------------------------------------
BSTR CInternetToolbar::_GetEditProgID(IHTMLDocument2* pHTMLDocument)
{
    BSTR bstrProgID = NULL;

    //
    // First get all document elements.  Note that this is very fast in
    // ie5 because the collection directly accesses the internal tree.
    //
    IHTMLElementCollection * pAllCollection;
    if (SUCCEEDED(pHTMLDocument->get_all(&pAllCollection)))
    {
        IHTMLMetaElement* pMetaElement;
        IHTMLBodyElement* pBodyElement;
        IHTMLFrameSetElement* pFrameSetElement;
        IDispatch* pDispItem;

        //
        // Now we scan the document for meta tags.  Since these must reside in
        // in the head, and since Trident always creates a body tag, we can
        // stop looking when we hit the body.
        //
        // Note, the alternative of using pAllCollection->tags to return the
        // collection of meta tags is likely more expensive because it will
        // walk the whole tree (unless Trident optimizes this).
        //
        long lItemCnt = 0;
        VARIANT vEmpty;
        V_VT(&vEmpty) = VT_EMPTY;

        VARIANT vIndex;
        V_VT(&vIndex) = VT_I4;

        pAllCollection->get_length(&lItemCnt);

        for (long lItem = 0; lItem < lItemCnt; lItem++)
        {
            V_I4(&vIndex) = lItem;

            if (S_OK == pAllCollection->item(vIndex, vEmpty, &pDispItem))
            {
                //
                // First see if it's a meta tag
                //
                if (SUCCEEDED(pDispItem->QueryInterface(IID_PPV_ARG(IHTMLMetaElement, &pMetaElement))))
                {
                    BSTR bstrName = NULL;

                    //
                    // We have a META element, check its NAME and CONTENT
                    //
                    if ( SUCCEEDED(pMetaElement->get_name(&bstrName)) && (bstrName != NULL) &&
                         (StrCmpIW(bstrName, OLESTR("ProgId")) == 0) &&
                         SUCCEEDED(pMetaElement->get_content(&bstrProgID)) && (bstrProgID != NULL)
                       )
                    {
                        // We got the ProgID, so terminate the search;
                        lItem = lItemCnt;
                    }

                    if (bstrName != NULL)
                        SysFreeString(bstrName);

                    pMetaElement->Release();
                }
                //
                // Next check for the body tag
                //
                else if (SUCCEEDED(pDispItem->QueryInterface(IID_PPV_ARG(IHTMLBodyElement, &pBodyElement))))
                {
                    // Found the body tag, so terminate the search
                    lItem = lItemCnt;
                    pBodyElement->Release();
                }
                //
                // Finally, check for a frameset tag
                //
                else if (SUCCEEDED(pDispItem->QueryInterface(IID_PPV_ARG(IHTMLFrameSetElement, &pFrameSetElement))))
                {
                    // Found a frameset tag, so terminate the search
                    lItem = lItemCnt;
                    pFrameSetElement->Release();
                }
                pDispItem->Release();
            }
        }
        // Make sure that these don't have to be cleared (should not have been modified)
        ASSERT(vEmpty.vt == VT_EMPTY);
        ASSERT(vIndex.vt == VT_I4);

        pAllCollection->Release();
    }

    return bstrProgID;
}

//+-------------------------------------------------------------------------
// Returns grey-scale image from the icon passed in.
//--------------------------------------------------------------------------
HIMAGELIST CInternetToolbar::_CreateGrayScaleImagelist(HBITMAP hbmpImage, HBITMAP hbmpMask)
{
    // Determine the button dimensions
    int cx = g_fSmallIcons ? TB_SMBMP_CX : g_iToolBarLargeIconWidth;
    int cy = g_fSmallIcons ? TB_SMBMP_CY : g_iToolBarLargeIconHeight;

    // Start with a 24 bit color image list
    HIMAGELIST himlEdit = ImageList_Create(cx, cy, ILC_COLOR24 | ILC_MASK, 1, 1);
    if (NULL == himlEdit)
    {
        return NULL;
    }

    ImageList_Add(himlEdit, hbmpImage, hbmpMask);

    // Get the dib section from the image list
    IMAGEINFO ii;
    if (ImageList_GetImageInfo(himlEdit, 0, &ii))
    {
        DIBSECTION ds = {0};
        if (GetObject(ii.hbmImage, sizeof(ds), &ds))
        {
            //
            // Map each pixel to a monochrome equivalent.
            //
            BYTE* pBits = (BYTE*)ds.dsBm.bmBits;
            BYTE* pScan = pBits;
            int xWid = ds.dsBm.bmWidth;
            int yHei = ds.dsBm.bmHeight;
            long cbScan = ((xWid * 24 + 31) & ~31) / 8;

            for (int y=0; y < yHei; ++y)
            {
                for (int x=0; x < xWid; ++x)
                {
                    //
                    // Map to equivalent gray color by setting r,g,b to the same value.
                    // Using the average of r,g,b can be too dark, and using the max
                    // of r,g,b can be too bright.  So, as a simple algorithm we use
                    // the average of the two schemes.  This is cheaper than using true
                    // intensity matching.
                    //
                    BYTE nMax = max(max(pScan[0], pScan[1]), pScan[2]);
                    BYTE nAve = ((UINT)pScan[0] + pScan[1] + pScan[2])/3;
                    pScan[0] = pScan[1] = pScan[2] = ((UINT)nMax + nAve)/2;

                    // Increment to next pixel
                    pScan += 3;
                }

                // Increment to the next scan line
                pBits += cbScan;
                pScan = pBits;
            }
        }
    }
    return himlEdit;
}

//+-------------------------------------------------------------------------
// Returns image and mask bitmaps for the desired image list item
//--------------------------------------------------------------------------
BOOL MyImageList_GetBitmaps
(
    HIMAGELIST himl,        // image list to use
    int iImage,             // image to copy
    int x,                  // x-offset to draw in bitmap
    int y,                  // x-offset to draw in bitmap
    int cx,                 // width of bitmap
    int cy,                 // height of bitmap
    HBITMAP* phbmpImage,    // returned color bitmap
    HBITMAP* phbmpMask      // returned mask bitmap
)
{
    ASSERT(phbmpImage);
    ASSERT(phbmpMask);

    BOOL fRet = FALSE;
    HDC hdc = GetDC(NULL);

    if (hdc)
    {
        HDC hdcDst = CreateCompatibleDC(hdc);
        if (hdcDst)
        {
            HBITMAP hbmpImage = CreateCompatibleBitmap(hdc, cx, cy);
            if (hbmpImage)
            {
                HBITMAP hbmpMask = CreateBitmap(cx, cy, 1, 1, NULL);
                if (hbmpMask)
                {
                    // Draw  mask bitmap
                    HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcDst, hbmpMask);
                    PatBlt(hdcDst, 0, 0, cx, cy, WHITENESS);
                    ImageList_Draw(himl, iImage, hdcDst, x, y, ILD_MASK);

                    // Draw image bitmap
                    SelectObject(hdcDst, hbmpImage);
                    ImageList_Draw(himl, iImage, hdcDst, x, y, ILD_NORMAL);

                    SelectObject(hdcDst, hbmpOld);

                    *phbmpImage = hbmpImage;
                    *phbmpMask  = hbmpMask;
                    fRet = TRUE;
                }
                else
                {
                    DeleteObject(hbmpImage);
                }
            }
            DeleteDC(hdcDst);
        }
        ReleaseDC(NULL, hdc);
    }

    return fRet;
}
extern HBITMAP CreateMirroredBitmap( HBITMAP hbmOrig);

//+-------------------------------------------------------------------------
// Creates a special image list for the edit button and configures the edit
// button to use it.  If the hIcon is -1, the edit button is reset to use
// it's default glyph.
//--------------------------------------------------------------------------
void CInternetToolbar::_SetEditGlyph
(
    int iIcon   // new edit button glyph, index into shell image cache
)
{
    // If no toolbar, we just need to see if we need to free the old image lists.
    if (_btb._hwnd == NULL)
    {
        if (iIcon == -1)
        {
            if (_himlEdit)
            {
                ImageList_Destroy(_himlEdit);
                _himlEdit = NULL;
            }
            if (_himlEditHot)
            {
                ImageList_Destroy(_himlEditHot);
                _himlEditHot = NULL;
            }
        }
        else
        {
            // Can't set the glyph if no toolbar!
            ASSERT(FALSE);
        }
        return;
    }

    // Determine the button dimensions
    int cx = g_fSmallIcons ? TB_SMBMP_CX : g_iToolBarLargeIconWidth;
    int cy = g_fSmallIcons ? TB_SMBMP_CY : g_iToolBarLargeIconHeight;


    UINT uiCmd = -1;
    // Dochost merges under one of two clsids, so have to check both
    if (FAILED(_btb._ConvertCmd(&CLSID_InternetButtons, DVIDM_EDITPAGE, NULL, &uiCmd)) &&
        FAILED(_btb._ConvertCmd(&CLSID_MSOButtons, DVIDM_EDITPAGE, NULL, &uiCmd)))
    {
        // The edit button is not on toolbar, so free the edit glyphs
        iIcon = -1;
    }

    // If the current icon is already set, we are done
    if ((_iEditIcon == iIcon) && (_cxEditGlyph == cx) && (_cyEditGlyph == cy))
    {
        if (_himlEdit)
        {
            // Set up the new image lists
            SendMessage(_btb._hwnd, TB_SETIMAGELIST, IL_EDITBUTTON, (LPARAM)_himlEdit);
            if (_himlEditHot)
            {
                SendMessage(_btb._hwnd, TB_SETHOTIMAGELIST, IL_EDITBUTTON, (LPARAM)_himlEditHot);
            }

            // Redirect the edit button to the new image list
            TBBUTTONINFO tbi = {0};
            tbi.cbSize = sizeof(tbi);
            tbi.dwMask = TBIF_IMAGE;
            tbi.iImage = MAKELONG(0, IL_EDITBUTTON);

            SendMessage(_btb._hwnd, TB_SETBUTTONINFO, uiCmd, (LPARAM)&tbi);
        }
        return;
    }

    _iEditIcon = iIcon;
    _cxEditGlyph = cx;
    _cyEditGlyph = cy;

    if (-1 == iIcon)
    {
        if (_himlEdit)
        {
            if (uiCmd != -1)
            {
                // Reset to the original edit glyph
                TBBUTTONINFO tbi = {0};
                tbi.cbSize = sizeof(tbi);
                tbi.dwMask = TBIF_IMAGE;
                tbi.iImage = EDITGLYPH_OFFSET;
                SendMessage(_btb._hwnd, TB_SETBUTTONINFO, uiCmd, (LPARAM)&tbi);
            }

            // Destroy the custom edit glyphs.  Note that we have to reset the primary image list
            // or the image sizes are messed up.
            SendMessage(_btb._hwnd, TB_SETIMAGELIST, IL_EDITBUTTON, (LPARAM)NULL);
            ImageList_Destroy(_himlEdit);
            _himlEdit = NULL;
        }

        if (_himlEditHot)
        {
            SendMessage(_btb._hwnd, TB_SETHOTIMAGELIST, IL_EDITBUTTON, (LPARAM)NULL);
            ImageList_Destroy(_himlEditHot);
            _himlEditHot = NULL;
        }
    }
    else
    {
        // Get the image bitmaps
        HBITMAP hbmpImage = NULL;
        HBITMAP hbmpMask = NULL;
        BOOL bMirrored = IS_WINDOW_RTL_MIRRORED(_btb._hwnd);
        HIMAGELIST himlSmall;
        int cxSmall;
        int cySmall;

        if (Shell_GetImageLists(NULL, &himlSmall) &&
            ImageList_GetIconSize(himlSmall, &cxSmall, &cySmall) &&
            MyImageList_GetBitmaps(himlSmall, iIcon, (cx - cxSmall)/2, (cy - cySmall)/2,
                                   cx, cy, &hbmpImage, &hbmpMask))
        {

            if (bMirrored) 
            {
                HBITMAP hbmpTemp;

                hbmpTemp = CreateMirroredBitmap(hbmpImage);
                if (hbmpTemp)
                {
                    DeleteObject(hbmpImage);
                    hbmpImage = hbmpTemp;
                }
                hbmpTemp = CreateMirroredBitmap(hbmpMask);
                if (hbmpTemp)
                {
                    DeleteObject(hbmpMask);
                    hbmpMask = hbmpTemp;
                }
            }
            // Create a monochrome glyph for the edit button
            HIMAGELIST himlEdit = _CreateGrayScaleImagelist(hbmpImage, hbmpMask);
            SendMessage(_btb._hwnd, TB_SETIMAGELIST, IL_EDITBUTTON, (LPARAM)himlEdit);
            if (_himlEdit)
            {
                ImageList_Destroy(_himlEdit);
            }
            _himlEdit = himlEdit;

            // Create a hot glyph for the edit button
            HIMAGELIST himlEditHot = ImageList_Create(cx, cy, ILC_COLORDDB | ILC_MASK, 1, 1);
            int nIndex = ImageList_Add(himlEditHot, hbmpImage, hbmpMask);

            SendMessage(_btb._hwnd, TB_SETHOTIMAGELIST, IL_EDITBUTTON, (LPARAM)himlEditHot);
            if (_himlEditHot)
            {
                ImageList_Destroy(_himlEditHot);
            }
            _himlEditHot = himlEditHot;

            // Redirect the edit button to the new image list
            if (_himlEdit)
            {
                TBBUTTONINFO tbi = {0};
                tbi.cbSize = sizeof(tbi);
                tbi.dwMask = TBIF_IMAGE;
                tbi.iImage = MAKELONG(nIndex, IL_EDITBUTTON);

                SendMessage(_btb._hwnd, TB_SETBUTTONINFO, uiCmd, (LPARAM)&tbi);
            }

            DeleteObject(hbmpImage);
            DeleteObject(hbmpMask);
               
        }
        else
        {
            // Couldn't create images so use the default edit glyph
            _SetEditGlyph(-1);
        }
    }
}

//+-------------------------------------------------------------------------
// Initializes the edit button to display a drop-down menu if there are
// multiple verbs.  Also optionally displays a custion glyph.
//--------------------------------------------------------------------------
void CInternetToolbar::_InitEditButtonStyle()
{
    // If we have or want a custon edit glyph, load it
    _SetEditGlyph(_aEditVerb.GetIcon());

    UINT uiCmd;

    // Dochost merges under one of two clsids, so have to check both
    if (SUCCEEDED(_btb._ConvertCmd(&CLSID_InternetButtons, DVIDM_EDITPAGE, NULL, &uiCmd)) ||
        SUCCEEDED(_btb._ConvertCmd(&CLSID_MSOButtons, DVIDM_EDITPAGE, NULL, &uiCmd)))
    {
        ASSERT(uiCmd != -1);

        // If multiple verbs, make the button a split button
        TBBUTTONINFO tbi = {0};
        tbi.cbSize = sizeof(tbi);
        tbi.dwMask = TBIF_STYLE | TBIF_STATE;
        tbi.fsState = 0;

        if (_aEditVerb.GetSize() > 1)
        {
            tbi.fsStyle |= BTNS_DROPDOWN;
        }

        if (_aEditVerb.GetSize() > 0)
        {
            tbi.fsState = TBSTATE_ENABLED;
        }
        SendMessage(_btb._hwnd, TB_SETBUTTONINFO, uiCmd, (LPARAM)&tbi);
    }
}

//+-------------------------------------------------------------------------
// If the edit button is displaying a custon glyph, this function reloads
// the glyph.
//--------------------------------------------------------------------------
void CInternetToolbar::_RefreshEditGlyph()
{
    // If we have a custon edit glyph, reload it
    if (_himlEdit)
    {
        // Refresh the edit glyph
        _iEditIcon = -1;
        _InitEditButtonStyle();
    }
}

//+-------------------------------------------------------------------------
// Updates the edit button based on the document type currently loaded
//--------------------------------------------------------------------------
void CInternetToolbar::_UpdateEditButton()
{
    _aEditVerb.RemoveAll();
    _fEditEnabled = FALSE;
    BOOL fNoEditSpecified = FALSE;

    //
    // First add editors associated with the url
    //
    BSTR bstrUrl = NULL;
    _pdie->get_LocationURL(&bstrUrl);
    if (bstrUrl)
    {
        LPTSTR pszExt;
        //
        // Find the cache file associated with the url.  The file extension for this entry
        // is based off of the mime type. (Note that get_mimeType on the document
        // returns a frindly name that is hard to translate back to an actual mimetype.
        // So we use the file extension instead.)
        //
        WCHAR szCacheFileName[MAX_PATH];
        *szCacheFileName = 0;
        if (FAILED(URLToCacheFile(bstrUrl, szCacheFileName, ARRAYSIZE(szCacheFileName))))
        {
            // If we can't get a file associated with the url, probably want to disable the edit button
            // because most apps need a file to edit.
            SysFreeString(bstrUrl);
            return;
        }

        pszExt = PathFindExtension(szCacheFileName);

        // bug 79055 - The cache has a bug where some html entries are not
        // given a file extension.  Too risky to fix for 5.x, so we'll just
        // assume .htm for http if no extension is present.
        if (L'\0' == *pszExt && GetUrlScheme(bstrUrl) == URL_SCHEME_HTTP)
        {
            StrCpyN(szCacheFileName, L".htm", ARRAYSIZE(szCacheFileName));
            pszExt = szCacheFileName;
        }

        if (*pszExt)
        {
            _aEditVerb.Add(pszExt);

            // If ".html", use the ".htm" editors too
            if (StrCmpI(pszExt, L".html") == 0 )
            {
                //  This is an html document, so add the .htm editors
                if (!_aEditVerb.Add(TEXT(".htm")) && StrCmpI(pszExt, L".html") != 0)
                {
                    _aEditVerb.Add(TEXT(".html"));
                }
            }
        }

        SysFreeString(bstrUrl);
    }

    //
    // See if the feature to search the doc for the progid is enabled
    //
    static int fCheckDocForProgID = -1;
    if (fCheckDocForProgID == -1)
    {
        fCheckDocForProgID = SHRegGetBoolUSValue(REGSTR_PATH_MAIN,
                 TEXT("CheckDocumentForProgID"), FALSE, TRUE) ? 1 : 0;
    }

    // Check for a meta tag that specifies a progid for editing this document
    if (fCheckDocForProgID)
    {
        //
        // Next see if this is an html document with a progid
        //
        IWebBrowser2*       pWB2 = NULL;
        IDispatch *         pDispatch = NULL;
        IHTMLDocument2 *    pHTMLDocument = NULL;

        // Get the html document currently loaded
        if (_psp &&
            SUCCEEDED(_psp->QueryService(SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &pWB2))) &&
            SUCCEEDED(pWB2->get_Document(&pDispatch)) &&
            SUCCEEDED(pDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pHTMLDocument))))
        {
            //
            // Check the current document for a META tag specifying the program to use to
            // edit this file.
            //
            BSTR bstrProgID = _GetEditProgID(pHTMLDocument);
            if (bstrProgID)
            {
                if (lstrcmpi(bstrProgID, TEXT("NoEdit")) == 0)
                {
                    fNoEditSpecified = TRUE;
                }
                else
                {
                    // this edit verb progid comes directly from the html document so its not trusted.
                    // however, the CEditVerb will validate that the progid in the registry has the "edit"
                    // or "open" verb associated with it and thats all it will do, so its not like a blind
                    // shellexecute or running a dispatch object or anything.
                    // there are also no objects installed by default that will format a users hard drive
                    // upon cocreate or anything.
                    _aEditVerb.Add(bstrProgID);
                    SysFreeString(bstrProgID);
                }
            }
        }

        SAFERELEASE(pWB2);
        SAFERELEASE(pDispatch);
        SAFERELEASE(pHTMLDocument);
    }


    if (!fNoEditSpecified)
    {
        _fEditEnabled = (_aEditVerb.GetSize() > 0);
    }

    // Update edit glyph, drop-down style, & enabled state
    _InitEditButtonStyle();
}

HRESULT CInternetToolbar::Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                                 DISPPARAMS * pdispparams, VARIANT * pvarResult,
                                 EXCEPINFO * pexcepinfo,UINT * puArgErr)
{
    if(!pdispparams)
        return E_INVALIDARG;

    switch(dispidMember)
    {

    case DISPID_NAVIGATECOMPLETE2:
    {
        //
        // Notify the brand and theater mode objects about whether we're in shell or
        // web mode. Wait til now to do it (rather than doing it in SetCommandTarget)
        // because they might want to ask the browser about the new pidl, which isn't
        // yet filled in at SetCommandTarget time.
        //
        DWORD nCmdexecopt = _fShellView ? CITE_SHELL : CITE_INTERNET;

        CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_BRAND);
        if (pbid)
        {
            IUnknown_Exec(pbid->pdb, &CGID_PrivCITCommands, CITIDM_ONINTERNET, nCmdexecopt, NULL, NULL);
            pbid->Release();
        }

        if (_fTheater)
        {
            IUnknown_Exec(_ptbsite, &CGID_Theater, THID_ONINTERNET, nCmdexecopt, NULL, NULL);
        }

        // If notification is not from a frame, set the _fNavigateComplete flag
        for (DWORD i = 0; i < pdispparams->cArgs; i++)
        {
            if (pdispparams->rgvarg[i].vt == VT_DISPATCH)
            {
                // See who's sending us this event
                IBrowserService* pbs = NULL;
                HRESULT hr = IUnknown_QueryService(pdispparams->rgvarg[i].pdispVal, SID_SShellBrowser, IID_PPV_ARG(IBrowserService, &pbs));
                if (pbs)
                {
                    // We don't really need this interface, just its address
                    pbs->Release();
                }
                if (SUCCEEDED(hr) && pbs == _pbs)
                {
                    // Notification did not come from a frame, 
                    _fNavigateComplete = TRUE;
                }
            }
        }
    }
    break;

    case DISPID_BEFORENAVIGATE:
    {
        BOOL fWeb = FALSE;

        ASSERT((pdispparams->rgvarg[5].vt == VT_BSTR) &&
               (pdispparams->rgvarg[5].bstrVal != NULL));

        PARSEDURL pu = { 0 };
        pu.cbSize = sizeof(pu);
        ParseURL(pdispparams->rgvarg[5].bstrVal, &pu);

        if ((URL_SCHEME_UNKNOWN != pu.nScheme) && (URL_SCHEME_FILE != pu.nScheme))
            fWeb = TRUE;

        UINT uiState = 0;
        GetState(&CLSID_CommonButtons, TBIDM_STOPDOWNLOAD, &uiState);

        if ((uiState & TBSTATE_HIDDEN) && fWeb)
        {

            _fTransitionToHTML = TRUE;
            uiState &= ~TBSTATE_HIDDEN;
            SetState(&CLSID_CommonButtons, TBIDM_STOPDOWNLOAD, uiState);
        }

        // Default to the edit button hidden
        _fEditEnabled = FALSE;
    }
    break;

    case DISPID_DOWNLOADBEGIN:// This is when we just started to navigate?  No bits?
        _StartDownload();
        break;

    case DISPID_DOWNLOADCOMPLETE:    // we be done
        _fTransitionToHTML = FALSE;
        _StopDownload(FALSE);
        break;

    case DISPID_DOCUMENTCOMPLETE:   // This is where we have all the bits
    {
        //
        // Sometimes we get a premature document complete (for framesets).  We can catch this
        // by checking to see if we have received a DISPID_NAVIGATECOMPLETE2 event
        // for the top window.  We have to update the edit button here instead of in 
        // navigate complete because otherwise the document is not in the interactive
        // state and our metatag search sees the previous document. 
        //
        // REARCHITECT: Is it possible that this event came from a frame and the document is not
        // interactive yet? Trident posts an interactive event right before calling us so
        // we're probably ok.  We don't want to wait for the document complete for the top window
        // in framesets because it can take too long.  Really need to sink DISPID_READYSTATECHANGE
        // and wait for the document to go interactive.
        //
        if (_fNavigateComplete)
        {
            _fNavigateComplete = FALSE;
            _UpdateEditButton();
        }
        break;
    }

    case DISPID_COMMANDSTATECHANGE:
        BOOL fEnable;

        if(!pdispparams || (pdispparams->cArgs != 2) ||
           (pdispparams->rgvarg[0].vt != VT_BOOL) ||
           (pdispparams->rgvarg[1].vt != VT_I4))
            return E_INVALIDARG;

        fEnable = (BOOL) pdispparams->rgvarg[0].boolVal;
        UINT uiCmd;

        switch (pdispparams->rgvarg[1].lVal)
        {
        case CSC_UPDATECOMMANDS:
            // corresponds to OLECMDID_UPDATECOMMANDS from Exec()
            _UpdateToolbar(FALSE);
            break;

        case CSC_NAVIGATEBACK:
            _fBackEnabled = fEnable;
            _btb._ConvertCmd(&CLSID_CommonButtons, TBIDM_BACK, NULL, &uiCmd);
            SendMessage(_btb._hwnd, TB_ENABLEBUTTON, uiCmd,    MAKELONG(fEnable, 0));
            break;

        case CSC_NAVIGATEFORWARD:
            _fForwardEnabled = fEnable;
            _btb._ConvertCmd(&CLSID_CommonButtons, TBIDM_FORWARD, NULL, &uiCmd);
            SendMessage(_btb._hwnd, TB_ENABLEBUTTON, uiCmd, MAKELONG(fEnable, 0));
            break;

        default:
            return(E_INVALIDARG);
        }

        // FEATURE need to handle the case of navigation failure and
        // do some cleanup

    }

    return S_OK;
}

// *** IInputObjectSite methods ***

HRESULT CInternetToolbar::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return IUnknown_OnFocusChangeIS(_ptbsite, SAFECAST(this, IInputObject*), fSetFocus);
}


//***   CInternetToolbar::IInputObject::* {

HRESULT CInternetToolbar::TranslateAcceleratorIO(LPMSG lpMsg)
{
    if (_fShow)
    {
        if (lpMsg->message == WM_KEYDOWN)
        {
            switch (lpMsg->wParam)
            {
            case VK_F4:
        Laddrband:
                if (_nVisibleBands & VBF_ADDRESS)
                {
                    CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
                    if (pbid)
                    {
                        HRESULT hrT = IUnknown_TranslateAcceleratorIO(pbid->pdb, lpMsg);
                        ASSERT(hrT == S_OK);
                        pbid->Release();
                    }
                }
                return S_OK;    // (even if we just eat it)
            }
        }
        else if(lpMsg->message == WM_SYSCHAR)
        {
            static CHAR szAccel[2] = "\0";
            CHAR   szChar [2] = "\0";

            if ('\0' == szAccel[0])
                MLLoadStringA(IDS_ADDRBAND_ACCELLERATOR, szAccel, ARRAYSIZE(szAccel));

            szChar[0] = (CHAR)lpMsg->wParam;
            
            if (lstrcmpiA(szChar,szAccel) == 0)
            {
                goto Laddrband;
            }
        }
        return _bs.TranslateAcceleratorIO(lpMsg);
    }
    return S_FALSE;
}


// }

HRESULT CInternetToolbar::SetSite(IUnknown* punkSite)
{
    ATOMICRELEASE(_ptbsite);
    ATOMICRELEASE(_ptbsitect);
    ATOMICRELEASE(_pbs);
    ATOMICRELEASE(_pbs2);
    ATOMICRELEASE(_psp);

    _Unadvise();

    ATOMICRELEASE(_pdie);

    ASSERT(_ptbsite==NULL);
    ASSERT(_ptbsitect==NULL);
    ASSERT(_pbs==NULL);
    ASSERT(_pbs2==NULL);
    ASSERT(_pdie==NULL);

    if (_pbp && _fCreatedBandProxy)
        _pbp->SetSite(punkSite);

    if (punkSite)
    {
        punkSite->QueryInterface(IID_PPV_ARG(IDockingWindowSite, &_ptbsite));
        punkSite->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_ptbsitect));
        punkSite->QueryInterface(IID_PPV_ARG(IBrowserService2, &_pbs2));
        punkSite->QueryInterface(IID_PPV_ARG(IServiceProvider, &_psp));

        if (_psp)
        {
            _psp->QueryService(SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &_pdie));
            _psp->QueryService(SID_SShellBrowser, IID_PPV_ARG(IBrowserService, &_pbs));
            ASSERT(_pdie);
        }
        else
        {
            ASSERT(0);
        }

    }
    else
    {
        SetClient(NULL);
    }


    return S_OK;
}


//***
//
void CInternetToolbar::_UpdateGroup(const GUID *pguidCmdGroup, int cnt,
    OLECMD rgcmds[], const GUID* pguidButton, const int buttonsInternal[])
{

    if (!IsEqualGUID(*pguidButton, CLSID_CommonButtons) &&
        !IsEqualGUID(*pguidButton, _btb._guidCurrentButtonGroup))
        return; // we don't have any buttons at this time, so no use checking

    if (_ptbsitect)
    {
        _ptbsitect->QueryStatus(pguidCmdGroup, cnt, rgcmds, NULL);

        // make sure stop is enabled while we are animating
        if (_fAnimating && pguidCmdGroup == NULL && rgcmds[0].cmdID == OLECMDID_STOP)
        {
            rgcmds[0].cmdf = OLECMDF_ENABLED;
        }
    }

    for (int i = 0; i < cnt; i++)
    {
        // do nothing if command is not available or not in our table
        if (rgcmds[i].cmdf & OLECMDF_SUPPORTED)
        {
            UINT idBut;
            if (SUCCEEDED(_btb._ConvertCmd(pguidButton, buttonsInternal[i], NULL, (UINT*)&idBut)))
            {
                SendMessage(_btb._hwnd, TB_ENABLEBUTTON, idBut,
                    (rgcmds[i].cmdf & OLECMDF_ENABLED) ? TRUE : FALSE);

                SendMessage(_btb._hwnd, TB_CHECKBUTTON, idBut,
                    (rgcmds[i].cmdf & OLECMDF_LATCHED) ? TRUE : FALSE);
            }
        }
    }
    return;
}

void CInternetToolbar::_UpdateToolbar(BOOL fForce)
{
    if (fForce || SHIsChildOrSelf(GetForegroundWindow(), _hwnd) == S_OK)
    {
        if (!_fUpdateToolbarTimer)
        {
            SetTimer(_hwnd, IDT_UPDATETOOLBAR, TIMEOUT_UPDATETOOLBAR, NULL);
            _fUpdateToolbarTimer = TRUE;
            _UpdateToolbarNow();
        }
        else
        {
            _fNeedUpdateToolbar = TRUE;
        }
    }
}

BOOL CInternetToolbar::_UpEnabled()
{
    OLECMD rgcmd = { FCIDM_PREVIOUSFOLDER, 0 };
    _ptbsitect->QueryStatus(&CGID_ShellBrowser, 1, &rgcmd, NULL);

    return (rgcmd.cmdf & OLECMDF_ENABLED);
}

void CInternetToolbar::_UpdateCommonButton(int iCmd, UINT nCmdID)
{
    switch (nCmdID)
    {
    case TBIDM_THEATER:
        SendMessage(_btb._hwnd, TB_CHECKBUTTON, iCmd, _fTheater);
        break;

    case TBIDM_PREVIOUSFOLDER:
    case TBIDM_BACK:
    case TBIDM_FORWARD:
        {
            BOOL fEnabled;

            switch (nCmdID)
            {
            case TBIDM_PREVIOUSFOLDER:  fEnabled = _UpEnabled();       break;
            case TBIDM_BACK:            fEnabled = _fBackEnabled;      break;
            case TBIDM_FORWARD:         fEnabled = _fForwardEnabled;   break;
            }

            SendMessage(_btb._hwnd, TB_ENABLEBUTTON, iCmd, MAKELONG(fEnabled, 0));
        }
        break;
    }
}

void CInternetToolbar::_UpdateToolbarNow()
{
    _fNeedUpdateToolbar = FALSE;

    {
        // MUST not be static (due to ConvertCmd overwrite)
        OLECMD rgcmds[] = {
            { OLECMDID_STOP, 0 }, // NOTE: must be first
            { OLECMDID_REFRESH, 0 },
        };

        static const int buttonsInternal[] = { // MUST be in same order as above array
            TBIDM_STOPDOWNLOAD,
            TBIDM_REFRESH,
        };
        _UpdateGroup(NULL, ARRAYSIZE(buttonsInternal), rgcmds, &CLSID_CommonButtons, buttonsInternal);
    }

    {
        OLECMD rgcmds[] = {
            { SBCMDID_SEARCHBAR, 0 },
            { SBCMDID_FAVORITESBAR, 0 },
            { SBCMDID_HISTORYBAR, 0 },
            { SBCMDID_EXPLORERBAR, 0 },
            { SBCMDID_MEDIABAR, 0 },
        };
        static const int buttonsInternal[] = { // MUST be in same order as above array
            TBIDM_SEARCH,
            TBIDM_FAVORITES,
            TBIDM_HISTORY,
            TBIDM_ALLFOLDERS,
            TBIDM_MEDIABAR,
        };

        _UpdateGroup(&CGID_Explorer, ARRAYSIZE(buttonsInternal), rgcmds, &CLSID_CommonButtons, buttonsInternal);
    }

    int nButtons = (int) SendMessage(_btb._hwnd, TB_BUTTONCOUNT, 0, 0L);

    for (int nIndex = 0; nIndex < nButtons; nIndex++)
    {
        CMDMAP* pcm = _btb._GetCmdMapByIndex(nIndex);
        if (pcm)
        {
            int iCmd = _btb._CommandFromIndex(nIndex);
            if (IsEqualGUID(pcm->guidButtonGroup, CLSID_CommonButtons))
            {
                _UpdateCommonButton(iCmd, pcm->nCmdID);
            }
            else
            {
                // NOTE (andrewgu): ie5.5 b#106047 - the two conditions below used to be ASSERTs,
                // the second one was faulting under stress. if either one of these checks fails,
                // the button is stale.
                if (IsEqualGUID(pcm->guidButtonGroup, _btb._guidCurrentButtonGroup) &&
                    NULL != _btb._pctCurrentButtonGroup)
                {
                    OLECMD ocButton;
                    ocButton.cmdID = pcm->nCmdID;
                    ocButton.cmdf = 0;

                    if (SUCCEEDED(_btb._pctCurrentButtonGroup->QueryStatus(&pcm->guidButtonGroup, 1, &ocButton, NULL)))
                    {
                        SendMessage(_btb._hwnd, TB_ENABLEBUTTON, iCmd,
                                    (ocButton.cmdf & OLECMDF_ENABLED) ? TRUE : FALSE);

                        SendMessage(_btb._hwnd, TB_CHECKBUTTON, iCmd,
                                    (ocButton.cmdf & OLECMDF_LATCHED) ? TRUE : FALSE);
                    }
                }
            }
        }
    }

    if (_btb._hwnd)
    {
        _btb._BandInfoChanged();
    }
}

void CInternetToolbar::_StartDownload()
{
    UINT uiCmd;
    if (SUCCEEDED(_btb._ConvertCmd(&CLSID_CommonButtons, TBIDM_STOPDOWNLOAD, NULL, &uiCmd)))
    {
        SendMessage(_btb._hwnd, TB_ENABLEBUTTON, uiCmd, MAKELONG(TRUE, 0));

        _fAnimating = TRUE;
    }
}

//
// Parameters:
//  fClosing -- TRUE only if we are calling this from CloseDW member.
//              In that case, we can skip all UI-update code.
//
void CInternetToolbar::_StopDownload(BOOL fClosing)
{
    _fAnimating = FALSE;
}

HRESULT CInternetToolbar::CloseDW(DWORD dwReserved)
{
    _fDestroyed = TRUE; // Stop using the member variables, they are invalid.
    _StopDownload(TRUE);

    ASSERT(!_btb._pcinfo);
    ATOMICRELEASE(_btb._pctCurrentButtonGroup);

    _btb._FreeBtnsAdded();

    if (_btb._hwnd)
    {
        _btb._RemoveAllButtons();

        SendMessage(_btb._hwnd, TB_SETIMAGELIST, 0, NULL);
        SendMessage(_btb._hwnd, TB_SETHOTIMAGELIST, 0, NULL);

        DSA_Destroy(_hdsaTBBMPs);
        _hdsaTBBMPs = NULL;  // So we don't try to re-destroy in _InitBitmapDSA()
    }
    _SetEditGlyph(-1);

    _bs._Close();

    SUPERCLASS::CloseDW(dwReserved);

    _btb._hwnd = NULL;

    // We advise during ShowDW, so unadvise here. Also, we hit a stress
    // case where it seems that an event came in after closedw but before
    // one of the other _Unadvise calls. This event percolated down to
    // a reference to _hdsaCT which we freed above, causing a GPF.
    //
    _Unadvise();

    return S_OK;
}

void CInternetToolbar::CITBandSite::v_SetTabstop(LPREBARBANDINFO prbbi)
{
    // Don't set tabstops for all bands in the browser case.  A band
    // can still make itself a tabstop by setting WS_TABSTOP.
    return;
}

BOOL CInternetToolbar::CITBandSite::_SetMinDimensions()
{
    INT_PTR fRedraw = SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);

    int icBands = (int) SendMessage( _hwnd, RB_GETBANDCOUNT, 0, 0 );
    for (int i = 0; i < icBands; i++)
    {
        REBARBANDINFO rbbi;
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_ID | RBBIM_CHILDSIZE;
        if (SendMessage(_hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
        {
            rbbi.cxMinChild = 0;
            rbbi.cyMinChild = 0;
            CBandItemData *pbid = _GetBandItemDataStructByID(rbbi.wID);
            if (pbid)
            {
                if (IS_VALID_HANDLE(pbid->hwnd, WND))
                {
                    rbbi.cxMinChild = pbid->ptMinSize.x;
                    rbbi.cyMinChild = pbid->ptMinSize.y;
                }
                pbid->Release();
            }

            SendMessage(_hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
        }
    }

    SendMessage(_hwnd, WM_SETREDRAW, fRedraw, 0);

    return TRUE;
}


BOOL HimlCacheDirty(IMLCACHE* pimlCache, BOOL fSmallIcons)
{

    if (fSmallIcons != pimlCache->fSmallIcons)
        return TRUE;

    COLORREF cr3D = GetSysColor(COLOR_3DFACE);

    if (cr3D != pimlCache->cr3D)
        return TRUE;

    if (SHUseClassicToolbarGlyphs() != pimlCache->fUseClassicGlyphs)
        return TRUE;

    for (int i = 0; i < CIMLISTS; i++)
        if (!pimlCache->arhiml[i])
            return TRUE;

    return FALSE;
}


#define SZ_REGKEY_SMALLICONS       REGSTR_PATH_EXPLORER TEXT("\\SmallIcons")
#define SZ_REGVALUE_SMALLICONS     TEXT("SmallIcons")

BOOL _DefaultToSmallIcons()
{
    // We default to small icons if:
    //
    // This is NT 5, or the policy says to use small icons, or this is any
    // of the Whistler servers (server, adv server, dtc)

    return ((GetUIVersion() == 5) || SHRestricted2(REST_SMALLICONS, NULL, 0) ||
            (IsOS(OS_WHISTLERORGREATER) && IsOS(OS_ANYSERVER)));
}

BOOL _UseSmallIcons()
{
    BOOL fDefaultToSmall = _DefaultToSmallIcons();

    return SHRegGetBoolUSValue(SZ_REGKEY_SMALLICONS, SZ_REGVALUE_SMALLICONS,
                                        FALSE, fDefaultToSmall);
}


BOOL _UseMapNetDrvBtns()
{
#define SZ_REGKEY_ADVFOLDER        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")
#define SZ_REGVALUE_MAPNETDRV      TEXT("MapNetDrvBtn")

    DWORD dwData = 0;
    if (GetUIVersion() >= 4)
    {
        DWORD cbData = sizeof(dwData);
        DWORD dwDefault = 0;
        DWORD cbDefault = sizeof(dwDefault);

        SHRegGetUSValue(SZ_REGKEY_ADVFOLDER, SZ_REGVALUE_MAPNETDRV, NULL,
                            &dwData, &cbData, FALSE, &dwDefault, cbDefault);
    }
    return dwData;
}

HIMAGELIST _LoadThemedToolbarGlyphs(int idBmpType, int iTemperature, int cx, COLORREF crMask, UINT uFlags, BOOL bUseClassicGlyphs, HINSTANCE hInst);

void _LoadToolbarGlyphs(HWND hwnd, IMLCACHE *pimlCache, int cx, int idBmpType,
                        int iBitmapBaseIndex, BOOL bUseClassicGlyphs, HINSTANCE hInst)
{
    // set uMsg and uFlags for first iteration of loop (default state)
    UINT uMsg = TB_SETIMAGELIST;
    UINT uFlags = LR_CREATEDIBSECTION;
    int i;
    HBITMAP hBMP;
    BOOL fSmallIcons = g_fSmallIcons;

    if (HimlCacheDirty(pimlCache, fSmallIcons))
    {
        COLORREF cr3D   = GetSysColor(COLOR_3DFACE);
        COLORREF crMask = RGB( 255, 0, 255 );

#ifdef UNIX
        if (SHGetCurColorRes() < 2 )
        {
            crMask = CLR_NONE;
        }
#endif

        ENTERCRITICAL;

        if (!HimlCacheDirty(pimlCache, fSmallIcons) )
            goto DontReload;

        for (i = 0; i < CIMLISTS; i++)
        {
            if ((!pimlCache->arhiml[i]) || (cr3D != pimlCache->cr3D) ||
                (fSmallIcons != pimlCache->fSmallIcons) || (bUseClassicGlyphs != pimlCache->fUseClassicGlyphs))
            {
                TraceMsg(DM_ITBAR, "_LoadToolbarGlyphs: Loading New Images");

                if (pimlCache->arhimlPendingDelete[i])
                    ImageList_Destroy(pimlCache->arhimlPendingDelete[i]);

                pimlCache->arhimlPendingDelete[i] = pimlCache->arhiml[i];

                pimlCache->arhiml[i] = _LoadThemedToolbarGlyphs(idBmpType, i, cx, crMask, uFlags, bUseClassicGlyphs, hInst);

                if (pimlCache->arhiml[i])
                {
                    // add shell glyphs
                    int idShellBmp = iBitmapBaseIndex + idBmpType;
                    hBMP = (HBITMAP) LoadImage (hInst, MAKEINTRESOURCE(idShellBmp + i), IMAGE_BITMAP,
                                      0, 0, uFlags);

                    ImageList_AddMasked(pimlCache->arhiml[i], (HBITMAP)hBMP, crMask);

                    DeleteObject(hBMP);
                }
            }
        }
        pimlCache->cr3D = cr3D;
        pimlCache->fSmallIcons = fSmallIcons;
        pimlCache->fUseClassicGlyphs = bUseClassicGlyphs;
DontReload:
        LEAVECRITICAL;
    }

    if (hwnd)
    {
        ASSERT(IS_VALID_HANDLE(hwnd, WND));

        for (i = 0; i < CIMLISTS; i++)
        {
            SendMessage(hwnd, uMsg, 0, (LPARAM) pimlCache->arhiml[i]);

            // set uMsg and uFlags for last iteration of loop (hot state)
            uMsg = TB_SETHOTIMAGELIST;
            uFlags = 0;
        }
    }
}

#ifdef THEME_BUTTONS
BOOL _GetThemeSetting(HKEY hkey, PDWORD pdwSetting)
{
    ASSERT(pdwSetting);
    BOOL fRet = FALSE;
    DWORD dwType, dwcbData = sizeof(*pdwSetting);
    *pdwSetting = 0;
    if (ERROR_SUCCESS==SHGetValue(hkey, 
                                  c_szRegKeyCoolbar, TEXT("UseTheme"), &dwType, pdwSetting, &dwcbData))
    {
        // We going to assume that the data type and size is correct. This way, we can break
        // into an error state.
        fRet = TRUE;
        // Acceptable values:
        // 0: use IE6 icons
        // 1: use IE5.5 icons
        // 2: use themed icons
        // other values are reserved.
        if (*pdwSetting > 2)
        {
            *pdwSetting = 0;
        }
    }
    return fRet;
}


HIMAGELIST _LoadThemedToolbarGlyphs(int idBmpType, int iTemperature, int cx, COLORREF crMask,
                                    UINT uFlags, BOOL bUseClassicGlyphs, HINSTANCE hInst)
{
    HIMAGELIST himl = NULL;
    // Restriction goes here.

    HKEY hkey = HKEY_CURRENT_USER;
    DWORD dwSetting = 0;
    if (!_GetThemeSetting(hkey, &dwSetting))
    {
        hkey = HKEY_LOCAL_MACHINE;
        _GetThemeSetting(hkey, &dwSetting);
    }

    DWORD dwType, dwcbData;
    if (dwSetting==2)
    {
        TCHAR szPath[MAX_PATH];
        TCHAR szItem[] = TEXT("ITBx");
        szItem[3] = TEXT('0') + idBmpType + iTemperature;

        dwcbData = sizeof(szPath);
        if ((ERROR_SUCCESS==SHGetValue(hkey, 
                                       c_szRegKeyCoolbar, szItem, &dwType, szPath, &dwcbData))
            && (dwType==REG_SZ))
        {
            int nBmpIndex = PathParseIconLocation(szPath);

            WCHAR szExpPath[MAX_PATH];
            SHExpandEnvironmentStrings(szPath, szExpPath, ARRAYSIZE(szExpPath));

            // If no resource id, assume it's a bmp file
            if (nBmpIndex==0)
            {
                himl = CreateImageList(NULL,
                                       szExpPath, cx, 0, crMask,
                                       IMAGE_BITMAP, uFlags | LR_LOADFROMFILE,
                                       !bUseClassicGlyphs);
            }

            // Otherwise, see if it's a resouce
            if (!himl)
            {
                HINSTANCE hInst = LoadLibraryEx(szExpPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
                if (hInst)
                {
                    himl = CreateImageList(hInst,
                                           MAKEINTRESOURCE(nBmpIndex), cx, 0, crMask,
                                           IMAGE_BITMAP, uFlags, !bUseClassicGlyphs);
                    FreeLibrary(hInst);
                }
            }

            if (himl)
            {
                // You just can't trust anyone these days. If the graphics aren't the expected 
                // size, or there aren't the expected number, we're going to use the defaults

                // ISSUE: 16 is a magic number. Do we have a constant anywhere? I can't find it.
                int ecx, ecy;
                if (!(ImageList_GetIconSize(himl, &ecx, &ecy)
                    && (ecx==ecy)
                    && (ecy==cx)
                    && (ImageList_GetImageCount(himl)==16)))
                {
                    ImageList_Destroy(himl);
                    himl = NULL;
                }
            }
        }
    }

    if (!himl)
    {
        // dwSetting must be 1 to get IE6 icons. If dwSetting isn't set to 1, then default
        // either to the new Whistler icons or the default IE icons (as appropriate)
        int iResource;

        if (dwSetting == 1)
        {
            iResource = IDB_IE6_TOOLBAR;
        }
        else
        {
            if (bUseClassicGlyphs)
            {
                iResource = IDB_IETOOLBAR;
            }
            else
            {
                iResource = IDB_TB_IE_BASE;
            }
        }

        iResource += (idBmpType + iTemperature);

        himl = CreateImageList(hInst,
                               MAKEINTRESOURCE(iResource), cx, 0, crMask,
                               IMAGE_BITMAP, uFlags, !bUseClassicGlyphs);
    }
    return himl;
}

#else
HIMAGELIST _LoadThemedToolbarGlyphs(int idBmpType, int iTemperature, int cx, COLORREF crMask,
                                    UINT uFlags, BOOL bUseClassicGlyphs, HINSTANCE hInst)
{
    HIMAGELIST himl = NULL;
    int iResource;
    if (bUseClassicGlyphs)
    {
        iResource = IDB_IETOOLBAR;
    }
    else
    {
        iResource = IDB_TB_IE_BASE;
    }
    iResource += (idBmpType + iTemperature);

    himl = CreateImageList(hInst,
                           MAKEINTRESOURCE(iResource), cx, 0, crMask,
                           IMAGE_BITMAP, uFlags, !bUseClassicGlyphs);
    return himl;
}

#endif

void CInternetToolbar::_InitBitmapDSA()
{
    DSA_Destroy(_hdsaTBBMPs);
    _hdsaTBBMPs = DSA_Create(sizeof(TBBMP_LIST), TBBMPLIST_CHUNK);

    if (_hdsaTBBMPs)
    {
        TBBMP_LIST tbl = { HINST_COMMCTRL, 0, 0, TRUE, TRUE, FALSE };

        tbl.uiResID = IDB_STD_SMALL_COLOR;
        tbl.uiOffset = OFFSET_STD;
        DSA_AppendItem(_hdsaTBBMPs, &tbl);
        tbl.uiResID = IDB_STD_LARGE_COLOR;
        DSA_AppendItem(_hdsaTBBMPs, &tbl);

        tbl.uiResID = IDB_VIEW_SMALL_COLOR;
        tbl.uiOffset = OFFSET_VIEW;
        DSA_AppendItem(_hdsaTBBMPs, &tbl);
        tbl.uiResID = IDB_VIEW_LARGE_COLOR;
        DSA_AppendItem(_hdsaTBBMPs, &tbl);

        tbl.uiResID = IDB_HIST_SMALL_COLOR;
        tbl.uiOffset = OFFSET_HIST;
        DSA_AppendItem(_hdsaTBBMPs, &tbl);
        tbl.uiResID = IDB_HIST_LARGE_COLOR;
        DSA_AppendItem(_hdsaTBBMPs, &tbl);
    }
}


void CInternetToolbar::_ReloadBitmapDSA()
{
    if (_hdsaTBBMPs)
    {
        TBBMP_LIST * pTBBs = NULL;
        int nCount = DSA_GetItemCount(_hdsaTBBMPs);
        // We want to skip the first 6 entries in the DSA, which are added by InitBitmapDSA
        for (int nIndex = 6; nIndex < nCount; nIndex++)
        {
            pTBBs = (TBBMP_LIST*)DSA_GetItemPtr(_hdsaTBBMPs, nIndex);
            if (pTBBs)
            {
                HIMAGELIST himl = NULL;
                if (pTBBs->fNormal)
                {
                    himl = (HIMAGELIST)SendMessage(_btb._hwnd, TB_GETIMAGELIST, 0, 0L);
                    if (himl
                        && (pTBBs->uiOffset==ImageList_GetImageCount(himl)))
                    {
                        LRESULT lOffset = _AddBitmapFromForeignModule(TB_GETIMAGELIST, TB_SETIMAGELIST, pTBBs->uiCount, pTBBs->hInst, pTBBs->uiResID, RGB(192,192,192));
                        ASSERT(pTBBs->uiOffset==lOffset);
                    }
                }
                if (pTBBs->fHot)
                {
                    himl = (HIMAGELIST)SendMessage(_btb._hwnd, TB_GETHOTIMAGELIST, 0, 0L);
                    if (himl
                        && (pTBBs->uiOffset==ImageList_GetImageCount(himl)))
                    {
                        LRESULT lOffset = _AddBitmapFromForeignModule(TB_GETHOTIMAGELIST, TB_SETHOTIMAGELIST, pTBBs->uiCount, pTBBs->hInst, pTBBs->uiResID, RGB(192,192,192));
                        ASSERT(pTBBs->uiOffset==lOffset);
                    }
                }
                if (pTBBs->fDisabled)
                {
                    himl = (HIMAGELIST)SendMessage(_btb._hwnd, TB_GETDISABLEDIMAGELIST, 0, 0L);
                    if (himl
                        && (pTBBs->uiOffset==ImageList_GetImageCount(himl)))
                    {
                        LRESULT lOffset = _AddBitmapFromForeignModule(TB_GETDISABLEDIMAGELIST, TB_SETDISABLEDIMAGELIST, pTBBs->uiCount, pTBBs->hInst, pTBBs->uiResID, RGB(192,192,192));
                        ASSERT(pTBBs->uiOffset==lOffset);
                    }
                }
            }
        }
    }
}


void CInternetToolbar::_InitForScreenSize()
{
    TCHAR szScratch[16];
    if (GetSystemMetrics(SM_CXSCREEN) < 650) 
    {
        MLLoadString(IDS_TB_WIDTH_EXTRA_LORES, szScratch, ARRAYSIZE(szScratch));
        _uiMaxTBWidth = MAX_TB_WIDTH_LORES;
    } 
    else 
    {
        MLLoadString(IDS_TB_WIDTH_EXTRA_HIRES, szScratch, ARRAYSIZE(szScratch));
        _uiMaxTBWidth = MAX_TB_WIDTH_HIRES;
    }
    _uiMaxTBWidth += StrToInt(szScratch) * WIDTH_FACTOR;
}


// removes all buttons marked hidden.  returns the number
// of buttons left
int RemoveHiddenButtons(TBBUTTON* ptbn, int iCount)
{
    int i;
    int iTotal = 0;
    TBBUTTON* ptbn1 = ptbn;
    for (i = 0; i < iCount; i++, ptbn1++) 
    {
        if (!(ptbn1->fsState & TBSTATE_HIDDEN)) 
        {
            if (ptbn1 != ptbn) 
            {
                *ptbn = *ptbn1;
            }
            ptbn++;
            iTotal++;
        }
    }
    return iTotal;
}

#ifdef DEBUG
void _AssertRestrictionOrderIsCorrect()
{
    COMPILETIME_ASSERT(ARRAYSIZE(c_tbExplorer) == ARRAYSIZE(c_rest));

    for (UINT i = 0; i < ARRAYSIZE(c_tbExplorer); i++)
    {
        // If any of these rip, it means that c_rest and c_tbExplorer have
        // gotten out of sync.  Need to fix up c_rest to match c_tbExplorer.
        switch (c_tbExplorer[i].idCommand)
        {
            case TBIDM_BACK:            ASSERT(c_rest[i] == REST_BTN_BACK);         break;
            case TBIDM_FORWARD:         ASSERT(c_rest[i] == REST_BTN_FORWARD);      break;
            case TBIDM_STOPDOWNLOAD:    ASSERT(c_rest[i] == REST_BTN_STOPDOWNLOAD); break;
            case TBIDM_REFRESH:         ASSERT(c_rest[i] == REST_BTN_REFRESH);      break;
            case TBIDM_HOME:            ASSERT(c_rest[i] == REST_BTN_HOME);         break;
            case TBIDM_SEARCH:          ASSERT(c_rest[i] == REST_BTN_SEARCH);       break;
            case TBIDM_HISTORY:         ASSERT(c_rest[i] == REST_BTN_HISTORY);      break;
            case TBIDM_FAVORITES:       ASSERT(c_rest[i] == REST_BTN_FAVORITES);    break;
            case TBIDM_ALLFOLDERS:      ASSERT(c_rest[i] == REST_BTN_ALLFOLDERS);   break;
            case TBIDM_THEATER:         ASSERT(c_rest[i] == REST_BTN_THEATER);      break;
            case TBIDM_MEDIABAR:        ASSERT(c_rest[i] == REST_BTN_MEDIABAR);     break;
            default:                    ASSERT(c_rest[i] == REST_BROWSER_NONE);     break;
        }
    }
}
#endif

__inline BOOL CInternetToolbar::_FoldersButtonAvailable()
{
    return (GetUIVersion() >= 4);
}

void CInternetToolbar::_AdminMarkDefaultButtons(PTBBUTTON ptbb, UINT cButtons)
{
    // We only have policies for web buttons.
    ASSERT(!_fShellView);

    // Caller should have checked this.
    ASSERT(SHRestricted2(REST_SPECIFYDEFAULTBUTTONS, NULL, 0));


    // SHRestricted2 returns 0 if it can't find the policy.  Assert that
    // this lines up with RESTOPT_BTN_STATE_DEFAULT.
    COMPILETIME_ASSERT(RESTOPT_BTN_STATE_DEFAULT == 0);

    for (UINT i = 0; i < cButtons; i++) 
    {
        if (c_rest[i] != 0)
        {
            DWORD dwRest = SHRestricted2(c_rest[i], NULL, 0);
            ptbb[i].fsState = SHBtnStateFromRestriction(dwRest, ptbb[i].fsState);
        }
    }

    // Folders button is not available on non-integrated platforms, so
    // set state to hidden even if policy specifies that it should be shown.
    ASSERT(c_tbExplorer[TBXID_ALLFOLDERS].idCommand == TBIDM_ALLFOLDERS);
    if (!_FoldersButtonAvailable())
        ptbb[TBXID_ALLFOLDERS].fsState |= TBSTATE_HIDDEN;
}

void CInternetToolbar::_MarkDefaultButtons(PTBBUTTON ptbb, UINT cButtons)
{
    if (SHRestricted(REST_NONLEGACYSHELLMODE))
    {
        ASSERT(ptbb[TBXID_BACK].idCommand == TBIDM_BACK);
        ptbb[TBXID_BACK].fsState |= TBSTATE_HIDDEN;
        ASSERT(ptbb[TBXID_FORWARD].idCommand == TBIDM_FORWARD);
        ptbb[TBXID_FORWARD].fsState |= TBSTATE_HIDDEN;
    }

    if (_fShellView) 
    {
        ASSERT(c_tbExplorer[TBXID_STOPDOWNLOAD].idCommand == TBIDM_STOPDOWNLOAD);
        ptbb[TBXID_STOPDOWNLOAD].fsState |= TBSTATE_HIDDEN;
        ASSERT(c_tbExplorer[TBXID_REFRESH].idCommand == TBIDM_REFRESH);
        ptbb[TBXID_REFRESH].fsState |= TBSTATE_HIDDEN;
        ASSERT(c_tbExplorer[TBXID_HOME].idCommand == TBIDM_HOME);
        ptbb[TBXID_HOME].fsState |= TBSTATE_HIDDEN;

        ASSERT(c_tbExplorer[TBXID_SEARCH].idCommand == TBIDM_SEARCH);
        ASSERT(c_tbExplorer[TBXID_HISTORY].idCommand == TBIDM_HISTORY);
        ASSERT(c_tbExplorer[TBXID_SEPARATOR2].idCommand == 0);    // (a separator)

        if (GetUIVersion() < 5) 
        {
            ptbb[TBXID_SEARCH].fsState |= TBSTATE_HIDDEN;
            ptbb[TBXID_HISTORY].fsState |= TBSTATE_HIDDEN;
            ptbb[TBXID_SEPARATOR2].fsState |= TBSTATE_HIDDEN;
        }
        else
        {
            if (GetUIVersion() > 5)
            {
                ptbb[TBXID_HISTORY].fsState |= TBSTATE_HIDDEN;
            }

            if (SHRestricted(REST_NOSHELLSEARCHBUTTON))
            {
                ptbb[TBXID_SEARCH].fsState |= TBSTATE_HIDDEN;
            }
            ASSERT(c_tbExplorer[TBXID_CONNECT].idCommand == TBIDM_CONNECT);
            ASSERT(c_tbExplorer[TBXID_DISCONNECT].idCommand == TBIDM_DISCONNECT);
            if (SHRestricted(REST_NONETCONNECTDISCONNECT))
            {
                ptbb[TBXID_CONNECT].fsState |= TBSTATE_HIDDEN;
                ptbb[TBXID_DISCONNECT].fsState |= TBSTATE_HIDDEN;
            }
        }

        ASSERT(c_tbExplorer[TBXID_FAVORITES].idCommand == TBIDM_FAVORITES);
        ptbb[TBXID_FAVORITES].fsState |= TBSTATE_HIDDEN;
    }

    ASSERT(c_tbExplorer[TBXID_PREVIOUSFOLDER].idCommand == TBIDM_PREVIOUSFOLDER);
    if (!_fShellView)
        ptbb[TBXID_PREVIOUSFOLDER].fsState |= TBSTATE_HIDDEN;

    ASSERT(c_tbExplorer[TBXID_CONNECT].idCommand == TBIDM_CONNECT);
    ASSERT(c_tbExplorer[TBXID_DISCONNECT].idCommand == TBIDM_DISCONNECT);
    if (!_fShellView || !_UseMapNetDrvBtns()) 
    {
        ptbb[TBXID_CONNECT].fsState |= TBSTATE_HIDDEN;
        ptbb[TBXID_DISCONNECT].fsState |= TBSTATE_HIDDEN;
    }

    // If this TBIDM_ALLFOLDERS assertion rips, remember to fix up _AdminMarkDefaultButtons too.
    ASSERT(c_tbExplorer[TBXID_ALLFOLDERS].idCommand == TBIDM_ALLFOLDERS);
    if (!_fShellView || GetUIVersion() < 5)
        ptbb[TBXID_ALLFOLDERS].fsState |= TBSTATE_HIDDEN;

    ASSERT(c_tbExplorer[TBXID_THEATER].idCommand == TBIDM_THEATER);
    ptbb[TBXID_THEATER].fsState |= TBSTATE_HIDDEN;

    ASSERT(c_tbExplorer[TBXID_MEDIABAR].idCommand == TBIDM_MEDIABAR);
    if (_fShellView || SHRestricted2W(REST_No_LaunchMediaBar, NULL, 0) || !CMediaBarUtil::IsWMP7OrGreaterCapable())
    {
        ptbb[TBXID_MEDIABAR].fsState |= TBSTATE_HIDDEN;
    }

    ASSERT(c_tbExplorer[TBXID_PREVIOUSFOLDER].idCommand == TBIDM_PREVIOUSFOLDER);
    if (!_fShellView) 
    {
        ptbb[TBXID_PREVIOUSFOLDER].fsState |= TBSTATE_HIDDEN;
    }
}

void CInternetToolbar::_AddCommonButtons()
{
    TBBUTTON  tbExplorer[ARRAYSIZE(c_tbExplorer)];

    memcpy(tbExplorer, c_tbExplorer, sizeof(TBBUTTON) * ARRAYSIZE(c_tbExplorer));

    if (IS_BIDI_LOCALIZED_SYSTEM())
    {
        if (!SHUseClassicToolbarGlyphs())
        {
            tbExplorer[0].iBitmap = 1;
            tbExplorer[1].iBitmap = 0;
        }
    }

    _MarkDefaultButtons(tbExplorer, ARRAYSIZE(c_tbExplorer));

#ifdef DEBUG
    _AssertRestrictionOrderIsCorrect();
#endif

    if (!_fShellView && SHRestricted2(REST_SPECIFYDEFAULTBUTTONS, NULL, 0))
        _AdminMarkDefaultButtons(tbExplorer, ARRAYSIZE(c_tbExplorer));

    int iButtons = RemoveHiddenButtons(tbExplorer, ARRAYSIZE(tbExplorer));

    for (int i = 0; i < iButtons; i++) 
    {
        if (!(tbExplorer[i].fsStyle & BTNS_SEP)) 
        {
            CMDMAP* pcm = (CMDMAP*)LocalAlloc(LPTR, sizeof(CMDMAP));
            if (pcm) 
            {
                pcm->guidButtonGroup = CLSID_CommonButtons;
                pcm->nCmdID = tbExplorer[i].idCommand;

                tbExplorer[i].idCommand = _btb._nNextCommandID++;
                tbExplorer[i].dwData = (LPARAM)pcm;
            }
        }
    }

    SendMessage(_btb._hwnd, TB_ADDBUTTONS, iButtons, (LPARAM) tbExplorer);

    _btb._RecalcButtonWidths();
}

#define IS_LIST_STYLE(hwnd) (BOOLIFY(GetWindowLong(hwnd, GWL_STYLE) & TBSTYLE_LIST))

void CInternetToolbar::_UpdateToolsStyle(BOOL fList)
{
    if (BOOLIFY(fList) != IS_LIST_STYLE(_btb._hwnd))
    {
        _fDirty = TRUE;

        // toggle TBSTYLE_LIST
        SHSetWindowBits(_btb._hwnd, GWL_STYLE, TBSTYLE_LIST, fList ? TBSTYLE_LIST : 0);
        // toggle TBSTYLE_EX_MIXEDBUTTONS
        SendMessage(_btb._hwnd, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_MIXEDBUTTONS, fList ? TBSTYLE_EX_MIXEDBUTTONS : 0);
    }
}

void CInternetToolbar::_InitToolbar()
{
    int nRows = _fCompressed ? 0 : _uiTBTextRows;
    DWORD dwStyle = TBSTYLE_EX_DRAWDDARROWS | TBSTYLE_EX_HIDECLIPPEDBUTTONS;

    if (IsOS(OS_WHISTLERORGREATER))
        dwStyle |= TBSTYLE_EX_DOUBLEBUFFER;

    // this tells the toolbar what version we are
    SendMessage(_btb._hwnd, TB_BUTTONSTRUCTSIZE,    sizeof(TBBUTTON), 0);
    SendMessage(_btb._hwnd, TB_SETEXTENDEDSTYLE, dwStyle, dwStyle);
    SendMessage(_btb._hwnd, TB_SETMAXTEXTROWS,      nRows, 0L);
    SendMessage(_btb._hwnd, TB_SETDROPDOWNGAP,  GetSystemMetrics(SM_CXEDGE) / 2, 0);
    SendMessage(_btb._hwnd, CCM_SETVERSION, COMCTL32_VERSION, 0);

    _UpdateToolsStyle(_cs.fList);
    _fDirty = FALSE; // _UpdateToolsStyle unfortunately sets this early on; but we can assume we're not dirty now.

    ITBar_LoadToolbarGlyphs(_btb._hwnd);
    _InitBitmapDSA();

    _InitForScreenSize();

    SendMessage(_btb._hwnd, TB_ADDSTRING, (WPARAM)MLGetHinst(), IDS_IE_TB_LABELS);

    _AddCommonButtons();

    INT_PTR nRet = SendMessage(_btb._hwnd, TB_ADDSTRING, (WPARAM)MLGetHinst(), IDS_SHELL_TB_LABELS);

#ifdef DEBUG
    if (nRet != SHELLTOOLBAR_OFFSET)
        TraceMsg(TF_ERROR, "CInternetToolbar::_InitToolbar -- nRet != SHELLTOOLBAR_OFFSET");
#endif
}

HRESULT CInternetToolbar::_ShowTools(PBANDSAVE pbs)
{
    HRESULT         hr  = S_OK;
    CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_TOOLS);

    if (!pbid)
    {
        ASSERT(!_btb._hwnd);

        _btb._hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                WS_CHILD | TBSTYLE_FLAT |
                                TBSTYLE_TOOLTIPS |
                                WS_CLIPCHILDREN |
                                WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                CCS_NORESIZE,
                                0, 0, 0, 0, _bs._hwnd, (HMENU) FCIDM_TOOLBAR, HINST_THISDLL, NULL);

        if (_btb._hwnd)
        {
            _InitToolbar();
            pbid = _AddNewBand((IDeskBand*)&_btb, CBIDX_TOOLS);
        }

        if (!pbid)
            return E_OUTOFMEMORY;
    }
    else
    {
        pbs = NULL;
    }

    _ShowBandCommon(pbs, pbid, _nVisibleBands & VBF_TOOLS);
    pbid->Release();
    return hr;
}

void CInternetToolbar::_ShowBandCommon(PBANDSAVE pbs, CBandItemData *pbid, BOOL fShow)
{
    REBARBANDINFO   rbbi;

    pbid->fShow = BOOLIFY(fShow);
    if (pbid->pdb)
    {
        pbid->pdb->ShowDW(pbid->fShow);
    }

    INT_PTR i = BandIDtoIndex(_bs._hwnd, pbid->dwBandID);

    if (pbs)
    {
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_SIZE | RBBIM_STYLE;

        // we just want to change the RBBS_BREAK bit
        // assert that our caller doesn't expect to set any other bits
        // ASSERT(!(pbs->fStyle & ~RBBS_BREAK)); <--- I hit this assert all the time

        // get old style
        SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM)&rbbi);

        rbbi.fStyle = (rbbi.fStyle & ~RBBS_BREAK) | (pbs->fStyle & RBBS_BREAK);
        rbbi.cx = pbs->cx;

        SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM)&rbbi);
    }


    if ( pbid->dwModeFlags & DBIMF_BREAK )
    {
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_STYLE;
        if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
        {
            // in theater mode we don't allow bands to have breaks
            if ((rbbi.fStyle & RBBS_BREAK ) && _fTheater)
            {
                rbbi.fStyle &= ~RBBS_BREAK;
                SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
            }
        }
    }

    SendMessage(_bs._hwnd, RB_SHOWBAND, i, pbid->fShow);
}


HRESULT CInternetToolbar::_GetPersistedBand(const CLSID clsid, REFIID riid, void ** ppiface)
{
    HRESULT hr  = E_FAIL;
    TCHAR szStreamName[MAX_PATH];

    if (SUCCEEDED(_GetStreamName(_fInitialPidlIsWeb, szStreamName, ARRAYSIZE(szStreamName))))
    {
        static BOOL fBrowserOnly = (WhichPlatform() != PLATFORM_INTEGRATED);
        TCHAR szKey[MAX_PATH];
        TCHAR szGUID[MAX_PATH];

        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar\\%s"), szStreamName);
        SHStringFromGUID(clsid, szGUID, ARRAYSIZE(szGUID));

        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, szKey, szGUID, NULL, NULL, NULL))
        {
            // Was the stream saved by an Integrated shell and we are in browser only mode?
            if ((_cs.fSaveInShellIntegrationMode) && fBrowserOnly)
            {
                // Yes, so we need to ignore the stream.
            }
            else
            {
                IStream * pstm = GetRegStream(_fInitialPidlIsWeb, szGUID, STGM_READ);
                if (pstm)
                {
                    hr = _bs.LoadFromStreamBS(pstm, riid, ppiface);
                    pstm->Release();
                }
            }
        }
    }

    if (FAILED(hr))
    {
        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, riid, ppiface);
        if (SUCCEEDED(hr))
        {
            IPersistStreamInit * ppsi;
            ((IUnknown *) *ppiface)->QueryInterface(IID_PPV_ARG(IPersistStreamInit, &ppsi));
            if (ppsi)
            {
                ppsi->InitNew();
                ppsi->Release();
            }
        }
    }

    return hr;
}


HRESULT CInternetToolbar::_ShowExternalBand( PBANDSAVE pbs, int idBand )
{
    HRESULT hr;
    if (IS_EXTERNALBAND(idBand))
    {
        int idBandExt = MAP_TO_EXTERNAL(idBand);

        if (!IsEqualCLSID(_rgebi[idBandExt].clsid, GUID_NULL))
        {
            CBandItemData *pbid = _bs._GetBandItemDataStructByID( idBand );
            BOOL fIsVisible = _nVisibleBands & EXTERNALBAND_VBF_BIT(idBandExt);
            if (!pbid && fIsVisible)
            {
                IDeskBand *pitbBand;
                hr = _GetPersistedBand(_rgebi[idBandExt].clsid, IID_PPV_ARG(IDeskBand, &pitbBand));
                if (SUCCEEDED(hr))
                {
                    pbid = _AddNewBand( pitbBand, idBand );
                    pitbBand->Release();
                }
                if (!pbid)
                    return E_OUTOFMEMORY;
            }
            else
            {
                pbs = NULL;
                if (!pbid)
                    return S_OK;
            }
            _ShowBandCommon(pbs, pbid, fIsVisible);
            pbid->Release();
        }
    }
    return S_OK;
}


HRESULT CInternetToolbar::_ShowAddressBand(PBANDSAVE pbs)
{
    HRESULT         hr  = S_OK;
    CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
    if (!pbid)
    {
       if (_nVisibleBands & VBF_ADDRESS)
       {
            IDeskBand *pitbAddressBand;

            hr = _GetPersistedBand(CLSID_AddressBand, IID_PPV_ARG(IDeskBand, &pitbAddressBand));
            if (SUCCEEDED(hr))
            {
                pbid = _AddNewBand(pitbAddressBand, CBIDX_ADDRESS);
                if (pbid)
                {
                    _hwndAddressBand = pbid->hwnd;

                    if (!pbs)
                    {
                        for (int i = 0; i < CBANDSMAX; i++)
                        {
                            if (_cs.bs[i].wID == CBIDX_ADDRESS)
                            {
                                pbs = _cs.bs + i;
                                break;
                            }
                        }
                    }
                }

                pitbAddressBand->Release();
            }
        }
        else
        {
            return S_OK;
        }

        if (!pbid)
            return E_OUTOFMEMORY;
    }
    else
        pbs = NULL;


    _ShowBandCommon(pbs, pbid, _nVisibleBands & VBF_ADDRESS);
    pbid->Release();
    return S_OK;
}

CBandItemData * CInternetToolbar::_AddNewBand(IDeskBand* pdb, DWORD dwID)
{
    if (SUCCEEDED(_bs._AddBandByID(pdb, dwID)))
    {
        return _bs._GetBandItemDataStructByID(dwID);
    }
    return NULL;
}


HRESULT CInternetToolbar::_ShowLinks(PBANDSAVE pbs)
{
    HRESULT hr = S_OK;

    CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_LINKS);
    if (!pbid)
    {
        IDeskBand* pdbLinks = NULL;

        // Check if custom link band GUID is present in the registry,
        // and if so, do a full CoCreateInstance using this GUID.
        // Otherwise, just do the normal internal call to the link's band factory.

        if (_nVisibleBands & VBF_LINKS)
        {
            if (!_fInitialPidlIsWeb ||
                FAILED(CreateFromRegKey(c_szRegKeyCoolbar, TEXT("QuickLinksCLSID"), IID_PPV_ARG(IDeskBand, &pdbLinks))))
            {
                hr = _GetPersistedBand(CLSID_QuickLinks, IID_PPV_ARG(IDeskBand, &pdbLinks));
                IUnknown_Exec(pdbLinks, &CLSID_QuickLinks, QLCMD_SINGLELINE, 1, NULL, NULL);
            }
        }
        else
        {
            return S_OK;
        }

        if (pdbLinks)
        {
            // mark it so ISFBand knows it's qlinks (for UAssist)
            VARIANTARG v;
#ifdef DEBUG
            {
                // n.b. we overwrite old persisted guys (which should be -1)
                IUnknown_Exec(pdbLinks, &CGID_ISFBand, ISFBID_PRIVATEID, 0, NULL, &v);
                ASSERT(v.lVal == -1 || v.lVal == CSIDL_FAVORITES);
            }
#endif
            v.vt = VT_I4;
            v.lVal = CSIDL_FAVORITES;   // close enough for our purposes...
            IUnknown_Exec(pdbLinks, &CGID_ISFBand, ISFBID_PRIVATEID, 0, &v, NULL);
            pbid = _AddNewBand(pdbLinks, CBIDX_LINKS);

            if (pbid && !pbs)
            {
                for (int i = 0; i < CBANDSMAX; i++)
                {
                    if (_cs.bs[i].wID == CBIDX_LINKS)
                    {
                        pbs = _cs.bs + i;
                        break;
                    }
                }
            }

            pdbLinks->Release();
        }

        if (!pbid)
            return E_OUTOFMEMORY;
    }
    else
        pbs = NULL;

    _ShowBandCommon(pbs, pbid, _nVisibleBands & VBF_LINKS);
    pbid->Release();

    return hr;
}

HRESULT CInternetToolbar::_ShowMenu(PBANDSAVE pbs)
{
    CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_MENU);
    if (!pbid)
    {
        CFavoritesCallback* pfcb = new CFavoritesCallback();
        if (pfcb)
        {
            IShellMenu* psm;
            if (SUCCEEDED(CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellMenu, &psm))))
            {
                VARIANTARG var;

                if (SUCCEEDED(IUnknown_Exec(_pbs2, &CGID_Explorer, SBCMDID_GETCURRENTMENU, 0, NULL, &var)) &&
                        var.vt == VT_INT_PTR && var.byref)
                {
                    IDeskBand* pdbMenu;
                    if (SUCCEEDED(psm->Initialize(pfcb, -1, ANCESTORDEFAULT, SMINIT_HORIZONTAL | SMINIT_TOPLEVEL)) &&
                        SUCCEEDED(psm->SetMenu((HMENU)var.byref, GetParent(_hwnd), SMSET_DONTOWN)) &&
                        SUCCEEDED(psm->QueryInterface(IID_PPV_ARG(IDeskBand, &pdbMenu))))
                    {
                        pbid = _AddNewBand(pdbMenu, CBIDX_MENU);
                        if (pbid)
                        {
                            // Tell the menuband we're not a real bar/bandsite/band
                            IUnknown_Exec(pbid->pdb, &CGID_MenuBand, MBANDCID_NOTAREALSITE, TRUE, NULL, NULL);

                            _bs.SetBandState(CBIDX_MENU, BSSF_NOTITLE, BSSF_NOTITLE);
                            _hwndMenu = pbid->hwnd;
                        }

                        pdbMenu->Release();
                    }
                }
                psm->Release();
            }
            pfcb->Release();
        }

        if (!pbid)
            return E_OUTOFMEMORY;
    }
    else
        pbs = NULL;


    _ShowBandCommon(pbs, pbid, _nVisibleBands & VBF_MENU);
    pbid->Release();
    return S_OK;
}

HBITMAP CInternetToolbar::_LoadBackBitmap()
{
    if (SHIsLowMemoryMachine(ILMM_IE4))
        return NULL;

    if (_fInitialPidlIsWeb)
    {
        static LPTSTR s_pszBitmapInternet = NULL;
        return LoadToolbarBackBmp(&s_pszBitmapInternet, &s_bmpBackInternet, _fInitialPidlIsWeb);
    }
    else
    {
        static LPTSTR s_pszBitmapShell = NULL;
        return LoadToolbarBackBmp(&s_pszBitmapShell, &s_bmpBackShell, _fInitialPidlIsWeb);
    }
}

void CInternetToolbar::_SetBackground()
{
    REBARBANDINFO   rbbi;
    HBITMAP         hbmp;

    // Theater mode doesn't allow bitmap customization, so don't bother loading one from the cache
    if (_fTheater)
        hbmp = NULL;
    else
        hbmp = _LoadBackBitmap();

    // don't bother updating the bkcolor if we know we'll just set it to CLR_NONE below (otherwise rebar invalidates)
    if (!hbmp)
        SendMessage(_bs._hwnd, RB_SETBKCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNFACE));

    // If we think we have a bitmap, or the cache thinks we have a bitmap, we have some work to do
    if (_bmpBack || hbmp)
    {
        BOOL fRemove = (NULL!=_bmpBack && NULL==hbmp);

        if (hbmp)
            SendMessage(_bs._hwnd, RB_SETBKCOLOR, 0, (LPARAM)CLR_NONE);
        _bmpBack = hbmp;

        rbbi.cbSize = sizeof(REBARBANDINFO);

        INT_PTR fRedraw = SendMessage(_bs._hwnd, WM_SETREDRAW, FALSE, 0);

        INT icBands = (INT) SendMessage( _bs._hwnd, RB_GETBANDCOUNT, 0, 0 );
        for (int i = 0; i < icBands; i++)
        {
            rbbi.fMask = RBBIM_ID | RBBIM_CHILD | RBBIM_BACKGROUND;
            if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
            {
                if (rbbi.wID != CBIDX_BRAND && rbbi.hbmBack != hbmp)
                {
                    rbbi.fMask = RBBIM_BACKGROUND;
                    rbbi.hbmBack = hbmp;
                    SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
                    InvalidateRect(rbbi.hwndChild, NULL, TRUE);
                }
            }
        }
        SendMessage(_bs._hwnd, WM_SETREDRAW, fRedraw, 0);

        // When removing the background bitmap, we need to invalidate *outside*
        // of the WM_SETREDRAW so we actually erase the background properly
        //
        if (fRemove)
            InvalidateRect(_bs._hwnd, NULL, TRUE);

    }
}


HRESULT CInternetToolbar::_ShowBrand(PBANDSAVE pbs)
{
    HRESULT hr = S_OK;
    BOOL fCreated = FALSE;

    CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_BRAND);
    if (!pbid)
    {
        IDeskBand *pdbBrandBand;
        hr = CBrandBand_CreateInstance(NULL, (IUnknown **)&pdbBrandBand, NULL);
        if (SUCCEEDED(hr))
        {
            pbid = _AddNewBand(pdbBrandBand, CBIDX_BRAND);
            fCreated = TRUE;
            pdbBrandBand->Release();
        }
        else
            return hr;
    }

    if (!pbid)
        return E_OUTOFMEMORY;

    pbid->pdb->ShowDW(TRUE);
    pbid->Release();

    INT_PTR i = BandIDtoIndex(_bs._hwnd, CBIDX_BRAND);
    if (fCreated)
    {
        REBARBANDINFO rbbi;
        // add these to ::IDeskBand::GetBandInfo()
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_STYLE;
        rbbi.fStyle = RBBS_FIXEDSIZE | RBBS_VARIABLEHEIGHT;

        if (pbs)
        {
            rbbi.fMask |= RBBIM_SIZE;
            rbbi.fStyle |= pbs->fStyle;
            rbbi.cx = pbs->cx;
        }
        SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM)&rbbi);
        // this can cause the band to move because a fixed size band
        // is forced in a particular location.
        // so we need to re-fetch the index
        i = BandIDtoIndex(_bs._hwnd, CBIDX_BRAND);
    }
    SendMessage(_bs._hwnd, RB_SHOWBAND, i, _nVisibleBands & VBF_BRAND);
    return S_OK;
}

void CInternetToolbar::_EnsureAllBandsShown()
{
    if (_hwnd)
    {
        INT_PTR fRedraw = SendMessage(_bs._hwnd, WM_SETREDRAW, FALSE, 0);

        _ShowMenu(NULL);
        _ShowTools(NULL);
        _ShowAddressBand(NULL);
        _ShowLinks(NULL);
        _ShowBrand(NULL);
        for (int i = CBIDX_EXTERNALFIRST; i <= CBIDX_EXTERNALLAST; i++)
        {
            _ShowExternalBand( NULL, i );
        }

        _SetBackground();
        _bs._SetMinDimensions();
        _UpdateLocking();
        
        SendMessage(_bs._hwnd, WM_SETREDRAW, fRedraw, 0);
    }
}

BOOL CInternetToolbar::_ShowBands(UINT fVisible)
{
    fVisible &= VBF_VALID;

    if (fVisible == _nVisibleBands)
        return(TRUE);

    _nVisibleBands = fVisible;
    _EnsureAllBandsShown();
    ShowDW(_fShow);

    return(TRUE);
}

HRESULT CInternetToolbar::_CreateBands()
{
    HRESULT hr = S_OK;

    if (!_hwnd && _ptbsite)
    {
        HWND hwndParent;

        hr = _ptbsite->GetWindow(&hwndParent);
        if (SUCCEEDED(hr))
        {
            TCHAR szScratch[16];
            int i;

            // Check if coolbar layout had already been loaded from the registry
            if(_cs.cbVer != CBS_VERSION)
            {
                TraceMsg(DM_ITBAR, "CInternetToolbar::_CreateBands failed. Bad Version");
                ASSERT(0);

                return(S_FALSE);
            }

            _nVisibleBands = _cs.uiVisible;

            _InitComCtl32();    // don't check result, if this fails our CreateWindows will fail

            MLLoadString(IDS_WEB_TB_TEXTROWS, szScratch, ARRAYSIZE(szScratch));
            _uiTBTextRows = _uiTBDefaultTextRows = StrToInt(szScratch);

            _fCompressed = (_cs.fNoText != FALSE);

            _hwnd = SHCreateWorkerWindow(SizableWndProc, hwndParent, 0, WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                                       (HMENU)FCIDM_REBAR, this);

            if (!IS_VALID_HANDLE(_hwnd, WND))
            {
                _fDontSave = TRUE;
                TraceMsg(TF_ERROR, "CInternetToolbar::_CreateBands() - _hwnd failed");
                return E_OUTOFMEMORY;
            }

            // delay until now
            // this sets up the parent child chain so that these children can
            // queryservice through us
            hr = SetClient(SAFECAST(&_bs, IInputObjectSite*));
            if (SUCCEEDED(hr))
            {
                INT_PTR fRedraw = SendMessage(_bs._hwnd, WM_SETREDRAW, FALSE, 0);

                for (i = 0; i < CBANDSMAX; i++)
                {
                    hr = S_OK;
                    switch (_cs.bs[i].wID)
                    {
                    case CBIDX_TOOLS:
                        if(!SHRestricted2W(REST_NoToolBar, NULL, 0))
                        {
                            hr = _ShowTools(_cs.bs + i);
                        }
                        else
                        {
                            _nVisibleBands &= ~VBF_TOOLS;
                        }
                        break;

                    case CBIDX_ADDRESS:
                        if(!SHRestricted2W(REST_NoAddressBar, NULL, 0))
                        {
                            hr = _ShowAddressBand(_cs.bs + i);
                        }
                        else
                        {
                            _nVisibleBands &= ~VBF_ADDRESS;
                        }
                        break;

                    case CBIDX_LINKS:
                        if(!SHRestricted2W(REST_NoLinksBar, NULL, 0))
                        {
                            hr = _ShowLinks(_cs.bs + i);
                        }
                        else
                        {
                            _nVisibleBands &= ~VBF_LINKS;
                        }
                        break;

                    case CBIDX_BRAND:
                        hr = _ShowBrand(_cs.bs + i);
                        break;

                    case CBIDX_MENU:
                        hr = _ShowMenu(_cs.bs + i);
                        break;

                    // If there is no id associated, there's nothing more to restore.
                    case 0:
                    {
                        // Out of bands; stop loop.
                        i = CBANDSMAX;
                        break;
                    }

                    default:
                        if (IS_EXTERNALBAND(_cs.bs[i].wID))
                        {
                            for (DWORD j = 0; j < MAXEXTERNALBANDS; j++)
                            {
                                if (_cs.aclsidExternalBands[MAP_TO_EXTERNAL(_cs.bs[i].wID)] == _rgebi[j].clsid)
                                {
                                    CLSID clsidTemp = _rgebi[j].clsid;
                                    _rgebi[j].clsid = _rgebi[MAP_TO_EXTERNAL(_cs.bs[i].wID)].clsid;
                                    _rgebi[MAP_TO_EXTERNAL(_cs.bs[i].wID)].clsid = clsidTemp;
                                    hr = _ShowExternalBand(_cs.bs + i, _cs.bs[i].wID);
                                    break;
                                }
                            }
                        }
                        break;
                    }

                    if (hr != S_OK)
                    {
                        TraceMsg(TF_ERROR, "CInternetToolbar::_CreateBands -- band ID %x creation failed", _cs.bs[i].wID);

                        // if band creation failed, we still go ahead and open the browser and do our normal stuff --
                        // including persisting the band state.
                        // unfortunately for the user who opens too many windows, they hit GDI limits and we can't
                        // create the bands and we fail, and then persist out that state.  so all future windows
                        // are broken without the file menu etc. and the user cant get out.
                        _fDontSave = TRUE;
                    }
                }

                _SetBackground();
                _bs._SetMinDimensions();
                _UpdateLocking();

                SendMessage(_bs._hwnd, WM_SETREDRAW, fRedraw, 0);
            }
        }
    }
    return hr;
}

HRESULT CInternetToolbar::ShowDW(BOOL fShow)
{
    if ((g_dwProfileCAP & 0x00000008) && s_imlTBGlyphs.arhiml[0])
    {
        StartCAP();
    }

    HRESULT hres = _CreateBands();
    if (FAILED(hres))
        return hres;

    if (!_nVisibleBands && fShow)
        return(FALSE);

    _fShow = fShow;

    _bs.UIActivateDBC(fShow ? DBC_SHOW : DBC_HIDE);

    ResizeBorderDW(NULL, NULL, FALSE);
    ShowWindow(_hwnd, fShow ? SW_SHOW : SW_HIDE);


    BOOL fConnect = (fShow && _dwcpCookie == 0);
    if (fConnect || (!fShow && _dwcpCookie != 0))
    {
        ConnectToConnectionPoint(SAFECAST(this, IDockingWindow*), DIID_DWebBrowserEvents2, fConnect, _pdie, &_dwcpCookie, NULL);
    }

    return hres;
}

int ITBar_TrackPopupMenuEx(HMENU hmenu, UINT uFlags, int x, int y, HWND hwnd, LPRECT prcExclude)
{
    TPMPARAMS tpm;
    if (prcExclude)
    {
        tpm.cbSize = sizeof(TPMPARAMS);
        CopyRect(&tpm.rcExclude, prcExclude);
    }
    return TrackPopupMenuEx(hmenu, uFlags, x, y, hwnd, prcExclude ? &tpm : NULL);
}

/*******************************************************************

NAME:       CInternetToolbar::_ShowBackForwardMenu

SYNOPSIS:
NOTES:
********************************************************************/
BOOL CInternetToolbar::_ShowBackForwardMenu(BOOL fForward, POINT pt, LPRECT prcExclude)
{
    BOOL fRet = FALSE;
    HMENU hmenuBF = CreatePopupMenu();
    if (hmenuBF)
    {
        ASSERT(_pbs2);
        ITravelLog *ptl;

        _pbs2->GetTravelLog(&ptl);
        if (NULL != ptl)
        {
            HRESULT hr;

            hr = ptl->InsertMenuEntries(_pbs2, hmenuBF, 0, 1, MAX_NAV_MENUITEMS, fForward ? TLMENUF_FORE : TLMENUF_BACK);
            if (S_OK == hr)
            {
                OLECMD cmd;

                cmd.cmdID = SBCMDID_HISTORYBAR;
                cmd.cmdf  = 0;

                ASSERT(NULL != _ptbsitect);
                _ptbsitect->QueryStatus(&CGID_Explorer, 1, &cmd, NULL);

                if (((cmd.cmdf & OLECMDF_ENABLED) && !(cmd.cmdf & OLECMDF_LATCHED)) &&
                    (1 /* MAX_NAV_MENUITEMS */ < ptl->CountEntries(_pbs2)))
                {
                    static TCHAR s_szMenuText[MAX_PATH];
                    static int   s_iMenuIcon = -1;

                    if (TEXT('\0') == s_szMenuText[0])
                    {
                        MLLoadString(IDS_MI_BACK_HISTORY, s_szMenuText, ARRAYSIZE(s_szMenuText));
                        ASSERT(TEXT('\0') != s_szMenuText[0]);
                    }

                    if (-1 == s_iMenuIcon)
                    {
                        IShellFolder  *psfParent;
                        LPITEMIDLIST  pidlHistory;
                        LPCITEMIDLIST pidlItem;

                        psfParent   = NULL;
                        pidlHistory = NULL;
                        pidlItem    = NULL;

                        SHGetSpecialFolderLocation(NULL, CSIDL_HISTORY, &pidlHistory);
                        if (NULL != pidlHistory)
                        {
                            SHBindToIDListParent(pidlHistory, IID_PPV_ARG(IShellFolder, &psfParent), &pidlItem);
                            if (NULL != psfParent)
                            {
                                ASSERT(NULL != pidlItem);

                                hr = SHMapPIDLToSystemImageListIndex(psfParent, pidlItem, &s_iMenuIcon);
                                if (FAILED(hr))
                                    s_iMenuIcon = -1;

                                psfParent->Release();
                            }

                            ILFree(pidlHistory);
                        }
                    }

                    ULONG_PTR rgpData[2];

                    rgpData[0] = (ULONG_PTR)s_szMenuText;
                    rgpData[1] = s_iMenuIcon;

                    AppendMenu(hmenuBF, MF_SEPARATOR, -1, NULL);
                    AppendMenu(hmenuBF, MF_OWNERDRAW, FCIDM_VBBHISTORYBAND, (PCTSTR)rgpData);
                }

                // If any menu items were added, show the menu and navigate to it
#ifndef MAINWIN
                int nIndex;

                if (nIndex = ITBar_TrackPopupMenuEx (hmenuBF, TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_RETURNCMD, pt.x, pt.y, _hwnd, prcExclude))
#else
                    // Because mainwin doesn't support win95 look and feel we are
                    // having a problem to keep the popup from dismissing when we
                    // pass NULL as noDismissal area.
                    RECT rect;
                    GetWindowRect( _hwnd, &rect );
                    if (nIndex = (int)TrackPopupMenu (hmenuBF,
                        TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                        pt.x, pt.y, 0, _hwnd,
                        &rect))
#endif
                {
                    if (FCIDM_VBBHISTORYBAND != nIndex)
                    {
                        ptl->Travel(_pbs2, (fForward ? nIndex : -nIndex));
                    }
                    else
                    {
                        VARIANTARG varOn;

                        varOn.vt   = VT_I4;
                        varOn.lVal = 1;

                        _ptbsitect->Exec(&CGID_Explorer, SBCMDID_HISTORYBAR, OLECMDEXECOPT_DONTPROMPTUSER, &varOn, NULL);
                    }
                }
            }

            ptl->Release();
        }

        DestroyMenu (hmenuBF);
    }

    return fRet;
}

// get per folder search items and default search
BOOL CInternetToolbar::_GetFolderSearchData()
{
    int iInserted=0;

    if (_pbs2)
    {
        LPCBASEBROWSERDATA pbbd;

        if (SUCCEEDED(_pbs2->GetBaseBrowserData(&pbbd)) && (pbbd->_psfPending || pbbd->_psf))
        {
            IShellFolder2 * psf2;
            IShellFolder*   psf = pbbd->_psfPending ? pbbd->_psfPending : pbbd->_psf;

            if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
            {
                LPENUMEXTRASEARCH penum;
                GUID              guid;

                if (SUCCEEDED(psf2->GetDefaultSearchGUID(&guid)))
                    _guidDefaultSearch = guid;

                // get per folder search items
                if (_hdpaFSI && SUCCEEDED(psf2->EnumSearches(&penum)))
                {
                    EXTRASEARCH  xs;

                    while(penum->Next(1, &xs, NULL) == S_OK)
                    {
                        LPFOLDERSEARCHITEM pfsi = (LPFOLDERSEARCHITEM)LocalAlloc(LPTR, sizeof(FOLDERSEARCHITEM));
                        if (pfsi)
                        {
                            pfsi->idCmd = -1;
                            pfsi->guidSearch = xs.guidSearch;
                            StrCpyNW(pfsi->wszUrl, xs.wszUrl, ARRAYSIZE(pfsi->wszUrl));
                            StrCpyNW(pfsi->wszName, xs.wszFriendlyName, ARRAYSIZE(pfsi->wszName));

                            if (DPA_InsertPtr(_hdpaFSI, iInserted, pfsi) != -1)
                                iInserted++;
                            else
                                LocalFree(pfsi);
                        }
                    }
                    penum->Release();
                }
                psf2->Release();
            }
        }
    }

    return (iInserted > 0);
}

void RestrictItbarViewMenu(HMENU hmenu, IUnknown *punkBar )
{
    BOOL fIsRestricted = SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0);
    if (fIsRestricted)
    {
        _EnableMenuItem(hmenu, FCIDM_VIEWLINKS, FALSE);
        _EnableMenuItem(hmenu, FCIDM_VIEWMENU, FALSE);
        _EnableMenuItem(hmenu, FCIDM_VIEWADDRESS, FALSE);
        _EnableMenuItem(hmenu, FCIDM_VIEWTOOLS, FALSE);
    }

    for (int i = 0; i < MAXEXTERNALBANDS; i++)
    {
        OLECMD cmd = { CITIDM_VIEWEXTERNALBAND_FIRST + i, 0 };
        OLECMDTEXTV<MAX_EXTERNAL_BAND_NAME_LEN> cmdtv;
        OLECMDTEXT *pcmdText = &cmdtv;
        pcmdText->cmdtextf = OLECMDTEXTF_NAME;
        pcmdText->cwActual = 0;
        pcmdText->cwBuf = MAX_EXTERNAL_BAND_NAME_LEN;

        IUnknown_QueryStatus( punkBar, &CGID_PrivCITCommands, 1, &cmd, pcmdText );
        if (cmd.cmdf & OLECMDF_SUPPORTED)
        {
            DWORD dwMenuCommand = FCIDM_EXTERNALBANDS_FIRST + i;
            InsertMenu( hmenu, FCIDM_VIEWCONTEXTMENUSEP, MF_BYCOMMAND, dwMenuCommand, pcmdText->rgwz );
            if (cmd.cmdf & OLECMDF_ENABLED)
            {
                _CheckMenuItem( hmenu, dwMenuCommand, TRUE );
            }
            if (fIsRestricted)
            {
                _EnableMenuItem( hmenu, dwMenuCommand, FALSE );
            }
        }
    }
}

void CInternetToolbar::_ShowContextMenu(HWND hwnd, LPARAM lParam, LPRECT prcExclude)
{
    // Bail if this context menu doesn't correspond to a band (fixes NT5 #181899)
    POINT pt;
    int iIndex = _bs._ContextMenuHittest(lParam, &pt);
    int idBandActive = _bs._IndexToBandID(iIndex);
    if (!InRange(idBandActive, CBIDX_FIRST, CBANDSMAX))
        return;

    // Bail if we can't find the resource
    HMENU hmenuITB = LoadMenuPopup(MENU_ITOOLBAR);
    if (!hmenuITB)
        return;

    UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UICONTEXT, idBandActive == -1 ? UIBL_CTXTITBBKGND : UIBL_CTXTITBITEM);

    // Set the initial state of the menu
    _CheckMenuItem (hmenuITB, FCIDM_VIEWTOOLS, _nVisibleBands & VBF_TOOLS);
    _CheckMenuItem (hmenuITB, FCIDM_VIEWADDRESS, _nVisibleBands & VBF_ADDRESS);
    _CheckMenuItem (hmenuITB, FCIDM_VIEWLINKS, _nVisibleBands & VBF_LINKS);
    
    int cItemsBelowSep = 4;

    // only in theater mode can we autohide
    if (!_fTheater)
    {
        DeleteMenu(hmenuITB, FCIDM_VIEWAUTOHIDE, MF_BYCOMMAND);
        cItemsBelowSep--;
        if (_nVisibleBands & VBF_MENU || _fNoShowMenu)
            DeleteMenu(hmenuITB, FCIDM_VIEWMENU, MF_BYCOMMAND);
    }
    else
    {
        if (_fNoShowMenu)
            DeleteMenu(hmenuITB, FCIDM_VIEWMENU, MF_BYCOMMAND);
        DeleteMenu(hmenuITB, FCIDM_VIEWTOOLS, MF_BYCOMMAND);
        _CheckMenuItem (hmenuITB, FCIDM_VIEWAUTOHIDE, _fAutoHide);
        _CheckMenuItem (hmenuITB, FCIDM_VIEWMENU, _nVisibleBands & VBF_MENU);

    }

    if (_fTheater || SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0))
    {
        // No lock in theater mode or Windows Explorer
        DeleteMenu(hmenuITB, FCIDM_VIEWLOCKTOOLBAR, MF_BYCOMMAND);
    }
    else
    {
        _CheckMenuItem(hmenuITB, FCIDM_VIEWLOCKTOOLBAR, _fLockedToolbar);
    }

    // if it was done via the keyboard, but focus wasn't on the tools band,
    // then don't have customize menu option
    // or if click didn't happen on the band
    if (!(_btb._fCustomize && idBandActive == CBIDX_TOOLS))
    {
        DeleteMenu(hmenuITB, FCIDM_VIEWTOOLBARCUSTOMIZE, MF_BYCOMMAND);
        cItemsBelowSep--;
    }

    BOOL fGoButtonAvailable =
        WasOpenedAsBrowser(static_cast<IExplorerToolbar *>(this)) || (GetUIVersion() >= 5);

    // Only show the go button item when you click on the address bar
    if (idBandActive != CBIDX_ADDRESS || !fGoButtonAvailable)
    {
        DeleteMenu(hmenuITB, FCIDM_VIEWGOBUTTON, MF_BYCOMMAND);
        cItemsBelowSep--;
    }
    else
    {
        BOOL fShowGoButton = SHRegGetBoolUSValue(REGSTR_PATH_MAIN,
                                TEXT("ShowGoButton"), FALSE, /*default*/TRUE);
        _CheckMenuItem(hmenuITB, FCIDM_VIEWGOBUTTON, fShowGoButton);
    }

    if (_fTheater || _btb._fCustomize || SHRestricted2(REST_LOCKICONSIZE, NULL, 0))
    {
        DeleteMenu(hmenuITB, FCIDM_VIEWTEXTLABELS, MF_BYCOMMAND);
        cItemsBelowSep--;
    }
    else
    {
        // If customize is unavailable, then there's no way for the user to
        // turn list style on/off.  In this case we want toggling text labels
        // to work the way it did in IE4 -- that is, switch between "text on
        // all buttons" and "text on no buttons".  So, if we're in "selective
        // text on right" mode, we say that labels are turned off.  If the user
        // picks this menu option, we'll go into "text on all buttons" mode.

        BOOL fChecked = !_fCompressed && !IS_LIST_STYLE(_btb._hwnd);
        _CheckMenuItem(hmenuITB, FCIDM_VIEWTEXTLABELS, fChecked);
    }

    if (!cItemsBelowSep)
        DeleteMenu(hmenuITB, FCIDM_VIEWCONTEXTMENUSEP, MF_BYCOMMAND);

    RestrictItbarViewMenu(hmenuITB, SAFECAST( this, IOleCommandTarget* ) );
    ITBar_TrackPopupMenuEx(hmenuITB, TPM_LEFTBUTTON | TPM_RIGHTBUTTON, pt.x, pt.y, _hwnd, prcExclude);

    // HACK: since the ITBar isn't a real bar/bandsite, we have to
    // do this so any menuband that might be up can take back the
    // mouse capture.
    CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_MENU);
    if (pbid)
    {
        IUnknown_Exec(pbid->pdb, &CGID_MenuBand, MBANDCID_RECAPTURE, 0, NULL, NULL);
        pbid->Release();
    }

    DestroyMenu (hmenuITB);
}


BOOL _IsDocHostGUID(const GUID* pguid)
{
    // Dochost merges under one of two clsids, so have to check both
    BOOL fRet = IsEqualGUID(*pguid, CLSID_InternetButtons) ||
                IsEqualGUID(*pguid, CLSID_MSOButtons);
    return fRet;
}

void _PruneAmpersands(LPTSTR psz)
{
    //
    // Collapse double ampersands in the string to single
    // ampersands, and rip out single ampersands.  e.g.,
    //
    //  "AT&T" -> "ATT"
    //  "AT&&T" -> "AT&T"
    //
    // We need to do this to hack around the ToolTips control's
    // annoying prefix behavior.  When TTS_NOPREFIX is set
    // (which is true of itbar's), TT leaves prefix characters
    // alone completely.  However when it is not set, besides just
    // letting DrawText do it's prefix thing on the string, TT also
    // pre-processes the string using an analogous version of the
    // below function, collapsing double ampersands to single
    // ampersands and ripping out single ampersands.  This is so
    // that that if you use menu text (e.g. "&File") as a tooltip,
    // you won't get an underline.  Unfortunately, the side effect
    // is that you're in trouble if you really wanted an ampersand in
    // the title (e.g. "AT&&T"), since the preprocessing turns "AT&&T"
    // into "AT&T", which DrawText then renders with an underline.
    //
    // Thus we have to leave TTS_NOPREFIX set and mimic the DrawText
    // preprocessing ourselves.
    //

    if (psz)
    {
        LPTSTR pszOut = psz;
        BOOL fLastAmpSkipped = FALSE;

        while (*psz)
        {
            if (*psz == TEXT('&'))
            {
                if (fLastAmpSkipped)
                {
                    fLastAmpSkipped = FALSE;
                    *pszOut++ = *psz;
                }
                else
                {
                    fLastAmpSkipped = TRUE;
                }
            }
            else
            {
                *pszOut++ = *psz;
            }

            psz++;
        }

        *pszOut = TEXT('\0');
    }
}

void CInternetToolbar::_OnTooltipNeeded(LPTOOLTIPTEXT pnmTT)
{
    UINT uiCmd;
    GUID guid;

    ASSERT(pnmTT->hdr.hwndFrom == (HWND)SendMessage(_btb._hwnd, TB_GETTOOLTIPS, 0, 0));

    pnmTT->szText[0] = TEXT('\0');

    // Make sure tooltips don't filter out ampersands
    LONG lStyle = GetWindowLong(pnmTT->hdr.hwndFrom, GWL_STYLE);
    if (!IsFlagSet(lStyle, TTS_NOPREFIX))
    {
        SetWindowLong(pnmTT->hdr.hwndFrom, GWL_STYLE, lStyle | TTS_NOPREFIX);
    }


    if (SUCCEEDED(_btb._ConvertCmd(NULL, (UINT)pnmTT->hdr.idFrom, &guid, &uiCmd)))
    {
        if (IsEqualGUID(guid, CLSID_CommonButtons))
        {
            switch (uiCmd)
            {
            case TBIDM_FORWARD:
            case TBIDM_BACK:
                if (_ptbsite)
                {
                    IBrowserService *pbsvc;

                    if (SUCCEEDED(_ptbsite->QueryInterface(IID_PPV_ARG(IBrowserService, &pbsvc))))
                    {
                        // FEATURE raymondc - make ITravelLog UNICODE someday
                        ITravelLog *ptl;
                        pbsvc->GetTravelLog( &ptl );
                        if (ptl)
                        {
                            WCHAR szTemp[ARRAYSIZE(pnmTT->szText)];
                            if (uiCmd == TBIDM_BACK)
                                ptl->GetToolTipText(pbsvc, TLOG_BACK, 0, szTemp, ARRAYSIZE(szTemp));
                            else if (uiCmd == TBIDM_FORWARD)
                                ptl->GetToolTipText(pbsvc, TLOG_FORE, 0, szTemp, ARRAYSIZE(szTemp));

                            SHUnicodeToTChar(szTemp, pnmTT->szText, ARRAYSIZE(pnmTT->szText));

                            ptl->Release();
                        }
                        pbsvc->Release();
                    }
                }
            }
        }
        // Dochost merges under one of two clsids, so have to check both
        else if (_IsDocHostGUID(&guid))
        {
            if (uiCmd == DVIDM_EDITPAGE)
            {
                _aEditVerb.GetToolTip(pnmTT->szText, ARRAYSIZE(pnmTT->szText));
            }
            else
            {
                // If the button text is hidden or truncated, we use that text for the tooltip.
                TBBUTTONINFO tbbi = {0};
                tbbi.cbSize = sizeof(TBBUTTONINFO);
                tbbi.dwMask = TBIF_STYLE | TBIF_STATE;
                SendMessage(_btb._hwnd, TB_GETBUTTONINFO, pnmTT->hdr.idFrom, (LPARAM)&tbbi);

                if (_fCompressed || 
                    IS_LIST_STYLE(_btb._hwnd) && !(tbbi.fsStyle & BTNS_SHOWTEXT) ||
                    (tbbi.fsState & TBSTATE_ELLIPSES))
                {
                    //
                    // Get the button text and fix up the ampersands so that the
                    // tooltip will look right
                    //
                    UINT cch = (UINT)SendMessage(_btb._hwnd, TB_GETBUTTONTEXT, pnmTT->hdr.idFrom, NULL);
                    if (cch != 0 && cch < ARRAYSIZE(pnmTT->szText))
                    {
                        if (SendMessage(_btb._hwnd, TB_GETBUTTONTEXT, pnmTT->hdr.idFrom, (LPARAM)&pnmTT->szText))
                        {
                            _PruneAmpersands(pnmTT->szText);
                        }
                    }
                }
            }
        }
    }
}

LRESULT CInternetToolbar::_OnBeginDrag(NMREBAR *pnm)
{
    if (SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0) || _fLockedToolbar)
    {
        return 1;
    }

    if (_fTheater)
    {
        // if we're in theater mode, we do our own drag handling where we force
        // all  the mouse moves into the middle of the band, thereby disallowing
        // the user to make a multi line rebar
        SetCapture(_hwnd);
        SendMessage(_bs._hwnd, RB_BEGINDRAG, pnm->uBand, (LPARAM)-2);
        _fRebarDragging = TRUE;
        return 1;
    }
    return SHRestricted2(REST_NoToolbarOptions, NULL, 0);
}

LRESULT CInternetToolbar::_OnNotify(LPNMHDR pnmh)
{
    LRESULT lres = 0;
    if (!_pdie)
        return 0;

    if (pnmh->code == TTN_NEEDTEXT  && pnmh->hwndFrom == (HWND)SendMessage(_btb._hwnd, TB_GETTOOLTIPS, 0, 0))
    {
        _OnTooltipNeeded((LPTOOLTIPTEXT)pnmh);
        return 0;
    }

    if(_SendToToolband(pnmh->hwndFrom, WM_NOTIFY,0, (LPARAM)pnmh, &lres))
        return lres;

    switch (pnmh->idFrom)
    {
    case FCIDM_REBAR:
        switch (pnmh->code)
        {
        case RBN_BEGINDRAG:
            return _OnBeginDrag((NMREBAR*)pnmh);

        case RBN_HEIGHTCHANGE:
            ResizeBorderDW(NULL, NULL, FALSE);
            break;

        case RBN_CHILDSIZE:
        {
            // make the brand always take the full height
            NMREBARCHILDSIZE *pnm = (NMREBARCHILDSIZE*)pnmh;
            if (pnm->wID == CBIDX_BRAND)
            {
                pnm->rcChild.top = pnm->rcBand.top;
                pnm->rcChild.bottom = pnm->rcBand.bottom;
            }
            break;
        }

        case RBN_LAYOUTCHANGED:
            //Because the layout has changed, remember to save later!
            _fDirty = TRUE;
            _UpdateBrandSize();

            if (_ptbsitect)
                _ptbsitect->Exec(&CGID_ShellBrowser, FCIDM_PERSISTTOOLBAR, 0, NULL, NULL);
            break;

        case RBN_GETOBJECT:
        {
            NMOBJECTNOTIFY *pnmon = (NMOBJECTNOTIFY *)pnmh;
            if (IsEqualIID(*pnmon->piid, IID_IDropTarget))
            {
                HWND hwnd;

                switch (pnmon->iItem)
                {
                case CBIDX_MENU:
                case CBIDX_LINKS:
                {
                     CBandItemData *pbid = _bs._GetBandItemDataStructByID(pnmon->iItem);
                     if (pbid)
                     {
                         if (pbid->pdb)
                         {
                            pnmon->hResult = pbid->pdb->QueryInterface(IID_IDropTarget, (void**)&pnmon->pObject);
                         }
                         pbid->Release();
                     }
                     break;
                }

                case CBIDX_TOOLS:
                    hwnd = _btb._hwnd;
                    pnmon->hResult = (HRESULT)SendMessage(hwnd, TB_GETOBJECT,
                                        (WPARAM)&IID_IDropTarget, (LPARAM)&pnmon->pObject);
                    break;

                case CBIDX_ADDRESS:
                    if (_ptbsite)
                    {
                        pnmon->hResult = _ptbsite->QueryInterface(IID_IDropTarget, (void**)&pnmon->pObject);
                    }
                    break;
                }
            }
            ASSERT((SUCCEEDED(pnmon->hResult) && pnmon->pObject) ? (IS_VALID_CODE_PTR(pnmon->pObject, IUnknown)) : (pnmon->pObject == NULL));
            return TRUE;
        }

        case RBN_CHEVRONPUSHED:
        {
            LPNMREBARCHEVRON pnmch = (LPNMREBARCHEVRON) pnmh;
            if (pnmch->wID == CBIDX_TOOLS)
            {
                int idMenu = MENU_TBMENU;
                // this must be the tools band (not enumerated in bandsite)
                MapWindowPoints(pnmh->hwndFrom, HWND_DESKTOP, (LPPOINT)&pnmch->rc, 2);
                if (!_btb._fCustomize)
                    idMenu = 0;

                ToolbarMenu_Popup(_hwnd, &pnmch->rc, NULL, _btb._hwnd, idMenu, (DWORD)pnmch->lParamNM);
                return TRUE;
            }
            _bs._OnNotify(pnmh);
            break;
        }

        default:
            return _bs._OnNotify(pnmh);

        } // switch (pnmh->code)
        break;

    } // switch (pnmh->idFrom)
    return 0;
}



void CInternetToolbar::_CommonHandleFileSysChange(LONG lEvent, LPITEMIDLIST* ppidl)
{
    // stuff that needs to be done tree or no tree
    switch (lEvent)
    {
        // README:
        // If you need to add events here, then you must change SHELLBROWSER_FSNOTIFY_FLAGS in
        // shbrowse.cpp in order to get the notifications
    case SHCNE_DRIVEREMOVED:
    case SHCNE_MEDIAREMOVED:
    case SHCNE_MEDIAINSERTED:
    case SHCNE_DRIVEADD:
    case SHCNE_UPDATEIMAGE:
    case SHCNE_UPDATEITEM:
        // Forward this command to CAddressBand::FileSysChange()
        // by using IToolbandHelper::OnWinEvent().
        {
            CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
            if (pbid)
            {
                // REVIEW: why don't we use IShellChangeNotify here?
                //
                IUnknown_FileSysChange(pbid->pdb, (DWORD)lEvent, (LPCITEMIDLIST*)ppidl);
                pbid->Release();
            }
        }
        break;
    }
}

HRESULT CInternetToolbar::OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPITEMIDLIST ppidl[2] = {(LPITEMIDLIST)pidl1, (LPITEMIDLIST)pidl2};
    _CommonHandleFileSysChange(lEvent, ppidl);

    return S_OK;
}

void CInternetToolbar::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    if (!_pdie)
        return;

    HWND hwndControl = GET_WM_COMMAND_HWND(wParam, lParam);
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);

    // If this is a command from the toolbar, and it is not one of the StdBrowseButtons
    // call Exec() on the appropriate CmdTarget
    if (hwndControl == _btb._hwnd)
    {
        UINT uiInternalCmdID = idCmd;

        // Convert to the real thing and get the guid
        CMDMAP* pcm = _btb._GetCmdMapByID(idCmd);

        IOleCommandTarget* pct = _btb._CommandTargetFromCmdMap(pcm);
        if (pct)
        {
            VARIANTARG var;
            var.vt = VT_I4;
            var.lVal = uiInternalCmdID;
            if (SHIsSameObject(_btb._pctCurrentButtonGroup, pct))
            {
                // give the browser a chance to pick this off in case
                // focus doesn't belong to the view currently
                if (SUCCEEDED(_ptbsitect->Exec(&IID_IExplorerToolbar, pcm->nCmdID, 0, NULL, &var)))
                    return;
            }

            UEMFireEvent(&UEMIID_BROWSER, UEME_UITOOLBAR, UEMF_XEVENT,
                UIG_COMMON, (LPARAM)pcm->nCmdID);
            pct->Exec(&pcm->guidButtonGroup, (DWORD)pcm->nCmdID, 0, NULL, &var);
        }
        return;
    }

    if (_SendToToolband(hwndControl, WM_COMMAND, wParam, lParam, NULL))
        return;


    // this switch block actually executes
    switch(idCmd)
    {
    case FCIDM_VIEWTOOLBARCUSTOMIZE:
        ASSERT(!SHRestricted2(REST_NOTOOLBARCUSTOMIZE, NULL, 0));
        SendMessage (_btb._hwnd, TB_CUSTOMIZE, 0, 0L);
        break;

    case FCIDM_DRIVELIST:
        _SendToToolband(_hwndAddressBand, WM_COMMAND, wParam, lParam, NULL);
        break;

    case FCIDM_VIEWADDRESS:
    case FCIDM_VIEWTOOLS:
    case FCIDM_VIEWMENU:
    case FCIDM_VIEWLINKS:
        if (!SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0)
            && !SHRestricted2(REST_NoToolbarOptions, NULL, 0))
        {
            DWORD dw = _nVisibleBands;
            switch (idCmd)
            {
            case FCIDM_VIEWTOOLS:
                dw ^= VBF_TOOLS;
                break;
            case FCIDM_VIEWMENU:
                dw ^= VBF_MENU;
                break;
            case FCIDM_VIEWADDRESS:
                dw ^= VBF_ADDRESS;
                break;
            case FCIDM_VIEWLINKS:
                dw ^= VBF_LINKS;
                break;
            }
            if ( !( dw & ~VBF_BRAND))
            {
                _pdie->put_ToolBar( FALSE );
            }

            _ShowVisible(dw, TRUE);
        }
        return;

    case FCIDM_VIEWAUTOHIDE:
    {
        ASSERT(_fTheater);
        _fAutoHide = !_fAutoHide;

        VARIANTARG v = {0};
        v.vt = VT_I4;
        v.lVal = _fAutoHide;
        IUnknown_Exec(_ptbsite, &CGID_Theater, THID_SETTOOLBARAUTOHIDE, 0, &v, NULL);

        ResizeBorderDW(NULL, NULL, FALSE);

        break;
    }

    case FCIDM_VIEWLOCKTOOLBAR:
    {
        _fLockedToolbar = !_fLockedToolbar;
        DWORD dwResult = _fLockedToolbar;
        SHSetValue(HKEY_CURRENT_USER, c_szRegKeyCoolbar, TEXT("Locked"), REG_DWORD, &dwResult, sizeof(dwResult));
        _UpdateLocking();
        break;
    }

    case FCIDM_VIEWTEXTLABELS:
        if(!SHRestricted2(REST_NoToolbarOptions, NULL, 0))
        {
            if (!_btb._fCustomize && IS_LIST_STYLE(_btb._hwnd))
            {
                // If customize is unavailable, then there's no way for the user to
                // turn list style on/off.  In this case we want toggling text labels
                // to work the way it did in IE4 -- that is, switch between "text on
                // all buttons" and "text on no buttons".  So, if we're in "selective
                // text on right" mode, we say that labels are turned off.  If the user
                // picks this menu option, we'll go into "text on all buttons" mode.

                _UpdateToolsStyle(FALSE);

                // Make ourselves believe that text labels are turned off (so
                // that _UpdateToolbarDisplay will turn them on)

                _fCompressed = TRUE;
            }
            _UpdateToolbarDisplay(UTD_TEXTLABEL, 0, !_fCompressed, TRUE);
        }
        return;

    case FCIDM_VIEWGOBUTTON:
        _SendToToolband(_hwndAddressBand, WM_COMMAND, wParam, lParam, NULL);
        break;

    default:
        if (InRange( idCmd, FCIDM_EXTERNALBANDS_FIRST, FCIDM_EXTERNALBANDS_LAST ))
        {
            if (!SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0))
            {
                DWORD dw = _nVisibleBands;
                dw ^= EXTERNALBAND_VBF_BIT(idCmd - FCIDM_EXTERNALBANDS_FIRST);
                if ( !( dw & ~VBF_BRAND))
                {
                    _pdie->put_ToolBar( FALSE );
                }
                _ShowVisible(dw, TRUE);
            }
            return;
        }
        break;
    }
}

BOOL CInternetToolbar::_CompressBands(BOOL fCompress, UINT uRowsNew, BOOL fForceUpdate)
{
    UINT_PTR uRowsOld = SendMessage(_btb._hwnd, TB_GETTEXTROWS, 0, 0L);
    if (fCompress)
        uRowsNew = 0;

    if (!fForceUpdate && (uRowsOld == uRowsNew))
    {
        // same as what we've already got, blow it off
        return FALSE;
    }

    _fCompressed = fCompress;

    // Change the size of the Brand window and add ot remove the text
    SendMessage(_btb._hwnd, TB_SETMAXTEXTROWS, uRowsNew, 0L);

    UINT uWidthNew = _fCompressed ? MAX_TB_COMPRESSED_WIDTH : _uiMaxTBWidth;
    SendMessage(_btb._hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, uWidthNew));

    _btb._BandInfoChanged();

    _UpdateBrandSize();
    _bs._SetMinDimensions();

    return TRUE;
}

#define ABS(x)  (((x) < 0) ? -(x) : (x))

void CInternetToolbar::_TrackSliding(int x, int y)
{
    INT_PTR cBands    = SendMessage(_bs._hwnd, RB_GETBANDCOUNT, 0, 0L);
    INT_PTR cRows     = SendMessage(_bs._hwnd, RB_GETROWCOUNT, 0, 0L);
    INT_PTR cyHalfRow = SendMessage(_bs._hwnd, RB_GETROWHEIGHT, cBands-1, 0L) / 2;
    RECT rc;
    int cyBefore;
    int c;
    BOOL_PTR fChanged = FALSE;

    // do this instead of GetClientRect so that we include borders
    GetWindowRect(_bs._hwnd, &rc);
    MapWindowPoints(HWND_DESKTOP, _bs._hwnd, (LPPOINT)&rc, 2);
    cyBefore = rc.bottom - rc.top;

    c = y - _yCapture;
    rc.bottom = y;

    // was there enough change?
    if (ABS(c) <= cyHalfRow)
        return;

    if ((cRows == 1) || _fCompressed)
    {
        if (c < -cyHalfRow)
            fChanged = _CompressBands(TRUE, 0, FALSE);
        else
            fChanged = _CompressBands(FALSE, _uiTBTextRows, FALSE);

    }

    if (!fChanged)
    {
        // if the compressing bands didn't change anything, try to fit it to size
        fChanged = SendMessage(_bs._hwnd, RB_SIZETORECT, 0, (LPARAM)&rc);
    }


    // TODO: There is a drawing glitch when you resize from 3 bars (No Text) to 3 bars
    // with text. The _yCapture gets set to a value greater than y. So on the
    // next MOUSEMOVE it figures that the user moved up and switches from 3 bars with text
    // to 2 bars with text.
    if (fChanged)
    {
        _UpdateBrandSize();
        GetWindowRect(_bs._hwnd, &rc);
        _yCapture += (rc.bottom - rc.top) - cyBefore;
        _fDirty = TRUE; //Since the band layout changed, set the dirty bit ON.
        if (_ptbsitect)
            _ptbsitect->Exec(&CGID_ShellBrowser, FCIDM_PERSISTTOOLBAR, 0, NULL, NULL);
    }
}


void CInternetToolbar::_ShowVisible(DWORD dwVisibleBands, BOOL fPersist)
{
    // PERF (scotth): is this even necessary now that we have a
    //  menu band always showing?
    BOOL fShowInitial = (! (_nVisibleBands & ~VBF_BRAND));

    _UpdateToolbarDisplay(UTD_VISIBLE, dwVisibleBands, _fCompressed, fPersist);

    if (fShowInitial)
        _pdie->put_ToolBar(TRUE);
}


HRESULT CInternetToolbar::_UpdateToolbarDisplay(DWORD dwFlags, UINT uVisibleBands, BOOL fNoText, BOOL fPersist)
{
    _fDirty = TRUE;  //Since we are making changes, set the dirty bit!

    //Update the back bitmap
    _SetBackground();

    //Show the bands.
    if(dwFlags & UTD_VISIBLE)
        _ShowBands(uVisibleBands);

    //Show/Hide the text.
    if(dwFlags & UTD_TEXTLABEL)
        _CompressBands(fNoText, _uiTBTextRows, TRUE);

    _fDirty = TRUE;  //Since we are making changes, set the dirty bit!
    if (!_fTheater && fPersist && _ptbsitect)
        _ptbsitect->Exec(&CGID_ShellBrowser, FCIDM_PERSISTTOOLBAR, 0, NULL, NULL);

    return S_OK;
}

void CInternetToolbar::_UpdateBrandSize()
{
    CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_BRAND);
    if (pbid)
    {
        if (((_nVisibleBands & (VBF_TOOLS | VBF_BRAND)) == (VBF_TOOLS | VBF_BRAND)))
        {
            BOOL fMinAlways = _fCompressed;

            if (!fMinAlways)
            {
                INT_PTR iTools = BandIDtoIndex(_bs._hwnd, CBIDX_TOOLS);
                INT_PTR iBrand = BandIDtoIndex(_bs._hwnd, CBIDX_BRAND);

                if (iBrand < iTools && !_fTheater)
                    fMinAlways = TRUE;
            }

            VARIANTARG v = {0};
            v.vt = VT_I4;
            v.lVal = fMinAlways;
            IUnknown_Exec(pbid->pdb, &CGID_PrivCITCommands, CITIDM_BRANDSIZE, 0, &v, NULL);
        }
        pbid->Release();
    }
}

LRESULT CALLBACK CInternetToolbar::SizableWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CInternetToolbar* pitbar = (CInternetToolbar*)GetWindowPtr0(hwnd); // GetWindowLong(hwnd, 0)

    switch(uMsg)
    {
    case WM_SETCURSOR:
    {
        if (pitbar->_fLockedToolbar)
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            return TRUE;
        }

        if ((HWND)wParam == hwnd && LOWORD(lParam) == HTCLIENT && 
              !SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0)) 
        {
            SetCursor(LoadCursor(NULL, IDC_SIZENS));
            return TRUE;
        }
        goto DoDefault;
    }

    case WM_SYSCOLORCHANGE:
        //
        // BUG : 535039 - WM_SYSCOLORCHANGE messages dont have a valid wParam and lParam included
        // SHExplorerIniChange expects these to be NULLed out. If an app doesnt NULL these out, we crash in 
        // SHExplorerIniChange. Greater safety here.
        //
        wParam = 0;
        lParam = 0;

        //
        //  Fall through..
        //
        
    case WM_WININICHANGE:
        if (FALSE == pitbar->_fDestroyed)
        {
            DWORD dwSection = SHIsExplorerIniChange(wParam, lParam);

            BOOL fRebuild = (uMsg == WM_SYSCOLORCHANGE) ||
                            (dwSection == EICH_KWINEXPLSMICO) ||
                            (wParam == SPI_SETNONCLIENTMETRICS);

            if (fRebuild)
            {
                pitbar->_InitForScreenSize();
                ITBar_LoadToolbarGlyphs(pitbar->_btb._hwnd);
                pitbar->_ReloadBitmapDSA();
                pitbar->_SetSearchStuff();
                pitbar->_ReloadButtons();
                if (uMsg == WM_SYSCOLORCHANGE)
                {
                    pitbar->_RefreshEditGlyph();
                }
            }
            
            if (dwSection == EICH_KINET)
            {
                pitbar->_aEditVerb.InitDefaultEditor();
                pitbar->_UpdateEditButton();
            }

            SendMessage(pitbar->_bs._hwnd, uMsg, wParam, lParam);
            pitbar->_SendToToolband(HWND_BROADCAST, uMsg, wParam, lParam, NULL);

            if (fRebuild)
            {
                pitbar->_SetBackground();
                InvalidateRect(pitbar->_bs._hwnd, NULL, TRUE);
                pitbar->_bs._SetMinDimensions();
            }
        }
        break;

    case WM_LBUTTONDOWN:
        //            RelayToToolTips(prb->hwndToolTips, hwnd, wMsg, wParam, lParam);
        // Don't allow toolbar resizing in theater mode
        if (!pitbar->_fTheater && 
            !SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0) && 
            (!pitbar->_fLockedToolbar))
        {
            pitbar->_xCapture = GET_X_LPARAM(lParam);
            pitbar->_yCapture = GET_Y_LPARAM(lParam);
            SetCapture(hwnd);
        }
        break;

    case WM_MOUSEMOVE:
        //            RelayToToolTips(prb->hwndToolTips, hwnd, wMsg, wParam, lParam);

        if (pitbar->_yCapture != -1)
        {
            if (hwnd != GetCapture())
                pitbar->_yCapture = -1;
            else
                pitbar->_TrackSliding(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        }
        else if (pitbar->_fRebarDragging)
        {
            RECT rc;
            POINT pt;
            GetClientRect(pitbar->_bs._hwnd, &rc);
            GetCursorPos(&pt);
            MapWindowPoints(HWND_DESKTOP, pitbar->_bs._hwnd, &pt, 1);
            rc.bottom /= 2;
            if (pt.y > rc.bottom)
                pt.y = rc.bottom;
            SendMessage(pitbar->_bs._hwnd, RB_DRAGMOVE, 0, MAKELPARAM(pt.x, pt.y));
        }
        break;

    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
        //            RelayToToolTips(prb->hwndToolTips, hwnd, wMsg, wParam, lParam);

        pitbar->_yCapture = -1;
        if (pitbar->_fRebarDragging)
        {
            pitbar->_fRebarDragging = FALSE;
            SendMessage(pitbar->_bs._hwnd, RB_ENDDRAG, 0, 0);
        }
        if (GetCapture() == hwnd)
            ReleaseCapture();
        break;

    case WM_CONTEXTMENU:
        pitbar->_bs.OnWinEvent(pitbar->_hwnd, uMsg, wParam, lParam, NULL);
        break;

    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
        // We must swallow these messages to avoid infinit SendMessage
        break;

    case WM_NOTIFY:
        // We must swallow these messages to avoid infinit SendMessage
        return pitbar->_OnNotify((LPNMHDR)lParam);

    case WM_NOTIFYFORMAT:
        if (NF_QUERY == lParam)
            return (DLL_IS_UNICODE ? NFR_UNICODE : NFR_ANSI);
        break;

    case WM_COMMAND:
        pitbar->_OnCommand(wParam, lParam);
        break;

    case WM_ERASEBKGND:
        {
            HDC hdc = (HDC)wParam;
            RECT rc;
            GetClientRect(hwnd, &rc);
            SHFillRectClr(hdc, &rc, (pitbar->_fTheater) ? RGB(0,0,0) : GetSysColor(COLOR_3DFACE));
            break;
         }

    case WM_PALETTECHANGED:
        //
        // PERF: we could optimize this by realizing and checking the
        // return value
        //
        // for now we will just invalidate ourselves and all children...
        //
        RedrawWindow(hwnd, NULL, NULL,
                     RDW_INVALIDATE  | RDW_ERASE | RDW_ALLCHILDREN);
        break;

    case WM_MEASUREITEM:
    {
        PMEASUREITEMSTRUCT pmis;

        ASSERT(NULL != lParam);
        pmis = (PMEASUREITEMSTRUCT)lParam;

        switch (pmis->itemID)
        {
        case FCIDM_VBBHISTORYBAND:
            ASSERT(0 == wParam);
            {
                PULONG_PTR pData = (PULONG_PTR)pmis->itemData;
                ASSERT(NULL != pData);
                MeasureMenuItem(pmis, (PCTSTR)pData[0]);
            }
            break;

        default:
            goto DoDefault;
        }
        break;
    }

    case WM_DRAWITEM:
    {
        PDRAWITEMSTRUCT pdis;

        ASSERT(NULL != lParam);
        pdis = (PDRAWITEMSTRUCT)lParam;

        switch (pdis->itemID)
        {
        case FCIDM_VBBHISTORYBAND:
            ASSERT(0 == wParam);
            {
                PULONG_PTR pData = (PULONG_PTR)pdis->itemData;
                ASSERT(NULL != pData);
                DrawMenuItem(pdis, (PCTSTR)pData[0], (UINT) pData[1]);
            }
            break;

        default:
            goto DoDefault;
        }
        break;
    }

    case WM_MENUCHAR:
        if (MF_POPUP == HIWORD(wParam))
        {
            MENUITEMINFO mii = { 0 };

            mii.cbSize = sizeof(mii);
            mii.fMask  = MIIM_DATA | MIIM_TYPE;
            GetMenuItemInfo((HMENU)lParam, FCIDM_VBBHISTORYBAND, FALSE, &mii);

            if (TEXT('h') == LOWORD(wParam) || TEXT('H') == LOWORD(wParam))
            {
                return MAKELRESULT(FCIDM_VBBHISTORYBAND, MNC_EXECUTE);
            }
        }
        break;

    case WM_TIMER:
        switch (wParam)
        {
        case IDT_UPDATETOOLBAR:
            pitbar->_fUpdateToolbarTimer = FALSE;
            KillTimer(hwnd, wParam);
            if (pitbar->_fNeedUpdateToolbar)
                pitbar->_UpdateToolbarNow();
            break;
        }
        break;

    case WM_DESTROY:
        pitbar->_Unadvise(); // remove ref-loop with _pdie
        TraceMsg(DM_TBREF, "CInternetToolbar::SizableWndProc() - Called RemoveProp. Called Release new _cRef=%d", pitbar->_cRef);
        goto DoDefault;

DoDefault:
    default:
        return(DefWindowProcWrap(hwnd, uMsg, wParam, lParam));
    }

    return 0L;
}


HRESULT CInternetToolbar::ResizeBorderDW(LPCRECT prcBorder,
                                         IUnknown* punkToolbarSite,
                                         BOOL fReserved)
{
    TraceMsg(DM_LAYOUT, "CITB::ResizeBorderDW called (_fShow==%d)", _fShow);
    HRESULT hres = S_OK;

    ASSERT(_ptbsite);
    if (_ptbsite)
    {
        RECT rcRequest = { 0, 0, 0, 0 };

        if (_fShow)
        {
            RECT rcRebar, rcBorder;
            int  cx,cy;

            GetWindowRect(_bs._hwnd, &rcRebar);
            cx = rcRebar.right - rcRebar.left;
            cy = rcRebar.bottom - rcRebar.top;

            int iExtra = 3;
            if (_fTheater)
            {
                // 1 for the 1 pixel border on the bottom
                iExtra = 1;
            }
            else if (_fLockedToolbar)
            {
                iExtra = 0;
            }

            TraceMsg(DM_LAYOUT, "CITB::ResizeBorderDW cy = %d", cy);

            if (!prcBorder)
            {
                _ptbsite->GetBorderDW(SAFECAST(this, IDockingWindow*), &rcBorder);
                prcBorder = &rcBorder;
            }

            cx = prcBorder->right - prcBorder->left;


            SetWindowPos(_bs._hwnd, NULL, 0, 0,
                         cx, cy,  SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE);

            GetWindowRect(_bs._hwnd, &rcRebar);


            rcRequest.top = rcRebar.bottom - rcRebar.top + iExtra;
            SetWindowPos(_hwnd, NULL, prcBorder->left, prcBorder->top,
                         rcRebar.right - rcRebar.left, rcRequest.top, SWP_NOZORDER | SWP_NOACTIVATE);
        }

        if (_fTheater && _fAutoHide)
        {
            // if we're in theater mode, then we should request no space
            rcRequest.left = rcRequest.top = 0;
        }

        TraceMsg(DM_LAYOUT, "CITB::ResizeBorderDW calling RequstBS with %d,%d,%d,%d",
                 rcRequest.left, rcRequest.top, rcRequest.right, rcRequest.bottom);
        _ptbsite->RequestBorderSpaceDW(SAFECAST(this, IDockingWindow*), &rcRequest);

        TraceMsg(DM_LAYOUT, "CITB::ResizeBorderDW calling SetBS with %d,%d,%d,%d",
                 rcRequest.left, rcRequest.top, rcRequest.right, rcRequest.bottom);
        _ptbsite->SetBorderSpaceDW(SAFECAST(this, IDockingWindow*), &rcRequest);
    }

    return hres;
}

HRESULT CInternetToolbar::QueryStatus(const GUID *pguidCmdGroup,
                                      ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
    if (pbid)
    {
        if (pbid->pdb)
        {
            IOleCommandTarget *poct;
            if (SUCCEEDED(pbid->pdb->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &poct))))
            {
                hr = poct->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
                poct->Release();
            }
        }
        pbid->Release();
    }

    if (pguidCmdGroup && IsEqualGUID(CGID_PrivCITCommands, *pguidCmdGroup))
    {
        hr = S_OK;
        for (ULONG i = 0 ; i < cCmds; i++)
        {
            rgCmds[i].cmdf = 0;
            switch (rgCmds[i].cmdID)
            {
            case CITIDM_VIEWTOOLS:
                if (_nVisibleBands & VBF_TOOLS)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_VIEWMENU:
                if (_nVisibleBands & VBF_MENU)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_VIEWTOOLBARCUSTOMIZE:
                if (_btb._fCustomize)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_VIEWAUTOHIDE:
                if (_fAutoHide)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_VIEWLOCKTOOLBAR:
                if (_fLockedToolbar)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_VIEWADDRESS:
                if (_nVisibleBands & VBF_ADDRESS)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_VIEWLINKS:
                if (_nVisibleBands & VBF_LINKS)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_TEXTLABELS:
                if (!_fCompressed)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_EDITPAGE:
                if (_fEditEnabled)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                // The tooltip text is also used for the menu
                if (pcmdtext)
                {
                    TCHAR szBuf[MAX_PATH];
                    if ((pcmdtext->cmdtextf == OLECMDTEXTF_NAME) &&
                         _aEditVerb.GetMenuText(szBuf, ARRAYSIZE(szBuf)))
                    {
                        SHTCharToUnicode(szBuf, pcmdtext->rgwz, pcmdtext->cwBuf);
                        pcmdtext->cwActual = lstrlenW(pcmdtext->rgwz) + 1;
                    }
                    else
                    {
                        pcmdtext->cwActual = 0;
                    }
                }
                break;
            default:
                if (InRange( rgCmds[i].cmdID, CITIDM_VIEWEXTERNALBAND_FIRST, CITIDM_VIEWEXTERNALBAND_LAST))
                {
                    int iBand = rgCmds[i].cmdID - CITIDM_VIEWEXTERNALBAND_FIRST;
                    if (!IsEqualCLSID( _rgebi[iBand].clsid, GUID_NULL ))
                    {
                        rgCmds[i].cmdf |= OLECMDF_SUPPORTED;
                        if (_nVisibleBands & EXTERNALBAND_VBF_BIT( iBand ))
                        {
                            rgCmds[i].cmdf |= OLECMDF_ENABLED;
                        }
                        if (pcmdtext)
                        {
                            pcmdtext->rgwz[0] = TEXT('\0');
                            switch (pcmdtext->cmdtextf)
                            {
                            case OLECMDTEXTF_NAME:
                                if (_rgebi[iBand].pwszName)
                                    Str_GetPtrW(_rgebi[iBand].pwszName, pcmdtext->rgwz, pcmdtext->cwBuf );
                                break;

                            case OLECMDTEXTF_STATUS:
                                if (_rgebi[iBand].pwszHelp)
                                    Str_GetPtrW(_rgebi[iBand].pwszHelp, pcmdtext->rgwz, pcmdtext->cwBuf );
                                break;

                            default:
                                break;
                            }
                            pcmdtext->cwActual = lstrlen( pcmdtext->rgwz );
                        }
                    }
                }
                break;
            }
        }
    }
    return hr;
}

void CInternetToolbar::_RestoreSaveStruct(COOLBARSAVE* pcs)
{
    REBARBANDINFO rbbi;
    rbbi.cbSize = sizeof(REBARBANDINFO);
    int i;

    _fAutoHide = pcs->fAutoHide;
    _ShowVisible(pcs->uiVisible, FALSE);

    BOOL fAllowRetry = TRUE;
    BOOL fNeedRetry = FALSE;
    INT_PTR fRedraw = SendMessage(_bs._hwnd, WM_SETREDRAW, FALSE, 0);
Retry:
    for (i = 0; i < CBANDSMAX; i++)
    {
        INT_PTR iIndex = SendMessage(_bs._hwnd, RB_IDTOINDEX, pcs->bs[i].wID, 0);
        if (iIndex != -1)
        {
            SendMessage(_bs._hwnd, RB_MOVEBAND, iIndex, i);
            rbbi.fMask = RBBIM_STYLE;
            if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
            {
                rbbi.fMask = RBBIM_SIZE | RBBIM_STYLE;
                rbbi.cx = pcs->bs[i].cx;
                rbbi.fStyle = pcs->bs[i].fStyle;
                SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
            }

            // the SetBandInfo could have potentially caused items to shift around
            // verify that this didn't happen.
            iIndex = SendMessage(_bs._hwnd, RB_IDTOINDEX, pcs->bs[i].wID, 0);
            if (iIndex != i)
            {
                fNeedRetry = TRUE;
            }
        }
    }

    if (fAllowRetry && fNeedRetry)
    {
        fAllowRetry = FALSE;
        goto Retry;
    }

    _CSHSetStatusBar(pcs->fStatusBar);
    _UpdateToolsStyle(pcs->fList);

    RECT rc;
    GetWindowRect(_bs._hwnd, &rc);
    SetWindowPos(_bs._hwnd, NULL, 0,0, RECTWIDTH(rc), pcs->cyRebar, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    SendMessage(_bs._hwnd, WM_SETREDRAW, fRedraw, 0);
}

void CInternetToolbar::_CSHSetStatusBar(BOOL fOn)
{
    VARIANTARG v = { 0 };
    v.vt = VT_I4;
    v.lVal = fOn;
    IUnknown_Exec(_ptbsite, &CGID_ShellBrowser, FCIDM_SETSTATUSBAR,
        0, &v, NULL);
}

void CInternetToolbar::_TheaterModeLayout(BOOL fEnter)
{
    static const struct {
        int id;
        int cx;
    } c_layout[] =
    {
        { CBIDX_TOOLS, 400 },
        { CBIDX_MENU, 200 },
        { CBIDX_ADDRESS, 300 },
        { CBIDX_LINKS, 40 }
    };

    REBARBANDINFO rbbi;
    rbbi.cbSize = sizeof(REBARBANDINFO);

    BOOL_PTR fRedraw = SendMessage(_bs._hwnd, WM_SETREDRAW, FALSE, 0);
    SHSetWindowBits(_bs._hwnd, GWL_STYLE, RBS_AUTOSIZE, 0);
    if (fEnter)
    {
        _BuildSaveStruct(&_cs);

        // turn off text labels
        COOLBARSAVE cs;
        DWORD dwType, cbSize = sizeof(COOLBARSAVE);
        if (SHRegGetUSValue(c_szRegKeyCoolbar, c_szValueTheater, &dwType, (void*)&cs, &cbSize, FALSE, NULL, 0) == ERROR_SUCCESS &&
           cs.cbVer == CBS_VERSION)
        {
            _RestoreSaveStruct(&cs);
            _UpdateToolbarDisplay(UTD_TEXTLABEL, 0, TRUE, TRUE);
        }
        else
        {
            _UpdateToolbarDisplay(UTD_TEXTLABEL, 0, TRUE, TRUE);
            _ShowVisible(VBF_TOOLS | VBF_BRAND, FALSE); // only show tools band by default
            RECT rc = { 0, 0, GetSystemMetrics(SM_CXSCREEN), 20 }; // something arbitrarily small vertically
            SendMessage(_bs._hwnd, RB_SIZETORECT, 0, (LPARAM)&rc);

            int cBands = (int) SendMessage(_bs._hwnd, RB_GETBANDCOUNT, 0, 0L);
            int i;
            // strip off all blanks
            rbbi.fMask = RBBIM_STYLE;
            for (i = 0; i < cBands; i++)
            {
                if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
                {
                    rbbi.fStyle &= ~RBBS_BREAK;
                    SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
                }
            }

            // then move into the proper order and size
            for (i = 0; i < ARRAYSIZE(c_layout); i++)
            {
                INT_PTR iIndex = SendMessage(_bs._hwnd, RB_IDTOINDEX, c_layout[i].id, 0);
                if (iIndex != -1)
                {
                    SendMessage(_bs._hwnd, RB_MOVEBAND, iIndex, i);

                    rbbi.fMask = RBBIM_SIZE;
                    rbbi.cx = c_layout[i].cx;
                    SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
                }
            }
            _CSHSetStatusBar(FALSE);  // default value in theater mode
        }
        SHSetWindowBits(_bs._hwnd, GWL_STYLE, RBS_BANDBORDERS | WS_BORDER, RBS_BANDBORDERS);
    }
    else
    {
        COOLBARSAVE cs;
        _BuildSaveStruct(&cs);
        SHRegSetUSValue(c_szRegKeyCoolbar, c_szValueTheater, REG_BINARY,
                        (void*)&cs, sizeof(COOLBARSAVE), SHREGSET_HKCU | SHREGSET_FORCE_HKCU);
        _RestoreSaveStruct(&_cs);
        _UpdateToolbarDisplay(UTD_TEXTLABEL, 0, _cs.fNoText, FALSE);
        SHSetWindowBits(_bs._hwnd, GWL_STYLE, RBS_BANDBORDERS | WS_BORDER, RBS_BANDBORDERS | WS_BORDER);
    }

    _SetBackground();
    SHSetWindowBits(_bs._hwnd, GWL_STYLE, RBS_AUTOSIZE, RBS_AUTOSIZE);
    SendMessage(_bs._hwnd, WM_SETREDRAW, fRedraw, 0);

    SetWindowPos(_bs._hwnd, NULL, 0, 0, 0, 0, SWP_FRAMECHANGED|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
}

HRESULT CInternetToolbar::_GetMinRowHeight()
{
    UINT iHeight = 0;
    int icBands = (int) SendMessage( _bs._hwnd, RB_GETBANDCOUNT, 0, 0 );
    for (int i = 0; i < icBands; i++)
    {
        REBARBANDINFO rbbi;
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_CHILDSIZE | RBBIM_STYLE;
        if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM)&rbbi))
        {
            // go until the end of the row
            if (rbbi.fStyle & RBBS_BREAK)
                break;

            if (!(rbbi.fStyle & RBBS_HIDDEN))
            {
                if (rbbi.cyMinChild > iHeight)
                    iHeight = rbbi.cyMinChild;
            }
        }
    }

    return ResultFromShort(iHeight);
}

BOOL IsBarRefreshable(IDeskBar* pdb)
{
    ASSERT(pdb);
    BOOL fIsRefreshable = TRUE;
    VARIANT varClsid = {0};

    if (SUCCEEDED(IUnknown_Exec(pdb, &CGID_DeskBarClient, DBCID_CLSIDOFBAR, 1, NULL, &varClsid)) && (varClsid.vt == VT_BSTR))
    {
        CLSID clsidBar;

        //if the bar is hidden, it returns GUID_NULL, so don't refresh it
        if ( GUIDFromString(varClsid.bstrVal, &clsidBar) &&
             (IsEqualGUID(clsidBar, GUID_NULL)) )
        {
            fIsRefreshable = FALSE;
        }
        else
        {
            //APPHACK for office discussions band (and possibly others)
            //CLSID\GUID\Instance
            WCHAR wszKey[6+40+1+9];
            DWORD dwValue, dwType=REG_DWORD, dwcbData = 4;
            wnsprintf(wszKey, ARRAYSIZE(wszKey), L"CLSID\\%s\\Instance", varClsid.bstrVal);

            if ( (SHGetValue(HKEY_CLASSES_ROOT, wszKey, L"DontRefresh", &dwType, &dwValue, &dwcbData) == ERROR_SUCCESS) &&
                 (dwValue != 0) )
            {
                fIsRefreshable = FALSE;
            }
        }
        VariantClear(&varClsid);
    }
    return fIsRefreshable;
}

HRESULT CInternetToolbar::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;  // assume failure

    if (!pguidCmdGroup)
    {
        goto Lother;
    }
    else if (IsEqualGUID(CLSID_CommonButtons, *pguidCmdGroup))
    {
        if (pvarargOut)
        {
            ASSERT(pvarargOut && pvarargOut->vt == VT_I4);
            UINT uiInternalCmdID = pvarargOut->lVal;

            if (nCmdID == TBIDM_SEARCH && uiInternalCmdID == -1)
                _btb._ConvertCmd(pguidCmdGroup, nCmdID, NULL, &uiInternalCmdID);

            switch (nCmdID)
            {
            case TBIDM_BACK:
            case TBIDM_FORWARD:
            case TBIDM_STOPDOWNLOAD:
            case TBIDM_REFRESH:
            case TBIDM_HOME:
            case TBIDM_SEARCH:
            case TBIDM_FAVORITES:
            case TBIDM_HISTORY:
            case TBIDM_ALLFOLDERS:
            case TBIDM_MEDIABAR:
                if (!SendMessage(_btb._hwnd, TB_ISBUTTONENABLED, uiInternalCmdID, 0))
                    return S_OK;
                break;
            }
            if (nCmdexecopt == OLECMDEXECOPT_PROMPTUSER)
            {
                // the user hit the drop down
                if (_ptbsitect && pvarargIn && pvarargIn->vt == VT_INT_PTR)
                {
                    // v.vt = VT_I4;
                    POINT pt;
                    RECT* prc = (RECT*)pvarargIn->byref;
                    pt.x = prc->left;
                    pt.y = prc->bottom;

                    switch (nCmdID)
                    {
                    case TBIDM_BACK:
                        _ShowBackForwardMenu(FALSE, pt, prc);
                        break;

                    case TBIDM_FORWARD:
                        _ShowBackForwardMenu(TRUE, pt, prc);
                        break;
                    }
                    // VariantClearLazy(&v);
                }
                return S_OK;
            }

            switch(nCmdID)
            {
            case TBIDM_PREVIOUSFOLDER:
                _ptbsitect->Exec(&CGID_ShellBrowser, FCIDM_PREVIOUSFOLDER, 0, NULL, NULL);
                break;

            case TBIDM_CONNECT:
                DoNetConnect(_hwnd);
                break;

            case TBIDM_DISCONNECT:
                DoNetDisconnect(_hwnd);
                break;

            case TBIDM_BACK:
                _pdie->GoBack();
                break;

            case TBIDM_FORWARD:
                _pdie->GoForward();
                break;

            case TBIDM_HOME:
                _pdie->GoHome();
                break;

            case TBIDM_SEARCH:
                if (_ptbsitect)
                {
                    VARIANTARG vaOut = {0};
                    VARIANTARG* pvaOut = NULL;
                    LPITEMIDLIST pidl = NULL;

                    // i'm leaving this not #ifdefed out because it is used by explorer bar
                    // persistance (reljai)
                    //_SetSearchStuff initializes _guidDefaultSearch, which may or may not have
                    // been called yet
                    if (IsEqualGUID(_guidDefaultSearch, GUID_NULL))
                        _SetSearchStuff();

                    // see if what the state of search pane is, so we can toggle it...
                    OLECMD rgcmds[] = {{ SBCMDID_SEARCHBAR, 0 },};
                    
                    if (_ptbsitect)
                        _ptbsitect->QueryStatus(&CGID_Explorer, ARRAYSIZE(rgcmds), rgcmds, NULL);
                    // not pressed, then show the pane
                    if (!(rgcmds[0].cmdf & OLECMDF_LATCHED))
                    {
                        WCHAR       wszUrl[MAX_URL_STRING];

                        if (_GetSearchUrl(wszUrl, ARRAYSIZE(wszUrl)))
                        {
                            CLSID clsid;

                            if (GUIDFromString(wszUrl, &clsid))
                            {
                                IContextMenu* pcm;

                                if (SUCCEEDED(SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IContextMenu, &pcm))))
                                {
                                    CMINVOKECOMMANDINFO ici = {0};
                                    CHAR                szGuid[GUIDSTR_MAX];
                                    BOOL                bSetSite = TRUE;

                                    ici.cbSize = sizeof(ici);
                                    ici.hwnd = _hwnd;
                                    ici.lpVerb = (LPSTR)MAKEINTRESOURCE(0);
                                    ici.nShow  = SW_NORMAL;
                                    SHStringFromGUIDA(_guidDefaultSearch, szGuid, ARRAYSIZE(szGuid));
                                    ici.lpParameters = szGuid;

                                    // in case of rooted browser we need to open the search in the new window
                                    // 'coz otherwise the pane opens in the same window and user starts search
                                    // and browseobject (or someone) detects the rooted case and launches new
                                    // browser for our search results view (which is blank because it cannot do
                                    // search by itself and also there is not search pane) (reljai)
                                    if (_pbs2)
                                    {
                                        LPITEMIDLIST pidl;

                                        if (SUCCEEDED(_pbs2->GetPidl(&pidl)))
                                        {
                                            bSetSite = !ILIsRooted(pidl);
                                            ILFree(pidl);
                                        }
                                    }
                                    // if there is no site, InvokeCommand bellow will launch new browser w/ the 
                                    // search pane open
                                    if (bSetSite)
                                        IUnknown_SetSite(pcm, _psp);
                                    hr = pcm->InvokeCommand(&ici);
                                    if (bSetSite)
                                        IUnknown_SetSite(pcm, NULL);
                                    pcm->Release();
                                }
                                break;
                            }
                            //_guidCurrentSearch = _guidDefaultSearch;//done on set state
                            IECreateFromPathW(wszUrl, &pidl);
                            // convert pidl into VARIANT
                            // way to pass the pidl, so...
                            InitVariantFromIDList(&vaOut, pidl);
                            pvaOut = &vaOut;
                        }
                    }

                    hr = _ptbsitect->Exec(&CGID_Explorer, SBCMDID_SEARCHBAR, OLECMDEXECOPT_DONTPROMPTUSER, NULL, pvaOut); // vaIn:NULL means toggle
                    ASSERT(SUCCEEDED(hr));
                    if (pvaOut)
                        VariantClear(pvaOut);
                    ILFree(pidl);
                }
                else
                {
                    TraceMsg(DM_ERROR, "CITBar::Exec: no IOleCommandTarget!");
                }
                break;

            case TBIDM_FAVORITES:
            case TBIDM_HISTORY:
            case TBIDM_ALLFOLDERS:
            case TBIDM_MEDIABAR:
                if (_ptbsitect) 
                {
                    static const int tbtab[] = {
                        TBIDM_FAVORITES    , TBIDM_HISTORY    ,   TBIDM_ALLFOLDERS   , TBIDM_MEDIABAR  ,
                    };
                    static const int cttab[] = {
                        SBCMDID_FAVORITESBAR, SBCMDID_HISTORYBAR, SBCMDID_EXPLORERBAR, SBCMDID_MEDIABAR,
                    };
                    HRESULT hres;
                    int idCT;

                    idCT = SHSearchMapInt(tbtab, cttab, ARRAYSIZE(tbtab), nCmdID);
                    hres = _ptbsitect->Exec(&CGID_Explorer, idCT, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);  // vaIn:NULL means toggle
                    ASSERT(SUCCEEDED(hres));
                }
                else
                {
                    TraceMsg(DM_ERROR, "CITBar::Exec: no IOleCommandTarget!");
                }
                break;

            case TBIDM_THEATER:
                {
                    VARIANT_BOOL b;
                    if (SUCCEEDED(_pdie->get_TheaterMode(&b)))
                        _pdie->put_TheaterMode( b == VARIANT_TRUE ? VARIANT_FALSE : VARIANT_TRUE);
                    break;
                }

            case TBIDM_STOPDOWNLOAD:
                if (_fTransitionToHTML)
                {
                    UINT uiState;
                    _fTransitionToHTML = FALSE;
                    if (SUCCEEDED(GetState(&CLSID_CommonButtons, TBIDM_STOPDOWNLOAD, &uiState)))
                    {
                        uiState |= TBSTATE_HIDDEN;
                        SetState(&CLSID_CommonButtons, TBIDM_STOPDOWNLOAD, uiState);
                    }
                    SendMessage(_hwndAddressBand, CB_SETEDITSEL, NULL, (LPARAM)MAKELONG(-1,0));
                }
                _pdie->Stop();
                break;

            case TBIDM_REFRESH:
            {
                VARIANT v = {0};
                v.vt = VT_I4;
                v.lVal = (GetAsyncKeyState(VK_CONTROL) < 0) ?
                         OLECMDIDF_REFRESH_COMPLETELY|OLECMDIDF_REFRESH_PROMPTIFOFFLINE :
                         OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_PROMPTIFOFFLINE;
                _pdie->Refresh2(&v);

                if (_hwndAddressBand)
                {
                    CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
                    if (pbid)
                    {
                        if (pbid->pdb)
                        {
                            IAddressBand *pab = NULL;
                            if (SUCCEEDED(pbid->pdb->QueryInterface(IID_PPV_ARG(IAddressBand, &pab))))
                            {
                                VARIANTARG varType = {0};
                                varType.vt = VT_I4;
                                varType.lVal = OLECMD_REFRESH_TOPMOST;
                                pab->Refresh(&varType);
                                pab->Release();
                            }
                        }
                        pbid->Release();
                    }
                }

                // pass this to vert and horz bars
                IDockingWindowFrame *psb;
                if (_psp && SUCCEEDED(_psp->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IDockingWindowFrame, &psb))))
                {
                    IDeskBar* pdb;

                    if (SUCCEEDED(psb->FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdb))) && pdb &&
                        IsBarRefreshable(pdb))
                    {
                        IUnknown_Exec(pdb, NULL, OLECMDID_REFRESH, OLECMDIDF_REFRESH_NORMAL|OLECMDIDF_REFRESH_PROMPTIFOFFLINE, NULL, NULL);
                        pdb->Release();
                    }
                    if (SUCCEEDED(psb->FindToolbar(COMMBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdb))) && pdb &&
                        IsBarRefreshable(pdb))
                    {
                        IUnknown_Exec(pdb, NULL, OLECMDID_REFRESH, OLECMDIDF_REFRESH_NORMAL|OLECMDIDF_REFRESH_PROMPTIFOFFLINE, NULL, NULL);
                        pdb->Release();
                    }
                    psb->Release();
                }

            }
                break;
            }
        }
    } 
    else if (IsEqualGUID(IID_IExplorerToolbar, *pguidCmdGroup)) 
    {
        switch (nCmdID)
        {
        case ETCMDID_GETBUTTONS:
            {
                if (_iButtons == -1) 
                {
                    // haven't initialized yet
                    _iButtons = ARRAYSIZE(c_tbExplorer);
                    memcpy(_tbExplorer, c_tbExplorer, sizeof(TBBUTTON) * ARRAYSIZE(c_tbExplorer));

                    if (IS_BIDI_LOCALIZED_SYSTEM())
                    {
                        if (!SHUseClassicToolbarGlyphs())
                        {
                            _tbExplorer[0].iBitmap = 1;
                            _tbExplorer[1].iBitmap = 0;
                        }
                    }

                    if (GetUIVersion() < 5) 
                    {
                        // we don't want up button and network drive buttons available
                        // on < nt5 shell (by trident pm design)

                        // no customization in shell view on < nt5
                        ASSERT(!_fShellView);

                        ASSERT(c_tbExplorer[TBXID_PREVIOUSFOLDER].idCommand == TBIDM_PREVIOUSFOLDER);
                        _tbExplorer[TBXID_PREVIOUSFOLDER].fsState |= TBSTATE_HIDDEN;

                        ASSERT(c_tbExplorer[TBXID_CONNECT].idCommand == TBIDM_CONNECT);
                        _tbExplorer[TBXID_CONNECT].fsState |= TBSTATE_HIDDEN;

                        ASSERT(c_tbExplorer[TBXID_DISCONNECT].idCommand == TBIDM_DISCONNECT);
                        _tbExplorer[TBXID_DISCONNECT].fsState |= TBSTATE_HIDDEN;

                        ASSERT(c_tbExplorer[TBXID_ALLFOLDERS].idCommand == TBIDM_ALLFOLDERS);
                        if (!_FoldersButtonAvailable())
                            _tbExplorer[TBXID_ALLFOLDERS].fsState |= TBSTATE_HIDDEN;
                    }
                    else
                    {
                        ASSERT(c_tbExplorer[TBXID_SEARCH].idCommand == TBIDM_SEARCH);
                        if (_fShellView && SHRestricted(REST_NOSHELLSEARCHBUTTON))
                            _tbExplorer[TBXID_SEARCH].fsState |= TBSTATE_HIDDEN;
                            
                        ASSERT(c_tbExplorer[TBXID_CONNECT].idCommand == TBIDM_CONNECT);
                        ASSERT(c_tbExplorer[TBXID_DISCONNECT].idCommand == TBIDM_DISCONNECT);
                        if (SHRestricted(REST_NONETCONNECTDISCONNECT))
                        {
                            _tbExplorer[TBXID_CONNECT].fsState |= TBSTATE_HIDDEN;
                            _tbExplorer[TBXID_DISCONNECT].fsState |= TBSTATE_HIDDEN;
                        }
                    }
                    ASSERT(_tbExplorer[TBXID_MEDIABAR].idCommand == TBIDM_MEDIABAR);
                    if (_fShellView || SHRestricted2W(REST_No_LaunchMediaBar, NULL, 0) || !CMediaBarUtil::IsWMP7OrGreaterCapable())
                    {
                        _tbExplorer[TBXID_MEDIABAR].fsState |= TBSTATE_HIDDEN;
                    }

                    ASSERT(_tbExplorer[TBXID_PREVIOUSFOLDER].idCommand == TBIDM_PREVIOUSFOLDER);
                    if (!_fShellView) 
                    {
                        _tbExplorer[TBXID_PREVIOUSFOLDER].fsState |= TBSTATE_HIDDEN;
                    }
                    
                    _iButtons = RemoveHiddenButtons(_tbExplorer, ARRAYSIZE(_tbExplorer));
                }

                pvarargOut->vt = VT_BYREF;
                pvarargOut->byref = (void*)_tbExplorer;
                *pvarargIn->plVal = _iButtons;
            }
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_PrivCITCommands, *pguidCmdGroup))
    {
        DWORD dw;
        hr = S_OK;
        switch (nCmdID)
        {
        case CITIDM_GETFOLDERSEARCHES:
            {
                hr = E_INVALIDARG;

                if (pvarargOut)
                {
                    IFolderSearches *pfs;
                    hr = _GetFolderSearches(&pfs);

                    if (SUCCEEDED(hr))
                    {
                        VariantClear(pvarargOut);
                        pvarargOut->vt = VT_UNKNOWN;
                        pvarargOut->punkVal = pfs;
                    }
                }
            }
            break;

        case CITIDM_SET_DIRTYBIT:
            _fDirty = BOOLIFY(nCmdexecopt);
            break;

        case CITIDM_GETMINROWHEIGHT:
            hr = _GetMinRowHeight();
            break;

        case CITIDM_VIEWTOOLBARCUSTOMIZE:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWTOOLBARCUSTOMIZE, _hwnd, 0));
            break;

        case CITIDM_TEXTLABELS:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWTEXTLABELS, _hwnd, 0));
            break;

        case CITIDM_EDITPAGE:
            // FEATURE: temp code -- edit code moving to dochost.cpp
            _btb.Exec(&CLSID_InternetButtons, DVIDM_EDITPAGE, 0, NULL, NULL);
            break;

        case CITIDM_ONINTERNET:
            switch (nCmdexecopt)
            {
            case CITE_INTERNET:
                _fInitialPidlIsWeb = TRUE;
                _fShellView = !_fInitialPidlIsWeb;
                break;
            case CITE_SHELL:
                _fInitialPidlIsWeb = FALSE;
                _fShellView = !_fInitialPidlIsWeb;
                break;
            case CITE_QUERY:
                return ResultFromScode(_fShellView ? CITE_SHELL : CITE_INTERNET);
                break;
            }
            return ResultFromScode(_fInitialPidlIsWeb ? CITE_INTERNET : CITE_SHELL);

        case CITIDM_VIEWTOOLS:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWTOOLS, _hwnd, 0));
            break;

        case CITIDM_VIEWAUTOHIDE:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWAUTOHIDE, _hwnd, 0));
            break;

        case CITIDM_VIEWLOCKTOOLBAR:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWLOCKTOOLBAR, _hwnd, 0));
            break;

        case CITIDM_VIEWADDRESS:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWADDRESS, _hwnd, 0));
            break;

        case CITIDM_VIEWLINKS:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWLINKS, _hwnd, 0));
            break;

        case CITIDM_VIEWMENU:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWMENU, _hwnd, 0));
            break;

        case CITIDM_SHOWTOOLS:
            dw = VBF_TOOLS;
            goto ShowABand;

        case CITIDM_SHOWADDRESS:
            dw = VBF_ADDRESS;
            goto ShowABand;

        case CITIDM_SHOWLINKS:
            dw = VBF_LINKS;
            goto ShowABand;

#ifdef UNIX
        case CITIDM_SHOWBRAND:
            dw = VBF_BRAND;
            goto ShowABand;
#endif

        case CITIDM_SHOWMENU:
            dw = VBF_MENU;
ShowABand:
            if (nCmdexecopt)
                dw |= _nVisibleBands;           // Set
            else
                dw = (_nVisibleBands & ~dw);    // Clear

            _ShowVisible(dw, TRUE);
            _fUsingDefaultBands = FALSE;
            break;

        case CITIDM_DISABLESHOWMENU:
            _fNoShowMenu = BOOLIFY(nCmdexecopt);
            break;

        case CITIDM_STATUSCHANGED:
            _fDirty = TRUE;
            if (_ptbsitect)
                _ptbsitect->Exec(&CGID_ShellBrowser, FCIDM_PERSISTTOOLBAR, 0, NULL, NULL);
            break;

        case CITIDM_THEATER:

            if (_fShow)
            {

                // IF YOU SEE HTIS ASSERT, TRY TO REMEMBER WHAT YOU DID AND CALL CHEE
                ASSERT(_fTheater || _nVisibleBands & VBF_MENU);

                switch (nCmdexecopt)
                {

                case THF_ON:
                    _fTheater = TRUE;
                    ResizeBorderDW(NULL, NULL, FALSE);
                    _TheaterModeLayout(TRUE);
                    // theater has its own brand, so needs to know whether we're in shell or web view so it can show the right brand
                    IUnknown_Exec(_ptbsite, &CGID_Theater, THID_ONINTERNET, _fShellView ? CITE_SHELL : CITE_INTERNET, NULL, NULL);

                    // pass back _fAutoHide
                    pvarargOut->vt = VT_I4;
                    pvarargOut->lVal = _fAutoHide;

                    goto notify_bands;


                case THF_OFF:
                    _fTheater = FALSE;
                    ResizeBorderDW(NULL, NULL, FALSE);
                    _TheaterModeLayout(FALSE);

                    // position everything properly (needed after reparenting)
                    SendMessage(_hwnd, RB_PRIV_RESIZE, 0, 0);
                    goto notify_bands;

notify_bands:
                    {
                        int icBands = (int) SendMessage( _bs._hwnd, RB_GETBANDCOUNT, 0, 0 );
                        for (int i = 0; i < icBands; i++)
                        {
                            REBARBANDINFO rbbi;
                            rbbi.cbSize = sizeof(REBARBANDINFO);
                            rbbi.fMask = RBBIM_ID;

                            if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
                            {
                                CBandItemData *pbid = _bs._GetBandItemDataStructByID(rbbi.wID);
                                if (pbid)
                                {
                                    IUnknown_Exec(pbid->pdb, pguidCmdGroup, CITIDM_THEATER, nCmdexecopt, NULL, NULL);
                                    pbid->Release();
                                }
                            }
                        }
                    }
                    break;

                case THF_UNHIDE:
                    // position everything properly (needed after reparenting)
                    SendMessage(_hwnd, RB_PRIV_RESIZE, 0, 0);
                    break;
                }

                // IF YOU SEE HTIS ASSERT, TRY TO REMEMBER WHAT YOU DID AND CALL CHEE
                ASSERT(_fTheater || _nVisibleBands & VBF_MENU);
            }

            break;
        case CITIDM_VIEWEXTERNALBAND_BYCLASSID:
            if ((pvarargIn->vt == VT_BSTR) && pvarargIn->bstrVal)
            {
                CLSID clsid;
                if (GUIDFromString( pvarargIn->bstrVal, &clsid ))
                {
                    hr = E_FAIL;
                    for (DWORD i = 0; i < MAXEXTERNALBANDS; i++)
                    {
                        if (clsid == _rgebi[i].clsid)
                        {
                            DWORD dw = _nVisibleBands;
                            DWORD dwBit = EXTERNALBAND_VBF_BIT( i );
                            dw = (nCmdexecopt) ? dw | dwBit : dw & ~dwBit;
                            if ( !( dw & ~VBF_BRAND))
                            {
                                _pdie->put_ToolBar( FALSE );
                            }
                            _ShowVisible(dw, TRUE);
                            _fUsingDefaultBands = FALSE;
                            hr = S_OK;
                            break;
                        }
                    }
                }
            }
            break;
        default:
            if (InRange( nCmdID, CITIDM_VIEWEXTERNALBAND_FIRST, CITIDM_VIEWEXTERNALBAND_LAST ))
            {
                _OnCommand(GET_WM_COMMAND_MPS( nCmdID - CITIDM_VIEWEXTERNALBAND_FIRST + FCIDM_EXTERNALBANDS_FIRST, _hwnd, 0));
                break;
            }
            ASSERT(0);
            break;
        }
    }
    else
    {
Lother:
        CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
        if (pbid)
        {
            hr = IUnknown_Exec(pbid->pdb, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            pbid->Release();
        }
    }

    return hr;
}

BOOL _GetSearchHKEY(REFGUID guidSearch, HKEY *phkey)
{
    HKEY hkey;
    BOOL bRet = FALSE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_SZ_STATIC, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        TCHAR szExt[MAX_PATH];//extension key name
        DWORD cchExt = ARRAYSIZE(szExt);
        int  iExt;
        BOOL bNoUrl = FALSE; // true iff guidSearch is found and there is no Url subkey

        for (iExt=0;
             !bRet && RegEnumKeyEx(hkey, iExt, szExt, &cchExt, NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
             cchExt = ARRAYSIZE(szExt), iExt++)
        {
            HKEY hkeyExt; // static extension key

            if (RegOpenKeyEx(hkey, szExt, 0, KEY_READ, &hkeyExt) == ERROR_SUCCESS)
            {
                int i;
                TCHAR szSubKey[32];
                HKEY  hkeySub;

                for (i = 0; !bRet && (wnsprintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%d"), i),
                            RegOpenKeyEx(hkeyExt, szSubKey, 0, KEY_READ, &hkeySub) == ERROR_SUCCESS);
                     i++)
                {
                    TCHAR szSearchGuid[GUIDSTR_MAX];
                    DWORD cb;
                    DWORD dwType;

                    cb = sizeof(szSearchGuid);
                    if (SHGetValue(hkeySub, REG_SZ_SEARCH_GUID, NULL, &dwType, (BYTE*)szSearchGuid, &cb) == ERROR_SUCCESS)
                    {
                        GUID guid;

                        if (GUIDFromString(szSearchGuid, &guid) &&
                            IsEqualGUID(guid, guidSearch))
                        {
                            HKEY hkeyTmp;

                            if (RegOpenKeyEx(hkeySub, REG_SZ_SEARCH_URL, 0, KEY_READ, &hkeyTmp) == ERROR_SUCCESS)
                                RegCloseKey(hkeyTmp);
                            else
                                bNoUrl = TRUE;

                            bRet = TRUE;
                        }
                    }
                    if (!bRet || bNoUrl)
                        RegCloseKey(hkeySub);
                    else
                        *phkey = hkeySub;

                }
                if (!bNoUrl)
                    RegCloseKey(hkeyExt);
                else
                {
                    ASSERT(bRet);
                    *phkey = hkeyExt;
                }
            }
        }
        RegCloseKey(hkey);
    }
    return bRet;
}

HRESULT CInternetToolbar::GetDefaultSearchUrl(LPWSTR pwszUrl, UINT cch)
{
    HRESULT hr = E_FAIL;

    if (GetDefaultInternetSearchUrlW(pwszUrl, cch, TRUE))
        hr = S_OK;
    return hr;
}

void WINAPI CopyEnumElement(void *pDest, const void *pSource, DWORD dwSize)
{
    if (!pDest)
        return;

    memcpy(pDest, pSource, dwSize);
}

class CFolderSearches : public IFolderSearches
{
public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    // *** IFolderSearches ***
    STDMETHODIMP EnumSearches(IEnumUrlSearch **ppenum);
    STDMETHODIMP DefaultSearch(GUID *pguid);

    CFolderSearches(GUID *pguid, int iCount, URLSEARCH *pUrlSearch);
    ~CFolderSearches();
private:
    LONG _cRef;
    int  _iCount;
    GUID _guidDefault;
    URLSEARCH *_pUrlSearch;
};

CFolderSearches::CFolderSearches(GUID *pguid, int iCount, URLSEARCH *pUrlSearch)
{
    _cRef = 1;
    _iCount = iCount;
    _guidDefault = *pguid;
    _pUrlSearch = pUrlSearch;
}

CFolderSearches::~CFolderSearches()
{
    if (_pUrlSearch)
        LocalFree(_pUrlSearch);
}

HRESULT CFolderSearches::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CFolderSearches, IFolderSearches),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CFolderSearches::AddRef()
{
    return ++_cRef;
}

ULONG CFolderSearches::Release()
{
    if (--_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CFolderSearches::EnumSearches(IEnumUrlSearch **ppenum)
{
    HRESULT hres = E_OUTOFMEMORY;

    *ppenum = (IEnumUrlSearch *)new CStandardEnum(IID_IEnumUrlSearch, FALSE,
                _iCount, sizeof(URLSEARCH), _pUrlSearch, CopyEnumElement);
    if (*ppenum)
    {
        _pUrlSearch = NULL;
        _iCount = 0;
        hres = S_OK;
    }
    return hres;
}

HRESULT CFolderSearches::DefaultSearch(GUID *pguid)
{
    *pguid = _guidDefault;
    return S_OK;
}

HRESULT CInternetToolbar::_GetFolderSearches(IFolderSearches **ppfs)
{
    HRESULT hres = E_FAIL;

    *ppfs = NULL;
    if (_hdpaFSI)
    {
        LPURLSEARCH pUrlSearch = NULL;
        int iCount = 0;
        int cFSIs = DPA_GetPtrCount(_hdpaFSI);

        hres = E_OUTOFMEMORY;
        if (cFSIs > 0
            && ((pUrlSearch = (LPURLSEARCH)LocalAlloc(LPTR, sizeof(URLSEARCH)*cFSIs)) != NULL))
        {
            LPFOLDERSEARCHITEM pfsi;
            int i;

            // insert per folder items
            for (i = 0; i < cFSIs && (pfsi = (LPFOLDERSEARCHITEM)DPA_GetPtr(_hdpaFSI, i)) != NULL; i++)
            {
                CLSID  clsid;

                // check if Url is actually a GUID. if yes we cannot enumerate it because
                // we need Title/Url pair.
                if (!GUIDFromStringW(pfsi->wszUrl, &clsid))
                {
                    lstrcpynW(pUrlSearch[iCount].wszName, pfsi->wszName, ARRAYSIZE(pUrlSearch[iCount].wszName));
                    lstrcpynW(pUrlSearch[iCount].wszUrl,  pfsi->wszUrl,  ARRAYSIZE(pUrlSearch[iCount].wszUrl));
                    iCount++;
                }
            }
        }
        *ppfs = new CFolderSearches(&_guidDefaultSearch, iCount, pUrlSearch);
        if (*ppfs)
            hres = S_OK;
        else
            LocalFree(pUrlSearch);
    }
    return hres;
}

BOOL CInternetToolbar::_GetSearchUrl(LPWSTR pwszUrl, DWORD cch)
{
    BOOL        bRet = FALSE;
    HKEY        hkey;

    if (pwszUrl)
    {
        pwszUrl[0] = L'\0';

        // if we are looking for web search url bypass the registry lookup and the
        // per folder items and go straight to GetDefaultSearchUrl which call
        // GetSearchAssistantUrlW
        if (!IsEqualGUID(_guidDefaultSearch, SRCID_SWebSearch))
        {
            // _GetSearchHKEY looks in the registry where shell search items are registered
            // if we have old shell32 then we don't display shell search items so we should
            // not look in the registry
            if (GetUIVersion() >= 5 && _GetSearchHKEY(_guidDefaultSearch, &hkey))
            {
                DWORD cb = cch*sizeof(TCHAR);
                TCHAR szGuid[GUIDSTR_MAX];
                DWORD cbGuid = sizeof(szGuid);

                // is there a url key
                if (SHGetValueW(hkey, REG_SZ_SEARCH_URL, NULL, NULL, pwszUrl, &cb) == ERROR_SUCCESS)
                    bRet = TRUE;
                // no? try the default value, maybe it's the clsid
                else if (SHGetValueW(hkey, NULL, NULL, NULL, szGuid, &cbGuid) == ERROR_SUCCESS)
                {
                    GUID guid;
                    // is it a valid guid string
                    if (GUIDFromString(szGuid, &guid))
                    {
                        StrCpyNW(pwszUrl, szGuid, cch);
                        bRet = TRUE;
                    }
                }

                RegCloseKey(hkey);
            }
            // maybe it's one of the per-folder items...
            else if (_hdpaFSI) //FSI = folder search items
            {
                int i;
                LPFOLDERSEARCHITEM pfsi;

                for (i=0; (pfsi = (LPFOLDERSEARCHITEM)DPA_GetPtr(_hdpaFSI, i)) != NULL; i++)
                {
                    if (IsEqualGUID(_guidDefaultSearch, pfsi->guidSearch))
                    {
                        StrCpyNW(pwszUrl, pfsi->wszUrl, cch);
                        bRet = TRUE;
                        break;
                    }
                }
            }
        }

        if (!bRet)
            bRet = SUCCEEDED(GetDefaultSearchUrl(pwszUrl, cch));
    }

    return bRet;
}

void CInternetToolbar::_SetSearchStuff()
{
    UINT uiState;
    BOOL bChecked = FALSE;

    if (SUCCEEDED(GetState(&CLSID_CommonButtons, TBIDM_SEARCH, &uiState)))
        bChecked = uiState & TBSTATE_CHECKED;

    if (!_hdpaFSI)
    {
        _hdpaFSI = DPA_Create(2);
    }
    else
    {
        DPA_EnumCallback(_hdpaFSI, DeleteDPAPtrCB, NULL); // delete all ptrs
        DPA_DeleteAllPtrs(_hdpaFSI); // now tell hdpa to forget about them
    }

    // this is bogus -- _fShellView is always FALSE when using automation
    if (_fShellView)
        _guidDefaultSearch = SRCID_SFileSearch;
    else
        _guidDefaultSearch = SRCID_SWebSearch;

    // get per folder search items and the default search (if any)
    // and insert them to _himlSrc
    _GetFolderSearchData();

    if (!bChecked)
    {
        _guidCurrentSearch = _guidDefaultSearch;
    }
}

//
// CInternetToolbar::SetCommandTarget()
//
// This function sets the current command target and button group.  A client calls this
// before merging in buttons with the AddButtons method.
//
// There are a couple of tricky things about this function.
//
// NTRAID#NTBUG9-196149-2000/12/11-AIDANL  Hide Address Bar by default in explorer for Per/Pro
//      We no longer allow dwFlags to set links, address, tools, brand, relying on 
//      CInternetToolbar::_LoadDefaultSettings() for those settings.
//
// One is that the client can pass some flags (dwFlags param) specifying the bands it wants
// showing by default (menu, links, address, tools, brand, external).  But we don't let them change
// the state of the menu band.  And, if another client has already set the default bands, we
// don't let them change the state of any of the bands.
//
// The other is that we do some stuff to figure out if the caller is just another instantiation of the same
// client.  If we think this is a new client (new guidButtonGroup), we flush the toolbar and return S_OK.
// But if we think this is the same client reincarnated (same guidButtonGroup and non-NULL command target),
// we return S_FALSE without flushing the toolbar.  This is done for performance.  A new dochost is instantiated
// on each navigation, but its toolbar buttons never change, so don't bother remerging its toolbar buttons.
//
HRESULT CInternetToolbar::SetCommandTarget(IUnknown* punkCmdTarget, const GUID* pguidButtonGroup, DWORD dwFlags)
{
    if (!pguidButtonGroup || !punkCmdTarget || IsEqualGUID(CLSID_CommonButtons, *pguidButtonGroup))
        return E_INVALIDARG;

    // RAID 196149 - disallow changes to links, address, tools, brand, instead use _cs.uiVisible for these settings
    dwFlags = dwFlags & ~(VBF_LINKS| VBF_ADDRESS | VBF_TOOLS | VBF_BRAND);
    dwFlags |= (_cs.uiVisible & (VBF_LINKS| VBF_ADDRESS | VBF_TOOLS | VBF_BRAND));

    // this should not change the menu bit or external bands.
    dwFlags |= (_nVisibleBands & (VBF_MENU | VBF_EXTERNALBANDS));

    _btb._fCustomize = !((dwFlags & VBF_NOCUSTOMIZE) || SHRestricted2(REST_NOTOOLBARCUSTOMIZE, NULL, 0));

    // if the new button group is the internet button group, then we're
    // in internet mode; else we're in shell mode
    _fShellView = !(_IsDocHostGUID(pguidButtonGroup));

    _SetSearchStuff();

    HRESULT hr = S_FALSE;

    BOOL fNewButtonGroup = !IsEqualGUID(*pguidButtonGroup, _btb._guidCurrentButtonGroup);
    BOOL fNewCommandTarget = !SHIsSameObject(_btb._pctCurrentButtonGroup, punkCmdTarget);

    // when changing button groups we need to invalidate our cache of buttons for customization
    // why? well, with browse in separate process not turned on, navigating from shell to web
    // reuses the toolbar and some buttons may be disabled for shell but not for browser and vice versa.
    if (fNewButtonGroup)
        _iButtons = -1;
        
    if (fNewButtonGroup || fNewCommandTarget) 
    {
        if (_btb._pctCurrentButtonGroup)
            _btb._pctCurrentButtonGroup->Exec(&IID_IExplorerToolbar, ETCMDID_NEWCOMMANDTARGET, 0, NULL, NULL);

        _btb._guidCurrentButtonGroup = *pguidButtonGroup;
        ATOMICRELEASE(_btb._pctCurrentButtonGroup);
        punkCmdTarget->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_btb._pctCurrentButtonGroup));

        // A new view can tell us how many rows of text it NEEDs.
        // if it doesn't specify, we give it the default. (stored in _uiDefaultTBTextRows)
        if (dwFlags & VBF_ONELINETEXT )
            _uiTBTextRows = 1;
        else if (dwFlags & VBF_TWOLINESTEXT)
            _uiTBTextRows = 2;
        else
            _uiTBTextRows = _uiTBDefaultTextRows;

        _CompressBands(_fCompressed, _uiTBTextRows, FALSE);

        if (fNewButtonGroup) 
        {
            // new button group; flush toolbar
            _btb._RemoveAllButtons();
            hr = S_OK;
        }

        if (_fUsingDefaultBands && !_fTheater)
            _fUsingDefaultBands = FALSE;
        else
            dwFlags = _nVisibleBands;

        if (dwFlags)
            _ShowBands(dwFlags);
    }

    return hr;
}

HRESULT CInternetToolbar::AddStdBrowserButtons()
{
    //
    // code to add browser buttons has moved to CDocObjectHost::_AddButtons
    //
    ASSERT(0);
    return E_NOTIMPL;
}

void CInternetToolbar::_ReloadButtons()
{
    if (!IsEqualGUID(_btb._guidCurrentButtonGroup, CLSID_CommonButtons) &&
            _btb._pctCurrentButtonGroup)
    {
        HRESULT hres = _btb._pctCurrentButtonGroup->Exec(&IID_IExplorerToolbar, ETCMDID_RELOADBUTTONS, 0, NULL, NULL);
        if (FAILED(hres))
            AddButtons(&_btb._guidCurrentButtonGroup, _btb._cBtnsAdded, _btb._pbtnsAdded);

        _InitEditButtonStyle();

        _UpdateToolbar(TRUE);
    }
}

// The cmdTarget should have already added the Imagelists and the strings.
HRESULT CInternetToolbar::AddButtons(const GUID* pguidButtonGroup, UINT nNewButtons, const TBBUTTON * lpButtons)
{
    if (!pguidButtonGroup || !IsEqualGUID(*pguidButtonGroup, _btb._guidCurrentButtonGroup))
        return E_INVALIDARG;

    if (!IsWindow(_btb._hwnd))
        return E_FAIL;

    LPTBBUTTON lpTBCopy = (LPTBBUTTON)LocalAlloc(LPTR, nNewButtons * sizeof(TBBUTTON));
    if (!lpTBCopy)
        return E_OUTOFMEMORY;

    _CreateBands();
    _btb._RemoveAllButtons();

    memcpy(lpTBCopy, lpButtons, sizeof(TBBUTTON) * nNewButtons);

    nNewButtons = _btb._ProcessExternalButtons(lpTBCopy, nNewButtons);

    // Free the old button array
    _btb._FreeBtnsAdded();

    _btb._pbtnsAdded = lpTBCopy;
    _btb._cBtnsAdded = nNewButtons;

    if (_btb._fCustomize && _btb._SaveRestoreToolbar(FALSE))
    {
        // Customization mechanism filled the toolbar for us

        // 
        // The customization mechanism allocated its own set of
        // cmdmaps for the buttons, which means that we need to
        // free those hanging off _pbtnsAdded when _pbtnsAdded is
        // freed.
        //
        _btb._fNeedFreeCmdMapsAdded = TRUE;
        
        _btb._RecalcButtonWidths();

        //
        // If we had a custom edit glyph, reload it so that we
        // don't momentarily flash the default glyph during
        // navigation.  We'll update it again when we get a
        // DISPID_DOCUMENTCOMPLETE event.
        //
        _RefreshEditGlyph();

        if (!_fShellView)
        {
            _btb._AddMediaBarButton();
        }
    }
    else
    {
        // No customization found for this button group

        //
        // We're adding the button array to toolbar directly,
        // and the cmdmaps get freed on TBN_DELETINGBUTTON, so
        // we shouldn't also try to free them when _pbtnsAdded
        // is freed.
        //
        _btb._fNeedFreeCmdMapsAdded = FALSE;

        _AddCommonButtons();
        SendMessage(_btb._hwnd, TB_ADDBUTTONS, nNewButtons, (LPARAM)lpTBCopy);
    }

    _bs._SetMinDimensions();
    return S_OK;
}

HRESULT CInternetToolbar::AddString(const GUID * pguidButtonGroup, HINSTANCE hInst, UINT_PTR uiResID, LONG_PTR *pOffset)
{
    TraceMsg(DM_ITBAR, "CITBar::AddString called");

    *pOffset = -1;

    if (!IsWindow(_btb._hwnd))
    {
        TraceMsg(DM_ERROR, "CITBar::AddString failed");
        return E_FAIL;
    }

    *pOffset= SendMessage(_btb._hwnd, TB_ADDSTRING, (WPARAM)hInst, (LPARAM)uiResID);

    if (*pOffset != -1)
        return S_OK;

    TraceMsg(DM_ERROR, "CITBar::AddString failed");
    return E_FAIL;
}

HRESULT CInternetToolbar::GetButton(const GUID* pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton)
{
    UINT_PTR uiIndex = 0;
    TraceMsg(DM_ITBAR, "CITBar::GetButton called");

    if (!pguidButtonGroup || !IsWindow(_btb._hwnd))
        return E_FAIL;

    if (SUCCEEDED(_btb._ConvertCmd(pguidButtonGroup, uiCommand, NULL, &uiCommand)))
    {
        uiIndex = SendMessage(_btb._hwnd, TB_COMMANDTOINDEX, uiCommand, 0L);
        if (SendMessage(_btb._hwnd, TB_GETBUTTON, uiIndex, (LPARAM)lpButton))
        {
            GUID guid;
            _btb._ConvertCmd(NULL, lpButton->idCommand, &guid, (UINT*)&lpButton->idCommand);
            return S_OK;
        }
    }
    return E_FAIL;
}

HRESULT CInternetToolbar::GetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT * pfState)
{
    TraceMsg(DM_ITBAR, "CITBar::GetState called");

    if (!pguidButtonGroup || !IsWindow(_btb._hwnd))
        return E_FAIL;

    if (SUCCEEDED(_btb._ConvertCmd(pguidButtonGroup, uiCommand, NULL, &uiCommand)))
    {
        *pfState = (UINT)SendMessage(_btb._hwnd, TB_GETSTATE, uiCommand, 0L);
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CInternetToolbar::SetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT fState)
{
    BOOL bIsSearchBtn;

    if (!pguidButtonGroup || !IsWindow(_btb._hwnd))
        return E_FAIL;

    TraceMsg(DM_ITBAR, "CITBar::SetState called");

    bIsSearchBtn = uiCommand == TBIDM_SEARCH;
    if (SUCCEEDED(_btb._ConvertCmd(pguidButtonGroup, uiCommand, NULL, &uiCommand)))
    {
        UINT_PTR uiState;

        uiState = SendMessage(_btb._hwnd, TB_GETSTATE, uiCommand, NULL);
        uiState ^= fState;
        if (uiState)
        {
            // search button is being unchecked, change the icon to the default search's
            if (bIsSearchBtn && !(fState & TBSTATE_CHECKED) && !IsEqualGUID(_guidCurrentSearch, _guidDefaultSearch))
            {
                _guidCurrentSearch = _guidDefaultSearch;
            }
            if (SendMessage(_btb._hwnd, TB_SETSTATE, uiCommand, (LPARAM)fState))
            {
                if (uiState & TBSTATE_HIDDEN)
                    _bs._SetMinDimensions();
            }
        }
        return S_OK;
    }
    return E_FAIL;
}

//
//  A bitmap can be added in two ways:
//  1.  Send a bitmap in the hBMPNew field. The uiBMPType parameter needs to be a BITMAP_BMP*
//      The uiCount and the ptb parameters are ignored
//      The offset is placed in puiOffset
//
//  2.  A TBADDBITMAP struct can be sent. The uiCount should have the count
//      uiBMPType parameter needs to be a BITMAP_TBA* value
//      The offset is placed in puiOffset
HRESULT CInternetToolbar::AddBitmap(const GUID * pguidButtonGroup, UINT uiBMPType, UINT uiCount, TBADDBITMAP * ptb, LRESULT * pOffset, COLORREF rgbMask)
{
    UINT uiGetMSG, uiSetMSG;
    TBBMP_LIST tbl = {NULL};

    TraceMsg(DM_ITBAR, "CITBar::AddBitmap called");
    *pOffset = -1;

    _CreateBands();
    if ((!pguidButtonGroup) || (!IsWindow(_btb._hwnd)) || !_hdsaTBBMPs)
    {
        TraceMsg(DM_ERROR, "CITBar::AddBitmap failed - NULL pguidButtonGroup or invalid _hwnd");
        return E_FAIL;
    }

    // See if we already have the bitmap loaded.
    TBBMP_LIST * pTBBs = NULL;
    int nCount = DSA_GetItemCount(_hdsaTBBMPs);
    for (int nIndex = 0; nIndex < nCount; nIndex++)
    {
        pTBBs = (TBBMP_LIST*)DSA_GetItemPtr(_hdsaTBBMPs, nIndex);
        if ((pTBBs) && (pTBBs->hInst == ptb->hInst) && (pTBBs->uiResID == ptb->nID))
            break;
        pTBBs = NULL;
    }

    // If it was in the commctrl, then we should already have an entry in the DSA
    if ((ptb->hInst == HINST_COMMCTRL) && (!pTBBs))
    {
        TraceMsg(DM_ERROR, "CITBar::AddBitmap failed - bogus ResID for HINST_COMMCTL");
        return E_FAIL;
    }

    // If the icons being added are from fontsext.dll or from dialup networking
    // or the briefcase, then we have it. So just send return the offset
    if (ptb->hInst != HINST_COMMCTRL)
    {
        TCHAR szDLLFileName[MAX_PATH], *pszFN;
        ZeroMemory(szDLLFileName, sizeof(szDLLFileName));
        if (GetModuleFileName(ptb->hInst, szDLLFileName, ARRAYSIZE(szDLLFileName)))
        {
            pszFN = PathFindFileName(szDLLFileName);
            if(!lstrcmpi(pszFN, TEXT("fontext.dll")))
                *pOffset = FONTGLYPH_OFFSET;
            else if (!lstrcmpi(pszFN, TEXT("shell32.dll")))
            {
                // 140 and 141 are the glyphs that Shell32.dll uses:
                // IDB_BRF_TB_SMALL        140
                // IDB_BRF_TB_LARGE        141
                if ((ptb->nID == 140) || (ptb->nID == 141))
                    *pOffset = BRIEFCASEGLYPH_OFFSET;
            }
            else if (!lstrcmpi(pszFN, TEXT("rnaui.dll")))
                *pOffset = RNAUIGLYPH_OFFSET;
            else if (!lstrcmpi(pszFN, TEXT("webcheck.dll")))
                *pOffset = WEBCHECKGLYPH_OFFSET;
            if (*pOffset != -1)
                return S_OK;
        }
    }

    // So the bitmaps is not from commctrl. And we have never seen this before.
    // Add an entry into the DSA and then add the bitmap to the himage list.
    if (!pTBBs)
    {
        tbl.hInst = ptb->hInst;
        tbl.uiResID = ptb->nID;
        nIndex = DSA_AppendItem(_hdsaTBBMPs, &tbl);
        if (nIndex  < 0)
        {
            TraceMsg(DM_ERROR, "CITBar::AddBitmap failed - nIndex < 0!");
            return E_FAIL;
        }
        pTBBs = (TBBMP_LIST*)DSA_GetItemPtr(_hdsaTBBMPs, nIndex);
        if (!pTBBs)
        {
            TraceMsg(DM_ERROR, "CITBar::AddBitmap failed - pTBBS is NULL!");
            return E_FAIL;
        }
    }


    switch(uiBMPType)
    {
    case BITMAP_NORMAL:
        if ((pTBBs) && (pTBBs->fNormal))
        {
            *pOffset = pTBBs->uiOffset;
            return S_OK;
        }
        else if (pTBBs)
            pTBBs->fNormal = TRUE;

        uiGetMSG = TB_GETIMAGELIST; uiSetMSG = TB_SETIMAGELIST;
        break;

    case BITMAP_HOT:
        if ((pTBBs) && (pTBBs->fHot))
        {
            *pOffset = pTBBs->uiOffset;
            return S_OK;
        }
        else if (pTBBs)
            pTBBs->fHot = TRUE;

        uiGetMSG = TB_GETHOTIMAGELIST; uiSetMSG = TB_SETHOTIMAGELIST;
        break;

    case BITMAP_DISABLED:
        if ((pTBBs) && (pTBBs->fDisabled))
        {
            *pOffset = pTBBs->uiOffset;
            return S_OK;
        }
        else if (pTBBs)
            pTBBs->fDisabled = TRUE;

        uiGetMSG = TB_GETDISABLEDIMAGELIST; uiSetMSG = TB_SETDISABLEDIMAGELIST;
        break;

    default:
        ASSERT(FALSE);
        return E_FAIL;
    }
    pTBBs->uiCount = uiCount;
    
    *pOffset = _AddBitmapFromForeignModule(uiGetMSG, uiSetMSG, uiCount, ptb->hInst, ptb->nID, rgbMask);
    if (pTBBs)
        pTBBs->uiOffset = (UINT)*pOffset;

    return S_OK;
}

// the CmdTarget needs to call this to see what size of bmps we are using.
HRESULT CInternetToolbar::GetBitmapSize(UINT * uiSize)
{
    TraceMsg(DM_ITBAR, "CITBar::GetBitmapSize called");

    *uiSize = g_fSmallIcons ? MAKELONG(TB_SMBMP_CX, TB_SMBMP_CY) : MAKELONG(g_iToolBarLargeIconWidth,g_iToolBarLargeIconHeight);
    return S_OK;
}

HRESULT CInternetToolbar::SetImageList( const GUID* pguidCmdGroup, HIMAGELIST himlNormal, HIMAGELIST himlHot, HIMAGELIST himlDisabled)
{
    if (IsEqualGUID(*pguidCmdGroup, _btb._guidCurrentButtonGroup))
    {
        SendMessage(_btb._hwnd, TB_SETIMAGELIST, 1, (LPARAM)himlNormal);
        SendMessage(_btb._hwnd, TB_SETHOTIMAGELIST, 1, (LPARAM)himlHot);
        SendMessage(_btb._hwnd, TB_SETDISABLEDIMAGELIST, 1, (LPARAM)himlDisabled);
    }
    return S_OK;
}

HRESULT CInternetToolbar::ModifyButton( const GUID * pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton)
{
    UINT uiIndex = 0;
    TraceMsg(DM_ITBAR, "CITBar::ModifyButton called");

    if (!pguidButtonGroup || !IsWindow(_btb._hwnd))
        return E_FAIL;

    if (SUCCEEDED(_btb._ConvertCmd(pguidButtonGroup, uiCommand, NULL, &uiCommand)))
    {
        TBBUTTONINFO tbbi;
        tbbi.cbSize = sizeof(tbbi);
        tbbi.dwMask = TBIF_STATE | TBIF_IMAGE;
        tbbi.fsState = lpButton->fsState;
        tbbi.iImage = lpButton->iBitmap;

        if (SendMessage(_btb._hwnd, TB_SETBUTTONINFO, uiCommand, (LPARAM)&tbbi))
        {
            return S_OK;
        }
    }
    return E_FAIL;
}

HRESULT CInternetToolbar::SendToolbarMsg(const GUID* pguidButtonGroup, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT * plRes)
{
    LRESULT lRes;
    if (!IsWindow(_btb._hwnd))
    {
        TraceMsg(DM_ERROR, "CITBar::SendToolbarMsg Message failed");
        return E_FAIL;
    }

    if (
        // this api is only here for back compat, and these messages didn't
        // exist when the old clients were written

        uMsg == TB_GETBUTTONINFOA ||
        uMsg == TB_GETBUTTONINFOW ||
        uMsg == TB_SETBUTTONINFOA ||
        uMsg == TB_SETBUTTONINFOW ||

        // unsupported right now
        uMsg == TB_ADDBUTTONSA || uMsg == TB_ADDBUTTONSW
       )
    {

        ASSERT(0);
        return E_FAIL;
    }



    if ((uMsg == TB_ENABLEBUTTON) || (uMsg == TB_HIDEBUTTON) || (uMsg == TB_CHECKBUTTON) ||
        (uMsg == TB_PRESSBUTTON) || (uMsg == TB_MARKBUTTON))
    {
        unsigned int uiTemp;
        if (SUCCEEDED(_btb._ConvertCmd(pguidButtonGroup, (UINT)wParam, NULL, &uiTemp)))
            wParam = uiTemp;
    }

    if (uMsg == TB_INSERTBUTTON && lParam)
    {
        TBBUTTON btn = (*(TBBUTTON*)lParam);
        _btb._PreProcessExternalTBButton(&btn);
        lRes = SendMessage(_btb._hwnd, uMsg, wParam, (LPARAM)&btn);
    }
    else
    {
        lRes = SendMessage(_btb._hwnd, uMsg, wParam, lParam);

        if (uMsg == TB_GETBUTTON)
        {
            TBBUTTON* pbtn = (TBBUTTON*)lParam;
            if (pbtn && pbtn->dwData)
            {
                CMDMAP* pcm = (CMDMAP*)pbtn->dwData;
                pbtn->idCommand = pcm->nCmdID;
                pbtn->dwData = pcm->lParam;
            }
        }
    }

    if (plRes)
        *plRes = lRes;
    return S_OK;
}

TOOLSBANDCLASS::CBrowserToolsBand() : CToolbarBand()
{
    _fCanFocus = TRUE;
}

#define DEFAULT_LIST_VALUE()    (GetUIVersion() >= 5)

void TOOLSBANDCLASS::_FreeBtnsAdded()
{
    if (_pbtnsAdded)
    {
        if (_fNeedFreeCmdMapsAdded)
        {
            for (int i = 0; i < _cBtnsAdded; i++)
            {
                CMDMAP* pcm = (CMDMAP*)_pbtnsAdded[i].dwData;
                _FreeCmdMap(pcm);
            }
        }

        LocalFree(_pbtnsAdded);

        _pbtnsAdded = NULL;
        _cBtnsAdded = 0;
    }
}

LRESULT TOOLSBANDCLASS::_ToolsCustNotify (LPNMHDR pnmh)
{
    LPTBNOTIFY ptbn = (LPTBNOTIFY) pnmh;

    switch (pnmh->code)
    {

    case TBN_SAVE:
    {
        NMTBSAVE *pnmtbs = (NMTBSAVE*)pnmh;
        if (pnmtbs->iItem == -1)
        {
            // before the save
            int nButtons = (int) SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0L);
            int uSize = pnmtbs->cbData +
                        sizeof(BUTTONSAVEINFO) * nButtons +  // stuff for each button
                        sizeof(TOOLBARSAVEINFO); // stuff for the toolbar
            pnmtbs->pData = (LPDWORD)LocalAlloc(LPTR, uSize);
            pnmtbs->pCurrent = pnmtbs->pData;
            pnmtbs->cbData = uSize;

            if (pnmtbs->pData)
            {
                TOOLBARSAVEINFO *ptbsi = (TOOLBARSAVEINFO*)pnmtbs->pData;
                ptbsi->cVersion = TBSI_VERSION;
                pnmtbs->pCurrent = (LPDWORD)(ptbsi+1);
            }
        }
        else
        {
            CMDMAP *pcm = (CMDMAP*)pnmtbs->tbButton.dwData;
            BUTTONSAVEINFO* pbsi = (BUTTONSAVEINFO*)pnmtbs->pCurrent;
            pnmtbs->pCurrent = (LPDWORD)(pbsi+1);
            if (pcm)
            {
                pbsi->guid = pcm->guidButtonGroup;
                pbsi->nCmdID = pcm->nCmdID;
                pbsi->fButtonState = pnmtbs->tbButton.fsState;
#ifdef DEBUG
                TCHAR szGuid[80];
                SHStringFromGUID(pcm->guidButtonGroup, szGuid, ARRAYSIZE(szGuid));
                TraceMsg(TF_TBCUST, "Saving: %s - %d (%x)", szGuid, pbsi->nCmdID, pbsi->nCmdID);
#endif
            }
            else
            {
                ASSERT(pnmtbs->tbButton.fsStyle & BTNS_SEP);
                if (pnmtbs->tbButton.idCommand)
                {
                    TraceMsg(TF_TBCUST, "Saving: a separator w/ id %d (%x)", pnmtbs->tbButton.idCommand, pnmtbs->tbButton.idCommand);
                    pbsi->guid = CLSID_Separator;
                    pbsi->nCmdID = pnmtbs->tbButton.idCommand;
                }
                else
                {
                    TraceMsg(TF_TBCUST, "Saving: a separator");
                }
            }
        }
        break;
    }

    case TBN_RESTORE:
        {
            NMTBRESTORE* pnmtbr = (NMTBRESTORE*)pnmh;
            if (pnmtbr->iItem == -1)
            {
                // before the restore.
                // take the data, verify the version,
                // fill in the button count, bytes per record
                // initialize the pCurrent to the end of the tb header
                //
                TOOLBARSAVEINFO* ptbsi = (TOOLBARSAVEINFO*)pnmtbr->pCurrent;
                if (ptbsi->cVersion != TBSI_VERSION)
                {
                    TraceMsg( TF_WARNING, "TOOLSBANDCLASS::_ToolsCustNotify() - Wrong Toolbar Save Info Version (0x%x vs. 0x%x)!", ptbsi->cVersion, TBSI_VERSION );
                    return 1; // abort
                }


                // we're actually going to do a restore.  initialize our database:
                _BuildButtonDSA();

                pnmtbr->pCurrent = (LPDWORD)(ptbsi+1);
                pnmtbr->cbBytesPerRecord += sizeof(BUTTONSAVEINFO);
                pnmtbr->cButtons = (pnmtbr->cbData - sizeof(TOOLBARSAVEINFO)) / pnmtbr->cbBytesPerRecord;
                // make sure we did the math right and there are no remainders
                ASSERT(((pnmtbr->cbData - sizeof(TOOLBARSAVEINFO)) % pnmtbr->cbBytesPerRecord) == 0);

                //this is going to clobber all of the buttons in the current toolbar.
                // since toolbar control just writes over the dwords, we need to go free them now.
                int nButtons = (int) SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0L);

                for (int nTemp = 0; nTemp < nButtons; nTemp++)
                {
                    CMDMAP *pcm = _GetCmdMapByIndex(nTemp);
                    _FreeCmdMap(pcm);
                    TBBUTTONINFO tbbi;
                    tbbi.cbSize = sizeof(tbbi);
                    tbbi.lParam = (LPARAM)NULL;
                    tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
                    SendMessage(_hwnd, TB_SETBUTTONINFO, nTemp, (LPARAM)&tbbi);
                }
            }
            else
            {
                BUTTONSAVEINFO* pbsi = (BUTTONSAVEINFO*)pnmtbr->pCurrent;
                pnmtbr->pCurrent = (LPDWORD)(pbsi+1);
                pnmtbr->tbButton.dwData = 0;
                pnmtbr->tbButton.iString = -1;

                if (IsEqualGUID(CLSID_Separator, pbsi->guid))
                {
                    // restore a separator with a command id
                    pnmtbr->tbButton.fsStyle = BTNS_SEP;
                    TraceMsg(TF_TBCUST, "Restoring: a separator w/ id %d (%x)", pnmtbr->tbButton.idCommand, pnmtbr->tbButton.idCommand);
                }
                else if (!(pnmtbr->tbButton.fsStyle & BTNS_SEP))
                {
                    // Make sure that the button exists for this site
                    CMDMAPCUSTOMIZE* pcmc = _GetCmdMapCustomize(&pbsi->guid, pbsi->nCmdID);
                    if ((pcmc == NULL) || (SHRestricted(REST_NONLEGACYSHELLMODE) && ((pbsi->nCmdID == TBIDM_BACK) || (pbsi->nCmdID == TBIDM_FORWARD))))
                    {
                        // Ignore this button
                        return 1;
                    }

                    CMDMAP* pcm = (CMDMAP*)LocalAlloc(LPTR, sizeof(CMDMAP));
                    if (pcm)
                    {
                        pcm->guidButtonGroup = pbsi->guid;
                        pcm->nCmdID = pbsi->nCmdID;

#ifdef DEBUG
                        TCHAR szGuid[80];
                        SHStringFromGUID(pcm->guidButtonGroup, szGuid, ARRAYSIZE(szGuid));
                        TraceMsg(TF_TBCUST, "Restoring: %s - %d (%x)", szGuid, pbsi->nCmdID, pbsi->nCmdID);
#endif

                        // fill in the rest of the info
                        pnmtbr->tbButton = pcmc->btn;
                        pnmtbr->tbButton.fsState = pbsi->fButtonState;
                        pnmtbr->tbButton.dwData = (DWORD_PTR) pcm;

                    }
                }
                else
                {
                    TraceMsg(TF_TBCUST, "Restoring: a separator");
                }
            }
        }
        break;

    case TBN_ENDADJUST:
        _OnEndCustomize();
        break;

    case TBN_TOOLBARCHANGE:
        _pcinfo->fDirty = TRUE;
        break;

    case TBN_INITCUSTOMIZE:
        _OnBeginCustomize((NMTBCUSTOMIZEDLG*)pnmh);
        return TBNRF_HIDEHELP;

    case TBN_RESET:
        _pcinfo->fDirty = FALSE;
        if (_pctCurrentButtonGroup)
        {
            NMTBCUSTOMIZEDLG *pnm = (NMTBCUSTOMIZEDLG*)pnmh;
            CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
            TCHAR szGuid[GUIDSTR_MAX];
            SHStringFromGUID(_guidCurrentButtonGroup, szGuid, ARRAYSIZE(szGuid));
            SHDeleteValue(HKEY_CURRENT_USER, REGSTR_PATH_TOOLBAR, szGuid);

            // Default text labels setting should be as follows:
            //
            //  If fullscreen mode, any platform -- "No text labels"
            //  Else if NT5 -- "Selective text on right"
            //  Else  -- "Show text labels"
            //
            int idsDefault;

            if (pitbar->_fTheater)
                idsDefault = IDS_NOTEXTLABELS;
            else if (DEFAULT_LIST_VALUE())
                idsDefault = IDS_PARTIALTEXT;
            else
                idsDefault = IDS_TEXTLABELS;

            _UpdateTextSettings(idsDefault);

            HWND hwnd = (HWND) GetProp(pnm->hDlg, SZ_PROP_CUSTDLG);
            if (hwnd)
            {
                // update our dialog's control selection states
                _SetDialogSelections(hwnd, _DefaultToSmallIcons());
            }

            _RemoveAllButtons();
            _OnEndCustomize();
            if (_pbtnsAdded)
            {
                pitbar->AddButtons(&_guidCurrentButtonGroup, _cBtnsAdded, _pbtnsAdded);

                // Restore the edit button
                pitbar->_InitEditButtonStyle();

                pitbar->_UpdateToolbar(TRUE);
            }
            else
            {
                return TBNRF_ENDCUSTOMIZE;
            }
        }
        break;

    case TBN_QUERYINSERT:
        return TRUE;

    case TBN_QUERYDELETE:
        return (SendMessage(_hwnd, TB_ISBUTTONHIDDEN,
                            (WPARAM) ptbn->tbButton.idCommand,
                            (LPARAM) 0)) ? FALSE : TRUE;

    case TBN_GETBUTTONINFO:
        if (ptbn->iItem < DSA_GetItemCount(_pcinfo->hdsa))
        {
            CMDMAPCUSTOMIZE *pcmc;
            pcmc = (CMDMAPCUSTOMIZE*)DSA_GetItemPtr(_pcinfo->hdsa, ptbn->iItem);
            ptbn->tbButton = pcmc->btn;
            ptbn->tbButton.fsState &= ~TBSTATE_HIDDEN;
            return TRUE;
        }
        return FALSE;

    case TBN_BEGINADJUST:
        if (!_pcinfo || !_pcinfo->fAdjust)
            return 1;
        break;

    }
    return FALSE;
}

BOOL TOOLSBANDCLASS::_SaveRestoreToolbar(BOOL fSave)
{
    TBSAVEPARAMS tbsp;
    TCHAR szGuid[GUIDSTR_MAX];
    SHStringFromGUID(_guidCurrentButtonGroup, szGuid, ARRAYSIZE(szGuid));

    tbsp.hkr = HKEY_CURRENT_USER;
    tbsp.pszSubKey = REGSTR_PATH_TOOLBAR;
    tbsp.pszValueName = szGuid;
    BOOL fRet = BOOLFROMPTR(SendMessage(_hwnd, TB_SAVERESTORE, (WPARAM) fSave, (LPARAM) &tbsp));

    _FreeCustomizeInfo();
    return fRet;
}

void TOOLSBANDCLASS::_AddMediaBarButton()
{
    // Wrap this with a reg key to make sure it happens only once
    // then check to make sure it's not already in the thing

    if (_hwnd && !SHRestricted2W(REST_No_LaunchMediaBar, NULL, 0) && !SHRestricted2(REST_BTN_MEDIABAR, NULL, 0) && CMediaBarUtil::IsWMP7OrGreaterCapable())
    {
        DWORD dwType, dwSize;
        DWORD dwValue = TBBIF_NONE;
        dwSize = sizeof(dwValue);
        if (   (ERROR_SUCCESS==SHGetValue(HKEY_CURRENT_USER, TBBIF_REG_PATH, TBBIF_REG_KEY, &dwType, &dwValue, &dwSize))
            && (dwType==REG_DWORD)
            && ((dwValue & TBBIF_MEDIA) != 0))
        {
            return;
        }
        dwValue |= TBBIF_MEDIA;
        SHSetValue(HKEY_CURRENT_USER, TBBIF_REG_PATH, TBBIF_REG_KEY, REG_DWORD, &dwValue, sizeof(dwValue));

        TBBUTTONINFO tbbi;
        tbbi.cbSize = sizeof(tbbi);
        tbbi.dwMask = TBIF_STATE | TBIF_BYINDEX | TBIF_LPARAM;

        int iFavs = -1, iHist = -1, iLastTool = -1;
        int iMedia = -1;
        
        // lookup MediaBar in current toolbar
        // this could be a previous PersonalBar since the MediaBar reuses the cmdID
        BOOL fFound = FALSE;
        int cntButtons = (int)SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0);
        for (int j = 0; j < cntButtons; j++)
        {
            if (SendMessage(_hwnd, TB_GETBUTTONINFO, j, (LPARAM)&tbbi)!=-1)
            {
                CMDMAP* pcm = (CMDMAP*)tbbi.lParam;
                if (pcm)
                {
                    // already present ?
                    if (pcm->nCmdID == TBIDM_MEDIABAR)
                    {
                        fFound = TRUE;  // no need to add, only care about updating position in toolbar
                        iMedia = j;
                    }
                    // will try placing after Favorites....
                    else if (pcm->nCmdID == TBIDM_FAVORITES)
                    {
                        iFavs = j;
                        iLastTool = j;
                    }
                    // ... and/or before History
                    else if (pcm->nCmdID == TBIDM_HISTORY)
                    {
                        iHist = j;
                        iLastTool = j;
                    }
                    // ... but at least after last found button in second group
                    else if (   (pcm->nCmdID == TBIDM_SEARCH)
                             || (pcm->nCmdID == TBIDM_ALLFOLDERS))
                    {
                        iLastTool = j;
                    }
                }                
            }
        }

        // force-expose MediaBar button at least once
        if (!fFound)
        {
            TBBUTTON tbXBar;
            memcpy((VOID*)&tbXBar, (VOID*)&c_tbExplorer[TBXID_MEDIABAR], sizeof(TBBUTTON));

            CMDMAP* pcm = (CMDMAP*)LocalAlloc(LPTR, sizeof(CMDMAP));
            if (pcm) 
            {
                pcm->guidButtonGroup = CLSID_CommonButtons;
                pcm->nCmdID = c_tbExplorer[TBXID_MEDIABAR].idCommand;

                tbXBar.idCommand = _nNextCommandID++;
                tbXBar.dwData = (LPARAM)pcm;
                SendMessage(_hwnd, TB_ADDBUTTONS, 1, (LPARAM)&tbXBar);
            }
        }

        if (iMedia < 0)
        {
            cntButtons = (int)SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0);
            for (j = cntButtons - 1; j >= 0; j--)
            {
                if (SendMessage(_hwnd, TB_GETBUTTONINFO, j, (LPARAM)&tbbi)!=-1)
                {
                    CMDMAP* pcm = (CMDMAP*)tbbi.lParam;
                    if (pcm)
                    {
                        // already present ?
                        if (pcm->nCmdID == TBIDM_MEDIABAR)
                        {
                            iMedia = j;
                            break;
                        }
                    }
                }
            }
        }

        // update position of MediaBar button
        // do we know a preferred position where the MediaBar button should move to?
        if ((iMedia >= 0) && ((iFavs >= 0) || (iHist >= 0) || (iLastTool >= 0)))
        {
            int iNewPos = -1;
            if (iFavs >= 0)
            {
                iNewPos = iFavs;
            }
            else if (iHist >= 0)
            {
                iNewPos = max(iHist - 1, 0);
            }
            else if (iLastTool >= 0)
            {
                iNewPos = iLastTool;
            }

            if (iNewPos >= 0)
            {
                if (iNewPos < iMedia)
                    SendMessage(_hwnd, TB_MOVEBUTTON, iMedia, iNewPos + 1);
                else
                    SendMessage(_hwnd, TB_MOVEBUTTON, iMedia, iNewPos);

                _SaveRestoreToolbar(TRUE);
                _RecalcButtonWidths();
            }
        }

    }
}

int TOOLSBANDCLASS::_CommandFromIndex(UINT uIndex)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_COMMAND | TBIF_BYINDEX;
    SendMessage(_hwnd, TB_GETBUTTONINFO, uIndex, (LPARAM)&tbbi);
    return tbbi.idCommand;
}

//  _btb._ConvertCmd()
//  This is used to covert a external Command ID to an internal ID or vice versa
//  If we are converting to an external ID then
//      call with pguidButtonGroup == NULL                  (to external:  pguidButtonGroup == NULL)
//      otherwise call with the external button group GUID  (to internal:  pguidOut == NULL)
HRESULT TOOLSBANDCLASS::_ConvertCmd(const GUID* pguidButtonGroup, UINT id, GUID* pguidOut, UINT * pid)
{
    HRESULT hres = E_FAIL;
    BOOL fToInternal = (bool) (pguidButtonGroup);

    ASSERT((pguidButtonGroup == NULL) ^ (pguidOut == NULL));

    // First look for the command
    if (fToInternal)
    {
        if (_hwnd)
        {
            int nCount = (int) SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0);
            for (int i = 0; i < nCount; i++)
            {
                CMDMAP *pcm = _GetCmdMapByIndex(i);

                if (pcm)
                {
                    // loop through the command mapping structures until we
                    // find this guid and id
                    if (IsEqualGUID(pcm->guidButtonGroup, *pguidButtonGroup) &&
                        id == pcm->nCmdID)
                    {
                        *pid = _CommandFromIndex(i);
                        hres = S_OK;
                        break;
                    }
                }
            }
        }
    }
    else
    {

        // going from toolbar id to commandtarget info
        CMDMAP *pcm = _GetCmdMapByID(id);
        if (pcm)
        {
            *pguidOut = pcm->guidButtonGroup;
            *pid = pcm->nCmdID;
            hres = S_OK;
        }
    }
    return hres;
}



LRESULT CInternetToolbar::_AddBitmapFromForeignModule(UINT uiGetMSG, UINT uiSetMSG, UINT uiCount, HINSTANCE hinst, UINT_PTR nID, COLORREF rgbMask)
{
    HBITMAP hBMPRaw = NULL, hBMPFixedUp = NULL;
    HBITMAP * phBmp = &hBMPFixedUp;
    BITMAP bmp;
    HIMAGELIST himlTemp;
    LRESULT lRes = 1L;
    BOOL fOk = TRUE;
    HDC dc = NULL, dcMemSrc = NULL, dcMemDest = NULL;
    HBITMAP hbmpOldDest = NULL, hbmpOldSrc = NULL;
    int cxOrg = 0;
    int xDest = 0, yDest = 0;
    RECT rect = {0,0,0,0};
    HBRUSH hbr = NULL;

    // What if hinst == NULL?  That means that nID is really an HBITMAP
    ASSERT( hinst != NULL );

    if (!(hBMPRaw = LoadBitmap(hinst, MAKEINTRESOURCE(nID))))
        return 0L;

    fOk = (BOOL)(GetObject(hBMPRaw, sizeof(BITMAP), &bmp) != 0);

    // Check is the size is OK
    if (fOk && (bmp.bmWidth != (LONG)(g_iToolBarLargeIconWidth * uiCount)) || (bmp.bmHeight != (LONG)g_iToolBarLargeIconHeight) )
    {
        int cxBmp;
        int cyBmp;

        if (g_fSmallIcons)
        {
            cxBmp = TB_SMBMP_CX;
            cyBmp = TB_SMBMP_CY;
        }
        else
        {
            cxBmp = g_iToolBarLargeIconWidth;
            cyBmp = g_iToolBarLargeIconHeight;
        }

        // If the height is 15, the we assume that this is one of the old bitmaps therefore
        // the width is 16. We cannot rely on the (bmp.bmWidth / uiCount) because some apps
        // like SecureFile give us a bitmap 192 wide and say that there are 10 glyphs in it.
        if (bmp.bmHeight == 15)
            cxOrg = 16;
        else
            cxOrg = bmp.bmWidth / (uiCount ? uiCount : 1);

        if (rgbMask)
            fOk = (BOOL)((hbr = CreateSolidBrush(rgbMask))!= NULL);

        if (fOk)
            fOk = (BOOL)((dc = GetDC(_btb._hwnd)) != NULL);

        if (fOk)
            fOk = (BOOL)((hBMPFixedUp = CreateCompatibleBitmap(dc, (cxBmp * uiCount), cyBmp)) != NULL);

        if (fOk)
            fOk = (BOOL)((dcMemSrc = CreateCompatibleDC(dc)) != NULL);

        if (fOk)
            fOk = (BOOL)((dcMemDest = CreateCompatibleDC(dc)) != NULL);

        if (!fOk)
            goto Error;

        hbmpOldSrc = (HBITMAP)SelectObject(dcMemSrc, hBMPRaw);
        hbmpOldDest = (HBITMAP)SelectObject(dcMemDest, hBMPFixedUp);

        rect.right = (cxBmp * uiCount);
        rect.bottom = cyBmp;
        if (rgbMask)
            FillRect(dcMemDest, &rect, hbr);

        for (UINT n = 0; n < uiCount; n++)
        {

            int cxCopy;
            int cyCopy;

            xDest = (n * cxBmp);
            if (cxOrg < cxBmp)
            {
                // if the bitmap is too small, we need to center it.
                // the amount we copy is the full bitmap
                cxCopy = cxOrg;
                xDest += ((cxBmp - cxOrg) / 2);
            }
            else
            {
                // if the bitmap is big enough, we align it to top left and
                // we strecth(shrink) it down to fit
                cxCopy = cxBmp;
            }

            if (bmp.bmHeight < cyBmp)
            {
                cyCopy = bmp.bmHeight;
                yDest = ((cyBmp - bmp.bmHeight) / 2);
            }
            else
            {
                cyCopy = cyBmp;
                yDest = 0;
            }
            StretchBlt(dcMemDest, xDest, yDest, cxOrg, bmp.bmHeight,
                   dcMemSrc, (cxOrg * n), 0, cxCopy, cyCopy, SRCCOPY);

        }

        SelectObject(dcMemDest, hbmpOldDest);
        SelectObject(dcMemSrc, hbmpOldSrc);
    }
    else
        phBmp = &hBMPRaw;

    if (!(himlTemp = (HIMAGELIST)SendMessage(_btb._hwnd, uiGetMSG, 0, 0L)))
    {
        TraceMsg(DM_ERROR, "CITBar::_AddBitmapFromForeignModule Failed - uiGetMSG SendMessage Failure");
        fOk = FALSE;
        goto Error;
    }

    if (rgbMask)
        lRes = ImageList_AddMasked(himlTemp, (HBITMAP)*phBmp, rgbMask);
    else
        lRes = ImageList_Add(himlTemp, (HBITMAP)*phBmp, NULL);

    if (lRes == -1)
    {
        TraceMsg(DM_ERROR, "CITBar::_AddBitmapFromForeignModule Failed - lRes == -1");
        fOk = FALSE;
        goto Error;
    }


    if (!SendMessage(_btb._hwnd, uiSetMSG, 0, (LPARAM)himlTemp))
    {
        TraceMsg(DM_ERROR, "CITBar::_AddBitmapFromForeignModule Failed - uiSetMSG SendMessage Failed");
        fOk = FALSE;
        goto Error;
    }

Error:
    if (hBMPFixedUp)
        DeleteObject(hBMPFixedUp);

    if (hBMPRaw)
        DeleteObject(hBMPRaw);

    if (dc)
        ReleaseDC(_btb._hwnd, dc);

    if (dcMemSrc)
        DeleteDC(dcMemSrc);

    if (dcMemDest)
        DeleteDC(dcMemDest);

    if (hbr)
        DeleteObject(hbr);

    if (!fOk)
        lRes = 0L;

    return lRes;
}

#define VERY_HIGH_NUMBER    4000
HRESULT CInternetToolbar::_LoadDefaultSettings()
{
    ZeroMemory(&_cs, sizeof(_cs));
    _cs.cbVer       = CBS_VERSION;

    _cs.bs[0].wID    = CBIDX_MENU;
    _cs.bs[0].cx     = VERY_HIGH_NUMBER;

    _cs.bs[1].wID    = CBIDX_BRAND;

    _cs.bs[2].wID    = CBIDX_TOOLS;
    _cs.bs[2].cx     = VERY_HIGH_NUMBER;
    _cs.bs[2].fStyle = RBBS_BREAK;

    _cs.bs[3].wID    = CBIDX_ADDRESS;
    _cs.bs[3].cx     = VERY_HIGH_NUMBER;
    _cs.bs[3].fStyle = RBBS_BREAK;

    _cs.bs[4].wID    = CBIDX_LINKS;

    if (!_fInitialPidlIsWeb)
    {
        // we're in shell view, or we're rooted.  for perf, don't bother creating the links band.
        if (IsOS(OS_WHISTLERORGREATER) && (IsOS(OS_PERSONAL)))
        {
            _cs.uiVisible = (VBF_MENU | VBF_TOOLS | VBF_BRAND);
        }
        else
        {
            _cs.uiVisible = (VBF_MENU | VBF_TOOLS | VBF_ADDRESS | VBF_BRAND);
        }
    }
    else
    {
        // web page
        _cs.uiVisible = (VBF_MENU | VBF_TOOLS | VBF_ADDRESS | VBF_LINKS | VBF_BRAND);
    }

    _cs.clsidVerticalBar = GUID_NULL;
    _cs.clsidHorizontalBar = GUID_NULL;
    _cs.fNoText = FALSE;
    _cs.fList = DEFAULT_LIST_VALUE();

    _fUsingDefaultBands = TRUE;

    return(NOERROR);
}

typedef struct tagCOOLBARSAVEv12    // IE4
{
    UINT        cbVer;
    UINT        uiMaxTBWidth;
    UINT        uiMaxQLWidth;
#ifdef UNIX
    BITBOOL     fUnUsed : 28;       // unused
#endif
    BOOL        fVertical : 1;      // The bar is oriented vertically
    BOOL        fNoText :1;         // "NoText"
    BOOL        fAutoHide : 1;      // Auto hide toolbar in theater mode
    BOOL        fStatusBar : 1;     // Status bar in theater mode
    BOOL        fSaveInShellIntegrationMode : 1;     // Did we save in shell
    UINT        uiVisible;          // "Visible bands"
    UINT        cyRebar;
    BANDSAVE    bs[5];
} COOLBARSAVEv12;

typedef struct tagCOOLBARSAVEv15    // IE5 Beta2
{
    UINT        cbVer;
    UINT        uiMaxTBWidth;
    UINT        uiMaxQLWidth;
#ifdef UNIX
    BITBOOL     fUnUsed : 28;       // unused
#endif
    BITBOOL     fVertical : 1;      // The bar is oriented vertically
    BITBOOL     fNoText :1;         // "NoText"
    BITBOOL     fList : 1;          // toolbar is TBSTYLE_LIST (text on right) + TBSTYLE_EX_MIXEDBUTTONS
    BITBOOL     fAutoHide : 1;      // Auto hide toolbar in theater mode
    BITBOOL     fStatusBar : 1;     // Status bar in theater mode
    BITBOOL     fSaveInShellIntegrationMode : 1;     // Did we save in shell integration mode?
    UINT        uiVisible;          // "Visible bands"
    UINT        cyRebar;
    BANDSAVE    bs[5];
    CLSID       clsidVerticalBar;       //clsid of bar persisted within vertical band
    CLSID       clsidHorizontalBar;
} COOLBARSAVEv15;

#define CB_V12  (sizeof(COOLBARSAVEv12))
#define CB_V13  (sizeof(COOLBARSAVEv15))
#define CB_V14  CB_V13          // 14: added fList:1 (in middle!)
#define CB_V15  CB_V14          // 15: new rbbi.fStyle semantics
#define CB_V17  (sizeof(COOLBARSAVE))

HRESULT CInternetToolbar::_LoadUpgradeSettings(ULONG cbRead)
{
    // If we shipped with the CBS_VERSION you're incrementing, you need
    // to add upgrade code here for that version, then update this assertion.
    COMPILETIME_ASSERT(CBS_VERSION == 17);

    // Double-check our size calculations.
#ifndef UNIX
    COMPILETIME_ASSERT(CB_V12 == (6 * sizeof(UINT) + CBIDX_LAST * sizeof(BANDSAVE)));
#endif
    COMPILETIME_ASSERT(CB_V12 == (CB_V15 - sizeof(CLSID) * 2));
    COMPILETIME_ASSERT(CB_V13 == (CB_V12 + 2 * sizeof(CLSID)));
    COMPILETIME_ASSERT(CB_V14 == (CB_V13 + 0));
    COMPILETIME_ASSERT(CB_V15 == (CB_V14 + 0));
    COMPILETIME_ASSERT(CB_V17 == (CB_V15 + (MAXEXTERNALBANDS * sizeof(BANDSAVE)) + (MAXEXTERNALBANDS * sizeof(CLSID))));

    // If the stream was shorter than the version data field, there's nothing we can do.
    if (cbRead < sizeof(_cs.cbVer))
    {
        return E_FAIL;
    }

    // Check to see if the version is one we know about and that the stream
    // size is the same as that version's structure size.
    if (!((_cs.cbVer == 12 && cbRead == CB_V12) ||      // IE4
          (_cs.cbVer == 13 && cbRead == CB_V13) ||      // ?
          (_cs.cbVer == 14 && cbRead == CB_V14) ||      // ?
          (_cs.cbVer == 15 && cbRead == CB_V15)))       // IE5 Beta2
    {
        return E_FAIL;
    }

    TraceMsg(DM_WARNING, "citb._lus: try upgrade %d->%d", _cs.cbVer, CBS_VERSION);

    // Make a scratch copy of _cs so we don't worry about overwriting
    // parts of _cs we need to read later.
    COOLBARSAVE cs = _cs;

    if (_cs.cbVer == 12)
    {
        // clsidVerticalBar/clsidHorizontalBar weren't a part
        // of the structure until v13
        cs.clsidVerticalBar = GUID_NULL;
        cs.clsidHorizontalBar = GUID_NULL;
    }
    else
    {
        ASSERT(_cs.cbVer < 16);

        // Band array (bs) grew in v16 to include external bands, so
        // clsidVerticalBar/clsidHorizontalBar were at a different offset.
        COOLBARSAVEv15 *pv15 = (COOLBARSAVEv15 *) &_cs;
        cs.clsidVerticalBar = pv15->clsidVerticalBar;
        cs.clsidHorizontalBar = pv15->clsidHorizontalBar;
        cs.bs[CBIDX_LAST].wID = 0xFFFFFFFF;
    }

    if (InRange(_cs.cbVer, 12, 13))
    {
        // fList was inserted into the middle of the bitbool list in v14.
        // Copy the displaced bitbools and initialize fList.
        COOLBARSAVEv12 *pv12 = (COOLBARSAVEv12 *) &_cs;
        cs.fAutoHide = pv12->fAutoHide;
        cs.fStatusBar = pv12->fStatusBar;
        cs.fSaveInShellIntegrationMode = pv12->fSaveInShellIntegrationMode;
        cs.fList = DEFAULT_LIST_VALUE();
    }

    // Force FALSE as no longer support vertical itbar mode.
    cs.fVertical = FALSE;

    // Strip off any invalid visible band bits
    cs.uiVisible &= VBF_VALID;

    // Set current version and copy scratch cs back to _cs
    cs.cbVer = CBS_VERSION;
    _cs = cs;

    return S_OK;
}

HRESULT CInternetToolbar::_LoadDefaultWidths()
{
    // If there was no max width set for the QL bar or the Toolbar, then
    // before we use the default, check it the localization people wanted to
    // increase the width. The RC file string range from '0' to '9'
    TCHAR szScratch[16];
    UINT uiExtraWidth = 0;

    if (GetSystemMetrics(SM_CXSCREEN) < 650)
    {
        MLLoadString(IDS_TB_WIDTH_EXTRA_LORES, szScratch, ARRAYSIZE(szScratch));
        _uiMaxTBWidth = MAX_TB_WIDTH_LORES;
    }
    else
    {
        MLLoadString(IDS_TB_WIDTH_EXTRA_HIRES, szScratch, ARRAYSIZE(szScratch));
        _uiMaxTBWidth = MAX_TB_WIDTH_HIRES;
    }
    _uiMaxTBWidth += StrToInt(szScratch) * WIDTH_FACTOR;


    return(NOERROR);
}

BOOL IsClsidInHKCR(REFGUID pclsid)
{
    HKEY hkeyResult;

    if (SHRegGetCLSIDKeyW(pclsid, NULL, FALSE, FALSE, &hkeyResult) == ERROR_SUCCESS)
    {
        RegCloseKey(hkeyResult);
        return TRUE;
    }
    return FALSE;
}

typedef struct tagCOOLBARSAVEv2     // IE3
{
    UINT        cbVer;
    UINT        uiMaxTBWidth;
    UINT        uiMaxQLWidth;
    BOOL        fVertical;             // The bar is oriented vertically
    BANDSAVE    bs[4];
} COOLBARSAVEv2;

#define VBF_VALIDv2               (VBF_TOOLS | VBF_ADDRESS | VBF_LINKS)

void CInternetToolbar::_TryLoadIE3Settings()
{
    HKEY hKey;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegKeyCoolbar, 0, KEY_QUERY_VALUE, &hKey))
    {
        COOLBARSAVEv2 cbv2;
        DWORD dwcbData = sizeof(cbv2);
        if (SHQueryValueEx(hKey, TEXT("Layout"), NULL, NULL, (LPBYTE)&cbv2, &dwcbData) == ERROR_SUCCESS)
        {
            _cs.uiMaxTBWidth = cbv2.uiMaxTBWidth;
            _cs.uiMaxQLWidth = cbv2.uiMaxQLWidth;
            // FEATURE: todo -- read in bs field too; need to do some conversions as
            // CBIDX_ numbers were zero-based and there was no menuband in IE3.
        }

        BOOL fNoText;
        dwcbData = sizeof(fNoText);
        if (SHQueryValueEx(hKey, TEXT("NoText"), NULL, NULL, (LPBYTE)&fNoText, &dwcbData) == ERROR_SUCCESS)
        {
            // Set the no-text flag.
            _cs.fNoText = BOOLIFY(fNoText);
        }

        UINT uiVisible;
        dwcbData = sizeof(uiVisible);
        if (SHQueryValueEx(hKey, TEXT("VisibleBands"), NULL, NULL, (LPBYTE)&uiVisible, &dwcbData) == ERROR_SUCCESS)
        {
            // Set the visible bands, changing only the ones that IE3 knew about.
            _cs.uiVisible = (_cs.uiVisible &~ VBF_VALIDv2) | (uiVisible & VBF_VALIDv2);
        }

        RegCloseKey(hKey);
    }
}

VOID CInternetToolbar::_UpdateLocking()
{
    // if we have no gripper then turn them off
    BANDSITEINFO bsinfo;
    bsinfo.dwMask = BSIM_STYLE;
    bsinfo.dwStyle = BSIS_LEFTALIGN | (_fLockedToolbar ? BSIS_NOGRIPPER : 0);
    _bs.SetBandSiteInfo(&bsinfo);
    _bs._UpdateAllBands(FALSE, TRUE);
    ResizeBorderDW(NULL, NULL, FALSE);
}

HRESULT CInternetToolbar::Load(IStream *pstm)
{
    ULONG  ulRead;

    //Read from the given stream and initialize the Toolbar data!

    _fLoading = TRUE;
    HRESULT hr = pstm->Read(&_cs, sizeof(COOLBARSAVE), &ulRead);
    if (SUCCEEDED(hr))
    {
        if (ulRead != sizeof(COOLBARSAVE) || _cs.cbVer != CBS_VERSION)
        {
            hr = _LoadUpgradeSettings(ulRead);
        }
    }

    if (FAILED(hr))
    {
        _LoadDefaultSettings();
    }

    ASSERT(_cs.uiVisible & VBF_MENU);
    // make sure that the settings include a menu
    _cs.uiVisible |= VBF_MENU;

    _LoadDefaultWidths();
    hr = _CreateBands();

    _UpdateLocking();
    
    //if in web view, show the last visible browser bars too
    if (!_fShellView)
    {
        VARIANT varOut = {0};
        varOut.vt = VT_I4;

        if (!IsEqualGUID(_cs.clsidVerticalBar, GUID_NULL) && IsClsidInHKCR(_cs.clsidVerticalBar))
        {
            BOOL fSearch = IsEqualGUID(_cs.clsidVerticalBar, CLSID_SearchBand) 
                           || IsEqualGUID(_cs.clsidVerticalBar, CLSID_FileSearchBand);

            WCHAR wsz[GUIDSTR_MAX];
            SHStringFromGUID((const CLSID)_cs.clsidVerticalBar, wsz, ARRAYSIZE(wsz));

#ifdef UNIX
            // IEUNIX: Donot persist/load MsgBand
            if (!IsEqualGUID(_cs.clsidVerticalBar, CLSID_MsgBand))
#endif
            {
                if (!fSearch)
                {
                    VARIANT varClsid;
                    varClsid.vt = VT_BSTR;
                    varClsid.bstrVal = wsz;

                    IUnknown_Exec(_pbs2, &CGID_ShellDocView, SHDVID_SHOWBROWSERBAR, 1, &varClsid, &varOut);
                }
                else
                {
                    // if it's the search band, must be shown in this way to get correct search
                    VARIANTARG var;
                    var.vt = VT_I4;
                    var.lVal = -1;

                    Exec(&CLSID_CommonButtons, TBIDM_SEARCH, 0, NULL, &var);
                }
            }
        }

        if (!IsEqualGUID(_cs.clsidHorizontalBar, GUID_NULL) && IsClsidInHKCR(_cs.clsidHorizontalBar))
        {
            WCHAR wsz[GUIDSTR_MAX];
            SHStringFromGUID((const CLSID)_cs.clsidHorizontalBar, wsz, ARRAYSIZE(wsz));

            VARIANT varClsid;
            varClsid.vt = VT_BSTR;
            varClsid.bstrVal = wsz;

            IUnknown_Exec(_pbs2, &CGID_ShellDocView, SHDVID_SHOWBROWSERBAR, 1, &varClsid, &varOut);
        }
    }
    _fLoading = FALSE;

    return hr;
}

//see APPHACK note below
const GUID CLSID_AlexaVert = { 0xBA0B386CL, 0x7143, 0x11d1, 0xba, 0x8c, 0x00, 0x60, 0x08, 0x27, 0x87, 0x8d };
const GUID CLSID_AlexaHorz = { 0xBA0B386EL, 0x7143, 0x11d1, 0xba, 0x8c, 0x00, 0x60, 0x08, 0x27, 0x87, 0x8d };

void CInternetToolbar::_GetVisibleBrowserBar(UINT idBar, CLSID *pclsidOut)
{
    *pclsidOut = GUID_NULL;

    ASSERT(idBar == IDBAR_VERTICAL || idBar == IDBAR_HORIZONTAL);

    IDockingWindowFrame *psb;
    if (_psp && SUCCEEDED(_psp->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IDockingWindowFrame, &psb))))
    {
        IDeskBar* pdb;

        if ( (IDBAR_VERTICAL   == idBar && (SUCCEEDED(psb->FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdb))) && pdb)) ||
             (IDBAR_HORIZONTAL == idBar && (SUCCEEDED(psb->FindToolbar(COMMBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdb))) && pdb)) )
        {
            VARIANT varClsid = {0};

            if (SUCCEEDED(IUnknown_Exec(pdb, &CGID_DeskBarClient, DBCID_CLSIDOFBAR, 1, NULL, &varClsid)))
            {
                if (varClsid.vt == VT_BSTR)
                {
                    GUIDFromString(varClsid.bstrVal, pclsidOut);
                    VariantClear(&varClsid);
                }

//APPHACK
// Alexa 3.0 has some code so that their explorer bar persists that works in ie4. however, when ie5
// persists them, they don't handle the case where the main page has not finished loading yet, which
// causes them to fault on launch of the browser. see IE5 55895.
                if ( (IDBAR_VERTICAL   == idBar && (IsEqualGUID(*pclsidOut, CLSID_AlexaVert))) ||
                     (IDBAR_HORIZONTAL == idBar && (IsEqualGUID(*pclsidOut, CLSID_AlexaHorz))) )
                {
                    *pclsidOut = GUID_NULL;
                }
//END APPHACK
            }

            pdb->Release();
        }
        psb->Release();
    }
}

void CInternetToolbar::_BuildSaveStruct(COOLBARSAVE* pcs)
{
    REBARBANDINFO   rbbi;
    RECT rc;
    static BOOL fBrowserOnly = (WhichPlatform() != PLATFORM_INTEGRATED);

    //Save into the given stream!
    ZeroMemory(pcs, sizeof(*pcs));
    pcs->cbVer = CBS_VERSION;

    // Browser Only can't load Shell Integrated streams because of the Favorites
    // shell extension created pidls unreadable by browser only which doesn't have the Favorites ShellExt
    pcs->fSaveInShellIntegrationMode = !fBrowserOnly;

    GetWindowRect(_bs._hwnd, &rc);
    pcs->cyRebar = RECTHEIGHT(rc);
    //Save the new fields.
    pcs->fAutoHide = _fAutoHide;
    pcs->fNoText = _fCompressed;
    pcs->fList = IS_LIST_STYLE(_btb._hwnd);
    pcs->uiVisible = _nVisibleBands;

    //only persist the visible bars for web view
    if (!_fShellView)
    {
        _GetVisibleBrowserBar(IDBAR_VERTICAL, &pcs->clsidVerticalBar);
        _GetVisibleBrowserBar(IDBAR_HORIZONTAL, &pcs->clsidHorizontalBar);
    }
    //else pcs->clsid*Bar nulled out by memset above

    LRESULT lStyle = GetWindowLong(_bs._hwnd, GWL_STYLE);
    pcs->fVertical = BOOLIFY(lStyle & CCS_VERT);

    pcs->uiMaxTBWidth = _uiMaxTBWidth;

    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask = RBBIM_STYLE | RBBIM_SIZE | RBBIM_ID;
    int icBands = (int) SendMessage(_bs._hwnd, RB_GETBANDCOUNT, 0, 0);
    for (int i = 0; i < icBands; i++)
    {
        pcs->bs[i].wID = 0xFFFFFFFF;
        if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
        {
            if (rbbi.wID < CBANDSMAX)
            {
                // desk band objects have the choice of not saving there visibility
                // state
                CBandItemData *pbid = _bs._GetBandItem(i);
                if (pbid)
                {
                    UINT uiMask = rbbi.wID <= CBIDX_LAST ? ( 1 << (rbbi.wID - 1) ) : EXTERNALBAND_VBF_BIT(rbbi.wID - CBIDX_LAST-1);
                    if (pbid->pdb && (pcs->uiVisible & uiMask))
                    {
                        OLECMD cmd;
                        cmd.cmdID = CITIDM_DISABLEVISIBILITYSAVE;
                        cmd.cmdf = 0;
                        IUnknown_QueryStatus(pbid->pdb, &CGID_PrivCITCommands, 1, &cmd, NULL);
                        if (cmd.cmdf & OLECMDF_ENABLED)
                        {
                            pcs->uiVisible &= ~uiMask;
                            rbbi.fStyle |= RBBS_HIDDEN;
                        }
                    }
                    pbid->Release();
                }
                pcs->bs[i].fStyle = rbbi.fStyle;
                pcs->bs[i].cx = rbbi.cx;
                pcs->bs[i].wID = rbbi.wID;
                if (IS_EXTERNALBAND(rbbi.wID))
                {
                    pcs->aclsidExternalBands[MAP_TO_EXTERNAL(rbbi.wID)] = _rgebi[MAP_TO_EXTERNAL(rbbi.wID)].clsid;
                }
            }
        }
    }
    // Query CShellBrowser for status bar state
    VARIANTARG v = { 0 };
    v.vt = VT_I4;
    IUnknown_Exec(_ptbsite, &CGID_ShellBrowser, FCIDM_GETSTATUSBAR,
        0, NULL, &v);
    pcs->fStatusBar = v.lVal;
}

typedef struct tagCLSID_BANDTYPE
{
    const CLSID * pclsid;
    DWORD dwBandID;
} CLSID_BANDTYPE;

CLSID_BANDTYPE c_CLSIDsToSave[] =
{
    {&CLSID_AddressBand, CBIDX_ADDRESS},
    {&CLSID_QuickLinks, CBIDX_LINKS},
};

HRESULT CInternetToolbar::Save(IStream *pstm, BOOL fClearDirty)
{
    COOLBARSAVE cs;
    HRESULT hr = S_FALSE;

    // avoid the hit of saving when we are still loading.  State will not have
    // changed, at least not enough to justify saving, until after we are loaded.
    if (_fLoading)
        return S_OK;

    // Check the dirty bit to see if we need to save.
    if (!_fDirty)
        return S_OK;

    // if we failed during creation, our current state isnt good enough to persist.
    if (_fDontSave)
        return S_OK;

    ASSERT(!_fTheater);
    _BuildSaveStruct(&cs);

    if(SUCCEEDED(hr = pstm->Write(&cs, sizeof(COOLBARSAVE), NULL)) && fClearDirty)
        _fDirty = FALSE;

    REBARBANDINFO rbbi;
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask = RBBIM_ID;

    int icBands = (int) SendMessage( _bs._hwnd, RB_GETBANDCOUNT, 0, 0 );
    for (int i = 0; i < icBands; i++)
    {
        if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
        {
            if ((rbbi.wID == CBIDX_ADDRESS) || (rbbi.wID == CBIDX_LINKS) || IS_EXTERNALBAND(rbbi.wID))
            {
                CBandItemData *pbid = _bs._GetBandItem( i );
                if (pbid)
                {
                    if (pbid->pdb)
                    {
                        IPersistStream *pStream;
                        if (SUCCEEDED(pbid->pdb->QueryInterface(IID_PPV_ARG(IPersistStream, &pStream))))
                        {
                            CLSID clsid;
                            if (SUCCEEDED(pStream->GetClassID(&clsid)))
                            {
                                TCHAR szGUID[MAX_PATH];
                                SHStringFromGUID( clsid, szGUID, ARRAYSIZE(szGUID) );
                                IStream *pstm = GetRegStream( _fInitialPidlIsWeb, szGUID, STGM_WRITE | STGM_CREATE );
                                if (pstm)
                                {
                                    HRESULT hrInternal = _bs.SaveToStreamBS(pbid->pdb, pstm);

                                    // Only return Success values
                                    if (SUCCEEDED(hrInternal))
                                        hr = S_OK;
                                    pstm->Release();
                                }
                            }
                            pStream->Release();
                        }
                    }
                    pbid->Release();
                }
            }
        }
    }
    return(hr);
}

HRESULT CInternetToolbar::InitNew(void)
{
    // This shouldn't get called if Load has already been called, so assert
    // that _cs is uninitialized.
    ASSERT(_cs.cbVer == 0);

    _LoadDefaultSettings();

    // Look for any IE3 settings and override defaults with those.  (IE3
    // wrote structures directly to registry, rather than via IPersistStream).
    _TryLoadIE3Settings();

    _LoadDefaultWidths();

    return S_OK;
}

BOOL CInternetToolbar::_SendToToolband(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    return _bs._SendToToolband(hwnd, uMsg, wParam, lParam, plres);
}


HRESULT CInternetToolbar::IsDirty(void)
{
    if (_fDirty && !_fLoading)
        return S_OK;
    else
        return S_FALSE;
}


HRESULT CInternetToolbar::QueryService(REFGUID guidService,
                                       REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;
    HRESULT hr = E_NOTIMPL;

    if (IsEqualIID(guidService, SID_IBandProxy))
    {
        hr = QueryService_SID_IBandProxy(SAFECAST(_ptbsitect, IUnknown *), riid, &_pbp, ppvObj);
        if (!_pbp)
        {
            // We need to create it ourselves since our parent couldn't help
            ASSERT(FALSE == _fCreatedBandProxy);

            hr = CreateIBandProxyAndSetSite(SAFECAST(_ptbsitect, IUnknown *), riid, &_pbp, ppvObj);
            if (_pbp)
            {
                ASSERT(S_OK == hr);
                _fCreatedBandProxy = TRUE;
            }
        }
    }
    else if (IsEqualGUID(guidService, IID_IBandSite))
    {
        hr = _bs.QueryInterface(riid, ppvObj);
    }
    else if (IsEqualGUID(guidService, IID_IAddressBand))
    {
        hr = E_FAIL;
        CBandItemData *pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
        if (pbid)
        {
            if (pbid->pdb)
            {
                hr = pbid->pdb->QueryInterface(riid, ppvObj);
            }
            pbid->Release();
        }
    }
    else if (_psp)
    {
        hr = _psp->QueryService(guidService, riid, ppvObj);
    }
    else
    {
        hr = SUPERCLASS::QueryService(guidService, riid, ppvObj);
    }
    return hr;
}

//
// FEATURE: Do we really need to implement the following two functions?
// Currently nobody uses them.
//
HRESULT CInternetToolbar::GetClassID(GUID *pguid)
{
    *pguid = CLSID_InternetToolbar;
    return(S_OK);
}

HRESULT CInternetToolbar::GetSizeMax(ULARGE_INTEGER *ulMaxSize)
{
    ulMaxSize->LowPart = sizeof(COOLBARSAVE);
    ulMaxSize->HighPart = 0;
    return(S_OK);
}


CInternetToolbar::CITBandSite::CITBandSite() : CBandSite(NULL)
{
    // HACKHACK: set the initial band ID to something bigger
    //           than the number of toolbars that is in this
    //           object.  Currently those toolbars are not
    //           individual bands, but we want CBandSite to
    //           at least be aware of them.
    //
    _dwBandIDNext = CBANDSMAX;
}

HRESULT CInternetToolbar::CITBandSite::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _bs, this);
    pitbar->_ShowContextMenu((HWND)wParam, lParam, NULL);
    return S_OK;
}

HRESULT CInternetToolbar::CITBandSite::_Initialize(HWND hwndParent)
{
    _hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, REBARCLASSNAME, NULL,
                           RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_REGISTERDROP | RBS_DBLCLKTOGGLE |
                           WS_VISIBLE | WS_BORDER | WS_CHILD | WS_CLIPCHILDREN |
//                           WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN |
                           WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN,
                           0, 0, 100, 36, hwndParent, (HMENU) FCIDM_REBAR, HINST_THISDLL, NULL);

    if (_hwnd)
    {
        Comctl32_SetWindowTheme(_hwnd, TEXT("ExplorerToolbar"));
        SendMessage(_hwnd, RB_SETTEXTCOLOR, 0, CLR_DEFAULT);
        SendMessage(_hwnd, RB_SETBKCOLOR, 0, CLR_DEFAULT);
        SendMessage(_hwnd, CCM_SETVERSION, COMCTL32_VERSION, 0);
    }

    return CBandSite::_Initialize(hwndParent);
}


HRESULT CInternetToolbar::CITBandSite::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (!pguidCmdGroup)
    {
        /*NOTHING*/
    }
    else if (IsEqualGUID(CGID_PrivCITCommands, *pguidCmdGroup))
    {
        CInternetToolbar* pitbar = IToClass(CInternetToolbar, _bs, this);
        return pitbar->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    else if (IsEqualGUID(CGID_Theater, *pguidCmdGroup))
    {
        CInternetToolbar* pitbar = IToClass(CInternetToolbar, _bs, this);
        return IUnknown_Exec(pitbar->_ptbsite, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    return CBandSite::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

HRESULT CInternetToolbar::CITBandSite::AddBand(IUnknown *punk)
{
    HRESULT hres = CBandSite::AddBand(punk);
    if (SUCCEEDED(hres))
    {
        CInternetToolbar* pitbar = IToClass(CInternetToolbar, _bs, this);
        pitbar->_SetBackground();
    }
    return hres;
}

HRESULT CInternetToolbar::CITBandSite::HasFocusIO()
{
    HRESULT hres = CBandSite::HasFocusIO();
    if (hres == S_FALSE)
    {
        CInternetToolbar* pitbar = IToClass(CInternetToolbar, _bs, this);
        if (pitbar->_btb._hwnd == GetFocus())
            hres = S_OK;

    }
    return hres;
}

// This will remove all the buttons except the first 2
BOOL TOOLSBANDCLASS::_RemoveAllButtons()
{
    INT_PTR nCount = SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0L);

    if (!nCount)
        return FALSE;

    while (nCount-- > 0)
    {
        SendMessage(_hwnd, TB_DELETEBUTTON, nCount, 0L);
    }

    return S_OK;
}


HRESULT TOOLSBANDCLASS::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
     CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
    if (!pguidCmdGroup)
    {
        /*NOTHING*/
#ifdef DEBUG
    }
    else if (IsEqualGUID(*pguidCmdGroup, IID_IExplorerToolbar))
    {
        switch(nCmdID)
        {
        case ETCMDID_GETBUTTONS:
            // if this rips call tjgreen
            ASSERT(0);
            return E_FAIL;
        }
#endif
    }
    else if (_IsDocHostGUID(pguidCmdGroup))
    {
        UEMFireEvent(&UEMIID_BROWSER, UEME_UITOOLBAR, UEMF_XEVENT, UIG_INET, nCmdID);

        if (nCmdexecopt == OLECMDEXECOPT_PROMPTUSER)
        {
            // the user hit the drop down
            if (pitbar->_ptbsitect && pvarargIn && pvarargIn->vt == VT_INT_PTR)
            {
                // v.vt = VT_I4;
                POINT pt;
                RECT* prc = (RECT*)pvarargIn->byref;
                pt.x = prc->left;
                pt.y = prc->bottom;

                switch (nCmdID)
                {
                case DVIDM_EDITPAGE:
                    {
                        // Show the edit pop-up
                        BSTR bstrURL;
                        pitbar->_pdie->get_LocationURL(&bstrURL);
                        if (bstrURL)
                        {
                            pitbar->_aEditVerb.ShowEditMenu(pt,  pitbar->_hwnd, bstrURL);
                            SysFreeString(bstrURL);
                        }
                        break;
                    }

                default:
                    // if this rips find tjgreen
                    ASSERT(0);
                    break;
                }
            }
            return S_OK;
        }

        switch(nCmdID)
        {
        case DVIDM_EDITPAGE:
        {
            BSTR bstrURL;
            ULONG fMask = 0;
            TCHAR szCacheFileName[MAX_PATH + MAX_URL_STRING + 2];
            memset(szCacheFileName, 0, sizeof(szCacheFileName));

            pitbar->_pdie->get_LocationURL(&bstrURL);
            if (NULL == bstrURL)
                break;

            // Use the default edit verb
            pitbar->_aEditVerb.Edit(bstrURL);
        }
        break;

        default:
            // if this rips call tjgreen
            ASSERT(0);
            break;
        }
    }

    return S_OK;
}

// *** IInputObject methods ***
HRESULT TOOLSBANDCLASS::TranslateAcceleratorIO(LPMSG lpMsg)
{
    if (SendMessage(_hwnd, TB_TRANSLATEACCELERATOR, 0, (LPARAM)lpMsg))
        return S_OK;

    return CToolBand::TranslateAcceleratorIO(lpMsg);
}

// *** IUnknown methods ***
HRESULT TOOLSBANDCLASS::QueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(TOOLSBANDCLASS, IWinEventHandler),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres))
        hres = CToolBand::QueryInterface(riid, ppvObj);

    return hres;
}

// *** IDeskBand methods ***
HRESULT TOOLSBANDCLASS::GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi)
{

    _dwBandID = dwBandID;

    // set dwModeFlags
    pdbi->dwModeFlags = DBIMF_FIXEDBMP | DBIMF_USECHEVRON;

    // set ptMinSize
    {
        if (SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0))
        {
            // make our min size just big enough to show the first button
            RECT rc;
            SendMessage(_hwnd, TB_GETITEMRECT, 0, (LPARAM)&rc);
            pdbi->ptMinSize.x = RECTWIDTH(rc);
            pdbi->ptMinSize.y = RECTHEIGHT(rc);
        }
        else
        {
            // we don't have any buttons; so use standard button size
            LONG lButtonSize = (long) SendMessage(_hwnd, TB_GETBUTTONSIZE, 0, 0);
            pdbi->ptMinSize.x = LOWORD(lButtonSize);
            pdbi->ptMinSize.y = HIWORD(lButtonSize);
        }

        CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
        if (pitbar->_fTheater && (pdbi->ptMinSize.y < (THEATER_CYTOOLBAR - 1)))
            pdbi->ptMinSize.y = (THEATER_CYTOOLBAR - 1);
    }

    // set ptActual
    {
        SIZE size;
        size.cy = pdbi->ptMinSize.y;
        SendMessage(_hwnd, TB_GETIDEALSIZE, FALSE, (LPARAM)&size);
        pdbi->ptActual.x = size.cx;
        pdbi->ptActual.y = size.cy;
    }

    // no title
    pdbi->dwMask &= ~DBIM_TITLE;

    return S_OK;
}

IOleCommandTarget* TOOLSBANDCLASS::_CommandTargetFromCmdMap(CMDMAP* pcm)
{
    IOleCommandTarget* pct = NULL;

    if (pcm)
    {
        if (IsEqualGUID(pcm->guidButtonGroup, CLSID_CommonButtons))
        {
            CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
            pct = SAFECAST(pitbar, IOleCommandTarget*);
        }
        else
        {
            // If either of these rip, the button is stale
            ASSERT(IsEqualGUID(pcm->guidButtonGroup, _guidCurrentButtonGroup));
            ASSERT(_pctCurrentButtonGroup);

            pct = _pctCurrentButtonGroup;
        }
    }

    return pct;
}

BOOL ShiftRectToEdgeOfMonitor(RECT *prc)
{
    BOOL bRet = FALSE;
    POINT pt = {prc->left, prc->top};

    HMONITOR hmon = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);
    if (hmon)
    {
        MONITORINFO mi = {sizeof(MONITORINFO)};
        if (GetMonitorInfo(hmon, &mi))
        {
            // get the different between the monitor's left edge and the rect's left edge
            int iShift = mi.rcMonitor.left - prc->left;
            if (iShift > 0)
            {
                prc->left += iShift;
                prc->right += iShift;

                bRet = TRUE;
            }
        }
    }
    return bRet;
}

LRESULT TOOLSBANDCLASS::_OnToolbarDropDown(TBNOTIFY *ptbn)
{
    if (ptbn->hdr.hwndFrom == _hwnd)
    {
        CMDMAP* pcm = _GetCmdMapByID(ptbn->iItem);
        IOleCommandTarget* pct = _CommandTargetFromCmdMap(pcm);

        if (pct)
        {
            VARIANTARG var;
            var.vt = VT_I4;
            var.lVal = ptbn->iItem;

            // REARCHITECT: use VARIANT[TO/FROM]BUFFER here to fix win64 problem

            VARIANT v = {VT_INT_PTR};
            v.byref = &ptbn->rcButton;

            MapWindowRect(_hwnd, HWND_DESKTOP, &ptbn->rcButton);

            //
            // If this window is mirrored, then let's take the
            // other coordinate [samera]
            //
            if (IS_WINDOW_RTL_MIRRORED(_hwnd))
            {
                int iTmp = ptbn->rcButton.right;
                ptbn->rcButton.right = ptbn->rcButton.left;
                ptbn->rcButton.left  = iTmp;
            }

            // TrackMenuPopup is lame when confronted with negative co-ordinates... lets clip to the edge of the screen.
            ShiftRectToEdgeOfMonitor(&ptbn->rcButton);

            // FEATURE: temp code -- edit code moving to dochost.cpp
            if (_IsDocHostGUID(&pcm->guidButtonGroup) && pcm->nCmdID == DVIDM_EDITPAGE)
                Exec(&pcm->guidButtonGroup, (DWORD)pcm->nCmdID, OLECMDEXECOPT_PROMPTUSER, &v, &var);
            else
                pct->Exec(&pcm->guidButtonGroup, (DWORD)pcm->nCmdID, OLECMDEXECOPT_PROMPTUSER, &v, &var);
        }
    }

    return TBDDRET_DEFAULT;
}

LRESULT TOOLSBANDCLASS::_TryShowBackForwardMenu(DWORD dwItemSpec, LPPOINT ppt, LPRECT prcExclude)
{
    LRESULT lres = 0;

    GUID guid;
    UINT id;
    if (SUCCEEDED(_ConvertCmd(NULL, dwItemSpec, &guid, &id)))
    {
        // If the user right clicked on the the back or forward button, show the context menu
        // On all other buttons show the regular shortcut menu
        if (IsEqualGUID(guid, CLSID_CommonButtons))
        {
            CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
            if (id == TBIDM_BACK)
            {
                pitbar->_ShowBackForwardMenu(FALSE, *ppt, prcExclude);
                lres = 1;
            }
            else if (id == TBIDM_FORWARD)
            {
                pitbar->_ShowBackForwardMenu(TRUE, *ppt, prcExclude);
                lres = 1;
            }
        }
    }
    return lres;
}

LRESULT TOOLSBANDCLASS::_OnNotify(LPNMHDR pnmh)
{
    LRESULT lres = 0;

    ASSERT(pnmh->idFrom == FCIDM_TOOLBAR);

    switch (pnmh->code)
    {

    case NM_RCLICK:
        {
            NMCLICK * pnm = (LPNMCLICK)pnmh;

            if (!pnm)
                break;

            // Convert to Screen coordinates
            MapWindowPoints(pnmh->hwndFrom, HWND_DESKTOP, &pnm->pt, 1);

            if (pnmh->hwndFrom == _hwnd)
                lres = _TryShowBackForwardMenu((DWORD)pnm->dwItemSpec, &pnm->pt, NULL);
        }
        break;

    case TBN_DROPDOWN:
        lres = _OnToolbarDropDown((TBNOTIFY *)pnmh);
        break;

    case TBN_DELETINGBUTTON:
        _OnDeletingButton((TBNOTIFY*)pnmh);
        break;

    case TBN_SAVE:
    case TBN_RESET:
    case TBN_INITCUSTOMIZE:
    case TBN_RESTORE:
    case TBN_BEGINADJUST:
    case TBN_GETBUTTONINFO:
    case TBN_ENDADJUST:
    case TBN_QUERYDELETE:
    case TBN_QUERYINSERT:
    case TBN_TOOLBARCHANGE:
        if (pnmh->hwndFrom == _hwnd)
            lres = _ToolsCustNotify (pnmh);
        break;

    case TBN_GETOBJECT:
        {
            NMOBJECTNOTIFY *pnmon = (NMOBJECTNOTIFY *)pnmh;
            if (IsEqualIID(*pnmon->piid, IID_IDropTarget))
            {
                if (pnmh->hwndFrom == _hwnd)
                {
                    UINT uiCmd;
                    GUID guid;
                    _ConvertCmd(NULL, pnmon->iItem, &guid, &uiCmd);

                    if (IsEqualGUID(guid, CLSID_CommonButtons) &&
                            (uiCmd == TBIDM_HOME || uiCmd == TBIDM_FAVORITES))
                    {
                        CITBarDropTarget *pdtgt = new CITBarDropTarget(_hwnd, uiCmd);
                        if (pdtgt)
                        {
                            pnmon->pObject = SAFECAST(pdtgt, IDropTarget*);
                            pnmon->hResult = NOERROR;
                        }
                    }
                    else     // pass back CDropDummy to handle basics.
                    {
                        CDropDummy *pdtgt = new CDropDummy(_hwnd);
                        if (pdtgt)
                        {
                            pnmon->pObject = SAFECAST(pdtgt, IDropTarget*);
                            pnmon->hResult = NOERROR;
                        }
                    }

                }
                lres = TRUE;
            }
        }
        break;

    default:
        lres = CToolbarBand::_OnNotify(pnmh);
        break;
    }

    return lres;
}

LRESULT TOOLSBANDCLASS::_OnContextMenu(LPARAM lParam, WPARAM wParam)
{
    LRESULT lres = 0;

    if (IS_WM_CONTEXTMENU_KEYBOARD(lParam))
    {
        // keyboard context menu.  figure out where to pop up menu and
        // which context menu to use, and tell itbar to pop it up.
        RECT rc;
        BOOL fBackForward = FALSE;

        // figure out coordinates to use
        INT_PTR iBtn = SendMessage(_hwnd, TB_GETHOTITEM, 0, 0);
        if (iBtn != -1)
        {
            // use lower left corner of current hot button
            SendMessage(_hwnd, TB_GETITEMRECT, iBtn, (LPARAM)&rc);
        }
        else
        {
            // no hot button; use top left corner of tools window
            SetRect(&rc, 0, 0, 0, 0);
        }
        MapWindowPoints(_hwnd, HWND_DESKTOP, (LPPOINT)&rc, 2);

        if (iBtn != -1)
        {
            // get hot button's command
            TBBUTTONINFO tbbi;
            tbbi.cbSize = sizeof(TBBUTTONINFO);
            tbbi.dwMask = TBIF_BYINDEX | TBIF_COMMAND;
            SendMessage(_hwnd, TB_GETBUTTONINFO, iBtn, (LPARAM)&tbbi);

            POINT pt = {rc.left, rc.bottom};

            // try popping up the back/forward context menu
            if (_TryShowBackForwardMenu(tbbi.idCommand, &pt, &rc))
                fBackForward = TRUE;
        }

        if (!fBackForward)
        {
            // pop up the standard context menu
            CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
            pitbar->_ShowContextMenu((HWND)wParam, MAKELONG(rc.left, rc.bottom), (iBtn == -1 ? NULL : &rc));
        }

        lres = 1;
    }
    return lres;
}

void TOOLSBANDCLASS::_RecalcButtonWidths()
{
    // We need the toolbars buttons to use ONLY exactly as much space as is needed.
    // By setting the size a a really small number like 10, and then setting it to
    // the real number we can accomplish this.
    // If we don't use do this, then when we add new buttons after doing this
    // RemoveAllButtons(), the new buttons will be at least as wide as the widest
    // button that existed on the last set of buttons (the ones we are just removing)
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
    SendMessage(_hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM)MAKELONG(0, 10));
    SendMessage(_hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM)(pitbar->_fCompressed ? MAKELONG(0, MAX_TB_COMPRESSED_WIDTH) : MAKELONG(0, pitbar->_uiMaxTBWidth)));
}

// *** IWinEventHandler methods ***
HRESULT TOOLSBANDCLASS::OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HRESULT hres = S_OK;

    switch (dwMsg)
    {
    case WM_CONTEXTMENU:
        *plres = _OnContextMenu(lParam, wParam);
        break;

    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        break;

    case WM_WININICHANGE:
        *plres = SendMessage(_hwnd, dwMsg, wParam, lParam);
        if (wParam == SPI_SETNONCLIENTMETRICS)
        {
            _RecalcButtonWidths();
            _BandInfoChanged();
        }
        break;

    default:
        hres = CToolbarBand::OnWinEvent(hwnd, dwMsg, wParam, lParam, plres);
        break;
    }

    return hres;
}

CMDMAP* TOOLSBANDCLASS::_GetCmdMap(int i, BOOL fByIndex)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_LPARAM;
    tbbi.lParam = 0;
    if (fByIndex)
        tbbi.dwMask |= TBIF_BYINDEX;
    SendMessage(_hwnd, TB_GETBUTTONINFO, i, (LPARAM)&tbbi);
    return (CMDMAP*)(void*)tbbi.lParam;
}


void TOOLSBANDCLASS::_FreeCmdMap(CMDMAP* pcm)
{
    if (pcm)
        LocalFree(pcm);
}

void TOOLSBANDCLASS::_OnDeletingButton(TBNOTIFY* ptbn)
{
    CMDMAP *pcm = (CMDMAP*)(void*)ptbn->tbButton.dwData;
    _FreeCmdMap(pcm);
}

LONG_PTR TOOLSBANDCLASS::_AddString(LPWSTR pwstr)
{
    LONG_PTR lOffset;
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
    pitbar->AddString(&_guidCurrentButtonGroup, 0, (UINT_PTR)pwstr, &lOffset);

    return lOffset;
}

#define PPBS_LOOKINTOOLBAR  0x00000001
#define PPBS_EXTERNALBUTTON 0x00000002

void TOOLSBANDCLASS::_PreProcessButtonString(TBBUTTON *ptbn, DWORD dwFlags)
{
    // Caller should have checked this.
    ASSERT(!(ptbn->fsStyle & BTNS_SEP));

    // If we don't have a command target, we shouldn't have any external buttons.
    ASSERT(_pctCurrentButtonGroup || !(dwFlags & PPBS_EXTERNALBUTTON));

    if (ptbn->iString < 0 && ptbn->iBitmap <= MAX_SHELLGLYPHINDEX)
    {
        // total hack
        // we're hard coding the strings in to match
        // the bitmap.  so if anyone uses the shell bitmaps,
        // they're going to get our text labels
        // also hacking in that the bitmap array and string array are
        // matched
        // who designed reviewed this???

        ptbn->iString = ptbn->iBitmap;
    }
    else if (!ptbn->iString && (dwFlags & PPBS_EXTERNALBUTTON))
    {
        // Some Extensions are giving us bogus string ids (Font ext sends 0)
        ptbn->iString = -1;
    }
    else if (ptbn->iString != -1 && !IS_INTRESOURCE(ptbn->iString))
    {
        // It's a string pointer.  The customization mechanism requires that all buttons
        // use strings from the tb string pool.  So add the string to the pool and set
        // iString to the pool index.
        ptbn->iString = _AddString((LPWSTR)ptbn->iString);
    }

    if (ptbn->iString == -1 && IsFlagSet(dwFlags, PPBS_LOOKINTOOLBAR | PPBS_EXTERNALBUTTON))
    {
        // If we're building the customization dsa rather than adding new buttons to the
        // toolbar, we may already have this button in the toolbar.  If so, use that string.

        UINT idCommand;
        if (SUCCEEDED(_ConvertCmd(&_guidCurrentButtonGroup, ptbn->idCommand, NULL, &idCommand)))
        {
            TBBUTTON tbb;
            if (SendMessage(_hwnd, TB_GETBUTTON, idCommand, (LPARAM)&tbb))
                ptbn->iString = tbb.iString;
        }
    }

    if (ptbn->iString == -1 && (dwFlags & PPBS_EXTERNALBUTTON))
    {
        // Still don't have a string for this puppy.  Last resort is to ask via QueryStatus.
        OLECMDTEXTV<MAX_TOOLTIP_STRING> cmdtv;
        OLECMDTEXT *pcmdText = &cmdtv;

        pcmdText->cwBuf = MAX_TOOLTIP_STRING;
        pcmdText->cmdtextf = OLECMDTEXTF_NAME;
        pcmdText->cwActual = 0;

        OLECMD rgcmd = {ptbn->idCommand, 0};

        HRESULT hr = _pctCurrentButtonGroup->QueryStatus(&_guidCurrentButtonGroup, 1, &rgcmd, pcmdText);
        if (SUCCEEDED(hr) && (pcmdText->cwActual))
            ptbn->iString = _AddString(pcmdText->rgwz);
    }

    // If it's an internal button, we'd better have found a string for it.
    ASSERT(ptbn->iString != -1 || (dwFlags & PPBS_EXTERNALBUTTON));
}

void TOOLSBANDCLASS::_PreProcessExternalTBButton(TBBUTTON *ptbn)
{
    if (!(ptbn->fsStyle & BTNS_SEP))
    {
        CMDMAP* pcm = (CMDMAP*)LocalAlloc(LPTR, sizeof(CMDMAP));
        if (pcm)
        {
            pcm->guidButtonGroup = _guidCurrentButtonGroup;
            pcm->nCmdID = ptbn->idCommand;

            _PreProcessButtonString(ptbn, PPBS_EXTERNALBUTTON);

            _nNextCommandID++;
            pcm->lParam = ptbn->dwData;
        }

        ptbn->dwData = (LPARAM)pcm;
    }
    else
    {
        ptbn->dwData = 0;

        // override default toolbar width for separators; iBitmap member of
        // TBBUTTON struct is a union of bitmap index & separator width
        ptbn->iBitmap = CX_SEPARATOR;
    }
}

UINT TOOLSBANDCLASS::_ProcessExternalButtons(PTBBUTTON ptbb, UINT cButtons)
{
    cButtons = RemoveHiddenButtons(ptbb, cButtons);

    for (UINT i = 0; i < cButtons; i++)
        _PreProcessExternalTBButton(&ptbb[i]);

    return cButtons;
}

void TOOLSBANDCLASS::_GetButtons(IOleCommandTarget* pct, const GUID* pguid, HDSA hdsa)
{
    LONG lCount;
    VARIANTARG v1;
    VariantInit(&v1);
    v1.vt = VT_BYREF | VT_I4;
    v1.plVal = &lCount;

    VARIANTARG v2;
    VariantInit(&v2);
    if (SUCCEEDED(pct->Exec(&IID_IExplorerToolbar, ETCMDID_GETBUTTONS, 0, &v1, &v2)) && v2.vt == VT_BYREF)
    {
        CMDMAPCUSTOMIZE cmc;
        TBBUTTON* pbtn = (TBBUTTON*)v2.byref;

        cmc.cm.guidButtonGroup = *pguid;

        DWORD dwFlags = PPBS_LOOKINTOOLBAR;

        if (!IsEqualGUID(*pguid, CLSID_CommonButtons))
            dwFlags |= PPBS_EXTERNALBUTTON;

        for (long l = 0; l < lCount; l++)
        {
            cmc.btn = pbtn[l];
            if (!(cmc.btn.fsStyle & BTNS_SEP))
            {
                cmc.cm.nCmdID = pbtn[l].idCommand;

                _PreProcessButtonString(&cmc.btn, dwFlags);

                if (FAILED(_ConvertCmd(pguid, cmc.cm.nCmdID, NULL, (UINT*)&cmc.btn.idCommand)))
                {
                    // not already in the toolbar, generate a new id
                    cmc.btn.idCommand = _nNextCommandID++;
                }

                DSA_AppendItem(hdsa, &cmc);
            }
            else
            {
                cmc.btn.dwData = 0;
            }
        }
    }
}

void TOOLSBANDCLASS::_OnEndCustomize()
{

    if (_pcinfo)
    {
        // loop through and make sure that any items added have the appropriate cmdmap
        int i;
        INT_PTR nCount = SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0L);
        _pcinfo->fAdjust = FALSE;
        for(i = 0; i < nCount; i++)
        {
            CMDMAP* pcm = _GetCmdMapByIndex(i);
            if (!pcm)
            {
                // no command map for this item
                // find the corresponding CMDMAP in our hdsa, clone it and give it to this button.

                // the command id's are the same, so get the toolbar command id, find the corresponding
                // one in the hdsa and clone away.
                TBBUTTONINFO tbbi;
                tbbi.cbSize = sizeof(tbbi);
                tbbi.dwMask = TBIF_COMMAND | TBIF_BYINDEX;
                SendMessage(_hwnd, TB_GETBUTTONINFO, i, (LPARAM)&tbbi);

                int j;
                for (j = 0; j < DSA_GetItemCount(_pcinfo->hdsa); j++)
                {
                    CMDMAPCUSTOMIZE* pcmc = (CMDMAPCUSTOMIZE*)DSA_GetItemPtr(_pcinfo->hdsa, j);
                    ASSERT(pcmc);
                    if (pcmc->btn.idCommand == tbbi.idCommand)
                    {
                        // found it!

                        // clone the cmdmap
                        CMDMAP *pcm = (CMDMAP*)LocalAlloc(LPTR, sizeof(CMDMAP));
                        if (pcm)
                        {
                            *pcm = pcmc->cm;
                            tbbi.lParam = (LPARAM)pcm;
                            tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
                            SendMessage(_hwnd, TB_SETBUTTONINFO, i, (LPARAM)&tbbi);
                        }
                    }
                }
            }
        }

        if (_pcinfo->fDirty)
            _SaveRestoreToolbar(TRUE);
        
        _FreeCustomizeInfo();

        _RecalcButtonWidths();
        CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);

        pitbar->_InitEditButtonStyle();
        if (g_fSmallIcons != _UseSmallIcons())
        {
            SendShellIEBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)SZ_REGKEY_SMALLICONS, 3000);

            // Resize the Theater Controls based upon the icon changes.
            IUnknown_Exec( _punkSite, &CGID_Theater, THID_RECALCSIZING, 0, NULL, NULL );
        }

        pitbar->_UpdateToolbar(TRUE);
    }
}

void TOOLSBANDCLASS::_FreeCustomizeInfo()
{
    if (_pcinfo)
    {
        DSA_Destroy(_pcinfo->hdsa);
        _pcinfo->hdsa = NULL;
        LocalFree(_pcinfo);
        _pcinfo = NULL;
    }
}

CMDMAPCUSTOMIZE* TOOLSBANDCLASS::_GetCmdMapCustomize(GUID* pguid, UINT nCmdID)
{
    int j;
    for (j = 0; j < DSA_GetItemCount(_pcinfo->hdsa); j++)
    {
        CMDMAPCUSTOMIZE* pcmc = (CMDMAPCUSTOMIZE*)DSA_GetItemPtr(_pcinfo->hdsa, j);

        if (pcmc->cm.nCmdID == nCmdID &&
            IsEqualGUID(*pguid, pcmc->cm.guidButtonGroup))
        {
            return pcmc;
        }
    }

    return NULL;
}

BOOL TOOLSBANDCLASS::_BuildButtonDSA()
{
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);

    ASSERT(!_pcinfo);
    _pcinfo = (CUSTOMIZEINFO*)LocalAlloc(LPTR, sizeof(CUSTOMIZEINFO));

    if (_pcinfo)
    {
        // build a CMDMAP array of all the buttons available
        _pcinfo->hdsa = DSA_Create(sizeof(CMDMAPCUSTOMIZE), 4);

        if (_pcinfo->hdsa)
        {
            // add the common set (back,forward, stop, refresh, home and search
            _GetButtons(pitbar, &CLSID_CommonButtons, _pcinfo->hdsa);
            _GetButtons(_pctCurrentButtonGroup, &_guidCurrentButtonGroup, _pcinfo->hdsa);
            return TRUE;
        }
        else
        {
            _FreeCustomizeInfo();
            return FALSE;
        }
    }
    return FALSE;
}

void TOOLSBANDCLASS::_UpdateTextSettings(INT_PTR ids)
{
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);

    BOOL fText, fList;

    switch (ids)
    {
    case IDS_TEXTLABELS:
        fList = FALSE;
        fText = TRUE;
        break;

    case IDS_PARTIALTEXT:
        fList = TRUE;
        fText = TRUE;
        break;

    case IDS_NOTEXTLABELS:
        fList = FALSE;  // (but we really don't care)
        fText = FALSE;
        break;

    default:
        ASSERT(0);
        fList = FALSE;
        fText = FALSE;
        break;
    }

    pitbar->_UpdateToolsStyle(fList);

    // (_fCompressed == TRUE means no text labels)
    pitbar->_UpdateToolbarDisplay(UTD_TEXTLABEL, 0, !fText, TRUE);
}

const static DWORD c_aBtnAttrHelpIDs[] = {
    IDC_SHOWTEXT,       IDH_BROWSEUI_TB_TEXTOPTNS,
    IDC_SMALLICONS,     IDH_BROWSEUI_TB_ICONOPTNS,
    0, 0
};

BOOL_PTR CALLBACK TOOLSBANDCLASS::_BtnAttrDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CInternetToolbar* pitbar = (CInternetToolbar*)GetWindowPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);  /* LPADJUSTDLGDATA pointer */
        return TRUE;

    case WM_COMMAND:
        if (GET_WM_COMMAND_ID(wParam, lParam) == IDC_SHOWTEXT)
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELENDOK ||
                GET_WM_COMMAND_CMD(wParam, lParam) == CBN_CLOSEUP)
            {
                // what'd they pick?
                HWND hwndText = GET_WM_COMMAND_HWND(wParam, lParam);
                INT_PTR iSel = SendMessage(hwndText, CB_GETCURSEL, 0, 0);
                INT_PTR idsSel = SendMessage(hwndText, CB_GETITEMDATA, iSel, 0);

                pitbar->_btb._UpdateTextSettings(idsSel);

                return TRUE;
            }
        }
        break;

    case WM_CONTEXTMENU:
        SHWinHelpOnDemandWrap((HWND) wParam, c_szHelpFile,
            HELP_CONTEXTMENU, (DWORD_PTR)(LPTSTR) c_aBtnAttrHelpIDs);
        return TRUE;

    case WM_HELP:
        SHWinHelpOnDemandWrap((HWND) ((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPTSTR) c_aBtnAttrHelpIDs);
        return TRUE;

    case WM_DESTROY:
        {
#define SZ_YES  TEXT("yes")
#define SZ_NO   TEXT("no")

            HWND hwndIcons = GetDlgItem(hDlg, IDC_SMALLICONS);
            if (TPTR(hwndIcons))
            {
                INT_PTR iSel = SendMessage(hwndIcons, CB_GETCURSEL, 0, 0);
                BOOL fSmallIcons = (SendMessage(hwndIcons, CB_GETITEMDATA, iSel, 0) == IDS_SMALLICONS);

                LPCTSTR szData;
                DWORD cbData;

                if (fSmallIcons)
                {
                    szData = SZ_YES;
                    cbData = sizeof(SZ_YES);
                }
                else
                {
                    szData = SZ_NO;
                    cbData = sizeof(SZ_NO);
                }
                SHRegSetUSValue(SZ_REGKEY_SMALLICONS, SZ_REGVALUE_SMALLICONS, REG_SZ, (void*)szData, cbData, SHREGSET_FORCE_HKCU);
            }
        }
        return TRUE;
    }

    return FALSE;
}

void TOOLSBANDCLASS::_PopulateComboBox(HWND hwnd, const int iResource[], UINT cResources)
{
    TCHAR sz[256];

    // loop through iResource[], load each string resource and insert into combobox
    for (UINT i = 0; i < cResources; i++)
    {
        if (MLLoadString(iResource[i], sz, ARRAYSIZE(sz)))
        {
            INT_PTR iIndex = SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)sz);
            SendMessage(hwnd, CB_SETITEMDATA, iIndex, iResource[i]);
        }
    }
}

void TOOLSBANDCLASS::_SetComboSelection(HWND hwnd, int iCurOption)
{
    INT_PTR cItems = SendMessage(hwnd, CB_GETCOUNT, 0, 0);

    while (cItems--)
    {
        INT_PTR iItemData = SendMessage(hwnd, CB_GETITEMDATA, cItems, 0);

        if (iItemData == iCurOption)
        {
            SendMessage(hwnd, CB_SETCURSEL, cItems, 0);
            break;
        }
        else
        {
            // iCurOption should be in list somewhere;
            // assert that we're not done looking
            ASSERT(cItems);
        }
    }
}

void TOOLSBANDCLASS::_SetDialogSelections(HWND hDlg, BOOL fSmallIcons)
{
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);

    int iCurOption;
    HWND hwnd;

    hwnd = GetDlgItem(hDlg, IDC_SHOWTEXT);

    if (pitbar->_fCompressed)
        iCurOption = IDS_NOTEXTLABELS;
    else if (IS_LIST_STYLE(_hwnd))
        iCurOption = IDS_PARTIALTEXT;
    else
        iCurOption = IDS_TEXTLABELS;

    _SetComboSelection(hwnd, iCurOption);
    if (pitbar->_fTheater)
        SHSetWindowBits(hwnd, GWL_STYLE, WS_DISABLED, WS_DISABLED);

    hwnd = GetDlgItem(hDlg, IDC_SMALLICONS);
    iCurOption = (fSmallIcons ? IDS_SMALLICONS : IDS_LARGEICONS);
    _SetComboSelection(hwnd, iCurOption);
}

static const int c_iTextOptions[] = {
    IDS_TEXTLABELS,
    IDS_PARTIALTEXT,
    IDS_NOTEXTLABELS,
};

static const int c_iIconOptions[] = {
    IDS_SMALLICONS,
    IDS_LARGEICONS,
};

void TOOLSBANDCLASS::_PopulateDialog(HWND hDlg)
{
    HWND hwnd;

    hwnd = GetDlgItem(hDlg, IDC_SHOWTEXT);
    _PopulateComboBox(hwnd, c_iTextOptions, ARRAYSIZE(c_iTextOptions));

    hwnd = GetDlgItem(hDlg, IDC_SMALLICONS);
    _PopulateComboBox(hwnd, c_iIconOptions, ARRAYSIZE(c_iIconOptions));
}

void TOOLSBANDCLASS::_OnBeginCustomize(LPNMTBCUSTOMIZEDLG pnm)
{
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
    HWND hwnd = (HWND) GetProp(pnm->hDlg, SZ_PROP_CUSTDLG);

    if (!hwnd)
    {
        //
        // hasn't been initialized.
        //
        // we need to check this because this init will be called
        // when the user hits reset as well

        hwnd = CreateDialogParam(MLGetHinst(), MAKEINTRESOURCE(DLG_TEXTICONOPTIONS), pnm->hDlg, _BtnAttrDlgProc, (LPARAM)pitbar);
        if (hwnd)
        {
            // store hwnd of our dialog as property on tb cust dialog
            SetProp(pnm->hDlg, SZ_PROP_CUSTDLG, hwnd);

            // populate dialog controls
            _PopulateDialog(hwnd);

            // initialize dialog control selection states
            _SetDialogSelections(hwnd, g_fSmallIcons);

            RECT rc, rcWnd, rcClient;
            GetWindowRect(pnm->hDlg, &rcWnd);
            GetClientRect(pnm->hDlg, &rcClient);
            GetWindowRect(hwnd, &rc);

            // enlarge tb dialog to make room for our dialog
            SetWindowPos(pnm->hDlg, NULL, rcWnd.left, rcWnd.top + 64, RECTWIDTH(rcWnd), RECTHEIGHT(rcWnd) + RECTHEIGHT(rc), SWP_NOZORDER);

            // position our dialog at the bottom of the tb dialog
            SetWindowPos(hwnd, HWND_TOP, rcClient.left, rcClient.bottom, 0, 0, SWP_NOSIZE | SWP_SHOWWINDOW);
        }
    }

    if (_BuildButtonDSA())
    {
        _pcinfo->fAdjust = TRUE;
    }
}

class CBitmapPreload : public IRunnableTask
{
public:
    STDMETHOD ( QueryInterface ) ( REFIID riid, void ** ppvObj );
    STDMETHOD_( ULONG, AddRef ) ();
    STDMETHOD_( ULONG, Release ) ();

    STDMETHOD (Run)( void );
    STDMETHOD (Kill)( BOOL fWait );
    STDMETHOD (Suspend)( );
    STDMETHOD (Resume)( );
    STDMETHOD_( ULONG, IsRunning )( void );

protected:
    friend HRESULT CBitmapPreload_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

    CBitmapPreload();
    ~CBitmapPreload();

    LONG            m_cRef;
    LONG            m_lState;
};

STDAPI CBitmapPreload_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking and *ppunk zeroing are handled in class factory
    ASSERT(pUnkOuter == NULL);

    CBitmapPreload* pbp = new CBitmapPreload();

    if (pbp)
    {
        *ppunk = SAFECAST(pbp, IRunnableTask*);
        return S_OK;
    }
    else
    {
        *ppunk = NULL; // redundant but doesn't hurt
        return E_OUTOFMEMORY;
    }
}


CBitmapPreload::CBitmapPreload() : m_cRef(1)
{
    m_lState = IRTIR_TASK_NOT_RUNNING;
}


CBitmapPreload::~CBitmapPreload()
{
}


STDMETHODIMP CBitmapPreload::QueryInterface (REFIID riid, void ** ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBitmapPreload, IRunnableTask),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


STDMETHODIMP_( ULONG ) CBitmapPreload:: AddRef ()
{
    return InterlockedIncrement( &m_cRef );
}

STDMETHODIMP_( ULONG ) CBitmapPreload:: Release ()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement( &m_cRef );
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CBitmapPreload::Run ( void )
{
    if ( m_lState != IRTIR_TASK_NOT_RUNNING )
    {
        return E_FAIL;
    }

    InterlockedExchange( &m_lState, IRTIR_TASK_RUNNING );

    CInternetToolbar_Preload( );

    InterlockedExchange( &m_lState, IRTIR_TASK_FINISHED );

    return NOERROR;
}


STDMETHODIMP CBitmapPreload::Kill ( BOOL fWait )
{
    return E_NOTIMPL;
}


STDMETHODIMP CBitmapPreload::Suspend ( )
{
    return E_NOTIMPL;
}


STDMETHODIMP CBitmapPreload::Resume ( )
{
    return E_NOTIMPL;
}


STDMETHODIMP_( ULONG ) CBitmapPreload:: IsRunning ( void )
{
    return m_lState;
}




//+-------------------------------------------------------------------------
//  Constructor
//--------------------------------------------------------------------------
CInternetToolbar::CEditVerb::CEditVerb()
{
    ASSERT(_nElements == 0);
    ASSERT(_nDefault == 0);
    ASSERT(_pVerb == NULL);
    ASSERT(_lpfnOldWndProc == NULL);
    ASSERT(_pszDefaultEditor == NULL);
    ASSERT(_fInitEditor == FALSE);
}

//+-------------------------------------------------------------------------
//  Destructor
//--------------------------------------------------------------------------
CInternetToolbar::CEditVerb::~CEditVerb()
{
    if (_pVerb) RemoveAll();
    SetStr(&_pszDefaultEditor, NULL);
}

//+-------------------------------------------------------------------------
// Removes all cached edit verbs and associated memory
//--------------------------------------------------------------------------
void CInternetToolbar::CEditVerb::RemoveAll()
{
    if (_nElements > 0)
    {
        for (UINT i=0; i < _nElements; ++i)
        {
            EDITVERB& rVerb = _pVerb[i];

            SetStr(&rVerb.pszDesc, NULL);
            SetStr(&rVerb.pszMenuText, NULL);
            SetStr(&rVerb.pszExe, NULL);
            if (rVerb.hkeyProgID)
            {
                RegCloseKey(rVerb.hkeyProgID);
            }
            _ClearMSAAMenuInfo(rVerb);
        }

        LocalFree(_pVerb);

        _pVerb = NULL;
        _nElements = 0;
        _nDefault = 0;
    }
}

void _AddToOpenWithList(HKEY hkeyProgid, LPCWSTR pszVerb, LPCWSTR pszFileExt)
{
    ASSERT(hkeyProgid);
    ASSERT(pszVerb);
    ASSERT(pszFileExt);

    // First get the name of the exe
    WCHAR szPath[MAX_PATH];

    if (SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, hkeyProgid,
        pszVerb, szPath, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szPath)))))
    {
        // Now see if it is in the openwith list for the given file extension
        LPCWSTR pszExe = PathFindFileName(szPath);

        WCHAR szKey[MAX_PATH];
        wnsprintf(szKey, ARRAYSIZE(szKey), L"%s\\OpenWithList\\%s", pszFileExt, pszExe);
        HKEY hkey;

        DWORD dwDisp;
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, szKey, 0, L"", REG_OPTION_NON_VOLATILE,
                                      KEY_READ | KEY_WRITE, NULL, &hkey, &dwDisp))
        {
            // If we create a new key, we then need to check that verb is registered
            // for this app
            if (dwDisp == REG_CREATED_NEW_KEY)
            {
                AssocMakeApplicationByKey(ASSOCMAKEF_VERIFY, hkeyProgid, pszVerb);
            }
            RegCloseKey(hkey);
        }
    }
}

//+-------------------------------------------------------------------------
// Check registry for a default mhtml editor.  If a new editor is detected,
// it is added to the mhtml openwith list.
//--------------------------------------------------------------------------
void CInternetToolbar::CEditVerb::_InitDefaultMHTMLEditor()
{
    //
    // Check for a default MHTML editor.
    //
    HKEY hkeyEdit = NULL;
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_MHTML_EDITOR, 0, KEY_READ | KEY_WRITE, &hkeyEdit))
    {
        // Migrate hklm setting to hkcu
        HKEY hkeySrc;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DEFAULT_MHTML_EDITOR, 0, KEY_READ, &hkeySrc))
        {
            HKEY hkeyDest;
            // read/write needed
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_MHTML_EDITOR, 0, NULL,
                                                REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hkeyDest, NULL))
            {
                SHCopyKey(hkeySrc, NULL, hkeyDest, 0);
                hkeyEdit = hkeyDest;
            }
            RegCloseKey(hkeySrc);
        }
    }

    if (hkeyEdit)
    {
        // If the mhtml editor has changed, copy it into the mhtml openwithlist
        DWORD dwType;
        WCHAR szCurrent[MAX_PATH];
        DWORD cb = sizeof(szCurrent);
        if (ERROR_SUCCESS == SHGetValue(hkeyEdit, L"shell\\edit\\command", NULL, &dwType, szCurrent, &cb) &&
            dwType == REG_SZ)
        {
            WCHAR szLast[MAX_PATH];
            DWORD cb = sizeof(szLast);
            if (ERROR_SUCCESS != SHGetValue(hkeyEdit, NULL, L"Last", &dwType, szLast, &cb) ||
                (dwType == REG_SZ && StrCmp(szLast, szCurrent) != 0))
            {
                // Copy the MHTML editor into our MHTML openwithlist
                _AddToOpenWithList(hkeyEdit, L"edit", L".mhtml");

                // Remember that we migrated this key. Copying to the openwithlist can be slow
                // because we need to hit the disk to verify the exe name. So it's worth the effort
                // to avoid doing this unecessarily.
                SHSetValue(hkeyEdit, NULL, L"Last", REG_SZ, szCurrent, CbFromCch(lstrlen(szCurrent) +1));
            }
        }

        RegCloseKey(hkeyEdit);
    }
}

//+-------------------------------------------------------------------------
// Check registry for the friendly name of the default html editor.  This
// editor is configured by inetcpl or by office 2000.  If necessary, the
// associated verb is moved to the OpenWithList for .htm files.
//--------------------------------------------------------------------------
void CInternetToolbar::CEditVerb::InitDefaultEditor(HKEY hkey)
{
    //
    // First see if the default editor is in HKCU
    //
    HKEY hkeyEdit = hkey;
    if (hkey ||
        ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_HTML_EDITOR,
                                      0, KEY_READ | KEY_WRITE, &hkeyEdit))
    {
        //
        // See if we have a default editor selected
        //
        WCHAR szBuf[MAX_PATH];
        DWORD cbBuf = sizeof(szBuf);
        if (ERROR_SUCCESS == SHGetValue(hkeyEdit, NULL, L"Description", NULL, szBuf, &cbBuf))
        {
            // We got it!  Save the friendly name.
            PathRemoveBlanks(szBuf);
            SetStr(&_pszDefaultEditor, szBuf);
        }
        else
        {
            // No default editor description, so check to see if an edit verb was added.
            // (Office/inetcpl deletes the description key to signal to us that something changed).
            IQueryAssociations *pqa;

            if (SUCCEEDED(AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa))))
            {
                if (SUCCEEDED(pqa->Init(0, NULL, hkeyEdit, NULL)) &&
                ( SUCCEEDED(pqa->GetString(ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, L"edit", szBuf, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szBuf))))
                || SUCCEEDED(pqa->GetString(ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, NULL, szBuf, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szBuf))))))
                {
                    PathRemoveBlanks(szBuf);

                    // Save the name of the default editor
                    SetStr(&_pszDefaultEditor, szBuf);
                    SHSetValue(hkeyEdit, NULL, L"Description", REG_SZ, szBuf, CbFromCch(lstrlen(szBuf) +1));

                    // Add it to our openwithlist for .htm files
                    _AddToOpenWithList(hkeyEdit, L"edit", L".htm");
                }

                pqa->Release();
            }
        }

        // Close the key if it wasn't passed in
        if (hkeyEdit && NULL == hkey)
        {
            RegCloseKey(hkeyEdit);
        }
    }

    // During setup, Office places the orginial edit verb in HKLM. We need to copy this to HKCU.
    else if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DEFAULT_HTML_EDITOR, 0, KEY_READ, &hkeyEdit))
    {
        // Migrate this key into HKCU
        HKEY hkeyDest;
        // read/write necessary
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_HTML_EDITOR, 0, NULL,
                                            REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hkeyDest, NULL))
        {
            SHCopyKey(hkeyEdit, NULL, hkeyDest, 0);

            // Try again
            InitDefaultEditor(hkeyDest);
            RegCloseKey(hkeyDest);
        }
        RegCloseKey(hkeyEdit);
    }

    //
    // Check for a default MHTML editor.
    //
    if (hkey == NULL)   // Don't do on recursion
    {
        _InitDefaultMHTMLEditor();
    }
}

BOOL _GetAppKey(LPCWSTR pszApp, HKEY *phkApp)
{
    ASSERT(pszApp && *pszApp);
    WCHAR szKey[MAX_PATH];
    StrCpyN(szKey, L"Applications\\", ARRAYSIZE(szKey));
    StrCatBuff(szKey, pszApp, SIZECHARS(szKey));

    return (NOERROR == RegOpenKeyEx(
        HKEY_CLASSES_ROOT,
        szKey,
        0L,
        MAXIMUM_ALLOWED,
        phkApp));
}

//+-------------------------------------------------------------------------
// Make sure that notepad is registered in the OpenWithList for .htm files.
// This is called when this dll is registered (at setup time)
//--------------------------------------------------------------------------
void AddNotepadToOpenWithList()
{
    // Add notepad to the openwith list for .htm files
    HKEY hkeyOpenWith;
    DWORD dwDisp;
    // write access not necessary
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, L".htm\\OpenWithList\\notepad.exe", 0, L"",
                                        REG_OPTION_NON_VOLATILE, KEY_READ, NULL, &hkeyOpenWith, &dwDisp))
    {
        RegCloseKey(hkeyOpenWith);
    }
}

//+-------------------------------------------------------------------------
// Returns the friendly name of the default HTML editor
//--------------------------------------------------------------------------
LPCTSTR CInternetToolbar::CEditVerb::_GetDefaultEditor()
{
    // Do a lazy init of the default editor
    if (!_fInitEditor)
    {
        InitDefaultEditor();
        _fInitEditor = TRUE;
    }
    return _pszDefaultEditor;
}

//+-------------------------------------------------------------------------
// Gets the path of the exe associated with the verb and stores the
// result in rVerb.  The caller is responsible for freeing the string
// returned.
//--------------------------------------------------------------------------
LPCTSTR CInternetToolbar::CEditVerb::_GetExePath(EDITVERB& rVerb)
{
    // If we already have the path, simply return it
    if (NULL == rVerb.pszExe)
    {
        ASSERT(rVerb.hkeyProgID);
        TCHAR sz[MAX_PATH];
        if (SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, rVerb.hkeyProgID,
            rVerb.fUseOpenVerb ? NULL : L"edit", sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
            rVerb.pszExe = StrDup(sz);
    }

    return rVerb.pszExe;
}

//+-------------------------------------------------------------------------
// Returns TRUE if path of the exe associated with the verb is not found in
// any of the existing verbs.
//--------------------------------------------------------------------------
BOOL CInternetToolbar::CEditVerb::_IsUnique(EDITVERB& rNewVerb)
{
    // Get the friendly name of the new element
    LPCTSTR pszNewDesc = _GetDescription(rNewVerb);
    if (NULL == pszNewDesc)
    {
        // Executable must not exist
        return FALSE;
    }

    // Scan existing elements for the same executable
    for (UINT i=0; i < _nElements; ++i)
    {
        LPCTSTR pszDesc = _GetDescription(_pVerb[i]);
        if (pszDesc && (StrCmpI(pszNewDesc, pszDesc) == 0))
        {
            // Match found, so free the friendly name for the new verb
            SetStr(&rNewVerb.pszDesc, NULL);

            // If the new item shows its icon on the button, make the duplicate
            // do the same.
            if (rNewVerb.fShowIcon)
            {
                _pVerb[i].fShowIcon = TRUE;
                _nDefault = i;
            }
            return FALSE;
        }
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
// Some programs such as msothmed.exe act as stubs that redirect the edit
// command to the appropriate executable. This function returns true if
// the path contains the name of a known stub.
//--------------------------------------------------------------------------
BOOL CInternetToolbar::CEditVerb::_IsHtmlStub
(
    LPCWSTR pszPath
)
{
    BOOL fRet = FALSE;

    // Get the MULTISZ list of known redirectors
    TCHAR szRedir[MAX_PATH];
    ZeroMemory(szRedir, sizeof(szRedir)); // Protect against non-multisz strings in the reg
    DWORD dwType;
    DWORD cb = sizeof(szRedir) - 4;
    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_DEFAULT_HTML_EDITOR, L"Stubs", &dwType, szRedir, &cb))
    {
        // Nothing in registry, so default to ignore the Office redirector
        StrCpyN(szRedir, L"msohtmed.exe\0", ARRAYSIZE(szRedir));
    }

    // See if the path contains the name of a redirectors
    // Note that PathFindFileName doesn't work well for pathes with parameters so we just
    // check for the exe name in the path)
    for (LPTSTR p = szRedir; *p != NULL; p += lstrlen(p) + 1)
    {
        if (StrStrI(pszPath, p))
        {
            fRet = TRUE;
            break;
        }
    }
    return fRet;
}

//+-------------------------------------------------------------------------
//  Adds a new edit verb.  Returns a pointer to the new verb if it
//  successfully added.
//--------------------------------------------------------------------------
CInternetToolbar::CEditVerb::EDITVERB* CInternetToolbar::CEditVerb::_Add
(
    HKEY hkeyProgID,        // location of of verb
    BOOL fPermitOpenVerb,   // permit open as well as edit verb
    BOOL fCheckForOfficeApp,// redirect to office app
    BOOL fShowIcon          // if button face icon should be customized
)
{
    EDITVERB* pNewVerb = NULL;

    if (hkeyProgID)
    {
        BOOL fUseOpenVerb = FALSE;

        //
        // See if an appropriate verb exists.
        //
        TCHAR szCommand[MAX_PATH];
        HRESULT hr = AssocQueryStringByKey(0, ASSOCSTR_COMMAND, hkeyProgID, L"edit", szCommand, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szCommand)));
        if (FAILED(hr) && fPermitOpenVerb)
        {
            hr = AssocQueryStringByKey(0, ASSOCSTR_COMMAND, hkeyProgID, NULL, szCommand, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szCommand)));
            if (SUCCEEDED(hr))
            {
                fUseOpenVerb = TRUE;
            }
        }

        // If no verb or if this is the office redirector, ignore this progid
        // Otherwise we can get two entries that do the same thing.
        if (FAILED(hr) || _IsHtmlStub(szCommand))
        {
            RegCloseKey(hkeyProgID);
            return NULL;
        }

        if (fCheckForOfficeApp)
        {
            ASSERT(*szCommand);

            //
            // HACK: Office2000 needs us to call a special proxy to get around thier DDE bugs and
            // to check the HTML document for the name of the original document.  These problems
            // should be fixed in the apps themselves.
            //
            // So if this is an office app, we will redirect to the appropriate progid. Note that
            // we don't need to do this if a progid was from the html meta tag because this progid
            // already supports the proxy.
            //
            struct OfficeHackery {LPCWSTR pszApp; LPCWSTR pszProgID;};

            // Must not have been a progid passed in.
            static const OfficeHackery exeToProgID[] =
            {
                {L"winword",   L"Word.Document"},
                {L"excel",     L"Excel.Sheet"},
                {L"powerpnt",  L"PowerPoint.Slide"},
                {L"msaccess",  L"Access.Application"},
                {L"frontpg",   L"FrontPage.Editor.Document"},
            };

            for (int i=0; i < ARRAYSIZE(exeToProgID); ++i)
            {
                if (StrStrI(szCommand, exeToProgID[i].pszApp))
                {
                    // Match found!
                    HKEY hkeyOffice = NULL;
                    if (SUCCEEDED(AssocQueryKey(0, ASSOCKEY_SHELLEXECCLASS, exeToProgID[i].pszProgID, NULL, &hkeyOffice)))
                    {
                        // Redirect to the office progid
                        RegCloseKey(hkeyProgID);
                        hkeyProgID = hkeyOffice;

                        // The office apps always use the open verb
                        fUseOpenVerb = TRUE;

                        // The icon is shown on the button face for office apps
                        fShowIcon = TRUE;
                    }
                    break;
                }
            }
        }

        EDITVERB newVerb = {0};
        newVerb.hkeyProgID = hkeyProgID;
        newVerb.fUseOpenVerb = fUseOpenVerb;
        newVerb.fShowIcon = fShowIcon;

        // Ignore it if we have another verb to the same exe.
        if (!_IsUnique(newVerb))
        {
            RegCloseKey(hkeyProgID);
        }
        else
        {
            EDITVERB* pVerbsNew;
            if (_pVerb == NULL)
            {
                pVerbsNew = (EDITVERB*)LocalAlloc(LPTR, sizeof(EDITVERB));
                ASSERT(_nElements == 0);
            }
            else
            {
                pVerbsNew = (EDITVERB*)LocalReAlloc(_pVerb, (_nElements+1) * sizeof(EDITVERB), LMEM_MOVEABLE | LMEM_ZEROINIT);
            }

            if (pVerbsNew == NULL)
            {
                RegCloseKey(hkeyProgID);
            }
            else
            {
                _pVerb = pVerbsNew;
                pNewVerb = &_pVerb[_nElements];
                *pNewVerb = newVerb;

                //
                // If the description of the executable matches that of the default editor, make
                // it our default edit verb.  If we are not checking for the office app, we
                // can assume that this verb was from a progid in an html file and we will also
                // make it our default.
                //
                LPCWSTR pszDefDesc = _GetDefaultEditor();
                LPCWSTR pszNewDesc = _GetDescription(*pNewVerb);

                if (!fCheckForOfficeApp ||
                    (pszDefDesc && pszNewDesc && StrCmp(pszDefDesc, pNewVerb->pszDesc) == 0))
                {
                    _nDefault = _nElements;
                }

                ++_nElements;
            }
        }
    }

    return pNewVerb;
}

//+-------------------------------------------------------------------------
//  Adds a new edit verb.  Returns TRUE if a verb was successfully added.
//--------------------------------------------------------------------------
BOOL CInternetToolbar::CEditVerb::Add
(
    LPTSTR pszProgID    // program id or file extension associated with verb
)
{
    ASSERT(pszProgID);

    BOOL fRet = FALSE;
    BOOL fFileExt = (pszProgID[0] == TEXT('.'));

    //
    // Open the associated reg key and try to add it to our list of verbs
    //
    BOOL fUseOpenVerb = FALSE;
    HKEY hkeyProgID = NULL;
    BOOL fPermitOpenVerb = !fFileExt;
    BOOL fShowIcon = !fFileExt;    // If a progid was passed in, we will show the icon on the button face

    if (SUCCEEDED(AssocQueryKey(0, ASSOCKEY_SHELLEXECCLASS, pszProgID, NULL, &hkeyProgID)))
    {
        EDITVERB* pNewVerb = _Add(hkeyProgID, fPermitOpenVerb, fFileExt, fShowIcon);
        if (pNewVerb)
        {
            fRet = TRUE;
        }
    }

    //
    // If a file extension was passed in, we also add the alternative editors from the
    // OpenWithList
    //
    if (fFileExt)
    {
        WCHAR szOpenWith[MAX_PATH];
        StrCpyN(szOpenWith, pszProgID, ARRAYSIZE(szOpenWith));
        StrCatBuff(szOpenWith, L"\\OpenWithList", ARRAYSIZE(szOpenWith));

        HKEY hkeyOpenWithList;

        // See if there is an OpenWithList
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szOpenWith, 0, KEY_READ, &hkeyOpenWithList))
        {
            DWORD dwIndex = 0;
            DWORD dwSize = ARRAYSIZE(szOpenWith);
            HKEY hkeyOpenWith = NULL;
            while (ERROR_SUCCESS == RegEnumKeyEx(hkeyOpenWithList, dwIndex, szOpenWith, &dwSize, NULL, NULL, NULL, NULL))
            {
                if (_GetAppKey(szOpenWith, &hkeyOpenWith))
                {
                    // We only permit the edit verbs from here
                    EDITVERB* pNewVerb = _Add(hkeyOpenWith, FALSE, TRUE, FALSE);
                    if (pNewVerb)
                    {
                        fRet = TRUE;
                    }

                    ++dwIndex;

                    // Note that we don't close hkeyOpenWith here.  It is either closed if it was not added, or
                    // it will be closed later.
                }
                else
                {
                    // Invalid entry, so try to fix it (may be old format):
                    //
                    // In IE5.0 we use to store the friendly names of apps in the openwithlist.  For shell compatibility, we need
                    // to convert these entries to store the exe name instead:
                    //
                    //  ----> permanent entries are stored un HKCR
                    //  HKCR
                    //     \.Ext
                    //         \OpenWithList
                    //             \app.exe
                    //
                    //  ----> and applications or the system can write app association here
                    //     \Applications
                    //         \APP.EXE
                    //             \shell...
                    //         \foo.exe
                    //             \shell...
                    //
                    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyOpenWithList, szOpenWith, 0, KEY_READ, &hkeyOpenWith))
                    {
                        _AddToOpenWithList(hkeyOpenWith, L"edit", L".htm");

                        // Remove the invalid entry
                        if (ERROR_SUCCESS != SHDeleteKey(hkeyOpenWith, L""))
                        {
                            // NOTE (andrewgu): ie5.5 b#108551 - on locked-down nt5 this will fail
                            // and if dwIndex is not incremented, will result in an infinite loop.
                            dwIndex++;
                        }

                        RegCloseKey(hkeyOpenWith);
                    }
                }
                dwSize = ARRAYSIZE(szOpenWith);
            }

            RegCloseKey(hkeyOpenWithList);
        }

        //
        // If a ".htm" or ".html" was passed in, add our default html editor
        //
        if ((StrCmpI(pszProgID, L".htm") == 0 || StrCmpI(pszProgID, L".html") == 0) &&
            _GetDefaultEditor())
        {
            HKEY hkeyDefault;
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_HTML_EDITOR, 0, KEY_READ, &hkeyDefault))
            {
                if (_Add(hkeyDefault, TRUE, TRUE, FALSE))
                {
                    fRet = TRUE;
                }
            }
        }
    }

    return fRet;
}

//+-------------------------------------------------------------------------
// Returns the tooltip for the default edit verb
//--------------------------------------------------------------------------
BOOL CInternetToolbar::CEditVerb::GetToolTip
(
    LPTSTR pszToolTip,
    UINT cchMax,
    BOOL fStripAmpersands
)
{
    if (_nElements == 0)
    {
        return FALSE;
    }

    // Use the menu text for the tooltip.
    _FormatMenuText(_nDefault);

    // Copy text stripping out any ampersands
    LPWSTR pszDest = pszToolTip;
    LPWSTR pszSrc = _GetVerb(_nDefault).pszMenuText;
    if (0 < cchMax)
    {
        // Leave room for the null terminator
        while (0 < --cchMax)
        {
            // strip out '&'
            if (fStripAmpersands)
            {
                while (*pszSrc == L'&')
                {
                    ++pszSrc;
                }
            }

            if ( !(*pszDest++ = *pszSrc++) )
            {
                --pszDest;
                break;
            }
        }

        if (0 == cchMax)
            *pszDest = L'\0';

        ASSERT(*pszDest == 0);

        //
        // In some locals, the accelerator is identified in brackets at the
        // end of the string, so if we strip ampersands, we strip these too.
        //
        if (fStripAmpersands && --pszDest >= pszToolTip && *pszDest == L')')
        {
            while (--pszDest >= pszToolTip)
            {
                if (*pszDest == L'(')
                {
                    *pszDest = L'\0';
                    break;
                }
            }
        }
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
// "Lazy-fetches" the verb info, and returns the desired info.
//--------------------------------------------------------------------------
CInternetToolbar::CEditVerb::EDITVERB& CInternetToolbar::CEditVerb::_GetVerb(UINT nIndex)
{
    ASSERT(nIndex < _nElements);

    // We fetch the info when first asked for it.
    if (!_pVerb[nIndex].fInit)
    {
        _FetchInfo(nIndex);
        _pVerb[nIndex].fInit = TRUE;
    }
    return _pVerb[nIndex];
}

//+-------------------------------------------------------------------------
// Gets the name of the app associated with the verb.
//--------------------------------------------------------------------------
LPCTSTR CInternetToolbar::CEditVerb::_GetDescription(EDITVERB& rVerb)
{
    // If we already have a description, we are done
    if (NULL == rVerb.pszDesc)
    {
        ASSERT(rVerb.hkeyProgID);

        TCHAR sz[MAX_PATH];
        if (SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, rVerb.hkeyProgID,
            rVerb.fUseOpenVerb ? NULL : L"edit", sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
        {
            rVerb.pszDesc = StrDup(sz);
            if (rVerb.pszDesc)
            {
                // Remove preceeding and trailing blanks
                PathRemoveBlanks(rVerb.pszDesc);
            }
        }
    }

    return rVerb.pszDesc;
}

//+-------------------------------------------------------------------------
// Reads the info associated with the progid at the given index.  This
// function allows us to do a lazy fetch of the info when requested.
//--------------------------------------------------------------------------
void CInternetToolbar::CEditVerb::_FetchInfo(UINT nIndex)
{
    ASSERT(nIndex < _nElements);
    ASSERT(_pVerb[nIndex].hkeyProgID != NULL);

    EDITVERB& rVerb = _pVerb[nIndex];

    //
    // Get the path to the edit verb's exe
    //
    if (_GetExePath(rVerb))
    {
        ASSERT(rVerb.pszExe);

        // Note that we fetched the friendly name earlier
        ASSERT(rVerb.pszDesc);

        // Now get the icon
        rVerb.iIcon = Shell_GetCachedImageIndex(rVerb.pszExe, 0, 0);
    }
    else
    {
        rVerb.iIcon = -1;
    }
}

//+-------------------------------------------------------------------------
// SetMSAAMenuInfo()
//
// Fills in MSAAMenuInfo part of EDITVERB from the other fields of the rVerb
//--------------------------------------------------------------------------

void CInternetToolbar::CEditVerb::_SetMSAAMenuInfo( EDITVERB& rVerb )
{
    rVerb.m_MSAA.m_CharLen = lstrlen( rVerb.pszMenuText );
    rVerb.m_MSAA.m_pWStr = rVerb.pszMenuText;

    // Finally, add MSAAINFO signature...
    rVerb.m_MSAA.m_MSAASig = MSAA_MENU_SIG;
}


//+-------------------------------------------------------------------------
// ClearMSAAMenuInfo()
//
// Clean up MSAAMenuInfo - specifically, release the allocated
// UNICODE string, if appropriate...
//--------------------------------------------------------------------------

void CInternetToolbar::CEditVerb::_ClearMSAAMenuInfo( EDITVERB& rVerb )
{
    // Paranoia - clear signature...
    rVerb.m_MSAA.m_MSAASig = 0;
}


//+-------------------------------------------------------------------------
// Shows the edit pop-up menu.
//--------------------------------------------------------------------------
BOOL CInternetToolbar::CEditVerb::ShowEditMenu(POINT pt, HWND hwnd, LPTSTR pszURL)
{
    BOOL  bRet  = FALSE;
    HMENU hmEdit = CreatePopupMenu();

    if (hmEdit)
    {
        UINT idCmd = FCIDM_EDITFIRST;
        UINT nMax = FCIDM_EDITLAST - FCIDM_EDITFIRST;

        // Add each verb to the menu
        for (UINT i=0; i<_nElements && i < nMax; ++i)
        {
            EDITVERB& rVerb = _GetVerb(i);
            _FormatMenuText(i);
            rVerb.idCmd = idCmd;
            AppendMenu(hmEdit, MF_OWNERDRAW, idCmd, (LPCTSTR) &rVerb );

            // Fix up MSAAMenuInfo part...
            _SetMSAAMenuInfo( rVerb );

            ++idCmd;
        }

        // Temporarily subclass the hwnd to intercept the owner-draw messages
        if (SetProp(hwnd, SZ_EDITVERB_PROP, this))
        {
            ASSERT(!_lpfnOldWndProc);
            _lpfnOldWndProc = (WNDPROC) SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) _WndProc);

            idCmd = ITBar_TrackPopupMenuEx(hmEdit, TPM_RETURNCMD, pt.x, pt.y, hwnd, NULL);

            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)_lpfnOldWndProc);
            _lpfnOldWndProc = NULL;
            RemoveProp(hwnd, SZ_EDITVERB_PROP);

            if (InRange(idCmd, FCIDM_EDITFIRST, FCIDM_EDITLAST))
            {
                // Execute the selected edit verb
                _Edit(pszURL, idCmd - FCIDM_EDITFIRST);
            }
        }

        DestroyMenu(hmEdit);
    }

    return bRet;
}

//+-------------------------------------------------------------------------
// Creates a menu string from the progid's description
//--------------------------------------------------------------------------
void CInternetToolbar::CEditVerb::_FormatMenuText(UINT nIndex)
{
    ASSERT(nIndex < _nElements);

    EDITVERB& rVerb = _GetVerb(nIndex);
    if (rVerb.pszMenuText == NULL)
    {
        if (_GetDescription(rVerb))
        {
            TCHAR szFormat[100];
            TCHAR szMenuText[200];

            MLLoadString(IDS_EDITWITH, szFormat, ARRAYSIZE(szFormat));
            wnsprintf(szMenuText, ARRAYSIZE(szMenuText), szFormat, rVerb.pszDesc);
            SetStr(&((EDITVERB&)rVerb).pszMenuText, szMenuText);
        }
        else
        {
            // Things are really messed up
            ASSERT(FALSE);
            SetStr(&((EDITVERB&)rVerb).pszMenuText, TEXT(""));
        }
    }
}


//+-------------------------------------------------------------------------
// Executes the edit verb indicated by nIndex.
//--------------------------------------------------------------------------
void CInternetToolbar::CEditVerb::_Edit
(
    LPCTSTR pszURL,     // url assocated with the verb
    UINT nIndex         // verb to execute
)
{
    ASSERT(pszURL);

    if (nIndex >= _nElements)
    {
        return;
    }

    EDITVERB& rVerb = _pVerb[nIndex];
    int fMask = SEE_MASK_CLASSKEY;

    SHELLEXECUTEINFO sei = {0};

    TCHAR szCacheFileName[MAX_PATH + MAX_URL_STRING + 2];
    memset(szCacheFileName, 0, sizeof(szCacheFileName));

    if (PathIsURL(pszURL))
    {
        // We pass the url if the app has register that it wants this
        if ((WhichPlatform() == PLATFORM_BROWSERONLY) && DoesAppWantUrl(rVerb.pszExe))
        {
            //
            // Old versions of shell32 (PLATFORM_BROWSERONLY) ignore the SEE_MASK_FILEANDURL
            // flag, so on these platforms we check ourselves to see if the app
            // wants the url instead of the cache file name.
            //
            StrCpyN(szCacheFileName, pszURL, ARRAYSIZE(szCacheFileName));
            sei.lpFile = szCacheFileName;
        }
        else
        {
            // (reinerf)
            // Some apps (FrontPad, Office99, etc) want the URL passed to
            // them instead of the cache filename. We therefore create a string
            // that has the URL name after the null:
            //
            //  "CacheFileName/0UrlName"
            //
            // and pass it as the lpFile parameter to shellexecute.
            // We also pass SEE_MASK_FILEANDURL, so shellexecute can
            // recognize this case.
            //
            int iLength;

            if (FAILED(URLToCacheFile(pszURL, szCacheFileName, ARRAYSIZE(szCacheFileName))))
            {
                // Frontpage express crashes if we pass a null file name, so if the app doesn't
                // prefer the url instead, we bail.
                if (!DoesAppWantUrl(rVerb.pszExe))
                {
                    return;
                }
            }
            iLength = lstrlen(szCacheFileName);

            // copy in the URL name
            StrCpyN(&szCacheFileName[iLength + 1], pszURL, ARRAYSIZE(szCacheFileName) - (iLength + 1));

            // add the mask so shellexecute knows to check for the URL, if necessary.
            fMask |= SEE_MASK_FILEANDURL;
            sei.lpFile = szCacheFileName;
        }
    }
    else
    {
        // Not a URL, so pass the filename
        StrCpyN(szCacheFileName, pszURL, ARRAYSIZE(szCacheFileName));
        sei.lpFile = szCacheFileName;
    }

    // Hack for IE5 bug 50033 - Can remove when fpxpress fixes mru buffer overrun
    _GetExePath(rVerb);
    if(StrStr(rVerb.pszExe, TEXT("fpxpress.exe")) != NULL)
        szCacheFileName[256] = TEXT('\0');

    sei.cbSize = sizeof(SHELLEXECUTEINFO);
    sei.fMask = fMask;
    sei.hwnd = NULL;
    sei.lpVerb = rVerb.fUseOpenVerb ? NULL : TEXT("edit");
    sei.lpDirectory = NULL;
    sei.nShow = SW_SHOWNORMAL;
    sei.hInstApp = NULL;
    sei.hkeyClass= rVerb.hkeyProgID;

    //
    // The office guys want us to call a special proxy to get around some DDE problems
    // and to sniff the html file for the original document name. Hackers! So let's
    // see if it is registered.
    //
    HKEY hkeyProxy = NULL;
    if (ERROR_SUCCESS == RegOpenKeyEx(rVerb.hkeyProgID, TEXT("HTML Handler"), 0, KEY_READ, &hkeyProxy))
    {
        DWORD cch;
        if (SUCCEEDED(AssocQueryStringByKey(0, ASSOCSTR_COMMAND, hkeyProxy, L"edit", NULL, &cch)))
        {
            sei.lpVerb = L"edit";
            sei.hkeyClass = hkeyProxy;
        }
        else if (SUCCEEDED(AssocQueryStringByKey(0, ASSOCSTR_COMMAND, hkeyProxy, NULL, NULL, &cch)))
        {
            sei.lpVerb = NULL;
            sei.hkeyClass = hkeyProxy;
        }
    }

    // executing "edit" on the URL or the file in the cache.
    // UTF problems going from the URL to the filename shouldnt happen since we're forcing it to come from
    // the cache -- GetUrlCacheEntryInfoEx will hit the disk to get a valid cache entry so people wont be able
    // to spoof the URL somehow to fake up a bad shellexecute.
    ShellExecuteEx(&sei);

    if (hkeyProxy)
    {
        RegCloseKey(hkeyProxy);
    }
}

//+-------------------------------------------------------------------------
// This window procedure intercepts owner-draw menu messages when the edit
// pop-up menu is displayed.
//--------------------------------------------------------------------------
LRESULT CALLBACK CInternetToolbar::CEditVerb::_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CEditVerb* pThis = (CEditVerb*)GetProp(hwnd, SZ_EDITVERB_PROP);

    if (!pThis)
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);

    switch(uMsg)
    {
        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        {
            UINT idCmd;

            switch (uMsg)
            {
                case WM_DRAWITEM:
                    idCmd = ((EDITVERB*)((DRAWITEMSTRUCT*)lParam)->itemData)->idCmd;
                    break;
                case WM_MEASUREITEM:
                    idCmd = ((EDITVERB*)((MEASUREITEMSTRUCT*)lParam)->itemData)->idCmd;
                    break;
            }

            if (InRange(idCmd, FCIDM_EDITFIRST, FCIDM_EDITLAST))
            {
                // do our own measuring
                UINT index  = idCmd - FCIDM_EDITFIRST;
                const EDITVERB& rVerb = pThis->_GetVerb(index);

                // We don't want the same accelerator on all items,
                // so remove underlines
                WCHAR wzBuf[MAX_PATH];
                UINT cchMax = ARRAYSIZE(wzBuf);
                LPWSTR pszTo = wzBuf;
                LPWSTR pszFrom = rVerb.pszMenuText;
                if (pszFrom)
                {
                    while (0 < --cchMax)
                    {
                        if (*pszFrom == L'&')
                        {
                            pszFrom++;
                            continue;
                        }

                        if ( !(*pszTo++ = *pszFrom++) )
                        {
                            --pszTo;
                            break;
                        }
                    }

                    if (0 == cchMax)
                        *pszTo = L'\0';

                    //
                    // In some locals, the accelerator is identified in brackets at the
                    // end of the string, so if we strip ampersands, we strip these too.
                    //
                    if (--pszTo >= wzBuf && *pszTo == L')')
                    {
                        while (--pszTo >= wzBuf)
                        {
                            if (*pszTo == L'(')
                            {
                                *pszTo = L'\0';
                                break;
                            }
                        }
                    }
                }
                else
                {
                    wzBuf[0] = 0;
                }

                switch (uMsg)
                {
                    case WM_MEASUREITEM:
                        MeasureMenuItem((MEASUREITEMSTRUCT *)lParam, wzBuf);
                        break;
                    case WM_DRAWITEM:
                        int iIcon = (rVerb.iIcon != -1) ? rVerb.iIcon : 0;
                        DrawMenuItem((LPDRAWITEMSTRUCT)lParam, wzBuf, iIcon);
                        break;
                }
            }
        }
        default:
           return CallWindowProc(pThis->_lpfnOldWndProc, hwnd, uMsg, wParam, lParam);
    }
    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\libx.cpp ===
//***   libx.cpp -- 'source library' inclusions
// DESCRIPTION
//  there are some things that we share in source (rather than .obj or .dll)
// form.  this file builds them in the current directory.

#include "priv.h"

#include "..\inc\uassist.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy.h ===
#ifndef __LEGACY_H__
#define __LEGACY_H__

#include "logo.h"

#define CGID_MenuBand CLSID_MenuBand
#define CGID_ISFBand  CLSID_ISFBand
#define SID_SDropBlocker CLSID_SearchBand


// REARCHITECT: An exercise for the reader, how many of these are unused now?
#define MBANDCID_GETFONTS       1       // Command Id for getting font info
#define MBANDCID_RECAPTURE      2       // Take the mouse capture back
#define MBANDCID_NOTAREALSITE   3       // This is not a real site
#define MBANDCID_SELECTITEM     5       // Select an item
#define MBANDCID_POPUPITEM      6       // Popup an item
#define MBANDCID_ITEMDROPPED    7       // Item was dropped into a menu
#define MBANDCID_DRAGENTER      8       // Entering a drag operation
#define MBANDCID_DRAGLEAVE      9       // Leaving a Drag operation
#define MBANDCID_ISVERTICAL     10      // Is this a vertical band
#define MBANDCID_RESTRICT_CM    11      // Disallow ContextMenu
#define MBANDCID_RESTRICT_DND   12      // Disallow Drag And Drop
#define MBANDCID_EXITMENU       13      // Nofity: Exiting Menu
#define MBANDCID_ENTERMENU      14      // Notify: Entering Menu
#define MBANDCID_SETACCTITLE    15      // Sets the title of the band
#define MBANDCID_SETICONSIZE    16
#define MBANDCID_SETFONTS       17
#define MBANDCID_SETSTATEOBJECT 18      // Sets the global state
#define MBANDCID_ISINSUBMENU    19      // Returns S_OK if in submenu, S_FALSE if not.
#define MBANDCID_EXPAND         20      // Cause this band to expand
#define MBANDCID_KEYBOARD       21      // Popuped up because of a keyboard action
#define MBANDCID_DRAGCANCEL     22      // Close menus because of drag
#define MBANDCID_REPOSITION     23      // 
#define MBANDCID_EXECUTE        24      // sent to the site when somethis is executed.
#define MBANDCID_ISTRACKING     25      // Tracking a Context Menu

HRESULT ToolbarMenu_Popup(HWND hwnd, LPRECT prc, IUnknown* punk, HWND hwndTB, int idMenu, DWORD dwFlags);

class CISFBand;
HRESULT CISFBand_CreateEx(IShellFolder * psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv);

typedef enum {
    ISFBID_PRIVATEID        = 1,
    ISFBID_ISITEMVISIBLE    = 2,
    ISFBID_CACHEPOPUP       = 3,
    ISFBID_GETORDERSTREAM   = 4,
    ISFBID_SETORDERSTREAM   = 5,
} ISFBID_FLAGS;

HRESULT CExtractImageTask_Create( CLogoBase* plb,
                                  LPEXTRACTIMAGE pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  LPRUNNABLETASK * ppTask );

#define EITF_SAVEBITMAP     0x00000001  // do not delete bitmap on destructor
#define EITF_ALWAYSCALL     0x00000002  // always call the update whether extract succeded or not

extern long g_lMenuPopupTimeout;

#define QLCMD_SINGLELINE 1

#define CITIDM_VIEWTOOLS     4      // This toggles on/off
#define CITIDM_VIEWADDRESS   5      // This toggles on/off
#define CITIDM_VIEWLINKS     6      // This toggles on/off
#define CITIDM_SHOWTOOLS     7      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_SHOWADDRESS   8      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_SHOWLINKS     9      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_EDITPAGE      10
#define CITIDM_BRANDSIZE     11     // brand at minimum always or not
#define CITIDM_VIEWMENU      12      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_VIEWAUTOHIDE  13      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_GETMINROWHEIGHT 14    // gets the minimum height of row 0... for branding
#define CITIDM_SHOWMENU      15
#define CITIDM_STATUSCHANGED 16
#define CITIDM_GETDEFAULTBRANDCOLOR 17
#define CITIDM_DISABLESHOWMENU      18
#define CITIDM_SET_DIRTYBIT         19  // nCmdexecopt equals TRUE or FALSE which will overwrite _fDirty.
#define CITIDM_VIEWTOOLBARCUSTOMIZE       20
#define CITIDM_VIEWEXTERNALBAND_BYCLASSID 21
#define CITIDM_DISABLEVISIBILITYSAVE 22 // bands can choose not to persist their visibility state
#ifdef UNIX
#define CITIDM_SHOWBRAND     25     //nCmdExecOpt:  TRUE or FALSE 
#endif 
#define CITIDM_GETFOLDERSEARCHES        26

// iBar/xBar stuff
#define CITIDM_VIEWLOCKTOOLBAR     27

#define TOOLBAR_MASK 0x80000000

#endif // __LEGACY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\itbdrop.cpp ===
//
//  ITBDROP.CPP
//  routines for implementing OLE drop target capability
//  within the internet toolbar control
//
//  History:
//      07/13/96 t-mkim     Created
//      10/13/96 chrisg     massive cleanup
//

#include "priv.h"
#include "itbdrop.h"
#include "sccls.h"

#include "resource.h"

#include "mluisupp.h"

#ifdef UNIX

#ifdef SIZEOF
#undef SIZEOF
#endif
#define SIZEOF(x)   sizeof(x)       // has been checked for UNICODE correctness

#endif

#define MAX_NAME_QUICKLINK 40

// Data type of the incoming data object.
#define CITBDTYPE_NONE      0
#define CITBDTYPE_HDROP     1
#define CITBDTYPE_URL       2
#define CITBDTYPE_TEXT      3



//  get an IDropTarget for shell special folders
//
HRESULT _GetSpecialDropTarget(UINT csidl, IDropTarget **ppdtgt)
{
    IShellFolder *psfDesktop;

    *ppdtgt = NULL;

    HRESULT hres = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hres))
    {
        LPITEMIDLIST pidl;
        hres = SHGetSpecialFolderLocation(NULL, csidl, &pidl);
        if (SUCCEEDED(hres))
        {
            IShellFolder *psf;
            hres = psfDesktop->BindToObject(pidl, NULL, IID_IShellFolder, (void **)&psf);
            if (SUCCEEDED(hres))
            {
                hres = psf->CreateViewObject(NULL, IID_IDropTarget, (void **)ppdtgt);
                psf->Release();
            }

            ILFree(pidl);
        }
        psfDesktop->Release();
    }
    return hres;
}

//  Takes a variety of inputs and returns a string for drop targets.
//  szUrl:    the URL
//  szName:   the name (for quicklinks and the confo dialog boxes)
//  returns:  NOERROR if succeeded
//
HRESULT _GetURLData(IDataObject *pdtobj, int iDropType, TCHAR *pszUrl, DWORD cchUrl,  TCHAR *pszName)
{
    HRESULT hRes = NOERROR;
    STGMEDIUM stgmedium;
    UINT cfFormat;

    *pszName = 0;
    *pszUrl = 0;

    switch (iDropType)
    {
    case CITBDTYPE_HDROP:
        cfFormat = CF_HDROP;
        break;

    case CITBDTYPE_URL:
        InitClipboardFormats();
        cfFormat = g_cfURL;
        break;

    case CITBDTYPE_TEXT:
        cfFormat = CF_TEXT;
        break;

    default:
        return E_UNEXPECTED;
    }

    // Get the parse string
    LPCSTR pszURL = (LPCSTR)DataObj_GetDataOfType(pdtobj, cfFormat, &stgmedium);
    if (pszURL)
    {
        if (iDropType == CITBDTYPE_HDROP)
        {
            ASSERT(stgmedium.tymed == TYMED_HGLOBAL);

            TCHAR szPath[MAX_PATH];
            DragQueryFile((HDROP)stgmedium.hGlobal, 0, szPath, ARRAYSIZE(szPath));

            // defaults...
            lstrcpyn(pszUrl, szPath, MAX_URL_STRING);
            lstrcpyn(pszName, szPath, MAX_NAME_QUICKLINK);

            SHFILEINFO sfi;
            DWORD_PTR bGotInfo = SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME | SHGFI_ATTRIBUTES);
            if (bGotInfo)
                lstrcpyn(pszName, sfi.szDisplayName, MAX_NAME_QUICKLINK);

            if (bGotInfo && (sfi.dwAttributes & SFGAO_LINK))
            {
                LPITEMIDLIST pidl;
                if (SUCCEEDED(GetLinkTargetIDList(szPath, pszUrl, cchUrl, &pidl)))
                {
                    // we only care about the name... thanks anyway.
                    ILFree(pidl);
                }
            }
        }
        else
        {
#ifdef UNICODE
            WCHAR wszURL[MAX_URL_STRING];
            SHAnsiToUnicode(pszURL, wszURL, ARRAYSIZE(wszURL));
            LPTSTR pszURLData = wszURL;
#else
            LPTSTR pszURLData = pszURL;
#endif
            if (iDropType == CITBDTYPE_URL)
            {
                // defaults
                lstrcpyn(pszUrl,  pszURLData, MAX_URL_STRING);
                lstrcpyn(pszName, pszURLData, MAX_NAME_QUICKLINK);

                WCHAR szPath[MAX_PATH];

                if (SUCCEEDED(DataObj_GetNameFromFileDescriptor(pdtobj, szPath, ARRAYSIZE(szPath))))
                    PathToDisplayNameW(szPath, pszName, MAX_NAME_QUICKLINK);
                    
            }
            else // if (iDropType == CITBDTYPE_TEXT)
            {
                ASSERT(iDropType == CITBDTYPE_TEXT);

                lstrcpyn(pszUrl, pszURLData, MAX_URL_STRING);
                lstrcpyn(pszName, pszURLData, MAX_NAME_QUICKLINK);
            }
        }
    
        ReleaseStgMediumHGLOBAL(NULL, &stgmedium);
    }
    else
    {
        hRes = E_FAIL;
    }

    return hRes;
}

//  Displays a dialog asking for confirmation of drop-set operations.
//  Returns: User's response to the dialog box: YES = TRUE, NO = FALSE
//
BOOL _ConfirmChangeQuickLink(HWND hwndParent, TCHAR *pszName, int iTarget)
{
    MSGBOXPARAMS mbp;
    TCHAR szHeader[64];
    TCHAR szBuffer [MAX_NAME_QUICKLINK + 64];
    TCHAR szCaption [MAX_NAME_QUICKLINK + 64];
    UINT titleID, textID, iconID;

    switch (iTarget)
    {
    case TBIDM_HOME:
        titleID = IDS_SETHOME_TITLE;
        textID = IDS_SETHOME_TEXT;
        iconID = IDI_HOMEPAGE;
        break;
#if 0
    case TBIDM_SEARCH:
        titleID = IDS_SETSEARCH_TITLE;
        textID = IDS_SETSEARCH_TEXT;
        iconID = IDI_FRAME; // Warning if you unif0 this: IDI_FRAME is not in this dll
        break;
#endif

    default:
        return FALSE;           // We should never get here!
    }
    mbp.cbSize = sizeof (MSGBOXPARAMS);
    mbp.hwndOwner = hwndParent;
    mbp.hInstance = HinstShdocvw();
    mbp.dwStyle = MB_YESNO | MB_USERICON;
    MLLoadString(titleID, szCaption, ARRAYSIZE (szCaption));
    mbp.lpszCaption = szCaption;
    mbp.lpszIcon = MAKEINTRESOURCE (iconID);
    mbp.dwContextHelpId = 0;
    mbp.lpfnMsgBoxCallback = NULL;
    mbp.dwLanguageId = LANGIDFROMLCID (g_lcidLocale);

    MLLoadString(textID, szHeader, ARRAYSIZE (szHeader));
    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szHeader, pszName);
    mbp.lpszText = szBuffer;

    return MessageBoxIndirect(&mbp) == IDYES;
}

//  Creates an instance of CITBarDropTarget. ptr is a pointer to the parent
//  CInternetToolbar.
//
CITBarDropTarget::CITBarDropTarget(HWND hwnd, int iTarget) : 
    _cRef(1), _iDropType(CITBDTYPE_NONE), _hwndParent(hwnd), _iTarget(iTarget)
{
}

STDMETHODIMP CITBarDropTarget::QueryInterface(REFIID iid, void **ppvObj)
{
    if (IsEqualIID (iid, IID_IUnknown) || IsEqualIID (iid, IID_IDropTarget))
    { 
        *ppvObj = SAFECAST(this, IDropTarget*);
        AddRef(); 
        return NOERROR; 
    } 

    *ppvObj = NULL; 
    return E_NOINTERFACE; 
}

STDMETHODIMP_(ULONG) CITBarDropTarget::AddRef()
{
    _cRef++;
    return _cRef;
}

STDMETHODIMP_(ULONG) CITBarDropTarget::Release()
{
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

typedef struct
{
    int iTarget;
    int iDropType;
    HWND hwnd;
    TCHAR szUrl [MAX_URL_STRING];
    TCHAR szName [MAX_NAME_QUICKLINK];
} DROPDATA;


DWORD CALLBACK ITBarDropThreadProc(void *pv)
{
    DROPDATA *pdd = (DROPDATA *)pv;

    switch (pdd->iTarget)
    {
    case TBIDM_HOME:

        if (pdd->iDropType != CITBDTYPE_TEXT)
        {
            if (_ConfirmChangeQuickLink(pdd->hwnd, pdd->szName, pdd->iTarget)) {
                ASSERT(pdd->iTarget == TBIDM_HOME);
                // currently don't support pdd->itarget == TBIDM_SEARCH
                //(pdd->iTarget == TBIDM_HOME) ? DVIDM_GOHOME : DVIDM_GOSEARCH);
                _SetStdLocation(pdd->szUrl, DVIDM_GOHOME);
            }
        }
        break;

    case TBIDM_SEARCH:
        ASSERT(0);
        break;
    }

    LocalFree(pdd);

    return 0;
}

STDMETHODIMP CITBarDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    ASSERT(pdtobj);
    _DragEnter(_hwndParent, ptl, pdtobj);
    if (_iTarget == TBIDM_FAVORITES)
    {
        if (SUCCEEDED(_GetSpecialDropTarget(CSIDL_FAVORITES, &_pdrop)))
            _pdrop->DragEnter(pdtobj, grfKeyState, ptl, pdwEffect);
        else
            *pdwEffect = DROPEFFECT_NONE;
        return NOERROR;
    }
    else if (_iTarget == TBIDM_HOME)
    {
        HKEY                hkeyRest = 0;
        DWORD               dwValue = 0;
        DWORD               dwLen = sizeof(DWORD);

        // Check if setting home page is restricted
    
        if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_SET_HOMEPAGE_RESTRICTION, 0,
                         KEY_READ, &hkeyRest) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hkeyRest, REGVAL_HOMEPAGE_RESTRICTION, NULL, NULL,
                                (LPBYTE)&dwValue, &dwLen) == ERROR_SUCCESS
                && dwValue)
            {
                return E_ACCESSDENIED;
            }
    
            RegCloseKey(hkeyRest);
        }
    }

    
    InitClipboardFormats();

    // Find the drop object's data format.
    FORMATETC fe = {g_cfURL, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if (NOERROR == pdtobj->QueryGetData (&fe))
    {
        _iDropType = CITBDTYPE_URL;
    }
    else if (fe.cfFormat = CF_HDROP, NOERROR == pdtobj->QueryGetData (&fe))
    {
        _iDropType = CITBDTYPE_HDROP;
    }
    else if (fe.cfFormat = CF_TEXT, NOERROR == pdtobj->QueryGetData (&fe))
    {
        _iDropType = CITBDTYPE_TEXT;
        // We want to eventually pick through the text for an
        // URL, but right now we just leave it unmolested.
    }
    DragOver (grfKeyState, ptl, pdwEffect);
    return NOERROR;
}

STDMETHODIMP CITBarDropTarget::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    DWORD dwEffectAvail;
    _DragMove(_hwndParent, ptl);
    if (_iTarget == TBIDM_FAVORITES)
    {
        if (_pdrop)
            return _pdrop->DragOver(grfKeyState, ptl, pdwEffect);

        *pdwEffect = DROPEFFECT_NONE;
        return NOERROR;
    }
    ASSERT(!_pdrop);

    if (_iDropType == CITBDTYPE_NONE)
    {
        *pdwEffect = DROPEFFECT_NONE;
        return NOERROR;
    }

    dwEffectAvail = DROPEFFECT_NONE;
    switch (_iTarget)
    {
        case TBIDM_HOME:
        case TBIDM_SEARCH:
            if (_iDropType == CITBDTYPE_TEXT)
            {
                // CF_TEXT doesn't do link.
            }
            else
                dwEffectAvail = DROPEFFECT_LINK;
            break;
    }
    *pdwEffect &= dwEffectAvail;
    return NOERROR;
}

STDMETHODIMP CITBarDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    BOOL fSafe = TRUE;
    LPITEMIDLIST pidl;

    if (_pdrop)
    {
        ASSERT(_iTarget == TBIDM_FAVORITES);

        //
        // Force a linking since we are passing straight through to the folder.
        // This avoids confusion when dragging to the toolbar button.
        //
        // FEATURE: this should really go through the "Add to Favorites" UI
        //

        // When forcing a link, make sure that you can move it. If you cannot move it,
        // then we rely on the prefered effect of the data object. Why? Well, the history
        // folder only allows a copy. If you just whack this to LINK, the shell folder hoses
        // the drag images (Does a DAD_SetDragImage(NULL), blowing away the information about
        // the last locked window, without unlocking it.). So, if you can move the item, 
        // you can link to it (I guess), but if you cannot move it, do whatever. 
        //     - (lamadio) 1.3.99
        if (*pdwEffect & DROPEFFECT_MOVE)
            *pdwEffect = DROPEFFECT_LINK;

        if (TBIDM_FAVORITES == _iTarget &&
            SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0)))
        {
            fSafe = IEIsLinkSafe(_hwndParent, pidl, ILS_ADDTOFAV);
            ILFree(pidl);
        }

        if (fSafe)
        {
            _pdrop->Drop(pdtobj, grfKeyState, pt, pdwEffect);
        }
        else
        {
            pdtobj->Release();  // Match Release called in _pdrop->Drop.
        }
       
        DAD_DragLeave();

        _pdrop->Release();
        _pdrop = NULL;
    }
    else
    {
        if (TBIDM_HOME == _iTarget &&
            SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0)))
        {
            fSafe = IEIsLinkSafe(_hwndParent, pidl, ILS_HOME);
            ILFree(pidl);
        }

        if (fSafe)
        {
            DROPDATA *pdd = (DROPDATA *)LocalAlloc (LPTR, sizeof(DROPDATA));
            if (pdd)
            {
                pdd->iTarget = _iTarget;
                pdd->iDropType = _iDropType;
                pdd->hwnd = _hwndParent;

                // do this async so we don't block the source of the drag durring our UI
                if (FAILED(_GetURLData(pdtobj, _iDropType, pdd->szUrl, ARRAYSIZE(pdd->szUrl), pdd->szName)) ||
                    !SHCreateThread(ITBarDropThreadProc, pdd, 0, NULL))
                    LocalFree(pdd);
            }
        }
        DragLeave();
    }
    return NOERROR;
}

STDMETHODIMP CITBarDropTarget::DragLeave(void)
{
    DAD_DragLeave();
    // Check if we should to pass to the favorites dt.
    if (_pdrop)
    {
        ASSERT(_iTarget == TBIDM_FAVORITES);
        _pdrop->DragLeave();
        _pdrop->Release();
        _pdrop = NULL;
    }
    _iDropType = CITBDTYPE_NONE;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\makefile.inc ===
LIBOBJ          = $(CCSHELL_DIR)\lib\$O

clean:
    -del /F /Q $(NTTARGETFILE0)
    -del /F /Q $(NTTARGETFILES)


# These are the dependencies that the RC file has
#
..\browseui.rc: $(SELFREGNAME)


!include $(CCSHELL_DIR)\makefile.inc

#
# Copy browseui libs to shell\lib\$(O)
#
$(LIBOBJ)\browseui.lib: $(TARGETPATH)\$(TARGET_DIRECTORY)\browseui.lib
    if not exist $(TARGETPATH)\nul md $(TARGETPATH)
    if not exist $(LIBOBJ)\nul md $(LIBOBJ)
    copy $** $@

$(LIBOBJ)\browseuip.lib: $(TARGETPATH)\$(TARGET_DIRECTORY)\browseuip.lib
    if not exist $(TARGETPATH)\nul md $(TARGETPATH)
    if not exist $(LIBOBJ)\nul md $(LIBOBJ)
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\itbdrop.h ===
//
//  ITBDROP_H
//  Header file for the internet toolbar's drop target.
//
//  History:
//      8/22/96 -   t-mkim: created

#ifndef _ITBDROP_H
#define _ITBDROP_H

#define TBIDM_BACK              0x120
#define TBIDM_FORWARD           0x121
#define TBIDM_HOME              0x122
#define TBIDM_SEARCH            0x123  // copy of this in shdocvw\basesb.cpp
#define TBIDM_STOPDOWNLOAD      0x124
#define TBIDM_REFRESH           0x125
#define TBIDM_FAVORITES         0x126
#define TBIDM_THEATER           0x128
#define TBIDM_HISTORY           0x12E
#define TBIDM_PREVIOUSFOLDER    0x130
#define TBIDM_CONNECT           0x131
#define TBIDM_DISCONNECT        0x132
#define TBIDM_ALLFOLDERS        0x133
#define TBIDM_MEDIABAR          0x134

#define REGSTR_SET_HOMEPAGE_RESTRICTION               TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define REGVAL_HOMEPAGE_RESTRICTION                   TEXT("HomePage")

// Class for implementing a single drop target for all the various and sundry things
// that can be dropped onto on the internet toolbar.
class CITBarDropTarget : public IDropTarget
{
private:
    ULONG _cRef;
    HWND _hwndParent;
    IDropTarget *_pdrop;    // hand on to the the favorites target
    int _iDropType;         // Which format data is in.
    int _iTarget;           // what item are we running for

public:
    CITBarDropTarget(HWND hwnd, int iTarget);

    STDMETHODIMP QueryInterface(REFIID iid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef (void);
    STDMETHODIMP_(ULONG) Release (void);

    STDMETHODIMP DragEnter(IDataObject *dtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
};

#endif //_ITBDROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\mbbehave.cpp ===
//------------------------------------------------------------------------
//
//  Microsoft Windows 
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:      mbBehave.cpp
//
//  Contents:  mediaBar player behavior
//
//  Classes:   CMediaBehavior
//
//------------------------------------------------------------------------

#include "priv.h"
#define INITGUID        // pull in additional declaration for private mediabar IIDs
#include "initguid.h"
#include "mbBehave.h"
#undef INITGUID
#include "mediaBand.h"
#include "mediautil.h"
#include "varutil.h"
#include <mluisupp.h>
#include "resource.h"

//================================================================================================
//  CMediaBehavior
//================================================================================================

#define NO_COOKIE   -1


// event names fired from this behavior:
// NOTE: need to match the enums in the mbBehave.h with this array!!!
struct _eventInfo {
    LONG        levtCookie;
    LPWSTR      pwszName;
} s_behaviorEvents[] =
{
    NO_COOKIE,  L"OnOpenStateChange",
    NO_COOKIE,  L"OnPlayStateChange",
    NO_COOKIE,  L"OnShow",
    NO_COOKIE,  L"OnHide",
};

#ifndef WMPCOREEVENT_BASE
// ISSUE/010430/davidjen  should be pulled in from wmp.idl, but this file is not part of source tree
#define INITGUID        // define GUID, not only declare it
#include "initguid.h"
DEFINE_GUID(DIID__WMPOCXEvents,0x6BF52A51,0x394A,0x11d3,0xB1,0x53,0x00,0xC0,0x4F,0x79,0xFA,0xA6);
#define WMPCOREEVENT_BASE                       5000
#define DISPID_WMPCOREEVENT_OPENSTATECHANGE     (WMPCOREEVENT_BASE + 1)
#define WMPCOREEVENT_CONTROL_BASE               5100
#define DISPID_WMPCOREEVENT_PLAYSTATECHANGE     (WMPCOREEVENT_CONTROL_BASE + 1)
#undef INITGUID
#endif



// class factories
//------------------------------------------------------------------------
CMediaBehavior *
    CMediaBehavior_CreateInstance(CMediaBand* pHost)
{
    return new CMediaBehavior(pHost);
}

//------------------------------------------------------------------------
CMediaItem *
    CMediaItem_CreateInstance(CMediaBehavior* pHost)
{
    return new CMediaItem(pHost);
}

//------------------------------------------------------------------------
CMediaItemNext *
    CMediaItemNext_CreateInstance(CMediaBehavior* pHost)
{
    return new CMediaItemNext(pHost);
}

//------------------------------------------------------------------------
CPlaylistInfo *
    CPlaylistInfo_CreateInstance(CMediaBehavior* pHost)
{
    return new CPlaylistInfo(pHost);
}



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// class CMediaBehavior
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
CMediaBehavior::CMediaBehavior(CMediaBand* pHost)
  : CImpIDispatch(LIBID_BrowseUI, 1, 0, IID_IMediaBehavior),
    _cRef(0),
    _dwcpCookie(0),
    _fDisabledUI(FALSE),
    _fPlaying(FALSE)
{
    ASSERT(pHost);
    _pHost = pHost;
    if (_pHost)
    {
        _pHost->AddRef();
        HRESULT hr = _pHost->addProxy((IContentProxy*)this);
        ASSERT(SUCCEEDED(hr));
    }
}

//------------------------------------------------------------------------
CMediaBehavior::~CMediaBehavior()
{
    Detach();   // to be sure...
    if (_pHost)
        _pHost->Release();
}


//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CMediaBehavior, IElementBehavior),
        QITABENT(CMediaBehavior, IMediaBehavior),
        QITABENT(CMediaBehavior, IDispatch),
        QITABENTMULTI2(CMediaBehavior, DIID__WMPOCXEvents, IDispatch),
        QITABENT(CMediaBehavior, IContentProxy),
        QITABENT(CMediaBehavior, IMediaBehaviorContentProxy),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}



//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::Detach(void)
{
    _ConnectToWmpEvents(FALSE);

    // detach from behavior site
    if (_pHost)
    {
        _pHost->removeProxy(SAFECAST(this, IContentProxy*));    // optimize: _pHost saves ptr as IContentProxy, this saves a QI
        _pHost->Release();
        _pHost = NULL;
    }
    _fPlaying = FALSE;

    if (_apMediaItems != NULL)
    {
        int cnt = _apMediaItems.GetPtrCount();
        for (int i = 0; i < cnt; i++)
        {
            CMediaItem* pItem = _apMediaItems.GetPtr(i);
            if (pItem) 
                pItem->Release();
        }
        _apMediaItems.Destroy();
    }

    _pBehaviorSite.Release();
    _pBehaviorSiteOM.Release();
    for (int i = 0; i < ARRAYSIZE(s_behaviorEvents); i++)
    {
        s_behaviorEvents[i].levtCookie = NO_COOKIE;
    }
    
    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::Init(IElementBehaviorSite* pBehaviorSite)
{
    ASSERT(pBehaviorSite);
    if (pBehaviorSite == NULL)  return E_POINTER;

    _pBehaviorSite = pBehaviorSite;

    pBehaviorSite->QueryInterface(IID_PPV_ARG(IElementBehaviorSiteOM, &_pBehaviorSiteOM));
    ASSERT(_pBehaviorSiteOM != NULL);

    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::Notify(LONG lEvent, VARIANT* pVar)
{
// ISSUE/000923/davidjen 
// these enums require behavior.idl; this idl is only available in inetcore,
// might have to be moved to shell/published or mergedcomponents
/*
    switch (lEvent) {
    case BEHAVIOREVENT_CONTENTCHANGE:
        break;
    case BEHAVIOREVENT_DOCUMENTREADY:
        break;
    }
*/
    return S_OK;
}


// *** IDispatch ***
//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    if (!_ProcessEvent(dispidMember, pdispparams->cArgs, pdispparams->rgvarg))
    {
        return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
    }
    return S_OK;
}

//------------------------------------------------------------------------
BOOL CMediaBehavior::_ProcessEvent(DISPID dispid, long lCount, VARIANT varParams[])
{
    BOOL fHandled = FALSE;
    switch (dispid)
    {
      case DISPID_WMPCOREEVENT_PLAYSTATECHANGE:
          ASSERT(lCount == 1);
          ASSERT(V_VT(&varParams[0]) == VT_I4);
          fireEvent(OnPlayStateChange);
          fHandled = TRUE;
          break;
      case DISPID_WMPCOREEVENT_OPENSTATECHANGE:
          ASSERT(lCount == 1);
          ASSERT(V_VT(&varParams[0]) == VT_I4);
          fireEvent(OnOpenStateChange);
          fHandled = TRUE;
          break;
      default:
          fHandled = FALSE;
          break;
    }
    return fHandled;
}


// *** IMediaBehavior ***
//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::playURL(BSTR bstrURL, BSTR bstrMIME)
{
    if (!_pHost)
    {
        return E_UNEXPECTED;
    }
    _fPlaying = TRUE;
    _pHost->playURL(bstrURL, bstrMIME);
    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::stop()
{
    if (!_pHost)
    {
        return E_UNEXPECTED;
    }
    return IUnknown_Exec(SAFECAST(_pHost, IMediaBar*), &CLSID_MediaBand, FCIDM_MEDIABAND_STOP, 0, NULL, NULL);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::playNext()
{
    if (!_pHost)
    {
        return E_UNEXPECTED;
    }
    return IUnknown_Exec(SAFECAST(_pHost, IMediaBar*), &CLSID_MediaBand, FCIDM_MEDIABAND_NEXT, 0, NULL, NULL);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_currentItem(IMediaItem **ppMediaItem)
{
    if (ppMediaItem == NULL)
        return E_POINTER;
    *ppMediaItem = NULL;

    HRESULT hr = S_OK;
    if (_apMediaItems == NULL) {
        _apMediaItems.Create(2);
    }
    if (_apMediaItems == NULL)
        return E_OUTOFMEMORY;

    CMediaItem *pItem = CMediaItem_CreateInstance(this);
    if (pItem)
    {
        pItem->AddRef();    // keep object alive with ref count >= 1
        hr = pItem->AttachToWMP();
        if (SUCCEEDED(hr))
        {
            hr = pItem->QueryInterface(IID_PPV_ARG(IMediaItem, ppMediaItem));
//            pItem->AddRef();
//            _apMediaItems.AppendPtr(pItem);     // keep a ref for us
        }
        pItem->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_nextItem(IMediaItem **ppMediaItem)
{
    if (ppMediaItem == NULL)
        return E_POINTER;
    *ppMediaItem = NULL;

    HRESULT hr = S_OK;
    if (_apMediaItems == NULL) {
        _apMediaItems.Create(2);
    }
    if (_apMediaItems == NULL)
        return E_OUTOFMEMORY;

    CMediaItemNext *pItem = CMediaItemNext_CreateInstance(this);
    if (pItem)
    {
        pItem->AddRef();    // keep object alive with ref count >= 1
        hr = pItem->AttachToWMP();
        if (SUCCEEDED(hr))
        {
            hr = pItem->QueryInterface(IID_PPV_ARG(IMediaItem, ppMediaItem));
//            pItem->AddRef();
//            _apMediaItems.AppendPtr(pItem);     // keep a ref for us
        }
        pItem->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_playlistInfo(IPlaylistInfo **ppPlaylistInfo)
{
    if (ppPlaylistInfo == NULL)
        return E_POINTER;
    *ppPlaylistInfo = NULL;

    HRESULT hr = S_OK;
    if (_apMediaItems == NULL) {
        _apMediaItems.Create(2);
    }
    if (_apMediaItems == NULL)
        return E_OUTOFMEMORY;

    CPlaylistInfo *pInfo = CPlaylistInfo_CreateInstance(this);
    if (pInfo)
    {
        pInfo->AddRef();    // keep object alive with ref count >= 1
        hr = pInfo->AttachToWMP();
        if (SUCCEEDED(hr))
        {
            hr = pInfo->QueryInterface(IID_PPV_ARG(IPlaylistInfo, ppPlaylistInfo));
//            pItem->AddRef();
//            _apMediaItems.AppendPtr(pInfo);     // keep a ref for us
        }
        pInfo->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_hasNextItem(VARIANT_BOOL *pfhasNext)
{
    if (pfhasNext == NULL)
    {
        return E_POINTER;
    }
    *pfhasNext = VARIANT_FALSE;
    if (!_pHost)
    {
        return E_UNEXPECTED;
    }

    LONG currTrack = 0;
    LONG cntTracks = 0;
    HRESULT hr = getPlayListIndex(&currTrack, &cntTracks);
    if (SUCCEEDED(hr))
    {
        *pfhasNext = ((currTrack >= 0) && (currTrack < cntTracks - 1)) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_playState(mbPlayState *pps)
{
    if (pps == NULL)
        return E_POINTER;
    *pps = mbpsUndefined;

    CComDispatchDriver pwmpPlayer;
    HRESULT hr = getWMP(&pwmpPlayer);
    if (FAILED(hr) || !pwmpPlayer)
    {
        // player not created yet, state undefined
        *pps = mbpsUndefined;
        return S_OK;
    }

    CComVariant vtPlayState;
    hr = pwmpPlayer.GetPropertyByName(L"playState", &vtPlayState);
    if (SUCCEEDED(hr) && (V_VT(&vtPlayState) == VT_I4))
    {
        *pps = (mbPlayState) V_I4(&vtPlayState);
    }
    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_openState(mbOpenState *pos)
{
    if (pos == NULL)
        return E_POINTER;
    *pos = mbosUndefined;

    CComDispatchDriver pwmpPlayer;
    HRESULT hr = getWMP(&pwmpPlayer);
    if (FAILED(hr) || !pwmpPlayer)
    {
        // player not created yet, state undefined
        *pos = mbosUndefined;
        return S_OK;
    }

    CComVariant vtOpenState;
    hr = pwmpPlayer.GetPropertyByName(L"openState", &vtOpenState);
    if (SUCCEEDED(hr) && (V_VT(&vtOpenState) == VT_I4))
    {
        *pos = (mbOpenState) V_I4(&vtOpenState);
    }
    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_enabled(VARIANT_BOOL *pbEnabled)
{
    if (pbEnabled == NULL)
        return E_POINTER;
    *pbEnabled = VARIANT_FALSE;

    CComDispatchDriver pwmpPlayer;
    HRESULT hr = getWMP(&pwmpPlayer);
    if (FAILED(hr) || !pwmpPlayer)
    {
        // player not created yet, state undefined
        *pbEnabled = VARIANT_FALSE;
        return S_FALSE;
    }

    CComVariant vtEnabled;
    hr = pwmpPlayer.GetPropertyByName(L"enabled", &vtEnabled);
    if (SUCCEEDED(hr) && (V_VT(&vtEnabled) == VT_BOOL))
    {
        *pbEnabled = V_BOOL(&vtEnabled);
    }
    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::put_enabled(VARIANT_BOOL bEnabled)
{
    CComDispatchDriver pwmpPlayer;
    HRESULT hr = getWMP(&pwmpPlayer);
    if (FAILED(hr) || !pwmpPlayer)
    {
        // player not created yet, fire exception to let scrip know it has no control
        return E_UNEXPECTED;
    }

    CComVariant vtEnabled = bEnabled;
    return pwmpPlayer.PutPropertyByName(L"enabled", &vtEnabled);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_disabledUI(VARIANT_BOOL *pbDisabled)
{
    if (pbDisabled == NULL)
        return E_POINTER;
    *pbDisabled = _fDisabledUI ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::put_disabledUI(VARIANT_BOOL bDisable)
{
    _fDisabledUI = bDisable;
    // tell mediaband
    if (_pHost)
    {
        _pHost->OnDisableUIChanged(_fDisabledUI);
    }
    return S_OK;
}


// 
// *** IMediaBehaviorContentProxy ***
//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::OnCreatedPlayer(void)
{
    return _ConnectToWmpEvents(TRUE);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::fireEvent(enum contentProxyEvent event)
{
    ASSERT(_pBehaviorSiteOM != NULL);   // called too early, must have received Init() call from Trident first!
    if (!_pBehaviorSiteOM)
        return E_UNEXPECTED;

    if ((event < 0) || (event >= ARRAYSIZE(s_behaviorEvents)))
        return E_INVALIDARG;

    struct _eventInfo *pEvtInfo = &s_behaviorEvents[event];

    HRESULT hr = S_OK;
    // don't have cookie yet, need to register event first!
    if (pEvtInfo->levtCookie == NO_COOKIE)
    {
        // register event with behavior site
        hr = _pBehaviorSiteOM->RegisterEvent(pEvtInfo->pwszName, 0, &pEvtInfo->levtCookie);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;
    }
    if (pEvtInfo->levtCookie == NO_COOKIE)
        return E_UNEXPECTED;

    CComPtr<IHTMLEventObj>  pEvt;
    hr = _pBehaviorSiteOM->CreateEventObject(&pEvt);
    if (FAILED(hr))
        return hr;

    // fire into script:
     return _pBehaviorSiteOM->FireEvent(pEvtInfo->levtCookie, pEvt);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::detachPlayer(void)
{
    return _ConnectToWmpEvents(FALSE);
}

// *** IMediaBehaviorContentProxy ***
//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::OnUserOverrideDisableUI()
{
    return put_disabledUI(VARIANT_FALSE);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::IsDisableUIRequested(BOOL *pfRequested)
{
    if (!pfRequested)
    {
        return E_POINTER;
    }
    *pfRequested = _fDisabledUI;
    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::IsNextEnabled(BOOL *pfEnabled)
{
    if (!pfEnabled)
    {
        return E_POINTER;
    }
    *pfEnabled = FALSE;

    CComDispatchDriverEx    pwmpPlayer;
    HRESULT hr = getWMP(&pwmpPlayer);
    if (SUCCEEDED(hr) && pwmpPlayer)
    {
        CComVariant vtControls;
        hr = pwmpPlayer.GetPropertyByName(L"controls", &vtControls);
        if (SUCCEEDED(hr))
        {
            CComDispatchDriverEx pwmpControls;
            pwmpControls = vtControls;
            
            CComVariant vtNext = "Next";
            CComVariant vtEnabled;
            hr = pwmpControls.GetPropertyByName1(L"isAvailable", &vtNext, &vtEnabled);
            if (SUCCEEDED(hr) && (V_VT(&vtEnabled) == VT_BOOL))
            {
                *pfEnabled = (V_BOOL(&vtEnabled) == VARIANT_TRUE);
            }
        }
    }
    return S_OK;
}

//------------------------------------------------------------------------
HRESULT CMediaBehavior::getWMP(IDispatch **ppPlayer)
{
    if (ppPlayer == NULL)
        return E_POINTER;
    *ppPlayer = NULL;
    if (!CMediaBarUtil::IsWMP7OrGreaterCapable() || !_pHost)
    {
        return E_UNEXPECTED;
    }
    if (!_fPlaying)
    {
        return E_ACCESSDENIED;
    }

    HRESULT hr = E_UNEXPECTED;
    CComPtr<IUnknown>    pMediaPlayer;
    hr = _pHost->getMediaPlayer(&pMediaPlayer);
    // getMediaPlayer can return NULL and S_FALSE if player isn't loaded yet!
    if (SUCCEEDED(hr) && pMediaPlayer)
    {
        CComQIPtr<ITIMEMediaElement, &IID_ITIMEMediaElement> pMediaElem = pMediaPlayer;
        if (pMediaElem)
        {
            return pMediaElem->get_playerObject(ppPlayer);
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    return hr;
}

//------------------------------------------------------------------------
HRESULT CMediaBehavior::getPlayListIndex(LONG *plIndex, LONG *plCount)
{
    if (!_pHost)
    {
        return E_UNEXPECTED;
    }
    CComPtr<IUnknown>    pMediaPlayer;
    HRESULT hr = _pHost->getMediaPlayer(&pMediaPlayer);
    // getMediaPlayer can return NULL and S_FALSE if player isn't loaded yet!
    if (SUCCEEDED(hr) && pMediaPlayer)
    {
        CComQIPtr<ITIMEMediaElement, &IID_ITIMEMediaElement> pMediaElem = pMediaPlayer;
        if (pMediaElem)
        {
            CComPtr<ITIMEPlayList> pPlayList;
            if (SUCCEEDED(pMediaElem->get_playList(&pPlayList)) && pPlayList)
            {
                // current track index
                if (plIndex)
                {
                    CComPtr<ITIMEPlayItem> pPlayItem;
                    if (SUCCEEDED(pPlayList->get_activeTrack(&pPlayItem)) && pPlayItem)
                    {
                        hr = pPlayItem->get_index(plIndex);
                    }
                }
                // number of tracks in playlist
                if (plCount)
                {
                    hr = pPlayList->get_length(plCount);
                }
            }
        }
    }

    return hr;
}


//------------------------------------------------------------------------
HRESULT CMediaBehavior::_ConnectToWmpEvents(BOOL fConnect)
{
    if (   (fConnect && (_dwcpCookie != 0))
        || (!fConnect && (_dwcpCookie == 0))
        || !_pHost)
    {
        return S_FALSE; // no change in connection or no host
    }

    CComPtr<IDispatch>    pwmpPlayer;
    HRESULT hr = getWMP(&pwmpPlayer);
    if (SUCCEEDED(hr) && pwmpPlayer)
    {
        return ConnectToConnectionPoint(SAFECAST(this, IDispatch*), 
                DIID__WMPOCXEvents, fConnect, pwmpPlayer, &_dwcpCookie, NULL);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// class CWMPWrapper
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
CWMPWrapper::CWMPWrapper(CMediaBehavior* pHost)
  : _cRef(0),
    _fStale(FALSE)
{
    ASSERT(pHost);
    _pHost = pHost;
    if (_pHost)
        _pHost->AddRef();
}

//------------------------------------------------------------------------
CWMPWrapper::~CWMPWrapper()
{
    if (_pHost)
        _pHost->Release();
}

//------------------------------------------------------------------------
HRESULT CWMPWrapper::_getVariantProp(LPCOLESTR pwszPropName, VARIANT *pvtParam, VARIANT *pvtValue, BOOL fCallMethod)
{
    if (pvtValue == NULL)
        return E_POINTER;

    HRESULT hr = S_FALSE;
    VariantInit(pvtValue);
    if (!_fStale && _pwmpWrapper)
    {
        if (fCallMethod)
        {
            if (pvtParam != NULL)
            {
                hr = _pwmpWrapper.Invoke1(pwszPropName, pvtParam, pvtValue);
            }
            else
            {
                hr = _pwmpWrapper.Invoke0(pwszPropName, pvtValue);
            }
        }
        else
        {
            if (pvtParam != NULL)
            {
                hr = _pwmpWrapper.GetPropertyByName1(pwszPropName, pvtParam, pvtValue);
            }
            else
            {
                hr = _pwmpWrapper.GetPropertyByName(pwszPropName, pvtValue);
            }
        }
    }

    return hr;
}

//------------------------------------------------------------------------
HRESULT CWMPWrapper::_getStringProp(LPCOLESTR pwszPropName, VARIANT *pvtParam, OUT BSTR *pbstrValue, BOOL fCallMethod)
{
    if (pbstrValue == NULL)
        return E_POINTER;
    *pbstrValue = NULL;

    CComVariant vtValue;
    HRESULT hr = _getVariantProp(pwszPropName, pvtParam, &vtValue, fCallMethod);
    if (SUCCEEDED(hr) && (V_VT(&vtValue) == VT_BSTR))
    {
        *pbstrValue = SysAllocString(V_BSTR(&vtValue));
    }

    // always return string, even if empty one (e.g. when media object is stale)
    if (SUCCEEDED(hr) && (*pbstrValue == NULL))
    {
        *pbstrValue = SysAllocString(L"");
        hr = S_OK;
    }

    return hr;
}


//------------------------------------------------------------------------
HRESULT CWMPWrapper::AttachToWMP()
{
    HRESULT hr = E_UNEXPECTED;
    if (_pHost)
    {
        CComDispatchDriver pwmpPlayer;
        hr = _pHost->getWMP(&pwmpPlayer);
        if (SUCCEEDED(hr) && pwmpPlayer)
        {
            // walk to WMP media object as signaled by requested type
            CComVariant vtMedia;
            hr = FetchWmpObject(pwmpPlayer, &vtMedia);
            if (SUCCEEDED(hr))
            {
                _pwmpWrapper = vtMedia;
            }
        }
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// class CMediaItem
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
CMediaItem::CMediaItem(CMediaBehavior* pHost)
  : CWMPWrapper(pHost),
    CImpIDispatch(LIBID_BrowseUI, 1, 0, IID_IMediaItem)
{
}

//------------------------------------------------------------------------
CMediaItem::~CMediaItem()
{
}


//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IMediaItem))
    {
        *ppvObj = (IMediaItem*) this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch*) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}



// *** IMediaItem
//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::get_sourceURL(BSTR *pbstrSourceURL)
{
    return _getStringProp(L"sourceURL", NULL, pbstrSourceURL);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::get_name(BSTR *pbstrName)
{
    return _getStringProp(L"name", NULL, pbstrName);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::get_duration(double * pDuration)
{
    if (pDuration == NULL)
        return E_POINTER;
    *pDuration = 0.0;

    CComVariant vtValue;
    HRESULT hr = _getVariantProp(L"duration", NULL, &vtValue);
    if (SUCCEEDED(hr) && (V_VT(&vtValue) == VT_R8))
    {
        *pDuration = V_R8(&vtValue);
    }

    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::get_attributeCount(long *plCount)
{
    if (plCount == NULL)
        return E_POINTER;
    *plCount = 0;

    CComVariant vtValue;
    HRESULT hr = _getVariantProp(L"attributeCount", NULL, &vtValue);
    if (SUCCEEDED(hr) && (V_VT(&vtValue) == VT_I4))
    {
        *plCount = V_I4(&vtValue);
    }

    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::getAttributeName(long lIndex, BSTR *pbstrItemName)
{
    CComVariant vtIndex = lIndex;
    return _getStringProp(L"getAttributeName", &vtIndex, pbstrItemName, TRUE);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::getItemInfo(BSTR bstrItemName, BSTR *pbstrVal)
{
    CComVariant vtItemName = bstrItemName;
    return _getStringProp(L"getItemInfo", &vtItemName, pbstrVal, TRUE);
}


//------------------------------------------------------------------------
HRESULT CMediaItem::FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj)
{
    CComDispatchDriver pwmpPlayer;
    pwmpPlayer = pdispWmpPlayer;
    return pwmpPlayer.GetPropertyByName(L"currentMedia", pvtWrapperObj);
}


//////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// class CMediaItemNext
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
CMediaItemNext::CMediaItemNext(CMediaBehavior* pHost)
  : CMediaItem(pHost)
{
}

//------------------------------------------------------------------------
CMediaItemNext::~CMediaItemNext()
{
}

//------------------------------------------------------------------------
HRESULT CMediaItemNext::FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj)
{
    if (!_pHost)
    {
        return E_UNEXPECTED;
    }
    CComDispatchDriver pwmpPlayer;
    pwmpPlayer = pdispWmpPlayer;
    
    HRESULT hr = E_UNEXPECTED;
    CComVariant vtCurrPlayList;
    hr = pwmpPlayer.GetPropertyByName(L"currentPlaylist", &vtCurrPlayList);
    if (SUCCEEDED(hr))
    {
        CComDispatchDriverEx pwmpCurrPlayList;
        pwmpCurrPlayList = vtCurrPlayList;
            
        // what's the index of the current item in play?
        CComPtr<IMediaBarPlayer>    pMediaPlayer;
        LONG cnt = 0;
        LONG currIndex = 0;
        hr = _pHost->getPlayListIndex(&currIndex, &cnt);
        if (SUCCEEDED(hr))
        {
            if (currIndex + 1 < cnt)
            {
                CComVariant vtNext = currIndex + 1;
                return pwmpCurrPlayList.GetPropertyByName1(L"item", &vtNext, pvtWrapperObj);
            }
            else
            {
                return E_UNEXPECTED;
            }
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// class CPlaylistInfo
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
CPlaylistInfo::CPlaylistInfo(CMediaBehavior* pHost)
  : CWMPWrapper(pHost),
    CImpIDispatch(LIBID_BrowseUI, 1, 0, IID_IPlaylistInfo)
{
}

//------------------------------------------------------------------------
CPlaylistInfo::~CPlaylistInfo()
{
}


//------------------------------------------------------------------------
STDMETHODIMP CPlaylistInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IPlaylistInfo))
    {
        *ppvObj = (IPlaylistInfo*) this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch*) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


// *** IPlaylistInfo
//------------------------------------------------------------------------
//------------------------------------------------------------------------
STDMETHODIMP CPlaylistInfo::get_name(BSTR *pbstrName)
{
    return _getStringProp(L"name", NULL, pbstrName);
}

//------------------------------------------------------------------------
STDMETHODIMP CPlaylistInfo::get_attributeCount(long *plCount)
{
    if (plCount == NULL)
        return E_POINTER;
    *plCount = 0;

    CComVariant vtValue;
    HRESULT hr = _getVariantProp(L"attributeCount", NULL, &vtValue);
    if (SUCCEEDED(hr) && (V_VT(&vtValue) == VT_I4))
    {
        *plCount = V_I4(&vtValue);
    }

    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CPlaylistInfo::getAttributeName(long lIndex, BSTR *pbstrItemName)
{
    CComVariant vtIndex = lIndex;
    return _getStringProp(L"attributeName", &vtIndex, pbstrItemName);
}

//------------------------------------------------------------------------
STDMETHODIMP CPlaylistInfo::getItemInfo(BSTR bstrItemName, BSTR *pbstrVal)
{
    CComVariant vtItemName = bstrItemName;
    return _getStringProp(L"getItemInfo", &vtItemName, pbstrVal, TRUE);
}

//------------------------------------------------------------------------
HRESULT CPlaylistInfo::FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj)
{
    CComDispatchDriver pwmpPlayer;
    pwmpPlayer = pdispWmpPlayer;
    return pwmpPlayer.GetPropertyByName(L"currentPlaylist", pvtWrapperObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\logo.h ===
#ifndef _LOGO_H
#define _LOGO_H

typedef HRESULT (* LPUPDATEFN)( void *pData, DWORD dwItem, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache );

#define LOGO_HEIGHT 32
#define LOGO_WIDE_WIDTH 194
#define LOGO_WIDTH  80

class CLogoBase
{
public:
    CLogoBase( BOOL fWide = FALSE );
    ~CLogoBase();

    virtual STDMETHODIMP_(ULONG) AddRef(void)  PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;

    static void _Initialize( void );
    static void _Cleanup( void );
    
    virtual IShellFolder * GetSF() PURE;
    virtual HWND GetHWND() PURE;

    inline HIMAGELIST GetLogoHIML( void );
    
    // intialisation functions
    HRESULT InitLogoView( void );
    HRESULT ExitLogoView( void );

    int GetLogoIndex( DWORD dwItem, LPCITEMIDLIST pidl, IRunnableTask **ppTask, DWORD * pdwPriority, DWORD * pdwFlags );
    int GetDefaultLogo( LPCITEMIDLIST pidl, BOOL fQuick );

    HRESULT AddTaskToQueue( IRunnableTask *pTask, DWORD dwPriority, DWORD lParam );
    
    // create the default logo for an item....
    HRESULT CreateDefaultLogo(int iIcon, int cxLogo, int cyLogo, LPCTSTR pszText, HBITMAP * phBmpLogo);

    HRESULT FlushLogoCache( void );

    HRESULT AddRefLogoCache( void );
    HRESULT ReleaseLogoCache( void );

    // get the task ID used with the task scheduler
    virtual REFTASKOWNERID GetTOID( void ) PURE;

    virtual HRESULT UpdateLogoCallback( DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache ) PURE;

    HRESULT DitherBitmap( HBITMAP hBmp, HBITMAP * phBmpNew );

    int AddIndicesToLogoList( int iIcon, UINT uIndex );

    int FindLogoFromIcon( int iIcon, int * piLastLogo );
    
protected:
    
    int GetCachedLogoIndex(DWORD dwItem, LPCITEMIDLIST pidl, IRunnableTask **ppTask, DWORD * pdwPriority, DWORD * pdwFlags );
    
    IImageCache * _pLogoCache;              // My be NULL in low memory conditions.
    IShellTaskScheduler * _pTaskScheduler;
    HIMAGELIST _himlLogos;
    SIZEL _rgLogoSize;
    DWORD _dwClrDepth;
    HDSA  _hdsaLogoIndices;

    static CRITICAL_SECTION s_csSharedLogos;
    static long             s_lSharedWideLogosRef;
    static IImageCache *    s_pSharedWideLogoCache;
    static HDSA             s_hdsaWideLogoIndices;

    HPALETTE _hpalHalftone;
    BOOL     _fWide;
};

inline HIMAGELIST CLogoBase::GetLogoHIML( )
{
    return _himlLogos;
}

struct LogoIndex
{
    int iIcon;
    int iLogo;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\mbutil.h ===
#ifndef _MEDIAMENU_H_
#define _MEDIAMENU_H_

#include "cowsite.h"

class CMediaBand;

#define MEDIA_MRU_LIMIT         10

class CMediaMRU
{
public:
    CMediaMRU();
    ~CMediaMRU();
    
    VOID Load(PTSTR pszKey);
    VOID Add(PTSTR pszData);
    BOOL Get(INT iWhich, PTSTR pszOut);
    VOID Delete(INT iWhich);

private:
    HKEY _hkey;
};

class CMediaWidget
{
public:
    CMediaWidget(HWND, int cx, int cy);
    ~CMediaWidget();
    virtual LRESULT Draw(LPNMTBCUSTOMDRAW pnmc) = 0;
    virtual BOOL IsEnabled() = 0;
    virtual HRESULT TranslateAccelerator(LPMSG pMsg) = 0;
//private:
    HWND _hwnd, _hwndParent;
    INT _cx, _cy;
};

enum
{
    MWB_NORMAL = 0,
    MWB_DISABLED,
    MWB_HOT,
    MWB_PRESSED
};

class CMediaWidgetButton : public CMediaWidget
{
public:
    CMediaWidgetButton(HWND, int, int);
    ~CMediaWidgetButton();
    HRESULT SetImageList(INT iResource);
    HRESULT SetAlternateImageList(INT iResource);
    HRESULT SetImageSource(BOOL fImageSource);
    HRESULT SetMode(DWORD);
    virtual HRESULT Initialize(int idCommand, int idTooltip=0, int idTooltipAlt=0);
    LRESULT Draw(LPNMTBCUSTOMDRAW pnmc);
    BOOL IsEnabled();
    HRESULT TranslateAccelerator(LPMSG pMsg);

//private:
    HIMAGELIST _himl, _himlAlt;
    INT _iTooltip, _iTooltipAlt, _iCommand;
    BOOL _fImageSource;
    DWORD _dwMode;
};

CMediaWidgetButton * CMediaWidgetButton_CreateInstance(HWND hwnd, int cx, int cy, int idCommand, int idImageList, int idAlt=0, int idTooltip=0, int idTooltipAlt=0);

class CMediaWidgetToggle : public CMediaWidgetButton
{
public:
    CMediaWidgetToggle(HWND, int, int);
    LRESULT Draw(LPNMTBCUSTOMDRAW pnmc);
    VOID SetState(BOOL fState);
    BOOL IsEnabled() { return TRUE; };

    BOOL _fState;
};

class CMediaWidgetOptions : public CMediaWidgetButton
{
public:
    CMediaWidgetOptions(HWND, int, int);
    LRESULT Draw(LPNMTBCUSTOMDRAW pnmc);
    BOOL IsEnabled() { return TRUE; }
    HRESULT Initialize(int idCommand, int idTooltip=0, int idTooltipAlt=0);
    VOID SetDepth(BOOL fDepth) { _fDepth = fDepth; };

    BOOL _fDepth;
};

class CMediaWidgetVolume : public CMediaWidget
{
public:
    CMediaWidgetVolume() : CMediaWidget(NULL, 0, 0) {};
    LRESULT Draw(LPNMTBCUSTOMDRAW pnmc) { return CDRF_DODEFAULT; };
    BOOL IsEnabled() { return TRUE; };
    HRESULT TranslateAccelerator(LPMSG pMsg);
    HRESULT Initialize(HWND hwnd);
};

class CMediaWidgetSeek : public CMediaWidget
{
public:
    CMediaWidgetSeek() : CMediaWidget(NULL, 0, 0) { _fState = FALSE; };
    LRESULT Draw(LPNMTBCUSTOMDRAW pnmc) { return CDRF_DODEFAULT; };
    BOOL IsEnabled() { return _fState; };
    HRESULT TranslateAccelerator(LPMSG pMsg);
    HRESULT Initialize(HWND hwnd);
    VOID SetState(BOOL fState);

    BOOL _fState;
 };

#define crMask  RGB(255, 0, 255)
#define COLOR_BKGND          RGB(71, 80, 158)
#define COLOR_BKGND2         RGB(92, 118, 186)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\mbbehave.h ===
//------------------------------------------------------------------------
//
//  Microsoft Windows 
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:      mbBehave.h
//
//  Contents:  mediaBar player behavior
//
//  Classes:   CMediaBehavior
//
//------------------------------------------------------------------------

#ifndef _MB_BEHAVE_H_
#define _MB_BEHAVE_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include "dpa.h"
#include "dspsprt.h"

class   CMediaBand;
class   CMediaBehavior;


interface IMediaBehaviorContentProxy  : public IUnknown
{
    STDMETHOD(IsDisableUIRequested)(BOOL *pfRequested) PURE;
    STDMETHOD(OnUserOverrideDisableUI)(void) PURE;
    STDMETHOD(IsNextEnabled)(BOOL *pfEnabled) PURE;
};
// {F4C74D34-AB35-4d67-A7CF-7845548F45A8}
DEFINE_GUID(IID_IMediaBehaviorContentProxy, 0xf4c74d34, 0xab35, 0x4d67, 0xa7, 0xcf, 0x78, 0x45, 0x54, 0x8f, 0x45, 0xa8);

/*
interface IMediaHost2  : public IMediaHost
{
    virtual STDMETHOD(DetachBehavior)(void) PURE;
    virtual STDMETHOD(OnDisableUIChanged)(BOOL fDisabled) PURE;
};
// {895EBF7E-ECA0-4ba8-B0F2-89DEBF70DE65}
DEFINE_GUID(IID_IMediaHost2, 0x895ebf7e, 0xeca0, 0x4ba8, 0xb0, 0xf2, 0x89, 0xde, 0xbf, 0x70, 0xde, 0x65);
*/


//------------------------------------------------------------------------
//------------------------------------------------------------------------
// need an additional operator to easily assign from VARIANTs
class CComDispatchDriverEx : public CComDispatchDriver
{
public:
    IDispatch* operator=(VARIANT vt)
    {
        IDispatch   *pThis = NULL;
        ASSERT((V_VT(&vt) == VT_UNKNOWN) || (V_VT(&vt) == VT_DISPATCH));
        if (V_VT(&vt) == VT_UNKNOWN) 
        {
            pThis = (IDispatch*) AtlComQIPtrAssign((IUnknown**)&p, V_UNKNOWN(&vt), IID_IDispatch);
        }
        else if (V_VT(&vt) == VT_DISPATCH)
        {
            pThis = (IDispatch*)AtlComPtrAssign((IUnknown**)&p, V_DISPATCH(&vt));
        }

        // ISSUE could make more efforts to accept REF variants too
        return pThis;
    }

    // get a property by name with a single parameter
    HRESULT GetPropertyByName1(LPCOLESTR lpsz, VARIANT* pvarParam1, VARIANT* pVar)
    {
        DISPID dwDispID;
        HRESULT hr = GetIDOfName(lpsz, &dwDispID);
        if (SUCCEEDED(hr))
        {
            DISPPARAMS dispparams = { pvarParam1, NULL, 1, 0};
            return p->Invoke(dwDispID, IID_NULL,
                            LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
                            &dispparams, pVar, NULL, NULL);
        }
        return hr;
    }
};


//------------------------------------------------------------------------
//------------------------------------------------------------------------
class CWMPWrapper
{
public:
    HRESULT             AttachToWMP();


protected:
    virtual HRESULT     FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj) = 0;
    STDMETHODIMP_(ULONG) _AddRef(void)
                        {
                            _cRef++;
                            return _cRef;
                        }
    STDMETHODIMP_(ULONG) _Release(void)
                        {
                            ASSERT(_cRef > 0);
                            _cRef--;
                            if (_cRef > 0)  return _cRef;
                            delete this;
                            return 0;
                        }
    HRESULT             _getVariantProp(LPCOLESTR pwszPropName, VARIANT *pvtParam, VARIANT *pvtValue, BOOL fCallMethod = FALSE);
    HRESULT             _getStringProp(LPCOLESTR pwszPropName, VARIANT *pvtParam, OUT BSTR *pbstrValue, BOOL fCallMethod = FALSE);

protected:
                        CWMPWrapper(CMediaBehavior* pHost);
    virtual            ~CWMPWrapper();

protected:
    CMediaBehavior    * _pHost;
    CComDispatchDriverEx    _pwmpWrapper;
    BOOL                _fStale;

private:
    ULONG               _cRef;
};

//------------------------------------------------------------------------
//------------------------------------------------------------------------
class CMediaItem        :   public CWMPWrapper,
                            public IMediaItem,
                            protected CImpIDispatch
{
typedef CWMPWrapper super;
public:
    // *** IUnknown ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void)   { return _AddRef(); }
    STDMETHODIMP_(ULONG) Release(void)  { return _Release(); }
    
    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // *** IMediaItem
    STDMETHOD(get_sourceURL)(BSTR *pbstrSourceURL);
    STDMETHOD(get_name)(BSTR *pbstrName);
    STDMETHOD(get_duration)(double * pDuration);
    STDMETHOD(get_attributeCount)(long *plCount);
    STDMETHOD(getAttributeName)(long lIndex, BSTR *pbstrItemName);
    STDMETHOD(getItemInfo)(BSTR bstrItemName, BSTR *pbstrVal);

protected:
    virtual HRESULT     FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj);
    friend CMediaItem*  CMediaItem_CreateInstance(CMediaBehavior* pHost);

                        CMediaItem(CMediaBehavior* pHost);
    virtual            ~CMediaItem();



private:
};

//------------------------------------------------------------------------
//------------------------------------------------------------------------
class CMediaItemNext        :   public CMediaItem
{
public:
protected:
    virtual HRESULT     FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj);
    friend CMediaItemNext*  CMediaItemNext_CreateInstance(CMediaBehavior* pHost);

                        CMediaItemNext(CMediaBehavior* pHost);
    virtual            ~CMediaItemNext();

private:
};

//------------------------------------------------------------------------
//------------------------------------------------------------------------
class CPlaylistInfo        :   public CWMPWrapper,
                               public IPlaylistInfo,
                               protected CImpIDispatch
{
typedef CWMPWrapper super;
public:
    // *** IUnknown ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void)   { return _AddRef(); }
    STDMETHODIMP_(ULONG) Release(void)  { return _Release(); }
    
    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // *** IPlaylistInfo
    STDMETHOD(get_name)(BSTR *pbstrName);
    STDMETHOD(get_attributeCount)(long *plCount);
    STDMETHOD(getAttributeName)(long lIndex, BSTR *pbstrItemName);
    STDMETHOD(getItemInfo)(BSTR bstrItemName, BSTR *pbstrVal);

protected:
    virtual HRESULT     FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj);
    friend CPlaylistInfo*  CPlaylistInfo_CreateInstance(CMediaBehavior* pHost);

                        CPlaylistInfo(CMediaBehavior* pHost);
private:
    virtual            ~CPlaylistInfo();

private:
};



//------------------------------------------------------------------------
//------------------------------------------------------------------------
class CMediaBehavior        :   public IMediaBehavior,
                                public IElementBehavior,
                                public IContentProxy,
                                public IMediaBehaviorContentProxy,
                                protected CImpIDispatch
{
public:
    // *** IUnknown ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void)
                        {
                            _cRef++;
                            return _cRef;
                        }
    STDMETHODIMP_(ULONG) Release(void)
                        {
                            ASSERT(_cRef > 0);
                            _cRef--;
                            if (_cRef > 0)  return _cRef;
                            delete this;
                            return 0;
                        }

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

    // *** IElementBehavior ***
    STDMETHOD(Detach)(void);
    STDMETHOD(Init)(IElementBehaviorSite* pBehaviorSite);
    STDMETHOD(Notify)(LONG lEvent, VARIANT* pVar);

    // *** IMediaBehavior ***
    STDMETHOD(playURL)(BSTR bstrURL, BSTR bstrMIME);
    STDMETHOD(stop)();
    STDMETHOD(playNext)();
    
    STDMETHOD(get_currentItem)(IMediaItem **ppMediaItem);
    STDMETHOD(get_nextItem)(IMediaItem **ppMediaItem);
    STDMETHOD(get_playlistInfo)(IPlaylistInfo **ppPlaylistInfo);

    STDMETHOD(get_hasNextItem)(VARIANT_BOOL *pfhasNext);
    STDMETHOD(get_playState)(mbPlayState *pps);
    STDMETHOD(get_openState)(mbOpenState *pos);
    STDMETHOD(get_enabled)(VARIANT_BOOL *pbEnabled);
    STDMETHOD(put_enabled)(VARIANT_BOOL bEnabled);
    STDMETHOD(get_disabledUI)(VARIANT_BOOL *pbDisabled);
    STDMETHOD(put_disabledUI)(VARIANT_BOOL bDisable);

    // *** IContentProxy **
    STDMETHOD(fireEvent)(enum contentProxyEvent event);
    STDMETHOD(OnCreatedPlayer)(void);
    STDMETHOD(detachPlayer)(void);

    // *** IMediaBehaviorContentProxy **
    STDMETHOD(IsDisableUIRequested)(BOOL *pfRequested);
    STDMETHOD(OnUserOverrideDisableUI)(void);
    STDMETHOD(IsNextEnabled)(BOOL *pfEnabled);

    HRESULT             getWMP(IDispatch **ppPlayer);
    HRESULT             getPlayListIndex(LONG *plIndex, LONG *plCount);

protected:
    friend CMediaBehavior* CMediaBehavior_CreateInstance(CMediaBand* pHost);

                        CMediaBehavior(CMediaBand* pHost);
private:
    virtual            ~CMediaBehavior();

private:
    HRESULT             _ConnectToWmpEvents(BOOL fConnect);
    BOOL                _ProcessEvent(DISPID dispid, long lCount, VARIANT varParams[]);

private:
    ULONG               _cRef;
    CMediaBand        * _pHost;
    CComPtr<IElementBehaviorSite>   _pBehaviorSite;
    CComPtr<IElementBehaviorSiteOM>   _pBehaviorSiteOM;
    DWORD               _dwcpCookie;
    BOOL                _fDisabledUI;
    CDPA<CMediaItem>    _apMediaItems;
    BOOL                _fPlaying;
};


//------------------------------------------------------------------------


#endif // _MB_BEHAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\mbutil.cpp ===
#include "priv.h"
#include "mbutil.h"
#include "legacy.h"
#include "mediahlpr.h"
#include "mediautil.h"
#include "mediaband.h"
#include "resource.h"
#include <mluisupp.h>
#include "apithk.h"

CMediaMRU::CMediaMRU()
{
    _hkey = NULL;
}

CMediaMRU::~CMediaMRU()
{
    if (_hkey)
        RegCloseKey(_hkey);
}

VOID CMediaMRU::Load(PTSTR pszKey)
{
    HKEY hkey = NULL;
    if (ERROR_SUCCESS==RegCreateKeyEx(HKEY_CURRENT_USER, pszKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                      NULL, &hkey, NULL))
    {
        _hkey = hkey;
    }
}

VOID CMediaMRU::Add(PTSTR pszData)
{
    if (!_hkey)
        return;

    ASSERT((pszData && *pszData));
        
    TCHAR szData[INTERNET_MAX_URL_LENGTH];
    TCHAR szTemp[INTERNET_MAX_URL_LENGTH];
    for (INT i = MEDIA_MRU_LIMIT-2; i>=0; i--)
    {
        if (!Get(i, szData))
        {
            continue;
        }

        TCHAR szValue[] = TEXT("0");        
        if (!PathUnExpandEnvStringsForUser(NULL, szData, szTemp, ARRAYSIZE(szTemp)))
        {
            StrCpyN(szTemp, szData, ARRAYSIZE(szTemp));
        }
        *szValue = TEXT('0')+(TCHAR)i+1;
        SHSetValue(_hkey, NULL, szValue, REG_EXPAND_SZ, szTemp, (lstrlen(szTemp)+1)*sizeof(TCHAR));
    }
    if (!PathUnExpandEnvStringsForUser(NULL, pszData, szTemp, ARRAYSIZE(szTemp)))
    {
        StrCpyN(szTemp, pszData, ARRAYSIZE(szTemp));
    }
    SHSetValue(_hkey, NULL, TEXT("0"), REG_EXPAND_SZ, szTemp, (lstrlen(szTemp)+1)*sizeof(TCHAR));
}

VOID CMediaMRU::Delete(INT iWhich)
{
    if (!_hkey)
        return;

    TCHAR szData[INTERNET_MAX_URL_LENGTH];
    TCHAR szTemp[INTERNET_MAX_URL_LENGTH];
    for (INT i = iWhich; i<MEDIA_MRU_LIMIT; i++)
    {
        if (!Get(i+1, szData))
        {
            continue;
        }

        TCHAR szValue[] = TEXT("0");        
        if (!PathUnExpandEnvStringsForUser(NULL, szData, szTemp, ARRAYSIZE(szTemp)))
        {
            StrCpyN(szTemp, szData, ARRAYSIZE(szTemp));
        }
        *szValue = TEXT('0')+(TCHAR)i;
        SHSetValue(_hkey, NULL, szValue, REG_EXPAND_SZ, szTemp, (lstrlen(szTemp)+1)*sizeof(TCHAR));
    }
}

BOOL CMediaMRU::Get(INT iWhich, PTSTR pszOut)
{
    BOOL fRet = FALSE;

    TCHAR szValue[] = TEXT("0");        
    DWORD dwType, cb = INTERNET_MAX_URL_LENGTH;

    *szValue = TEXT('0')+(TCHAR)iWhich;
    if (ERROR_SUCCESS==SHGetValue(_hkey, NULL, szValue, &dwType, pszOut, &cb))
    {
        fRet = TRUE;
    }
    return fRet;
}

CMediaWidget::CMediaWidget(HWND hwnd, int cx, int cy)
{
    _hwnd = NULL;
    _hwndParent = hwnd;
    _cx = cx;
    _cy = cy;
}

CMediaWidget::~CMediaWidget()
{
    DESTROY_OBJ_WITH_HANDLE(_hwnd, DestroyWindow);
}

CMediaWidgetButton* 
CMediaWidgetButton_CreateInstance(HWND hwnd, int cx, int cy, int idCommand, int idImageList, int idAlt, int idTooltip, int idTooltipAlt)
{
    CMediaWidgetButton* pmwb = new CMediaWidgetButton(hwnd, cx, cy);
    if (pmwb)
    {
        HRESULT hr = pmwb->Initialize(idCommand, idTooltip, idTooltipAlt);
        if (SUCCEEDED(hr) && idImageList)
        {
            hr = pmwb->SetImageList(idImageList);
        }
        if (SUCCEEDED(hr) && idAlt)
        {
            hr = pmwb->SetAlternateImageList(idAlt);
        }
        if (FAILED(hr))
        {
            delete pmwb;
            pmwb = NULL;
        }
    }
    return pmwb;
}

CMediaWidgetButton::CMediaWidgetButton(HWND hwnd, int cx, int cy) : CMediaWidget(hwnd, cx, cy)
{
    _himl = _himlAlt = NULL;
    _dwMode = MWB_NORMAL;
    _fImageSource = TRUE;
    _iCommand = _iTooltip = _iTooltipAlt = 0;
}

CMediaWidgetButton::~CMediaWidgetButton()
{
    DESTROY_OBJ_WITH_HANDLE(_himl, ImageList_Destroy);
    DESTROY_OBJ_WITH_HANDLE(_himlAlt, ImageList_Destroy);
}

HRESULT CMediaWidgetButton::Initialize(int idCommand, int idTooltip, int idTooltipAlt)
{
    HRESULT hr = E_FAIL;
    _hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                           WS_TABSTOP |WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |  
                           TBSTYLE_FLAT | TBSTYLE_TOOLTIPS | TBSTYLE_TRANSPARENT |
                           CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NORESIZE,
                           0, 0, 0, 0, _hwndParent, NULL, HINST_THISDLL, NULL);
    if (_hwnd)
    {
        _iCommand = idCommand;
        TBBUTTON tb;
        tb.iBitmap = 0;
        tb.idCommand = idCommand;
        tb.fsState = TBSTATE_ENABLED;
        tb.fsStyle = BTNS_AUTOSIZE | BTNS_BUTTON;
        tb.dwData = 0; //(DWORD_PTR)this;
        tb.iString = 0;

        SendMessage(_hwnd, TB_BUTTONSTRUCTSIZE, SIZEOF(TBBUTTON), 0);
        SendMessage(_hwnd, TB_SETMAXTEXTROWS, 0, 0L);
        if (idTooltip)
        {
            if (idTooltipAlt)
            {
                _iTooltip = idTooltip;
                _iTooltipAlt = idTooltipAlt;
            }
            else
            {
                tb.iString = (int)SendMessage(_hwnd, TB_ADDSTRING, (WPARAM)MLGetHinst(), MAKELPARAM(idTooltip, 0));
            }
        }
        SendMessage(_hwnd, TB_ADDBUTTONS, 1, (LPARAM)&tb);
        SendMessage(_hwnd, TB_SETPADDING, 0, MAKELPARAM(0, 1));
        ShowWindow(_hwnd, SW_SHOW);
        Comctl32_SetDPIScale(_hwnd);
        hr = S_OK;
    }
    
    return hr;
}

HRESULT CMediaWidgetButton::SetImageList(INT iResource)
{
    HRESULT hr = E_FAIL;

    ASSERT(_cx && _cy);
    DESTROY_OBJ_WITH_HANDLE(_himl, ImageList_Destroy);
    _himl = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(iResource), _cx, 0, crMask,
                                                 IMAGE_BITMAP, LR_CREATEDIBSECTION);
    if (_himl && _hwnd)
    {
        SendMessage(_hwnd, TB_SETIMAGELIST, 0, (LPARAM)_himl);
        SendMessage(_hwnd, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)_himl);
        SendMessage(_hwnd, TB_SETHOTIMAGELIST, 0, (LPARAM)_himl);

        hr = S_OK;
    }

    return hr;
}

HRESULT CMediaWidgetButton::SetAlternateImageList(INT iResource)
{
    HRESULT hr = E_FAIL;
    ASSERT(_himl);
    ASSERT(_cx && _cy);
    DESTROY_OBJ_WITH_HANDLE(_himlAlt, ImageList_Destroy);
    _himlAlt = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(iResource), _cx, 0, crMask,
                                                 IMAGE_BITMAP, LR_CREATEDIBSECTION);
    if (_himlAlt)
    {
        hr = S_OK;
    }
    ASSERT(_iTooltipAlt);
    SetImageSource(TRUE);

    return hr;
}

HRESULT CMediaWidgetButton::SetImageSource(BOOL fImageSource)
{
    ASSERT(_himlAlt);
    if (_himlAlt)
    {
        _fImageSource = fImageSource;
        if (_hwnd)
        {
            InvalidateRect(_hwnd, NULL, FALSE);
            UpdateWindow(_hwnd);

            INT i = fImageSource ? _iTooltip : _iTooltipAlt;
            if (i)
            {
                // ISSUE Why are we doing this? Because on Win9x, the tooltips code isn't working 
                //       no matter how hard I pound.
                TCHAR szText[MAX_PATH];
                if (MLLoadStringW(i, szText, ARRAYSIZE(szText)))
                {
                    TBBUTTONINFO tb = {0};
                    tb.cbSize = sizeof(tb);
                    tb.dwMask = TBIF_TEXT;
                    tb.pszText = szText;
                    SendMessage(_hwnd, TB_SETBUTTONINFO, _iCommand, (LPARAM)&tb);
                }
            }
        }
    }
    return S_OK;
}

HRESULT CMediaWidgetButton::SetMode(DWORD dwMode)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_BYINDEX | TBIF_IMAGE;
    SendMessage(_hwnd, TB_GETBUTTONINFO, (WPARAM)0, (LPARAM)&tbbi);
    tbbi.iImage = (INT)dwMode;            
    SendMessage(_hwnd, TB_SETBUTTONINFO, (WPARAM)0, (LPARAM)&tbbi);
    _dwMode = dwMode;
    return S_OK;
}

LRESULT CMediaWidgetButton::Draw(LPNMTBCUSTOMDRAW pnm)
{
    LPNMTBCUSTOMDRAW pnmc = (LPNMTBCUSTOMDRAW)pnm;
    LRESULT lres;

    switch (pnmc->nmcd.dwDrawStage) 
    {
        case CDDS_PREPAINT:
            lres = CDRF_NOTIFYITEMDRAW;
            break;

        case CDDS_PREERASE:
            lres = CDRF_NOTIFYITEMDRAW;
            break;

        case CDDS_ITEMPREPAINT:
        {
            HIMAGELIST himl = _fImageSource ? _himl : _himlAlt;
            INT index = MWB_NORMAL;

            if (SendMessage(_hwnd, TB_GETSTATE, (WPARAM)pnmc->nmcd.dwItemSpec, 0) & TBSTATE_ENABLED)
            {
                index = (pnmc->nmcd.uItemState & CDIS_SELECTED) 
                            ? MWB_PRESSED 
                            : (pnmc->nmcd.uItemState & CDIS_HOT) ? MWB_HOT : _dwMode;
            }
            else
            {
                index = MWB_DISABLED;
            }

            if (himl)
            {
                UINT uFlags = ILD_TRANSPARENT | (IsOS(OS_WHISTLERORGREATER) ? ILD_DPISCALE : 0);
                INT x = pnmc->nmcd.rc.left;
                if (g_bRunOnMemphis && IS_WINDOW_RTL_MIRRORED(_hwnd))
                {
                    x++;
                }
                ImageList_Draw(himl, index, pnmc->nmcd.hdc, x, 1, uFlags);
                lres = CDRF_SKIPDEFAULT;
                break;
            }
        }

        default:
            lres = CDRF_DODEFAULT;
            break;
    }
    return lres;
}

BOOL CMediaWidgetButton::IsEnabled()
{
    return ((BOOL)SendMessage(_hwnd, TB_GETSTATE, _iCommand, 0) & TBSTATE_ENABLED);
}

HRESULT CMediaWidgetButton::TranslateAccelerator(LPMSG pMsg)
{
    return (_hwnd && SendMessage(_hwnd, TB_TRANSLATEACCELERATOR, 0, (LPARAM)pMsg)) ? S_OK : S_FALSE;
}

CMediaWidgetToggle::CMediaWidgetToggle(HWND hwnd, int cx, int cy) : CMediaWidgetButton(hwnd, cx, cy)
{
    _fState = FALSE;
}

LRESULT CMediaWidgetToggle::Draw(LPNMTBCUSTOMDRAW pnm)
{
    LPNMTBCUSTOMDRAW pnmc = (LPNMTBCUSTOMDRAW)pnm;
    LRESULT lres;

    switch (pnmc->nmcd.dwDrawStage) 
    {
        case CDDS_PREPAINT:
            lres = CDRF_NOTIFYITEMDRAW;
            break;

        case CDDS_PREERASE:
            lres = CDRF_NOTIFYITEMDRAW;
            break;

        case CDDS_ITEMPREPAINT:
        {
            INT index = MWB_NORMAL;
            if (_fState)
            {
                index = MWB_PRESSED;
            }
            else if (pnmc->nmcd.uItemState & CDIS_HOT)
            {
                index = MWB_HOT;
            }

            if (_himl)
            {
                UINT uFlags = ILD_TRANSPARENT | (IsOS(OS_WHISTLERORGREATER) ? ILD_DPISCALE : 0);
                INT x = pnmc->nmcd.rc.left;
                if (g_bRunOnMemphis && IS_WINDOW_RTL_MIRRORED(_hwnd))
                {
                    x++;
                }
                ImageList_Draw(_himl, index, pnmc->nmcd.hdc, x, 1, uFlags);
                lres = CDRF_SKIPDEFAULT;
                break;
            }
        }

        default:
            lres = CDRF_DODEFAULT;
            break;
    }
    return lres;
}


VOID CMediaWidgetToggle::SetState(BOOL fState)
{
    _fState = fState;
    InvalidateRect(_hwnd, NULL, FALSE);
    UpdateWindow(_hwnd);

    INT i = fState ? _iTooltip : _iTooltipAlt;
    if (i)
    {
        TCHAR szText[MAX_PATH];
        if (MLLoadStringW(i, szText, ARRAYSIZE(szText)))
        {
            TBBUTTONINFO tb = {0};
            tb.cbSize = sizeof(tb);
            tb.dwMask = TBIF_TEXT;
            tb.pszText = szText;
            SendMessage(_hwnd, TB_SETBUTTONINFO, _iCommand, (LPARAM)&tb);
        }
    }
}

CMediaWidgetOptions::CMediaWidgetOptions(HWND hwnd, int cx, int cy)  : CMediaWidgetButton(hwnd, cx, cy)
{
    _fDepth = TRUE;
}

HRESULT CMediaWidgetOptions::Initialize(int idCommand, int idTooltip, int idTooltipAlt)
{
    HRESULT hr = E_FAIL;

    _hwnd  = CreateWindowEx(WS_EX_TOOLWINDOW | TBSTYLE_EX_MIXEDBUTTONS | WS_EX_WINDOWEDGE, TOOLBARCLASSNAME, NULL,
                                   WS_TABSTOP| WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                                   TBSTYLE_FLAT | TBSTYLE_TOOLTIPS | TBSTYLE_CUSTOMERASE | TBSTYLE_LIST | TBSTYLE_TRANSPARENT |
                                   CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NORESIZE,
                                   0, 0, 0, 0, _hwndParent, NULL, HINST_THISDLL, NULL);
    if (_hwnd)
    {
        static const TBBUTTON tbInfoBar[] =
        {
            { I_IMAGECALLBACK, FCIDM_MEDIABAND_PLAYINFO, TBSTATE_ENABLED, BTNS_SHOWTEXT | BTNS_WHOLEDROPDOWN, {0,0}, 0, 0 },
        };

        // Init the toolbar control
        SendMessage(_hwnd, TB_BUTTONSTRUCTSIZE, SIZEOF(TBBUTTON), 0);
        SendMessage(_hwnd, TB_SETMAXTEXTROWS, 1, 0L);
        
        RECT rcClient;
        GetClientRect(_hwndParent, &rcClient);
        SendMessage(_hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(10,10));
        SendMessage(_hwnd, TB_ADDBUTTONS, ARRAYSIZE(tbInfoBar), (LPARAM)tbInfoBar);
        SendMessage(_hwnd, TB_SETBITMAPSIZE, 0, MAKELONG(0, 0));

        // Need to disable theming on this item
        SetWindowTheme(_hwnd, TEXT(""), TEXT(""));

        ShowWindow(_hwnd, SW_SHOW);
        hr = S_OK;
    }
    
    return hr;
}


LRESULT CMediaWidgetOptions::Draw(LPNMTBCUSTOMDRAW pnm)
{
    LRESULT lres = CDRF_NOTIFYITEMDRAW;

    switch (pnm->nmcd.dwDrawStage) 
    {
        case CDDS_PREPAINT:
        case CDDS_PREERASE:
            break;

        case CDDS_ITEMPREPAINT:
        {
            pnm->clrText = _fDepth ? RGB(255,255,255) : RGB(0,0,0);
            if (_fDepth)
            {
                lres |= TBCDRF_HILITEHOTTRACK;
                pnm->clrHighlightHotTrack = COLOR_BKGND2;
            }          
            break;
        }

        default:
            lres = CDRF_DODEFAULT;
            break;
    }
    return lres;
}


HRESULT CMediaWidgetSeek::Initialize(HWND hwnd)
{
    _hwnd = hwnd;
    return S_OK;
}

HRESULT CMediaWidgetSeek::TranslateAccelerator(LPMSG pMsg)
{
    return S_FALSE;
}

VOID CMediaWidgetSeek::SetState(BOOL fState)
{
    _fState = fState;

    InvalidateRect(_hwnd, NULL, FALSE);
    UpdateWindow(_hwnd);
}


HRESULT CMediaWidgetVolume::Initialize(HWND hwnd)
{
    _hwnd = hwnd;
    return S_OK;
}

HRESULT CMediaWidgetVolume::TranslateAccelerator(LPMSG pMsg)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\mrulist.cpp ===
/**************************************************************\
    FILE: mrulist.cpp

    DESCRIPTION:
        CMRUList implements the Shell Name Space List or DriveList.
    This will store a pidl and be able to populate the AddressBand
    combobox with the shell name space that includes that PIDL.
\**************************************************************/

#include "priv.h"
#include "addrlist.h"
#include "itbar.h"
#include "itbdrop.h"
#include "util.h"
#include "autocomp.h"
#include <urlhist.h>
#include <winbase.h>
#include <wininet.h>

#define SUPERCLASS CAddressList



///////////////////////////////////////////////////////////////////
// #DEFINEs
#define MRU_LIST_MAX_CONST            25

///////////////////////////////////////////////////////////////////
// Data Structures
typedef struct tagSIZESTRCOMBO
{
    DWORD dwStringSize; // Size in Characters (not bytes)
    LPTSTR lpszString;
    int iImage;
    int iSelectedImage;
} SIZESTRCOMBO;

///////////////////////////////////////////////////////////////////
// Prototypes

/**************************************************************\
    CLASS: CMRUList

    DESCRIPTION:
        The MRU List will contain the type MRU history for the
    browser.  This is an IAddressList used by the Address Band/Bar.
\**************************************************************/

class CMRUList  : public CAddressList
                , public IMRU
                , public IPersistStream
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////

    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IAddressList methods ***
    virtual STDMETHODIMP Connect(BOOL fConnect, HWND hwnd, IBrowserService * pbs, IBandProxy * pbp, IAutoComplete * pac);
    virtual STDMETHODIMP Refresh(DWORD dwType);
    virtual STDMETHODIMP Save(void);

  // *** IPersistStream methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID){ *pClassID = CLSID_MRUList; return S_OK; }
    virtual STDMETHODIMP Load(IStream *pStm) { return S_OK; }
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    virtual STDMETHODIMP IsDirty(void) { return S_FALSE; }
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize) { return E_NOTIMPL; }

    // *** IMRU methods ***
    virtual STDMETHODIMP AddEntry(LPCWSTR pszEntry);


    // IWinEventHandler
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

protected:
    //////////////////////////////////////////////////////
    // Private Member Functions
    //////////////////////////////////////////////////////

    // Constructor / Destructor
    CMRUList();
    ~CMRUList(void);        // This is now an OLE Object and cannot be used as a normal Class.

    // Address List Modification Functions
    HRESULT _UpdateMRUEntry(LPCTSTR szNewValue, int nIndex, int iImage , int iISelectedImage);
    HRESULT _LoadList(void);
    HKEY _GetRegKey(BOOL fCreate);
    HRESULT _UpdateMRU(void);
    int _FindInMRU(LPCTSTR szURL);
    HRESULT _MRUMerge(HKEY kKey);
    BOOL _MoveAddressToTopOfMRU(int nMRUIndex);
    HRESULT _PopulateOneItem(void);
    HRESULT _Populate(void);
    void _InitCombobox(void);
    HRESULT _SetTopItem(void);

    // Friend Functions
    friend IAddressList * CMRUList_Create(void);

    //////////////////////////////////////////////////////
    //  Private Member Variables
    //////////////////////////////////////////////////////
    BOOL                _fDropDownPopulated;// Have we populated the drop down yet?
    BOOL                _fListLoaded;       // Have we loaded the Type-in MRU?
    BOOL                _fMRUUptodate;      // Is it necessary to update the MRU?
    BOOL                _fNeedToSave;      // Do we need to update the registry?
    SIZESTRCOMBO        _szMRU[MRU_LIST_MAX_CONST];  // MRU list.
    int                 _nMRUSize;          // Number of entries in MRU used.
};




//=================================================================
// Implementation of CMRUList
//=================================================================


/****************************************************\
    FUNCTION: CMRUList_Create

    DESCRIPTION:
        This function will create an instance of the
    CMRUList COM object.
\****************************************************/
IAddressList * CMRUList_Create(void)
{
    CMRUList *p = new CMRUList();

    return p;
}


/****************************************************\

    Address Band Constructor

\****************************************************/
CMRUList::CMRUList()
{
}


/****************************************************\

    Address Band destructor

\****************************************************/
CMRUList::~CMRUList()
{
    // loop through every potential saved URL in registry.
    if (_fListLoaded)
    {
        for (int nIndex = 0; (nIndex < MRU_LIST_MAX_CONST) && (_szMRU[nIndex].lpszString); nIndex++)
        {
            LocalFree(_szMRU[nIndex].lpszString);
        }
    }
}


//===========================
// *** IUnknown Interface ***
HRESULT CMRUList::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IMRU))
    {
        *ppvObj = SAFECAST(this, IMRU*);
    }
    else if (IsEqualIID(riid, IID_IPersistStream))
    {
        *ppvObj = SAFECAST(this, IPersistStream*);
    }
    else
    {
        return SUPERCLASS::QueryInterface(riid,ppvObj);
    }

    AddRef();
    return S_OK;
}

ULONG CMRUList::AddRef()
{
    return SUPERCLASS::AddRef();
}

ULONG CMRUList::Release()
{
    return SUPERCLASS::Release();
}


//================================
// *** IAddressList Interface ***

/****************************************************\
    FUNCTION: Connect

    DESCRIPTION:
        We are either becoming the selected list for
    the AddressBand's combobox, or lossing this status.
    We need to populate or unpopulate the combobox
    as appropriate.
\****************************************************/

HRESULT CMRUList::Connect(BOOL fConnect, HWND hwnd, IBrowserService * pbs, IBandProxy * pbp, IAutoComplete * pac)
{
    HRESULT hr = S_OK;

    _fVisible = fConnect;
    if (!_hwnd)
        _hwnd = hwnd;
    ASSERT(_hwnd);

    if (fConnect)
    {
        // This needs to come before because it setups up
        // pointers that we need.
        SUPERCLASS::Connect(fConnect, hwnd, pbs, pbp, pac);

        // Initial combobox parameters.
        if (_pbp && _pbp->IsConnected() == S_FALSE)
        {
            // Do these tasks only the first time and only if
            // we are not in a browser window (because it will come
            // from the navigation complete).
            _PopulateOneItem();
        }
    }
    else
    {
        _UpdateMRU();    // Save contents of MRU because the ComboBox will be purged.
        _fDropDownPopulated = FALSE;

        // This call needs to come after _UpdateMRU() because
        // it releases pointers that we need.
        SUPERCLASS::Connect(fConnect, hwnd, pbs, pbp, pac);
    }
    return hr;
}


/****************************************************\
    FUNCTION: _SetTopItem

    DESCRIPTION:
        TODO.
\****************************************************/
HRESULT CMRUList::_SetTopItem(void)
{
    COMBOBOXEXITEM cbexItem = {0};
    LPCTSTR pszData = _szMRU[0].lpszString;

    if (pszData) {
        cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
        cbexItem.iItem = -1;
        cbexItem.pszText =(LPTSTR)pszData;
        cbexItem.cchTextMax = lstrlen(pszData);
        if(_szMRU[0].iImage == -1 ||  _szMRU[0].iSelectedImage == -1) {
            _GetUrlUI(NULL,pszData, &(_szMRU[0].iImage),\
                                      &(_szMRU[0].iSelectedImage));
        }

        cbexItem.iImage =_szMRU[0].iImage;
        cbexItem.iSelectedImage = _szMRU[0].iSelectedImage;

        SendMessage(_hwnd, CBEM_SETITEM, (WPARAM)0, (LPARAM)(LPVOID)&cbexItem);
    }
    return S_OK;
}


//================================
// *** IMRU Interface ***
/*******************************************************************
    FUNCTION: AddEntry

    DESCRIPTION:
        Adds the specified URL to the top of the address bar
    combo box.  Limits the number of URLs in combo box to
    MRU_LIST_MAX_CONST.
********************************************************************/
HRESULT CMRUList::AddEntry(LPCWSTR pszEntry)
{
    HRESULT hr = S_OK;

    _fNeedToSave = TRUE;
    if (_fDropDownPopulated)
    {
        _ComboBoxInsertURL(pszEntry, MAX_URL_STRING, MRU_LIST_MAX_CONST);
        _fMRUUptodate = FALSE;
    }
    else
    {
        int nMRUIndex;

        if (!_fListLoaded)
            _LoadList();

        // Since we don't own the ComboBox, we need to add it to
        // the end of our MRU data.
        nMRUIndex = _FindInMRU(pszEntry);  // Now make it the top most.

        if (-1 != nMRUIndex)
        {
            // We already have this entry in our list, so all we need
            // to do is move it to the top.
            _MoveAddressToTopOfMRU(nMRUIndex);
            return hr;
        }


        for (nMRUIndex = 0; nMRUIndex < MRU_LIST_MAX_CONST; nMRUIndex++)
        {
            if (!_szMRU[nMRUIndex].lpszString)
            {   // We found an empty spot.
                _UpdateMRUEntry(pszEntry, nMRUIndex, -1, -1);
                break;  // We are done.
            }
        }



        if (MRU_LIST_MAX_CONST == nMRUIndex)
        {
            // The MRU is full so we will replace the last entry.
            _UpdateMRUEntry(pszEntry, --nMRUIndex, -1, -1);
        }

        _MoveAddressToTopOfMRU(nMRUIndex);  // Now make it the top most.
    }
    TraceMsg(TF_BAND|TF_GENERAL, "CMRUList: AddEntry(), URL=%s", pszEntry);
    return hr;
}


//================================
// *** IPersistStream Interface ***

/****************************************************\
    FUNCTION: Save

    DESCRIPTION:
        TODO.
\****************************************************/

HRESULT CMRUList::Save(IStream *pstm, BOOL fClearDirty)
{
    // APPCOMPAT: There currently is a bug in the shell that it leaks
    //         an object.  This causes CAddressBand to never be
    //         destructed when hosted in the TaskBar.
    //         Since we normally call IAddressList::SaveList() in the
    //         destructor, we will now need to call it
    //         from here in that case.
    if (_pbp && _pbp->IsConnected() == S_FALSE)
    {
        Save();
    }

    return S_OK;
}


/****************************************************\
    FUNCTION: _InitCombobox

    DESCRIPTION:
        Prepare the combo box for this list.  This normally
    means that the indenting and icon are either turned
    on or off.
\****************************************************/

void CMRUList::_InitCombobox()
{
    HIMAGELIST himlSysSmall;
    Shell_GetImageLists(NULL, &himlSysSmall);

    SendMessage(_hwnd, CBEM_SETIMAGELIST, 0, (LPARAM)himlSysSmall);
    SendMessage(_hwnd, CBEM_SETEXTENDEDSTYLE, 0,0);
    SUPERCLASS::_InitCombobox();
}

HKEY CMRUList::_GetRegKey(BOOL fCreate)
{
    BOOL fIsConnected = FALSE;
    HKEY hKey;
    DWORD result;
    LPCTSTR pszKey;

    if (_pbp)
        fIsConnected = (_pbp->IsConnected() == S_OK);
    if (fIsConnected)
        pszKey = SZ_REGKEY_TYPEDURLMRU;
    else
        pszKey = SZ_REGKEY_TYPEDCMDMRU;

    if (fCreate)
        result = RegCreateKey(HKEY_CURRENT_USER, pszKey, &hKey);
    else
        result = RegOpenKey(HKEY_CURRENT_USER, pszKey, &hKey);

    if (result != ERROR_SUCCESS)
        return NULL;

    return hKey;
}

/****************************************************\
    FUNCTION: _LoadList

    DESCRIPTION:
        When the ComboBox is switched to this MRU
    AddressList, the contents need to be populated.  Before
    that happens, we copy the data to the combobox
    from the registry.
\****************************************************/

HRESULT CMRUList::_LoadList(void)
{
    HRESULT hr = S_OK;
    HKEY hKey;
    DWORD dwCount;
    TCHAR szAddress[MAX_URL_STRING+1];

    ASSERT(!_fListLoaded);
    ASSERT(_hwnd);

    hKey = _GetRegKey(TRUE);
    ASSERT(hKey);
    if (!hKey)
        return E_FAIL;


    for (dwCount = 0; dwCount < MRU_LIST_MAX_CONST ; dwCount++)
    {
        hr = GetMRUEntry(hKey, dwCount, szAddress, SIZECHARS(szAddress), NULL);

        if (SUCCEEDED(hr))
            _UpdateMRUEntry(szAddress, (int)dwCount, -1, -1);
        else
        {
            _szMRU[dwCount].lpszString = NULL;
            _szMRU[dwCount].iImage = -1;
            _szMRU[dwCount].iSelectedImage = -1;
        }
    }


    RegCloseKey(hKey);
    _fListLoaded = TRUE;

    return hr;
}


/****************************************************\
    FUNCTION: Save

    DESCRIPTION:
        When this object is closed, we save the contents
    to the registry.
\****************************************************/

HRESULT CMRUList::Save(void)
{
    HRESULT hr = S_OK;
    HKEY hKey;
    DWORD result;
    TCHAR szValueName[10];   // big enough for "url99"
    int nCount;
    int nItems = (_fDropDownPopulated) ? ComboBox_GetCount(_hwnd) : _nMRUSize;

    if (!_fListLoaded || !_fNeedToSave) // Don't save the registry if we don't need to.
        return S_OK;

    if (!_fMRUUptodate)
        hr = _UpdateMRU();

    hKey = _GetRegKey(TRUE);
    ASSERT(hKey);
    if (!hKey)
        return E_FAIL;

    hr = _MRUMerge(hKey);  // Merge if the list has been modified.

    // loop through every potential saved URL in registry.
    for (nCount = 0; nCount < MRU_LIST_MAX_CONST; nCount++)
    {
        // make a value name a la "url1" (1-based for historical reasons)
        wnsprintf(szValueName, ARRAYSIZE(szValueName), SZ_REGVAL_MRUENTRY, nCount+1);

        // for every combo box item we have, get the corresponding
        // text and save it in the registry
        if (nCount < nItems && _szMRU[nCount].lpszString)
        {
            // store it in registry and off to the next one.
            result = SHSetValue(hKey, NULL, szValueName, REG_SZ, (CONST BYTE *) _szMRU[nCount].lpszString,
                    _szMRU[nCount].dwStringSize*SIZEOF(TCHAR));
        }
        else
        {
            // if we get here, we've run out of combo box items (or
            // failed to retrieve text for one of them).  Delete any
            // extra items that may be lingering in the registry.
            SHDeleteValue(hKey, NULL, szValueName);
        }
    }
    _fNeedToSave = FALSE;

    RegCloseKey(hKey);
    return hr;
}


/****************************************************\
    FUNCTION: _MRUMerge

    DESCRIPTION:
        This function will merge the current contents
    of the saved MRU.  This means that if the Address
    Band is being closed, it will load the MRU again
    because it could have been saved by a AddressBar
    that was recently closed down.  The merge happens
    like this: If the MRU is not full, items
    in the registry will be appended to the end
    of the MRU if they don't currently exist in the
    MRU.
\****************************************************/
HRESULT CMRUList::_MRUMerge(HKEY hKey)
{
    HRESULT hr = S_OK;
    UINT nCount;
    UINT nNextFreeSlot = _nMRUSize;
    long lResult;
    TCHAR szValueName[10];   // big enough for "url99"
    TCHAR szAddress[MAX_URL_STRING+1];
    DWORD dwAddress;

    ASSERT(_fListLoaded);
    ASSERT(hKey);


    for (nCount = 0; (nCount < MRU_LIST_MAX_CONST) && (nNextFreeSlot < MRU_LIST_MAX_CONST); nCount++)
    {
        // make a value name a la "url1" (1-based for historical reasons)
        wnsprintf(szValueName, ARRAYSIZE(szValueName), SZ_REGVAL_MRUENTRY, nCount+1);

        dwAddress = SIZEOF(szAddress);

        lResult = SHQueryValueEx(hKey, szValueName, NULL, NULL, (LPBYTE) szAddress, &dwAddress);
        if (ERROR_SUCCESS == lResult)
        {
            if (-1 == _FindInMRU(szAddress))
            {
                // We found a unique item.  Add it to our free slot.
                _UpdateMRUEntry(szAddress, nNextFreeSlot++, -1, -1);
            }
        }
        else
            break;
    }


    // REARCHITECT: Because the AddressBand is always closed after all
    //         AddressBars when the shell is shut down, anything
    //         new in the AddressBars will be ignored if the
    //         MRU in the AddressBand is full.  Revisit.

    return hr;
}


/****************************************************\
    FUNCTION: _UpdateMRU

    DESCRIPTION:
        Save the contents of the Combobox because
    it will be purged for the next AddressList.
\****************************************************/
HRESULT CMRUList::_UpdateMRU(void)
{
    HRESULT hr = S_OK;
    TCHAR szAddress[MAX_URL_STRING+1];
    // get the number of items in combo box
    int nItems;
    int nCount;

    if (!_hwnd)
        return S_OK;

    if (!_fDropDownPopulated)
        return S_OK;        // Nothing to update.
    nItems = ComboBox_GetCount(_hwnd);

    ASSERT(_hwnd);

    // loop through every potential saved URL in registry.
    for (nCount = 0; nCount < MRU_LIST_MAX_CONST; nCount++)
    {
        // for every combo box item we have, get the corresponding
        // text and save it in our local array.
        if (nCount < nItems)
        {
            COMBOBOXEXITEM cbexItem = {0};

            cbexItem.mask = CBEIF_TEXT|CBEIF_IMAGE|CBEIF_SELECTEDIMAGE;
            cbexItem.pszText = szAddress;
            cbexItem.cchTextMax = ARRAYSIZE(szAddress);
            cbexItem.iItem = nCount;

            if (SendMessage(_hwnd, CBEM_GETITEM, 0, (LPARAM) &cbexItem))
            {
                hr = _UpdateMRUEntry(szAddress, nCount, cbexItem.iImage, cbexItem.iSelectedImage);
            }
        }
        else
        {
            if (_szMRU[nCount].lpszString)
            {
                // Free this array entry because it's not being used.
                LocalFree(_szMRU[nCount].lpszString);
                _szMRU[nCount].lpszString = NULL;
                _szMRU[nCount].iImage = -1;
                _szMRU[nCount].iSelectedImage = -1;

                _nMRUSize--;
            }
        }
    }
    _fMRUUptodate = TRUE;

    TraceMsg(TF_BAND|TF_GENERAL, "CMRUList: _UpdateMRU().");
    return hr;
}


/****************************************************\
    FUNCTION: _UpdateMRUEntry

    DESCRIPTION:
        When the ComboBox is switched to this MRU
    AddressList, the contents need to be populated.  Before
    that happens, we copy the data to the combobox
    from the registry.
\****************************************************/
HRESULT CMRUList::_UpdateMRUEntry(LPCTSTR szNewValue, int nIndex, int iImage , int iSelectedImage)
{
    DWORD dwStrSize = lstrlen(szNewValue);

    if (!szNewValue)
    {
        // The caller wants us to free the string.
        if (_szMRU[nIndex].lpszString)
        {
            // We have a string that needs freeing.
            LocalFree(_szMRU[nIndex].lpszString);
            _szMRU[nIndex].lpszString = NULL;
            _nMRUSize--;
        }
        return S_OK;
    }

    if (!(_szMRU[nIndex].lpszString))
    {
        // We need to create the string buffer
        _szMRU[nIndex].dwStringSize = dwStrSize+1;
        _szMRU[nIndex].lpszString = (LPTSTR) LocalAlloc(LPTR, _szMRU[nIndex].dwStringSize*SIZEOF(TCHAR));
        if (!(_szMRU[nIndex].lpszString))
            return E_FAIL;
        _nMRUSize++;
    }

    if (dwStrSize + 1 > _szMRU[nIndex].dwStringSize)
    {
        // We need to increase the size of the buffer.
        LocalFree(_szMRU[nIndex].lpszString);
        _szMRU[nIndex].dwStringSize = dwStrSize+1;
        _szMRU[nIndex].lpszString = (LPTSTR) LocalAlloc(LPTR, _szMRU[nIndex].dwStringSize*SIZEOF(TCHAR));
        if (!(_szMRU[nIndex].lpszString))
            return E_FAIL;
    }

    lstrcpyn(_szMRU[nIndex].lpszString, szNewValue, _szMRU[nIndex].dwStringSize);
    _szMRU[nIndex].iImage = iImage;
    _szMRU[nIndex].iSelectedImage = iSelectedImage;


    return S_OK;
}


/****************************************************\
    FUNCTION: _Populate

    DESCRIPTION:
        fills in the entire combo.

    WARNING!!!!!!!!:
        This is expensive, don't do it unless absolutely
    necessary!
\****************************************************/
HRESULT CMRUList::_Populate(void)
{
    HRESULT hr = S_OK;
    CShellUrl *psu;

    if (!_fListLoaded)
        hr = _LoadList();  // Load Data

    if (_fDropDownPopulated)
        return S_OK;    // We are already populated.

    psu = new CShellUrl();

    if (psu)
    {
        // We need to set the "Shell Path" so that we can find
        // the correct icons for items in "desktop" and in
        // Desktop/My Computer".
        SetDefaultShellPath(psu);

        // Give it a parent for displaying message boxes
        psu->SetMessageBoxParent(_hwnd);
            
        // read values from registry and put them in combo box
        COMBOBOXEXITEM cbexItem = {0};
        cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;

        for (cbexItem.iItem = 0; cbexItem.iItem < MRU_LIST_MAX_CONST ; cbexItem.iItem++)
        {
            if (_szMRU[cbexItem.iItem].lpszString)
            {
                cbexItem.pszText = _szMRU[cbexItem.iItem].lpszString;
                cbexItem.cchTextMax = _szMRU[cbexItem.iItem].dwStringSize;

                //Do Image creation when we actually populate
                if(_szMRU[cbexItem.iItem].iImage == -1 ||   _szMRU[cbexItem.iItem].iSelectedImage == -1) {
                    _GetUrlUI(psu,_szMRU[cbexItem.iItem].lpszString, &(_szMRU[cbexItem.iItem].iImage),\
                                                               &(_szMRU[cbexItem.iItem].iSelectedImage));
                }

                // initialize the image indexes
                cbexItem.iImage = _szMRU[cbexItem.iItem].iImage;
                cbexItem.iSelectedImage = _szMRU[cbexItem.iItem].iSelectedImage;

                SendMessage(_hwnd, CBEM_INSERTITEM, (WPARAM)0, (LPARAM)(LPVOID)&cbexItem);
            }
            else
                break;  // Stop populating when we hit the max.
        }
        _fDropDownPopulated = TRUE;

        //Delete the shell url object
        delete psu;
    } else {
        // low mem
        hr = E_OUTOFMEMORY;
    }

    TraceMsg(TF_BAND|TF_GENERAL, "CMRUList: _Populate(). This is a VERY EXPENSIVE operation.");
    return hr;
}


/****************************************************\
    FUNCTION: _PopulateOneItem

    DESCRIPTION:
        This just files the ComboBox's edit control.
    We do this when we want to postpone populating
    the entire drop down list.
\****************************************************/
HRESULT CMRUList::_PopulateOneItem(void)
{
    HRESULT hr = S_OK;

    if (!_fListLoaded)
        hr = _LoadList();  // Load Data

    if (_fDropDownPopulated)
        return S_OK;    // We are already populated.

    hr = _SetTopItem();
    return hr;
}


/****************************************************\
    FUNCTION: Refresh

    DESCRIPTION:
        Update the URL in the Top of the list.
\****************************************************/
HRESULT CMRUList::Refresh(DWORD dwType)
{
    HRESULT hr = S_OK;

    if (OLECMD_REFRESH_ENTIRELIST == dwType)
    {
        // Force a refresh.  We don't move the contents
        // of the of the Combobox to the MRU because the
        // user wanted to refresh the Combobox because
        // it's contents may be tainted.
        SendMessage(_hwnd, CB_RESETCONTENT, 0, 0L);
        _fDropDownPopulated = FALSE;
    }

    return hr;
}


//================================
// *** Internal/Private Methods ***


/*******************************************************************
    FUNCTION: _MoveAddressToTopOfMRU

    PARAMETERS:
        nMRUIndex - index of be moved to top.

    DESCRIPTION:
        This function will move the specified index to the top of
    the list.
********************************************************************/
BOOL CMRUList::_MoveAddressToTopOfMRU(int nMRUIndex)
{
    int nCurrent;
    SIZESTRCOMBO sscNewTopItem;
    _fNeedToSave = TRUE;

    ASSERT(nMRUIndex < MRU_LIST_MAX_CONST);

    // Save off new top item info.
    sscNewTopItem.dwStringSize = _szMRU[nMRUIndex].dwStringSize;
    sscNewTopItem.lpszString = _szMRU[nMRUIndex].lpszString;
    sscNewTopItem.iImage  = _szMRU[nMRUIndex].iImage;
    sscNewTopItem.iSelectedImage = _szMRU[nMRUIndex].iSelectedImage;

    for (nCurrent = nMRUIndex; nCurrent > 0; nCurrent--)
    {
        // Move item down in list.
        _szMRU[nCurrent].dwStringSize = _szMRU[nCurrent-1].dwStringSize;
        _szMRU[nCurrent].lpszString = _szMRU[nCurrent-1].lpszString;
        _szMRU[nCurrent].iImage = _szMRU[nCurrent-1].iImage;
        _szMRU[nCurrent].iSelectedImage = _szMRU[nCurrent-1].iSelectedImage;
    }

    // Set new top item.
    _szMRU[0].dwStringSize    = sscNewTopItem.dwStringSize;
    _szMRU[0].lpszString      = sscNewTopItem.lpszString;
    _szMRU[0].iImage          = sscNewTopItem.iImage;
    _szMRU[0].iSelectedImage  = sscNewTopItem.iSelectedImage;

    return TRUE;
}


/*******************************************************************
    FUNCTION: _FindInMRU

    PARAMETERS:
        szURL - URL to see if it exists in list.

    DESCRIPTION:
        Search through MRU for URL.  Return value will be -1 if not
    found or index if found.
********************************************************************/
int CMRUList::_FindInMRU(LPCTSTR szURL)
{
    int nCurrent;

    for (nCurrent = 0; (nCurrent < MRU_LIST_MAX_CONST) && _szMRU[nCurrent].lpszString; nCurrent++)
    {
        if (0 == StrCmpN(_szMRU[nCurrent].lpszString, szURL, _szMRU[nCurrent].dwStringSize))
        {
            // We found it.
            return nCurrent;
        }
    }

    return -1;
}



HRESULT CMRUList::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    switch(uMsg) {
    case WM_WININICHANGE:
    {
        HKEY hkey = _GetRegKey(FALSE);
        if (hkey) {
            RegCloseKey(hkey);
        } else {

            // reset if the key is gone
            if (_fVisible) {
                SendMessage(_hwnd, CB_RESETCONTENT, 0, 0L);
            }
            _fDropDownPopulated = FALSE;
            _fListLoaded = FALSE;
        }
    }
        break;
    }

    return SUPERCLASS::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\mediaband.h ===
// mediabar.h : Declaration of the CMediaBand

#ifndef __MEDIABAND_H_
#define __MEDIABAND_H_

#include "dpa.h"
#include "bands.h"
#include "player.h"
#include "mediautil.h"
#include "mbutil.h"
#include "mbBehave.h"
#include "iface.h"

#define ERROREXIT(hr) if(FAILED(hr)){hr = E_FAIL; goto done;}

enum
{
    MW_PLAY = 0,
    MW_STOP,
    MW_BACK,
    MW_NEXT,
    MW_MUTE,
    MW_VOLUME,
    MW_OPTIONS,
    MW_POP,
    MW_SEEK,
    MW_NUMBER 
};


#define WM_MB_DEFERRED_NAVIGATE   (WM_USER + 700)     // lParam: hwnd of window sending this message (used for reflection)


class CMediaBand : public CToolBand, 
                   public IMediaBar,
                   public IWinEventHandler,
                   public INamespaceWalkCB,
                   public IElementBehaviorFactory,
                   public IBrowserBand,
                   public IBandNavigate,
                   public IMediaHost,
                   public IDispatchImpl<DWebBrowserEvents2, &DIID_DWebBrowserEvents2, &LIBID_SHDocVw>,
                   public CMediaBarUtil
{
public:
    CMediaBand();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef();  };
    STDMETHODIMP_(ULONG) Release(void) { return CToolBand::Release(); };
    
    // IOleCommandTarget
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD       nCmdID,
                              DWORD       nCmdexecopt,
                              VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);

    // IOleWindow
    //  (overriding CNSCBand implementation
    STDMETHODIMP GetWindow(HWND *phwnd);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, VOID ** ppvObj);

    // IInputObject
    //  (overriding CNSCBand/CToolBand's implementation)
    STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    STDMETHODIMP HasFocusIO();

    // IDockingWindow
    STDMETHODIMP ShowDW(BOOL fShow);
    STDMETHODIMP CloseDW(DWORD dwReserved);
    
    // IElementBehaviorFactory
    STDMETHODIMP FindBehavior(BSTR bstrBehavior, BSTR bstrBehaviorUrl, IElementBehaviorSite* pSite, IElementBehavior** ppBehavior);
    
    // IBrowserBand
    STDMETHOD(GetObjectBB)(THIS_ REFIID riid, LPVOID *ppv);
    STDMETHODIMP SetBrowserBandInfo(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP GetBrowserBandInfo(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi) { ASSERT(FALSE); return E_NOTIMPL; }

    // IBandNavigate
    STDMETHOD(Select)(LPCITEMIDLIST pidl);

    // IMediaHost
    STDMETHOD(getMediaPlayer)(IUnknown **ppPlayer);
    STDMETHOD(playURL)(BSTR bstrURL, BSTR bstrMIME);
    STDMETHOD(addProxy)(IUnknown *pProxy);
    STDMETHOD(removeProxy)(IUnknown *pProxy);
    // IMediaHost2
    STDMETHOD(OnDisableUIChanged)(BOOL fDisabled);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown* punkSite);

    // IWinEventHandler
    STDMETHODIMP OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
    STDMETHODIMP IsWindowOwner(HWND hwnd);

    // IMediaBar
    STDMETHOD(Notify)(long lReason);
    STDMETHOD(OnMediaError)(int iErrCode);
  
    // IDeskBand
    STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // IPersistStream
    STDMETHODIMP GetClassID(CLSID *pClassID);
    STDMETHODIMP Load(IStream *pStm);
    STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // IDispatch
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

    // INamespaceWalkCB
    STDMETHODIMP FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl) { return S_OK; }
    STDMETHODIMP LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl) { return S_OK; }
    STDMETHODIMP InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel);

private:
    ~CMediaBand();

    LRESULT _OnVolumeCustomDraw(LPNMCUSTOMDRAW pnm);
    LRESULT _OnSeekBarCustomDraw(LPNMCUSTOMDRAW pnm);
    
    BOOL  EnsurePlayer();
    BOOL  CreatePlayer();
    VOID  DestroyPlayer();

    STDMETHOD(_TogglePause)();
    STDMETHOD(_PutUrl)(LPWSTR pstrUrl, LPWSTR pstrMime);

    STDMETHOD(_EnumPlayItems)(VOID);

    HRESULT  CreateControls();
    HRESULT  CreateSeekBar();
    HRESULT  CreateVolumeControl();
    HRESULT  CreateParentPane();
    HRESULT  CreateLayoutPane();

    HRESULT  _NavigateMainWindow(LPCTSTR lpstrUrl, bool fSuppressFirstAutoPlay = false);

    HRESULT   InitPlayerPopup();
    HWND      GetBrowserWindow();

    VOID     _ResizeChildWindows(HWND hwnd, LONG width, LONG height, BOOL fRepaint);
    HRESULT  _InitializeMediaUI();
    VOID     _ResizeVideo(LONG* lWidth, LONG* lHeight);

    VOID      AdjustLayout(LONG_PTR lWidth=0,LONG_PTR lHeight=0);
    VOID      DrawBackground(HDC hdc, HWND hwnd);

    LPTSTR GetUrlForStatusBarToolTip();
    
    HRESULT  _OpenInDefaultPlayer(BSTR bstrUrl);
    VOID     _ShowAllWindows(BOOL fShow);
    HRESULT  ShowPlayListMenu(HWND hwnd,RECTL* rc);
    HRESULT  ShowGenericMenu(HWND hwnd, RECTL* rc);
    HRESULT  HandleMenuTasks(INT iTask);
    VOID     ComputeMinMax(MINMAXINFO *pMinMax);
    
    VOID     DockMediaPlayer();

    static LRESULT  CALLBACK  s_PopupWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT  CALLBACK  s_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT  CALLBACK  s_LayoutWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT  CALLBACK  s_SeekWndSubClassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT  CALLBACK  s_VolumeWndSubClassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR  CALLBACK  s_PromptMimeDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT GetTrackTitle (BSTR* pbstrTitle);
    VOID GetToolbarSize(HWND hwndTB, SIZE* pSize);

    float GetSeekPos() ;
    VOID  SetSeekPos(float fPosition) ;
    HRESULT Seek(double dblProgress);

    VOID  SetStatusText(LPWSTR lpwStatusInfo);
    VOID  ShowPlayingStatus(BOOL fInitial=FALSE);

    VOID AdjustVideoHeight(BOOL fForceResize=FALSE);
    VOID TogglePlayPause();
    VOID ToggleMute();

    LONG GetLayoutHeight(LONG lWidth=0);
    LONG GetVideoHeight(LONG lWidth=0, BOOL fNewVideo=FALSE);
    LONG GetControlsHeight();

    // Menu helpers
    HRESULT AddToFavorites(BSTR bstrUrl, BSTR bstrTitle);
    HRESULT ResetMimePreferences();
    BOOL    PromptSettings(UINT IDPROMPT);
    
    // Handler for property change notifications
    VOID _OnTitleChange();

    // Navigation timeout helpers
    VOID _OnNavigationTimeOut();
    VOID _UpdateTimeOutCounter(double dblCurrBufProgress, double dblCurrPlayProgress);
    VOID _EndTimeOutCounter();
    VOID _BeginTimeOutCounter(BOOL fClear = TRUE);

    // per mime type checking stuff
    VOID    _HandleAutoPlay(VARIANTARG *pvarargMime, VARIANTARG *pvarargUrl);

    STDMETHODIMP ProfferService(IUnknown         *punkSite, 
                                REFGUID           sidWhat, 
                                IServiceProvider *pService, 
                                DWORD            *pdwCookie);

public:
    // mediabar behavior
    // non-COM public calls

private:
    HRESULT     _AddProxyToList(IUnknown *punkProxy);
    void        _AttachPlayerToProxies(BOOL fAttach);
    void        _DetachProxies();
    BOOL        _isUIDisabled();
    BOOL		_isProxiesNextEnabled();
    void        _OnUserOverrideDisableUI();
    void        _FireEventToProxies(enum contentProxyEvent event);
    void        _CleanupStopTimer();
    BOOL        _IsProxyRunning(void) { return (_apContentProxies && (_apContentProxies.GetPtrCount() > 0)); }
    HRESULT     _EnsureWMPInstalled(BOOL fShowErrorMsg = TRUE);

    BOOL        _fAttached;
    UINT_PTR    _idStopTimer;


private:                                
    double     _dblMediaDur;  // natural length of the media
    int        _iCurTrack;
    PTSTR     _pszStatus;
    HWND     _hwndVolume;
    HWND     _hwndSeek;
    HWND     _hwndPopup;
    HWND     _hwndVideo ;
    HWND     _hwndLayout;
    
    HMENU    _hPlayListMenu;
        
    IMediaBarPlayer    *_pMediaPlayer;

    DWORD               _dwCookieServiceMediaBar;

    // navigation timeout
    DWORD   _dwStartTime;
    LONG    _lTickCount;
    double  _dblLastBufProgress;
    double  _dblLastPlayProgress;

    SIZE           _sizeLayout;
    SIZE           _sizeVideo ;
    BOOL          _fPlayButton:1 ;
    BOOL          _fSeeking:1;    // We are seeking, so don't update the seekbar position while we seek.
    BOOL          _fIsVideo:1;
    BOOL          _fMuted:1;
    BOOL          _fVideoAdjust:1;
    BOOL          _fPlaying:1;
    BOOL          _fPlayEnabled:1;
    BOOL          _fInitialized:1;
    BOOL          _fHiColour:1;
    BOOL          _fUserPaused:1;
    BOOL          _fHighDPI:1;
    float         _scaleX, _scaleY;
    CMediaWidget*   _pmw[MW_NUMBER];
    HIMAGELIST  _himlGripper;
    HBITMAP     _hbmpBackground;
    HIMAGELIST _himlVolumeBack, _himlVolumeFill;
    HIMAGELIST _himlSeekBack, _himlSeekFill;
    HBRUSH _hbrSeekBrush;
    
    VOID        Resize(HWND hwnd, LONG lWidth, LONG lHeight);
    LONG        GetPopoutHeight(BOOL fVideo=FALSE, LONG lWidth=0);
    LONG        GetMinPopoutWidth();
    BOOL        ResetPlayer();
    HRESULT     PlayLocalTrack(INT iTrackNum);
    HRESULT     PlayNextTrack();
    BOOL        SetPlayerControl(UINT ui, BOOL fState);
    BOOL        UpdateBackForwardControls();
    VOID        UpdateMenuItems(HMENU hmenu);
    LPTSTR      _szToolTipUrl;
    BOOL        OnNotify(LPNMHDR pnm, LRESULT* plres);
    VOID        SetPlayPause(BOOL fState);
    VOID        SwitchBitmaps(BOOL fNewSetting);

    HRESULT _GetMusicFromFolder();
    void _ClearFolderItems();


    LPITEMIDLIST *_ppidls;
    UINT _cidls;

    INT         _iElement;
    double      _dblVol;
    TCHAR      _szConnecting[MAX_PATH];
    INT         _iOptionsWidth;
    CComBSTR    _strLastUrl;
    CComBSTR    _strLastMime;
    BOOL        _fLastUrlIsAutoPlay;

    // Content pane
    HWND        _hwndContent;
    DWORD       _dwcpCookie;
    CComPtr<IWebBrowser2> _spBrowser;
    CComBSTR    _strDeferredURL;
    CComBSTR    _strCurrentContentUrl;
    CComPtr<IOleInPlaceActiveObject>  _poipao;
    BOOL        _fContentInFocus;

    VOID        InitContentPane();
    HRESULT     NavigateContentPane(BSTR bstrUrl);
    HRESULT     NavigateContentPane(LPCITEMIDLIST pidl);
    VOID        NavigateMoreMedia();
    HRESULT     _NavigateContentToDefaultURL(void);
    HRESULT     _ConnectToCP(BOOL fConnect);
    HRESULT     _BuildPageURLWithParam(LPCTSTR pszURL, LPCTSTR pszParam, OUT LPTSTR pszBuffer, UINT uiBufSize);
    BOOL        _DeferredNavigate(LPCTSTR pszURL);
    HRESULT     _ContentActivateIO(BOOL fActivate, PMSG pMsg);
    LRESULT     _OnNotify(LPNMHDR pnm);

    BOOL _fSavedPopoutState;
    WINDOWPLACEMENT _wpPopout;
    BOOL _fPopoutHasFocus;
    void ActivatePopout(BOOL fState);

    HKEY _hkeyWMP;
    BOOL _fShow;

    // mediaBehavior
    CDPA<IContentProxy>    _apContentProxies;
};



#define _pmwPlay    ((CMediaWidgetButton*)_pmw[MW_PLAY])
#define _pmwStop    ((CMediaWidgetButton*)_pmw[MW_STOP])
#define _pmwBack    ((CMediaWidgetButton*)_pmw[MW_BACK])
#define _pmwNext    ((CMediaWidgetButton*)_pmw[MW_NEXT])
#define _pmwMute    ((CMediaWidgetToggle*)_pmw[MW_MUTE])
#define _pmwVolume  ((CMediaWidgetVolume*)_pmw[MW_VOLUME])
#define _pmwOptions     ((CMediaWidgetOptions*)_pmw[MW_OPTIONS])
#define _pmwPop     ((CMediaWidgetButton*)_pmw[MW_POP])
#define _pmwSeek    ((CMediaWidgetSeek*)_pmw[MW_SEEK])

#define ISVALIDWIDGET(x)    (x && x->_hwnd)
#endif // __MEDIABAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\multimon.cpp ===
#include "priv.h"
//=============================================================================
//
// This function defines the MULTIMON stub module that fakes multiple monitor 
// apis on pre Memphis Win32 OSes
// this is the only file that defines COMPILE_MULTIMON_STUBS 
//=============================================================================

#define COMPILE_MULTIMON_STUBS
#include "multimon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\onetree.h ===
#ifndef _onetree_h
#define _onetree_h

#ifdef __cplusplus
extern "C" {
#endif

#define OTGetRootFolder()                 (s_pshfRoot->AddRef(), s_pshfRoot)
#define OTGetRootParentFolder()           (s_pshfRootParent->AddRef(), s_pshfRootParent)


#define OTIsShared(lpnd)                    ((lpnd)->dwAttribs & SFGAO_SHARE)
#define OTIsRemovableRoot(lpnd)             (((lpnd)->dwAttribs & (SFGAO_REMOVABLE | SFGAO_FILESYSANCESTOR)) == (SFGAO_REMOVABLE | SFGAO_FILESYSANCESTOR))
#define OTGetSubNode(lpn, szSubFolderID)    FindKid(lpn, szSubFolderID, TRUE)
#define OTGetRootNode()                     (OTAddRef(s_lpnRoot), s_lpnRoot)
#define OTInvalidateAll()                   DoInvalidateAll(s_lpnRoot, -1)
#define OTAddRef(lpnd)                      ((lpnd)->cRef++)

typedef struct _OTCompareInfo
{
    BOOL bFound;
    BOOL fRooted;
    LPSHELLFOLDER psf;
} OTCompareInfo, *LPOTCompareInfo;

typedef struct _OTEnumInfo
{
    BOOL fTimedOut : 1;
    BOOL fAllowTimeout :1;
} OTEnumInfo, *LPEnumInfo;

typedef struct _OneTreeNode
{

#ifdef DEBUG
#define OTDEBUG_SIG ((TEXT('O') << 16) + (TEXT('T') << 8) + TEXT('N'))
    DWORD       dwDebugSig;
#endif

    struct _OneTreeNode * lpnParent;

    HDPA        hdpaKids;               // HASNOKIDS || KIDSUNKNOWN || array of kids

    LPTSTR      lpText;                 // The text for this item
    int         iImage;           
    int         iSelectedImage;

    BITBOOL     fMark          : 1;
    BITBOOL     fRoot          : 1;
    BITBOOL     fInvalid       : 1;
    BITBOOL     fShared        : 1;
    BITBOOL     fRemovable     : 1;
    BITBOOL     fInserted      : 1; // this means that this item was forceably added..  it's not safe to remove it if it doesn't show up in enumeration
    BITBOOL     fHasAttributes : 1;
    BITBOOL     fValidatePidl   :1; // this means the item was invalidated specifically by fsnotify (as opposed to not fully fetched yet)
                                    // so on the next call to GetAttributesOf, we need to pass SFGAO_VALIDATE
    BYTE        cChildren;
    DWORD       dwAttribs;
    DWORD       dwDropEffect;
    DWORD       dwLastChanged;
    int         cRef;
    LPITEMIDLIST  pidl;                // this needs to be at the end because it grows
} OneTreeNode, * LPOneTreeNode;

typedef struct _NMOTFSEINFO {
    NMHDR nmhdr;
    LONG lEvent;
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlExtra;
} NMOTFSEINFO, *LPNMOTFSEINFO;

#define OTN_FSE         CWM_ONETREEFSE
// from shelldll
#define IDOI_SHARE    1

#define NOKIDS          ((HDPA)-1)
#define KIDSUNKNOWN     ((HDPA)0)

extern LPOneTreeNode s_lpnRoot;
extern LPSHELLFOLDER s_pshfRoot;

extern LPSHELLFOLDER   s_pshfRoot;
extern LPSHELLFOLDER   s_pshfRootParent;

#ifdef FOR_GEORGEST
void DebugDumpNode(LPOneTreeNode lpn, LPTSTR lpsz);
#else
#define DebugDumpNode(lpn, lpsz)
#endif

BOOL OneTree_Initialize(LPCITEMIDLIST pidlRootClass);
void OneTree_Terminate();
void OneTree_GetAltColor(void);

#define OTILIsEqual(pidl1, pidl2)   IEILIsEqual((pidl1), (pidl2), FALSE)
BOOL WINAPI OTILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate);
BOOL OTIsCompressed(LPOneTreeNode lpNode);
BOOL OTIsBold(LPOneTreeNode lpNode);

STDAPI_(void) OTAssumeThread();

// any calls to this MUST BE IN A CRIT section!

LPITEMIDLIST OTCloneFolderID(LPOneTreeNode lpn);
LPTSTR OTGetNodeName(LPOneTreeNode lpn, LPTSTR pszText, int cch);
HRESULT WINAPI OTRealBindToFolder(LPOneTreeNode lpNode, LPSHELLFOLDER *ppshf);
LPSHELLFOLDER WINAPI OTBindToFolder(LPOneTreeNode lpnd);
HRESULT OTBindToParentFolder(LPOneTreeNode lpNode, IShellFolder **ppsf, LPITEMIDLIST *ppidlChild);
HRESULT WINAPI OTBindToParent(LPOneTreeNode lpnd, LPSHELLFOLDER *ppshf);
HRESULT WINAPI OTBindToFolderEx(LPOneTreeNode lpnd, LPSHELLFOLDER *ppshf);
HRESULT WINAPI OTRealBindToFolder(LPOneTreeNode lpNode, LPSHELLFOLDER *ppshf);
LPOneTreeNode WINAPI OTGetNthSubNode(HWND hwndOwner, LPOneTreeNode lpnd, UINT i);
void WINAPI OTInvalidateAttributeRecursive(LPOneTreeNode lpn);
BOOL WINAPI OTSubNodeCount(HWND hwndOwner, LPOneTreeNode lpNode, LPEnumInfo pei, UINT* pcnd, BOOL fInteractive);
BOOL WINAPI OTHasSubFolders(LPOneTreeNode lpnd);
void WINAPI OTNodeFillTV_ITEM(LPOneTreeNode lpnd, LPTV_ITEM lpItem);
void WINAPI OTUnregister(HWND hwndTree);
void WINAPI OTRegister(HWND hwndTree);
void WINAPI OTGetImageIndex(LPOneTreeNode lpnd, int *lpiImage, int * lpiSelectedImage);
void WINAPI OTGetDefaultImageIndices(int *lpiImage, int *lpiSelectedImage);
void WINAPI OTRelease(LPOneTreeNode lpNode);
void DoInvalidateAll(LPOneTreeNode lpNode, int iImage);
LPOneTreeNode WINAPI OTGetParent(LPOneTreeNode lpnd);
void OTActivate();

#define OTASF_ALLOWDUP          0x00000001
#define OTASF_MAYBESIMPLE       0x00000002
HRESULT WINAPI OTAddSubFolder(LPOneTreeNode lpnd, LPCITEMIDLIST pidl, DWORD dwFlags, LPOneTreeNode *ppndOut);

LPITEMIDLIST WINAPI OTCreateIDListFromNode(LPOneTreeNode lpnd);
BOOL WINAPI OTGetDisplayName(LPCITEMIDLIST pidl, LPTSTR pszName, int fType);

int CALLBACK OTTreeViewCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

LPOneTreeNode WINAPI OTGetNodeFromIDListEx(LPCITEMIDLIST pidl, UINT uFlags, HRESULT* phresOut);
#define OTGetNodeFromIDList(pidl, uFlags) OTGetNodeFromIDListEx(pidl, uFlags, (HRESULT*)NULL)

// onetree get node flags
#define OTGNF_VALIDATE   0x01
#define OTGNF_TRYADD     0x02
#define OTGNF_NEARESTMATCH 0x04

#ifdef __cplusplus
}
#endif


#endif // _onetree_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\nt5.cpp ===
#include "priv.h"
#include "shbrows2.h"
#include "commonsb.h"
#include "resource.h"

//
//
//  If you want NT5 defines in the above headerfiles, you gotta set _WIN32_WINNT
//  to 0x0500, which the standard browseui build does not do...
//
//  So we do it here in nt5.cpp.
//
//


// WM_APPCOMMAND handling
//
typedef struct tagAppCmd
{
    UINT idAppCmd;
    UINT idCmd;
} APPCMD;

BOOL CShellBrowser2::_OnAppCommand(WPARAM wParam, LPARAM lParam)
{
    static APPCMD rgcmd[] =
    {
        { APPCOMMAND_BROWSER_BACKWARD, FCIDM_NAVIGATEBACK },
        { APPCOMMAND_BROWSER_FORWARD, FCIDM_NAVIGATEFORWARD },
        { APPCOMMAND_BROWSER_REFRESH, FCIDM_REFRESH },
        { APPCOMMAND_BROWSER_STOP, FCIDM_STOP },
        { APPCOMMAND_BROWSER_SEARCH, FCIDM_VBBSEARCHBAND }, // FCIDM_SEARCHPAGE ?
        { APPCOMMAND_BROWSER_FAVORITES, FCIDM_VBBFAVORITESBAND },
        { APPCOMMAND_BROWSER_HOME, FCIDM_STARTPAGE },
        { APPCOMMAND_LAUNCH_MAIL, FCIDM_MAIL }
    };

    UINT idAppCmd = GET_APPCOMMAND_LPARAM(lParam);
    BOOL bRet = FALSE;

    for (int i = 0 ; i < ARRAYSIZE(rgcmd) ; i++)
    {
        if (rgcmd[i].idAppCmd == idAppCmd)
        {
            OnCommand(GET_WM_COMMAND_MPS(rgcmd[i].idCmd,
                                         GET_WM_COMMAND_HWND(wParam, lParam),
                                         GET_WM_COMMAND_CMD(wParam, lParam)));
            bRet = TRUE;
            break;
        }
    }
    return bRet;
}

// Our NT5 version of the WndProc
//
LPARAM CShellBrowser2::_WndProcBSNT5(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPARAM lRet = 0;
    switch(uMsg)
    {
       case WM_APPCOMMAND:
       {
          if (_OnAppCommand(wParam, lParam))
             lRet = 1;
          break;
       }
       default:
          break;
    }

    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\mediaband.cpp ===
#include "priv.h"
#include "sccls.h"
#include "resource.h"
#include "dhuihand.h"
#include <varutil.h>
#include "mstimeid.h"
#include <mluisupp.h>
#include "mediahlpr.h"
#include "mediaband.h"
#include "apithk.h"
#include "mbBehave.h"

#define SUPERCLASS  CToolBand

#define MIN_WINDOW_WIDTH     145  
#define MIN_WINDOW_HEIGHT    60
#define MIN_POPOUT_HEIGHT    300
#define MIN_POPOUT_WIDTH     300  
#define MIN_VOLUME_WIDTH     50
#define MIN_VOLUME_HEIGHT    16
#define MIN_HORZ_SPACING     10
#define SEEK_PART_WIDTH     18
#define SEEK_PART_HEIGHT    5
#define SEEK_HEIGHT          16
#define VOLUME_GRIPPER_LENGTH   6
#define COLOR_BKGND16        RGB(192, 192, 192)
#define COLOR_BKGNDMIDDLE   RGB(99, 129, 193)
#define VOLUME_BITMAP_WIDTH 42

#define VIDEO_MIN_HEIGHT    60
#define VIEW_MARGIN_BOTTOM  7
#define VIEW_MARGIN_LEFT     6
#define VIEW_MARGIN_INFO_LEFT     5
#define VIEW_MARGIN_RIGHT    10
#define VIEW_MARGIN_TOP     5
#define VIEW_MARGIN_TOP_VIDEO   6
#define VIEW_MARGIN_BOTTOM  7
#define VIEW_CONTROLS_HEIGHT    33
#define VIEW_CONTROLS_MARGIN    2

#define SCALEX(x)   (_fHighDPI ? ((INT)(((float)(x))*_scaleX)) : (x))
#define SCALEY(x)   (_fHighDPI ? ((INT)(((float)(x))*_scaleY)) : (x))

#define WZ_SMIE_MEDIA_MIME      REG_MEDIA_STR TEXT("\\MimeTypes")
#define REG_VALUE_MRU_INTERNET  REG_MEDIA_STR TEXT("\\Internet")
#define REG_VALUE_PATH           TEXT("MusicPath")

// 
// ISSUE: dilipk: these are localizable strings and need to be moved eventually !!!
//
#define WZ_WINDOWSMEDIA           L"http://www.windowsmedia.com"
 
#define WZ_ASX_MIMETYPE             L"video/x-ms-asx"

static const TCHAR c_szMediaBandProp[] = TEXT("CMediaBand_This");
static const TCHAR c_szMediaBarClassName[]       = TEXT("MediaPane");
static const TCHAR c_szMediaBarPopupClassName[] = TEXT("MediaPopupPane");
static const TCHAR c_szMediaBarLayoutClassName[] = TEXT("MediaLayoutPane");

// ISSUE: these two should be deleted when reg utilities are completely moved to mediautil.cpp
static const UINT MAX_REG_VALUE_LENGTH =  50;

// This is the number of ticks (from MSTIME) to skip each time before polling System Time 
// for the navigation timeout counter
#define POLL_INTERVAL       30
// This is the number of milli-seconds after which navigation times out
#define TIMEOUT_INTERVAL    90000 

static const TCHAR c_szContentUrl[] = TEXT("http://go.microsoft.com/fwlink/?LinkId=511");
static const TCHAR c_szMoreMediaUrl[] = TEXT("http://go.microsoft.com/fwlink/?LinkId=512");
static const TCHAR c_szRadioUrl[] = TEXT("http://go.microsoft.com/fwlink/?LinkId=822");

static const TCHAR c_szOfflineURL[] = TEXT("mbOffline.htm");
static const TCHAR c_szLoadingURL[] = TEXT("mbLoading.htm");
static const TCHAR c_sz404URL[]     = TEXT("mb404.htm");


extern HBITMAP CreateMirroredBitmap( HBITMAP hbmOrig);

//
// ISSUE: this is a temporary guid for the content pane sync feature.
//
static const IID SID_SMediaBarSync = { 0x2efc8085, 0x066b, 0x4823, { 0x9d, 0xb4, 0xd1, 0xe7, 0x69, 0x16, 0xda, 0xa0 } };
static const GUID SID_STimeContent = { 0x1ae98e18, 0xc527, 0x4f78, {0xb2, 0xa2, 0x6a, 0x81, 0x7f, 0x9c, 0xd4, 0xf8}};

// ISSUE where could be #include this GUID from?????
static const GUID CLSID_JITWMP8 = { 0x6BF52A52, 0x394A, 0x11d3, 0xb1, 0x53, 0x00, 0xc0, 0x4f, 0x79, 0xfa, 0xa6 };



CMediaBand::CMediaBand() :
    _fPlayButton(TRUE),
    _fPlayEnabled(TRUE),
    _iCurTrack(-1),
    _lTickCount(-1),
    _iElement(-1),
    _dblVol(-1.0),
    _fHiColour(TRUE),
    _fUserPaused(FALSE),
    _iOptionsWidth(0),
    _hbmpBackground(NULL),
    _hwndContent(NULL),
    _dwcpCookie(0),
    _fContentInFocus(FALSE),
    _hkeyWMP(NULL),
    _fShow(FALSE),
    _fAttached(FALSE)
{
    _sizeLayout.cx = MIN_WINDOW_WIDTH;
    _sizeLayout.cy = MIN_WINDOW_HEIGHT;
    _sizeVideo.cx  = 0 ;
    _sizeVideo.cy  = 0 ;
    _fCanFocus = TRUE;
    _scaleX = _scaleY = 1.0;

    // HighDPI support requires nice comctl32 6.0 functionality.
    if (IsOS(OS_WHISTLERORGREATER))
    {
        HDC hdcScreen = GetDC(NULL);
        if (hdcScreen)
        {
            _scaleX = (GetDeviceCaps(hdcScreen, LOGPIXELSX) / 96.0f);
            _scaleY = (GetDeviceCaps(hdcScreen, LOGPIXELSY) / 96.0f);
            ReleaseDC(NULL, hdcScreen);
        }
    }
    _fHighDPI = (_scaleX!=1.0) || (_scaleY!=1.0);
}

CMediaBand::~CMediaBand()
{
    DestroyPlayer();

    if (_spBrowser)
    {
        _ConnectToCP(FALSE);
        _spBrowser.Release();
        _poipao.Release();
    }
    DESTROY_OBJ_WITH_HANDLE(_hwndContent, DestroyWindow);

    DESTROY_OBJ_WITH_HANDLE(_hwndPopup, DestroyWindow);
    DESTROY_OBJ_WITH_HANDLE(_hwndLayout, DestroyWindow);
    DESTROY_OBJ_WITH_HANDLE(_hPlayListMenu, DestroyMenu);
    DESTROY_OBJ_WITH_HANDLE(_himlSeekBack, ImageList_Destroy);
    DESTROY_OBJ_WITH_HANDLE(_himlSeekFill, ImageList_Destroy);
    DESTROY_OBJ_WITH_HANDLE(_himlGripper, ImageList_Destroy);
    DESTROY_OBJ_WITH_HANDLE(_himlVolumeBack, ImageList_Destroy);
    DESTROY_OBJ_WITH_HANDLE(_himlVolumeFill, ImageList_Destroy);
    DESTROY_OBJ_WITH_HANDLE(_hbmpBackground, DeleteObject);

    // need to check IsWindow because this window can also be destroyed by CMediaBarPlayer
    if (_hwndVideo && ::IsWindow(_hwndVideo))
        DestroyWindow(_hwndVideo);

    if (_szToolTipUrl)
    {
        delete [] _szToolTipUrl;
    }

    if (_pszStatus)
    {
        delete [] _pszStatus;
    }

    for (int i=0; i < ARRAYSIZE(_pmw); i++)
    {
        if (_pmw[i])
        {
            delete _pmw[i];
        }
    }

    if (_hkeyWMP)
        RegCloseKey(_hkeyWMP);
}
    


// helper to get up to service provider and to do register/unregister
// two forms:
//      pService != NULL, register, pdwCookie is [out] returns cookie
//      pService == NULL, unregister, *pdwCookie is [in] de-registers the service

STDMETHODIMP CMediaBand::ProfferService(IUnknown *punkSite, REFGUID sidWhat, 
                                        IServiceProvider *pService, DWORD *pdwCookie)
{
    IProfferService *pps;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SProfferService, IID_PPV_ARG(IProfferService, &pps));
    if (SUCCEEDED(hr))
    {
        if (pService)
            hr = pps->ProfferService(sidWhat, pService, pdwCookie);
        else
        {
            hr = pps->RevokeService(*pdwCookie);
            *pdwCookie = 0;
        }
        pps->Release();
    }
    return hr;
}


HRESULT CMediaBand::SetSite(IUnknown *punkSite)
{
    // Make sure we proffer the service only once
    // This is important since we get created multiple times,
    CComPtr<IUnknown> spUnk;

    // Check if we need to revoke our service, or if our service was already proffered by
    // another instance of CMediaBar
    if ((!punkSite && _dwCookieServiceMediaBar) || 
        (punkSite && FAILED(IUnknown_QueryService(punkSite, SID_SMediaBar, IID_PPV_ARG(IUnknown, &spUnk)))))
    {
        // Proffer or Revoke BrandBand service as appropriate
        ProfferService(punkSite ? punkSite : _punkSite, SID_SMediaBar, 
              punkSite ? SAFECAST(this, IServiceProvider *) : NULL, &_dwCookieServiceMediaBar);
        // Failure here does not require special handling
    }

    return SUPERCLASS::SetSite(punkSite);
}

HRESULT CMediaBand::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CMediaBand, IMediaBar),
        QITABENT(CMediaBand, IWinEventHandler),
        QITABENT(CMediaBand, IObjectWithSite),
        QITABENT(CMediaBand, INamespaceWalkCB),
        QITABENTMULTI(CMediaBand, IDispatch, DWebBrowserEvents2),
        QITABENTMULTI2(CMediaBand, DIID_DWebBrowserEvents2, DWebBrowserEvents2),
        QITABENT(CMediaBand, IElementBehaviorFactory),
        QITABENT(CMediaBand, IBrowserBand),
        QITABENT(CMediaBand, IBandNavigate),
        QITABENT(CMediaBand, IMediaHost),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr))
    {
        hr = SUPERCLASS::QueryInterface(riid, ppv);
    }
    return hr;
}

// *** IWinEventHandler ***
HRESULT CMediaBand::IsWindowOwner(HWND hwnd)
{
    for (int i=0; i < ARRAYSIZE(_pmw); i++)
    {
        if (_pmw[i] && (hwnd==_pmw[i]->_hwnd))
        {
            return S_OK;
        }
    }

    return S_FALSE;
}

// *** IWinEventHandler ***
HRESULT CMediaBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    CMediaBand* pmb = reinterpret_cast<CMediaBand *>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    
    switch (uMsg)
    {
        case WM_COMMAND:
        {
            HWND hwndControl = GET_WM_COMMAND_HWND(wParam, lParam);
            UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
            
            if (HIWORD(wParam) == BN_CLICKED && hwndControl)
            {
                RECT       rc;
                VARIANTARG var;

                var.vt = VT_I4;
                GetWindowRect(hwndControl, &rc);
                MapWindowPoints(hwndControl, HWND_DESKTOP, (LPPOINT)&rc, 2);
                var.lVal = MAKELONG(rc.left, rc.bottom);
                return Exec(&CLSID_MediaBand, idCmd, 0, &var, NULL);
            }            
        }
        break;
    }
    return S_FALSE;
}


void CMediaBand::_ClearFolderItems()
{
    if (_ppidls)
    {
        FreeIDListArray(_ppidls, _cidls);
        _ppidls = NULL;
    }
    _cidls = 0;
}

// INamespaceWalkCB methods
HRESULT CMediaBand::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    if (NULL == _hkeyWMP)
    {
        RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Applications\\mplayer2.exe\\SupportedTypes"), &_hkeyWMP);
    }

    HRESULT hr = S_FALSE;   // default to no
    if (_hkeyWMP)
    {
        TCHAR szName[MAX_PATH];
        if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szName, ARRAYSIZE(szName))))
        {
            if (ERROR_SUCCESS == RegQueryValueEx(_hkeyWMP, PathFindExtension(szName), NULL, NULL, NULL, NULL))
            {
                hr = S_OK;
            }
        }
    }
    return hr;
}

STDMETHODIMP CMediaBand::InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel) 
{
    TCHAR szText[200];
    MLLoadString(IDS_MEDIABANDSEARCH, szText, ARRAYSIZE(szText));

    SHStrDup(szText, ppszTitle); 
    *ppszCancel = NULL; 
    return S_OK; 
}

HRESULT CMediaBand::_GetMusicFromFolder()
{
    _ClearFolderItems();

    INamespaceWalk *pnsw;
    HRESULT hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
    if (SUCCEEDED(hr))
    {
        hr = pnsw->Walk(_punkSite, NSWF_ONE_IMPLIES_ALL | NSWF_NONE_IMPLIES_ALL | NSWF_SHOW_PROGRESS, 10, this);
        if (SUCCEEDED(hr))
        {
            hr = pnsw->GetIDArrayResult(&_cidls, &_ppidls);
        }
        pnsw->Release();
    }
    return hr;
}

// *** IOleCommandTarget methods ***
HRESULT CMediaBand::Exec(const GUID *pguidCmdGroup, 
                         DWORD       nCmdID,
                         DWORD       nCmdexecopt, 
                         VARIANTARG *pvarargIn, 
                         VARIANTARG *pvarargOut)
{
    HRESULT hr = S_OK;
    if (pguidCmdGroup)
    {
        if (IsEqualGUID(CLSID_MediaBand, *pguidCmdGroup))
        {
            switch (nCmdID)
            {
            case FCIDM_MEDIABAND_POPOUT:
                {
                    DockMediaPlayer();
                }
                break;
                
            case FCIDM_MEDIABAND_PLAY:
                if (!_pMediaPlayer || _pMediaPlayer->isStopped())
                {
                    _CleanupStopTimer();
                    hr = _GetMusicFromFolder();
                    if (S_OK == hr)
                    {
                        _strLastUrl.Empty();    // would be nicer to replay same local file if navigated away....
                        PlayLocalTrack(0);
                    }
                    else if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
                    {
                        // if we already played a media in this session, replay it
                        if (_strLastUrl.Length() > 0)
                        {
                            if (_fLastUrlIsAutoPlay)
                            {
                                // repeat playing last auto-play
                                CComVariant vtURL = _strLastUrl;
                                CComVariant vtMime = _strLastMime;
                                Exec(&CGID_MediaBar, MBID_PLAY, 0, &vtMime, &vtURL);
                            }
                            else
                            {
                                // replay media thru content pane and media bar behavior
                                NavigateContentPane(_strLastUrl);
                            }
                        }
                        else
                        {
                            NavigateMoreMedia();
                        }
                    }
                }
                else
                {
                    _TogglePause();
                    TogglePlayPause();
                }
                break;
                
            case FCIDM_MEDIABAND_PREVIOUS:
                if (EnsurePlayer())
                {
                    LONG_PTR lCurTrack  = _pMediaPlayer->GetPlayListItemIndex();
                    LONG_PTR lItemCount = _pMediaPlayer->GetPlayListItemCount();

                    if (lCurTrack > 0)
                    {
                        _pMediaPlayer->Prev();
                    }
                    else if (_iCurTrack >= 0)
                    {
                        int i = _iCurTrack;
                        _iCurTrack = -1;        // don't auto-step to next on finished event
                        _pMediaPlayer->Stop();  // generates MEDIA_TRACK_FINISHED
                        PlayLocalTrack((i - 1 >= 0) ? i - 1 : 0);
                    }
                    UpdateBackForwardControls();
                    TogglePlayPause();
                }
                break;
                
            case FCIDM_MEDIABAND_NEXT:
                if (EnsurePlayer())
                {
                    LONG_PTR lCurTrack  = _pMediaPlayer->GetPlayListItemIndex();
                    LONG_PTR lItemCount = _pMediaPlayer->GetPlayListItemCount();

                    if ((lCurTrack >= 0) && (lCurTrack < lItemCount - 1))
                    {
                        _pMediaPlayer->Next();
                    }
                    else if (_iCurTrack >= 0)
                    {
                        int i = _iCurTrack;
                        _iCurTrack = -1;        // don't auto-step to next on finished event
                        _pMediaPlayer->Stop();  // generates MEDIA_TRACK_FINISHED
                        PlayLocalTrack(i + 1);
                    }
                    UpdateBackForwardControls();
                    TogglePlayPause();
                }
                break;
                
            case FCIDM_MEDIABAND_STOP:
                // when player is attached thru mediaBar behavior to script in media content pane,
                // we want to give the user a chance to get rid of the script and return to the default media content
                // the first click simply stops the player, clicking again within N secs will also navigate
                // the content pane to the default URL
                if (_idStopTimer == 0)
                {
                    if (_IsProxyRunning())
                    {
                        _idStopTimer = SetTimer(_hwnd, 747, 10000, NULL);
                    }
                    ResetPlayer();
                    _OnUserOverrideDisableUI();
                }
                else
                {
                    // clicked again, navigate media content to default URL
                    _CleanupStopTimer();
                    _NavigateContentToDefaultURL();
                }
                break;
                
            case FCIDM_MEDIABAND_MUTE:
                ToggleMute();
                break;
            }
        }
        else if (IsEqualGUID(CGID_MediaBar, *pguidCmdGroup))
        {
            switch (nCmdID)
            {
            case MBID_PLAY:
                if (pvarargIn && pvarargOut)
                {
                    _CleanupStopTimer();
                    if (_IsProxyRunning())
                    {
                        // user clicked on a media link in the main content pane, unfreeze controls!
                        _OnUserOverrideDisableUI();
                        _DetachProxies();
                        _NavigateContentToDefaultURL();
                    }

                    if (V_VT(pvarargOut) == VT_BSTR)
                    {
                        _strLastUrl = V_BSTR(pvarargOut);
                    }
                    if (V_VT(pvarargIn) == VT_BSTR)
                    {
                        _strLastMime = V_BSTR(pvarargIn);
                    }
                    _fLastUrlIsAutoPlay = TRUE;

                    // ISSUE: fix this to use the right CmdId & CmdIdGroup, not just zero, to prevent collisions.
                    // this is an auto-play command
                    _HandleAutoPlay(pvarargIn, pvarargOut);
                    hr = S_OK;
                }
                break;

            case MBID_POPOUT:
                if (pvarargOut)
                {
                    V_VT(pvarargOut) = VT_BOOL;
                    V_BOOL(pvarargOut) = _hwndPopup && IsWindowVisible(_hwndPopup);
                    hr = S_OK;
                }
                break;

            default:
                ASSERT(FALSE);
                break;
            }
        }
        else
        {
            hr = SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
    }
    else
    {
        hr = SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    return hr;
}

void CMediaBand::_HandleAutoPlay(VARIANTARG *pvarargMime, VARIANTARG *pvarargUrl)
{
    // check the mime type argument
    if (    (!pvarargMime)
        ||  (VT_BSTR != V_VT(pvarargMime))
        ||  (!V_BSTR(pvarargMime))
        ||  (L'' == (*V_BSTR(pvarargMime))))
    {
        goto done;
    }

    // check the Url argument
    if (    (!pvarargUrl) 
        ||  ( VT_BSTR != V_VT(pvarargUrl))
        ||  (!V_BSTR(pvarargUrl)) 
        ||  (L'' == (*V_BSTR(pvarargUrl))))
    {
        goto done;
    }

    if (EnsurePlayer())
    {
        // reset this to -1 to indicate we are not playing a mymusic track
        _iCurTrack = -1;

#ifdef _USE_MEDIA_MRU
        // ISSUE: temp fix for radio protocol. If this is an ASX mimetype, we know it is radio
        if (!SHRestricted(REST_NORECENTDOCSHISTORY))
        {
            CMediaMRU mmru;
            mmru.Load(REG_VALUE_MRU_INTERNET);
            mmru.Add(V_BSTR(pvarargUrl));
        }
#endif // _USE_MEDIA_MRU

        if (0 == StrCmpNIW(V_BSTR(pvarargMime), WZ_ASX_MIMETYPE, wcslen(WZ_ASX_MIMETYPE)))
        {
            _PutUrl(V_BSTR(pvarargUrl), V_BSTR(pvarargMime));
        }
        else
        {
            _PutUrl(V_BSTR(pvarargUrl), NULL);
        }

        TogglePlayPause();
    
        // clear the url to indicate we are handling this url
        ::VariantClear(pvarargUrl);
    }
    else
    {
        ASSERT(FALSE);
    }
done:
    ;
}

VOID
CMediaBand::_BeginTimeOutCounter(BOOL fClear /* = TRUE */)
{
    _dwStartTime = GetPerfTime();
    _lTickCount = 0;
    if (TRUE == fClear)
    {
        _dblLastBufProgress = 0;
        _dblLastPlayProgress = 0;
    }
}

VOID
CMediaBand::_EndTimeOutCounter()
{
    _lTickCount = -1;
}

VOID
CMediaBand::_UpdateTimeOutCounter(double dblCurrBufProgress, double dblCurrPlayProgress)
{
    BOOL fTimeOut = FALSE;

    // bail if the counter has not been started
    if (_lTickCount < 0)
        return;

    // Order of checking is important here.

    // If play progress is increasing then restart the counter
    if (dblCurrPlayProgress > _dblLastPlayProgress)
    {
        _BeginTimeOutCounter(FALSE);
        _dblLastPlayProgress = dblCurrPlayProgress;
    }
    // if buffering progress is increasing then restart the counter
    else if (dblCurrBufProgress > _dblLastBufProgress)
    {
        _BeginTimeOutCounter(FALSE);
        _dblLastBufProgress = dblCurrBufProgress;
    }
    else
    {
        // both play and buffering progress are stalled, so update the timeout counter

        // We poll the system time every POLL_INTERVAL ticks since we tick at a very high rate
        // (a tick is each time this function is called)

        if ((1 + _lTickCount) == POLL_INTERVAL)
        {
            DWORD dwCurrentTime = GetPerfTime();

            DWORD dwElapsedTime = (dwCurrentTime - _dwStartTime) 
                            + (dwCurrentTime < _dwStartTime ? 0xffffffff : 0); // if timer wraps around 2^32 milliseconds

            if (dwElapsedTime >= TIMEOUT_INTERVAL)
            {
                fTimeOut = TRUE;
            }
        }

        if (fTimeOut)
        {
            _OnNavigationTimeOut();
        }
        else
        {
            // update the poll interval counter and mod it by POLL_INTERVAL 
            _lTickCount =  (1 + _lTickCount) - (static_cast<long>(_lTickCount / POLL_INTERVAL) * POLL_INTERVAL);
        }
    }
}

VOID
CMediaBand::_OnNavigationTimeOut()
{
    _EndTimeOutCounter();

    // stop the player and show the timeout message
    if (EnsurePlayer())
    {
        if (VARIANT_FALSE == _pMediaPlayer->isStopped())
        {
            _pMediaPlayer->Stop();
            TogglePlayPause();

            // Show timeout error message
            TCHAR szText[200];
            szText[0] = TEXT('\0');
            MLLoadString(IDS_MEDIABAND_NAVTIMEOUT, szText, ARRAYSIZE(szText));
            SetStatusText(szText);
        }
    }
}

STDMETHODIMP
CMediaBand::_PutUrl(LPWSTR pstrUrl, LPWSTR pstrMime)
{
    HRESULT hr = E_FAIL;

    if (EnsurePlayer())
    {
        TCHAR szText[200];
        szText[0] = TEXT('\0');

        SetStatusText(_szConnecting);
        hr = _pMediaPlayer->put_type(pstrMime);
        if (SUCCEEDED(hr))
        {
            hr = _pMediaPlayer->put_url(pstrUrl);
            if (SUCCEEDED(hr))
            {
                // start the timeout counter
                if (_dblVol!=-1)
                {
                    _pMediaPlayer->put_volume(_dblVol);
                }
                _pMediaPlayer->put_mute(_fMuted);
                _BeginTimeOutCounter();
                UpdateBackForwardControls();
                SetPlayPause(FALSE);
                SetPlayerControl(FCIDM_MEDIABAND_STOP, TRUE);

                // make sure we undavise from soon-to-be obsolete player object 
                _AttachPlayerToProxies(FALSE);
            }
        }
    }
    return hr;
}

// *** IInputObject methods ***
HRESULT CMediaBand::TranslateAcceleratorIO(LPMSG pMsg)
{
    ASSERT(pMsg);
    TraceMsg(TF_ACCESSIBILITY, "CMediaBand::TranslateAcceleratorIO (hwnd=0x%08X) key=%d", _hwnd, pMsg->wParam);

    BOOL fHasFocus =     (   (_iElement>=0)
                          || (HasFocusIO() == S_OK)
                          || _fContentInFocus);

    if (fHasFocus && IsVK_CtlTABCycler(pMsg))
    {
        // Bail on ctl-tab/F6 if one of our guys already has focus
        return S_FALSE;
    }

    // if any child in focus, let them have a shot at it
    HRESULT hr = S_FALSE;
    if (fHasFocus)
    {
        if (_iElement >=0)
        {
            if (_hwndPopup && IsWindowVisible(_hwndPopup) && (pMsg->message==WM_KEYDOWN) && (pMsg->wParam==VK_ESCAPE))
    	    {
    	        DockMediaPlayer();
                hr = S_OK;
    	    }
            else 
            {
                hr = _pmw[_iElement]->TranslateAccelerator(pMsg);
            }
        }
        else if (_fContentInFocus && _poipao)
        {
            hr = _poipao->TranslateAccelerator(pMsg);
        }
        if (hr == S_OK) 
        {
            return S_OK;    // handled!!
        }
    }

    hr = S_FALSE;
    // try shifting focus to next element
    if (IsVK_TABCycler(pMsg))
    {
        BOOL fReverse = (GetKeyState(VK_SHIFT) < 0);
        if (fReverse)
        {
            // content pane is last tab target, move to last control widget with this backward tab
            if (_fContentInFocus)
            {
                _ContentActivateIO(FALSE, NULL);
                if (!(_hwndPopup && IsWindowVisible(_hwndPopup)))
                {
                    _iElement = ARRAYSIZE(_pmw)-1;
                }
                else
                {
                    return S_FALSE;
                }
            }
            else do 
            {
                _iElement--;
                if (_iElement<0)
                {
                    if (_fPopoutHasFocus)
                    {
                        _iElement = ARRAYSIZE(_pmw)-1;
                    }
                    break;
                }
            }
            while (!ISVALIDWIDGET(_pmw[_iElement]) || (!_pmw[_iElement]->IsEnabled()));
        }
        else
        {
            // content pane is last tab target, move away from mediabar with this forward tab
            if (_fContentInFocus)
            {
                _ContentActivateIO(FALSE, NULL);
                return S_FALSE;
            }
            // try next control widget
            if (!(_hwndPopup && IsWindowVisible(_hwndPopup)) || _fPopoutHasFocus)
            {
                if (_iElement<0)
                {
                    _iElement = 0;
                }
                else do 
                {
                    _iElement++;
                    if (_iElement>=ARRAYSIZE(_pmw))
                    {
                        _iElement = _fPopoutHasFocus ? 0 : -1;
                        break;
                    }
                }
                while (!ISVALIDWIDGET(_pmw[_iElement]) || (!_pmw[_iElement]->IsEnabled()));
            }
            // none of the control widgets claimed focus, try content pane
            if (_iElement<0)
            {
                hr = _ContentActivateIO(TRUE, pMsg);
                if (hr == S_OK) {
                    return S_OK;    // handled!!
                }
            }
        }
        if (_iElement<0)
        {
            return S_FALSE;
        }

        ASSERT(ISVALIDWIDGET(_pmw[_iElement]));
        ::SetFocus(_pmw[_iElement]->_hwnd);
        return S_OK;
    }
    
    return S_FALSE; // unhandled non-tab
}

//------------------------------------------------------------------------
HRESULT
    CMediaBand::UIActivateIO(BOOL fActivate, LPMSG pMsg)
{
    TraceMsg(TF_ACCESSIBILITY, "CMediaBand::UIActivateIO (hwnd=0x%08X) fActivate=%d", _hwnd, fActivate);
    HRESULT hr = S_OK;

    // activation:
    if (fActivate)
    {
        if (!(_hwndPopup && IsWindowVisible(_hwndPopup)) || _fPopoutHasFocus)
        {
            if (_iElement==-1)
            {
                _ContentActivateIO(FALSE, NULL);
                _iElement = 0;
            }
            if (_pmw[_iElement] && _pmw[_iElement]->_hwnd)
            {
                ::SetFocus(_pmw[_iElement]->_hwnd);
            }
        }
        else
        {
            _iElement = -1;
            _ContentActivateIO(TRUE, pMsg);
        }
        IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
    }
    else
    {
        _ContentActivateIO(FALSE, NULL);
        _iElement = -1;
        if (_hwndPopup && IsWindowVisible(_hwndPopup))
        {
            IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), FALSE);
        }            
    }
    return hr;
}

//------------------------------------------------------------------------
HRESULT
    CMediaBand::HasFocusIO()
{
    HRESULT hr = SHIsChildOrSelf((_hwndPopup && IsWindowVisible(_hwndPopup)) ? _hwndPopup : _hwnd, ::GetFocus());
    if (hr==S_FALSE)
    {
        // Focus might be in the content pane, which won't be a child if the popout is out
        hr = SHIsChildOrSelf(_hwndContent, ::GetFocus());
    }
    return hr;
}


HRESULT CMediaBand::_ContentActivateIO(BOOL fActivate, PMSG pMsg)
{
    ASSERT(_hwndContent);
    ASSERT(_poipao);

    if (_fContentInFocus == fActivate)
    {
        return S_OK;
    }

    _fContentInFocus = fActivate;
    if (fActivate)
    {
        _iElement = -1;
    }
    int iVerb = fActivate ? OLEIVERB_UIACTIVATE : OLEIVERB_INPLACEACTIVATE;

    HRESULT hr = S_OK;
    hr = OCHost_DoVerb(_hwndContent, iVerb, pMsg);

    // OCHost UIActivate is different than IInputObject::UIActivateIO.  It
    // doesn't do anything with the lpMsg parameter.  So, we need to pass
    // it to them via TranslateAccelerator.  Since the only case we care
    // about is when they're getting tabbed into (we want them to highlight
    // the first/last link), just do this in the case of a tab.  However,
    // don't give it to them if it's a ctl-tab.  The rule is that you shouldn't
    // handle ctl-tab when UI-active (ctl-tab switches between contexts), and
    // since Trident is always UI-active (for perf?), they'll always reject
    // ctl-tab.


    // suppress sending any tabs
    if (pMsg && _poipao && IsVK_TABCycler(pMsg) && !IsVK_CtlTABCycler(pMsg))
    {
        hr = _poipao->TranslateAccelerator(pMsg);
        // ignore if translate of tab fails when activating!
        if (FAILED(hr) && fActivate) {
            hr = S_OK;
        }
    }

    return hr;
}

LRESULT CMediaBand::_OnNotify(LPNMHDR pnm)
{
    switch (pnm->code)
    {
    case OCN_ONUIACTIVATE:  // UIActivate
        ASSERT(SHIsSameObject(((LPOCNONUIACTIVATEMSG)pnm)->punk, _poipao));

        _fContentInFocus = TRUE;
        _iElement = -1;
        
        IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
        return OCNONUIACTIVATE_HANDLED;

    case OCN_ONSETSTATUSTEXT:
        {
            HRESULT hr = E_FAIL;
            IShellBrowser *psb;

            hr = QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
            if (SUCCEEDED(hr)) {
                hr = psb->SetStatusTextSB(((LPOCNONSETSTATUSTEXTMSG)pnm)->pwszStatusText);
                psb->Release();
            }
        }
        break;

    default:
        break;
    }

    ASSERT(OCNONUIACTIVATE_HANDLED != 0);
    return 0;
}



// *** IDeskBand methods ***
HRESULT 
CMediaBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi) 
{
    _dwBandID = dwBandID;

    pdbi->dwModeFlags = DBIMF_FIXEDBMP | DBIMF_VARIABLEHEIGHT;
    
    if (pdbi->dwMask & DBIM_MINSIZE) 
    {
        pdbi->ptMinSize.x = 16;
        pdbi->ptMinSize.y = 16;
    }
    
    if (pdbi->dwMask & DBIM_MAXSIZE) 
    {
        pdbi->ptMaxSize.x = 32000; // random
        pdbi->ptMaxSize.y = 32000; // random
    }

    if (pdbi->dwMask & DBIM_ACTUAL) 
    {
        pdbi->ptActual.x = -1;
        pdbi->ptActual.y = -1;
    }

    if (pdbi->dwMask & DBIM_INTEGRAL) 
    {
        pdbi->ptIntegral.y = 1;
    }

    MLLoadStringW(IDS_MEDIABANDTEXT, pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));

    return S_OK;
} 

/***   CMediaBand::IPersistStream::**/
HRESULT CMediaBand::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_MediaBand;
    return S_OK;
}

// *** IPersistStream methods ***
HRESULT CMediaBand::Load(IStream *pstm)
{
    return S_OK;
}

// *** IPersistStream methods ***
HRESULT CMediaBand::Save(IStream *pstm, BOOL fClearDirty)
{
    return S_OK;
}

// *** IOleWindow methods ***
HRESULT CMediaBand::GetWindow(HWND *phwnd)
{
    if (!_hwnd) 
    {
        CreateParentPane();
    }

    if (!_hwndLayout) 
    {
        CreateLayoutPane();
    }
    if (!_hwndContent)
    {
        InitContentPane();
    }

    if (phwnd)
    {
        *phwnd = _hwnd ;
         return S_OK;
    }
    return SUPERCLASS::GetWindow(phwnd);
}

// *** IDockingWindow methods ***
HRESULT CMediaBand::ShowDW(BOOL fShow)
{
    if (!_hwnd)
        return S_FALSE; // The window needs to be created first.

    _fVideoAdjust = FALSE;
    if (fShow)
    {   
        _InitializeMediaUI();

        // FEATURE/010228/davidjen  uncomment this to suppress MediaBar's title bar
#ifdef _SUPPRESS_MB_TITLEBAR
        // hide caption/titlebar
        CComQIPtr<IBandSite, &IID_IBandSite>    pbs = _punkSite;
        if (pbs)
        {
            BANDSITEINFO    bsi;
            bsi.dwMask = BSIM_STYLE;
            HRESULT hr = pbs->GetBandSiteInfo(&bsi);
            if (SUCCEEDED(hr))
            {
                // suppress caption
                bsi.dwStyle |= BSIS_NOCAPTION;
                hr = pbs->SetBandSiteInfo(&bsi);
            }
        }
#endif // _SUPPRESS_MB_TITLEBAR
        
        if (!(_hwndPopup && IsWindowVisible(_hwndPopup)))
        {
            RECT rcParent, rc;
            GetClientRect(_hwnd, &rcParent);
            GetClientRect(_hwndLayout, &rc);

            if (RECTWIDTH(rcParent) > 0  || RECTHEIGHT(rcParent) > 0)
            {
                _ResizeChildWindows(_hwndLayout, RECTWIDTH(rc), RECTHEIGHT(rc), TRUE);
                SetWindowPos(_hwnd, NULL, 0, 0,RECTWIDTH(rcParent), RECTHEIGHT(rcParent), SWP_SHOWWINDOW | SWP_NOACTIVATE);
                RedrawWindow(_hwnd, NULL, NULL, RDW_INVALIDATE|RDW_UPDATENOW|RDW_ALLCHILDREN);
            }
        }
    }
    else
    {
        _ShowAllWindows(fShow);
    }
    if (fShow != _fShow)
    {
        _fShow = fShow;
        _FireEventToProxies(_fShow ? OnShow : OnHide);
    }
    return CToolBand::ShowDW(fShow);
}

HRESULT CMediaBand::CloseDW(DWORD dwReserved)
{
    if (!_hwnd)
        return S_FALSE; // The window needs to be created first.
    
    WTSUnRegisterSessionNotification(_hwnd);

    DestroyPlayer();

    if (_spBrowser)
    {
        _ConnectToCP(FALSE);
        _spBrowser.Release();
        _poipao.Release();
    }

    if (_hwndLayout && IsWindow(_hwndLayout))
    {
        DestroyWindow(_hwndLayout);
        _hwndLayout = NULL;
    }
    
    if (_hwndPopup && IsWindow(_hwndPopup))
    {
        DestroyWindow(_hwndPopup);
        _hwndPopup = NULL;
    }

    SUPERCLASS::CloseDW(dwReserved);

    return S_OK;
}


//--------------    Interface IElementBehaviorFactory
//------------------------------------------------------------------------
STDMETHODIMP CMediaBand::FindBehavior(BSTR bstrBehavior, BSTR bstrBehaviorUrl,
							          IElementBehaviorSite* pSite, IElementBehavior** ppBehavior)
{
    if (ppBehavior == NULL)
    {
        return E_POINTER;
    }
    *ppBehavior = NULL;

    // check namespace and URL
    if (StrCmpIW(bstrBehavior, TEXT("mediaBar")) != 0) {
        return E_NOTIMPL;   // don't know this behavior!!
    }

    HRESULT hr = S_OK;
    // create new behavior instance for this HTML pane
    IContentProxy * pProxy = NULL;
    pProxy = CMediaBehavior_CreateInstance(this);
    if (pProxy)
    {
        hr = pProxy->QueryInterface(IID_IElementBehavior, (void**)ppBehavior);
        if (FAILED(hr))
        {
            // make sure we get rid our reference
            removeProxy(pProxy);
        }
    }
    else {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

// IMediaHost
//------------------------------------------------------------------------
STDMETHODIMP CMediaBand::getMediaPlayer(IUnknown **ppPlayer)
{
    if (ppPlayer == NULL)
        return E_POINTER;
    *ppPlayer = NULL;

    if (_pMediaPlayer)
    {
        ITIMEMediaElement *pElem = NULL;
        if (SUCCEEDED(_pMediaPlayer->get_mediaElement(&pElem)))
        {
            *ppPlayer = pElem;  // no AddRef, get_mediaElement already did ref counting!!
        }
    }
    return *ppPlayer ? S_OK : S_FALSE;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBand::playURL(BSTR bstrURL, BSTR bstrMIME)
{
    HRESULT hr = _EnsureWMPInstalled();
    if (FAILED(hr))
    {   
        return hr;
    }
    CComVariant varMime = bstrMIME;
    CComVariant varUrl  = bstrURL;

    _strLastUrl = _strCurrentContentUrl;
    _strLastMime.Empty();
    _fLastUrlIsAutoPlay = FALSE;

    _HandleAutoPlay(&varMime, &varUrl);
    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBand::addProxy(IUnknown *punkProxy)
{
    HRESULT hr = E_POINTER;
    if (punkProxy)
    {
        // add to our array of proxies
        if (_apContentProxies == NULL) {
            _apContentProxies.Create(2);
        }
        if (_apContentProxies == NULL)
        {
            return E_OUTOFMEMORY;
        }

        // want to be sure proxy knows our protocol, also does add ref
        IContentProxy *pProxy = NULL;
        hr = punkProxy->QueryInterface(IID_PPV_ARG(IContentProxy, &pProxy));
        if (SUCCEEDED(hr))
        {
            _apContentProxies.AppendPtr(pProxy);
        }

    }
    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBand::removeProxy(IUnknown *punkProxy)
{
    if (_apContentProxies == NULL)
        return S_FALSE;

    HRESULT hr = S_FALSE;
    int cnt = _apContentProxies.GetPtrCount();
    for (int i = 0; i < cnt; i++)
    {
        IContentProxy* pProxy = _apContentProxies.GetPtr(i);
        ASSERT(pProxy);
        if (pProxy)
        {
            if (SHIsSameObject(pProxy, punkProxy))
            {
                _apContentProxies.DeletePtr(i);
                pProxy->Release();
                ResetPlayer();  // privacy issue:
                                    // make sure player is stopped and proxy/behavior in next page cannot access current media
                _fAttached = FALSE;     // force reattaching to player once a new behavior is up
                hr = S_OK;
                break;
            }
        }
    }
    return hr;
}

// IMediaHost2
//------------------------------------------------------------------------
STDMETHODIMP CMediaBand::OnDisableUIChanged(BOOL fDisabled)
{
    return S_OK;
}


//------------------------------------------------------------------------
void CMediaBand::_AttachPlayerToProxies(BOOL fAttach)
{
    if (_apContentProxies == NULL)
        return;
    if (_fAttached == fAttach)
        return;

    int cnt = _apContentProxies.GetPtrCount();
    for (int i = 0; i < cnt; i++)
    {
        IContentProxy* pProxy = _apContentProxies.GetPtr(i);
        ASSERT(pProxy);
        if (pProxy)
        {
            HRESULT hr;
            if (fAttach) {
                hr = pProxy->OnCreatedPlayer();
            }
            else {
                pProxy->detachPlayer();
                hr = S_OK;
            }
            if (SUCCEEDED(hr)) {
                _fAttached = fAttach;
            }
        }
    }
}

//------------------------------------------------------------------------
void CMediaBand::_DetachProxies()
{ 
    if (_apContentProxies == NULL)
        return;

    int cnt = _apContentProxies.GetPtrCount();
    // need to iterate from last to first, call to removeProxy() will also remove it from DPA!
    for (int i = cnt - 1; i >= 0; i--)
    {
        IContentProxy* pProxy = _apContentProxies.GetPtr(i);
        ASSERT(pProxy);
        if (pProxy)
        {
            removeProxy(pProxy);
        }
    } 
    _apContentProxies.Destroy();
    return;
}

//------------------------------------------------------------------------
BOOL CMediaBand::_isUIDisabled()
{
    if (_apContentProxies == NULL)
        return FALSE;

    int cnt = _apContentProxies.GetPtrCount();
    BOOL fDisabled = FALSE;
    for (int i = 0; i < cnt; i++)
    {
        CComQIPtr<IMediaBehaviorContentProxy, &IID_IMediaBehaviorContentProxy> pProxy = _apContentProxies.GetPtr(i);
        if (pProxy)
        {
            BOOL fQueryDisabled = FALSE;
            pProxy->IsDisableUIRequested(&fQueryDisabled);
            if (fQueryDisabled)
            {
                fDisabled = TRUE;
                break;
            }
        }
    }
    return fDisabled;
}

//------------------------------------------------------------------------
BOOL CMediaBand::_isProxiesNextEnabled()
{
    if (_apContentProxies == NULL)
        return TRUE;

    int cnt = _apContentProxies.GetPtrCount();
    BOOL fEnabled = TRUE;
    for (int i = 0; i < cnt; i++)
    {
        CComQIPtr<IMediaBehaviorContentProxy, &IID_IMediaBehaviorContentProxy> pProxy = _apContentProxies.GetPtr(i);
        if (pProxy)
        {
            BOOL fQueryEnabled = FALSE;
            pProxy->IsNextEnabled(&fQueryEnabled);
            if (!fQueryEnabled)
            {
                fEnabled = FALSE;
                break;
            }
        }
    }
    return fEnabled;
}


//------------------------------------------------------------------------
void CMediaBand::_OnUserOverrideDisableUI()
{
    if (_apContentProxies == NULL)
        return;

    int cnt = _apContentProxies.GetPtrCount();
    BOOL fDisabled = FALSE;
    for (int i = 0; i < cnt; i++)
    {
        CComQIPtr<IMediaBehaviorContentProxy, &IID_IMediaBehaviorContentProxy> pProxy = _apContentProxies.GetPtr(i);
        if (pProxy)
        {
            pProxy->OnUserOverrideDisableUI();
        }
    }
}

//------------------------------------------------------------------------
void CMediaBand::_FireEventToProxies(enum contentProxyEvent event)
{
    if (_apContentProxies == NULL)
        return;

    int cnt = _apContentProxies.GetPtrCount();
    BOOL fDisabled = FALSE;
    for (int i = 0; i < cnt; i++)
    {
        IContentProxy* pProxy = _apContentProxies.GetPtr(i);
        ASSERT(pProxy);
        if (pProxy)
        {
            pProxy->fireEvent(event);
        }
    }
}

//------------------------------------------------------------------------
void CMediaBand::_CleanupStopTimer()
{
    if (_idStopTimer != 0)
    {
        KillTimer(_hwnd, _idStopTimer);
        _idStopTimer = 0;
        // make sure user hasn't initiated another media action yet!!!
        SetPlayerControl(FCIDM_MEDIABAND_STOP, FALSE);
    }
}

//------------------------------------------------------------------------
HRESULT CMediaBand::_EnsureWMPInstalled(BOOL fShowErrorMsg)
{
    HRESULT hr = S_OK;
    if (!CMediaBarUtil::IsWMP7OrGreaterInstalled())
    {
        // ISSUE: assumption that XP already has matching WMP version
        if (!IsOS(OS_WHISTLERORGREATER))
        {
            // try to web-jit WMP8. 
            uCLSSPEC ucs;
            QUERYCONTEXT qc = { 0 };

            ucs.tyspec = TYSPEC_CLSID;
            ucs.tagged_union.clsid = CLSID_JITWMP8;

            hr = FaultInIEFeature(_hwnd, &ucs, &qc, FIEF_FLAG_FORCE_JITUI);
        }
        if (!CMediaBarUtil::IsWMP7OrGreaterInstalled())
        {
            // still no WMP, user might have aborted or install failed
            if (fShowErrorMsg)
            {
                MLShellMessageBox(_hwnd, MAKEINTRESOURCE(IDS_MEDIABAND_NOWMP7), MAKEINTRESOURCE(IDS_MEDIABAND_NOWMP7TITLE), MB_OK);
            }
            hr = E_UNEXPECTED;
        }
    }
    return hr;
}



// *** IBrowserBand methods ***
STDMETHODIMP CMediaBand::GetObjectBB(REFIID riid, LPVOID *ppv)
{
    return _spBrowser ? _spBrowser->QueryInterface(riid, ppv) : E_UNEXPECTED;
}

// *** IBandNavigate methods ***
STDMETHODIMP CMediaBand::Select(LPCITEMIDLIST pidl)
{
    _strDeferredURL.Empty();    // cancel any deferred navigation (usually during initial launch of mediabar
    return NavigateContentPane(pidl);
}

HRESULT CMediaBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    CMediaBand * pmb = new CMediaBand();

    if (!pmb)
        return E_OUTOFMEMORY;

    // if you change this cast, fix up CChannelBand_CreateInstance
    *ppunk = SAFECAST(pmb, IDeskBand *);

    return S_OK;
}

//+-------------------------------------------------------------------------
// Creates Player
//--------------------------------------------------------------------------
BOOL
CMediaBand::EnsurePlayer()
{
    BOOL fResult = _pMediaPlayer ? TRUE : FALSE;
    if (!fResult)
    {
        fResult = CreatePlayer();
    }
    return fResult && _pMediaPlayer;
}


BOOL  
CMediaBand::CreatePlayer()
{
    HRESULT hr = CMediaBarPlayer_CreateInstance(IID_PPV_ARG(IMediaBarPlayer, &_pMediaPlayer));
    if (SUCCEEDED(hr))
    {
        hr = _pMediaPlayer->Init(_hwndLayout, SAFECAST(this, IMediaBar*));
        if (SUCCEEDED(hr))
        {
            hr = _pMediaPlayer->GetVideoHwnd(&_hwndVideo);
        }
        if (FAILED(hr))
        {
            ASSERT(FALSE);
            DestroyPlayer();
        }
    }
    return SUCCEEDED(hr);
}

VOID CMediaBand::DestroyPlayer()
{
    _AttachPlayerToProxies(FALSE);
    if (_pMediaPlayer)
    {
        _pMediaPlayer->DeInit();
        _pMediaPlayer->Release();
        _pMediaPlayer = NULL;
    }
    _DetachProxies();
 }

// notifications from the player

STDMETHODIMP CMediaBand::Notify(long lReason)
{
    HRESULT hr = E_FAIL;
    
    if (EnsurePlayer())
    {
        // update play/pause state
        TogglePlayPause();
        if (!_fAttached) {
            _AttachPlayerToProxies(TRUE);
        }

        switch (lReason)
        {
        case DISPID_TIMESTATE_PROGRESS:
            {
                double dblProgress = _pMediaPlayer->GetTrackProgress();
                if (!_fSeeking)
                {
                    SetSeekPos(static_cast<float>(dblProgress));
                }
                
                // Update download/buffering progress, if any
                {
                    ProgressType ProgType = PT_None;
                    double dblBufProg = 0.0;
                    hr = _pMediaPlayer->GetBufProgress(&dblBufProg, &ProgType);
                    
                    // S_OK only means that there's some buffering going on
                    if ((hr == S_OK) && dblBufProg >= 0.0 && dblBufProg < 100.0)
                    {
                        SetStatusText(_szConnecting);
                    }
                    else
                    {
                        ShowPlayingStatus();
                    }
                    
                    if (TRUE == _pMediaPlayer->IsStreaming())
                    {
                        // if this is streamed then substitute progress with track time
                        // since progress is not meaningful
                        dblProgress = _pMediaPlayer->GetTrackTime();
                        _UpdateTimeOutCounter(dblBufProg, dblProgress);
                    }
                    else
                    {
                        _UpdateTimeOutCounter(dblBufProg, dblProgress);
                    }
                }
            } 
            break; // case DISPID_TIMESTATE_PROGRESS
            
        case MEDIACOMPLETE:
        case TRACK_CHANGE:
            _fPlaying = TRUE;
            ShowPlayingStatus(TRUE);
            AdjustVideoHeight(TRUE);
            _EndTimeOutCounter();
            SetPlayPause(_pMediaPlayer->IsPausePossible());
            UpdateBackForwardControls();
            if (ISVALIDWIDGET(_pmwSeek))
            {
                _pmwSeek->SetState(_pMediaPlayer->IsSeekPossible());
            }
            break;
            
        case MEDIA_TRACK_FINISHED:
            if (_iCurTrack != -1)
            {
                PlayNextTrack();
            }
            else
            {
                _fSeeking = FALSE;
                ResetPlayer();
            }
            break;
            
        case DISPID_TIMEMEDIAELEMENT_TITLE:
            _OnTitleChange();
            ShowPlayingStatus(TRUE);
            break;
        } // switch (lReason)
        hr = S_OK;
    } // end if
    
    return hr;
}

STDMETHODIMP CMediaBand::OnMediaError(int iErrCode)
{
    _EndTimeOutCounter();

    if (-1 == iErrCode)
    {
        // if there is no rich erro info display the generic error message
        TCHAR szText[MAX_PATH];
        szText[0] = TEXT('\0');
        MLLoadString(IDS_MEDIABAND_INVALIDFILE, szText, ARRAYSIZE(szText));
        SetStatusText(szText);
    }
    else
    {
        // ISSUE: to do: display the appropriate error message
        ASSERT(FALSE);
    }

#ifdef PLAY_INDEFAULT
    // delegate the playback to the default player (fix for 24146)
    {
        //
        // ISSUE: What should we do for errors within a playlist??????
        //

        CComBSTR sbstrUrl;
        if (EnsurePlayer() && SUCCEEDED(_pMediaPlayer->get_url(&sbstrUrl)) && (NULL != sbstrUrl.m_str))
        {
            _OpenInDefaultPlayer(sbstrUrl);
        }
    }
#endif

    return S_OK;
}

//+-------------------------------------------------------------------------
// Handler for property change notification
//--------------------------------------------------------------------------
void CMediaBand::_OnTitleChange()
{
    // The status text and playlist menu should be updated here
}

//+-------------------------------------------------------------------------
// Resize the video
//--------------------------------------------------------------------------
void CMediaBand::_ResizeVideo(LONG* plWidth, LONG* plHeight)
{
    if (EnsurePlayer() && _hwndVideo && ::IsWindow(_hwndVideo))
    {
        _pMediaPlayer->Resize(plHeight, plWidth, FALSE); 
    }
}

//+-------------------------------------------------------------------------
// Redraw/show/hide the video window only if something has changed
//--------------------------------------------------------------------------
VOID
CMediaBand::AdjustVideoHeight(BOOL fForceResize)
{
    VARIANT_BOOL vbHasVisual = VARIANT_FALSE;
    
    CComPtr<ITIMEMediaElement> spMediaElem;
    if (_pMediaPlayer && SUCCEEDED(_pMediaPlayer->get_mediaElement(&spMediaElem)))
    {    
        //  Show/hide the video display window
        if (SUCCEEDED(spMediaElem->get_hasVisual(&vbHasVisual)))
        {
            BOOL fVideo = (VARIANT_TRUE == vbHasVisual ? TRUE : FALSE) && _fPlaying;

            if (fVideo)
            {
                if (!IsWindowVisible(_hwndVideo) && !_fIsVideo)
                {                    
                    ShowWindow(_hwndVideo, SW_SHOW);
                    _fVideoAdjust = TRUE;
                    _fIsVideo = TRUE;
                }
            }
            else
            {
                if (IsWindowVisible(_hwndVideo) && _fIsVideo)
                {
                    _fVideoAdjust = TRUE;
                    ShowWindow(_hwndVideo, SW_HIDE);
                    _fIsVideo = FALSE;
                }
            }

            if (!_fVideoAdjust && fForceResize)
            {
                _fVideoAdjust = TRUE;
            }

            // redraw only if something has changed, so that this function can be called very often
            // (e.g. from Notify) without causing excessive drawing. 
            if (_fVideoAdjust)
            {
                _fVideoAdjust = FALSE;
                if (_hwndPopup && IsWindowVisible(_hwndPopup))
                {
                    LONG lHeight = GetPopoutHeight(TRUE, _sizeVideo.cx);
                    
                    SetWindowPos(_hwndPopup, HWND_TOPMOST, 0, 0, _sizeLayout.cx, 
                                 lHeight, SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE);

                    InvalidateRect(_hwndPopup, NULL, TRUE);
                    
                    ShowWindow(_hwndPopup, SW_SHOW);
                    UpdateWindow(_hwndPopup);
                }
                else
                {
                    RECT rcParent;
                    GetClientRect(_hwnd, &rcParent);
                    LONG lHeight = RECTHEIGHT(rcParent);

                    lHeight = GetLayoutHeight();
                    AdjustLayout(RECTWIDTH(rcParent), lHeight);
                    SendMessage(_hwnd, WM_SIZE, (WPARAM)0, (LPARAM) MAKELONG(RECTWIDTH(rcParent), lHeight));
                }   
            }
        }
    }
}


VOID
CMediaBand::AdjustLayout(LONG_PTR lWidth, LONG_PTR lHeight)
{
    RECT rcClient;

    if (!(_hwndPopup && IsWindowVisible(_hwndPopup)))
    {
        GetClientRect(_hwnd, &rcClient);

        if (lWidth<=MIN_WINDOW_WIDTH)
        {
          if (RECTWIDTH(rcClient) < MIN_WINDOW_WIDTH)
             lWidth = MIN_WINDOW_WIDTH ;
          else
             lWidth = RECTWIDTH(rcClient);
        }

        if (lHeight<=MIN_WINDOW_HEIGHT)
        {
            if (RECTHEIGHT(rcClient) < MIN_WINDOW_HEIGHT)
               lHeight = MIN_WINDOW_HEIGHT ;
            else
               lHeight  = RECTHEIGHT(rcClient);
        }
    }
    _ResizeChildWindows(_hwndLayout, (LONG)lWidth, (LONG)lHeight, TRUE);
}

// IServiceProvider implementation
HRESULT CMediaBand::QueryService(REFGUID guidService, REFIID riid, void ** ppvObj)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsEqualIID(guidService, SID_SMediaBar))
    {
        hr = QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(guidService, SID_SMediaBarSync))
    {
        hr = QueryInterface(riid, ppvObj);
    }
    else if (IsEqualGUID(guidService, SID_SElementBehaviorFactory))
    {
        hr = QueryInterface(riid, ppvObj);
    }
    else if (IsEqualGUID(guidService, SID_STimeContent))
    {
        hr = QueryInterface(riid, ppvObj);
    }
    else
    {
        hr = SUPERCLASS::QueryService(guidService, riid, ppvObj);
    }
    return hr;
}

STDMETHODIMP
CMediaBand::_TogglePause()
{
    HRESULT hr = E_FAIL;

    if (EnsurePlayer())
    {
        if (VARIANT_TRUE == _pMediaPlayer->isPaused())
        {
            _fUserPaused = FALSE;
            if (SUCCEEDED(_pMediaPlayer->Resume()))
            {
                _BeginTimeOutCounter();
                hr = S_OK;
            }
        }
        else
        {
            _fUserPaused = TRUE;
            hr = _pMediaPlayer->Pause();
            if (SUCCEEDED(hr))
            {
                _EndTimeOutCounter();
                hr = S_OK;
            }
        }

        TogglePlayPause();
    }
    return hr;
}      

//+-------------------------------------------------------------------------
// Creates and shows buttons
//--------------------------------------------------------------------------
HRESULT 
CMediaBand::CreateControls()
{
    // _pmwPlay
    _pmw[MW_PLAY] = CMediaWidgetButton_CreateInstance(_hwndLayout, 31, 33, FCIDM_MEDIABAND_PLAY, IDB_MEDIABAND_PLAY, IDB_MEDIABAND_PAUSE, IDS_MEDIABAND_PLAY, IDS_MEDIABAND_PAUSE);
    // _pmwStop
    _pmw[MW_STOP] = CMediaWidgetButton_CreateInstance(_hwndLayout, 18, 33, FCIDM_MEDIABAND_STOP, IDB_MEDIABAND_STOP, 0, IDS_MEDIABAND_STOP);
    // _pmwBack
    _pmw[MW_BACK] = CMediaWidgetButton_CreateInstance(_hwndLayout, 22, 16, FCIDM_MEDIABAND_PREVIOUS, IDB_MEDIABAND_BACK, 0, IDS_MEDIABAND_BACK);
    // _pmwNext
    _pmw[MW_NEXT] = CMediaWidgetButton_CreateInstance(_hwndLayout, 22, 16, FCIDM_MEDIABAND_NEXT, IDB_MEDIABAND_NEXT, 0, IDS_MEDIABAND_NEXT);

    _pmw[MW_MUTE] = new CMediaWidgetToggle(_hwndLayout, 22, 16);
    if (_pmwMute)
    {
        HRESULT hr = _pmwMute->Initialize(FCIDM_MEDIABAND_MUTE, IDS_MEDIABAND_UNMUTE, IDS_MEDIABAND_MUTE);
        if (SUCCEEDED(hr))
        {
            hr = _pmwMute->SetImageList(IDB_MEDIABAND_MUTE);
        }
        if (SUCCEEDED(hr))
        {
            hr = _pmwMute->SetAlternateImageList(IDB_MEDIABAND_MUTE);
        }
        _pmwMute->SetState(FALSE);
        if (FAILED(hr))
        {
            delete _pmwMute;
            _pmw[MW_MUTE] = NULL;
        }
    }

    _pmw[MW_OPTIONS] = new CMediaWidgetOptions(_hwndLayout, 16, 16);
    if (_pmwOptions)
    {
        HRESULT hr = _pmwOptions->Initialize(FCIDM_MEDIABAND_MUTE, IDS_MEDIABAND_UNMUTE, IDS_MEDIABAND_MUTE);
        if (FAILED(hr))
        {
            delete _pmwOptions;
            _pmw[MW_OPTIONS] = NULL;
        }
    }

    // _pmwPop
    _pmw[MW_POP] = CMediaWidgetButton_CreateInstance(_hwndLayout, 19, 20, FCIDM_MEDIABAND_POPOUT, IDB_MEDIABAND_POPOUT, IDB_MEDIABAND_POPIN, IDS_MEDIABAND_UNDOCK, IDS_MEDIABAND_DOCK);
    return S_OK;
}


HRESULT
CMediaBand::CreateSeekBar()
{
    DWORD dwWindowStyles = WS_TABSTOP | WS_VISIBLE | WS_CHILD | TBS_NOTICKS | TBS_FIXEDLENGTH; 
    DWORD dwExStyle      = WS_EX_TRANSPARENT;

    _hwndSeek = CreateWindowEx(dwExStyle, TRACKBAR_CLASS, NULL, dwWindowStyles,
                                0, 0, 0, 0, _hwndLayout, (HMENU) FCIDM_MEDIABAND_SEEK, HINST_THISDLL, NULL);

    if (_hwndSeek)
    {
        if (SetProp(_hwndSeek, c_szMediaBandProp, this))
        {
            SetWindowLongPtr(_hwndSeek, GWLP_USERDATA, (LPARAM)(WNDPROC)(GetWindowLongPtr(_hwndSeek, GWLP_WNDPROC)));
            SetWindowLongPtr(_hwndSeek, GWLP_WNDPROC,  (LPARAM)s_SeekWndSubClassProc);
        }
        SendMessage(_hwndSeek, TBM_SETRANGE, (WPARAM)TRUE , (LPARAM)MAKELONG(0, 100));  // min. & max. positions 
        SendMessage(_hwndSeek, TBM_SETPAGESIZE, 0, (LPARAM)4);                  // new page size 
        SendMessage(_hwndSeek, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)0); 

        // ISSUE: For some reason, the length of the trackbar slider is screwed up, and the rect returned by the slider is half the actual width
        SendMessage(_hwndSeek, TBM_SETTHUMBLENGTH, (WPARAM)VOLUME_GRIPPER_LENGTH*2, 0);
        _himlSeekBack = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_MEDIABAND_SEEKBACK), SEEK_PART_WIDTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);
        _himlSeekFill = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_MEDIABAND_SEEKFILL), SEEK_PART_WIDTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);
        _pmw[MW_SEEK] = new CMediaWidgetSeek();
        if (_pmwSeek)
        {
            _pmwSeek->Initialize(_hwndSeek);
        }
        Comctl32_SetDPIScale(_hwndSeek);
        ShowWindow(_hwndSeek, SW_SHOW);

        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

HRESULT
CMediaBand::CreateVolumeControl()
{
    DWORD dwWindowStyles = WS_TABSTOP | WS_VISIBLE | WS_CHILD | TBS_NOTICKS | TBS_TOOLTIPS;
    DWORD dwExStyle       = WS_EX_TRANSPARENT;

    _hwndVolume = CreateWindowEx(dwExStyle, TRACKBAR_CLASS, NULL, dwWindowStyles,
                                0, 0, 0, 0, _hwndLayout, (HMENU) FCIDM_MEDIABAND_VOLUME, HINST_THISDLL, NULL);

    if (_hwndVolume)
    {
        if (SetProp(_hwndVolume, c_szMediaBandProp, this))
        {
            SetWindowLongPtr(_hwndVolume, GWLP_USERDATA, (LPARAM)(WNDPROC)(GetWindowLongPtr(_hwndVolume, GWLP_WNDPROC)));
            SetWindowLongPtr(_hwndVolume, GWLP_WNDPROC,  (LPARAM)s_VolumeWndSubClassProc);
        }

        SendMessage(_hwndVolume, TBM_SETRANGE, (WPARAM)TRUE , (LPARAM)MAKELONG(0, 100));  // min. & max. positions 
        SendMessage(_hwndVolume, TBM_SETPAGESIZE, 0, (LPARAM) 4);                  // new page size 
        SendMessage(_hwndVolume, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)50); 

        ShowWindow(_hwndVolume, SW_SHOW);

        _himlVolumeBack = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_MEDIABAND_VOLBKGND), VOLUME_BITMAP_WIDTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);
        _himlVolumeFill = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_MEDIABAND_VOLFILL), VOLUME_BITMAP_WIDTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);
        _himlGripper = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_MEDIABAND_VOLTAB), VOLUME_GRIPPER_LENGTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);

        _pmw[MW_VOLUME] = new CMediaWidgetVolume;
        if (_pmwVolume)
        {
            _pmwVolume->Initialize(_hwndVolume);
        }
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

HRESULT
CMediaBand::CreateLayoutPane()
{
    if (!_hwndLayout)
    {
        WNDCLASS wndclass    = { 0 };
        wndclass.style         = CS_PARENTDC; // | CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc   = s_LayoutWndProc;
        wndclass.hInstance     = MLGetHinst();
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.lpszClassName = c_szMediaBarLayoutClassName;

        SHRegisterClass(&wndclass);

        _hwndLayout = CreateWindowEx(WS_EX_CONTROLPARENT, c_szMediaBarLayoutClassName, NULL, 
                               WS_TABSTOP | WS_VISIBLE | WS_CHILD, 
                               CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT, _hwnd, NULL, MLGetHinst(), (void *)this);


        if (_hwndLayout == NULL)
        {
            ASSERT(FALSE);
            return E_FAIL;        
        }
        else
        {
          ::ShowWindow(_hwndLayout, SW_SHOW);
        }
    }

    return S_OK;
}

#define BACKGROUND_WIDTH    (240/3)
#define BACKGROUND_TOP  12
#define BACKGROUND_MIDDLE 2
#define BACKGROUND_BOTTOM 55

VOID CMediaBand::DrawBackground(HDC hdc, HWND hwnd)
{
    if (_fHiColour)
    {
        HDC hdcSrc = CreateCompatibleDC(hdc);
        if (hdcSrc)
        {
            if (_hbmpBackground)
            {
                RECT rc;
                if (GetClientRect(hwnd, &rc))
                {
                    SelectObject(hdcSrc, _hbmpBackground);

                    UINT xTra = 0;

                    if (g_bRunOnMemphis && IS_WINDOW_RTL_MIRRORED(_hwnd))
                    {
                        rc.right++;
                        xTra++;
                    }

                    // We have 9 regions to paint. First we'll bitblt the corners, and then we'll do middle sections, which can be stretched without
                    // loss of fidelity in a given direction.
                    // |A|B|C|
                    // |D|E|F|
                    // |G|H|I|

                    // Corners are bitblted
                    // A
                    BitBlt(hdc, rc.left, rc.top, BACKGROUND_WIDTH, BACKGROUND_TOP, hdcSrc, 0, 0, SRCCOPY);
                    // C
                    BitBlt(hdc, max(rc.right-BACKGROUND_WIDTH, rc.left+BACKGROUND_WIDTH), rc.top, BACKGROUND_WIDTH, BACKGROUND_TOP, hdcSrc, 2*BACKGROUND_WIDTH, 0, SRCCOPY);
                    // G
                    BitBlt(hdc, rc.left, max(rc.bottom-BACKGROUND_BOTTOM, rc.top+BACKGROUND_TOP), BACKGROUND_WIDTH, BACKGROUND_BOTTOM, hdcSrc, 0, BACKGROUND_TOP+BACKGROUND_MIDDLE, SRCCOPY);
                    // I
                    BitBlt(hdc, max(rc.right-BACKGROUND_WIDTH, rc.left+BACKGROUND_WIDTH), max(rc.bottom-BACKGROUND_BOTTOM, rc.top+BACKGROUND_TOP), BACKGROUND_WIDTH*2, BACKGROUND_BOTTOM, hdcSrc, BACKGROUND_WIDTH*2, BACKGROUND_TOP+BACKGROUND_MIDDLE, SRCCOPY);

                    // Middles are all repeated/stetched
                    if (rc.right-BACKGROUND_WIDTH > rc.left+BACKGROUND_WIDTH)
                    {
                        // B
                        StretchBlt(hdc, rc.left+BACKGROUND_WIDTH, rc.top, RECTWIDTH(rc)-2*BACKGROUND_WIDTH+xTra, BACKGROUND_TOP, hdcSrc, BACKGROUND_WIDTH, 0, BACKGROUND_WIDTH, BACKGROUND_TOP, SRCCOPY);
                        // H
                        StretchBlt(hdc, rc.left+BACKGROUND_WIDTH, max(rc.bottom-BACKGROUND_BOTTOM, rc.top+BACKGROUND_TOP), RECTWIDTH(rc)-2*BACKGROUND_WIDTH+xTra, BACKGROUND_BOTTOM, hdcSrc, BACKGROUND_WIDTH, BACKGROUND_TOP+BACKGROUND_MIDDLE, BACKGROUND_WIDTH, BACKGROUND_BOTTOM, SRCCOPY);
                    }

                    if (rc.bottom-BACKGROUND_BOTTOM > rc.top+BACKGROUND_TOP)
                    {
                        // D
                        StretchBlt(hdc, rc.left, rc.top+BACKGROUND_TOP, BACKGROUND_WIDTH, RECTHEIGHT(rc)-BACKGROUND_TOP-BACKGROUND_BOTTOM, 
                                 hdcSrc, 0, BACKGROUND_TOP, BACKGROUND_WIDTH, BACKGROUND_MIDDLE, SRCCOPY);
                        // F
                        StretchBlt(hdc, max(rc.right-BACKGROUND_WIDTH, rc.left+BACKGROUND_WIDTH), rc.top+BACKGROUND_TOP, BACKGROUND_WIDTH, RECTHEIGHT(rc)-BACKGROUND_TOP-BACKGROUND_BOTTOM, 
                                 hdcSrc, BACKGROUND_WIDTH*2, BACKGROUND_TOP, BACKGROUND_WIDTH, BACKGROUND_MIDDLE, SRCCOPY);
                        // E
                        // This section is one solid colour.
                        if (rc.right-BACKGROUND_WIDTH > rc.left+BACKGROUND_WIDTH)
                        {
                            RECT rc2;
                            rc2.left = rc.left+BACKGROUND_WIDTH;
                            rc2.right = rc.right-BACKGROUND_WIDTH;
                            rc2.top = rc.top+BACKGROUND_TOP;
                            rc2.bottom = rc.bottom-BACKGROUND_BOTTOM;
                            SHFillRectClr(hdc, &rc2, COLOR_BKGNDMIDDLE);
                        }
                    }
                }
            }
            DeleteDC(hdcSrc);
        }
    }
    else
    {
        RECT rc;
        if (GetClientRect(hwnd, &rc))
        {
            SHFillRectClr(hdc, &rc, COLOR_BKGND16);
        }
    }

    if (_hwndVideo && IsWindowVisible(_hwndVideo))
    {
        RedrawWindow(_hwndVideo, NULL, NULL, RDW_ALLCHILDREN | RDW_INVALIDATE);
    }
}


// WndProc for main window to go in rebar
LRESULT CALLBACK CMediaBand::s_LayoutWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMediaBand* pmb = reinterpret_cast<CMediaBand *>(GetWindowLongPtr(hWnd, GWLP_USERDATA));

    if (msg==WM_CREATE)
    {
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (reinterpret_cast<LONG_PTR>((reinterpret_cast<CREATESTRUCT *>(lParam))->lpCreateParams)));
        return 0;
    }
    else if (pmb)
    {
        switch (msg)
        {
        case WM_PAINT:
        {
            break;
        }

        case WM_ERASEBKGND:
            pmb->DrawBackground((HDC)wParam, hWnd);
            return TRUE;

        case WM_SIZE:
            if ((LONG)LOWORD(lParam) <= 0 || (LONG)HIWORD(lParam) <= 0 )
                break;

            pmb->AdjustLayout(LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
            {
            BOOL fNewColours = (SHGetCurColorRes() > 8);
            if (fNewColours!=pmb->_fHiColour)
            {
                pmb->SwitchBitmaps(fNewColours);
            }
            pmb->AdjustVideoHeight(TRUE);
            }
            break;

        case WM_VSCROLL:
        case WM_HSCROLL:
            if ((HWND)lParam == pmb->_hwndSeek)
            {
                SendMessage(pmb->_hwndSeek, msg, wParam, lParam);
            }
            else if ((HWND)lParam == pmb->_hwndVolume)
            {
                SendMessage(pmb->_hwndVolume, msg, wParam, lParam);
            }
            break;

        case WM_NOTIFY:
        {
            LRESULT lres;
            if (pmb->OnNotify((LPNMHDR)lParam, &lres))
            {
                return lres;
            }
            break;
        }
        break;

        case WM_COMMAND:
        {
            LRESULT lres;
            if (pmb->OnWinEvent(hWnd, msg, wParam, lParam, &lres) == S_OK)
                return lres;
        }
        break;
        }
    }
    return DefWindowProc(hWnd, msg, wParam, lParam);
}


HRESULT CMediaBand::CreateParentPane()
{
    if (!_hwnd)
    {
        WNDCLASS wndclass    = { 0 };
        wndclass.style         = CS_PARENTDC | CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc   = s_WndProc;
        wndclass.hInstance     = MLGetHinst();
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.lpszClassName = c_szMediaBarClassName;

        SHRegisterClass(&wndclass);
        
        _hwnd = CreateWindowEx(WS_EX_CONTROLPARENT, c_szMediaBarClassName, NULL, 
            WS_TABSTOP | WS_VISIBLE | WS_CHILD, 
            CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
            _hwndParent, NULL, MLGetHinst(), (void *)this);
        
        if (_hwnd == NULL)
        {
            ASSERT(FALSE);
            return E_FAIL;        
        }
        else
        {
            ::ShowWindow(_hwnd, SW_SHOW);
        }
    }
    return S_OK;
}


VOID CMediaBand::Resize(HWND hwnd, LONG lWidth, LONG lHeight)
{
    if (lWidth <= 0 || lHeight <= 0)
        return;
    
    RECT rcParent; 
    if (GetClientRect(_hwnd, &rcParent))
    {
        if (IsWindowVisible(_hwndPopup))
        {
            MoveWindow(_hwndContent, rcParent.left, rcParent.top, RECTWIDTH(rcParent), RECTHEIGHT(rcParent), FALSE);
        }
        else 
        {
            LONG lPaneHeight = GetLayoutHeight();
            MoveWindow(_hwndLayout, rcParent.left, rcParent.bottom-lPaneHeight, lWidth, lPaneHeight, FALSE);
            MoveWindow(_hwndContent, rcParent.left, rcParent.top, lWidth, RECTHEIGHT(rcParent)-lPaneHeight, FALSE);
            InvalidateRect(hwnd, NULL, TRUE);
            UpdateWindow(hwnd);
        }
    }
}



// WndProc for main window to go in rebar
LRESULT CALLBACK CMediaBand::s_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMediaBand* pmb = reinterpret_cast<CMediaBand *>(GetWindowLongPtr(hWnd, GWLP_USERDATA));

    switch (msg)
    {
        case WM_ERASEBKGND:
            break;

        case WM_CREATE:
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (reinterpret_cast<LONG_PTR>((reinterpret_cast<CREATESTRUCT *>(lParam))->lpCreateParams)));
            return 0;

        case WM_SIZE:
            if (pmb)
            {
                pmb->Resize(hWnd, (LONG)LOWORD(lParam), (LONG)HIWORD(lParam));
            }                
            break;

        case WM_MB_DEFERRED_NAVIGATE:
            // navigation cancelled by IBandNavigate::ISelect() call
            if (pmb && (pmb->_strDeferredURL.Length() > 0))
            {
                pmb->NavigateContentPane(pmb->_strDeferredURL);
                pmb->_strDeferredURL.Empty();
            }
            break;

        case WM_NOTIFY:
            if (pmb)
            {
                return pmb->_OnNotify((LPNMHDR)lParam);
            }
            break;

        case WM_COMMAND:
        {
            LRESULT lres;
            if (pmb->OnWinEvent(hWnd, msg, wParam, lParam, &lres) == S_OK)
                return lres;
        }

        case WM_TIMER:
            // timeout of user's second chance to click stop again and navigate to media content pane to default URL
            if (pmb)
            {
                pmb->_CleanupStopTimer();
            }
            break;

        case WM_WTSSESSION_CHANGE:
            // stop playing media when media bar is no more in current terminal server session
            // this avoids "background noise" when user does fast user switching to other login in XP
            // NOTE: logging on as same user remotely will also stop stream
            if (pmb && ((wParam == WTS_CONSOLE_DISCONNECT) || (wParam == WTS_REMOTE_DISCONNECT)))
            {
                pmb->Exec(&CLSID_MediaBand, FCIDM_MEDIABAND_STOP, 0, NULL, NULL);
            }
            break;

        break;
    }
    return DefWindowProc(hWnd, msg, wParam, lParam);
}

LRESULT CALLBACK CMediaBand::s_PopupWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMediaBand* pmb = reinterpret_cast<CMediaBand *>(GetWindowLongPtr(hwnd, GWLP_USERDATA));

    switch (uMsg)
    {
        case WM_CREATE:
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) ((LPCREATESTRUCT)lParam)->lpCreateParams);
            break;

        case WM_ACTIVATE:
            if (pmb)
            {
                pmb->ActivatePopout(LOWORD(wParam)!=WA_INACTIVE);
            }
            return 0;

        case WM_KEYDOWN:
            if (wParam==VK_ESCAPE)
            {
                pmb->DockMediaPlayer();
            }
            break;

        case WM_GETMINMAXINFO:  // prevent it from getting too small or too large
            if (pmb)
            {
                pmb->ComputeMinMax((MINMAXINFO *)lParam);
            }
            break;

        case WM_SIZE:
            if (pmb && IsWindowVisible(hwnd))
            {
               SetWindowPos(pmb->_hwndLayout, NULL, 0, 0, LOWORD(lParam), HIWORD(lParam), SWP_NOACTIVATE);
               // MoveWindow(pmb->_hwndLayout, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
            }
            break;

        case WM_SYSCOMMAND :
            if (wParam == SC_CLOSE)
                pmb->DockMediaPlayer();
            break;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

VOID CMediaBand::ActivatePopout(BOOL fState)
{
    _fPopoutHasFocus = fState;
    UIActivateIO(fState, NULL);
}

VOID CMediaBand::ComputeMinMax(MINMAXINFO *pMinMax)
{
    pMinMax->ptMinTrackSize.x = GetMinPopoutWidth();
    if (_fIsVideo)
    {
        pMinMax->ptMinTrackSize.y = GetPopoutHeight(FALSE) + VIDEO_MIN_HEIGHT;
    }
    else
    {
        pMinMax->ptMaxTrackSize.y = pMinMax->ptMinTrackSize.y = GetPopoutHeight(FALSE);
    }
}


LRESULT CALLBACK CMediaBand::s_VolumeWndSubClassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMediaBand* pmb = (CMediaBand*)GetProp(hwnd, c_szMediaBandProp);

    if (!pmb)
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);

    WNDPROC pfnOldWndProc = (WNDPROC)(GetWindowLongPtr(hwnd, GWLP_USERDATA));

    switch (uMsg)
    {
        case WM_HSCROLL:
        case WM_VSCROLL:
        {
             INT_PTR lPos = SendMessage(hwnd, TBM_GETPOS, (WPARAM) 0 ,(LPARAM) 0); 

             switch (LOWORD(wParam))
             {
                case TB_THUMBPOSITION:
                case TB_THUMBTRACK:
                {   
                    if (pmb != NULL)
                    {
                        pmb->_dblVol = (double)lPos;
                        if (pmb->_pMediaPlayer)
                        {
                            pmb->_pMediaPlayer->put_volume(pmb->_dblVol);
                        }
                    }
                    InvalidateRect(hwnd,NULL,TRUE);
                    UpdateWindow(hwnd);
                }
                break ;

                case TB_TOP:
                {
                    if (pmb)
                    {
                        pmb->_dblVol = 0;
                        if (pmb->_pMediaPlayer)
                        {
                            pmb->_pMediaPlayer->put_volume(0);
                        }
                    }
                }
                break;

                case TB_BOTTOM:
                {
                    if (pmb)
                    {
                        pmb->_dblVol = 100;
                        if (pmb->_pMediaPlayer)
                        {
                            pmb->_pMediaPlayer->put_volume(100);
                        }
                    }
                }
                break;
            }    
        }
        break;
        
        case WM_DESTROY:
        {
            //
            // Unsubclass myself.
            //
            RemoveProp(hwnd, c_szMediaBandProp);
            if (pfnOldWndProc)
            {
                SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) pfnOldWndProc);
            }
        }
        break;
    }
    return CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, lParam);
}


LRESULT CALLBACK CMediaBand::s_SeekWndSubClassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMediaBand* pmb = (CMediaBand*)GetProp(hwnd, c_szMediaBandProp);
    
    if (!pmb)
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    
    WNDPROC pfnOldWndProc = (WNDPROC)(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    
    switch (uMsg)
    {
    case WM_ERASEBKGND:
        break;
        
    case WM_HSCROLL:
        {
            if (pmb && pmb->_pMediaPlayer && pmb->_fPlaying)
            {
                if (pmb->_pMediaPlayer->IsSeekPossible() && !pmb->_isUIDisabled())
                {
                    INT_PTR lPos = SendMessage(hwnd, TBM_GETPOS, (WPARAM) 0 ,(LPARAM) 0); 
                    switch (LOWORD(wParam))
                    {
                    case TB_THUMBPOSITION:
                        {
                            pmb->_fSeeking = FALSE;
                            pmb->Seek(lPos / 100.0);
                            if (!pmb->_fUserPaused)
                            {
                                pmb->_pMediaPlayer->Resume();
                            }
                        }
                        break;
                        
                    case TB_THUMBTRACK:
                        {   
                            pmb->_fSeeking = TRUE;
                            if (!pmb->_fUserPaused)
                            {
                                pmb->_pMediaPlayer->Pause();
                            }
                            pmb->Seek(lPos / 100.0);
                            InvalidateRect(hwnd,NULL,TRUE);
                            UpdateWindow(hwnd);
                        }
                        break;
                        
                    case TB_PAGEUP:
                    case TB_TOP:
                        {
                            double dblProgress = pmb->_pMediaPlayer->GetTrackProgress();
                            // seek backwards by 5%
                            pmb->Seek(dblProgress - 0.05);
                        }
                        break;
                        
                    case TB_PAGEDOWN:
                    case TB_BOTTOM:
                        {
                            double dblProgress = pmb->_pMediaPlayer->GetTrackProgress();
                            // seek ahead by 5%
                            pmb->Seek(dblProgress + 0.05);
                        }
                        break;
                    }
                }
                else
                {
                    // disallow seeking by setting the seek position to what it was
                    double dblProgress = pmb->_pMediaPlayer->GetTrackProgress();
                    pmb->SetSeekPos(static_cast<float>(dblProgress));
                }
            }
        }
        break;
        
    case WM_DESTROY:
        {
            //
            // Unsubclass myself.
            //
            RemoveProp(hwnd, c_szMediaBandProp);
            if (pfnOldWndProc)
            {
                SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) pfnOldWndProc);
            }
        }
        break;
    }
    return CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, lParam);
}

// sends appropriate resize messages to our children windows
VOID 
CMediaBand::_ResizeChildWindows(HWND hwnd, LONG width, LONG height, BOOL fRepaint)
{
    // Calculate the display rectangle
    RECT rc;
    SIZE sizeTB = {0}, sizePopout = {0};
    LONG lHorzSpacing   = MIN_HORZ_SPACING;
    
    _sizeLayout.cx = width;
    _sizeLayout.cy = GetLayoutHeight();

    SetRect(&rc, 0, 0, width, height); 

    LONG lWidthOffset  = rc.left+lHorzSpacing; 

    HDWP hdwp = BeginDeferWindowPos(10);

    lWidthOffset  = rc.left+lHorzSpacing; 
    if (_fIsVideo && _hwndVideo)
    {
        LONG lWidth, lHeight, lVideoStart = 0;
        
        if (_hwndPopup && IsWindowVisible(_hwndPopup))
        {
            lWidth = width-rc.left-lHorzSpacing*2;
            lHeight = GetVideoHeight();
        }
        else
        {
            lWidth = SCALEX(MIN_WINDOW_WIDTH-rc.left-lHorzSpacing*2);
            lHeight = SCALEY(MIN_WINDOW_WIDTH-rc.left);
        }
        // Resize the video and try to get the video sizes
        _ResizeVideo(&lWidth,&lHeight);

        _sizeVideo.cx  = (LONG)lWidth ;
        _sizeVideo.cy  = (LONG)lHeight ;
        
        if (lWidth >= width-rc.left-lHorzSpacing*2)
            lVideoStart = rc.left + lHorzSpacing;
        else
            lVideoStart =  (width-rc.left-lHorzSpacing*2-lWidth)/2 + rc.left + lHorzSpacing ;        

        DeferWindowPos(hdwp, _hwndVideo, HWND_TOP, (LONG)lVideoStart, rc.top+VIEW_MARGIN_TOP_VIDEO, (LONG)lWidth, (LONG)lHeight, SWP_NOZORDER);
    }
    else
    {
        _sizeVideo.cx  = 0 ;
        _sizeVideo.cy  = 0;
    }

    // Bottom-most row

    LONG lHeightOffset = height - VIEW_MARGIN_BOTTOM;  
    lWidthOffset = rc.left + VIEW_MARGIN_LEFT;

    LONG lSeekY = lHeightOffset, lSeekX = 0;
    if (_pmwPlay && _pmwPlay->_hwnd)
    {
        GetToolbarSize(_pmwPlay->_hwnd, &sizeTB);
        lSeekY = lHeightOffset-sizeTB.cy;
        DeferWindowPos(hdwp, _pmwPlay->_hwnd, HWND_TOP, lWidthOffset, lHeightOffset-sizeTB.cy, sizeTB.cx, sizeTB.cy, SWP_NOZORDER);
        lWidthOffset += sizeTB.cx;
    }

    if (_pmwStop && _pmwStop->_hwnd)
    {
        GetToolbarSize(_pmwStop->_hwnd, &sizeTB);
        DeferWindowPos(hdwp, _pmwStop->_hwnd, HWND_TOP, lWidthOffset, lHeightOffset-sizeTB.cy, sizeTB.cx, sizeTB.cy, SWP_NOZORDER);
        lWidthOffset += sizeTB.cx;
    }
    if (_pmwBack && _pmwBack->_hwnd)
    {
        GetToolbarSize(_pmwBack->_hwnd, &sizeTB);
        lSeekX = lWidthOffset;
        DeferWindowPos(hdwp, _pmwBack->_hwnd, HWND_TOP, lWidthOffset, lHeightOffset-sizeTB.cy, sizeTB.cx, sizeTB.cy, SWP_NOZORDER);
        lWidthOffset += sizeTB.cx;
    }
    if (_pmwNext && _pmwNext->_hwnd)
    {
        GetToolbarSize(_pmwNext->_hwnd, &sizeTB);
        DeferWindowPos(hdwp, _pmwNext->_hwnd, HWND_TOP, lWidthOffset, lHeightOffset-sizeTB.cy, sizeTB.cx, sizeTB.cy, SWP_NOZORDER);
        lWidthOffset += sizeTB.cx;
    }

    if (_pmwMute && _pmwMute->_hwnd)
    {
        GetToolbarSize(_pmwMute->_hwnd, &sizeTB);
        LONG lVolumeWidth = SCALEX(MIN_VOLUME_WIDTH);
        lWidthOffset = max(lWidthOffset+lHorzSpacing, (width - sizeTB.cx - lVolumeWidth - VIEW_MARGIN_RIGHT));
        DeferWindowPos(hdwp, _pmwMute->_hwnd, HWND_TOP, lWidthOffset, lHeightOffset-sizeTB.cy, sizeTB.cx, sizeTB.cy, SWP_NOZORDER);
        if (_hwndVolume)
        {
            lWidthOffset += sizeTB.cx;
            DeferWindowPos(hdwp, _hwndVolume, HWND_TOP, lWidthOffset, lHeightOffset-sizeTB.cy, lVolumeWidth, SCALEY(MIN_VOLUME_HEIGHT), SWP_NOZORDER);
        }
    }

    lWidthOffset = rc.left + lHorzSpacing;
    if (_hwndSeek)
    {
        LONG lSeekWidth = max(width-lHorzSpacing-lSeekX-2, 0);
        DeferWindowPos(hdwp, _hwndSeek, HWND_TOP, lSeekX+2, lSeekY, lSeekWidth, SCALEY(SEEK_HEIGHT), SWP_NOZORDER);
    }

    lWidthOffset = rc.left + VIEW_MARGIN_INFO_LEFT;
    if (ISVALIDWIDGET(_pmwPop))
    {
        GetToolbarSize(_pmwPop->_hwnd, &sizePopout);
        DeferWindowPos(hdwp, _pmwPop->_hwnd, HWND_TOP, width-sizePopout.cx-VIEW_MARGIN_INFO_LEFT, lSeekY-sizePopout.cy-VIEW_CONTROLS_MARGIN, sizePopout.cx, sizePopout.cy, SWP_NOZORDER);
    }

    if (ISVALIDWIDGET(_pmwOptions))
    {
        GetToolbarSize(_pmwOptions->_hwnd, &sizeTB);
        DeferWindowPos(hdwp, _pmwOptions->_hwnd, HWND_TOP, lWidthOffset, lSeekY-sizeTB.cy-VIEW_CONTROLS_MARGIN, width-lHorzSpacing*3-sizePopout.cx, sizeTB.cy, SWP_NOZORDER);
        _iOptionsWidth = width-lHorzSpacing*3-sizePopout.cx-10;
        SendMessage(_pmwOptions->_hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, _iOptionsWidth));
        SendMessage(_pmwOptions->_hwnd, TB_AUTOSIZE, 0, 0);
    }

    EndDeferWindowPos(hdwp);

    if (fRepaint)
    {
       InvalidateRect(hwnd, NULL, TRUE);
       UpdateWindow(hwnd);
    }
    else
    {
       InvalidateRect(hwnd, NULL, FALSE);
       UpdateWindow(hwnd);
    }
}

LONG CMediaBand::GetControlsHeight()
{
    LONG lHeightOffset = VIEW_MARGIN_TOP;
    // Compute height for options here
    if (ISVALIDWIDGET(_pmwOptions))
    {
        SIZE sizeTB = {0};
        GetToolbarSize(_pmwOptions->_hwnd, &sizeTB);
        lHeightOffset += SCALEY(sizeTB.cy) + VIEW_CONTROLS_MARGIN;
    }
    
    // Rest of controls
    lHeightOffset += VIEW_MARGIN_BOTTOM + SCALEY(VIEW_CONTROLS_HEIGHT);
    return lHeightOffset;
}

LONG CMediaBand::GetLayoutHeight(LONG lWidth)
{
    LONG lHeightOffset = GetControlsHeight();
    if (_hwndVideo && (IsWindowVisible(_hwndVideo) || _fIsVideo))
    {
        LONG lHeight = GetVideoHeight(lWidth);
        if (lHeight>0)
            lHeightOffset += lHeight + VIEW_MARGIN_TOP_VIDEO;
    }
    return lHeightOffset;
}

float 
CMediaBand::GetSeekPos()  
{ 
    INT_PTR lMax = SendMessage(_hwndSeek, TBM_GETRANGEMAX, 0, 0) ;
    INT_PTR lMin = SendMessage(_hwndSeek, TBM_GETRANGEMIN, 0, 0) ;
    INT_PTR lPos = SendMessage(_hwndSeek, TBM_GETPOS, 0, 0)  ;
    return ((float)lPos / (float)(lMax - lMin));
}
    
VOID 
CMediaBand::SetSeekPos(float fPosition)  
{ 
    INT_PTR lMax = SendMessage(_hwndSeek, TBM_GETRANGEMAX, 0, 0) ;
    INT_PTR lMin = SendMessage(_hwndSeek, TBM_GETRANGEMIN, 0, 0) ;
    fPosition *= (lMax - lMin) ;
    INT_PTR lPos = SendMessage(_hwndSeek, TBM_GETPOS, 0, 0)  ;
    if (lPos!=(LONG) fPosition)
    {
        SendMessage(_hwndSeek, TBM_SETPOS, TRUE, (LPARAM) (LONG) fPosition); 
        InvalidateRect(_hwndSeek, NULL,TRUE);
        UpdateWindow(_hwndSeek);
    }
}

HRESULT 
CMediaBand::_InitializeMediaUI()
{
    HRESULT hr = S_OK;

    _fHiColour = (SHGetCurColorRes() > 8);

    if (!_hwndLayout) 
    {
        CreateLayoutPane();
    }
    if (!_hwndContent)
    {
        InitContentPane();
    }

    if (!_fInitialized && _hwndLayout)
    {
        _szConnecting[0] = TEXT('\0');
        MLLoadString(IDS_MEDIABAND_NOWDOWNLOADING, _szConnecting, ARRAYSIZE(_szConnecting));

        _hbmpBackground = LoadBitmap(HINST_THISDLL, MAKEINTRESOURCE(IDB_MEDIABAND_BG_BASE));   

        CreateControls();
        CreateSeekBar();
        CreateVolumeControl();

        ResetPlayer();
        if (!_fHiColour)    
        {
            // Assume high colour. If not, switch to low colour versions.
            SwitchBitmaps(_fHiColour);
        }

        // want to sink notification when fast user switch occurs:
        WTSRegisterSessionNotification(_hwnd, NOTIFY_FOR_THIS_SESSION);

        _fInitialized = TRUE;
    }
    _ShowAllWindows(TRUE);

    return hr;
}

VOID
CMediaBand::_ShowAllWindows(BOOL fShow)
{
    if (_hwndPopup && IsWindowVisible(_hwndPopup))
    {
//        SendMessage(_hwndPopup, WM_SYSCOMMAND, (WPARAM)SC_CLOSE, (LPARAM)0);
        return;
    }
    
    if (_hwndLayout)
        ShowWindow(_hwndLayout, fShow ? SW_SHOW : SW_HIDE);

    for (int i=0; i < ARRAYSIZE(_pmw); i++)
    {
        if (ISVALIDWIDGET(_pmw[i]))
           ShowWindow(_pmw[i]->_hwnd, fShow ? SW_SHOW : SW_HIDE);
    }
    if (_hwndContent)
    {
        ShowWindow(_hwndContent, fShow ? SW_SHOW : SW_HIDE);
    }
}

VOID
CMediaBand::ToggleMute()
{
    _fMuted = !_fMuted;
    if (_pmwMute)
    {
        _pmwMute->SetState(_fMuted);
    }
    if (_pMediaPlayer)
    {
        _pMediaPlayer->put_mute(_fMuted);
    }
}

VOID 
CMediaBand::TogglePlayPause()
{
    if (!EnsurePlayer())
    {
        return;
    }

    VARIANT_BOOL vbPaused = _pMediaPlayer->isPaused();
    VARIANT_BOOL vbStopped = _pMediaPlayer->isStopped();

    // if player is in paused state, show the play button and vice-versa

    // _fPlayButton==FALSE means that the pause button is currently displayed
    // _fPlayButton==TRUE means that the play button is currently displayed

    if (vbStopped || vbPaused)
    {
        if (!_fPlayButton)
        {
            _fPlayButton = TRUE;
            if (_pmwPlay)
            {
                _pmwPlay->SetMode(MWB_NORMAL);
                _pmwPlay->SetImageSource(TRUE);
            }
        }
    }
    else
    {
        if (_fPlayButton)
        {
            _fPlayButton = FALSE;

            if (_pMediaPlayer->IsPausePossible())
            {
                // ISSUE (akabir): The following line doesn't work correctly
                // _pmwPlay->SetMode(MWB_DISABLED);
            }

            // change button bitmaps
            if (_pmwPlay)
            {
                _pmwPlay->SetImageSource(FALSE);
            }
        }
    }
}

HWND
CMediaBand::GetBrowserWindow()
{
    CComPtr<IWebBrowser2> spWebBrowser;

    // QS for the browser main window
    if (SUCCEEDED(QueryService(SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &spWebBrowser))))
    {
        LONG_PTR hwndApp;
        if (SUCCEEDED(spWebBrowser->get_HWND(&hwndApp)))
        {
            return ((HWND)hwndApp);
        }
    }
    return NULL;
}

// Called only by CMediaBand::CreateInstance
HRESULT 
CMediaBand::InitPlayerPopup()
{
    HRESULT hr = E_FAIL;

    WNDCLASS wndclass    = { 0 };
    wndclass.style         = CS_PARENTDC | CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc   = s_PopupWndProc;
    wndclass.hInstance     = HINST_THISDLL;
    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wndclass.lpszClassName = c_szMediaBarPopupClassName;
    wndclass.hIcon         = (HICON)LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(IDB_TB_MEDIA_HOT));
    wndclass.hbrBackground = NULL;
    
    SHRegisterClass(&wndclass);

    DWORD dwStyle   = (WS_OVERLAPPEDWINDOW & ~(WS_MINIMIZEBOX));
    DWORD dwExStyle =  WS_EX_CONTROLPARENT | (IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0);

    _hwndPopup = CreateWindowEx(dwExStyle, c_szMediaBarPopupClassName, NULL, dwStyle, 
                                CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT, 
                                GetBrowserWindow(), NULL, HINST_THISDLL, (void *)this);

    hr = (_hwndPopup && _hwndLayout) ? S_OK : E_FAIL;

    // modify the properties of the window as appropriate
    if (SUCCEEDED(hr))
    {
        // set parent
        SHSetParentHwnd(_hwndLayout, _hwndPopup);

        WCHAR szTitle[256];
        MLLoadStringW(IDS_MEDIABANDTEXT, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(_hwndPopup, szTitle);

        if (_sizeLayout.cx < GetMinPopoutWidth())
            _sizeLayout.cx = GetMinPopoutWidth();

        if (_fSavedPopoutState)
        {
            SetWindowPlacement(_hwndPopup, &_wpPopout);
        }
        else
        {
            RECT rc = { 0 };
            INT iHeight = GetPopoutHeight(TRUE, _sizeLayout.cx);
            INT x = 10, y = 10;
            if (GetWindowRect(_hwnd, &rc))
            {
                x = IS_WINDOW_RTL_MIRRORED(_hwnd) ? (rc.right - _sizeLayout.cx) : rc.left;
                y =  rc.bottom - iHeight;
                if (y < 0)
                {
                    y = rc.bottom;
                }
            }
            SetWindowPos(_hwndPopup, HWND_TOPMOST, x, y, _sizeLayout.cx, iHeight, SWP_FRAMECHANGED | SWP_SHOWWINDOW);
        }

        ShowWindow(_hwndPopup, SW_SHOW);
        UpdateWindow(_hwndPopup);

        if (_pmwPop && _pmwPop->_hwnd)
        {
            _pmwPop->SetImageSource(FALSE);          
            if (_iElement==MW_POP)
            {
                _fPopoutHasFocus = TRUE;
                UIActivateIO(TRUE, NULL);
            }
        }
    }
    return hr;
}

HRESULT
CMediaBand::GetTrackTitle(BSTR *pbstrTitle)
{
    USES_CONVERSION;

    CComPtr<ITIMEMediaElement> spMediaElem;
    HRESULT hr = E_FAIL;

    if (    !EnsurePlayer() 
        ||  !pbstrTitle)
    {
        hr = E_FAIL;
        goto done;
    }

    *pbstrTitle = NULL;

    //
    // if a title is available from the media element, display it
    //

    hr = _pMediaPlayer->get_mediaElement(&spMediaElem);
    if (    FAILED(hr) 
        ||  !spMediaElem.p)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = spMediaElem->get_title(pbstrTitle);
    if (SUCCEEDED(hr) &&  (*pbstrTitle != NULL))
    {
        if (SysStringLen(*pbstrTitle)>0)
        {
            goto done;
        }
        else
        {
            SysFreeString(*pbstrTitle);
            *pbstrTitle = NULL;
        }
    }

    //
    // if title is not available, display the the url 
    //

    hr = _pMediaPlayer->get_url(pbstrTitle);
    if (SUCCEEDED(hr) && *pbstrTitle && (SysStringLen(*pbstrTitle)<=0))
    {
        SysFreeString(*pbstrTitle);
        *pbstrTitle = NULL;
    }

    if (SUCCEEDED(hr) &&  (*pbstrTitle != NULL))
    {
        // If the url is available, display it

        DWORD dwcchUnescaped;
        TCHAR tszPath[MAX_PATH];

        StrCpyN(tszPath, W2T(*pbstrTitle), ARRAYSIZE(tszPath));
        PathStripPath(tszPath);

        if (SUCCEEDED(UrlUnescape(tszPath, NULL, &dwcchUnescaped, URL_UNESCAPE_INPLACE)))
        {
            SysFreeString(*pbstrTitle);
            *pbstrTitle = SysAllocString(tszPath);
        }
    }

    hr = S_OK;
done:
    return hr;
}

VOID
CMediaBand::ShowPlayingStatus(BOOL fInitial)
{
    USES_CONVERSION;

    BSTR bstrTitle = NULL;
    if (EnsurePlayer() && _fPlaying)
    {
        if (!_isUIDisabled())
        {
            GetTrackTitle(&bstrTitle);
            // Display the name of the title
            if (bstrTitle && bstrTitle[0] != 0)
                SetStatusText(W2T(bstrTitle));
        }
        else
        {
            TCHAR szText[MAX_PATH];
            szText[0] = TEXT('\0');
            MLLoadString(IDS_MEDIABAND_PLAYING, szText, ARRAYSIZE(szText));
            SetStatusText(szText);
        }

        CComPtr<ITIMEMediaElement> spMediaElem;
        HRESULT hr = _pMediaPlayer->get_mediaElement(&spMediaElem);
        ERROREXIT(hr)

        // store away the natural length of the media
        hr = spMediaElem->get_mediaDur(&_dblMediaDur);
        ERROREXIT(hr)
    }

done :
    if (bstrTitle)
        SysFreeString(bstrTitle);
}


VOID 
CMediaBand::SetStatusText(LPTSTR lpwStatusInfo)
{
    if (ISVALIDWIDGET(_pmwOptions))
    {
        // change buttons
        TBBUTTONINFO tbbi;
        TCHAR        szText[MAX_PATH];
        
        tbbi.cbSize = sizeof(tbbi);
        tbbi.dwMask = TBIF_BYINDEX | TBIF_TEXT;
        tbbi.pszText = szText ;
        tbbi.cchText = MAX_PATH ;
        SendMessage(_pmwOptions->_hwnd, TB_GETBUTTONINFO, (WPARAM)0, (LPARAM)&tbbi);

        if (StrCmpIW(tbbi.pszText,lpwStatusInfo))
        {
            tbbi.pszText = lpwStatusInfo;
            if (_pszStatus)
            {
                delete [] _pszStatus;
            }
            _pszStatus = new TCHAR[lstrlen(lpwStatusInfo)+1];
            if (_pszStatus)
            {
                StringCchCopy(_pszStatus, ARRAYSIZE(_pszStatus), lpwStatusInfo);
            }
            SendMessage(_pmwOptions->_hwnd, TB_SETBUTTONINFO, (WPARAM)0, (LPARAM)&tbbi);
            // Need to force a resizing to accommodate new text
            SendMessage(_pmwOptions->_hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, _iOptionsWidth-1));
            SendMessage(_pmwOptions->_hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, _iOptionsWidth));
        }
    }
}

HRESULT
CMediaBand::ShowPlayListMenu(HWND hwnd, RECTL* rc)
{
    if (_hPlayListMenu)
    {
        DestroyMenu(_hPlayListMenu);
        _hPlayListMenu = NULL;
    }

    _hPlayListMenu = GetSubMenu(LoadMenu(MLGetHinst(), MAKEINTRESOURCE(MENU_MEDIA_GENERIC)), 0);

    if (_EnumPlayItems() != S_OK)
    {
        DestroyMenu(_hPlayListMenu);
        _hPlayListMenu = NULL;
        return S_OK;
    }

    ASSERT(_pMediaPlayer);
    UINT nID = FCIDM_PLAYITEM_START + (UINT)_pMediaPlayer->GetPlayListItemIndex();
    CheckMenuRadioItem(_hPlayListMenu, FCIDM_PLAYITEM_START, FCIDM_PLAYITEM_END, nID, MF_BYCOMMAND);
    UpdateMenuItems(_hPlayListMenu);

    POINT pt = {rc->left ,rc->bottom};
    int idCmd = TrackPopupMenu(_hPlayListMenu, 
                                TPM_LEFTBUTTON | TPM_TOPALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                                pt.x, pt.y, 0, hwnd, NULL);

    if (idCmd>=FCIDM_PLAYITEM_START && idCmd<=FCIDM_PLAYITEM_END)                                
    {
        UINT  iCurTrack = idCmd - FCIDM_PLAYITEM_START ;
        _pMediaPlayer->SetActiveTrack(iCurTrack);
        UpdateBackForwardControls();
    }
    else
    {
        HandleMenuTasks(idCmd);
    }
    return S_OK;
}

STDMETHODIMP
CMediaBand::_EnumPlayItems()
{
    USES_CONVERSION;

    CComPtr<ITIMEMediaElement> spMediaElem;
    CComPtr<ITIMEPlayList> spPlayList;
    CComVariant svarIndex;
    long lLength = 0;
    INT i = 0;
    MENUITEMINFO mii = { sizeof(mii) };

    HRESULT hr = _pMediaPlayer->get_mediaElement(&spMediaElem);
    ERROREXIT(hr)

    hr = spMediaElem->get_playList(&spPlayList);
    ERROREXIT(hr)

    if (!(spPlayList.p))
       return S_FALSE;

    hr = spPlayList->get_length(&lLength);
    ERROREXIT(hr)

    svarIndex.vt = VT_I4;

    mii.cbSize     = sizeof(mii);
    mii.fMask      = MIIM_ID | MIIM_TYPE | MIIM_STATE;
    mii.fType      = MFT_STRING | MFT_RADIOCHECK;
    mii.fState     = MF_ENABLED;

    for (; i < lLength; i++)
    {
        CComPtr<ITIMEPlayItem> spPlayItem;
        CComBSTR sbstrTitle;
        TCHAR wszPath[40];

        V_I4(&svarIndex) = i;

        hr = spPlayList->item(svarIndex, &spPlayItem);
        ERROREXIT(hr)

        hr = spPlayItem->get_title(&sbstrTitle);
        ERROREXIT(hr)

        mii.wID        = i + FCIDM_PLAYITEM_START;
        if (sbstrTitle.Length() != 0)
        {
            StrCpyN(wszPath, sbstrTitle, ARRAYSIZE(wszPath));
        }
        else
        {
            CComBSTR sbstrSrc;   

            if (SUCCEEDED(spPlayItem->get_src(&sbstrSrc)) && sbstrSrc.Length() != 0)
            {
                PWSTR psz = PathFindFileName(sbstrSrc);
                StrCpyN(wszPath, psz, ARRAYSIZE(wszPath));
            }
            else
            {
                WCHAR szTemplate[64];
                if (!MLLoadStringW(IDS_MEDIABAND_TRACKNUMBER, szTemplate, ARRAYSIZE(szTemplate)))
                {
                    StrCpy(szTemplate, TEXT("%d"));
                }
                wnsprintf(wszPath, ARRAYSIZE(wszPath), szTemplate, i+1);
            }            
        }
        mii.dwTypeData = (LPTSTR)wszPath;
        InsertMenuItem(_hPlayListMenu, i, TRUE, &mii);
    }
    mii.fMask = MIIM_TYPE;
    mii.fType = MFT_SEPARATOR;
    InsertMenuItem(_hPlayListMenu, i, TRUE, &mii);
    hr = S_OK;
    
done:
    return hr;
}

HRESULT CMediaBand::ShowGenericMenu(HWND hwnd, RECTL* rc)
{
    HMENU hMenu = GetSubMenu(LoadMenu(MLGetHinst(), MAKEINTRESOURCE(MENU_MEDIA_GENERIC)), 0);
    if (hMenu)
    {
        UpdateMenuItems(hMenu);
        int idCmd = TrackPopupMenu(hMenu, 
                                    TPM_LEFTBUTTON | TPM_TOPALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                                    rc->left, rc->bottom, 0, hwnd, NULL);
        HandleMenuTasks(idCmd);
        DestroyMenu(hMenu);
    }

    return S_OK;
}

HRESULT CMediaBand::HandleMenuTasks(INT idCmd)
{
    switch (idCmd)
    {
    case IDM_MEDIA_PLAYINDEFAULT:
        {
            CComBSTR sbstrUrl;

            if (SUCCEEDED(_pMediaPlayer->get_url(&sbstrUrl)) && (NULL != sbstrUrl.m_str))
            {
                _OpenInDefaultPlayer(sbstrUrl);
            }
        }
        break;

    case IDM_MEDIA_ADDTOFAVORITES:
        {
            BSTR bstr = NULL, bstrTitle = NULL;
            if (EnsurePlayer() && !_isUIDisabled() && SUCCEEDED(_pMediaPlayer->get_url(&bstr)) && bstr && SUCCEEDED(GetTrackTitle(&bstrTitle)))
            {
                if (*bstr)
                {
                    AddToFavorites(bstr, bstrTitle);
                }
                SysFreeString(bstr);
            }
            break;
        }

    case IDM_MEDIA_PLAYINBAR:
        ToggleAutoplay(!GetAutoplay());
        break;

    case IDM_MEDIA_ASKTYPES:
        ToggleAutoplayPrompting(!GetAutoplayPrompt());
        break;

    case IDM_MEDIA_RESETTYPES:
        ResetMimePreferences();
        break;

    case IDM_MEDIA_TAKEOVERTYPES:
        if (PromptSettings(IDD_MEDIA_TAKEOVERMIMEPROMPT))
        {
            // do take over file types here
        }
        break;

    case IDM_MEDIA_RADIO_GOTO:
        _NavigateMainWindow(c_szRadioUrl);
        break;

    case IDM_MEDIA_BROADBAND_GUIDE:
        NavigateMoreMedia();
        break;
    }
    return S_OK;
}
    
HRESULT CMediaBand::_NavigateMainWindow(LPCTSTR wstrUrl, bool fSuppressFirstAutoPlay /* = false */) 
{
    CComPtr<IWebBrowser2> spWB2;

    // QS for the media bar
    HRESULT hr = QueryService(SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &spWB2));
    if (SUCCEEDED(hr))
    {
        CComBSTR sbstrUrl(wstrUrl);
        CComVariant svarEmpty;

        if (fSuppressFirstAutoPlay)
        {
            hr = CMediaBarHelper::DisableFirstAutoPlay(spWB2);
            if (FAILED(hr))
                goto done;
        }

        if (sbstrUrl)
        {
            hr = spWB2->Navigate(sbstrUrl, &svarEmpty, &svarEmpty, &svarEmpty, &svarEmpty);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

done:
    return hr;
}

HRESULT 
CMediaBand::ResetMimePreferences()
{
    HRESULT hr = S_OK;

    if (PromptSettings(IDD_MEDIA_RESETMIMEPROMPT))
    {
        DWORD dwRet = SHDeleteKey(HKEY_CURRENT_USER, WZ_SMIE_MEDIA_MIME);
        if (ERROR_SUCCESS != dwRet)
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

BOOL CMediaBand::PromptSettings(UINT IDPROMPT)
{
    return (DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDPROMPT), GetBrowserWindow(), s_PromptMimeDlgProc, NULL) == IDOK);
}

INT_PTR CALLBACK 
CMediaBand::s_PromptMimeDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        case WM_COMMAND:
            if (GET_WM_COMMAND_ID(wParam, lParam)==IDC_MEDIA_MOREINFO)
            {
                SHHtmlHelpOnDemandWrap(GetParent(hDlg), TEXT("iexplore.chm > iedefault"), 0, (DWORD_PTR) TEXT("mediabar_settings.htm"), ML_CROSSCODEPAGE);
            }
            else
            {
                EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            }
            break;
    }
    return FALSE;
}

HRESULT 
CMediaBand::AddToFavorites(BSTR bstrUrl, BSTR bstrTitle)
{
    HRESULT hr = E_FAIL;

    if (_hwndPopup && IsWindowVisible(_hwndPopup))
    {
        DockMediaPlayer();
    }

    if (bstrUrl)
    {
        CComPtr<IShellUIHelper> spShellUIHelper;
        
        hr = CoCreateInstance(CLSID_ShellUIHelper, NULL, CLSCTX_INPROC_SERVER,  IID_IShellUIHelper, (void**) &spShellUIHelper);
        if (SUCCEEDED(hr))
        {
            CComVariant svarTitle(bstrTitle);

            hr = spShellUIHelper->AddFavorite(bstrUrl, &svarTitle);
        }
    }
    return hr;
}

LONG
CMediaBand::GetVideoHeight(LONG lSpecifiedWidth, BOOL fNewVideo)
{
    LONG lPaneWidth = lSpecifiedWidth==0 ? SCALEX(MIN_WINDOW_WIDTH) : lSpecifiedWidth;
    LONG lWidth  = lPaneWidth-MIN_HORZ_SPACING*2,
          lHeight = lWidth; // Assumption: Video is never taller than it is wide
    
    if (_hwndPopup && IsWindowVisible(_hwndPopup))
    {
        RECT rcWindow;
        GetClientRect(_hwndPopup,&rcWindow);
        lPaneWidth = RECTWIDTH(rcWindow);
        // minimum widths as per spec

        lWidth  = lPaneWidth - MIN_HORZ_SPACING * 2;

        // Allow for controls.
        if (fNewVideo)
        {
            lHeight = lWidth;
        }
        else
        {
            lHeight = RECTHEIGHT(rcWindow)-GetControlsHeight()-VIEW_MARGIN_TOP_VIDEO;
        }
    }

    // Resize the video and get video sizes
    _ResizeVideo(&lWidth,&lHeight);

    if (lWidth != -1 || lHeight != -1)
        return (lHeight>0 ? lHeight : (lPaneWidth-MIN_HORZ_SPACING*5)) ; 
    else
        return -1;
}


VOID
CMediaBand::DockMediaPlayer()
{
    if (!_hwndPopup)
    {
        InitPlayerPopup();
    }
    else if (IsWindowVisible(_hwndPopup))
    {
        // map the system window close request into a redocking operation instead
        // of closing

        _wpPopout.length = sizeof(_wpPopout);
        _fSavedPopoutState = GetWindowPlacement(_hwndPopup, &_wpPopout);

        // set the parent back to embedded window
        SHSetParentHwnd(_hwndLayout, _hwnd);

        DestroyWindow(_hwndPopup);
        _hwndPopup = NULL;

        if (_pmwPop && _pmwPop->_hwnd)
        {
            _pmwPop->SetImageSource(TRUE);          
        }
    }

    RECT rcParent;
    GetClientRect(_hwnd, &rcParent);
    SendMessage(_hwnd, WM_SIZE, (WPARAM)0, (LPARAM)MAKELONG(RECTWIDTH(rcParent), RECTHEIGHT(rcParent)));
    InvalidateRect(_hwnd, NULL, TRUE);
    UpdateWindow(_hwnd);
}

VOID
CMediaBand::GetToolbarSize(HWND hwndTB, SIZE *pSize)
{
    int nButtons = ToolBar_ButtonCount(hwndTB);
    
    pSize->cx = 0 ;
    pSize->cy = 0 ;
    
    for (int nIndex = 0; nIndex < nButtons; nIndex++)
    {
        RECTL rc ;
        SendMessage(hwndTB, TB_GETITEMRECT, nIndex, (LPARAM)&rc);
        pSize->cx += RECTWIDTH(rc);
        pSize->cy = max(RECTHEIGHT(rc),pSize->cy);
    }
}

//+-------------------------------------------------------------------------
//  Name: Invoke, IDispatch
// 
//  Abstract:
//    This switches on the dispid looking for dispid's of events
//    that it should handle.  Note, this is called for all events
//    fired from the window, only the selected events are handled.
//--------------------------------------------------------------------------
STDMETHODIMP CMediaBand::Invoke(  /* [in] */ DISPID  dispidMember,
                                    /* [in] */ REFIID /*riid*/,
                                    /* [in] */ LCID   /*lcid*/,
                                    /* [in] */ WORD  /*wFlags*/,
                                    /* [out][in] */ DISPPARAMS* pdispparams,
                                    /* [out] */ VARIANT* pVarResult,
                                    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
                                    /* [out] */ UINT*  puArgErr)
{
    USES_CONVERSION;
    HRESULT hr = E_FAIL;
    if (!pdispparams)
        return E_INVALIDARG;

    // show our friendly 404 page on navigation error:
    if (dispidMember == DISPID_NAVIGATEERROR)
    {
        // validate expected param list
        if (   (pdispparams->cArgs != 5)
            || (pdispparams->rgvarg[4].vt != VT_DISPATCH)               // IWebBrowser2 as IDispatch
            || (pdispparams->rgvarg[3].vt != (VT_BYREF | VT_VARIANT))   // target URL as BSTR
            || (pdispparams->rgvarg[2].vt != (VT_BYREF | VT_VARIANT))   // target frame as BSTR
            || (pdispparams->rgvarg[1].vt != (VT_BYREF | VT_VARIANT))   // status code as VT_I4
            || (pdispparams->rgvarg[0].vt != (VT_BYREF | VT_BOOL)))     // Cancel as VT_BOOL, OUT param
        {
            ASSERTMSG(0, "unexpected param list for NavigateError");
            return E_INVALIDARG;
        }
        LPCTSTR pszURL = W2CT(VariantToStrCast(&pdispparams->rgvarg[3]));
        int iStatus = VariantToInt(pdispparams->rgvarg[1]);
        
        // can't navigate to page, give help page
        TCHAR szResURL[2*MAX_URL_STRING];   // expect URL to help page and original URL
        HRESULT hr;
        hr = _BuildPageURLWithParam(c_sz404URL, pszURL, szResURL, ARRAYSIZE(szResURL));
        if (FAILED(hr)) {
            return hr;
        }

        // navigate deferred, caller of this Invoke() will cancel the current navigation
        _DeferredNavigate(szResURL);

        // have our own page, cancel the std error page:
        ASSERT(pdispparams->rgvarg[0].vt == (VT_BYREF | VT_BOOL));
        *V_BOOLREF(&pdispparams->rgvarg[0]) = VARIANT_TRUE;
    }

    // just for additional leak protection: give up proxy refs if not done already
    // before we get out of current document context
    if (dispidMember == DISPID_BEFORENAVIGATE)
    {
        _DetachProxies();
    }

    return S_OK;
}


LRESULT
CMediaBand::_OnVolumeCustomDraw(LPNMCUSTOMDRAW pnm)
{
    RECT rcClient;
    GetClientRect(pnm->hdr.hwndFrom, &rcClient);

    switch (pnm->dwDrawStage) 
    {
        case CDDS_PREPAINT:
            return CDRF_NOTIFYITEMDRAW;

        case CDDS_PREERASE:
            return CDRF_NOTIFYITEMDRAW;
            
        case CDDS_ITEMPREPAINT:
        {
            HDC hdc = (HDC)pnm->hdc;
            RECT rcFill;
            SendMessage(pnm->hdr.hwndFrom, TBM_GETCHANNELRECT, (WPARAM)0, (LPARAM)(LPRECT)&rcFill);
            RECT rcThumb;
            SendMessage(pnm->hdr.hwndFrom, TBM_GETTHUMBRECT, 0L, (LPARAM)&rcThumb);

            SHFillRectClr(hdc, &rcClient, _fHiColour ? COLOR_BKGND : COLOR_BKGND16);
            UINT uFlags = ILD_TRANSPARENT | (IsOS(OS_WHISTLERORGREATER) ? ILD_DPISCALE : 0);
            if (_himlVolumeBack)
            {
                ImageList_Draw(_himlVolumeBack, 0, hdc, rcClient.left, rcClient.top, uFlags);
            }
            if (_himlVolumeFill)
            {
                ImageList_DrawEx(_himlVolumeFill, 0, hdc, rcClient.left, rcClient.top, rcThumb.left, SEEK_HEIGHT, 0, 0, uFlags);
            }
            if (_himlGripper)
            {
                ImageList_Draw(_himlGripper, 0, hdc, rcThumb.left, 0, uFlags);
            }
        }
        return CDRF_SKIPDEFAULT;
    }
    return CDRF_DODEFAULT;
}

LRESULT
CMediaBand::_OnSeekBarCustomDraw(LPNMCUSTOMDRAW pnm)
{
    RECT rcClient;
    GetClientRect(pnm->hdr.hwndFrom, &rcClient);

    switch (pnm->dwDrawStage) 
    {
        case CDDS_PREPAINT:
            return CDRF_NOTIFYITEMDRAW;

        case CDDS_PREERASE:
            return CDRF_NOTIFYITEMDRAW;
            
        case CDDS_ITEMPREPAINT:
        {
            HDC hdc = (HDC)pnm->hdc;

            SHFillRectClr(hdc, &rcClient, _fHiColour ? COLOR_BKGND2 : COLOR_BKGND16);

            RECT rcFill;
            SendMessage(pnm->hdr.hwndFrom, TBM_GETCHANNELRECT, (WPARAM)0, (LPARAM)(LPRECT)&rcFill);
            RECT rcThumb;
            SendMessage(pnm->hdr.hwndFrom, TBM_GETTHUMBRECT, 0L, (LPARAM)&rcThumb);
            int x, y = 1+(SEEK_HEIGHT-SEEK_PART_HEIGHT)/2;
            UINT uFlags = ILD_TRANSPARENT | (IsOS(OS_WHISTLERORGREATER) ? ILD_DPISCALE : 0);

            // always draw background with progress
            if (_himlSeekBack)
            {
                INT lPartWidth = SCALEX(SEEK_PART_WIDTH);
                x = rcFill.left;
                ImageList_Draw(_himlSeekBack, 0, hdc, x, y, uFlags);
                x = rcFill.right - lPartWidth;
                int inx = rcFill.left + lPartWidth;
                while (inx < x)
                {
                    ImageList_Draw(_himlSeekBack, 1, hdc, inx, y, uFlags);
                    inx += lPartWidth;
                }
                ImageList_Draw(_himlSeekBack, 2, hdc, x, y, uFlags);
            }

            if (pnm->dwItemSpec==TBCD_THUMB)
            {

                if ((!(pnm->uItemState & CDIS_DISABLED)) && ISVALIDWIDGET(_pmwSeek) && _pmwSeek->IsEnabled())
                {

                    x = rcFill.left;
                    int seekWidth = rcThumb.left-x;
                    if (_himlSeekFill && seekWidth)
                    {
                        if (seekWidth < SEEK_PART_WIDTH)
                        {
                            ImageList_DrawEx(_himlSeekFill, 0, hdc, x, y, seekWidth, SEEK_PART_HEIGHT, 0, 0, uFlags);
                        }
                        else
                        {
                            ImageList_Draw(_himlSeekFill, 0, hdc, x, y, uFlags);
                            x += SEEK_PART_WIDTH;
                            while ((rcThumb.left-x)>0)
                            {
                                ImageList_DrawEx(_himlSeekFill, 1, hdc, x, y, min(SEEK_PART_WIDTH, (rcThumb.left-x)), SEEK_PART_HEIGHT, 0, 0, uFlags);
                                x += SEEK_PART_WIDTH;
                            }
                        }
                        
                    }

                    INT iState = MWB_NORMAL;
                    if (pnm->uItemState & CDIS_SELECTED)
                    {
                        iState = MWB_PRESSED;
                    }
                    else if (pnm->uItemState & CDIS_HOT)
                    {
                        iState = MWB_HOT;
                    }
                    if (_himlGripper)
                    {
                        ImageList_Draw(_himlGripper, iState, hdc, rcThumb.left, 0, uFlags);
                    }
                }
            }
        }
        return CDRF_SKIPDEFAULT;
    }
    return CDRF_DODEFAULT;
}


LONG        
CMediaBand::GetPopoutHeight(BOOL fMeasureVideo, LONG lWidth)
{
    LONG lHeight = (fMeasureVideo ? GetLayoutHeight(lWidth) : GetControlsHeight())
                    + GetSystemMetrics(SM_CYSIZE) 
                    + GetSystemMetrics(SM_CYEDGE)*2
                    + GetSystemMetrics(SM_CYSIZEFRAME)*2;
    return lHeight;
}


LONG        
CMediaBand::GetMinPopoutWidth()
{
    return MIN_POPOUT_WIDTH + (GetSystemMetrics(SM_CXBORDER) + GetSystemMetrics(SM_CXFRAME))*2;
}


BOOL        
CMediaBand::ResetPlayer()
{
    _iCurTrack = -1;
    _fPlaying = FALSE;
    if (ISVALIDWIDGET(_pmwSeek))
    {
        _pmwSeek->SetState(FALSE);
    }
    if (_pMediaPlayer)
    {
        _pMediaPlayer->Stop();
        SetSeekPos(0.0);
        TogglePlayPause();
        if (_hwndVideo && IsWindowVisible(_hwndVideo))
        {
            _fIsVideo = FALSE;
            ShowWindow(_hwndVideo, SW_HIDE);
        }
        AdjustVideoHeight(TRUE);    
    }
    
    TCHAR szTitle[MAX_PATH];
    MLLoadStringW(IDS_MEDIABAND_MYMUSIC, szTitle, ARRAYSIZE(szTitle));
    SetStatusText(szTitle);
    
    SetPlayerControl(FCIDM_MEDIABAND_PREVIOUS, FALSE);
    SetPlayerControl(FCIDM_MEDIABAND_NEXT, FALSE);
    // while timer is running , give user a second chance to click stop again and reset media content pane
    if (_idStopTimer == 0)
    {
        SetPlayerControl(FCIDM_MEDIABAND_STOP, FALSE);
    }
    SetPlayPause(TRUE);
    return TRUE;
}

HRESULT CMediaBand::PlayLocalTrack(int iTrackNum)
{
    HRESULT hr = E_FAIL;

    if (_ppidls && (iTrackNum < (int)_cidls))
    {
        // to avoid pot. privacy leak, unload mediabar behavior
        if (_IsProxyRunning())
        {
            // user clicked on a media link in the main content pane, unfreeze controls!
            _OnUserOverrideDisableUI();
            _DetachProxies();
            _NavigateContentToDefaultURL();
        }

        TCHAR szFile[MAX_PATH];
        if (SUCCEEDED(SHGetNameAndFlags(_ppidls[iTrackNum], SHGDN_FORPARSING, szFile, ARRAYSIZE(szFile), NULL)))
        {
            _iCurTrack = iTrackNum;

            if (EnsurePlayer())
                _PutUrl(szFile, NULL);
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT CMediaBand::PlayNextTrack()
{
    if (EnsurePlayer() && (_iCurTrack != -1))
    {
        LONG_PTR lCurTrack  = _pMediaPlayer->GetPlayListItemIndex();
        LONG_PTR lItemCount = _pMediaPlayer->GetPlayListItemCount();
        if ((lItemCount <= 1) || (lCurTrack == lItemCount - 1))
        {
            PlayLocalTrack(_iCurTrack + 1);
        }
        else
        {
            ResetPlayer();
        }
    }
    return S_OK;
}

BOOL CMediaBand::SetPlayerControl(UINT ui, BOOL fState)
{
    CMediaWidget* pmw = NULL;

    switch (ui)
    {
    case FCIDM_MEDIABAND_PREVIOUS:
        // while UI frozen by mediabar behavior, previous is always disabled
        if (fState && _pMediaPlayer)
        {
            fState = _pMediaPlayer->IsSkippable();
        }
        if (_isUIDisabled())
        {
            fState = FALSE; // override to always disable
        }
        pmw = _pmwBack;
        break;

    case FCIDM_MEDIABAND_NEXT:
        // only override if any of the proxies are running
        if (fState && _pMediaPlayer)
        {
            fState = _pMediaPlayer->IsSkippable();
        }
        if (_apContentProxies != NULL)
        {
            if (_isUIDisabled() && _pMediaPlayer && !_pMediaPlayer->IsSeekPossible())
            {
                fState = FALSE;
            }
            // only force a disabled next button if stream has NOSKIP attribute set
            if (!_isProxiesNextEnabled())
            {
                fState = FALSE;
            }
        }
        pmw = _pmwNext;
        break;

    case FCIDM_MEDIABAND_STOP:
        pmw = _pmwStop;
        break;

    default:
        ASSERT(FALSE);
        break;
    }
        
    if (pmw && pmw->_hwnd)
    {
        SendMessage(pmw->_hwnd, TB_ENABLEBUTTON, ui, MAKELONG(fState, 0));
    }
    return TRUE;
}


BOOL        
CMediaBand::UpdateBackForwardControls()
{
    BOOL fPrevious = FALSE, fNext = FALSE;
    if (_iCurTrack != -1)
    {
        fPrevious = _iCurTrack != 0;
        fNext = ((_iCurTrack + 1) < (int)_cidls);
    }
    else if (EnsurePlayer())
    {
        LONG_PTR lItemCount= _pMediaPlayer->GetPlayListItemCount();
        if (lItemCount > 1)
        {
            LONG_PTR lCurTrack = _pMediaPlayer->GetPlayListItemIndex();
            fPrevious = (lCurTrack > 0);
            fNext = lCurTrack < lItemCount - 1;
        }
    }
    SetPlayerControl(FCIDM_MEDIABAND_PREVIOUS, fPrevious);
    SetPlayerControl(FCIDM_MEDIABAND_NEXT, fNext);
    return TRUE;
}

HRESULT 
CMediaBand::Seek(double dblProgress)
{
    HRESULT hr = S_OK;
    if (EnsurePlayer())
    {
        hr = _pMediaPlayer->Seek(dblProgress);
        if (SUCCEEDED(hr))
        {
            // play/pause state may have been changed by Seek
            TogglePlayPause();
        }
    }
    return hr;
}

LPTSTR 
CMediaBand::GetUrlForStatusBarToolTip()
{
    USES_CONVERSION;

    LPTSTR szRet = NULL;

    if (_pMediaPlayer)
    {
        if (_pMediaPlayer->isStopped())
        {
            return _pszStatus;       
        }

        CComBSTR sbstrUrl;

        HRESULT hr = _pMediaPlayer->get_url(&sbstrUrl);
        if (    SUCCEEDED(hr) 
            &&  (sbstrUrl.m_str) 
            &&  (sbstrUrl.Length()>0))
        {
            szRet = W2T(sbstrUrl);
            if (szRet)
            {
                //
                // The tooltip structure (NMTTDISPINFO.lpszText) requires a pointer to a private buffer.
                // Store the pointer so we can free it later.
                //

                int len = lstrlen(szRet);

                delete [] _szToolTipUrl;

                _szToolTipUrl = new TCHAR[len + 1];

                if (_szToolTipUrl)
                {
                    memcpy(_szToolTipUrl, szRet, sizeof(TCHAR) * (len + 1));
                }                

                szRet = _szToolTipUrl;
            }
        }
    }

    return szRet;
}

VOID CMediaBand::UpdateMenuItems(HMENU hmenu)
{
    ASSERT(hmenu);
    CComBSTR sbstrUrl;
    
    if (GetAutoplay())
    {
        CheckMenuItem(hmenu, IDM_MEDIA_PLAYINBAR, MF_BYCOMMAND | MF_CHECKED);
    }

    if (GetAutoplayPrompt())
    {
        CheckMenuItem(hmenu, IDM_MEDIA_ASKTYPES, MF_BYCOMMAND | MF_CHECKED);
    }

    if (!_pMediaPlayer || _pMediaPlayer->isStopped() || FAILED(_pMediaPlayer->get_url(&sbstrUrl)) || !sbstrUrl.m_str || (sbstrUrl.Length()<=0) || _isUIDisabled())
    {
        DeleteMenu(hmenu, IDM_MEDIA_PLAYINDEFAULT, MF_BYCOMMAND);
        DeleteMenu(hmenu, IDM_MEDIA_ADDTOFAVORITES, MF_BYCOMMAND);
        DeleteMenu(hmenu, 0, MF_BYPOSITION);
    }
}


BOOL CMediaBand::OnNotify(LPNMHDR pnm, LRESULT* plres)
{
    ASSERT(plres);
    BOOL fRet = FALSE;

    switch (pnm->code) 
    {
        case NM_CUSTOMDRAW:
        {
            LRESULT lres;
            LPNMCUSTOMDRAW pnmc = (LPNMCUSTOMDRAW)pnm;
            if (pnm->hwndFrom == _hwndVolume)
            {
                lres = _OnVolumeCustomDraw(pnmc);
            }
            else if (pnm->hwndFrom == _hwndSeek)
            {
                lres = _OnSeekBarCustomDraw(pnmc);                        
            }
            else 
            {
                for (int i=0; i<ARRAYSIZE(_pmw); i++)
                {
                    if (_pmw[i] && (pnm->hwndFrom == _pmw[i]->_hwnd))
                    {
                        lres = _pmw[i]->Draw((LPNMTBCUSTOMDRAW)pnm);
                    }
                }                        
            }
            
            fRet = TRUE;
            *plres = lres;
        }
        break;
        
        case TBN_DROPDOWN:
        {
            LPNMTOOLBAR lpnmTB = ((LPNMTOOLBAR)pnm);
            HWND hwndTB = pnm->hwndFrom;
            UINT nCmdID = lpnmTB->iItem;

            //  figure out coordinates to use
            INT_PTR iBtn = SendMessage(hwndTB, TB_GETHOTITEM, 0, 0);

            RECTL rc ;
            SendMessage(hwndTB, TB_GETITEMRECT, iBtn, (LPARAM)&rc);
            MapWindowPoints(hwndTB, HWND_DESKTOP, (LPPOINT)&rc , 2);

            if (_pmwOptions && hwndTB==_pmwOptions->_hwnd)
            {
                if (_pMediaPlayer && (_pMediaPlayer->GetPlayListItemCount() > 0) && !_pMediaPlayer->isStopped() && !_isUIDisabled() && _pMediaPlayer->IsSkippable())
                {
                    ShowPlayListMenu(hwndTB, &rc);
                }
                else
                {
                    ShowGenericMenu(hwndTB, &rc);
                }
            }
            else
            {
                VARIANTARG var;
                var.vt  = VT_I4;
                var.lVal = MAKELONG(rc.left, rc.bottom);
                *plres = Exec(&CLSID_MediaBand, nCmdID, 0, &var, NULL);
                fRet = TRUE;
            } // end of else
        }
        break;
        
        case TBN_GETDISPINFO:
        {
            LPNMTBDISPINFO lptbi = (LPNMTBDISPINFO)pnm;

            if (lptbi->hdr.hwndFrom == _pmwPlay->_hwnd && lptbi->dwMask & TBNF_IMAGE)
            {
                TBBUTTONINFO tbbi;
                tbbi.dwMask = TBIF_COMMAND | TBIF_STATE;
                SendMessage(lptbi->hdr.hwndFrom, TB_GETBUTTONINFO, (WPARAM)lptbi->idCommand, (LPARAM)&tbbi);

                if (_fPlayButton)
                   lptbi->iImage = (!(tbbi.fsState & TBSTATE_INDETERMINATE) && (tbbi.fsState & TBSTATE_PRESSED)) ? 3 : 1 ;
                else
                   lptbi->iImage = (!(tbbi.fsState & TBSTATE_INDETERMINATE) && (tbbi.fsState & TBSTATE_PRESSED)) ? 2 : 0 ;

                lptbi->dwMask |= TBNF_DI_SETITEM;
            }
            else if (_pmwOptions && (lptbi->hdr.hwndFrom ==_pmwOptions->_hwnd))
            {
                lptbi->iImage = 0;
                lptbi->dwMask |= TBNF_DI_SETITEM;
            }
        }
        break;

        case TTN_GETDISPINFO: 
        { 
            LPNMTTDISPINFO pnmtt = (LPNMTTDISPINFO)pnm; 
            pnmtt->hinst = MLGetHinst(); 

            switch (pnmtt->hdr.idFrom) 
            { 
                case FCIDM_MEDIABAND_POPOUT: 
                    pnmtt->lpszText = (PTSTR)MAKEINTRESOURCE(_hwndPopup ? IDS_MEDIABAND_DOCK : IDS_MEDIABAND_UNDOCK);
                    break; 

                case FCIDM_MEDIABAND_PLAY: 
                    pnmtt->lpszText = (PTSTR)MAKEINTRESOURCE(_fPlayButton ? IDS_MEDIABAND_PLAY : IDS_MEDIABAND_PAUSE);
                    break; 
                                                
                case FCIDM_MEDIABAND_MUTE: 
                    pnmtt->lpszText = (PTSTR)MAKEINTRESOURCE(_fMuted ? IDS_MEDIABAND_UNMUTE : IDS_MEDIABAND_MUTE);
                    break; 

                case FCIDM_MEDIABAND_PLAYINFO:
                {
                    if (_pMediaPlayer && !_isUIDisabled())
                    {
                        LPTSTR szUrl = GetUrlForStatusBarToolTip();
                        if (szUrl)
                        {
                            pnmtt->lpszText = szUrl;
                        }
                    }
                    break;
                }
            } 
        }
    } 

    return fRet;
}


HRESULT 
CMediaBand::_OpenInDefaultPlayer(BSTR bstrUrl)
{
    HRESULT hr = E_FAIL;

    if (    !bstrUrl 
        ||  !(*bstrUrl))
    {
        hr = E_FAIL;
        goto done;
    }

    // suppress first autoplay and navigate main IE window
    hr = _NavigateMainWindow(bstrUrl, true);    
    if (FAILED(hr))
    {
        goto done;
    }

    if (_hwndPopup && IsWindowVisible(_hwndPopup))
    {
        DockMediaPlayer();
    }
    // pause/stop the playback
    if (_pMediaPlayer->IsPausePossible())
    {
        _pMediaPlayer->Pause();
    }
    else
    {
        _pMediaPlayer->Stop();
    }

    hr = S_OK;
done:
    return hr;
}

VOID
CMediaBand::SetPlayPause(BOOL fState)
{
    _fPlayEnabled = fState;
    if (_pmwPlay && _pmwPlay->_hwnd)
    {
        SendMessage(_pmwPlay->_hwnd, TB_SETSTATE, FCIDM_MEDIABAND_PLAY, MAKELONG((_fPlayEnabled ? TBSTATE_ENABLED : 0), 0));
        InvalidateRect(_pmwPlay->_hwnd, NULL, FALSE);
        UpdateWindow(_pmwPlay->_hwnd);
    }
}

INT idNormalHi[MW_NUMBER] = 
{ 
IDB_MEDIABAND_PLAY, //    MW_PLAY = 0,
IDB_MEDIABAND_STOP, //    MW_STOP,
IDB_MEDIABAND_BACK, //    MW_BACK,
IDB_MEDIABAND_NEXT, //    MW_NEXT,
IDB_MEDIABAND_MUTE, //    MW_MUTE,
IDB_MEDIABAND_VOLBKGND, //    MW_VOLUME,
0, //    MW_OPTIONS,
IDB_MEDIABAND_POPOUT, //    MW_POP,
IDB_MEDIABAND_SEEKBACK, //    MW_SEEK,
};

INT idAltHi[MW_NUMBER] = 
{ 
IDB_MEDIABAND_PAUSE, //    MW_PLAY = 0,
0, //    MW_STOP,
0, //    MW_BACK,
0, //    MW_NEXT,
0, //    MW_MUTE,
IDB_MEDIABAND_VOLFILL, //    MW_VOLUME,
0, //    MW_OPTIONS,
IDB_MEDIABAND_POPIN, //    MW_POP,
IDB_MEDIABAND_SEEKFILL, //    MW_SEEK,
};

INT idNormalLo[MW_NUMBER] = 
{ 
IDB_MEDIABAND_PLAY16, //    MW_PLAY = 0,
IDB_MEDIABAND_STOP16, //    MW_STOP,
IDB_MEDIABAND_BACK16, //    MW_BACK,
IDB_MEDIABAND_NEXT16, //    MW_NEXT,
IDB_MEDIABAND_MUTE16, //    MW_MUTE,
IDB_MEDIABAND_VOLBKGND16, //    MW_VOLUME,
0, //    MW_OPTIONS,
IDB_MEDIABAND_POPOUT16, //    MW_POP,
IDB_MEDIABAND_SEEKBACK16, //    MW_SEEK,
};

INT idAltLo[MW_NUMBER] = 
{ 
IDB_MEDIABAND_PAUSE16, //    MW_PLAY = 0,
0, //    MW_STOP,
0, //    MW_BACK,
0, //    MW_NEXT,
0, //    MW_MUTE,
IDB_MEDIABAND_VOLFILL16, //    MW_VOLUME,
0, //    MW_OPTIONS,
IDB_MEDIABAND_POPIN16, //    MW_POP,
IDB_MEDIABAND_SEEKFILL16, //    MW_SEEK,
};

    
VOID        
CMediaBand::SwitchBitmaps(BOOL fNewSetting)
{
    INT* idAlt = fNewSetting ? idAltHi : idAltLo;
    INT* idNormal = fNewSetting ? idNormalHi : idNormalLo;

    for (int i=0; i<MW_NUMBER; i++)
    {
        if (ISVALIDWIDGET(_pmw[i]))
        {
            switch (i)
            {
            case MW_SEEK:
                DESTROY_OBJ_WITH_HANDLE(_himlSeekBack, ImageList_Destroy);
                DESTROY_OBJ_WITH_HANDLE(_himlSeekFill, ImageList_Destroy);
                _himlSeekBack = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(idNormal[i]), SEEK_PART_WIDTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);
                _himlSeekFill = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(idAlt[i]), SEEK_PART_WIDTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);

                break;

            case MW_OPTIONS:
                {
                CMediaWidgetOptions* pmwb = (CMediaWidgetOptions*)_pmw[i];
                pmwb->SetDepth(fNewSetting);
                }
                break;

            case MW_VOLUME:
                DESTROY_OBJ_WITH_HANDLE(_himlVolumeBack, ImageList_Destroy);
                DESTROY_OBJ_WITH_HANDLE(_himlVolumeFill, ImageList_Destroy);
                DESTROY_OBJ_WITH_HANDLE(_himlGripper, ImageList_Destroy);
                _himlVolumeBack = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(idNormal[i]), VOLUME_BITMAP_WIDTH, 0, crMask,
                                                     IMAGE_BITMAP, LR_CREATEDIBSECTION);
                _himlVolumeFill = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(idAlt[i]), VOLUME_BITMAP_WIDTH, 0, crMask,
                                                     IMAGE_BITMAP, LR_CREATEDIBSECTION);
                _himlGripper = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(fNewSetting ? IDB_MEDIABAND_VOLTAB : IDB_MEDIABAND_VOLTAB16), 6, 0, crMask,
                                                     IMAGE_BITMAP, LR_CREATEDIBSECTION);
                break;

            default:
                // The rest are buttons
                {
                CMediaWidgetButton* pmwb = (CMediaWidgetButton*)_pmw[i];
                pmwb->SetImageList(idNormal[i]);
                if (idAlt[i])
                {
                    pmwb->SetAlternateImageList(idAlt[i]);
                }
                }
                break;
            }
        }
    }

    _fHiColour = fNewSetting;
    InvalidateRect(_hwnd, NULL, TRUE);
    UpdateWindow(_hwnd);
}


VOID
CMediaBand::InitContentPane()
{
    SHDRC shdrc = {sizeof(SHDRC), SHDRCF_OCHOST};
    shdrc.cbSize = sizeof (SHDRC);
    shdrc.dwFlags |= SHDRCF_OCHOST;
    if (_hwnd && IsWindow(_hwnd) && DllRegisterWindowClasses(&shdrc))
    {
        // Create an OCHost window
        _hwndContent = CreateWindow(OCHOST_CLASS, NULL,
                                    WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_TABSTOP,
                                    0, 0, 0, 0,
                                    _hwnd, NULL, HINST_THISDLL, NULL);
        
        if (_hwndContent)
        {
            OCHINITSTRUCT ocs;
            ocs.cbSize = SIZEOF(OCHINITSTRUCT);   
            ocs.clsidOC  = CLSID_WebBrowser;
            ocs.punkOwner = SAFECAST(this, IDispatch*);
            
            if (SUCCEEDED(OCHost_InitOC(_hwndContent, (LPARAM)&ocs)))
            {
                OCHost_QueryInterface(_hwndContent, IID_PPV_ARG(IWebBrowser2, &_spBrowser));
                OCHost_QueryInterface(_hwndContent, IID_PPV_ARG(IOleInPlaceActiveObject, &_poipao));
                OCHost_DoVerb(_hwndContent, OLEIVERB_INPLACEACTIVATE, FALSE);
                _ConnectToCP(TRUE);
            }
            _NavigateContentToDefaultURL();
        }
    }
}

HRESULT
CMediaBand::_ConnectToCP(BOOL fConnect)
{
    // get ready to sink the OCHost's browser events
    if (!_spBrowser)
    {
        return E_FAIL;
    }
    if (!fConnect && (_dwcpCookie == 0))
    {
        return S_FALSE; //
    }
    return ConnectToConnectionPoint(SAFECAST(this, IDispatch*), DIID_DWebBrowserEvents2, fConnect, _spBrowser, &_dwcpCookie, NULL);
}

HRESULT CMediaBand::NavigateContentPane(BSTR bstrUrl)
{
    HRESULT hr = E_FAIL;
    if (_spBrowser && bstrUrl)
    {
        _strCurrentContentUrl = bstrUrl;

        CComVariant svarEmpty;
        svarEmpty.vt = VT_NULL;
        hr = _spBrowser->Navigate(bstrUrl, &svarEmpty, &svarEmpty, &svarEmpty, &svarEmpty);
    }
    return hr;
}

HRESULT CMediaBand::NavigateContentPane(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_FAIL;
    if (_spBrowser && pidl)
    {
        TCHAR szURL[MAX_URL_STRING];

        if (SUCCEEDED(::IEGetDisplayName(pidl, szURL, SHGDN_FORPARSING)))
        {
            _strCurrentContentUrl = szURL;
        }
        else
        {
            _strCurrentContentUrl.Empty();
        }

        CComVariant svarEmpty;
        svarEmpty.vt = VT_NULL;
        CComVariant varURL;
        InitVariantFromIDList(&varURL, pidl);

        hr = _spBrowser->Navigate2(&varURL, &svarEmpty, &svarEmpty, &svarEmpty, &svarEmpty);
    }
    return hr;
}


VOID CMediaBand::NavigateMoreMedia()
{
    _NavigateMainWindow(c_szMoreMediaUrl);
}

HRESULT CMediaBand::_NavigateContentToDefaultURL()
{
    TCHAR szResURL[2*MAX_URL_STRING];   // expect URL to help page and original URL
    HRESULT hr;
    LPCTSTR pszStartURL = NULL;
    
    // load inital page, this is always a local resource
    BOOL fSuppressOnline = SHRegGetBoolUSValue(REG_MEDIA_STR, TEXT("SuppressOnlineContent"), FALSE, FALSE);
    BOOL fStayOffline =    SHIsGlobalOffline()
        || fSuppressOnline 
        || SHRestricted2W(REST_No_MediaBarOnlineContent, NULL, 0);
    
    // ISSUE/010426/davidjen  with the restriction set,
    //              do we need a second offline page without external links, only MyMusic???????????????
    if (fStayOffline)
    {
        pszStartURL = c_szOfflineURL;
    }
    else
    {
        pszStartURL = c_szLoadingURL;
    }
    
    hr = _BuildPageURLWithParam(pszStartURL, NULL, szResURL, ARRAYSIZE(szResURL));
    if (FAILED(hr))
    {
        StrCpyN(szResURL, c_szOfflineURL, ARRAYSIZE(szResURL));
        hr = S_OK;
    }
    NavigateContentPane(szResURL);
    
    // if online, try navigating to windowsmedia.com
    if (!fStayOffline)
    {
        _DeferredNavigate(c_szContentUrl);
    }
    return S_OK;
}

HRESULT
CMediaBand::_BuildPageURLWithParam(LPCTSTR pszURL, LPCTSTR pszParam, OUT LPTSTR pszBuffer, UINT uiBufSize)
{
    USES_CONVERSION;
    // build a string of the form:  "res://d:\winnt\system32\browselc.dll\helppage.htm#http://www.windowsmedia.com/xyz.html"
    HRESULT hr = S_OK;

    ASSERT(pszBuffer);
    hr = MLBuildResURLWrap(TEXT("browselc.dll"), HINST_THISDLL, ML_CROSSCODEPAGE,
                           T2W((LPTSTR)pszURL), pszBuffer, uiBufSize, TEXT("browseui.dll"));
    
    if (SUCCEEDED(hr) && pszParam && (lstrlen(pszParam) > 0))
    {
        StrCatBuff(pszBuffer, TEXT("#"), uiBufSize);
        StrCatBuff(pszBuffer, pszParam, uiBufSize);
    }

    return hr;
}

BOOL CMediaBand::_DeferredNavigate(LPCTSTR pszURL)
{
    ASSERT(_strDeferredURL.Length() == 0);
    _strDeferredURL = pszURL;
    return PostMessage(_hwnd, WM_MB_DEFERRED_NAVIGATE, 0, (LPARAM) _hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\player.cpp ===
// MediaBarPlayer.cpp

#include "priv.h"

#include "dispex.h"
#include "player.h"
#include "resource.h"
#include "math.h"
#include "mediautil.h"
#include "mbBehave.h"


#define WZ_PLAY                 L"beginElement"
#define WZ_STOP                 L"endElement"
#define WZ_PAUSE                L"pauseElement"
#define WZ_RESUME               L"resumeElement"
#define WZ_URL                  L"src"
#define WZ_VOLUME               L"volume"
#define WZ_MUTE                 L"mute"
#define WZ_REGISTERED_TIME_NAME L"HTMLTIME"
#define WZ_BODY                 L"body"
#define WZ_PLAYER               L"player"
#define WZ_ONMEDIACOMPLETE      L"onmediacomplete"
#define WZ_MEDIACOMPLETE        L"mediacomplete"
#define WZ_ONMEDIAERROR         L"onmediaerror"
#define WZ_MEDIAERROR           L"mediaerror"
#define WZ_ONTRACKCHANGE       L"ontrackchange"
#define WZ_TRACKCHANGE         L"trackchange"
#define WZ_ONEND                L"onend"
#define WZ_END                  L"end"
#define WZ_PARAM                L"Param"

/////////////////////// Convenience macros ////////////////////
//
// used in QI calls, 
// e.g. IOleSite * pSite;  p->QI( IID_TO_PPV(IOleInPlaceSite, &pSite) ) 
// would cause a C2440 as _src is not really a _type **.
// Note: the riid must be the _type prepended by IID_.
//
#define IID_TO_PPV(_type,_src)      IID_##_type, \
                                    reinterpret_cast<void **>(static_cast<_type **>(_src))
// Explicit directive to ignore a return value
#define IGNORE_RETURN(_call)        static_cast<void>((_call))
#define ERROREXIT(hr) if(FAILED(hr)){hr = E_FAIL; goto done;}
#define IGNORE_HR(hr) IGNORE_RETURN(hr)
#define TIME_INFINITE HUGE_VAL

static inline double
Clamp(double min, double val, double max)
{
    if (val < min)
    {
        val = min;
    }
    else if (val > max)
    {
        val = max;
    }

    return val;
}


/****************************************************\
    FUNCTION: CMediaBarPlayer_CreateInstance

    DESCRIPTION:
        This function will create an instance of the
    MediaBarPlayer COM object.
\****************************************************/
HRESULT CMediaBarPlayer_CreateInstance(REFIID riid, void ** ppvObj)
{
    // aggregation checking is handled in class factory

    CComObject<CMediaBarPlayer> * pMediaBarPlayer = NULL;

    *ppvObj = NULL;

    HRESULT hr = CComObject<CMediaBarPlayer>::CreateInstance(&pMediaBarPlayer);
    if (FAILED(hr))
        return hr;

    hr = pMediaBarPlayer->QueryInterface(riid, ppvObj);
    if (FAILED(hr))
        delete pMediaBarPlayer;

    return hr;
}

//+-------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
CMediaBarPlayer::CMediaBarPlayer() :
    _dwDocumentEventConPtCookie(0),
    _dwCookiePropNotify(0),
    _pMediaBar(NULL),
    _hwnd(NULL)
{
}

//+-------------------------------------------------------------------------
// Destructor
//--------------------------------------------------------------------------
CMediaBarPlayer::~CMediaBarPlayer()
{
    _DestroyHost();
}

//+-------------------------------------------------------------------------
// Creates the control host
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_CreateHost(HWND hWnd)
{
    HRESULT hr = E_FAIL;
    
    if (_spBrowser.p)
    {
        hr = E_FAIL;
        goto done;
    }
    
    if (hWnd && ::IsWindow(hWnd) &&  _pMediaBar)
    {
        // Register the OCHost window class
        SHDRC shdrc = {sizeof(SHDRC), SHDRCF_OCHOST};
        shdrc.cbSize = sizeof (SHDRC);
        shdrc.dwFlags |= SHDRCF_OCHOST;
        if (DllRegisterWindowClasses(&shdrc))
        {
            // Create an OCHost window
            _hwnd = CreateWindow(OCHOST_CLASS, NULL,
                (WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS) & ~(WS_HSCROLL|WS_VSCROLL),
                0, 0, 0, 0,
                hWnd, NULL, HINST_THISDLL, NULL);
            
            if (_hwnd)
            {
                OCHINITSTRUCT ocs;
                ocs.cbSize = SIZEOF(OCHINITSTRUCT);   
                ocs.clsidOC  = CLSID_WebBrowser;
                ocs.punkOwner = SAFECAST(_pMediaBar, IUnknown*);
                
                hr = OCHost_InitOC(_hwnd, (LPARAM)&ocs);
                ERROREXIT(hr)
                
                OCHost_QueryInterface(_hwnd, IID_PPV_ARG(IWebBrowser2, &_spBrowser));
                OCHost_DoVerb(_hwnd, OLEIVERB_INPLACEACTIVATE, FALSE);
            }
        }
    }

    if (!_spBrowser.p)
    {
        hr = E_FAIL;
        goto done;
    }

    // navigate to the page containing the player
    {
        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);

        // generate the url for the HTML resource containing the player
        CComBSTR sbstrURL(OLESTR("res://"));
        sbstrURL.Append(szModule);
        sbstrURL.Append(OLESTR("/"));
        TCHAR szResID[11];
        wnsprintf(szResID, _MAX_PATH, _T("%d"), IDH_PLAYER);
        sbstrURL.Append(szResID);

        hr = _Navigate(sbstrURL.m_str);
        ERROREXIT(hr)
    }
  
    // listen to events
    hr = _InitEventSink();
    ERROREXIT(hr)
        
    hr = S_OK;
done:
    if (FAILED(hr))
    {
        _DestroyHost();
    }
    
    return hr;
}


STDMETHODIMP
CMediaBarPlayer::_Navigate(BSTR bstrUrl)
{
    HRESULT hr = E_FAIL;
    CComVariant svarEmpty;
    
    if (!bstrUrl || !_spBrowser.p)
    {
        hr = E_FAIL;
        goto done;
    }
   
    hr = _spBrowser->Navigate(bstrUrl, &svarEmpty, &svarEmpty, &svarEmpty, &svarEmpty);
    ERROREXIT(hr)
 
    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Destroys the control host
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_DestroyHost()
{
    _AttachPlayerEvents(FALSE);

    _UnhookPropNotifies();

    _DeInitEventSink();

    if (_spMediaElem.p)
    {
        _spMediaElem.Release();
    }

    if (_spMediaElem2.p)
    {
        _spMediaElem2.Release();
    }

    if (_spPlayerHTMLElem2.p)
    {
        _spPlayerHTMLElem2.Release();
    }

    if (_spBodyElem.p)
    {
        _spBodyElem.Release();
    }

    if (_spBrowser.p)
    {
        _spBrowser.Release();
    }

    if (_hwnd && ::IsWindow(_hwnd))
    {
        ::DestroyWindow(_hwnd);
        _hwnd = NULL;
    }

    return S_OK;
}


STDMETHODIMP
CMediaBarPlayer::GetVideoHwnd(HWND * pHwnd)
{
    if (pHwnd)
        *pHwnd = _hwnd;

    return S_OK;
}

static const PWSTR ppszInterestingEvents[] = 
{ 
    WZ_ONMEDIACOMPLETE,
    WZ_ONMEDIAERROR,
    WZ_ONEND,
    WZ_ONTRACKCHANGE    
};

//+-------------------------------------------------------------------------
// Attaches to player events
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_AttachPlayerEvents(BOOL fAttach)
{
    HRESULT hr = E_FAIL;

    CComPtr<IDispatchEx> spDispEx;
    CComPtr<IHTMLElement2> spElem2;

    hr = _GetElementDispatch(WZ_PLAYER, &spDispEx);
    ERROREXIT(hr)

    hr = spDispEx->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElem2));
    ERROREXIT(hr)
    
    hr = S_OK;
    for (DWORD i = 0; i < ARRAYSIZE(ppszInterestingEvents); i++)
    {
        if (fAttach)
        {
            VARIANT_BOOL bSuccess = FALSE;
            // Try to attach all events. We don't care if they fail
            if (FAILED(spElem2->attachEvent(ppszInterestingEvents[i], static_cast<IDispatch*>(this), &bSuccess)))
            {
                hr = S_FALSE;
            }
        }
        else
        {
            // Try to detact all events. We don't care if they fail
            hr = spElem2->detachEvent(ppszInterestingEvents[i], static_cast<IDispatch*>(this));
        }
    }


done:
    return hr;
}


//+-------------------------------------------------------------------------
// Hooks property change notifications
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_HookPropNotifies()
{
    HRESULT hr = E_FAIL;
    CComPtr<ITIMEState> spTimeState;
    CComPtr<IConnectionPointContainer> spConPtCont;

    if (!_spMediaElem || _spPropNotifyCP.p || _dwCookiePropNotify)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = _spMediaElem->get_currTimeState(&spTimeState);
    ERROREXIT(hr)

    hr = spTimeState->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &spConPtCont));
    ERROREXIT(hr)

    hr = spConPtCont->FindConnectionPoint(IID_IPropertyNotifySink, &_spPropNotifyCP);
    ERROREXIT(hr)

    hr = _spPropNotifyCP->Advise(static_cast<IUnknown*>(static_cast<IDispatch*>(this)), &_dwCookiePropNotify);
    ERROREXIT(hr)
    
    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Unhooks property change notifications
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_UnhookPropNotifies()
{
    if (_spPropNotifyCP.p)
    {
        if (_dwCookiePropNotify != 0)
        {
            IGNORE_HR(_spPropNotifyCP->Unadvise(_dwCookiePropNotify));
        }
        _spPropNotifyCP.Release();
    }
    _dwCookiePropNotify = 0;

    return S_OK;
}


//+-------------------------------------------------------------------------
// Invokes a method on the given element
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_InvokeDocument(LPWSTR pstrElem, INVOKETYPE it, LPWSTR pstrName, VARIANT * pvarArg)
{
    HRESULT hr = E_FAIL;
    DISPPARAMS dispparams = {NULL, NULL, 0, 0};
    CComPtr<IDispatchEx> spDispEx;
    CComBSTR sbstrName; 
    DISPID dispid = 0;
    DISPID dispidProp = 0;

    sbstrName.m_str = SysAllocString(pstrName);
    if (!sbstrName.m_str)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = _GetElementDispatch(pstrElem, &spDispEx);
    ERROREXIT(hr)

    hr = spDispEx->GetDispID(sbstrName, fdexNameEnsure, &dispid);
    ERROREXIT(hr)

    switch (it)
    {
        case IT_METHOD:
        {
            dispparams.rgvarg = pvarArg;
            dispparams.cArgs = (pvarArg ? 1 : 0);

            hr = spDispEx->InvokeEx(dispid, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, NULL, NULL, NULL);
            ERROREXIT(hr)
        }
        break;
    
        case IT_PUT:
        {
            dispidProp = DISPID_PROPERTYPUT;

            if (!pvarArg)
            {
                hr = E_INVALIDARG;
                goto done;
            }

            dispparams.rgvarg = pvarArg;
            dispparams.rgdispidNamedArgs = &dispidProp;
            dispparams.cArgs = 1;
            dispparams.cNamedArgs = 1;

            hr = spDispEx->InvokeEx(dispid, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT, &dispparams, NULL, NULL, NULL);
            ERROREXIT(hr)
        }
        break;
    
        case IT_GET:
        {
            if (!pvarArg)
            {
                hr = E_INVALIDARG;
                goto done;
            }

            hr = spDispEx->InvokeEx(dispid, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, &dispparams, pvarArg, NULL, NULL);
            ERROREXIT(hr)
        }
        break;
    }

    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Gets the dispatch ptr of the document 
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_GetDocumentDispatch(IDispatch ** ppDocDisp)
{
    HRESULT hr = E_FAIL;

    if (!ppDocDisp)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (!_spBrowser)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = _spBrowser->get_Document(ppDocDisp);
    ERROREXIT(hr)

    hr = S_OK;
done:
    return hr;
}

//+-------------------------------------------------------------------------
// Gets the ITIMEBodyElement interface
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_GetBodyElement(ITIMEBodyElement ** ppBodyElem)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;

    if (!ppBodyElem)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = _InvokeDocument(WZ_BODY, IT_GET, WZ_REGISTERED_TIME_NAME, &svarArg);
    ERROREXIT(hr)

    hr = ::VariantChangeType(&svarArg, &svarArg, NULL, VT_DISPATCH);
    ERROREXIT(hr)

    if (NULL == V_DISPATCH(&svarArg))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = V_DISPATCH(&svarArg)->QueryInterface(IID_TO_PPV(ITIMEBodyElement, ppBodyElem));
    ERROREXIT(hr)

    ASSERT(ppBodyElem);

    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Gets the ITIMEMediaElement interface
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_GetMediaElement(ITIMEMediaElement ** ppMediaElem)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;

    if (!ppMediaElem)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = _InvokeDocument(WZ_PLAYER, IT_GET, WZ_REGISTERED_TIME_NAME, &svarArg);
    ERROREXIT(hr)

    hr = ::VariantChangeType(&svarArg, &svarArg, NULL, VT_DISPATCH);
    ERROREXIT(hr)

    if (NULL == V_DISPATCH(&svarArg))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = V_DISPATCH(&svarArg)->QueryInterface(IID_TO_PPV(ITIMEMediaElement, ppMediaElem));
    ERROREXIT(hr)

    ASSERT(ppMediaElem);

    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Gets the IDispatchEx pointer of the named element
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_GetElementDispatch(LPWSTR pstrElem, IDispatchEx ** ppDispEx)
{
    HRESULT hr = E_FAIL;
    CComPtr<IDispatch> spElemDisp;
    CComPtr<IDispatch> spDocDisp;
    CComPtr<IHTMLDocument2> spDoc2;
    CComPtr<IHTMLElementCollection> spAll;
    CComVariant svarName;
    CComVariant svarIndex;

    if (!ppDispEx || !pstrElem)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    V_VT(&svarName) = VT_BSTR;
    V_BSTR(&svarName) = SysAllocString(pstrElem);

    if (NULL == V_BSTR(&svarName))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    V_VT(&svarIndex) = VT_I4;
    V_I4(&svarIndex) = 0;

    hr = _GetDocumentDispatch(&spDocDisp);
    ERROREXIT(hr)

    // WebOC returns S_OK even if doc disp is not available
    if (!spDocDisp.p)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = spDocDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &spDoc2));
    ERROREXIT(hr)

    hr = spDoc2->get_all(&spAll);
    ERROREXIT(hr)

    hr = spAll->item(svarName, svarIndex, &spElemDisp);
    ERROREXIT(hr)

    if (spElemDisp.p)
    {
        hr = spElemDisp->QueryInterface(IID_TO_PPV(IDispatchEx, ppDispEx));
        ERROREXIT(hr)
    }
    else
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Stuff to be done when document is loaded
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_OnDocumentComplete()
{
    HRESULT hr = E_FAIL;

    // store off a pointer to the media element behavior
    hr = _GetMediaElement(&_spMediaElem);
    ERROREXIT(hr)

    hr = _spMediaElem->QueryInterface(IID_TO_PPV(ITIMEMediaElement2, &_spMediaElem2));
    ERROREXIT(hr)

    // store off a pointer to the player's HTML element
    {
        CComPtr<IDispatchEx> spPlayerDisp;

        hr = _GetElementDispatch(WZ_PLAYER, &spPlayerDisp);
        ERROREXIT(hr)

        if (!spPlayerDisp.p)
        {
            hr = E_FAIL;
            goto done;
        }

        hr = spPlayerDisp->QueryInterface(IID_TO_PPV(IHTMLElement2, &_spPlayerHTMLElem2)); 
        ERROREXIT(hr)
    }

    // store off a pointer to the body element
    hr = _GetBodyElement(&_spBodyElem);
    ERROREXIT(hr)

    // Attach to player events
    hr = _AttachPlayerEvents(TRUE);
    ERROREXIT(hr)

    // Hook Property notifications
    hr = _HookPropNotifies();
    ERROREXIT(hr)

    // set the type if deferred
    if (_sbstrType.m_str)
    {
        hr = put_type(_sbstrType);
        _sbstrType.Empty();
        ERROREXIT(hr)
    }

    // set the url if deferred
    if (_sbstrUrl.m_str)
    {
        hr = put_url(_sbstrUrl);
        _sbstrUrl.Empty();
        ERROREXIT(hr)
    }

    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Stuff to be done when Media is ready
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_OnMediaComplete()
{
    // notify the media bar
    if (_pMediaBar)
    {
        _pMediaBar->Notify(MEDIACOMPLETE);
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Stuff to be done when Media is ready
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_OnTrackChange()
{
    // notify the media bar
    if (_pMediaBar)
    {
        _pMediaBar->Notify(TRACK_CHANGE);
    }

    return S_OK;
}



//+-------------------------------------------------------------------------
// Stuff to be done when track is finished
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_OnEnd()
{
    // notify the media bar
    if (_pMediaBar)
    {
        _pMediaBar->Notify(MEDIA_TRACK_FINISHED);
    }
    return S_OK;
}


//+-------------------------------------------------------------------------
// notification that there was some error playing the Media stream
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_OnMediaError(int iErrCode)
{
    CComPtr<IDispatch> spWMP;
    if (_spMediaElem && SUCCEEDED(_spMediaElem->get_playerObject(&spWMP)))
    {
        VARIANT varError;
        if (SUCCEEDED(GetProp(spWMP, L"error", &varError)))
        {
            CallMethod(varError.pdispVal, L"webHelp");
        }
        VariantClear(&varError);
    }
    // notify the media bar
    if (_pMediaBar)
    {
        _pMediaBar->OnMediaError(iErrCode);
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Handle property change notifications
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::OnChanged(DISPID dispid)
{
    // notify the media bar
    if (_pMediaBar)
    {
        _pMediaBar->Notify(dispid);
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////
//
// IMediaBarPlayer
//
////////////////////////////////////////////////////////////////////////////



//+-------------------------------------------------------------------------
// Init the player 
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Init(HWND hWnd, IMediaBar * pMediaBar)
{
    HRESULT hr = E_FAIL;

    if (!pMediaBar)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // store a weak ref to prevent circular reference
    _pMediaBar = pMediaBar;

    hr = _CreateHost(hWnd);
    ERROREXIT(hr)

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        DeInit();
    }

    return hr;
}

//+-------------------------------------------------------------------------
// DeInit the player 
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::DeInit()
{
    _pMediaBar = NULL;

    return _DestroyHost();
}

//+-------------------------------------------------------------------------
// sets the media clip type
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::put_type(BSTR bstrType)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;
    CComVariant svarEmpty;

    svarArg.vt = VT_NULL;
    svarEmpty.vt = VT_NULL;

    if (!IsReady())
    {
        _sbstrType.m_str = ::SysAllocString(bstrType);
        if (bstrType && !_sbstrType)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = S_OK;
        }
        goto done;
    }

    if (bstrType)
    {
        V_VT(&svarArg) = VT_BSTR;
        V_BSTR(&svarArg) = SysAllocString(bstrType);
        if (NULL == V_BSTR(&svarArg))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    // always stop the player
    hr = _spMediaElem->endElement();
    ERROREXIT(hr)

    hr = _spMediaElem->put_src(svarEmpty);
    ERROREXIT(hr)

    hr = _spMediaElem->put_type(svarArg);
    ERROREXIT(hr)

    hr = S_OK;
done:
    return hr;
}

//+-------------------------------------------------------------------------
// sets the media clip url 
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::put_url(BSTR bstrUrl)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;
    CComVariant svarEmpty;

    svarArg.vt = VT_NULL;
    svarEmpty.vt = VT_NULL;

    if (!IsReady())
    {
        _sbstrUrl.m_str = ::SysAllocString(bstrUrl);
        if (bstrUrl && !_sbstrUrl)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = S_OK;
        }
        goto done;
    }

    if (bstrUrl)
    {
        V_VT(&svarArg) = VT_BSTR;
        V_BSTR(&svarArg) = SysAllocString(bstrUrl);
        if (NULL == V_BSTR(&svarArg))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    // always stop the player
    hr = _spMediaElem->endElement();
    ERROREXIT(hr)

    hr = _spMediaElem->put_src(svarArg);
    ERROREXIT(hr)

    // always start the player
    hr = _spMediaElem->beginElement();
    ERROREXIT(hr)

    hr = S_OK;
done:
    return hr;
}

//+-------------------------------------------------------------------------
// gets the media clip url
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::get_url(BSTR * pbstrUrl)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;

    if (!pbstrUrl || !IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    *pbstrUrl = NULL;

    hr = _spMediaElem->get_src(&svarArg);
    ERROREXIT(hr)

    hr = svarArg.ChangeType(VT_BSTR);
    ERROREXIT(hr)

    if (svarArg.bstrVal)
    {
        *pbstrUrl = SysAllocString(svarArg.bstrVal);
        if (NULL == *pbstrUrl)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// gets the player attribute
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::get_player(BSTR * pbstrPlayer)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;

    if (!pbstrPlayer || !IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    *pbstrPlayer = NULL;

    hr = _spMediaElem->get_player(&svarArg);
    ERROREXIT(hr)

    hr = svarArg.ChangeType(VT_BSTR);
    ERROREXIT(hr)

    if (svarArg.bstrVal)
    {
        *pbstrPlayer = SysAllocString(svarArg.bstrVal);
        if (NULL == *pbstrPlayer)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

//+-------------------------------------------------------------------------
// sets the volume
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::put_volume(double dblVolume)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;
    
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    V_VT(&svarArg) = VT_R8;
    V_R8(&svarArg) = dblVolume;

    hr = _spMediaElem->put_volume(svarArg);
    ERROREXIT(hr)

    hr = S_OK;
done:
    return hr;
}

//+-------------------------------------------------------------------------
// gets the volume
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::get_volume(double * pdblVolume)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
// gets the media element pointer
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::get_mediaElement(ITIMEMediaElement ** ppMediaElem)
{
    if (!ppMediaElem || !_spMediaElem)
    {
        return E_FAIL;
    }

    *ppMediaElem = _spMediaElem;
    (_spMediaElem.p)->AddRef();

    return S_OK;
}


//+-------------------------------------------------------------------------
// sets the mute
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::put_mute(BOOL bMute)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    V_VT(&svarArg) = VT_BOOL;
    V_BOOL(&svarArg) = bMute ? VARIANT_TRUE : VARIANT_FALSE;

    hr = _spMediaElem->put_mute(svarArg);
    ERROREXIT(hr)

    hr = S_OK;
done:
    return hr;
}

//+-------------------------------------------------------------------------
// gets the mute
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::get_mute(BOOL * pbMute)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
// plays the media
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Play()
{
    if (!IsReady())
        return E_FAIL;

    return _spMediaElem->beginElement();
}


//+-------------------------------------------------------------------------
// stops the media
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Stop()
{
    if (!IsReady())
        return E_FAIL;

    return _spMediaElem->endElement();
}


//+-------------------------------------------------------------------------
// pauses the media
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Pause()
{
    if (!IsReady())
        return E_FAIL;

    return _spMediaElem->pauseElement();
}

//+-------------------------------------------------------------------------
// resumes the media
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Resume()
{
    if (!IsReady())
        return E_FAIL;

    return _spMediaElem->resumeElement();
}


//+-------------------------------------------------------------------------
// seeks the media to the given progress
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Seek(double dblProgress)
{
    HRESULT hr = E_FAIL;
    CComPtr<ITIMEState> spTimeState;
    double dblActiveDur = 0.0;
    double dblSeekTime = 0.0;
    VARIANT_BOOL vbActive = VARIANT_FALSE;

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    if (!IsPlayList())
    {
        hr = _spMediaElem->get_currTimeState(&spTimeState);
        ERROREXIT(hr)

        hr = spTimeState->get_activeDur(&dblActiveDur);
        ERROREXIT(hr)

        hr = spTimeState->get_isActive(&vbActive);
        ERROREXIT(hr)

        // ISSUE: workaround for IE6 #20622
        // if the clip has ended, reactivate it in the paused state
        if (VARIANT_FALSE == vbActive)
        {
            _spMediaElem->beginElement();
            _spMediaElem->pauseElement();
        }

        if (TIME_INFINITE == dblActiveDur)
        {
            // we shouldn't be allowed to seek
            goto done;
        }
        else
        {
            Clamp(0.0, dblProgress, 1.0);
            dblSeekTime = dblActiveDur *  dblProgress;
        }

        // seek the body
        hr = _spMediaElem->seekActiveTime(dblSeekTime);
        ERROREXIT(hr)

        hr = S_OK;
    }
    else
    {
        CComPtr<ITIMEPlayList> spPlayList;
        CComPtr<ITIMEPlayItem> spPlayItem;
        CComPtr<ITIMEMediaNative> spMediaNative;

        hr = _spMediaElem->get_playList(&spPlayList);
        if (SUCCEEDED(hr) && spPlayList)
        {
            hr = spPlayList->get_activeTrack(&spPlayItem);
            if (SUCCEEDED(hr) && spPlayItem)
            {
                spPlayItem->get_dur(&dblActiveDur);
                dblSeekTime = dblActiveDur * dblProgress;

                hr = _spMediaElem->QueryInterface(IID_TO_PPV(ITIMEMediaNative, &spMediaNative));
                if (SUCCEEDED(hr) && spMediaNative)
                {
                    spMediaNative->seekActiveTrack(dblSeekTime);
                }
            }
        }
    }

done:
    return hr;
}

//+-------------------------------------------------------------------------
// Resize the video to fit in the given window size, preserving aspect ratio 
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Resize(LONG* plHeight, LONG* plWidth, BOOL fClampMaxSizeToNaturalSize)
{
    HRESULT hr = E_FAIL;
    long lMediaWidth = 0;
    long lMediaHeight = 0;
    long lResizeWidth = 0;
    long lResizeHeight = 0;
    float flWndAspect = 0.0f; 
    float flMediaAspect = 0.0f; 

    if (!IsReady() || !plHeight || !plWidth || (0 == (*plHeight)) || (0 == (*plWidth)))
    {
        goto done;
    }

    hr = _spMediaElem->get_mediaWidth(&lMediaWidth);
    ERROREXIT(hr)

    hr = _spMediaElem->get_mediaHeight(&lMediaHeight);
    ERROREXIT(hr)

    // do resize only if both dimensions are non-zero
    if (0 != lMediaWidth &&  0 != lMediaHeight)
    {
        // if natural media size <= window size and max size is clamped to natural media size
        if (    fClampMaxSizeToNaturalSize
            &&  lMediaWidth <= (*plWidth) 
            &&  lMediaHeight <= (*plHeight))
        {
            // set the media back to it's natural size
            lResizeHeight = lMediaHeight;
            lResizeWidth = lMediaWidth;
        }
        else        
        {
            // resize the media to the window size

            flWndAspect = (float) (*plHeight) / (float) (*plWidth); 
            flMediaAspect = (float) lMediaHeight / (float) lMediaWidth; 

            if (flMediaAspect <= flWndAspect)
            {
                // set width to window width and compute the height according to aspect ratio
                lResizeWidth = (long)(*plWidth);
                lResizeHeight = (long)(lResizeWidth * flMediaAspect);
            }
            else
            {
                // set height to window height and compute the width according to aspect ratio
                lResizeHeight = (long)(*plHeight);
                lResizeWidth = (long)(lResizeHeight / flMediaAspect);
            }
        }

        // set the resized height and width on the HTML element
        {
            CComPtr<IHTMLStyle> spStyle;
            CComPtr<IHTMLElement2> spHTMLElem;

            hr = _spPlayerHTMLElem2->QueryInterface(IID_PPV_ARG(IHTMLElement2, &spHTMLElem));
            ERROREXIT(hr)

            // Using runtimeStyle instead of style. 
            // (Previously, we did the reverse as a work around for IE6 #20625. But now style is broken.)
            hr = spHTMLElem->get_runtimeStyle(&spStyle);
            ERROREXIT(hr)

            hr = spStyle->put_pixelWidth(lResizeWidth);
            ERROREXIT(hr)

            hr = spStyle->put_pixelHeight(lResizeHeight);
            ERROREXIT(hr)
        }
    }

    *plWidth  = lResizeWidth ;
    *plHeight = lResizeHeight;
    
    hr = S_OK;
    
done:
    return hr;
}


////////////////////////////////////////////////////////////////////////////
//
// IDispatch
//
////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//  Name: Invoke
// 
//  Abstract:
//    This switches on the dispid looking for dispid's of events
//    that it should handle.  Note, this is called for all events
//    fired from the window, only the selected events are handled.
//--------------------------------------------------------------------------
STDMETHODIMP CMediaBarPlayer::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pVarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    HRESULT hr = E_FAIL;

    switch (dispIdMember)
    {
    case 0: //this is the case for events that have been hooked using attachEvent
        {
            CComBSTR sbstrEvent;
            CComPtr <IHTMLEventObj> pEventObj;
            
            if ((NULL != pDispParams) && (NULL != pDispParams->rgvarg) &&
                (V_VT(&(pDispParams->rgvarg[0])) == VT_DISPATCH))
            {
                hr = THR((pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj));
                if (FAILED(hr))
                {
                    goto done;
                }
            }
            else
            {
                ASSERT(0 && "Unexpected dispparam values passed to CEventMgr::Invoke(dispid = 0)");
                hr = E_UNEXPECTED;
                goto done;
            }
            
            hr = THR(pEventObj->get_type(&sbstrEvent));
            
            if (0 == StrCmpIW(WZ_TRACKCHANGE, sbstrEvent))
            {
                _OnTrackChange();
            }
            if (0 == StrCmpIW(WZ_MEDIACOMPLETE, sbstrEvent))
            {
                _OnMediaComplete();
            }
            else if (0 == StrCmpIW(WZ_MEDIAERROR, sbstrEvent))
            {

                int iErrCode = -1;

                // Get the param if available
                CComPtr<IHTMLEventObj2> spEventObj2;
                CComVariant svarParam;
                CComBSTR sbstrParam(WZ_PARAM);

                hr = pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**) &spEventObj2);
                if (SUCCEEDED(hr) && sbstrParam.m_str)
                {
                    // get the params
                    hr = spEventObj2->getAttribute(sbstrParam, 0, &svarParam);
                    if (SUCCEEDED(hr))
                    {
                        // change type to int
                        hr = svarParam.ChangeType(VT_I4);
                        if (SUCCEEDED(hr))
                        {
                            iErrCode = V_I4(&svarParam);
                        }
                    }
                }
                _OnMediaError(iErrCode);
            }
            else if (0 == StrCmpIW(WZ_END, sbstrEvent))
            {
                _OnEnd();
            }
        }
        break;
        
    case 259: // DISPID_DOCUMENTCOMPLETE
        {
            hr = _OnDocumentComplete();
            ERROREXIT(hr)
        }
        break;
    }

    hr = S_OK;
  done:
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: _InitEventSink
// 
//  Abstract:
//    Finds a connection point on the HTMLDocument interface
//    and passes this as an event handler.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CMediaBarPlayer::_InitEventSink()
{
    // Get a connection point to the container
    CComPtr<IConnectionPointContainer> spDocCPC; 

    HRESULT hr = E_FAIL;

    hr = _spBrowser->QueryInterface(IID_IConnectionPointContainer, (void**)&spDocCPC);
    ERROREXIT(hr)

    hr = THR(spDocCPC->FindConnectionPoint(DIID_DWebBrowserEvents2, &_spDocConPt ));
    ERROREXIT(hr)
    
    hr = THR(_spDocConPt->Advise(static_cast<IUnknown*>(static_cast<DWebBrowserEvents2*>(this)), &_dwDocumentEventConPtCookie));
    ERROREXIT(hr)

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        _DeInitEventSink();
    }
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: _DeInitEventSink
// 
///////////////////////////////////////////////////////////////
STDMETHODIMP
CMediaBarPlayer::_DeInitEventSink()
{
    //release the document connection points
    if (_spDocConPt)
    {
        if (_dwDocumentEventConPtCookie != 0)
        {
            IGNORE_HR(_spDocConPt->Unadvise(_dwDocumentEventConPtCookie));
        }
        _spDocConPt.Release();
    }
    _dwDocumentEventConPtCookie = 0;

    return S_OK;
}


double 
STDMETHODCALLTYPE 
CMediaBarPlayer::GetTrackProgress()
{
    if (IsReady())
    {
        if (!IsPlayList())
        {
            CComPtr<ITIMEState> spTimeState;
            if (SUCCEEDED(_spMediaElem->get_currTimeState(&spTimeState)) && spTimeState)
            {
                double dblProgress  = 0.0;
                if (SUCCEEDED(spTimeState->get_progress(&dblProgress)))
                {
                    return dblProgress;
                }                                    
            }
        }
        else
        {
            CComPtr<ITIMEMediaNative> spMediaNative;
            double dblProgress, dblActiveDur;
            CComPtr<ITIMEPlayList> spPlayList;
            CComPtr<ITIMEPlayItem> spPlayItem;

            if (SUCCEEDED(_spMediaElem->get_playList(&spPlayList)) && spPlayList)
            {
                if (SUCCEEDED(spPlayList->get_activeTrack(&spPlayItem)) && spPlayItem)
                {
                    spPlayItem->get_dur(&dblActiveDur);
                    if (SUCCEEDED(_spMediaElem->QueryInterface(IID_TO_PPV(ITIMEMediaNative, &spMediaNative))) && spMediaNative)
                    {
                        spMediaNative->get_activeTrackTime(&dblProgress);
                        return dblProgress / dblActiveDur;
                    }
                }
            }
        }
    }
    return 0.0;
}

double 
STDMETHODCALLTYPE 
CMediaBarPlayer::GetTrackTime()
{
    if (IsReady())
    {
        CComPtr<ITIMEState> spTimeState;
        if (SUCCEEDED(_spMediaElem->get_currTimeState(&spTimeState)) && spTimeState)
        {
            double dblTime = 0.0;
            if (SUCCEEDED(spTimeState->get_simpleTime(&dblTime)))
            {
                return dblTime;
            }
        }
    }
    return 0.0;
}
    
double 
STDMETHODCALLTYPE 
CMediaBarPlayer::GetTrackLength()
{
    if (IsReady())
    {
        double dblDur = 0.0;

        if (SUCCEEDED(_spMediaElem->get_mediaDur(&dblDur)))
            return dblDur ;
    }
    return 0.0;
}

// Returns a progress between 0 and 100 and whether this is download or buffering progress
STDMETHODIMP
CMediaBarPlayer::GetBufProgress(double * pdblProg, ProgressType * ppt)
{
    HRESULT hr = E_FAIL;
    VARIANT_BOOL vb = VARIANT_FALSE;

    if (!pdblProg || !ppt)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    *pdblProg = 0.0;
    *ppt = PT_None;

    hr = _spMediaElem2->get_isStreamed(&vb);
    if (FAILED(hr))
    {
        goto done;
    }

    if (VARIANT_TRUE == vb)
    {
        CComVariant svarBufProg;

        hr = _spMediaElem2->get_bufferingProgress(&svarBufProg);
        if (SUCCEEDED(hr))
        {
            *ppt = PT_Buffering;
            if (SUCCEEDED(svarBufProg.ChangeType(VT_R8)))
            {
                *pdblProg = V_R8(&svarBufProg);
            }
        }
    }
    else
    {
        CComVariant svarDownloadProg;

        hr = _spMediaElem2->get_downloadProgress(&svarDownloadProg);
        if (SUCCEEDED(hr))
        {
            *ppt = PT_Download;
            if (SUCCEEDED(svarDownloadProg.ChangeType(VT_R8)))
            {
                *pdblProg = V_R8(&svarDownloadProg);
            }
        }
    }
    
done:
    return hr;
}

VARIANT_BOOL STDMETHODCALLTYPE 
CMediaBarPlayer::isMuted()
{
    VARIANT_BOOL vbMuted = VARIANT_FALSE;
    if (IsReady())
    {
        CComPtr<ITIMEState> spTimeState;
        if (SUCCEEDED(_spMediaElem->get_currTimeState(&spTimeState)) && spTimeState)
        {
            spTimeState->get_isMuted(&vbMuted);
        }
    }
    return vbMuted;
}

VARIANT_BOOL STDMETHODCALLTYPE 
CMediaBarPlayer::isPaused()
{
    VARIANT_BOOL vbPaused = VARIANT_FALSE;
    if (IsReady())
    {
        CComPtr<ITIMEState> spTimeState;
        if (SUCCEEDED(_spMediaElem->get_currTimeState(&spTimeState)) && spTimeState)
        {
            spTimeState->get_isPaused(&vbPaused);
        }
    }
    return vbPaused;
}

VARIANT_BOOL STDMETHODCALLTYPE 
CMediaBarPlayer::isStopped()
{
    VARIANT_BOOL vbActive = VARIANT_FALSE;
    if (IsReady())
    {
        CComPtr<ITIMEState> spTimeState;
        if (SUCCEEDED(_spMediaElem->get_currTimeState(&spTimeState)) && spTimeState)
        {
            spTimeState->get_isActive(&vbActive);
        }
    }
    return (vbActive ? VARIANT_FALSE : VARIANT_TRUE);
}

STDMETHODIMP
CMediaBarPlayer::Next()
{
    return _SetTrack(TT_Next);;
}

STDMETHODIMP
CMediaBarPlayer::Prev()
{
    return _SetTrack(TT_Prev);
}

STDMETHODIMP
CMediaBarPlayer::_SetTrack(TrackType tt)
{
    HRESULT hr = E_FAIL;
    CComPtr<ITIMEPlayList> spPlayList;
    
    if (!IsReady())
    {
        goto done;
    }

    hr = _spMediaElem->get_playList(&spPlayList);
    ERROREXIT(hr)

    if (NULL != spPlayList.p)
    {
        if (TT_Next == tt)
        {
            hr = spPlayList->nextTrack();
            ERROREXIT(hr)
        }
        else if (TT_Prev == tt)
        {
            hr = spPlayList->prevTrack();
            ERROREXIT(hr)
        }
    }

    hr = S_OK;
done:
    return hr;
}

LONG_PTR 
STDMETHODCALLTYPE 
CMediaBarPlayer::GetPlayListItemIndex()
{
    CComPtr<ITIMEPlayList> spPlayList;
    long lIndex = -1;

    if (IsReady())
    {
        if (SUCCEEDED(_spMediaElem->get_playList(&spPlayList)))
        {
            CComPtr<ITIMEPlayItem> spPlayItem;
            if (spPlayList && SUCCEEDED(spPlayList->get_activeTrack(&spPlayItem)))
            {
                if (spPlayItem && SUCCEEDED(spPlayItem->get_index(&lIndex)))
                    return lIndex;
            }
        }
    }
    return (LONG_PTR)lIndex;
}

LONG_PTR 
STDMETHODCALLTYPE 
CMediaBarPlayer::GetPlayListItemCount()
{
    CComPtr<ITIMEPlayList> spPlayList;
    LONG lLength = 0;

    if (IsReady())
    {
        if (SUCCEEDED(_spMediaElem->get_playList(&spPlayList)))
        {
            if (spPlayList && SUCCEEDED(spPlayList->get_length(&lLength)))
            {
                return lLength;
            }
        }
    }
    return lLength;
}

HRESULT  
STDMETHODCALLTYPE 
CMediaBarPlayer::SetActiveTrack( long lIndex)
{
    CComPtr<ITIMEPlayList> spPlayList;
    HRESULT hr = S_OK;

    if (IsReady())
    {
        hr = _spMediaElem->get_playList(&spPlayList);
        ERROREXIT(hr);

        if (spPlayList)
        {
            VARIANT vIndex;
            VariantInit(&vIndex);

            vIndex.vt   = VT_I4;
            vIndex.lVal = lIndex;

            hr = spPlayList->put_activeTrack(vIndex) ;
            ERROREXIT(hr);
        }
        else
        {
            hr = S_FALSE;
        }
    }
    
done :   
    return hr ;
}

BOOL 
STDMETHODCALLTYPE 
CMediaBarPlayer::IsPausePossible()
{
    if (IsReady())
    {
        VARIANT_BOOL vbIsPausePossible = VARIANT_FALSE;

        if (SUCCEEDED(_spMediaElem->get_canPause(&vbIsPausePossible)))
        {
            return (vbIsPausePossible == VARIANT_TRUE) ? TRUE : FALSE;
        }
    }
    return FALSE;
}

BOOL 
STDMETHODCALLTYPE 
CMediaBarPlayer::IsSeekPossible()
{
   if (IsReady())
    {
        VARIANT_BOOL vbIsSeekPossible = VARIANT_FALSE;

        if (SUCCEEDED(_spMediaElem->get_canSeek(&vbIsSeekPossible)))
        {
            return (vbIsSeekPossible  == VARIANT_TRUE) ? TRUE : FALSE;
        }
    }
    return FALSE;
}

BOOL 
STDMETHODCALLTYPE 
CMediaBarPlayer::IsStreaming()
{
   if (IsReady())
    {
        VARIANT_BOOL vbIsStreaming = VARIANT_FALSE;

        if (SUCCEEDED(_spMediaElem2->get_isStreamed(&vbIsStreaming)))
        {
            return (vbIsStreaming  == VARIANT_TRUE) ? TRUE : FALSE;
        }
    }
    return FALSE;
}

BOOL 
STDMETHODCALLTYPE 
CMediaBarPlayer::IsPlayList()
{
    VARIANT_BOOL vbIsPlayList = VARIANT_FALSE;

    if (IsReady())
    {
        if (SUCCEEDED(_spMediaElem->get_hasPlayList(&vbIsPlayList)))
        {
            return (vbIsPlayList == VARIANT_TRUE) ? TRUE : FALSE;
        }
    }
    return FALSE;
}

BOOL 
STDMETHODCALLTYPE 
CMediaBarPlayer::IsSkippable()
{
    BOOL fRet = TRUE;
    // We need to check if the client has specified CLIENTSKIP="no" and respect that. This is to prevent 
    // the media bar from allowing the user to skip server-side stuff, which is a no-no. There are legal restrictions
    // related to this.
    CComDispatchDriverEx spWMP;
    if (_spMediaElem && SUCCEEDED(_spMediaElem->get_playerObject(&spWMP)) && spWMP)
    {
        CComVariant vtControls;
        HRESULT hr = spWMP.GetPropertyByName(L"controls", &vtControls);
        if (SUCCEEDED(hr))
        {
            CComDispatchDriverEx pwmpControls;
            pwmpControls = vtControls;

            // We're only checking for next (but not back), and assuming that NOSKIP will affect only "next".
            CComVariant vtNext = "Next";
            CComVariant vtEnabled;
            hr = pwmpControls.GetPropertyByName1(L"isAvailable", &vtNext, &vtEnabled);
            if (SUCCEEDED(hr) && (V_VT(&vtEnabled) == VT_BOOL))
            {
                fRet = (V_BOOL(&vtEnabled) == VARIANT_TRUE);
            }
        }
    }
    return fRet;
}



#ifdef SINKWMP
HRESULT CMediaBarPlayer::InitWMPSink()
{
    if (!_spWMP)
    {
        if (SUCCEEDED(_spMediaElem->get_playerObject(&_spWMP)))
        {
            CComPtr<IConnectionPointContainer> pcpc;
            
            HRESULT hr = _spWmp->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pcpc));
            if (SUCCEEDED(hr))
            {
                hr = pcpc->FindConnectionPoint(DIID__WMPOCXEvents, &_spWMPCP);
            }
            if (SUCCEEDED(hr))
            {
                hr = _spWMPCP->Advise(GetUnknown(), &_dwWMPCookie);
                if (FAILED(hr))
                {
                    m_pcpMediaEvents.Release();
                    m_dwMediaEventsCookie = 0;
                }
            }
        }
    }
    return S_OK;
}
#endif

HRESULT CMediaBarPlayer::GetProp(IDispatch* pDispatch, OLECHAR* pwzProp, VARIANT* pvarResult, DISPPARAMS* pParams)
{
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPPARAMS  params      = {NULL, NULL, 0, 0};

    if (!pParams)
    {
        pParams = &params;
    }

    if (!pDispatch)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &pwzProp, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispatch->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET,
            pParams, pvarResult, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

HRESULT CMediaBarPlayer::CallMethod(IDispatch* pDispatch, OLECHAR* pwzMethod, VARIANT* pvarResult, VARIANT* pvarArgument1)
{
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPPARAMS  params      = {pvarArgument1, NULL, 0, 0};

    if (NULL != pvarArgument1)
    {
        params.cArgs = 1;
    }

    if (!pDispatch)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &pwzMethod, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispatch->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
            &params, pvarResult, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\player.h ===
// MediaBarPlayer.h

#pragma once

#ifndef __MEDIABARPLAYER_H_
#define __MEDIABARPLAYER_H_

#include "exdisp.h"
#ifdef SINKWMP
#include "wmp\wmp_i.c"
#include "wmp\wmp.h"
#include "wmp\wmpids.h"
#endif

#define MEDIACOMPLETE   -1
#define MEDIA_TRACK_FINISHED    -2
#define TRACK_CHANGE    -3

////////////////////////////////////////////////////////////////
// IMediaBar

// {3AE35551-8362-49fc-BC4F-F5715BF4291E}
static const IID IID_IMediaBar = 
{ 0x3ae35551, 0x8362, 0x49fc, { 0xbc, 0x4f, 0xf5, 0x71, 0x5b, 0xf4, 0x29, 0x1e } };

interface IMediaBar : public IUnknown
{
public:
    STDMETHOD(Notify)(long lReason) = 0;
    STDMETHOD(OnMediaError)(int iErrCode) = 0;
};


HRESULT CMediaBarPlayer_CreateInstance(REFIID riid, void ** ppvObj); 



/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  DANGER !!!  DANGER !!!  DANGER !!!  DANGER !!!  DANGER !!!  DANGER !!!  DANGER !!!  DANGER !!!  DANGER !!!  
//
// ISSUE: dilipk: till I find a way to include mstime.h without compile errors, explicitly declaring the interfaces
//                This is DANGEROUS because changes in mstime.idl could break media bar
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// fwd declarations (See end of file for definitions)

interface IMediaBarPlayer;
interface ITIMEElement;
interface ITIMEBodyElement;
interface ITIMEMediaElement;
interface ITIMEState;
interface ITIMEElementCollection;
interface ITIMEActiveElementCollection;
interface ITIMEPlayList;
interface ITIMEPlayItem;
interface ITIMEMediaNative;

EXTERN_C const IID IID_ITIMEMediaElement2;

typedef enum _TimeState
{   
    TS_Inactive = 0,
    TS_Active   = 1,
    TS_Cueing   = 2,
    TS_Seeking  = 3,
    TS_Holding  = 4
} TimeState;

////////////////////////////////////////////////////////////////////////////
// MediaBarPlayer 

// {f810fb9c-5587-47f1-a7cb-838cc4ca979f}
DEFINE_GUID(CLSID_MediaBarPlayer, 0xf810fb9c, 0x5587, 0x47f1, 0xa7, 0xcb, 0x83, 0x8c, 0xc4, 0xca, 0x97, 0x9f);

// {0c84b786-af32-47bc-a904-d8ebae3d5f96}
static const IID IID_IMediaBarPlayer = 
{ 0x0c84b786, 0xaf32, 0x47bc, { 0xa9, 0x04, 0xd8, 0xeb, 0xae, 0x3d, 0x5f, 0x96 } };

typedef enum _ProgressType
{
    PT_Download = 0,
    PT_Buffering = 1,
    PT_None = 2
} ProgressType;

typedef enum _TrackType
{
    TT_Next = 0,
    TT_Prev = 1,
    TT_None = 2
} TrackType;


interface 
__declspec(uuid("0c84b786-af32-47bc-a904-d8ebae3d5f96")) 
IMediaBarPlayer : public IUnknown
{
public:
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_url( 
        /* [retval][out] */ BSTR __RPC_FAR *url) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_url( 
        /* [in] */ BSTR url) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_player( 
        /* [retval][out] */ BSTR __RPC_FAR *player) = 0;

    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_type( 
    /* [in] */ BSTR url) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_volume( 
        /* [retval][out] */ double __RPC_FAR *volume) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_volume( 
        /* [in] */ double volume) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mute( 
        /* [retval][out] */ BOOL __RPC_FAR *mute) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_mute( 
        /* [in] */ BOOL mute) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mediaElement( 
        /* [retval][out] */ ITIMEMediaElement __RPC_FAR *__RPC_FAR *ppMediaElement) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Init( 
        HWND hWnd,
        IMediaBar __RPC_FAR *pMediaBar) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DeInit( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Play( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Seek( 
        double Progress) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Resize(
        LONG* height, LONG* width, BOOL fClampMaxSizeToNaturalSize = TRUE) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetVideoHwnd(
        HWND * pHwnd) = 0;

    virtual double STDMETHODCALLTYPE GetTrackTime( void ) = 0;
    
    virtual double STDMETHODCALLTYPE GetTrackLength( void ) = 0;

    virtual double STDMETHODCALLTYPE GetTrackProgress( void ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBufProgress( double * pdblProg, ProgressType * ppt) = 0;

    virtual VARIANT_BOOL STDMETHODCALLTYPE isMuted( void ) = 0;

    virtual VARIANT_BOOL STDMETHODCALLTYPE isPaused( void ) = 0;

    virtual VARIANT_BOOL STDMETHODCALLTYPE isStopped( void ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Next( void ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Prev( void ) = 0;

    virtual LONG_PTR STDMETHODCALLTYPE GetPlayListItemCount( void ) = 0;

    virtual LONG_PTR STDMETHODCALLTYPE GetPlayListItemIndex( void ) = 0;

    virtual HRESULT  STDMETHODCALLTYPE SetActiveTrack( long lIndex) = 0;

    virtual BOOL STDMETHODCALLTYPE IsPausePossible() = 0;

    virtual BOOL STDMETHODCALLTYPE IsSeekPossible()  = 0;

    virtual BOOL STDMETHODCALLTYPE IsStreaming()  = 0;

    virtual BOOL STDMETHODCALLTYPE IsPlayList( void ) = 0;

    virtual BOOL STDMETHODCALLTYPE IsSkippable() = 0;
};


//////////////////////////////////////////////////////////////////////////////////////
// ITIMEElement

interface     ITIMEElement : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_accelerate( 
            /* [retval][out] */ VARIANT *__MIDL_0010) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_accelerate( 
            /* [in] */ VARIANT __MIDL_0011) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_autoReverse( 
            /* [retval][out] */ VARIANT *__MIDL_0012) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_autoReverse( 
            /* [in] */ VARIANT __MIDL_0013) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_begin( 
            /* [retval][out] */ VARIANT *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_begin( 
            /* [in] */ VARIANT time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_decelerate( 
            /* [retval][out] */ VARIANT *__MIDL_0014) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_decelerate( 
            /* [in] */ VARIANT __MIDL_0015) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_dur( 
            /* [retval][out] */ VARIANT *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_dur( 
            /* [in] */ VARIANT time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_end( 
            /* [retval][out] */ VARIANT *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_end( 
            /* [in] */ VARIANT time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_fill( 
            /* [retval][out] */ BSTR *f) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_fill( 
            /* [in] */ BSTR f) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mute( 
            /* [retval][out] */ VARIANT *b) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_mute( 
            /* [in] */ VARIANT b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_repeatCount( 
            /* [retval][out] */ VARIANT *c) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_repeatCount( 
            /* [in] */ VARIANT c) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_repeatDur( 
            /* [retval][out] */ VARIANT *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_repeatDur( 
            /* [in] */ VARIANT time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_restart( 
            /* [retval][out] */ BSTR *__MIDL_0016) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_restart( 
            /* [in] */ BSTR __MIDL_0017) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_speed( 
            /* [retval][out] */ VARIANT *speed) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_speed( 
            /* [in] */ VARIANT speed) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_syncBehavior( 
            /* [retval][out] */ BSTR *sync) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_syncBehavior( 
            /* [in] */ BSTR sync) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_syncTolerance( 
            /* [retval][out] */ VARIANT *tol) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_syncTolerance( 
            /* [in] */ VARIANT tol) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_syncMaster( 
            /* [retval][out] */ VARIANT *b) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_syncMaster( 
            /* [in] */ VARIANT b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_timeAction( 
            /* [retval][out] */ BSTR *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_timeAction( 
            /* [in] */ BSTR time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_timeContainer( 
            /* [retval][out] */ BSTR *__MIDL_0018) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_volume( 
            /* [retval][out] */ VARIANT *val) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_volume( 
            /* [in] */ VARIANT val) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_currTimeState( 
            /* [retval][out] */ ITIMEState **TimeState) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_timeAll( 
            /* [retval][out] */ ITIMEElementCollection **allColl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_timeChildren( 
            /* [retval][out] */ ITIMEElementCollection **childColl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_timeParent( 
            /* [retval][out] */ ITIMEElement **parent) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_isPaused( 
            /* [retval][out] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE beginElement( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE beginElementAt( 
            /* [in] */ double parentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE endElement( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE endElementAt( 
            /* [in] */ double parentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE pauseElement( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE resetElement( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE resumeElement( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE seekActiveTime( 
            /* [in] */ double activeTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE seekSegmentTime( 
            /* [in] */ double segmentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE seekTo( 
            /* [in] */ LONG repeatCount,
            /* [in] */ double segmentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE documentTimeToParentTime( 
            /* [in] */ double documentTime,
            /* [retval][out] */ double *parentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE parentTimeToDocumentTime( 
            /* [in] */ double parentTime,
            /* [retval][out] */ double *documentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE parentTimeToActiveTime( 
            /* [in] */ double parentTime,
            /* [retval][out] */ double *activeTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE activeTimeToParentTime( 
            /* [in] */ double activeTime,
            /* [retval][out] */ double *parentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE activeTimeToSegmentTime( 
            /* [in] */ double activeTime,
            /* [retval][out] */ double *segmentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE segmentTimeToActiveTime( 
            /* [in] */ double segmentTime,
            /* [retval][out] */ double *activeTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE segmentTimeToSimpleTime( 
            /* [in] */ double segmentTime,
            /* [retval][out] */ double *simpleTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE simpleTimeToSegmentTime( 
            /* [in] */ double simpleTime,
            /* [retval][out] */ double *segmentTime) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_endSync( 
            /* [retval][out] */ BSTR *es) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_endSync( 
            /* [in] */ BSTR es) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_activeElements( 
            /* [retval][out] */ ITIMEActiveElementCollection **activeColl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_hasMedia( 
            /* [out][retval] */ VARIANT_BOOL *flag) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE nextElement( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE prevElement( void) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_updateMode( 
            /* [retval][out] */ BSTR *updateMode) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_updateMode( 
            /* [in] */ BSTR updateMode) = 0;
        
    };


//////////////////////////////////////////////////////////////////////////////////////
// ITIMEMediaElement

extern "C" const IID IID_ITIMEMediaElement;

interface ITIMEMediaElement : public ITIMEElement
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_clipBegin( 
            /* [retval][out] */ VARIANT *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_clipBegin( 
            /* [in] */ VARIANT time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_clipEnd( 
            /* [retval][out] */ VARIANT *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_clipEnd( 
            /* [in] */ VARIANT time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_player( 
            /* [retval][out] */ VARIANT *id) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_player( 
            /* [in] */ VARIANT id) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_src( 
            /* [retval][out] */ VARIANT *url) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_src( 
            /* [in] */ VARIANT url) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ VARIANT *mimetype) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_type( 
            /* [in] */ VARIANT mimetype) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_abstract( 
            /* [retval][out] */ BSTR *abs) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_author( 
            /* [retval][out] */ BSTR *auth) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_copyright( 
            /* [retval][out] */ BSTR *cpyrght) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_hasAudio( 
            /* [out][retval] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_hasVisual( 
            /* [out][retval] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mediaDur( 
            /* [retval][out] */ double *dur) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mediaHeight( 
            /* [retval][out] */ long *height) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mediaWidth( 
            /* [retval][out] */ long *width) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_playerObject( 
            /* [retval][out] */ IDispatch **ppDisp) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_playList( 
            /* [retval][out] */ ITIMEPlayList **pPlayList) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_rating( 
            /* [retval][out] */ BSTR *rate) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_title( 
            /* [retval][out] */ BSTR *name) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_hasPlayList( 
            /* [retval][out] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_canPause( 
            /* [out][retval] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_canSeek( 
            /* [out][retval] */ VARIANT_BOOL *b) = 0;
        
    };


//////////////////////////////////////////////////////////////////////////////////////
// ITIMEMediaElement2

    interface ITIMEMediaElement2 : public ITIMEMediaElement
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_earliestMediaTime( 
            /* [retval][out] */ VARIANT *earliestMediaTime) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_latestMediaTime( 
            /* [retval][out] */ VARIANT *latestMediaTime) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_minBufferedMediaDur( 
            /* [retval][out] */ VARIANT *minBufferedMediaDur) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_minBufferedMediaDur( 
            /* [in] */ VARIANT minBufferedMediaDur) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_downloadTotal( 
            /* [retval][out] */ VARIANT *downloadTotal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_downloadCurrent( 
            /* [retval][out] */ VARIANT *downloadCurrent) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_isStreamed( 
            /* [retval][out] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bufferingProgress( 
            /* [retval][out] */ VARIANT *bufferingProgress) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_hasDownloadProgress( 
            /* [retval][out] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_downloadProgress( 
            /* [retval][out] */ VARIANT *downloadProgress) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mimeType( 
            /* [retval][out] */ BSTR *mimeType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE seekToFrame( 
            /* [in] */ long frameNr) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE decodeMimeType( 
            /* [in] */ TCHAR *header,
            /* [in] */ long headerSize,
            /* [out] */ BSTR *mimeType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_currentFrame( 
            /* [retval][out] */ long *currFrame) = 0;
        
    };

    
//////////////////////////////////////////////////////////////////////////////////////
// ITIMEState

    interface ITIMEState : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_activeDur( 
            /* [out][retval] */ double *dur) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_activeTime( 
            /* [out][retval] */ double *time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_isActive( 
            /* [out][retval] */ VARIANT_BOOL *active) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_isOn( 
            /* [out][retval] */ VARIANT_BOOL *on) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_isPaused( 
            /* [out][retval] */ VARIANT_BOOL *paused) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_isMuted( 
            /* [out][retval] */ VARIANT_BOOL *muted) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_parentTimeBegin( 
            /* [out][retval] */ double *time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_parentTimeEnd( 
            /* [out][retval] */ double *time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_progress( 
            /* [out][retval] */ double *progress) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_repeatCount( 
            /* [out][retval] */ LONG *count) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_segmentDur( 
            /* [out][retval] */ double *dur) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_segmentTime( 
            /* [out][retval] */ double *time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_simpleDur( 
            /* [out][retval] */ double *dur) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_simpleTime( 
            /* [out][retval] */ double *time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_speed( 
            /* [out][retval] */ float *speed) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_state( 
            /* [out][retval] */ TimeState *timeState) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_stateString( 
            /* [out][retval] */ BSTR *state) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_volume( 
            /* [out][retval] */ float *vol) = 0;
        
    };

//////////////////////////////////////////////////////////////////////////////////////
// ITIMEBodyElement

extern "C" const IID IID_ITIMEBodyElement;

interface ITIMEBodyElement : public ITIMEElement
{
public:
};

//////////////////////////////////////////////////////////////////////////////////////
// ITIMEPlayList

    interface ITIMEPlayList : public IDispatch
    {
    public:
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_activeTrack( 
            /* [in] */ VARIANT vTrack) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_activeTrack( 
            /* [retval][out] */ ITIMEPlayItem **pPlayItem) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_dur( 
            double *dur) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in][defaultvalue] */ VARIANT varIndex,
            /* [retval][out] */ ITIMEPlayItem **pPlayItem) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *p) = 0;
        
        virtual /* [hidden][restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [retval][out] */ IUnknown **p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE nextTrack( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE prevTrack( void) = 0;
        
    };

//////////////////////////////////////////////////////////////////////////////////////
// ITIMEPlayItem

    interface ITIMEPlayItem : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_abstract( 
            /* [retval][out] */ BSTR *abs) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_author( 
            /* [retval][out] */ BSTR *auth) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_copyright( 
            /* [retval][out] */ BSTR *cpyrght) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_dur( 
            /* [retval][out] */ double *dur) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_index( 
            /* [retval][out] */ long *index) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_rating( 
            /* [retval][out] */ BSTR *rate) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_src( 
            /* [retval][out] */ BSTR *src) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_title( 
            /* [retval][out] */ BSTR *title) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setActive( void) = 0;
        
    };

//////////////////////////////////////////////////////////////////////////////////////
// ITIMEMediaNative
    const GUID IID_ITIMEMediaNative = {0x3e3535c0,0x445b,0x4ef4,{0x8a,0x38,0x4d,0x37,0x9c,0xbc,0x98,0x28}};

    interface ITIMEMediaNative : public IUnknown
    {
    public:
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE seekActiveTrack( 
            /* [in] */ double dblSeekTime) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_activeTrackTime( 
            /* [retval][out] */ double *dblActiveTrackTime) = 0;
        
    };

////////////////////////////////////////////////////////////////
// CMediaBarPlayer

class
__declspec(uuid("210e94fa-5e4e-4580-aecb-f01abbf73de6")) 
CMediaBarPlayer :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IMediaBarPlayer,
    public IPropertyNotifySink,
    public CComCoClass<CMediaBarPlayer, &CLSID_MediaBarPlayer>,
//    public IDispatchImpl<_WMPOCXEvents, &DIID__WMPOCXEvents, (CONST)&LIBID_WMPOCX>,
    public IDispatchImpl<DWebBrowserEvents2, &DIID_DWebBrowserEvents2, &LIBID_SHDocVw>
{
public:
    CMediaBarPlayer();
    virtual ~CMediaBarPlayer();

    BEGIN_COM_MAP(CMediaBarPlayer)
        COM_INTERFACE_ENTRY(IMediaBarPlayer)
        COM_INTERFACE_ENTRY(IPropertyNotifySink)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IID(DIID_DWebBrowserEvents2, IDispatch)
#ifdef SINKWMP
        COM_INTERFACE_ENTRY_IID(DIID__WMPOCXEvents, IDispatch)
#endif
    END_COM_MAP();

    /*
    DECLARE_REGISTRY(CLSID_MediaBarPlayer,
                     LIBID __T(".MediaBarPlayer.1"),
                     LIBID __T(".MediaBarPlayer"),
                     0,
                     THREADFLAGS_BOTH);
    */

    ////////////////////////////////////////////////////////////////
    // IMediaBarPlayer 

    STDMETHOD(put_url)(BSTR bstrUrl);
    STDMETHOD(get_url)(BSTR * pbstrUrl);

    STDMETHOD(get_player)(BSTR * pbstrPlayer);

    STDMETHOD(put_type)(BSTR bstrType);

    STDMETHOD(put_volume)(double dblVolume);
    STDMETHOD(get_volume)(double * pdblVolume);

    STDMETHOD(put_mute)(BOOL bMute);
    STDMETHOD(get_mute)(BOOL * pbMute);

    STDMETHOD(get_mediaElement)(ITIMEMediaElement ** ppMediaElem);

    STDMETHOD(Init)(HWND hwnd, IMediaBar * pMediaBar);

    STDMETHOD(DeInit)();

    STDMETHOD(Play)();

    STDMETHOD(Stop)();

    STDMETHOD(Pause)();

    STDMETHOD(Resume)();

    STDMETHOD(Seek)(double dblProgress);

    STDMETHOD(Resize)(LONG* lHeight, LONG* lWidth, BOOL fClampMaxSizeToNaturalSize = TRUE);

    STDMETHOD(GetVideoHwnd)(HWND * pHwnd);

    double STDMETHODCALLTYPE GetTrackTime();
    
    double STDMETHODCALLTYPE GetTrackLength();

    double STDMETHODCALLTYPE GetTrackProgress( void ) ;

    STDMETHOD(GetBufProgress)(double * pdblProg, ProgressType * ppt);

    VARIANT_BOOL STDMETHODCALLTYPE isMuted();

    VARIANT_BOOL STDMETHODCALLTYPE isPaused();

    VARIANT_BOOL STDMETHODCALLTYPE isStopped();

    STDMETHOD(Next)();

    STDMETHOD(Prev)();

    LONG_PTR STDMETHODCALLTYPE GetPlayListItemCount( void );

    LONG_PTR STDMETHODCALLTYPE GetPlayListItemIndex( void );

    HRESULT  STDMETHODCALLTYPE SetActiveTrack(long lIndex);

    BOOL STDMETHODCALLTYPE IsPausePossible() ;

    BOOL STDMETHODCALLTYPE IsSeekPossible()  ;

    BOOL STDMETHODCALLTYPE IsStreaming() ;
        
    BOOL STDMETHODCALLTYPE IsPlayList( void );

    BOOL STDMETHODCALLTYPE IsSkippable();

    ////////////////////////////////////////////////////////////////
    // IDispatch

    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

    ////////////////////////////////////////////////////////////////
    // IPropertyNotifySink

    STDMETHOD(OnChanged)(DISPID dispid);
    STDMETHOD(OnRequestEdit)(DISPID dispid) { return S_OK; }

private:
    // *** Methods ***
    enum INVOKETYPE {IT_GET, IT_PUT, IT_METHOD};

    STDMETHOD(_CreateHost)(HWND hWnd);
    STDMETHOD(_DestroyHost)();

    STDMETHOD(_GetDocumentDispatch)(IDispatch ** ppDocDisp);

    STDMETHOD(_GetElementDispatch)(LPWSTR pstrElem, IDispatchEx ** ppDispEx);
    STDMETHOD(_GetMediaElement)(ITIMEMediaElement ** ppMediaElem);
    STDMETHOD(_GetBodyElement)(ITIMEBodyElement ** ppBodyaElem);
    STDMETHOD(_InvokeDocument)(LPWSTR pstrElem, INVOKETYPE it, LPWSTR pstrName, VARIANT * pvarArg);

    STDMETHOD(_OnDocumentComplete)();
    STDMETHOD(_OnMediaComplete)();
    STDMETHOD(_OnTrackChange)();
    STDMETHOD(_OnEnd)();
    STDMETHOD(_OnMediaError)(int iErrCode);

    STDMETHOD(_InitEventSink)();
    STDMETHOD(_DeInitEventSink)();

    STDMETHOD(_AttachPlayerEvents)(BOOL fAttach);

    STDMETHOD(_HookPropNotifies)();
    STDMETHOD(_UnhookPropNotifies)();

    STDMETHOD(_Navigate)(BSTR bstrUrl);

    STDMETHOD(_SetTrack)(TrackType tt);

    // ISSUE: dilipk: optimize this to check only the last reference stored since that would validate all others
    bool IsReady() { return     (NULL != _spMediaElem.p)
                            &&  (NULL != _spMediaElem2.p)
                            &&  (NULL != _spBrowser.p) 
                            &&  (NULL != _spBodyElem.p) 
                            &&  (NULL != _spPlayerHTMLElem2.p); }

    // *** Data ***
    CComPtr<IWebBrowser2>           _spBrowser;
    CComPtr<ITIMEMediaElement>      _spMediaElem;
    CComPtr<ITIMEMediaElement2>     _spMediaElem2;
    CComPtr<ITIMEBodyElement>       _spBodyElem;
    CComPtr<IHTMLElement2>          _spPlayerHTMLElem2;

    IMediaBar *                     _pMediaBar;

    DWORD                           _dwDocumentEventConPtCookie;
    DWORD                           _dwCookiePropNotify;
    CComPtr<IConnectionPoint>       _spDocConPt;
    CComPtr<IConnectionPoint>       _spPropNotifyCP;
    CComBSTR                        _sbstrType;
    CComBSTR                        _sbstrUrl;
    HWND                            _hwnd;

#ifdef SINKWMP
    CComPtr<IDispatch>              _spWMP;
    CComPtr<IConnectionPoint>        _spWMPCP;
    DWORD                         _dwWMPCookie;
    HRESULT                        InitWMPSink();
#endif

    HRESULT GetProp(IDispatch* pDispatch, OLECHAR* pwzProp, VARIANT* pvarResult, DISPPARAMS* pParams = NULL);
    HRESULT CallMethod(IDispatch* pDispatch, OLECHAR* pwzMethod, VARIANT* pvarResult = NULL, VARIANT* pvarArgument1 = NULL);
};

#endif // __MEDIABARPLAYER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

// For use with VC6
#pragma warning(4:4519)  //default template arguments are only allowed on a class template; ignored
#pragma warning(4:4242)  //'initializing' : conversion from 'unsigned int' to 'unsigned short', possible loss of data

// Extra error checking (catches false errors, but useful to run every so often)
#if 0
#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4709)   // command operator w/o index expression
#endif

// Sundown: forcing value to bool
#pragma warning(disable:4800)

// This stuff must run on Win95
#define _WIN32_WINDOWS      0x0400

#ifndef WINVER
#define WINVER              0x0400
#endif

#define _OLEAUT32_       // get DECLSPEC_IMPORT stuff right, we are defing these
#define _BROWSEUI_       // define bruiapi as functions exported instead of imported
#define _WINMM_          // for DECLSPEC_IMPORT in mmsystem.h
#define _WINX32_         // get DECLSPEC_IMPORT stuff right for WININET API
#define _URLCACHEAPI     // get DECLSPEC_IMPORT stuff right for WININET CACHE API
#define _UXTHEME_        // get DECLSPEC_IMPORT stuff right for uxtheme

#ifndef STRICT
#define STRICT
#endif

// Map KERNEL32 unicode string functions to SHLWAPI
// This is needed way up here.
#define lstrcmpW    StrCmpW
#define lstrcmpiW   StrCmpIW
#define lstrcpyW    StrCpyW
#define lstrcpynW   StrCpyNW
#define lstrcatW    StrCatW


//
// Enable channel code for IE4 upgrades.
//
#define ENABLE_CHANNELS

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

/////////////////////////////////////////////////////////////////////////
//
//  ATL / OLE HACKHACK
//
//  Include <w95wraps.h> before anything else that messes with names.
//  Although everybody gets the wrong name, at least it's *consistently*
//  the wrong name, so everything links.
//
//  NOTE:  This means that while debugging you will see functions like
//  CWindowImplBase__DefWindowProcWrapW when you expected to see
//  CWindowImplBase__DefWindowProc.
//
#define POST_IE5_BETA // turn on post-split iedev stuff
#include <w95wraps.h>

#include <windows.h>

// VariantInit is a trivial function -- avoid using OleAut32, use intrinsic
// version of memset for a good size win
// (it's here so that atl (in stdafx.h) gets it too)
#define VariantInit(p) memset(p, 0, sizeof(*(p)))

#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
//WinInet need to be included BEFORE ShlObjp.h
#define HLINK_NO_GUIDS
#include <hlink.h>
#include <wininet.h>
#include <winineti.h>
#include <urlmon.h>
#undef GetClassInfo
#include <shlobj.h>
#include <exdispid.h>
#undef GetClassInfo
#include <objidl.h>

#include <shlwapi.h>

//#include <shconv.h>   // replacement for atlconv.h if ATL is not included below

#if defined(__cplusplus) && !defined(DONT_USE_ATL)
// (stdafx.h must come before windowsx.h)
#include "stdafx.h"             // ATL header file for this component

// AtlMisc.h needs some defines from AtlApp.h
#ifndef __ATLAPP_H__
#include "AtlApp.h"
#endif

// include CString, CSize, CRect, CPoint, CFindFile from WTL10
// see %_NTROOT%\public\sdk\inc\wtl10
#include "AtlMisc.h"

// Include LBSTR::CString
#include <locbstr.h>

#endif

#include <windowsx.h>

#include <shellapi.h>

#include <crtfree.h>

#include <ole2ver.h>
#include <olectl.h>
#include <hliface.h>
#include <docobj.h>
#define DLL_IS_ROOTABLE
#include <ccstock.h>
#include <ccstock2.h>
#include <port32.h>

#include <shellp.h>
#include <ieguidp.h>
#include <isguids.h>
#include <mimeinfo.h>
#include <hlguids.h>
#include <mshtmdid.h>
#include <dispex.h>     // IDispatchEx
#include <perhist.h>
#include <shobjidl.h>
#include <iepriv.h>

#include <help.h>

#include <multimon.h>

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <urlhist.h>

#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#define USE_SYSTEM_URL_MONIKER
#include <urlmon.h>
#include <winineti.h>    // Cache APIs & structures
#include <inetreg.h>

#define _INTSHCUT_    // get DECLSPEC_IMPORT stuff right for INTSHCUT.h
#include <intshcut.h>

#include <propset.h>        // If this ever becomes a problem, remove this once OLE adds an official header

#include <regapix.h>        // MAXIMUM_SUB_KEY_LENGTH, MAXIMUM_VALUE_NAME_LENGTH, MAXIMUM_DATA_LENGTH

#include <browseui.h>
#include <shdocvw.h>
#include <commctrl.h>
#include <shfusion.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


//
// WARNING: Don't add private header files in shdocvw here randomly, which
//  will force us to re-compiling everything. Keep those private headers
//  out of priv.h
//  
// #include <iface.h>
#include "globals.h"
#include "runonnt.h"
#include "util.h"
#include "brutil.h"
#include "qistub.h"
#ifdef DEBUG
#include "dbutil.h"
#endif

// Include the automation definitions...
#include <exdisp.h>
#include <exdispid.h>
#include <brdispp.h>
#include <ocmm.h>
#include <mshtmhst.h>
#include <simpdata.h>
#include <htiface.h>
#include <objsafe.h>


#include "shui.h"
#define URLID_URLBASE           0
#define URLID_LOCATION          1
/////// URLID_FTPFOLDER         2 // Taken by a pre-release FTP Folder dll
#define URLID_PROTOCOL          3

// If stdshnor.bmp  or stdshhot.bmp are modifed, change this number to reflect the 
// new number of glyphs
#define NUMBER_SHELLGLYPHS      47
#define MAX_SHELLGLYPHINDEX     SHELLTOOLBAR_OFFSET + NUMBER_SHELLGLYPHS - 1

// Increment steps. For changing the with of the TB buttons. For localization
#define WIDTH_FACTOR            4

//
// Neutral ANSI/UNICODE types and macros... 'cus Chicago seems to lack them
//

#define DLL_IS_UNICODE         (sizeof(TCHAR) == sizeof(WCHAR))

//===========================================================================
// ITEMIDLIST
//===========================================================================

// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

#define SEN_FIRST       (0U-550U)       // ;Internal



#ifdef __cplusplus

//
//  Pseudoclass for the variable-sized OLECMDTEXT structure.
//  You need to declare it as a class (and not a BYTE buffer that is
//  suitable cast) because BYTE buffers are not guaranteed to be aligned.
//
template <int n>
class OLECMDTEXTV : public OLECMDTEXT {
    WCHAR wszBuf[n-1];          // "-1" because OLECMDTEXT includes 1 wchar
};

extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */

void CInternetToolbar_CleanUp();
void CUserAssist_CleanUp(DWORD dwReason, LPVOID lpvReserved);
void CBrandBand_CleanUp();
STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes);


// Count of images Currently - 2 (Normal and Hot)
#define CIMLISTS                2


typedef struct tagIMLCACHE
{
    HIMAGELIST arhiml[CIMLISTS];
    HIMAGELIST arhimlPendingDelete[CIMLISTS];
    COLORREF cr3D;
    BOOL fSmallIcons;
    BOOL fUseClassicGlyphs;
} IMLCACHE;
    
void IMLCACHE_CleanUp(IMLCACHE * pimlCache, DWORD dwFlags);
#define IML_DELETEPENDING   0x01
#define IML_DESTROY         0x02

extern const ITEMIDLIST c_idlDesktop;
typedef const BYTE *LPCBYTE;

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

#define EnterModeless() AddRef()       // Used for selfref'ing
#define ExitModeless() Release()

//
// Debug helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

BOOL    IsStringContained(LPCTSTR pcszBigger, LPCTSTR pcszSuffix);

#endif // DEBUG

//
//  In DEBUG, send all our class registrations through a wrapper that
//  checks that the class is on our unregister-at-unload list.
//
#ifdef DEBUG
#undef  SHRegisterClass
#undef    RegisterClass
#define SHRegisterClass       SHRegisterClassD
#define   RegisterClass         RegisterClassD

STDAPI_(BOOL) SHRegisterClassD(CONST WNDCLASS* pwc);
STDAPI_(ATOM)   RegisterClassD(CONST WNDCLASS* pwc);
#ifdef UNICODE
#define RealSHRegisterClass   SHRegisterClassW
#define   RealRegisterClass     RegisterClassWrapW
#else
#define RealSHRegisterClass   SHRegisterClassA
#define   RealRegisterClass     RegisterClassA
#endif // UNICODE
#endif // DEBUG

//
//  In DEBUG, send FindWindow through a wrapper that ensures that the
//  critical section is not taken.  FindWindow sends interthreadmessages,
//  which is not obvious.
//
#ifdef DEBUG
#undef  FindWindow
#undef  FindWindowEx
#define FindWindow              FindWindowD
#define FindWindowEx            FindWindowExD

STDAPI_(HWND) FindWindowD  (LPCTSTR lpClassName, LPCTSTR lpWindowName);
STDAPI_(HWND) FindWindowExD(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpClassName, LPCTSTR lpWindowName);
#ifdef UNICODE
#define RealFindWindowEx        FindWindowExWrapW
#else
#define RealFindWindowEx        FindWindowExA
#endif // UNICODE
#endif // DEBUG


//
// Trace/dump/break flags specific to shell32\.
//   (Standard flags defined in shellp.h)
//

// Break flags
#define BF_ONDUMPMENU       0x10000000      // Stop after dumping menus
#define BF_ONLOADED         0x00000010      // Stop when loaded

// Trace flags
#define TF_UEM              0x00000010      // UEM stuff
#define TF_AUTOCOMPLETE     0x00000100      // AutoCompletion

// The following aren't really valid until the ccshell.ini file is updated.
#define TF_SHDLIFE          0x00000200
#define TF_SHDREF           0x00000400
#define TF_SHDPERF          0x00000800
#define TF_SHDAUTO          0x00001000
#define TF_MENUBAND         0x00002000      // Menu band messages
#define TF_SITEMAP          0x00004000      // Sitemap messages
#define TF_SHDTHREAD        0x00008000      // Thread management
#define TF_SHDCONTROL       0x00010000      // ActiveX Control
#define TF_SHDAPPHACK       0x00020000      // Hack for app-bug
#define TF_SHDBINDING       0x00040000      // Moniker binding
#define TF_SHDPROGRESS      0x00080000      // Download progress
#define TF_SHDNAVIGATE      0x00100000      // Navigation
#define TF_SHDUIACTIVATE    0x00200000      // UI-Activation/Deactivation
#define TF_OCCONTROL        0x00400000      // OC Hosting Window Control
#define TF_PIDLWRAP         0x00800000      // Pidl / Protocol wrapping
#define TF_REGCHECK         0x00000100      // Registry check stuff
#define TF_COCREATE         0x02000000      // WinList/CoCreate(Browser only)
#define TF_URLNAMESPACE     0x04000000      // URL Name Space
#define TF_BAND             0x08000000      // Bands (ISF Band, etc)
#define TF_TRAVELLOG        0x10000000      // TravelLog and Navigation stack 
#define TF_DDE              0x20000000      // PMDDE traces
#define TF_CUSTOM1          0x40000000      // Custom messages #1
#define TF_CUSTOM2          0x80000000      // Custom messages #2

#define TF_ACCESSIBILITY    TF_CUSTOM2      // accessibility messages: tabstop handling, get/lose tab focus, accelerators



//There is some thinking that says this should be removed, but why risk the regression
#define TF_OBJECTCACHE      TF_TRAVELLOG

// (Re-use TF_CUSTOM1 and TF_CUSTOM2 by defining a TF_ value in your
// local file to one of these values while you have the file checked 
// out.)

// Dump flags
#define DF_SITEMAP          0x00000001      // Sitemap
#define DF_MEMLEAK          0x00000002      // Dump leaked memory at the end
#define DF_DEBUGQI          0x00000004      // Alloc stub object for each QI
#define DF_DEBUGQINOREF     0x00000008      // No AddRef/Release QI stub
#define DF_DEBUGMENU        0x00000010      // Dump menu handles
#define DF_URL              0x00000020      // Display URLs
#define DF_AUTOCOMPLETE     0x00000040      // AutoCompletion
#define DF_DELAYLOADDLL     0x00000080      // Delay-loaded DLL
#define DF_SHELLLIST        0x00000100      // CShellList contents
#define DF_INTSHCUT         0x00000200      // Internet shortcut structs
#define DF_URLPROP          0x00000400      // URL properties
#define DF_MSGHOOK          0x00000800      // Menu MessageFilter 
#define DF_GETMSGHOOK       0x00001000      // GetMessageFilter 
#define DF_TRANSACCELIO     0x00002000      // GetMessageFilter 

// Prototype flags
#define PF_USERMENUS        0x00000001      // Use traditional USER menu bar
#define PF_NEWFAVMENU       0x00000002      // New favorites menu
#define PF_NOBROWSEUI       0x00001000          // don't use browseui
#define PF_FORCEANSI        0x00002000      // Assume that Shell32 is ANSI

// global object array - used for class factory, auto registration, type libraries, oc information
//

#include "cfdefs.h"

#define OIF_ALLOWAGGREGATION  0x0001
#define OIF_DONTIECREATE      0x0002

//
// global variables
//
//
// Function prototypes
//
STDAPI CMyHlinkSrc_CreateInstance(REFCLSID rclsid, DWORD grfContext, REFIID riid, LPVOID* ppvOut);
STDAPI CMyHlinkSrc_OleCreate(CLSID rclsid, REFIID riid, DWORD renderOpt,
                             FORMATETC* pFormatEtc, IOleClientSite* pclient,
                             IStorage* pstg, LPVOID* ppvOut);

STDAPI CMyHlinkSrc_OleLoad(IStorage* pstg, REFIID riid, IOleClientSite* pclient, LPVOID* ppvOut);

HRESULT SHRegisterTypeLib(void);
VOID SHCheckRegistry(void);

STDAPI_(IBindCtx *) BCW_Create(IBindCtx* pibc);

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);


#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH
#define MAX_NAME_STRING     INTERNET_MAX_PATH_LENGTH
#define MAX_BROWSER_WINDOW_TITLE   128

#define REG_SUBKEY_FAVORITESA            "\\MenuOrder\\Favorites"
#define REG_SUBKEY_FAVORITES             TEXT(REG_SUBKEY_FAVORITESA)

//
//  Class names
//
#define c_szExploreClass TEXT("ExploreWClass")
#define c_szIExploreClass TEXT("IEFrame")
#ifdef IE3CLASSNAME
#define c_szCabinetClass TEXT("IEFrame")
#else
#define c_szCabinetClass TEXT("CabinetWClass")
#endif
#define c_szAutoSuggestClass TEXT("Auto-Suggest Dropdown")

// Stack allocated BSTR (to avoid calling SysAllocString)
typedef struct _SA_BSTR {
    ULONG   cb;
    WCHAR   wsz[MAX_URL_STRING];
} SA_BSTR;

// A "fake" variants for use on the stack - usable for [in] parameters only!!!
typedef struct _SA_BSTRGUID {
    UINT  cb;
    WCHAR wsz[39];
} SA_BSTRGUID;
#define InitFakeBSTR(pSA_BSTR, guid) SHStringFromGUIDW((guid), (pSA_BSTR)->wsz, ARRAYSIZE((pSA_BSTR)->wsz)), (pSA_BSTR)->cb = (38*sizeof(WCHAR))

STDAPI _SetStdLocation(LPTSTR szPath, UINT id);

STDAPI CDocObjectHost_AddPages(LPARAM that, HWND hwnd, HINSTANCE hinst, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
STDAPI_(void) CDocObjectHost_GetCurrentPage(LPARAM that, LPTSTR szBuf, UINT cchMax);

//
// a couple bogus pidls
//
#define PIDL_LOCALHISTORY ((LPCITEMIDLIST)-1)
#define PIDL_NOTHING      ((LPCITEMIDLIST)-2)

#define CALLWNDPROC WNDPROC

// Smartly delay load OLEAUT32
HRESULT VariantClearLazy(VARIANTARG *pvarg);
#define VariantClear VariantClearLazy
WINOLEAUTAPI VariantCopyLazy(VARIANTARG * pvargDest, VARIANTARG * pvargSrc);
#define VariantCopy VariantCopyLazy

#ifdef UNICODE
#define IsDBCSLeadByte(x) ((x), FALSE)
#else
#define IsDBCSLeadByte(x) IsDBCSLeadByteEx(CP_ACP,x)
#endif

#define ILIsEqual(p1, p2)   IEILIsEqual(p1, p2, FALSE)


#ifdef __cplusplus
//
// C++ modules only
//
#include <shstr.h>

extern "C" const ITEMIDLIST s_idlNULL;

// helper routines for view state stuff

IStream *GetDesktopRegStream(DWORD grfMode, LPCTSTR pszName, LPCTSTR pszStreams);
IStream *GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCTSTR pszName, LPCTSTR pszStreamMRU, LPCTSTR pszStreams);

// StreamHeader Signatures
#define STREAMHEADER_SIG_CADDRESSBAND        0xF432E001
#define STREAMHEADER_SIG_CADDRESSEDITBOX     0x24F92A92

#define CoCreateInstance IECreateInstance
HRESULT IECreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);

#endif

extern HRESULT LoadHistoryShellFolder(IUnknown *punkSFHistory, IHistSFPrivate **pphsfHistory); // from urlhist.cpp
extern void CUrlHistory_CleanUp();

// Dummy union macros for code compilation on platforms not
// supporting nameless stuct/union

#ifdef NONAMELESSUNION
#define DUMMYUNION_MEMBER(member)   DUMMYUNIONNAME.##member
#define DUMMYUNION2_MEMBER(member)  DUMMYUNIONNAME2.##member
#define DUMMYUNION3_MEMBER(member)  DUMMYUNIONNAME3.##member
#define DUMMYUNION4_MEMBER(member)  DUMMYUNIONNAME4.##member
#define DUMMYUNION5_MEMBER(member)  DUMMYUNIONNAME5.##member
#else
#define DUMMYUNION_MEMBER(member)    member
#define DUMMYUNION2_MEMBER(member)   member
#define DUMMYUNION3_MEMBER(member)   member
#define DUMMYUNION4_MEMBER(member)   member
#define DUMMYUNION5_MEMBER(member)   member
#endif

#undef COMCTL32_VERSION
#define COMCTL32_VERSION 5          // Browseui is stuck with Version 5 comctl32 because it has to run downlevel.


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

#undef ExpandEnvironmentStrings
#define ExpandEnvironmentStrings #error "Use SHExpandEnvironmentStrings instead"

// Uncomment the following define to enable ATL components to be built in 
// browseui.dll. You'll also have to perform the following steps:
// 1. modify the type library in brdispp.idl (Note that this is for private components only)
// 2. modify selfreg.inx to register your components
// 3. copy atl.cpp and atl.h from shdocvw, and modify to return the appropriate classes
// 4. add atl.* to the makefile
// #define ATL_ENABLED

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\progress.cpp ===
// Display the Progress Dialog for the progress on the completion of some
//    generic operation.  This is most often used for Deleting, Uploading, Copying,
//    Moving and Downloading large numbers of files.

#include "priv.h"
#include "resource.h"
#include "mluisupp.h"

// this is how long we wait for the UI thread to create the progress hwnd before giving up
#define WAIT_PROGRESS_HWND 10*1000 // ten seconds


STDAPI CProgressDialog_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

class CProgressDialog 
                : public IProgressDialog
                , public IOleWindow
                , public IActionProgressDialog
                , public IActionProgress
                , public IObjectWithSite
{
public:
    CProgressDialog();

    // IUnknown
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // IProgressDialog
    STDMETHODIMP StartProgressDialog(HWND hwndParent, IUnknown * punkEnableModless, DWORD dwFlags, LPCVOID pvResevered);
    STDMETHODIMP StopProgressDialog(void);
    STDMETHODIMP SetTitle(LPCWSTR pwzTitle);
    STDMETHODIMP SetAnimation(HINSTANCE hInstAnimation, UINT idAnimation);
    STDMETHODIMP_(BOOL) HasUserCancelled(void);
    STDMETHODIMP SetProgress(DWORD dwCompleted, DWORD dwTotal);
    STDMETHODIMP SetProgress64(ULONGLONG ullCompleted, ULONGLONG ullTotal);
    STDMETHODIMP SetLine(DWORD dwLineNum, LPCWSTR pwzString, BOOL fCompactPath, LPCVOID pvResevered);
    STDMETHODIMP SetCancelMsg(LPCWSTR pwzCancelMsg, LPCVOID pvResevered);
    STDMETHODIMP Timer(DWORD dwAction, LPCVOID pvResevered);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND * phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

    //  IActionProgressDialog
    STDMETHODIMP Initialize(SPINITF flags, LPCWSTR pszTitle, LPCWSTR pszCancel);
    STDMETHODIMP Stop();

    //  IActionProgress
    STDMETHODIMP Begin(SPACTION action, SPBEGINF flags);
    STDMETHODIMP UpdateProgress(ULONGLONG ulCompleted, ULONGLONG ulTotal);
    STDMETHODIMP UpdateText(SPTEXT sptext, LPCWSTR pszText, BOOL fMayCompact);
    STDMETHODIMP QueryCancel(BOOL * pfCancelled);
    STDMETHODIMP ResetCancel();
    STDMETHODIMP End();

    //  IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *punk) { IUnknown_Set(&_punkSite, punk); return S_OK; }
    STDMETHODIMP GetSite(REFIID riid, void **ppv) { *ppv = 0; return _punkSite ? _punkSite->QueryInterface(riid, ppv) : E_FAIL;}

    // Other Public Methods
    static INT_PTR CALLBACK ProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    static DWORD CALLBACK ThreadProc(LPVOID pvThis) { return ((CProgressDialog *) pvThis)->_ThreadProc(); };
    static DWORD CALLBACK SyncThreadProc(LPVOID pvThis) { return ((CProgressDialog *) pvThis)->_SyncThreadProc(); };

private:
    ~CProgressDialog(void);
    LONG       _cRef;

    // State Accessible thru IProgressDialog
    LPWSTR      _pwzTitle;                  // This will be used to cache the value passed to IProgressDialog::SetTitle() until the dialog is displayed
    UINT        _idAnimation;
    HINSTANCE   _hInstAnimation;
    LPWSTR      _pwzLine1;                  // NOTE:
    LPWSTR      _pwzLine2;                  // these are only used to init the dialog, otherwise, we just
    LPWSTR      _pwzLine3;                  // call through on the main thread to update the dialog directly.
    LPWSTR      _pwzCancelMsg;              // If the user cancels, Line 1 & 2 will be cleared and Line 3 will get this msg.

    // Other internal state.
    HWND        _hwndDlgParent;             // parent window for message boxes
    HWND        _hwndProgress;              // dialog/progress window
    DWORD       _dwFirstShowTime;           // tick count when the dialog was first shown (needed so we don't flash it up for an instant)

    SPINITF     _spinitf;
    SPBEGINF    _spbeginf;
    IUnknown   *_punkSite;
    HINSTANCE   _hinstFree;
    
    BOOL        _fCompletedChanged;         // has the _dwCompleted changed since last time?
    BOOL        _fTotalChanged;             // has the _dwTotal changed since last time?
    BOOL        _fChangePosted;             // is there a change pending?
    BOOL        _fCancel;
    BOOL        _fTermThread;
    BOOL        _fThreadRunning;
    BOOL        _fInAction;
    BOOL        _fMinimized;
    BOOL        _fScaleBug;                 // Comctl32's PBM_SETRANGE32 msg will still cast it to an (int), so don't let the high bit be set.
    BOOL        _fNoTime;
    BOOL        _fReleaseSelf;
    BOOL        _fInitialized;

    // Progress Values and Calculations
    DWORD       _dwCompleted;               // progress completed
    DWORD       _dwTotal;                   // total progress
    DWORD       _dwPrevRate;                // previous progress rate (used for computing time remaining)
    DWORD       _dwPrevTickCount;           // the tick count when we last updated the progress time
    DWORD       _dwPrevCompleted;           // the ammount we had completed when we last updated the progress time
    DWORD       _dwLastUpdatedTimeRemaining;// tick count when we last update the "Time remaining" field, we only update it every 5 seconds
    DWORD       _dwLastUpdatedTickCount;    // tick count when SetProgress was last called, used to calculate the rate
    UINT        _iNumTimesSetProgressCalled;// how many times has the user called SetProgress?

    // Private Member Functions
    DWORD _ThreadProc(void);
    DWORD _SyncThreadProc(void);
    BOOL _OnInit(HWND hDlg);
    BOOL _ProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    void _PauseAnimation(BOOL bStop);
    void _UpdateProgressDialog(void);
    void _AsyncUpdate(void);
    HRESULT _SetProgressTime(void);
    void _SetProgressTimeEst(DWORD dwSecondsLeft);
    void _UserCancelled(void);
    HRESULT _DisplayDialog(void);
    void _CompactProgressPath(LPCWSTR pwzStrIn, BOOL fCompactPath, UINT idDlgItem, LPWSTR pwzStrOut, DWORD cchSize);
    HRESULT _SetLineHelper(LPCWSTR pwzNew, LPWSTR * ppwzDest, UINT idDlgItem, BOOL fCompactPath);
    HRESULT _SetTitleBarProgress(DWORD dwCompleted, DWORD dwTotal);
    HRESULT _BeginAction(SPBEGINF flags);
    void _SetModeless(BOOL fModeless);
    void _ShowProgressBar(HWND hwnd);
};

//#define TF_PROGRESS 0xFFFFFFFF
#define TF_PROGRESS 0x00000000

// REVIEW, we should tune this size down as small as we can
// to get smoother multitasking (without effecting performance)
#define MIN_MINTIME4FEEDBACK    5       // is it worth showing estimated time to completion feedback?
#define MS_TIMESLICE            2000    // ms, (MUST be > 1000!) first average time to completion estimate

#define SHOW_PROGRESS_TIMEOUT   1000    // 1 second
#define MINSHOWTIME             2000    // 2 seconds

// progress dialog message
#define PDM_SHUTDOWN     WM_APP
#define PDM_TERMTHREAD  (WM_APP + 1)
#define PDM_UPDATE      (WM_APP + 2)

// progress dialog timer messages
#define ID_SHOWTIMER    1

#ifndef UNICODE
#error "This code will only compile UNICODE for perf reasons.  If you really need an ANSI browseui, write all the code to convert."
#endif // !UNICODE

// compacts path strings to fit into the Text1 and Text2 fields

void CProgressDialog::_CompactProgressPath(LPCWSTR pwzStrIn, BOOL fCompactPath, UINT idDlgItem, LPWSTR pwzStrOut, DWORD cchSize)
{
    WCHAR wzFinalPath[MAX_PATH];
    LPWSTR pwzPathToUse = (LPWSTR)pwzStrIn;

    // We don't compact the path if the dialog isn't displayed yet.
    if (fCompactPath && _hwndProgress)
    {
        RECT rc;
        int cxWidth;

        StrCpyNW(wzFinalPath, (pwzStrIn ? pwzStrIn : L""), ARRAYSIZE(wzFinalPath));

        // get the size of the text boxes
        HWND hwnd = GetDlgItem(_hwndProgress, idDlgItem);
        if (EVAL(hwnd))
        {
            HDC hdc;
            HFONT hfont;
            HFONT hfontSave;

            hdc = GetDC(_hwndProgress);
            hfont = (HFONT)SendMessage(_hwndProgress, WM_GETFONT, 0, 0);
            hfontSave = (HFONT)SelectObject(hdc, hfont);

            GetWindowRect(hwnd, &rc);
            cxWidth = rc.right - rc.left;

            ASSERT(cxWidth >= 0);
            PathCompactPathW(hdc, wzFinalPath, cxWidth);

            SelectObject(hdc, hfontSave);
            ReleaseDC(_hwndProgress, hdc);
        }
        pwzPathToUse = wzFinalPath;
    }

    StrCpyNW(pwzStrOut, (pwzPathToUse ? pwzPathToUse : L""), cchSize);
}

HRESULT CProgressDialog::_SetLineHelper(LPCWSTR pwzNew, LPWSTR * ppwzDest, UINT idDlgItem, BOOL fCompactPath)
{
    WCHAR wzFinalPath[MAX_PATH];

    _CompactProgressPath(pwzNew, fCompactPath, idDlgItem, wzFinalPath, ARRAYSIZE(wzFinalPath));

    Str_SetPtrW(ppwzDest, wzFinalPath); // No, so cache the value for later.

    // Does the dialog exist?
    if (_hwndProgress)
       SetDlgItemText(_hwndProgress, idDlgItem, wzFinalPath);

    return S_OK;
}


HRESULT CProgressDialog::_DisplayDialog(void)
{
    TraceMsg(TF_PROGRESS, "CProgressDialog::_DisplayDialog()");
    // Don't force ourselves into the foreground if a window we parented is already in the foreground:
    
    // This is part of the fix for NT bug 298163 (the confirm replace dialog was deactivated
    // by the progress dialog)
    HWND hwndCurrent = GetForegroundWindow();
    BOOL fChildIsForeground = FALSE;
    while (NULL != (hwndCurrent = GetParent(hwndCurrent)))
    {
        if (_hwndProgress == hwndCurrent)
        {
            fChildIsForeground = TRUE;
            break;
        }
    }
    
    if (fChildIsForeground)
    {
        ShowWindow(_hwndProgress, SW_SHOWNOACTIVATE);
    }
    else
    {
        ShowWindow(_hwndProgress, SW_SHOW);
        SetForegroundWindow(_hwndProgress);
    }
    
    SetFocus(GetDlgItem(_hwndProgress, IDCANCEL));
    return S_OK;
}

DWORD CProgressDialog::_SyncThreadProc()
{
    _InitComCtl32();        // Get ready for the Native Font Control
    _hwndProgress = CreateDialogParam(MLGetHinst(), MAKEINTRESOURCE(DLG_PROGRESSDIALOG),
                                          _hwndDlgParent, ProgressDialogProc, (LPARAM)this);

    _fThreadRunning = (_hwndProgress != NULL);
    return TRUE;
}

DWORD CProgressDialog::_ThreadProc(void)
{
    if (_hwndProgress)
    {
        //  WARNING - copy perf goes way down if this is normal or 
        //  better priority.  the default thread pri should be low.
        //  however if there are situations in which it should be higher,
        //  we can add SPBEGINF bits to support it.
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);
    
        SetTimer(_hwndProgress, ID_SHOWTIMER, SHOW_PROGRESS_TIMEOUT, NULL);

        // Did if finish while we slept?
        if (!_fTermThread)
        {
            // No, so display the dialog.
            MSG msg;

            while(GetMessage(&msg, NULL, 0, 0))
            {
                if (_fTermThread && (GetTickCount() - _dwFirstShowTime) > MINSHOWTIME)
                {
                    // we were signaled to finish and we have been visible MINSHOWTIME,
                    // so its ok to quit
                    break;
                }

                if (!IsDialogMessage(_hwndProgress, &msg))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        DestroyWindow(_hwndProgress);
        _hwndProgress = NULL;
    }

    //  this is for callers that dont call stop
    ENTERCRITICAL;
    _fThreadRunning = FALSE;

    if (_fReleaseSelf)
        Release();
    LEAVECRITICAL;
    return 0;
}

DWORD FormatMessageWrapW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageID, DWORD dwLangID, LPWSTR pwzBuffer, DWORD cchSize, ...)
{
    va_list vaParamList;

    va_start(vaParamList, cchSize);
    DWORD dwResult = FormatMessageW(dwFlags, lpSource, dwMessageID, dwLangID, pwzBuffer, cchSize, &vaParamList);
    va_end(vaParamList);

    return dwResult;
}

DWORD FormatMessageWrapA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageID, DWORD dwLangID, LPSTR pszBuffer, DWORD cchSize, ...)
{
    va_list vaParamList;

    va_start(vaParamList, cchSize);
    DWORD dwResult = FormatMessageA(dwFlags, lpSource, dwMessageID, dwLangID, pszBuffer, cchSize, &vaParamList);
    va_end(vaParamList);

    return dwResult;
}

#define TIME_DAYS_IN_YEAR               365
#define TIME_HOURS_IN_DAY               24
#define TIME_MINUTES_IN_HOUR            60
#define TIME_SECONDS_IN_MINUTE          60

void _FormatMessageWrapper(LPCTSTR pszTemplate, DWORD dwNum1, DWORD dwNum2, LPTSTR pszOut, DWORD cchSize)
{
    // Is FormatMessageWrapW implemented?
    if (g_bRunOnNT5)
    {
        FormatMessageWrapW(FORMAT_MESSAGE_FROM_STRING, pszTemplate, 0, 0, pszOut, cchSize, dwNum1, dwNum2);
    }
    else
    {
        CHAR szOutAnsi[MAX_PATH];
        CHAR szTemplateAnsi[MAX_PATH];

        SHTCharToAnsi(pszTemplate, szTemplateAnsi, ARRAYSIZE(szTemplateAnsi));
        FormatMessageWrapA(FORMAT_MESSAGE_FROM_STRING, szTemplateAnsi, 0, 0, szOutAnsi, ARRAYSIZE(szOutAnsi), dwNum1, dwNum2);
        SHAnsiToTChar(szOutAnsi, pszOut, cchSize);
    }
}


#define CCH_TIMET_TEMPLATE_SIZE         120     // Should be good enough, even with localization bloat.
#define CCH_TIME_SIZE                    170     // Should be good enough, even with localization bloat.

void _SetProgressLargeTimeEst(DWORD dwSecondsLeft, LPTSTR pszOut, DWORD cchSize)
{
    // Yes.
    TCHAR szTemplate[CCH_TIMET_TEMPLATE_SIZE];
    DWORD dwMinutes = (dwSecondsLeft / TIME_SECONDS_IN_MINUTE);
    DWORD dwHours = (dwMinutes / TIME_MINUTES_IN_HOUR);
    DWORD dwDays = (dwHours / TIME_HOURS_IN_DAY);

    if (dwDays)
    {
        dwHours %= TIME_HOURS_IN_DAY;

        // It's more than a day, so display days and hours.
        if (1 == dwDays)
        {
            if (1 == dwHours)
                LoadString(MLGetHinst(), IDS_TIMEEST_DAYHOUR, szTemplate, ARRAYSIZE(szTemplate));
            else
                LoadString(MLGetHinst(), IDS_TIMEEST_DAYHOURS, szTemplate, ARRAYSIZE(szTemplate));
        }
        else
        {
            if (1 == dwHours)
                LoadString(MLGetHinst(), IDS_TIMEEST_DAYSHOUR, szTemplate, ARRAYSIZE(szTemplate));
            else
                LoadString(MLGetHinst(), IDS_TIMEEST_DAYSHOURS, szTemplate, ARRAYSIZE(szTemplate));
        }

        _FormatMessageWrapper(szTemplate, dwDays, dwHours, pszOut, cchSize);
    }
    else
    {
        // It's let than a day, so display hours and minutes.
        dwMinutes %= TIME_MINUTES_IN_HOUR;

        // It's more than a day, so display days and hours.
        if (1 == dwHours)
        {
            if (1 == dwMinutes)
                LoadString(MLGetHinst(), IDS_TIMEEST_HOURMIN, szTemplate, ARRAYSIZE(szTemplate));
            else
                LoadString(MLGetHinst(), IDS_TIMEEST_HOURMINS, szTemplate, ARRAYSIZE(szTemplate));
        }
        else
        {
            if (1 == dwMinutes)
                LoadString(MLGetHinst(), IDS_TIMEEST_HOURSMIN, szTemplate, ARRAYSIZE(szTemplate));
            else
                LoadString(MLGetHinst(), IDS_TIMEEST_HOURSMINS, szTemplate, ARRAYSIZE(szTemplate));
        }

        _FormatMessageWrapper(szTemplate, dwHours, dwMinutes, pszOut, cchSize);
    }
}


// This sets the "Seconds Left" text in the progress dialog
void CProgressDialog::_SetProgressTimeEst(DWORD dwSecondsLeft)
{
    TCHAR szFmt[CCH_TIMET_TEMPLATE_SIZE];
    TCHAR szOut[CCH_TIME_SIZE];
    DWORD dwTime;
    DWORD dwTickCount = GetTickCount();

    // Since the progress time has either a 1 minute or 5 second granularity (depending on whether the total time
    // remaining is greater or less than 1 minute), we only update it every 20 seconds if the total time is > 1 minute,
    // and ever 4 seconds if the time is < 1 minute. This keeps the time from flashing back and forth between 
    // boundaries (eg 45 secondsand 40 seconds remaining).
    if (dwTickCount - _dwLastUpdatedTimeRemaining < (DWORD)((dwSecondsLeft > 60) ? 20000 : 4000))
        return;

    if (_fNoTime)
    {
        szOut[0] = TEXT('\0');
    }
    else
    {
        // Is it more than an hour?
        if (dwSecondsLeft > (TIME_SECONDS_IN_MINUTE * TIME_MINUTES_IN_HOUR))
            _SetProgressLargeTimeEst(dwSecondsLeft, szOut, ARRAYSIZE(szOut));
        else
        {
            // No.
            if (dwSecondsLeft > TIME_SECONDS_IN_MINUTE)
            {
                // Note that dwTime is at least 2, so we only need a plural form
                LoadString(MLGetHinst(), IDS_TIMEEST_MINUTES, szFmt, ARRAYSIZE(szFmt));
                dwTime = (dwSecondsLeft / TIME_SECONDS_IN_MINUTE) + 1;
            }
            else
            {
                LoadString(MLGetHinst(), IDS_TIMEEST_SECONDS, szFmt, ARRAYSIZE(szFmt));
                // Round up to 5 seconds so it doesn't look so random
                dwTime = ((dwSecondsLeft + 4) / 5) * 5;
            }

            wnsprintf(szOut, ARRAYSIZE(szOut), szFmt, dwTime);
        }
    }

    // we are updating now, so set the _dwLastUpdatedTimeRemaining to now
    _dwLastUpdatedTimeRemaining = dwTickCount;

    // update the Time remaining field
    SetDlgItemText(_hwndProgress, IDD_PROGDLG_LINE3, szOut);
}

#define MAX(x, y)    ((x) > (y) ? (x) : (y))
//
// This function updates the ProgressTime field (aka Line3)
//
HRESULT CProgressDialog::_SetProgressTime(void)
{
    DWORD dwSecondsLeft;
    DWORD dwTotal;
    DWORD dwCompleted;
    DWORD dwCurrentRate;
    DWORD dwTickDelta;
    DWORD dwLeft;
    DWORD dwCurrentTickCount;

    _iNumTimesSetProgressCalled++;

    // grab these in the crit sec (because they can change, and we need a matched set)
    ENTERCRITICAL;
    dwTotal = _dwTotal;
    dwCompleted = _dwCompleted;
    dwCurrentTickCount = _dwLastUpdatedTickCount;
    LEAVECRITICAL;

    dwLeft = dwTotal - dwCompleted;

    dwTickDelta = dwCurrentTickCount - _dwPrevTickCount;

    if (!dwTotal || !dwCompleted)
        return dwTotal ? S_FALSE : E_FAIL;

    // we divide the TickDelta by 100 to give tenths of seconds, so if we have recieved an
    // update faster than that, just skip it
    if (dwTickDelta < 100)
    {
        return S_FALSE;
    }
    
    TraceMsg(TF_PROGRESS, "Current tick count = %lu", dwCurrentTickCount);
    TraceMsg(TF_PROGRESS, "Total work     = %lu", dwTotal);
    TraceMsg(TF_PROGRESS, "Completed work = %lu", dwCompleted);
    TraceMsg(TF_PROGRESS, "Prev. comp work= %lu", _dwPrevCompleted);
    TraceMsg(TF_PROGRESS, "Work left      = %lu", dwLeft);
    TraceMsg(TF_PROGRESS, "Tick delta         = %lu", dwTickDelta);

    if (dwTotal < dwCompleted)
    {
        // we can get into this case if we are applying attributes to sparse files
        // on a volume. As we add up the file sizes, we end up with a number that is bigger
        // than the drive size. We get rid of the time so that we wont show the user something
        // completely bogus
        _fNoTime = TRUE;
        dwTotal = dwCompleted + (dwCompleted >> 3);  // fudge dwTotal forward a bit
        TraceMsg(TF_PROGRESS, "!! (Total < Completed), fudging Total work to = %lu", dwTotal);
    }

    if(dwCompleted <= _dwPrevCompleted)
    {
        // woah, we are going backwards, we dont deal w/ negative or zero rates so...
        dwCurrentRate = (_dwPrevRate ? _dwPrevRate : 2);
    }
    else
    {
        // calculate the current rate in points per tenth of a second
        dwTickDelta /= 100;
        if (0 == dwTickDelta)
            dwTickDelta = 1; // Protect from divide by zero

        dwCurrentRate = (dwCompleted - _dwPrevCompleted) / dwTickDelta;
    }

    TraceMsg(TF_PROGRESS, "Current rate = %lu", dwCurrentRate);
    TraceMsg(TF_PROGRESS, "Prev.   rate = %lu", _dwPrevRate);

    // time remaining in seconds (we take a REAL average to smooth out random fluxuations)
    DWORD dwAverageRate = (DWORD)((dwCurrentRate + (_int64)_dwPrevRate * _iNumTimesSetProgressCalled) / (_iNumTimesSetProgressCalled + 1));
    TraceMsg(TF_PROGRESS, "Average rate= %lu", dwAverageRate);

    dwAverageRate = MAX(dwAverageRate, 1); // Protect from divide by zero

    dwSecondsLeft = (dwLeft / dwAverageRate) / 10;
    TraceMsg(TF_PROGRESS, "Seconds left = %lu", dwSecondsLeft);
    TraceMsg(TF_PROGRESS, "");

    // It would be odd to show "1 second left" and then immediately clear it, and to avoid showing 
    // rediculous early estimates, we dont show anything until we have at least 5 data points
    if ((dwSecondsLeft >= MIN_MINTIME4FEEDBACK) && (_iNumTimesSetProgressCalled >= 5))
    {
        // display new estimate of time left
        _SetProgressTimeEst(dwSecondsLeft);
    }

    // set all the _dwPrev stuff for next time
    _dwPrevRate = dwAverageRate;
    _dwPrevTickCount = dwCurrentTickCount;
    _dwPrevCompleted = dwCompleted;

    return S_OK;
}

INT_PTR CALLBACK CProgressDialog::ProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CProgressDialog * ppd = (CProgressDialog *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        ppd = (CProgressDialog *)lParam;
    }

    if (ppd)
        return ppd->_ProgressDialogProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}

// apithk.c entry
STDAPI_(void) ProgressSetMarqueeMode(HWND hwndProgress, BOOL bOn);

void CProgressDialog::_ShowProgressBar(HWND hwnd)
{
    if (hwnd)
    {
        HWND hwndPrgress = GetDlgItem(hwnd, IDD_PROGDLG_PROGRESSBAR);

        ProgressSetMarqueeMode(hwndPrgress, (SPBEGINF_MARQUEEPROGRESS & _spbeginf));

        UINT swp = SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE;

        if (SPBEGINF_NOPROGRESSBAR & _spbeginf)
            swp |= SWP_HIDEWINDOW;
        else
            swp |= SWP_SHOWWINDOW;

        SetWindowPos(hwndPrgress, NULL, 0, 0, 0, 0, swp);
    }
}

BOOL CProgressDialog::_OnInit(HWND hDlg)
{
    //  dont minimize if the caller requests or is modal
    if ((SPINITF_MODAL | SPINITF_NOMINIMIZE) & _spinitf)
    {
        // The caller wants us to remove the Minimize Box or button in the caption bar.
        SHSetWindowBits(hDlg, GWL_STYLE, WS_MINIMIZEBOX, 0);
    }

    _ShowProgressBar(hDlg);
    
    return FALSE;
}

BOOL CProgressDialog::_ProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = TRUE;   // handled

    switch (wMsg)
    {
    case WM_INITDIALOG:
        return _OnInit(hDlg);

    case WM_SHOWWINDOW:
        if (wParam)
        {
            _SetModeless(FALSE);
            ASSERT(_hwndProgress);
            SetAnimation(_hInstAnimation, _idAnimation);

            // set the initial text values
            if (_pwzTitle)  
                SetTitle(_pwzTitle);
            if (_pwzLine1)  
                SetLine(1, _pwzLine1, FALSE, NULL);
            if (_pwzLine2)  
                SetLine(2, _pwzLine2, FALSE, NULL);
            if (_pwzLine3)  
                SetLine(3, _pwzLine3, FALSE, NULL);
        }
        break;

    case WM_DESTROY:
        _SetModeless(TRUE);
        if (_hwndDlgParent)
        {
            if (SHIsChildOrSelf(_hwndProgress, GetFocus()))
                SetForegroundWindow(_hwndDlgParent);
        }
        break;

    case WM_ENABLE:
        if (wParam)
        {
            // we assume that we were previously disabled and thus restart our tick counter
            // because we also naively assume that no work was being done while we were disabled
            _dwPrevTickCount = GetTickCount();
        }

        _PauseAnimation(wParam == 0);
        break;

    case WM_TIMER:
        if (wParam == ID_SHOWTIMER)
        {
            KillTimer(hDlg, ID_SHOWTIMER);

            _DisplayDialog();
 
            _dwFirstShowTime = GetTickCount();
        }
        break;

    case WM_COMMAND:
        if (IDCANCEL == GET_WM_COMMAND_ID(wParam, lParam))
            _UserCancelled();
        break;

    case PDM_SHUTDOWN:
        // Make sure this window is shown before telling the user there
        // is a problem.  Ignore FOF_NOERRORUI here because of the 
        // nature of the situation
        MLShellMessageBox(hDlg, MAKEINTRESOURCE(IDS_CANTSHUTDOWN), NULL, (MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND));
        break;


    case PDM_TERMTHREAD:
        // a dummy id that we can take so that folks can post to us and make
        // us go through the main loop
        break;

    case WM_SYSCOMMAND:
        switch(wParam)
        {
        case SC_MINIMIZE:
            _fMinimized = TRUE;
            break;
        case SC_RESTORE:
            SetTitle(_pwzTitle);    // Restore title to original text.
            _fMinimized = FALSE;
            break;
        }
        fHandled = FALSE;
        break;

    case PDM_UPDATE:
        if (!_fCancel && IsWindowEnabled(hDlg))
        {
            _SetProgressTime();
            _UpdateProgressDialog();
        }
        // we are done processing the update
        _fChangePosted = FALSE;
        break;

    case WM_QUERYENDSESSION:
        // Post a message telling the dialog to show the "We can't shutdown now"
        // dialog and return to USER right away, so we don't have to worry about
        // the user not clicking the OK button before USER puts up its "this
        // app didn't respond" dialog
        PostMessage(hDlg, PDM_SHUTDOWN, 0, 0);

        // Make sure the dialog box procedure returns FALSE
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
        return(TRUE);

    default:
        fHandled = FALSE;   // Not handled
    }

    return fHandled;
}


// This is used to asyncronously update the progess dialog.
void CProgressDialog::_AsyncUpdate(void)
{
    if (!_fChangePosted && _hwndProgress)   // Prevent from posting too many messages.
    {
        // set the flag first because with async threads
        // the progress window could handle it and clear the
        // bit before we set it.. then we'd lose further messages
        // thinking that one was still pending
        _fChangePosted = TRUE;
        if (!PostMessage(_hwndProgress, PDM_UPDATE, 0, 0))
        {
            _fChangePosted = FALSE;
        }
    }
}

void CProgressDialog::_UpdateProgressDialog(void)
{
    if (_fTotalChanged)
    {
        _fTotalChanged = FALSE;
        if (0x80000000 & _dwTotal)
            _fScaleBug = TRUE;
            
        SendMessage(GetDlgItem(_hwndProgress, IDD_PROGDLG_PROGRESSBAR), PBM_SETRANGE32, 0, (_fScaleBug ? (_dwTotal >> 1) : _dwTotal));
    }

    if (_fCompletedChanged)
    {
        _fCompletedChanged = FALSE;
        SendMessage(GetDlgItem(_hwndProgress, IDD_PROGDLG_PROGRESSBAR), PBM_SETPOS, (WPARAM) (_fScaleBug ? (_dwCompleted >> 1) : _dwCompleted), 0);
    }
}

void CProgressDialog::_PauseAnimation(BOOL bStop)
{
    // only called from within the hwndProgress wndproc so assum it's there
    if (_hwndProgress)
    {
        if (bStop)
        {
            Animate_Stop(GetDlgItem(_hwndProgress, IDD_PROGDLG_ANIMATION));
        }
        else
        {
            Animate_Play(GetDlgItem(_hwndProgress, IDD_PROGDLG_ANIMATION), -1, -1, -1);
        }
    }
}

void CProgressDialog::_UserCancelled(void)
{
    // Don't hide the dialog because the caller may not pole
    // ::HasUserCancelled() for quite a while.
    // ShowWindow(hDlg, SW_HIDE);
    _fCancel = TRUE;

    // give minimal feedback that the cancel click was accepted
    EnableWindow(GetDlgItem(_hwndProgress, IDCANCEL), FALSE);

    // If the user cancels, Line 1 & 2 will be cleared and Line 3 will get this msg.
    if (!_pwzCancelMsg)
    {
        WCHAR wzDefaultMsg[MAX_PATH];

        LoadStringW(MLGetHinst(), IDS_DEFAULT_CANCELPROG, wzDefaultMsg, ARRAYSIZE(wzDefaultMsg));
        Str_SetPtr(&_pwzCancelMsg, wzDefaultMsg);
    }

    SetLine(1, L"", FALSE, NULL);
    SetLine(2, L"", FALSE, NULL);
    SetLine(3, _pwzCancelMsg, FALSE, NULL);
}

HRESULT CProgressDialog::Initialize(SPINITF flags, LPCWSTR pszTitle, LPCWSTR pszCancel)
{
    if (!_fInitialized)
    {
        _spinitf = flags;
        if (pszTitle)
            SetTitle(pszTitle);
        if (pszCancel)
            SetCancelMsg(pszCancel, NULL);

        _fInitialized = TRUE;

        return S_OK;
    }
    
    return E_UNEXPECTED;
}

void CProgressDialog::_SetModeless(BOOL fModeless)
{
    // if the user is requesting a modal window, disable the parent now.
    if (_spinitf & SPINITF_MODAL)
    {
        if (FAILED(IUnknown_EnableModless(_punkSite, fModeless))
        && _hwndDlgParent)
        {
            EnableWindow(_hwndDlgParent, fModeless);
        }
    }
}

HRESULT CProgressDialog::_BeginAction(SPBEGINF flags)
{
    _spbeginf = flags;

    _fTermThread = FALSE;
    _fTotalChanged = TRUE;

    if (!_fThreadRunning)
    {
        SHCreateThread(CProgressDialog::ThreadProc, this, CTF_FREELIBANDEXIT, CProgressDialog::SyncThreadProc);
        //  _fThreadRunning is set in _SyncThreadProc()
    }

    if (_fThreadRunning)
    {
        _fInAction = TRUE;
        _ShowProgressBar(_hwndProgress);

        // initialize the _dwPrev counters
        _dwPrevRate = 0;
        _dwPrevCompleted = 0;
        _dwPrevTickCount = GetTickCount();

        TraceMsg(TF_PROGRESS, "Initial tick count = %lu", _dwPrevTickCount);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

#define ACTIONENTRY(a, dll, id)     {a, dll, id}

#define c_szShell32 "shell32.dll"
#define c_szShdocvw "shdocvw.dll"
const static struct
{
    SPACTION action;
    LPCSTR pszDll;
    UINT id;
}
c_spActions[] =
{
    ACTIONENTRY(SPACTION_MOVING, c_szShell32,   160),           // IDA_FILEMOVE
    ACTIONENTRY(SPACTION_COPYING, c_szShell32,   161),          // IDA_FILECOPY
    ACTIONENTRY(SPACTION_RECYCLING, c_szShell32,   162),        // IDA_FILEDEL
    ACTIONENTRY(SPACTION_APPLYINGATTRIBS, c_szShell32,   165),  // IDA_APPLYATTRIBS
    ACTIONENTRY(SPACTION_DOWNLOADING, c_szShdocvw, 0x100),
    ACTIONENTRY(SPACTION_SEARCHING_INTERNET, c_szShell32, 166), // IDA_ISEARCH
    ACTIONENTRY(SPACTION_SEARCHING_FILES, c_szShell32, 150)     // IDA_SEARCH
};

HRESULT CProgressDialog::Begin(SPACTION action, SPBEGINF flags)
{
    if (_fInAction || !_fInitialized)
        return E_FAIL;

    HRESULT hr = S_OK;

    for (int i = 0; i < ARRAYSIZE(c_spActions); i++)
    {
        if (c_spActions[i].action == action)
        {
            HINSTANCE hinst = LoadLibraryA(c_spActions[i].pszDll);
            if (hinst)
            {
                hr = SetAnimation(hinst, c_spActions[i].id);

                if (_hinstFree)
                    FreeLibrary(_hinstFree);

                _hinstFree = hinst;
            }
            break;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (!_hwndDlgParent)
            IUnknown_GetWindow(_punkSite, &_hwndDlgParent);
            
        hr = _BeginAction(flags);
    }

    return hr;
}

#define SPINIT_MASK         (SPINITF_MODAL | SPINITF_NOMINIMIZE)
#define SPBEGIN_MASK        0x1F

// IProgressDialog

HRESULT CProgressDialog::StartProgressDialog(HWND hwndParent, IUnknown * punkNotUsed, DWORD dwFlags, LPCVOID pvResevered)
{
    if (_fInAction)
        return S_OK;

    HRESULT hr = Initialize(dwFlags & SPINIT_MASK, NULL, NULL);

    if (SUCCEEDED(hr))
    {
        _fNoTime = dwFlags & PROGDLG_NOTIME;

        // we dont Save punkNotUsed 
        _hwndDlgParent = hwndParent;
        hr = _BeginAction(dwFlags & SPBEGIN_MASK);
    }    

    return hr;
}

HRESULT CProgressDialog::End()
{
    ASSERT(_fInitialized && _fInAction);
    //  possibly need to pop stack or change state
    _fInAction = FALSE;
    _spbeginf = 0;

    return S_OK;
}

HRESULT CProgressDialog::Stop()
{
    ASSERT(!_fInAction);
    BOOL fFocusParent = FALSE; 
    
    // shut down the progress dialog
    if (_fThreadRunning)
    {
        ASSERT(_hwndProgress);

        _fTermThread = TRUE;
        PostMessage(_hwndProgress, PDM_TERMTHREAD, 0, 0);
    }
    return S_OK;
}

HRESULT CProgressDialog::StopProgressDialog(void)
{
    //  callers can call this over and over
    if (_fInAction)
        End();
    return Stop();
}

HRESULT CProgressDialog::SetTitle(LPCWSTR pwzTitle)
{
    HRESULT hr = S_OK;

    // Does the dialog exist?
    if (_hwndProgress)
    {
        // Yes, so put the value directly into the dialog.
        if (!SetWindowTextW(_hwndProgress, (pwzTitle ? pwzTitle : L"")))
            hr = E_FAIL;
    }
    else
        Str_SetPtrW(&_pwzTitle, pwzTitle);

    return hr;
}

HRESULT CProgressDialog::SetAnimation(HINSTANCE hInstAnimation, UINT idAnimation)
{
    HRESULT hr = S_OK;

    _hInstAnimation = hInstAnimation;
    _idAnimation = idAnimation;

    // Does the dialog exist?
    if (_hwndProgress)
    {
        if (!Animate_OpenEx(GetDlgItem(_hwndProgress, IDD_PROGDLG_ANIMATION), _hInstAnimation, IntToPtr(_idAnimation)))
            hr = E_FAIL;
    }

    return hr;
}

    
HRESULT CProgressDialog::UpdateText(SPTEXT sptext, LPCWSTR pszText, BOOL fMayCompact)
{
    if (_fInitialized)
        return SetLine((DWORD)sptext, pszText, fMayCompact, NULL);
    else
        return E_UNEXPECTED;
}
    
HRESULT CProgressDialog::SetLine(DWORD dwLineNum, LPCWSTR pwzString, BOOL fCompactPath, LPCVOID pvResevered)
{
    HRESULT hr = E_INVALIDARG;

    switch (dwLineNum)
    {
    case 1:
        hr = _SetLineHelper(pwzString, &_pwzLine1, IDD_PROGDLG_LINE1, fCompactPath);
        break;
    case 2:
        hr = _SetLineHelper(pwzString, &_pwzLine2, IDD_PROGDLG_LINE2, fCompactPath);
        break;
    case 3:
        if (_spbeginf & SPBEGINF_AUTOTIME)
        {
            // you cant change line3 directly if you want PROGDLG_AUTOTIME, because
            // this is updated by the progress dialog automatically
            // unless we're cancelling
            ASSERT(_fCancel);
            hr = _fCancel ? S_OK : E_INVALIDARG;
            break;
        }
        hr = _SetLineHelper(pwzString, &_pwzLine3, IDD_PROGDLG_LINE3, fCompactPath);
        break;

    default:
        ASSERT(0);
    }

    return hr;
}

HRESULT CProgressDialog::SetCancelMsg(LPCWSTR pwzCancelMsg, LPCVOID pvResevered)
{
    Str_SetPtr(&_pwzCancelMsg, pwzCancelMsg);              // If the user cancels, Line 1 & 2 will be cleared and Line 3 will get this msg.
    return S_OK;
}


HRESULT CProgressDialog::Timer(DWORD dwAction, LPCVOID pvResevered)
{
    HRESULT hr = E_NOTIMPL;

    switch (dwAction)
    {
    case PDTIMER_RESET:
        _dwPrevTickCount = GetTickCount();
        hr = S_OK;
        break;
    }

    return hr;
}

HRESULT CProgressDialog::SetProgress(DWORD dwCompleted, DWORD dwTotal)
{
    DWORD dwTickCount = GetTickCount(); // get the tick count before taking the critical section

    // we grab the crit section in case the UI thread is trying to access
    // _dwCompleted, _dwTotal or _dwLastUpdatedTickCount to do its time update.
    ENTERCRITICAL;
    if (_dwCompleted != dwCompleted)
    {
        _dwCompleted = dwCompleted;
        _fCompletedChanged = TRUE;
    }

    if (_dwTotal != dwTotal)
    {
        _dwTotal = dwTotal;
        _fTotalChanged = TRUE;
    }
 
    if (_fCompletedChanged || _fTotalChanged)
    {
        _dwLastUpdatedTickCount = dwTickCount;
    }

    LEAVECRITICAL;

#ifdef DEBUG
    if (_dwCompleted > _dwTotal)
    {
        TraceMsg(TF_WARNING, "CProgressDialog::SetProgress(_dwCompleted > _dwTotal ?!?!)");
    }
#endif

    if (_fCompletedChanged || _fTotalChanged)
    {
        // something changed, so update the progress dlg
        _AsyncUpdate();
    }

    TraceMsg(TF_PROGRESS, "CProgressDialog::SetProgress(Complete=%#08lx, Total=%#08lx)", dwCompleted, dwTotal);
    if (_fMinimized)
    {
        _SetTitleBarProgress(dwCompleted, dwTotal);
    }

    return S_OK;
}

HRESULT CProgressDialog::UpdateProgress(ULONGLONG ulCompleted, ULONGLONG ulTotal)
{
    if (_fInitialized && _fInAction)
        return SetProgress64(ulCompleted, ulTotal);
    else
        return E_UNEXPECTED;
}


HRESULT CProgressDialog::SetProgress64(ULONGLONG ullCompleted, ULONGLONG ullTotal)
{
    ULARGE_INTEGER uliCompleted, uliTotal;
    uliCompleted.QuadPart = ullCompleted;
    uliTotal.QuadPart = ullTotal;

    // If we are using the top 32 bits, scale both numbers down.
    // Note that I'm using the attribute that dwTotalHi is always
    // larger than dwCompletedHi
    ASSERT(uliTotal.HighPart >= uliCompleted.HighPart);
    while (uliTotal.HighPart)
    {
        uliCompleted.QuadPart >>= 1;
        uliTotal.QuadPart >>= 1;
    }

    ASSERT((0 == uliCompleted.HighPart) && (0 == uliTotal.HighPart));       // Make sure we finished scaling down.
    return SetProgress(uliCompleted.LowPart, uliTotal.LowPart);
}

HRESULT CProgressDialog::_SetTitleBarProgress(DWORD dwCompleted, DWORD dwTotal)
{
    TCHAR szTemplate[MAX_PATH];
    TCHAR szTitle[MAX_PATH];
    int nPercent = 0;

    if (dwTotal)    // Disallow divide by zero.
    {
        // Will scaling it up cause a wrap?
        if ((100 * 100) <= dwTotal)
        {
            // Yes, so scale down.
            nPercent = (dwCompleted / (dwTotal / 100));
        }
        else
        {
            // No, so scale up.
            nPercent = ((100 * dwCompleted) / dwTotal);
        }
    }

    LoadString(MLGetHinst(), IDS_TITLEBAR_PROGRESS, szTemplate, ARRAYSIZE(szTemplate));
    wnsprintf(szTitle, ARRAYSIZE(szTitle), szTemplate, nPercent);
    SetWindowText(_hwndProgress, szTitle);

    return S_OK;
}

HRESULT CProgressDialog::ResetCancel()
{
    _fCancel = FALSE;
    if (_pwzLine1)  
        SetLine(1, _pwzLine1, FALSE, NULL);
    if (_pwzLine2)  
        SetLine(2, _pwzLine2, FALSE, NULL);
    if (_pwzLine3)  
        SetLine(3, _pwzLine3, FALSE, NULL);

    return S_OK;
}

HRESULT CProgressDialog::QueryCancel(BOOL * pfCancelled)
{
    *pfCancelled = HasUserCancelled();
    return S_OK;
}

/****************************************************\
    DESCRIPTION:
    This queries the progress dialog for a cancel and yields.
    it also will show the progress dialog if a certain amount of time has passed
    
     returns:
        TRUE      cacnel was pressed, abort the operation
        FALSE     continue
\****************************************************/
BOOL CProgressDialog::HasUserCancelled(void)
{
    if (!_fCancel && _hwndProgress)
    {
        MSG msg;

        // win95 handled messages in here.
        // we need to do the same in order to flush the input queue as well as
        // for backwards compatability.

        // we need to flush the input queue now because hwndProgress is
        // on a different thread... which means it has attached thread inputs
        // inorder to unlock the attached threads, we need to remove some
        // sort of message until there's none left... any type of message..
        while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (!IsDialogMessage(_hwndProgress, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        if (_fTotalChanged || _fCompletedChanged)
            _AsyncUpdate();
    }

    return _fCancel;
}

// IOleWindow
HRESULT CProgressDialog::GetWindow(HWND * phwnd)
{
    HRESULT hr = E_FAIL;

    *phwnd = _hwndProgress;
    if (_hwndProgress)
        hr = S_OK;

    return hr;
}

HRESULT CProgressDialog::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CProgressDialog, IProgressDialog),
        QITABENT(CProgressDialog, IActionProgressDialog),
        QITABENT(CProgressDialog, IActionProgress),
        QITABENT(CProgressDialog, IObjectWithSite),
        QITABENT(CProgressDialog, IOleWindow),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CProgressDialog::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CProgressDialog::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        if (_fThreadRunning)
        {
            //  need to keep this thread's ref around
            //  for a while longer to avoid the race 
            //  to destroy this object on the dialog thread
            AddRef();
            ENTERCRITICAL;
            if (_fThreadRunning)
            {
                //  we call addref
                AddRef();
                _fReleaseSelf = TRUE;
            }
            LEAVECRITICAL;
            Stop();
            cRef = Release();
        }
        else
        {
            delete this;
        }
    }
        
    return cRef;
}

CProgressDialog::CProgressDialog() : _cRef(1)
{
    DllAddRef();

    // ASSERT zero initialized because we can only be created in the heap. (Private destructor)
    ASSERT(!_pwzLine1);
    ASSERT(!_pwzLine2);
    ASSERT(!_pwzLine3);
    ASSERT(!_fCancel);
    ASSERT(!_fTermThread);
    ASSERT(!_fInAction);
    ASSERT(!_hwndProgress);
    ASSERT(!_hwndDlgParent);
    ASSERT(!_fChangePosted);
    ASSERT(!_dwLastUpdatedTimeRemaining);
    ASSERT(!_dwCompleted);
    ASSERT(!_fCompletedChanged);
    ASSERT(!_fTotalChanged);
    ASSERT(!_fMinimized);

    _dwTotal = 1;     // Init to Completed=0, Total=1 so we are at 0%.
}

CProgressDialog::~CProgressDialog()
{
    ASSERT(!_fInAction);
    ASSERT(!_fThreadRunning);

    Str_SetPtrW(&_pwzTitle, NULL);
    Str_SetPtrW(&_pwzLine1, NULL);
    Str_SetPtrW(&_pwzLine2, NULL);
    Str_SetPtrW(&_pwzLine3, NULL);

    if (_hinstFree)
        FreeLibrary(_hinstFree);

    DllRelease();
}

STDAPI CProgressDialog_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    *ppunk = NULL;
    CProgressDialog * pProgDialog = new CProgressDialog();
    if (pProgDialog) 
    {
        *ppunk = SAFECAST(pProgDialog, IProgressDialog *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\regkeys.h ===
#define  SZ_REGKEY_IEXPLOREA     "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE"
#define  SZ_REGKEY_IEXPLORE      TEXT(SZ_REGKEY_IEXPLOREA)
#define  c_szIexploreKey         SZ_REGKEY_IEXPLORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\resource.h ===
//------------------------------------------------------------
// M E N U  I D E N T I F I E R S
//------------------------------------------------------------
#include "legacy/mnbandid.h"

#define MENU_BANDSITE1          0x100
#define MENU_BANDSITE2          0x101
// in legacy/mnbandid.h #define MENU_ISFBAND            0x102
#define MENU_WEBBAR             0x103
// (unused)                     0x104
#define MENU_BROWBAND           0x105  // was MENU_IWBBAND
#define MENU_MAILNEWS           0x106
#define MENU_FULL               0x107
#define MENU_ITOOLBAR           0x108
#define MENU_SYSPOPUP           0x109
#define MENU_TEMPLATE           0x10A
#define MENU_PREMERGED          0x10B
#define MENU_DESKBARAPP         0x10C
// in legacy/mnbandid.h #define MENU_MNFOLDERCONTEXT    0x10D
#define MENU_TBMENU             0x10E
#define MENU_SM_CONTEXTMENU     0x10F

#define MENU_AC_CONTEXTMENU     0x112
#define MENU_SCRDEBUG           0x121

#define  RSVIDM_FIRST           0x1
#define  RSVIDM_OPEN            RSVIDM_FIRST+0
#define  RSVIDM_NEWFOLDER       RSVIDM_FIRST+1
#define  RSVIDM_LAST            RSVIDM_NEWFOLDER /* Adjust me if you add new RSVIDM_s. */

#define IDSYSPOPUP_CLOSE        0x1
#define IDSYSPOPUP_FIRST        0x2
#define IDSYSPOPUP_LAST         0x7fff

//--------------------------------------------------------------
// S T R I N G   I D E N T I F I E R S
//--------------------------------------------------------------
#define IDS_CONFIRMCLOSEBAND    0x3000
#define IDS_CONFIRMCLOSEBAR     0x3001
#define IDS_CONFIRMCLOSETITLE   0x3002
#define IDS_CONFIRMCLOSETEXT    0x3003
#define IDS_ALREADYAUTOHIDEBAR  0x3004
#define IDS_WEBBARTITLE         0x3005      // singular
#define IDS_EXPLORING           0x3006

#define IDS_DISCONNECTERROR     0x3007
#define IDS_NETERROR            0x3008
#define IDS_CABINET             0x3009
#define IDS_NOTADIR             0x300A
#define IDS_FWLINK_HELPISLEGAL  0x300B
#define IDS_CANTISFBAND         0x300C

#define IDS_SMALLICONS          0x300D
#define IDS_LARGEICONS          0x300E

#define IDS_TEXTLABELS          0x300F
#define IDS_NOTEXTLABELS        0x3010
#define IDS_PARTIALTEXT         0x3011
#define IDS_WEBBARSTITLE        0x3012      // plural

#define IDS_SHURL_ERR_TITLE                 0x3040
#define IDS_SHURL_ERR_PARSE_FAILED          0x3041
#define IDS_SHURL_ERR_PARSE_NOTALLOWED      0x3042

#ifdef UNIX
#define IDS_SHURL_ERR_NOASSOC               0x3044
#endif

#define IDS_SETHOME_TITLE                   0x3050
#define IDS_SETHOME_TEXT                    0x3051
#define IDS_SETSEARCH_TITLE                 0x3052
#define IDS_SETSEARCH_TEXT                  0x3053

// in legacy/mnbandid.h #define IDS_QLINKS                          0x3061
#define IDS_QLAUNCHAPPDATAPATH              0x3062
#define IDS_NEWFSBANDTITLE                  0x3063
#define IDS_NEWFSBANDCAPTION                0x3064


//// address band strings
#define IDS_ADDRBAND_ACCELLERATOR        0x3100
#define IDS_ADDRBAND_DEVICE_NOTAVAILABLE 0x3101

#define IDS_DESKTOP             0x3140
#define IDS_WINDOWSNT           0x3141

#define IDS_ABOUTWINDOWS        0x3143

#define IDS_TITLE               0x3145
#define IDS_ABOUTWINDOWS9X      0x3146
#define IDS_ABOUTWINDOWSNT      0x3147


/// itbar strings
#define IDS_IE_TB_LABELS        0x3150

#define IDS_WEB_TB_TEXTROWS      0x3161
#define IDS_SHELL_TB_TEXTROWS    0x3162
#define IDS_TB_WIDTH_EXTRA_HIRES 0x3163
#define IDS_TB_WIDTH_EXTRA_LORES 0x3164

#define IDS_SEARCH_BAR_LABELS   0x3166
#define IDS_SHELL_TB_LABELS     0x3167
#define IDS_CACHE_BAR_LABELS    0x3168 // FEATURE: This may not be used any longer

#define IDS_ADDRESS_TB_LABELS   0x3170
#define IDS_GO_TOOLTIP          0x3171
#define IDS_BANDSITE_CLOSE_LABELS 0x3172

#define IDS_EDITPAGE            0x3173
#define IDS_EDITWITH            0x3174

#define IDS_EXCEPTIONMSGSH      0x3175
#define IDS_EXCEPTIONMSG        0x3176
#define IDS_EXCEPTIONNOMEMORY   0x3177
#define IDS_EDITVERB            0x3178



#define IDS_DEF_HOME    998  //// WARNING!!! DO NOT CHANGE THESE VALUES
#define IDS_DEF_SEARCH  999 //// WARNING!!!  INETCPL RELIES ON THEM

#define IDS_QLURL1      0x3200     // URLs for Quicklinks
#define IDS_QLURL2      0x3201     // Important: Assumes all IDs for
#define IDS_QLURL3      0x3202     // QLURLs, QLTEXT, and TBBUTTONS
#define IDS_QLURL4      0x3203     // are consecutive
#define IDS_QLURL5      0x3204

#define IDS_QLTEXT1     0x3210
#define IDS_QLTEXT2     0x3211
#define IDS_QLTEXT3     0x3212
#define IDS_QLTEXT4     0x3213
#define IDS_QLTEXT5     0x3214

#define IDS_ACC_OPEN            0x3232
#define IDS_ACC_CLOSE           0x3233
#define IDS_ACC_EXEC            0x3234
#define IDS_ACC_APP             0x3235
#define IDS_ACC_APPMB           0x3236
#define IDS_ACC_SEP             0x3237
#define IDS_ACC_CHEVRON         0x3238
#define IDS_ACC_ALT             0x3239
#define IDS_CHEVRONTIP          0x3240
#define IDS_CHEVRONTIPTITLE     0x3241


#define IDS_URL_LOGO            0x3250
// in legacy\mnbandid.h #define IDS_EMPTY                0x3251

#define IDS_BAND_ADDRESS         0x3260
#define IDS_BAND_SEARCH          0x3261


#ifdef UNIX
#define IDS_BAND_MESSAGE         0x3265
#endif
#define IDS_BAND_ADDRESS2        0x3266


#define IDS_WORKINGOFFLINETIP   0x3269
#define IDS_WORKINGOFFLINE      0x3270

//unused                        0x3271
#define IDS_ERROR_GOTOA         0x3272
#define IDS_INTERNETOPTIONS     0x3273
#define IDS_MIXEDZONE           0x3274
#define IDS_UNKNOWNZONE         0x3275
#define IDS_CLOSEANYWAY         0x3276
#define IDS_TREETITLE           0x3277
#define IDS_ERROR_GOTOW         0x3278
#define IDS_FOLDEROPTIONS       0x3279

#define IDS_CLOSE               0x3280
#define IDS_MINIMIZE            0x3281
#define IDS_RESTORE             0x3282

#define IDS_CANCELFILEDOWNLOAD      0x3283
#define IDS_FILEDOWNLOADCAPTION     0x3284

#define IDS_CHANNEL                 0x3285
#define IDS_CHANBAR_SHORTCUT_MSG    0x3286
#define IDS_CHANBAR_SHORTCUT_TITLE  0x3287

#define IDS_QUICKCOMPLETE      0x3288

#define IDS_IE_INFOTIP         0x3289
#define IDS_IE_DISPLAYNAME     0x328a

#define IDS_FAVORITEBROWSE     0x3290
#define IDS_FAVORITES          0x3291

#define IDS_FAVS_FOLDER        0x3292
#define IDS_FAVS_BROWSETEXT    0x3293
#define IDS_FAVS_NEWFOLDERBUTTON 0x3294
#define IDS_FAVS_NAME          0x3295
#define IDS_FAVS_ADVANCED      0x3296
// in legacy\mnbandid.h #define IDS_FAVS_ADDTOFAVORITES 0x3297
#define IDS_FAVS_SAVE           0x3298
#define IDS_FAVS_TITLE          0x3299
#define IDS_FAVS_SUBSCRIBE_TEXT 0x329A
#define IDS_FAVS_SUBSCRIBE      0x329B
// in legacy\mnbandid.h #define IDS_FAVS_INVALIDFN      0x329C
#define IDS_FAVS_FNTOOLONG      0x329D
#define IDS_FAVS_MORE           0x329E
#define IDS_FAVS_FILEEXISTS     0x329F

#define IDS_FAV_UNABLETOCREATE  0x33A0
#define IDS_NEED_CHANNEL_PASSWORD     0x33A1

#define IDS_SUBS_UNKNOWN        0x32A2
#define IDS_CHANNELS_FILEEXISTS 0x32A3

#define MH_POPUPS                       700
#define MH_ITEMS                        (800-FCIDM_FIRST)
#define MH_TTBASE                       (MH_ITEMS - (FCIDM_LAST - FCIDM_FIRST))
#define IDS_TT_PREVIOUSFOLDER           (MH_TTBASE+FCIDM_PREVIOUSFOLDER)
#define IDS_TT_NAVIGATEBACK             (MH_TTBASE + FCIDM_NAVIGATEBACK)
#define IDS_TT_NAVIGATEFORWARD          (MH_TTBASE + FCIDM_NAVIGATEFORWARD)
#define IDS_TT_FAVORITES                (MH_TTBASE + FCIDM_ORGANIZEFAVORITES)
#define IDS_TT_ADDTOFAVORITES           (MH_TTBASE + FCIDM_ADDTOFAVORITES)
#define IDS_TT_DRIVES                   0x3215
#define IDS_TT_VIEWTREE                 (MH_TTBASE + FCIDM_VIEWTREE)

#define IDS_SM_SEARCHASSIST         0x32B0  // search menu hard coded search assistant
#define IDS_SM_SEARCHASSIST_HELP    0x32B1
#define IDS_SM_SEARCHCFG            0x32B2  // search menu hard coded configuration
#define IDS_SM_SEARCHCFG_HELP       0x32B3

#define IDS_WARNING                 0x3301
#define IDS_ALLUSER_WARNING         0x3302
#define IDS_ALLUSER_WARNING_TITLE   0x3303

#define IDS_INETFIND_TEXT           0x3304
#define IDS_INETFIND_HELP           0x3305

#define IDS_FORTEZZA_MENU           0x3308
#define IDS_FORTEZZA_LOGIN          0x3309
#define IDS_FORTEZZA_LOGOUT         0x330a
#define IDS_FORTEZZA_CHANGE         0x330b

#define IDS_ELLIPSES                0x3340
#define IDS_SEARCHFOR               0x3341
#define IDS_SEARCHFORCMD            0x3342

#define IDS_NEW_WINDOW              0x3350

#define IDS_ADDRESSBANDTEXT         0x3351
// in legacy\mnbandid.h #define IDS_LINKSBANDTEXT           0x3352
#define IDS_MEDIABANDTEXT           0x3353
#define IDS_MEDIABANDSEARCH         0x3354

#define IDS_MI_BACK_HISTORY         0x3371

// descriptive text to CATIDs, see also shdocvw!
#define IDS_CATDESKBAND             0x3400
#define IDS_CATINFOBAND             0x3401
#define IDS_CATCOMMBAND             0x3402

// media bar

#define FCIDM_MEDIABAND_MUTE            0x3502
#define FCIDM_MEDIABAND_VOLUME          0x3503

#define FCIDM_MEDIABAND_PLAY            0x3505
#define FCIDM_MEDIABAND_STOP            0x3506
#define FCIDM_MEDIABAND_NEXT            0x3508
#define FCIDM_MEDIABAND_PREVIOUS        0x3509
#define FCIDM_MEDIABAND_SEEK            0x350a
#define FCIDM_MEDIABAND_PLAYINFO        0x350b
#define FCIDM_MEDIABAND_POPOUT          0x350c

#define IDM_MEDIA_RADIO_GOTO            0x3524
#define IDM_MEDIA_BROADBAND_GUIDE       0x3529
#define IDM_MEDIA_INTERNET              0x3531
#define IDM_MEDIA_GENERIC               0x3532
#define IDM_MEDIA_FAVORITES             0x3533
#define IDM_MEDIA_FAVORITES_PLACEHOLDER 0x3534

#define IDM_MEDIA_MUSIC_MRU             0x3540

#define IDB_MEDIABAND_BG_BASE           0x351f
#define IDB_MEDIABAND_BG_BC             0x3520
#define IDB_MEDIABAND_BG_BL             0x3521
#define IDB_MEDIABAND_BG_BR             0x3522
#define IDB_MEDIABAND_BG_MC             0x3523
#define IDB_MEDIABAND_BG_ML             0x3524
#define IDB_MEDIABAND_BG_MR             0x3525
#define IDB_MEDIABAND_BG_TC             0x3526
#define IDB_MEDIABAND_BG_TL             0x3527
#define IDB_MEDIABAND_BG_TR             0x3528

#define IDB_MEDIABAND_PLAY              0x3529
#define IDB_MEDIABAND_PAUSE                0x352a
#define IDB_MEDIABAND_BACK               0x352b
#define IDB_MEDIABAND_NEXT               0x352c
#define IDB_MEDIABAND_STOP               0x352d
#define IDB_MEDIABAND_MUTE               0x352e
#define IDB_MEDIABAND_POPOUT               0x3530
#define IDB_MEDIABAND_POPIN             0x3531

#define IDB_MEDIABAND_SEEKFILL          0x3533
#define IDB_MEDIABAND_SEEKBACK         0x3534
#define IDB_MEDIABAND_SEEKGRIPPER      0x3535
#define IDB_MEDIABAND_VOLTAB            0x3536
#define IDB_MEDIABAND_VOLBKGND          0x3537
#define IDB_MEDIABAND_VOLFILL           0x3538


#define IDB_MEDIABAND_PLAY16              0x3539
#define IDB_MEDIABAND_PAUSE16                0x353a
#define IDB_MEDIABAND_BACK16               0x353b
#define IDB_MEDIABAND_NEXT16               0x353c
#define IDB_MEDIABAND_STOP16               0x353d
#define IDB_MEDIABAND_MUTE16               0x353e
#define IDB_MEDIABAND_POPOUT16               0x3540
#define IDB_MEDIABAND_POPIN16             0x3541

#define IDB_MEDIABAND_SEEKFILL16          0x3543
#define IDB_MEDIABAND_SEEKBACK16         0x3544
#define IDB_MEDIABAND_SEEKGRIPPER16      0x3545
#define IDB_MEDIABAND_VOLTAB16            0x3542
#define IDB_MEDIABAND_VOLBKGND16          0x3549
#define IDB_MEDIABAND_VOLFILL16           0x3548


#define IDB_TB_MEDIA_DEFAULT            0x3546 // You should prop any change to selfreg.inx !!!
#define IDB_TB_MEDIA_HOT                0x3547 // You should prop any change to selfreg.inx !!!

#define MENU_MEDIA_GENERIC              0x3551

#define IDD_MEDIA_RESETMIMEPROMPT       0x3558
#define IDD_MEDIA_TAKEOVERMIMEPROMPT    0x3559

#define IDM_MEDIA_ADDTOFAVORITES        0x3561
#define IDM_MEDIA_PLAYINBAR             0x3562
#define IDM_MEDIA_ASKTYPES              0x3563
#define IDM_MEDIA_RESETTYPES            0x3564
#define IDM_MEDIA_TAKEOVERTYPES         0x3565
#define IDM_MEDIA_SETTINGS              0x3568
#define IDM_MEDIA_PLAYINDEFAULT         0x3569
#define IDM_MEDIA_PLAY                  0x356D

#define FCIDM_PLAYITEM_START            0x3570
#define FCIDM_PLAYITEM_END              0x4000

#define FCIDM_MEDIABAND_PLAYALL         0x4001
#define IDS_PLAYALL                     0x4002
#define IDS_MEDIABAND_MYMUSIC           0x4003
#define IDS_MEDIABAND_CHANGEMYMUSIC     0x4004
#define IDS_MEDIABAND_DURATION          0x4005
#define IDS_MEDIABAND_SRC_LABELS        0x4006
#define IDS_MEDIABAND_DOCK                0x4007
#define IDS_MEDIABAND_UNDOCK             0x4008
#define IDS_MEDIABAND_TRACKNUMBER       0x4009
#define IDS_MEDIABAND_PLAY              0x400A
#define IDS_MEDIABAND_PAUSE             0x400B
#define IDS_MEDIABAND_MUTE              0x400C
#define IDS_MEDIABAND_UNMUTE            0x400D
#define IDS_MEDIABAND_NOWDOWNLOADING    0x400E
#define IDS_MEDIABAND_NAVTIMEOUT        0x400F
#define IDS_MEDIABAND_INVALIDFILE       0x401A
#define IDS_MEDIABAND_STOP               0x401d
#define IDS_MEDIABAND_BACK               0x401e
#define IDS_MEDIABAND_NEXT               0x401f
#define IDS_MEDIABAND_NOWMP7TITLE       0x4020
#define IDS_MEDIABAND_NOWMP7            0x4021
#define IDS_MEDIABAND_PLAYING           0x4022

#define IDC_MEDIA_MOREINFO               0x8001

//--------------------------------------------------------------
// B I T M A P    I D E N T I F I E R S
//--------------------------------------------------------------
#define DELTA_HICOLOR           4

#define IDB_IETOOLBAR           0x105
#define IDB_IETOOLBARHOT        0x106
#define IDB_IETOOLBAR16         0x107   // 16 means small (18x16 vs 22x20)
#define IDB_IETOOLBARHOT16      0x108

#define IDB_IETOOLBARHICOLOR    0x109   // hicolors are locolor + 4
#define IDB_IETOOLBARHOTHICOLOR 0x10A
#define IDB_IETOOLBARHICOLOR16  0x10B
#define IDB_IETOOLBARHOTHICOLOR16 0x10C

#define IDB_SHSTD               0x110
#define IDB_SHSTDHOT            0x111
#define IDB_SHSTD16             0x112
#define IDB_SHSTDHOT16          0x113

#define IDB_SHSTDHICOLOR        0x114
#define IDB_SHSTDHOTHICOLOR     0x115
#define IDB_SHSTDHICOLOR16      0x116
#define IDB_SHSTDHOTHICOLOR16   0x117


#define IDB_GO                  0x122
#define IDB_GOHOT               0x123

// Note: shdocvw loads IDB_IEBRAND from browseui when running in design mode.
// Do not change this value without changing the constant in shdocvw\resource.h!!!

#define IDB_IEBRAND             0x130
#define IDB_IESMBRAND           0x131
#define IDB_IEMICROBRAND        0x132

///end bitmaps for itbar

//Bitmap ID for advanced tree options
#define IDB_BUTTONS             0x210
#define IDB_GROUPBUTTON         0x211

#define IDB_THEATERCLOSE        0x220
#define IDB_BROWSERTOOLBAR      0x221

#ifdef UNIX
#define IDB_WHITEBROWSERTOOLBAR  0x232
#endif

#define IDB_SEARCHBANDDEF       0x233
#define IDB_SEARCHBANDHOT       0x234

//---------------------------------------------------------------------
// A C C E L E R A T O R     I D E N T I F I E R S
//---------------------------------------------------------------------
#define ACCEL_MERGE             0x100
#define ACCEL_MERGEEXPLORER     0x101


//---------------------------------------------------------------------
// C O M M A N D    I D E N T I F I E R S
//---------------------------------------------------------------------

#define BSIDM_CLOSEBAND         0x0001
#define BSIDM_SHOWTITLEBAND     0x0002
#define BSIDM_IEAK_DISABLE_DDCLOSE   0x0003 // Disable Both Drag & Drop, and Closing
#define BSIDM_IEAK_DISABLE_MOVE 0x0004      // Disable Moving within a Bar.

#define ISFBIDM_LARGE           0x0001
#define ISFBIDM_SMALL           0x0002
#define ISFBIDM_LOGOS           0x0003
#define ISFBIDM_SHOWTEXT        0x0004
#define ISFBIDM_REFRESH         0x0005
#define ISFBIDM_OPEN            0x0006


#define DBIDM_NEWFOLDERBAND     0x0001
#define DBIDM_DESKTOPBAND       0x0003
#define DBIDM_LAUNCHBAND        0x0004
#define DBIDM_NEWBANDFIXEDLAST  0x0010

// mnfolder context menu commands
// in legacy\mnbandid.h #define MNIDM_RESORT            0x0001
// in legacy\mnbandid.h #define MNIDM_LAST              0x0001

/// appbar (dockbar) specific messages
#define IDM_AB_FIRST        0x1

#define IDM_AB_LEFT         (IDM_AB_FIRST + ABE_LEFT)
#define IDM_AB_TOP          (IDM_AB_FIRST + ABE_TOP)
#define IDM_AB_RIGHT        (IDM_AB_FIRST + ABE_RIGHT)
#define IDM_AB_BOTTOM       (IDM_AB_FIRST + ABE_BOTTOM)

#define IDM_AB_BOTTOMMOST   (IDM_AB_FIRST + 0x4)
#define IDM_AB_TOPMOST      (IDM_AB_FIRST + 0x5)
#define IDM_AB_REGULAR      (IDM_AB_FIRST + 0x6)
#define IDM_AB_AUTOHIDE     (IDM_AB_FIRST + 0x7)

#define IDM_AB_CLOSE        (IDM_AB_FIRST + 0x10)

#define IDM_AB_ENABLEMODELESS   (IDM_AB_FIRST + 0x11)
#define IDM_AB_DISABLEMODELESS  (IDM_AB_FIRST + 0x12)
#define IDM_AB_ACTIVATE     (IDM_AB_FIRST + 0x13)

#define IDM_AB_LAST         (IDM_AB_FIRST + 0x1f)




// normal toolbar commands
#define FCIDM_DROPDRIVELIST     0x100


//---------------------------------------------------------------------------
// Defines for the rc file.
//---------------------------------------------------------------------------

// Commmand ID
#define FCIDM_FIRST             FCIDM_GLOBALFIRST
#define FCIDM_LAST              FCIDM_BROWSERLAST

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_FILE      (FCIDM_BROWSERFIRST+0x0020)
#define FCIDM_FILECLOSE         (FCIDM_BROWSER_FILE+0x0001)
#define FCIDM_PREVIOUSFOLDER    (FCIDM_BROWSER_FILE+0x0002) // shbrowse::EXEC (cannot change)
#define FCIDM_DELETE            (FCIDM_BROWSER_FILE+0x0003)
#define FCIDM_RENAME            (FCIDM_BROWSER_FILE+0x0004)
#define FCIDM_PROPERTIES        (FCIDM_BROWSER_FILE+0x0005)
#define FCIDM_VIEWOFFLINE       (FCIDM_BROWSER_FILE+0x0006)
#define FCIDM_FILENSCBANDSEP    (FCIDM_BROWSER_FILE+0x0007)
#define FCIDM_FILENSCBANDPOPUP  (FCIDM_BROWSER_FILE+0x0008)

// these aren't real menu commands, but they map to accelerators or other things
// IE4 shipped with FCIDM_NEXTCTL as 0xA030 and we can not change it
// because we need to support IE5 browser only on top of IE4 integrated.
#define FCIDM_NEXTCTL           (FCIDM_BROWSER_FILE+0x0010) // explorer browseui shell32
//                              (FCIDM_BROWSER_FILE+0x0011)  // unused, reclaim
#define FCIDM_BACKSPACE         (FCIDM_BROWSER_FILE+0x0012)

#ifdef TEST_AMBIENTS
#define FCIDM_VIEWLOCALOFFLINE  (FCIDM_BROWSER_FILE+0x0013)
#define FCIDM_VIEWLOCALSILENT   (FCIDM_BROWSER_FILE+0x0014)
#endif // TEST_AMBIENTS

#define FCIDM_FORTEZZA_MENU     (FCIDM_BROWSER_FILE+0x0018)
#define FCIDM_FORTEZZA_LOGIN    (FCIDM_BROWSER_FILE+0x0019)
#define FCIDM_FORTEZZA_LOGOUT   (FCIDM_BROWSER_FILE+0x001a)
#define FCIDM_FORTEZZA_CHANGE   (FCIDM_BROWSER_FILE+0x001b)


//---------------------------------------------------------------------------
#define FCIDM_BROWSER_EDIT      (FCIDM_BROWSERFIRST+0x0040)
#define FCIDM_MOVE              (FCIDM_BROWSER_EDIT+0x0001)
#define FCIDM_COPY              (FCIDM_BROWSER_EDIT+0x0002)
#define FCIDM_PASTE             (FCIDM_BROWSER_EDIT+0x0003)
#define FCIDM_SELECTALL         (FCIDM_BROWSER_EDIT+0x0004)
#define FCIDM_LINK              (FCIDM_BROWSER_EDIT+0x0005)     // create shortcut
#define FCIDM_EDITPAGE          (FCIDM_BROWSER_EDIT+0x0006)

// APPCOMPAT:: IOmega relies on FCIDM_REFRESH was WM_COMMAND of A065
// APPCOMPAT:: shell32 also relies on it - Cabinet_RefreshAll
#define FCIDM_W95REFRESH        (FCIDM_BROWSERFIRST+0x0065) // browseui win95shell32



//---------------------------------------------------------------------------
#define FCIDM_BROWSER_TOOLS     (FCIDM_BROWSERFIRST+0x0080)
#define FCIDM_CONNECT           (FCIDM_BROWSER_TOOLS+0x0001) // shbrowse::EXEC (cannot change)
#define FCIDM_DISCONNECT        (FCIDM_BROWSER_TOOLS+0x0002) // shbrowse::EXEC (cannot change)
#define FCIDM_CONNECT_SEP       (FCIDM_BROWSER_TOOLS+0x0003)
#define FCIDM_GETSTATUSBAR      (FCIDM_BROWSER_TOOLS+0x0004) // shbrowse::EXEC (cannot change)
// IE4 shipped with FCIDM_FINDFILES as 0xA0085 and we can not change it
// because we need to support IE5 browser only on top of IE4 integrated.
#define FCIDM_FINDFILES         (FCIDM_BROWSER_TOOLS+0x0005) // explorer shdocvw shell32
// IE4 shipped with FCIDM_FINDFILES as 0xA0086 and we can not change it
// because we need to support IE5 browser only on top of IE4 integrated.
#define FCIDM_FINDCOMPUTER      (FCIDM_BROWSER_TOOLS+0x0006) // explorer shdocvw
//                              (FCIDM_BROWSER_TOOLS+0x0008) // unused, reclaim
#define FCIDM_SETSTATUSBAR      (FCIDM_BROWSER_TOOLS+0x0009) // shbrowse::EXEC (cannot change)
#define FCIDM_PERSISTTOOLBAR    (FCIDM_BROWSER_TOOLS+0x0010) // shbrowse::EXEC (cannot change)
//                              (FCIDM_BROWSER_TOOLS+0x0011) // unused, reclaim
#define FCIDM_MAILANDNEWS       (FCIDM_BROWSER_TOOLS+0x0012)
#define FCIDM_OPENWEBFOLDER     (FCIDM_BROWSER_TOOLS+0x0013)

// APPCOMPAT: these overlap the above and below, but it's sort of okay since
// it's a context menu? not really.
#define FCIDM_MENU_TOOLS_FINDFIRST (FCIDM_BROWSER_TOOLS+0x0007)
#define FCIDM_MENU_TOOLS_FINDLAST  (FCIDM_BROWSER_TOOLS+0x0040)

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_HELP      (FCIDM_BROWSERFIRST+0x0100)

#define FCIDM_HELPSEARCH        (FCIDM_BROWSER_HELP+0x0001)
#define FCIDM_HELPABOUT         (FCIDM_BROWSER_HELP+0x0002)
#define FCIDM_HELPTIPOFTHEDAY   (FCIDM_BROWSER_HELP+0x0003)
#define FCIDM_HELPISLEGAL       (FCIDM_BROWSER_HELP+0x0004)
#define FCIDM_HELPNETSCAPEUSERS (DVIDM_HELPMSWEB+11)
#define FCIDM_HELPONLINESUPPORT (DVIDM_HELPMSWEB+4)
#define FCIDM_HELPSENDFEEDBACK  (DVIDM_HELPMSWEB+5)
#define FCIDM_PRODUCTUPDATES    (DVIDM_HELPMSWEB+2)

//----------------------------------------------------------------
#define FCIDM_BROWSER_EXPLORE   (FCIDM_BROWSERFIRST + 0x0120)
#define FCIDM_NAVIGATEBACK      (FCIDM_BROWSER_EXPLORE+0x0001)
#define FCIDM_NAVIGATEFORWARD   (FCIDM_BROWSER_EXPLORE+0x0002)
#define FCIDM_BROWSEROPTIONS    (FCIDM_BROWSER_EXPLORE+0x0003)
#define FCIDM_LINKSSEPARATOR    (FCIDM_BROWSER_EXPLORE+0x0004)
#define FCIDM_STARTPAGE         (FCIDM_BROWSER_EXPLORE+0x0005)
#define FCIDM_UPDATEPAGE        (FCIDM_STARTPAGE+IDP_UPDATE)
#define FCIDM_CHANNELGUIDE      (FCIDM_STARTPAGE+IDP_CHANNELGUIDE)
#define FCIDM_SEARCHPAGE        (FCIDM_STARTPAGE+IDP_SEARCH)
#define FCIDM_RESETWEBSETTINGS  (FCIDM_BROWSER_EXPLORE+0x0009)
#define FCIDM_MAIL              (FCIDM_BROWSER_EXPLORE+0x000a)
#define FCIDM_NEWS              (FCIDM_BROWSER_EXPLORE+0x000b)
#define FCIDM_MAILNEWSSEPARATOR (FCIDM_BROWSER_EXPLORE+0x000c)
#define FCIDM_NEWMESSAGE        (FCIDM_BROWSER_EXPLORE+0x000d)
#define FCIDM_SENDLINK          (FCIDM_BROWSER_EXPLORE+0x000e)
#define FCIDM_SENDDOCUMENT      (FCIDM_BROWSER_EXPLORE+0x000f)
#define FCIDM_SEARCHSIMILAR     (FCIDM_BROWSER_EXPLORE+0x0010)
#define FCIDM_TOOLSSEPARATOR    (FCIDM_BROWSER_EXPLORE+0x0011)
#define FCIDM_MYCOMPUTER        (FCIDM_BROWSER_EXPLORE+0x0012)
#define FCIDM_SEARCHMENU        (FCIDM_BROWSER_EXPLORE+0x0013)

#define FCIDM_SHOWSCRIPTERRDLG  (FCIDM_BROWSER_EXPLORE+0x0014)

#define FCIDM_RECENTMENU        (FCIDM_BROWSER_EXPLORE+0x0021)
#define FCIDM_RECENTFIRST       (FCIDM_BROWSER_EXPLORE+0x0022)
#define FCIDM_RECENTLAST        (FCIDM_BROWSER_EXPLORE+0x0050)
#define FCIDM_FTPOPTIONS        (FCIDM_BROWSER_EXPLORE+0x0051)

#define FCIDM_FAVS_FIRST        (FCIDM_BROWSER_EXPLORE  +0x0052)
#define FCIDM_ORGANIZEFAVORITES (FCIDM_FAVS_FIRST       +0x0000)
#define FCIDM_ADDTOFAVORITES    (FCIDM_FAVS_FIRST       +0x0001)
#define FCIDM_FAVS_MORE         (FCIDM_FAVS_FIRST       +0x0002)
#define FCIDM_FAVORITEFIRST     (FCIDM_FAVS_FIRST       +0x0003)
#define FCIDM_UPDATESUBSCRIPTIONS (FCIDM_FAVS_FIRST       +0x0004)
#define FCIDM_SORTBY            (FCIDM_FAVS_FIRST       +0x0005)
#define FCIDM_SORTBYNAME        (FCIDM_FAVS_FIRST       +0x0006)
#define FCIDM_SORTBYVISIT       (FCIDM_FAVS_FIRST       +0x0007)
#define FCIDM_SORTBYDATE        (FCIDM_FAVS_FIRST       +0x0008)
#define FCIDM_FAVAUTOARRANGE    (FCIDM_FAVS_FIRST       +0x0009)
#define FCIDM_SUBSCRIPTIONS     (FCIDM_FAVS_FIRST       +0x000A)
#define FCIDM_SUBSCRIBE         (FCIDM_FAVS_FIRST       +0x000B)
#define FCIDM_FAVPLACEHOLDER    (FCIDM_FAVS_FIRST       +0x000C)

#define FCIDM_FAVORITELAST      (FCIDM_FAVORITEFIRST    +0x0050)
#define FCIDM_FAVORITE_ITEM     (FCIDM_FAVORITEFIRST + 0)
#define FCIDM_FAVORITECMDFIRST  (FCIDM_FAVS_FIRST)
#define FCIDM_FAVORITECMDLAST   (FCIDM_FAVORITELAST)
#define FCIDM_FAVS_LAST         (FCIDM_FAVORITELAST)

// (see histBand.cpp for more info...)
//shdocvw
//#define FCIDM_HISTBAND_FIRST      (FCIDM_BROWSERFIRST   + 0x0180)
//#define FCIDM_HISTBAND_VIEW       (FCIDM_HISTBAND_FIRST + 0x0000)

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_VIEW      (FCIDM_BROWSERFIRST + 0x0200)
#define FCIDM_VIEWTOOLBAR       (FCIDM_BROWSER_VIEW + 0x0001)
#define FCIDM_VIEWSTATUSBAR     (FCIDM_BROWSER_VIEW + 0x0002)
#define FCIDM_VIEWOPTIONS       (FCIDM_BROWSER_VIEW + 0x0003)
#define FCIDM_VIEWTOOLS         (FCIDM_BROWSER_VIEW + 0x0004)
#define FCIDM_VIEWADDRESS       (FCIDM_BROWSER_VIEW + 0x0005)
#define FCIDM_VIEWLINKS         (FCIDM_BROWSER_VIEW + 0x0006)
#define FCIDM_VIEWTEXTLABELS    (FCIDM_BROWSER_VIEW + 0x0007)
#define FCIDM_VIEWCONTEXTMENUSEP (FCIDM_BROWSER_VIEW + 0x0008)
#define FCIDM_VIEWAUTOHIDE      (FCIDM_BROWSER_VIEW + 0x0009)
#define FCIDM_VIEWMENU          (FCIDM_BROWSER_VIEW + 0x000A)
#define FCIDM_VIEWGOBUTTON      (FCIDM_BROWSER_VIEW + 0x000B)
#define FCIDM_VIEWLOCKTOOLBAR   (FCIDM_BROWSER_VIEW + 0x000C)

#define FCIDM_STOP              (FCIDM_BROWSER_VIEW + 0x001a)
#define FCIDM_VIEWTREE          (FCIDM_BROWSER_VIEW + 0x0016)
#define FCIDM_VIEWSEARCH        (FCIDM_BROWSER_VIEW + 0x0017)
#define FCIDM_CUSTOMIZEFOLDER   (FCIDM_BROWSER_VIEW + 0x0018)
#define FCIDM_VIEWFONTS         (FCIDM_BROWSER_VIEW + 0x0019)
// 1a is FCIDM_STOP
#define FCIDM_THEATER           (FCIDM_BROWSER_VIEW + 0x001b)
#define FCIDM_JAVACONSOLE       (FCIDM_BROWSER_VIEW + 0x001c)
#define FCIDM_VIEWTOOLBARCUSTOMIZE (FCIDM_BROWSER_VIEW + 0x001d)
#define FCIDM_ENCODING          (FCIDM_BROWSER_VIEW + 0x001e)
#define FCIDM_REFRESH           (FCIDM_BROWSER_VIEW + 0x0020) // ie4 shell32: must be A220 (cannot change)
#define FCIDM_ADDTOFAVNOUI      (FCIDM_BROWSER_VIEW + 0x0021)
#define FCIDM_VIEWITBAR         (FCIDM_BROWSER_VIEW + 0x0022)
#define FCIDM_VIEW_PRIVACY_POLICIES (FCIDM_BROWSER_VIEW + 0x0023)

#define FCIDM_VIEWBROWSERBARS   (FCIDM_BROWSER_VIEW + 0x0030)

// static guys
#define FCIDM_VBBSEARCHBAND         (FCIDM_VIEWBROWSERBARS + 0x0001)
#define FCIDM_VBBFAVORITESBAND      (FCIDM_VIEWBROWSERBARS + 0x0002)
#define FCIDM_VBBHISTORYBAND        (FCIDM_VIEWBROWSERBARS + 0x0003)
#define FCIDM_VBBEXPLORERBAND       (FCIDM_VIEWBROWSERBARS + 0x0005)
#ifdef UNIX
// UNIX only : MsgBand
#define FCIDM_VBBMSGBAND            (FCIDM_VIEWBROWSERBARS + 0x0006)
#endif
#define FCIDM_VBBMEDIABAND          (FCIDM_VIEWBROWSERBARS + 0x0007)

#define FCIDM_VBBPLACEHOLDER        (FCIDM_VIEWBROWSERBARS + 0x000b)
#define FCIDM_VBBFIXFIRST           (FCIDM_VIEWBROWSERBARS + 0x0001)
#define FCIDM_VBBFIXLAST            (FCIDM_VIEWBROWSERBARS + 0x000f)
#define FCIDM_VBBNOHORIZONTALBAR    0
#define FCIDM_VBBNOVERTICALBAR      0

// dynamic guys
#define FCIDM_VBBDYNFIRST           (FCIDM_VIEWBROWSERBARS + 0x10)
#define VBBDYN_MAXBAND              14
#define VBBDYN_MAXBAR               2
#define FCIDM_VBBDYNLAST            (FCIDM_VBBDYNFIRST + VBBDYN_MAXBAND * VBBDYN_MAXBAR)

#define FCIDM_SEARCHIDS         (FCIDM_BROWSER_VIEW + 0x0070)
#define FCIDM_SEARCHSEP         (FCIDM_SEARCHIDS    + 0x0001)
#define FCIDM_SEARCHALL         (FCIDM_SEARCHIDS    + 0x0002)
#define FCIDM_SEARCHFIRST       (FCIDM_SEARCHIDS    + 0x0003)
#define FCIDM_SEARCHLAST        (FCIDM_SEARCHFIRST  + 0x0020)

#define IDM_AC_FIRST            (FCIDM_BROWSER_EXPLORE+0x200)
#define AC_MENUITEMS            20  //  reserved space for auto complete items
#define IDM_AC_UNDO             (IDM_AC_FIRST+0x01)
#define IDM_AC_CUT              (IDM_AC_FIRST+0x02)
#define IDM_AC_COPY             (IDM_AC_FIRST+0x03)
#define IDM_AC_PASTE            (IDM_AC_FIRST+0x04)
#define IDM_AC_DELETE           (IDM_AC_FIRST+0x05)
#define IDM_AC_SELECTALL        (IDM_AC_FIRST+0x06)
#define IDM_AC_COMPLETIONS      (IDM_AC_FIRST+0x07)
#define IDM_AC_FIRSTCOMPITEM    (IDM_AC_FIRST+0x08)
#define IDM_AC_LASTCOMPITEM     (IDM_AC_FIRSTCOMPITEM+AC_MENUITEMS)

#define FCIDM_APPS_FIRST        (FCIDM_BROWSER_EXPLORE+0x220)
#define FCIDM_CONTACTS          (FCIDM_APPS_FIRST + 0x001)
#define FCIDM_CALENDAR          (FCIDM_APPS_FIRST + 0x002)
#define FCIDM_TASKS             (FCIDM_APPS_FIRST + 0x003)
#define FCIDM_JOURNAL           (FCIDM_APPS_FIRST + 0x004)
#define FCIDM_NOTES             (FCIDM_APPS_FIRST + 0x005)
#define FCIDM_CALL              (FCIDM_APPS_FIRST + 0x006)
#define FCIDM_APPS_LAST         (FCIDM_APPS_FIRST + 0x020)



#define FSIDM_NEWFOLDER         (FCIDM_FILECTX_LAST+0x21)
#define FSIDM_NEWLINK           (FCIDM_FILECTX_LAST+0x22)
#define FSIDM_NEWOTHER          (FCIDM_FILECTX_LAST+0x23)

#define FCIDM_EXTERNALBANDS_FIRST (FCIDM_BROWSERFIRST + 0x450)
#define FCIDM_EXTERNALBANDS_LAST  (FCIDM_BROWSERFIRST + 0x464)

#define FCIDM_FILECTX_FIRST     (FCIDM_BROWSERFIRST+0x470)
#define FCIDM_FILECTX_LAST      (FCIDM_BROWSERFIRST+0x570)

// start menu's augmisf context menu ids
#define SMIDM_OPEN               0x0001
#define SMIDM_EXPLORE            0x0002
#define SMIDM_OPENCOMMON         0x0003
#define SMIDM_EXPLORECOMMON      0x0004
#define SMIDM_DELETE             0x0005
#define SMIDM_RENAME             0x0006
#define SMIDM_PROPERTIES         0x0007

#define IDS_COMPLETIONS         507

#define IDS_MH_DRIVELIST        (MH_ITEMS+FCIDM_DRIVELIST)
#define IDS_MH_MENU_FILE        (MH_ITEMS+FCIDM_MENU_FILE)
#define IDS_MH_MENU_EXPLORE     (MH_ITEMS+FCIDM_MENU_EXPLORE)
#define IDS_MH_MENU_HELP        (MH_ITEMS+FCIDM_MENU_HELP)
#define IDS_MH_FILECLOSE        (MH_ITEMS+FCIDM_FILECLOSE)
#define IDS_MH_LINK             (MH_ITEMS+FCIDM_LINK)
#define IDS_MH_DELETE           (MH_ITEMS+FCIDM_DELETE)
#define IDS_MH_RENAME           (MH_ITEMS+FCIDM_RENAME)
#define IDS_MH_PROPERTIES       (MH_ITEMS+FCIDM_PROPERTIES)
#define IDS_MH_VIEWOFFLINE      (MH_ITEMS+FCIDM_VIEWOFFLINE)

#define IDS_MH_PREVIOUSFOLDER   (MH_ITEMS+FCIDM_PREVIOUSFOLDER)
#define IDS_MH_HELPSEARCH       (MH_ITEMS+FCIDM_HELPSEARCH)
#define IDS_MH_HELPABOUT        (MH_ITEMS+FCIDM_HELPABOUT)
#define IDS_MH_HELPTIPOFTHEDAY  (MH_ITEMS+FCIDM_HELPTIPOFTHEDAY)
#define IDS_MH_HELPISLEGAL      (MH_ITEMS+FCIDM_HELPISLEGAL)
#define IDS_MH_NAVIGATEBACK     (MH_ITEMS+FCIDM_NAVIGATEBACK)
#define IDS_MH_NAVIGATEFORWARD  (MH_ITEMS+FCIDM_NAVIGATEFORWARD)
#define IDS_MH_PREVIOUSFOLDER   (MH_ITEMS+FCIDM_PREVIOUSFOLDER)
#define IDS_MH_VIEWTOOLBAR      (MH_ITEMS+FCIDM_VIEWTOOLBAR)
#define IDS_MH_VIEWTOOLS        (MH_ITEMS+FCIDM_VIEWTOOLS)
#define IDS_MH_VIEWADDRESS      (MH_ITEMS+FCIDM_VIEWADDRESS)
#define IDS_MH_VIEWLINKS        (MH_ITEMS+FCIDM_VIEWLINKS)
#define IDS_MH_VIEWAUTOHIDE     (MH_ITEMS+FCIDM_VIEWAUTOHIDE)
#define IDS_MH_VIEWMENU         (MH_ITEMS+FCIDM_VIEWMENU)
#define IDS_MH_VIEWTEXTLABELS   (MH_ITEMS+FCIDM_VIEWTEXTLABELS)
#define IDS_MH_VIEWSTATUSBAR    (MH_ITEMS+FCIDM_VIEWSTATUSBAR)
#define IDS_MH_VIEWLOCKTOOLBAR  (MH_ITEMS+FCIDM_VIEWLOCKTOOLBAR)
#define IDS_MH_VIEWBROWSERBARS  (MH_ITEMS+FCIDM_VIEWBROWSERBARS)
#define IDS_MH_VIEWPRIVACY      (MH_ITEMS+FCIDM_VIEW_PRIVACY_POLICIES) 
#define IDS_MH_VBBSEARCHBAND    (MH_ITEMS+FCIDM_VBBSEARCHBAND)
#define IDS_MH_VBBFAVORITESBAND (MH_ITEMS+FCIDM_VBBFAVORITESBAND)
#define IDS_MH_VBBHISTORYBAND   (MH_ITEMS+FCIDM_VBBHISTORYBAND)
#define IDS_MH_VBBEXPLORERBAND  (MH_ITEMS+FCIDM_VBBEXPLORERBAND)
#define IDS_MH_VBBMEDIABAND     (MH_ITEMS+FCIDM_VBBMEDIABAND)

#define IDS_MH_BROWSEROPTIONS   (MH_ITEMS+FCIDM_BROWSEROPTIONS)
#define IDS_MH_STARTPAGE        (MH_ITEMS+FCIDM_STARTPAGE )
#define IDS_MH_SEARCHPAGE       (MH_ITEMS+FCIDM_SEARCHPAGE)
#define IDS_MH_UPDATEPAGE       (MH_ITEMS+FCIDM_UPDATEPAGE )
#define IDS_MH_CHANNELGUIDE     (MH_ITEMS+FCIDM_CHANNELGUIDE )
#define IDS_MH_UPDATESUBSCRIPTIONS  (MH_ITEMS+FCIDM_UPDATESUBSCRIPTIONS)
#define IDS_MH_WINDOWSUPDATE    (MH_ITEMS+FCIDM_WINDOWSUPDATE)
#define IDS_MH_RECENTFIRST      (MH_ITEMS+FCIDM_RECENTFIRST)
#define IDS_MH_MENU_FAVORITES   (MH_ITEMS+FCIDM_MENU_FAVORITES)
#define IDS_MH_FAVORITES        (MH_ITEMS+FCIDM_ORGANIZEFAVORITES)
#define IDS_MH_ADDTOFAVORITES   (MH_ITEMS+FCIDM_ADDTOFAVORITES)
#define IDS_MH_FAVS_MORE        (MH_ITEMS+FCIDM_FAVS_MORE)
#define IDS_MH_FAVORITE_ITEM    (MH_ITEMS+FCIDM_FAVORITE_ITEM)
#define IDS_MH_MAILANDNEWS      (MH_ITEMS+FCIDM_MAILANDNEWS)
#define IDS_MH_MAIL             (MH_ITEMS+FCIDM_MAIL)
#define IDS_MH_NEWS             (MH_ITEMS+FCIDM_NEWS)
#define IDS_MH_NEWMESSAGE       (MH_ITEMS+FCIDM_NEWMESSAGE)
#define IDS_MH_SENDLINK         (MH_ITEMS+FCIDM_SENDLINK)
#define IDS_MH_EXPLORE          (MH_ITEMS+FCIDM_MENU_EXPLORE)
#define IDS_MH_VIEW             (MH_ITEMS+FCIDM_MENU_VIEW)
#define IDS_MH_EDIT             (MH_ITEMS+FCIDM_MENU_EDIT)
#define IDS_MH_TOOLS            (MH_ITEMS+FCIDM_MENU_TOOLS) // for Win9x compat
#define IDS_MH_SENDDOCUMENT     (MH_ITEMS+FCIDM_SENDDOCUMENT)
#define IDS_MH_EDITPAGE         (MH_ITEMS+FCIDM_EDITPAGE)
#define IDS_MH_THEATER          (MH_ITEMS+FCIDM_THEATER)
#define IDS_MH_VIEWTOOLBARCUSTOMIZE (MH_ITEMS+FCIDM_VIEWTOOLBARCUSTOMIZE)
#define IDS_MH_ENCODING         (MH_ITEMS+FCIDM_ENCODING)
#define IDS_MH_VIEWFONTS        (MH_ITEMS+FCIDM_VIEWFONTS)
#define IDS_MH_MYCOMPUTER       (MH_ITEMS+FCIDM_MYCOMPUTER)
//#define IDS_MH_PRODUCTUPDATES   (MH_ITEMS+FCIDM_PRODUCTUPDATES)

#define IDS_MH_CONTACTS          (MH_ITEMS+FCIDM_CONTACTS)
#define IDS_MH_CALENDAR          (MH_ITEMS+FCIDM_CALENDAR)
#define IDS_MH_TASKS             (MH_ITEMS+FCIDM_TASKS   )
#define IDS_MH_JOURNAL           (MH_ITEMS+FCIDM_JOURNAL )
#define IDS_MH_NOTES             (MH_ITEMS+FCIDM_NOTES   )
#define IDS_MH_CALL              (MH_ITEMS+FCIDM_CALL    )

#define IDS_MH_CONNECT           (MH_ITEMS+FCIDM_CONNECT   )
#define IDS_MH_DISCONNECT        (MH_ITEMS+FCIDM_DISCONNECT)

#define IDS_MH_RESETWEBSETTINGS  (MH_ITEMS+FCIDM_RESETWEBSETTINGS)

#define IDM_BROWBAND_REFRESH         0x0001  // IWBBIDM_REFRESH
#define IDM_BROWBAND_OPENNEW         0x0002

// mediabar ids
#define TBIDM_PLAY              0x135
#define TBIDM_PAUSE           	0x136
#define TBIDM_STOP	            0x137
#define TBIDM_REWIND            0x138  
#define TBIDM_FASTFORWARD       0x139
#define TBIDM_VOLUME            0x140
#define TBIDM_MYMUSIC           0x141
#define TBIDM_SEEK	            0x142
#define TBIDM_PLAYINFO          0x143

// global ids
#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif

#define DLG_TEXTICONOPTIONS     0x100
#define IDC_SHOWTEXT            0x1000
#define IDC_SMALLICONS          0x1001

#define DLG_NEWFOLDER           0x101
#define IDD_NEW                 0x110
#define IDD_CREATEIN            0x111
#define IDD_NAMESTATIC          0x112
#define IDD_CREATEINSTATIC      0x113
#define IDD_SUBSCRIBE           0x114
#define IDD_SUBSCRIBE_TEXT      0x115

// in legacy\mnbandid.h #define DLG_ISFBANDRENAME       0x102

#define IDD_ADDTOFAVORITES_TEMPLATE     0x120
#define IDD_ADDTOCHANNELS_TEMPLATE      0x121
#define IDD_ACTIVATE_PLATINUM_CHANNEL   0x122
#define IDD_SUBSCRIBE_FAV_CHANNEL       0x123
#define IDD_SUBSCRIBE_FAVORITE          0x124
#define IDD_ADDTOSOFTDISTCHANNELS_TEMPLATE  0x125

#define IDC_SUBSCRIBE_POSSIBLE          0x130
#define IDC_SUBSCRIBE_NONE              0x131
#define IDC_SUBSCRIBE_NOTIFY            0x132
#define IDC_SUBSCRIBE_DOWNLOAD          0x133
#define IDC_SUBSCRIBE_CUSTOMIZE         0x134

#define IDC_FAVORITE_NAME               0x135
#define IDC_FAVORITE_CREATEIN           0x136
#define IDC_FAVORITE_NEWFOLDER          0x137
#define IDC_FAVORITE_ICON               0x138

#define IDC_CHANNEL_NAME                0x139
#define IDC_CHANNEL_URL                 0x13A
#define IDC_FOLDERLISTSTATIC            0x13B
#define IDC_NAMESTATIC                  0x13C


#define IDD_NAME                0x140
#define IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER 0x141
#define IDD_PROMPT              0x142

// Progress Dialog
#define DLG_PROGRESSDIALOG      0x103
#define IDD_PROGDLG_ANIMATION   0x150
#define IDD_PROGDLG_LINE1       0x151
#define IDD_PROGDLG_LINE2       0x152
#define IDD_PROGDLG_LINE3       0x153
#define IDD_PROGDLG_PROGRESSBAR 0x154

#define IDS_TIMEEST_MINUTES     0x3030
#define IDS_TIMEEST_SECONDS     0x3031
#define IDS_CANTSHUTDOWN        0x3032
#define IDS_DEFAULT_CANCELPROG  0x3033
#define IDS_TIMEEST_DAYSHOURS  0x3034
#define IDS_TIMEEST_DAYHOURS   0x3035
#define IDS_TIMEEST_DAYSHOUR   0x3036
#define IDS_TIMEEST_DAYHOUR    0x3037
#define IDS_TIMEEST_HOURSMINS  0x3038
#define IDS_TIMEEST_HOURSMIN   0x3039
#define IDS_TIMEEST_HOURMINS   0x303A
#define IDS_TIMEEST_HOURMIN    0x303B
#define IDS_TITLEBAR_PROGRESS  0x303C

#define IDC_WEBFOLDEREDIT       0x1002

//--------------------------------------------------------------
// I C O N S
//--------------------------------------------------------------
#define IDI_NEW_FOLDER          0x1
#define IDI_FRAME               0x2

// UNIX only
#define IDI_MONOFRAME           0x4020

//--------------------------------------------------------------
// HTML dialog resources
//--------------------------------------------------------------
#define RT_FILE                         2110

#define FCIDM_TOOLS_EXT_PLACEHOLDER         0x9000
#define FCIDM_HELP_EXT_PLACEHOLDER          0x9002

//--------------------------------------------------------------
// HTML File Resources
//--------------------------------------------------------------

#define IDH_PLAYER          0x7300
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\proxy.cpp ===
#include "priv.h"
#include "hnfblock.h"
#include <trayp.h>
#include "desktop.h"
#include "shbrows2.h"
#include "resource.h"
#include "onetree.h"
#include "apithk.h"
#include <regitemp.h>

#include "mluisupp.h"

//forward declaration of private function
BOOL  _private_ParseField(LPCTSTR pszData, int n, LPTSTR szBuf, int iBufLen);


BOOL _RootsEqual(HANDLE hCR, DWORD dwProcId, LPCITEMIDLIST pidlRoot)
{
    BOOL bSame = FALSE;
    if (hCR)
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)SHLockShared(hCR, dwProcId);
        if (pidl)
        {
            bSame = ILIsEqualRoot(pidlRoot, pidl);
            SHUnlockShared(pidl);
        }
    }
    return bSame;
}


// NOTE: this export is new to IE5, so it can move to browseui
// along with the rest of this proxy desktop code
BOOL SHOnCWMCommandLine(LPARAM lParam)
{
    HNFBLOCK hnf = (HNFBLOCK)lParam;
    IETHREADPARAM *piei = ConvertHNFBLOCKtoNFI(hnf);
    if (piei)
        return SHOpenFolderWindow(piei);

    // bad params passed, normal failure case
    return FALSE;
}


//---------------------------------------------------------------------------
// This proxy desktop window procedure is used when we are run and we
// are not the shell.  We are a hidden window which will simply respond
// to messages like the ones that create threads for folder windows.
// This window procedure will close after all of the open windows
// associated with it go away.
class CProxyDesktop
{
private:
    static LRESULT CALLBACK ProxyWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    friend CProxyDesktop *CreateProxyDesktop(IETHREADPARAM *piei);
    friend BOOL SHCreateFromDesktop(PNEWFOLDERINFO pfi);

    CProxyDesktop() {};
    ~CProxyDesktop();

    HWND            _hwnd;
    LPITEMIDLIST    _pidlRoot;
};

CProxyDesktop::~CProxyDesktop()
{
    ILFree(_pidlRoot);
}

LRESULT CALLBACK CProxyDesktop::ProxyWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CProxyDesktop *pproxy = (CProxyDesktop *)GetWindowPtr0(hwnd);

    switch (msg)
    {
    case WM_CREATE:
        pproxy = (CProxyDesktop *)((CREATESTRUCT *)lParam)->lpCreateParams;
        SetWindowPtr0(hwnd, pproxy);

        pproxy->_hwnd = hwnd;
        return 0;   // success

    case WM_DESTROY:
        if (pproxy)
            pproxy->_hwnd = NULL;
        return 0;

    case CWM_COMMANDLINE:
        SHOnCWMCommandLine(lParam);
        break;

    case CWM_COMPAREROOT:
        return _RootsEqual((HANDLE)lParam, (DWORD)wParam, pproxy->_pidlRoot);

    default:
        return DefWindowProcWrap(hwnd, msg, wParam, lParam);
    }
    return 0;
}

CProxyDesktop *CreateProxyDesktop(IETHREADPARAM *piei)
{
    CProxyDesktop *pproxy = new CProxyDesktop();
    if (pproxy)
    {
        WNDCLASS wc = {0};
        wc.lpfnWndProc = CProxyDesktop::ProxyWndProc;
        wc.cbWndExtra = SIZEOF(CProxyDesktop *);
        wc.hInstance = HINST_THISDLL;
        wc.hbrBackground = (HBRUSH)(COLOR_DESKTOP + 1);
        wc.lpszClassName = DESKTOPPROXYCLASS;

        SHRegisterClass(&wc);

        if (CreateWindowEx(WS_EX_TOOLWINDOW, DESKTOPPROXYCLASS, DESKTOPPROXYCLASS,
            WS_POPUP, 0, 0, 0, 0, NULL, NULL, HINST_THISDLL, pproxy))
        {
            if (ILIsRooted(piei->pidl))
            {
                pproxy->_pidlRoot = ILCloneFirst(piei->pidl);
                if (pproxy->_pidlRoot == NULL)
                {
                    DestroyWindow(pproxy->_hwnd);
                    pproxy = NULL;
                }
            }
        }
        else
        {
            delete pproxy;
            pproxy = NULL;
        }
    }
    return pproxy;
}


// REVIEW: maybe just check (hwnd == GetShellWindow())

STDAPI_(BOOL) IsDesktopWindow(HWND hwnd)
{
    TCHAR szName[80];

    GetClassName(hwnd, szName, ARRAYSIZE(szName));
    if (!lstrcmp(szName, DESKTOPCLASS))
    {
        GetWindowText(hwnd, szName, ARRAYSIZE(szName));
        return !lstrcmp(szName, PROGMAN);
    }
    return FALSE;
}

typedef struct
{
    HWND hwndDesktop;
    HANDLE hCR;
    DWORD dwProcId;
    HWND hwndResult;
} FRDSTRUCT;

BOOL CALLBACK FindRootEnumProc(HWND hwnd, LPARAM lParam)
{
    FRDSTRUCT *pfrds = (FRDSTRUCT *)lParam;
    TCHAR szClassName[40];

    GetClassName(hwnd, szClassName, ARRAYSIZE(szClassName));
    if (lstrcmpi(szClassName, DESKTOPPROXYCLASS) == 0)
    {
        ASSERT(hwnd != pfrds->hwndDesktop);

        if (SendMessage(hwnd, CWM_COMPAREROOT, (WPARAM)pfrds->dwProcId, (LPARAM)pfrds->hCR))
        {
            // Found it, so stop enumerating
            pfrds->hwndResult = hwnd;
            return FALSE;
        }
    }
    return TRUE;
}

BOOL RunSeparateDesktop()
{
    DWORD bSeparate = FALSE;

    if (SHRestricted(REST_SEPARATEDESKTOPPROCESS))
        bSeparate = TRUE;
    else
    {
        SHELLSTATE ss;

        SHGetSetSettings(&ss, SSF_SEPPROCESS, FALSE);
        bSeparate = ss.fSepProcess;

        if (!bSeparate)
        {
            DWORD cbData = SIZEOF(bSeparate);
            SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER, TEXT("DesktopProcess"), NULL, &bSeparate, &cbData);
        }
    }
    return bSeparate;

}

//  if we need to force some legacy rootet explorers into their own process, implement this.
//#define _RootRunSeparateProcess(pidlRoot)  ILIsRooted(pidlRoot)  OLD BEHAVIOR
#define _RootRunSeparateProcess(pidlRoot)  FALSE

HWND FindRootedDesktop(LPCITEMIDLIST pidlRoot)
{
    HWND hwndDesktop = GetShellWindow();    // This is the "normal" desktop

    if (!RunSeparateDesktop() && !_RootRunSeparateProcess(pidlRoot) && hwndDesktop)
    {
        ASSERT(IsDesktopWindow(hwndDesktop));
        return hwndDesktop;
    }

    FRDSTRUCT frds;
    frds.hwndDesktop = hwndDesktop;
    frds.hwndResult = NULL;     // Initalize to no matching rooted expl
    frds.dwProcId = GetCurrentProcessId();
    frds.hCR = SHAllocShared(pidlRoot, ILGetSize(pidlRoot), frds.dwProcId);
    if (frds.hCR)
    {
        EnumWindows(FindRootEnumProc, (LPARAM)&frds);
        SHFreeShared(frds.hCR, frds.dwProcId);
    }

    return frds.hwndResult;
}


UINT _GetProcessHotkey(void)
{
    STARTUPINFO si = {SIZEOF(si)};
    GetStartupInfo(&si);
    return (UINT)(DWORD_PTR)si.hStdInput;
}

void FolderInfoToIEThreadParam(PNEWFOLDERINFO pfi, IETHREADPARAM *piei)
{
    piei->uFlags = pfi->uFlags;
    piei->nCmdShow = pfi->nShow;
    piei->wHotkey = _GetProcessHotkey();
    
    ASSERT(pfi->pszRoot == NULL);       // explorer always converts to a PIDL for us

    //  we no longer support rooted explorers this way
    //  it should have been filtered out above us.
    ASSERT(!pfi->pidlRoot);
    ASSERT(!(pfi->uFlags & (COF_ROOTCLASS | COF_NEWROOT)));
    ASSERT(IsEqualGUID(pfi->clsid, CLSID_NULL));

    if (pfi->pidl) 
    {
        piei->pidl = ILClone(pfi->pidl);
    } 
    //  COF_PARSEPATH means that we should defer the parsing of the pszPath
    else if (!(pfi->uFlags & COF_PARSEPATH) && pfi->pszPath && pfi->pszPath[0])
    {
        //  maybe should use IECreateFromPath??
        //  or maybe we should parse relative to the root??
        piei->pidl = ILCreateFromPathA(pfi->pszPath);
    }
}

// IE4 Integrated delay loads CreateFromDesktop from SHDOCVW.DLL
// So we need to keep this function here. Forward to the correct
// implementation in SHELL32 (if integrated) or SHDOC41 (if not)
BOOL SHCreateFromDesktop(PNEWFOLDERINFO pfi)
{
    IETHREADPARAM *piei = SHCreateIETHREADPARAM(NULL, 0, NULL, NULL);
    if (piei)
    {
        //  ASSUMING UNICODE COMPILE!
        LPCTSTR pszPath = NULL;
        HWND hwndDesktop;

        if (pfi->uFlags & COF_PARSEPATH)
        {
            ASSERT(!pfi->pidl);
            pszPath = (LPCTSTR) pfi->pszPath;
        }

        FolderInfoToIEThreadParam(pfi, piei);

        if (pfi->uFlags & COF_SEPARATEPROCESS)
        {
            hwndDesktop = NULL;         // Assume no desktop process exists
        }
        else
        {
            hwndDesktop = FindRootedDesktop(piei->pidl);
        }

        if (hwndDesktop)
        {
            DWORD dwProcId;
            DWORD dwThreadId = GetWindowThreadProcessId(hwndDesktop, &dwProcId);
            AllowSetForegroundWindow(dwProcId);
            HNFBLOCK hBlock = ConvertNFItoHNFBLOCK(piei, pszPath, dwProcId);
            if (hBlock)
            {
                PostMessage(hwndDesktop, CWM_COMMANDLINE, 0, (LPARAM)hBlock);

                HANDLE hExplorer = OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, dwProcId );
                if ( hExplorer )
                {
                    // wait for input idle 10 seconds.
                    WaitForInputIdle( hExplorer, 10000 );
                    CloseHandle( hExplorer );
                }
            }
        }
        else
        {
            HRESULT hrInit = SHCoInitialize();

            CProxyDesktop *pproxy = CreateProxyDesktop(piei);
            if (pproxy)
            {
                // CRefThread controls this processes reference count. browser windows use this
                // to keep this process (window) around and this also lets thrid parties hold 
                // references to our process, MSN uses this for example

                LONG cRefMsgLoop;
                IUnknown *punkRefMsgLoop;
                if (SUCCEEDED(SHCreateThreadRef(&cRefMsgLoop, &punkRefMsgLoop)))
                {
                    SHSetInstanceExplorer(punkRefMsgLoop);

                    //  we needed to wait for this for the CoInit()
                    if (pszPath)
                        piei->pidl = ILCreateFromPath(pszPath);

                    SHOpenFolderWindow(piei);
                    piei = NULL;                // OpenFolderWindow() takes ownership of this
                    punkRefMsgLoop->Release();  // we now depend on the browser window to keep our msg loop
                }

                MSG msg;
                while (GetMessage(&msg, NULL, 0, 0))
                {
                    if (cRefMsgLoop == 0)
                        break; // no more refs on this thread, done

                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
                delete pproxy;
            }

            SHCoUninitialize(hrInit);
        }

        if (piei)
            SHDestroyIETHREADPARAM(piei);
    }
    return TRUE;        // no one pays attention to this
}
        

HNFBLOCK ConvertNFItoHNFBLOCK(IETHREADPARAM* pInfo, LPCTSTR pszPath, DWORD dwProcId)
{
    UINT    uSize;
    UINT    uPidl;
    UINT    uPidlSelect;
    UINT    uPidlRoot;
    UINT    upszPath;
    PNEWFOLDERBLOCK pnfb;
    LPBYTE  lpb;
    HNFBLOCK hBlock;
    LPVOID pidlRootOrMonitor = NULL; // pidlRoot or &hMonitor

    uSize = SIZEOF(NEWFOLDERBLOCK);
    if (pInfo->pidl)
    {
        uPidl = ILGetSize(pInfo->pidl);
        uSize += uPidl;
    }
    if (pInfo->pidlSelect)
    {
        uPidlSelect = ILGetSize(pInfo->pidlSelect);
        uSize += uPidlSelect;
    }

    if (pInfo->uFlags & COF_HASHMONITOR)
    {
        pidlRootOrMonitor = &pInfo->pidlRoot;
        uPidlRoot = sizeof(HMONITOR);
        uSize += uPidlRoot;
    }
    else if (pInfo->pidlRoot)
    {
        pidlRootOrMonitor = pInfo->pidlRoot;
        uPidlRoot = ILGetSize(pInfo->pidlRoot);
        uSize += uPidlRoot;
    }

    if (pszPath) {
        upszPath = CbFromCch(lstrlen(pszPath) + 1);
        uSize += upszPath;
    }

    hBlock = (HNFBLOCK)SHAllocShared(NULL, uSize, dwProcId);
    if (hBlock == NULL)
        return NULL;

    pnfb = (PNEWFOLDERBLOCK)SHLockShared(hBlock, dwProcId);
    if (pnfb == NULL)
    {
        SHFreeShared(hBlock, dwProcId);
        return NULL;
    }

    pnfb->dwSize      = uSize;
    pnfb->uFlags      = pInfo->uFlags;
    pnfb->nShow       = pInfo->nCmdShow;
    pnfb->dwHwndCaller= PtrToInt(pInfo->hwndCaller);
    pnfb->dwHotKey    = pInfo->wHotkey;
    pnfb->clsid       = pInfo->clsid;
    pnfb->clsidInProc = pInfo->clsidInProc;
    pnfb->oidl        = 0;
    pnfb->oidlSelect  = 0;
    pnfb->oidlRoot    = 0;
    pnfb->opszPath    = 0;

    lpb = (LPBYTE)(pnfb+1);     // Point just past the structure

    if (pInfo->pidl)
    {
        memcpy(lpb,pInfo->pidl,uPidl);
        pnfb->oidl = (int)(lpb-(LPBYTE)pnfb);
        lpb += uPidl;
    }
    if (pInfo->pidlSelect)
    {
        memcpy(lpb,pInfo->pidlSelect,uPidlSelect);
        pnfb->oidlSelect = (int)(lpb-(LPBYTE)pnfb);
        lpb += uPidlSelect;
    }

    if (pidlRootOrMonitor)
    {
        memcpy(lpb, pidlRootOrMonitor, uPidlRoot);
        pnfb->oidlRoot = (int)(lpb-(LPBYTE)pnfb);
        lpb += uPidlRoot;
    }

    if (pszPath)
    {
        memcpy(lpb, pszPath, upszPath);
        pnfb->opszPath = (int)(lpb-(LPBYTE)pnfb);
        lpb += upszPath;
    }
    SHUnlockShared(pnfb);
    return hBlock;
}

IETHREADPARAM* ConvertHNFBLOCKtoNFI(HNFBLOCK hBlock)
{
    BOOL fFailure = FALSE;
    IETHREADPARAM* piei = NULL;
    if (hBlock)
    {
        DWORD dwProcId = GetCurrentProcessId();
        PNEWFOLDERBLOCK pnfb = (PNEWFOLDERBLOCK)SHLockShared(hBlock, dwProcId);
        if (pnfb)
        {
            if (pnfb->dwSize >= SIZEOF(NEWFOLDERBLOCK))
            {
                piei = SHCreateIETHREADPARAM(NULL, pnfb->nShow, NULL, NULL);
                if (piei)
                {
                    LPITEMIDLIST pidl = NULL;
                    piei->uFlags      = pnfb->uFlags;
                    piei->hwndCaller  = IntToPtr_(HWND, pnfb->dwHwndCaller);
                    piei->wHotkey     = pnfb->dwHotKey;
                    piei->clsid       = pnfb->clsid;
                    piei->clsidInProc = pnfb->clsidInProc;

                    if (pnfb->oidlSelect)
                        piei->pidlSelect = ILClone((LPITEMIDLIST)((LPBYTE)pnfb+pnfb->oidlSelect));

                    if (pnfb->oidlRoot)
                    {
                        LPITEMIDLIST pidlRoot = (LPITEMIDLIST)((LPBYTE)pnfb+pnfb->oidlRoot);
                        if (pnfb->uFlags & COF_HASHMONITOR)
                        {
                            piei->pidlRoot = (LPITEMIDLIST)*(UNALIGNED HMONITOR *)pidlRoot;
                        }
                        else
                        {
                            piei->pidlRoot = ILClone(pidl);
                        }
                    }

                    if (pnfb->oidl)
                        pidl = ILClone((LPITEMIDLIST)((LPBYTE)pnfb+pnfb->oidl));

                    if (pidl) 
                    {
                        piei->pidl = pidl;
                    } 
                    
                    // we pass this string through because msn fails the cocreateinstane of
                    // their desktop if another one is up and running, so we can't convert
                    // this from path to pidl except in the current process context
                    if (pnfb->opszPath) 
                    {
                        LPTSTR pszPath = (LPTSTR)((LPBYTE)pnfb+pnfb->opszPath);
                        HRESULT hr = E_FAIL;
                        
                        if (ILIsRooted(pidl))
                        {
                            //  let the root handle the parsing.
                            IShellFolder *psf;
                            if (SUCCEEDED(IEBindToObject(pidl, &psf)))
                            {
                                hr = IShellFolder_ParseDisplayName(psf, NULL, NULL, pszPath, NULL, &(piei->pidl), NULL);
                                psf->Release();
                            }
                        }
                        else
                            IECreateFromPath(pszPath, &(piei->pidl));

                        // APP COMPAT: these two specific return result codes are the two we ignored for win95.
                        // APP COMPAT: MSN 1.3 Classic accidentally on purpose returns one of these...
                        if ( !piei->pidl )
                        {
                            // failed, report the error to the user ... (will only fail for paths)
                            ASSERT( !PathIsURL( pszPath))

                            if (! (piei->uFlags & COF_NOTUSERDRIVEN) && ( hr != E_OUTOFMEMORY ) && ( hr != HRESULT_FROM_WIN32( ERROR_CANCELLED )))
                            {
                                MLShellMessageBox(
                                                  NULL,
                                                  MAKEINTRESOURCE( IDS_NOTADIR ),
                                                  MAKEINTRESOURCE( IDS_CABINET ),
                                                  MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND,
                                                  pszPath);
                            }
                            fFailure = TRUE;
                        }
                    }

                }
            }
            SHUnlockShared(pnfb);
        }
        SHFreeShared(hBlock, dwProcId);
    }

    // if we really failed somewhere, return NULL
    if (fFailure)
    {
        SHDestroyIETHREADPARAM(piei);
        piei = NULL;
    }
    return piei;
}


// Check the registry for a shell root under this CLSID.
BOOL GetRootFromRootClass(LPCTSTR pszGUID, LPTSTR pszPath, int cchPath)
{
    BOOL bRet;

    TCHAR szClass[MAX_PATH];
    if (SUCCEEDED(StringCchPrintf(szClass, ARRAYSIZE(szClass), TEXT("CLSID\\%s\\ShellExplorerRoot"), pszGUID)))
    {
        // REVIEW: Do we need SRRF_RM_NORMAL?  Is there a reason we wouldn't
        // want this to succeed in either safe or safe network boot modes?
        DWORD cbPath = cchPath * sizeof(TCHAR);
        bRet = ERROR_SUCCESS == SHRegGetValue(HKEY_CLASSES_ROOT, szClass, NULL, SRRF_RT_REG_SZ | SRRF_RM_NORMAL, NULL, pszPath, &cbPath);
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}

// format is ":<hMem>:<hProcess>"

LPITEMIDLIST IDListFromCmdLine(LPCTSTR pszCmdLine, int i)
{
    LPITEMIDLIST pidl = NULL;
    TCHAR szField[80];

    if (_private_ParseField(pszCmdLine, i, szField, ARRAYSIZE(szField)) && szField[0] == TEXT(':'))
    {
        // Convert the string of format ":<hmem>:<hprocess>" into a pointer
        HANDLE hMem = LongToHandle(StrToLong(szField + 1));
        LPTSTR pszNextColon = StrChr(szField + 1, TEXT(':'));
        if (pszNextColon)
        {
            DWORD dwProcId = (DWORD)StrToLong(pszNextColon + 1);
            LPITEMIDLIST pidlGlobal = (LPITEMIDLIST) SHLockShared(hMem, dwProcId);
            if (pidlGlobal)
            {
                pidl = ILClone(pidlGlobal);

                SHUnlockShared(pidlGlobal);
                SHFreeShared(hMem, dwProcId);
            }
        }
    }
    return pidl;
}

#define MYDOCS_CLSIDW L"{450d8fba-ad25-11d0-98a8-0800361b1103}" // CLSID_MyDocuments

LPITEMIDLIST MyDocsIDList(void)
{
    LPITEMIDLIST pidl = NULL;
    IShellFolder *psf;
    HRESULT hres = SHGetDesktopFolder(&psf);
    if (SUCCEEDED(hres))
    {
        hres = psf->ParseDisplayName(NULL, NULL, L"::" MYDOCS_CLSIDW, NULL, &pidl, NULL);
        psf->Release();
    }

    // Win95/NT4 case, go for the real MyDocs folder
    if (FAILED(hres))
    {
        hres = SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &pidl);
    }
    return SUCCEEDED(hres) ? pidl : NULL;
}


BOOL SHExplorerParseCmdLine(PNEWFOLDERINFO pfi)
{
    int i;
    TCHAR szField[MAX_PATH];

    LPCTSTR pszCmdLine = GetCommandLine();
    pszCmdLine = PathGetArgs(pszCmdLine);

    // empty command line -> explorer My Docs
    if (*pszCmdLine == 0)
    {
        pfi->uFlags = COF_CREATENEWWINDOW | COF_EXPLORE;

        // try MyDocs first?
        pfi->pidl = MyDocsIDList();
        if (pfi->pidl == NULL)
        {
            TCHAR szPath[MAX_PATH];
            GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
            PathStripToRoot(szPath);
            pfi->pidl = ILCreateFromPath(szPath);
        }

        return BOOLFROMPTR(pfi->pidl);
    }

    // Arguments must be separated by '=' or ','
    for (i = 1; _private_ParseField(pszCmdLine, i, szField, ARRAYSIZE(szField)); i++)
    {
        if (lstrcmpi(szField, TEXT("/N")) == 0)
        {
            pfi->uFlags |= COF_CREATENEWWINDOW | COF_NOFINDWINDOW;
        }
        else if (lstrcmpi(szField, TEXT("/S")) == 0)
        {
            pfi->uFlags |= COF_USEOPENSETTINGS;
        }
        else if (lstrcmpi(szField, TEXT("/E")) == 0)
        {
            pfi->uFlags |= COF_EXPLORE;
        }
        else if (lstrcmpi(szField, TEXT("/ROOT")) == 0)
        {
            LPITEMIDLIST pidlRoot = NULL;
            CLSID *pclsidRoot = NULL;
            CLSID clsid;

            RIPMSG(!pfi->pidl, "SHExplorerParseCommandLine: (/ROOT) caller passed bad params");

            // of the form:
            //     /ROOT,{clsid}[,<path>]
            //     /ROOT,/IDLIST,:<hmem>:<hprocess>
            //     /ROOT,<path>

            if (!_private_ParseField(pszCmdLine, ++i, szField, ARRAYSIZE(szField)))
                return FALSE;

            // {clsid}
            if (GUIDFromString(szField, &clsid))
            {
                TCHAR szGUID[GUIDSTR_MAX];
                StringCchCopy(szGUID, ARRAYSIZE(szGUID), szField);

                // {clsid} case, if not path compute from the registry
                if (!_private_ParseField(pszCmdLine, ++i, szField, ARRAYSIZE(szField)))
                {
                    // path must come from the registry now
                    if (!GetRootFromRootClass(szGUID, szField, ARRAYSIZE(szField)))
                    {
                        return FALSE;   // bad command line
                    }
                }

                IECreateFromPath(szField, &pidlRoot);
                pclsidRoot = &clsid;

            }
            else if (lstrcmpi(szField, TEXT("/IDLIST")) == 0)
            {
                // /IDLIST
                pidlRoot = IDListFromCmdLine(pszCmdLine, ++i);
            }
            else
            {
                // <path>
                IECreateFromPath(szField, &pidlRoot);
            }

            // fix up bad cmd line "explorer.exe /root," case
            if (pidlRoot == NULL)
            {
                HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP, &pfi->pidlRoot);
                if (FAILED(hr))
                {
                    pfi->pidlRoot = NULL;
                }
            }

            if (pidlRoot)
            {
                pfi->pidl = ILRootedCreateIDList(pclsidRoot, pidlRoot);
                ILFree(pidlRoot);
            }
        }
        else if (lstrcmpi(szField, TEXT("/INPROC")) == 0)
        {
            // Parse and skip the next arg or 2
            if (!_private_ParseField(pszCmdLine, ++i, szField, ARRAYSIZE(szField)))
            {
                return FALSE;
            }

            // The next arg must be a GUID
            if (!GUIDFromString(szField, &pfi->clsidInProc))
            {
                return FALSE;
            }

            pfi->uFlags |= COF_INPROC;
        }
        else if (lstrcmpi(szField, TEXT("/SELECT")) == 0)
        {
            pfi->uFlags |= COF_SELECT;
        }
        else if (lstrcmpi(szField, TEXT("/NOUI")) == 0)
        {
            pfi->uFlags |= COF_NOUI;
        }
        else if (lstrcmpi(szField, TEXT("-embedding")) == 0)
        {
            pfi->uFlags |= COF_AUTOMATION;
        }
        else if (lstrcmpi(szField, TEXT("/IDLIST")) == 0)
        {
            LPITEMIDLIST pidl = IDListFromCmdLine(pszCmdLine, ++i);

            if (pidl)
            {
                if (pfi->pidl)
                {
                    // again, this is kind of bogus (see comment below). If we already have a
                    // pidl, free it and use the new one.
                    ILFree(pfi->pidl);
                }

                pfi->pidl = pidl;
            }
            else if (pfi->pidl == NULL)
            {
                // if we didn't have a pidl before and we dont have one now, we are in trouble, so get out
                return FALSE;
            }
        }
        else if (lstrcmpi(szField, TEXT("/SEPARATE")) == 0)
        {
            pfi->uFlags |= COF_SEPARATEPROCESS;
        }
        else
        {
            LPITEMIDLIST pidl = ILCreateFromPath(szField);
            if (!pidl)
            {
                //
                //  LEGACY - if this is unparseable, then guess it is relative path
                //  this catches "explorer ." as opening the current directory
                //
                TCHAR szDir[MAX_PATH];
                TCHAR szCombined[MAX_PATH];

                DWORD lenDir = GetCurrentDirectory(ARRAYSIZE(szDir), szDir);

                if (lenDir > 0 && lenDir < ARRAYSIZE(szDir) && NULL != PathCombine(szCombined, szDir, szField))
                {
                    pidl = ILCreateFromPath(szCombined);
                }
            }

            // this is kind of bogus: we have traditionally passed both the idlist (/idlist,:580:1612) and the path
            // (C:\Winnt\Profiles\reinerf\Desktop) as the default command string to explorer (see HKCR\Folder\shell
            // \open\command). Since we have both a /idlist and a path, we have always used the latter so that is what
            // we continue to do here.
            if (pfi->pidl)
            {
                ILFree(pfi->pidl);  // free the /idlist pidl and use the one from the path
            }

            pfi->pidl = pidl;
            if (pidl)  
            {
                pfi->uFlags |= COF_NOTRANSLATE;     // pidl is abosolute from the desktop
            }
            else
            {
                pfi->pszPath = (LPSTR) StrDup(szField);
                if (pfi->pszPath)
                {
                    pfi->uFlags |= COF_PARSEPATH;
                }
            }
        }
    }
    return TRUE;
}

#define ISSEP(c)   ((c) == TEXT('=')  || (c) == TEXT(','))
#define ISWHITE(c) ((c) == TEXT(' ')  || (c) == TEXT('\t') || (c) == TEXT('\n') || (c) == TEXT('\r'))
#define ISNOISE(c) ((c) == TEXT('"'))

#define QUOTE   TEXT('"')
#define COMMA   TEXT(',')
#define SPACE   TEXT(' ')
#define EQUAL   TEXT('=')

/* BOOL ParseField(szData,n,szBuf,iBufLen)
 *
 * Given a line from SETUP.INF, will extract the nth field from the string
 * fields are assumed separated by comma's.  Leading and trailing spaces
 * are removed.
 *
 * ENTRY:
 *
 * szData    : pointer to line from SETUP.INF
 * n         : field to extract. ( 1 based )
 *             0 is field before a '=' sign
 * szDataStr : pointer to buffer to hold extracted field
 * iBufLen   : size of buffer to receive extracted field.
 *
 * EXIT: returns TRUE if successful, FALSE if failure.
 *
 * Copied from shell32\util.cpp 
 * note that this is now used to parse the Explorer command line
 * --ccooney
 */
BOOL  _private_ParseField(LPCTSTR pszData, int n, LPTSTR szBuf, int iBufLen)
{
    BOOL  fQuote = FALSE;
    LPCTSTR pszInf = pszData;
    LPTSTR ptr;
    int   iLen = 1;
    
    if (!pszData || !szBuf)
        return FALSE;
    
        /*
        * find the first separator
    */
    while (*pszInf && !ISSEP(*pszInf))
    {
        if (*pszInf == QUOTE)
            fQuote = !fQuote;
        pszInf = CharNext(pszInf);
    }
    
    if (n == 0 && *pszInf != TEXT('='))
        return FALSE;
    
    if (n > 0 && *pszInf == TEXT('=') && !fQuote)
        // Change pszData to point to first field
        pszData = ++pszInf; // Ok for DBCS
    
                           /*
                           *   locate the nth comma, that is not inside of quotes
    */
    fQuote = FALSE;
    while (n > 1)
    {
        while (*pszData)
        {
            if (!fQuote && ISSEP(*pszData))
                break;
            
            if (*pszData == QUOTE)
                fQuote = !fQuote;
            
            pszData = CharNext(pszData);
        }
        
        if (!*pszData)
        {
            szBuf[0] = 0;      // make szBuf empty
            return FALSE;
        }
        
        pszData = CharNext(pszData); // we could do ++ here since we got here
        // after finding comma or equal
        n--;
    }
    
    /*
    * now copy the field to szBuf
    */
    while (ISWHITE(*pszData))
        pszData = CharNext(pszData); // we could do ++ here since white space can
    // NOT be a lead byte
    fQuote = FALSE;
    ptr = szBuf;      // fill output buffer with this
    while (*pszData)
    {
        if (*pszData == QUOTE)
        {
            //
            // If we're in quotes already, maybe this
            // is a double quote as in: "He said ""Hello"" to me"
            //
            if (fQuote && *(pszData+1) == QUOTE)    // Yep, double-quoting - QUOTE is non-DBCS
            {
                if (iLen < iBufLen)
                {
                    *ptr++ = QUOTE;
                    ++iLen;
                }
                pszData++;                   // now skip past 1st quote
            }
            else
                fQuote = !fQuote;
        }
        else if (!fQuote && ISSEP(*pszData))
            break;
        else
        {
            if ( iLen < iBufLen )
            {
                *ptr++ = *pszData;                  // Thank you, Dave
                ++iLen;
            }
            
            if ( IsDBCSLeadByte(*pszData) && (iLen < iBufLen) )
            {
                *ptr++ = pszData[1];
                ++iLen;
            }
        }
        pszData = CharNext(pszData);
    }
    /*
    * remove trailing spaces
    */
    while (ptr > szBuf)
    {
        ptr = CharPrev(szBuf, ptr);
        if (!ISWHITE(*ptr))
        {
            ptr = CharNext(ptr);
            break;
        }
    }
    *ptr = 0;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\sccls.h ===
// Create Instance functions

#ifndef _SCCLS_H_
#define _SCCLS_H_



#define VERSION_2 2 // so we don't get confused by too many integers
#define VERSION_1 1
#define VERSION_0 0
#define COCREATEONLY NULL,NULL,VERSION_0,0,0 // piid,piidEvents,lVersion,dwOleMiscFlags,dwClassFactFlags
#define COCREATEONLY_NOFLAGS NULL,NULL,VERSION_0,0 // piid,piidEvents,lVersion,dwOleMiscFlags



STDAPI  CMediaBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi); // mediaband.cpp
STDAPI  CDocObjectFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CInternetToolbar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CQuickLinks_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CAddressBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);   // address.cpp
STDAPI  CAddressEditBox_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);   // aeditbox.cpp
STDAPI  CBandProxy_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);     // bandprxy.cpp
STDAPI  CBrandBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDeskBarApp_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBrowserBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CSearchBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CCommBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CISFBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
#ifdef ENABLE_CHANNELS
STDAPI  CChannelBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
#endif
STDAPI  CExplorerBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBandSiteMenu_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CComCatCacheTask_CreateInstance( IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi );
STDAPI  CComCatConditionalCacheTask_CreateInstance( IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi );
STDAPI  CAutoComplete_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLHistory_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLIShellFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLMRU_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLCustomMRU_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLMulti_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CCmdFileIcon_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CMenuBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CTrackShellMenu_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CMenuBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  ChannelOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CShellTaskScheduler_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CSharedTaskScheduler_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CDesktopTask_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CWinListShellProc_CreateInstance (IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CAugmentedISF_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CAugmentedISF2_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CIESplashScreen_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  COrderList_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  CMenuSite_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  CCDFCopyHook_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CRegTreeOptions_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  TaskbarList_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CInternetCacheCleaner_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CThumbnail_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CImgCtxThumb_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CImageListCache_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDocFileInfoTip_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CacheFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI  HistFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI  CCommonBrowser_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDockingBarPropertyBag_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBitmapPreload_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CUserAssist_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CGlobalFolderSettings_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

STDAPI CShellSearchExt_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CWebSearchExt_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CProgressDialog_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CAccessible_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CTrackPopupBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CShellUrl_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

STDAPI CBaseBrowser_Validate(HWND hwnd, LPVOID* ppsb);
STDAPI CShellBrowser_CreateInstance(HWND hwnd, LPVOID* ppsb);
STDAPI CExplorerBrowser_CreateInstance(HWND hwnd, LPVOID* ppsb);
STDAPI CSDWindows_CreateInstance(IShellWindows **ppunk);

STDAPI CIEFrameAuto_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk);

// to save some typing:
#define CLSIDOFOBJECT(p)          (*((p)->_pObjectInfo->pclsid))
#define VERSIONOFOBJECT(p)          ((p)->_pObjectInfo->lVersion)
#define EVENTIIDOFCONTROL(p)      (*((p)->_pObjectInfo->piidEvents))
#define OLEMISCFLAGSOFCONTROL(p)    ((p)->_pObjectInfo->dwOleMiscFlags)

extern char g_szLibName[]; // shocx.c
extern CRITICAL_SECTION  g_csDll;

#endif // _SCCLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\sccls.cpp ===
//#define  DONT_USE_ATL
#include "priv.h"
#define ATL_ENABLED
#include "atl.h"

#include "sccls.h"
#include <ntverp.h>

#include <shlobj.h>                 // for CLSID_ACLMRU
#include <schedule.h>

#include "shbrows2.h"               // CWinInetNotify_szWindowClass
#include "desktop.h"                // DESKTOPPROXYCLASS

#include "mluisupp.h"
#define DECL_CRTFREE
#include <crtfree.h>
#include "shfusion.h"

STDAPI_(void) InitURLIDs(UINT uPlatform);       // from shdocfl.cpp
STDAPI SHIsThereASystemScheduler(void);         // from schedule.cpp
STDAPI SHFreeSystemScheduler(void);

//
// Downlevel delay load support (we forward to shlwapi)
//
#include <delayimp.h>

PfnDliHook __pfnDliFailureHook;


LONG                g_cRefThisDll = 0;      // per-instance
CRITICAL_SECTION    g_csDll = {0};          // per-instance
HINSTANCE           g_hinst = NULL;
HANDLE              g_hMutexHistory = NULL;


BOOL g_fNashInNewProcess = FALSE;           // Are we running in a separate process
BOOL g_fRunningOnNT = FALSE;
BOOL g_bRunOnNT5 = FALSE;
BOOL g_fRunOnWhistler = FALSE;
BOOL g_bRunOnMemphis = FALSE;
BOOL g_fRunOnFE = FALSE;
DWORD g_dwStopWatchMode = 0;                // Shell perf automation
HANDLE g_hCabStateChange = NULL;
BOOL g_fIE = FALSE;

// Is Mirroring enabled
BOOL g_bMirroredOS = FALSE;

HPALETTE g_hpalHalftone = NULL;

void DestroyZoneIconNameCache(void);

//
// This array holds information needed for ClassFacory.
// OLEMISC_ flags are used by shembed and shocx.
//
// PERF: this table should be ordered in most-to-least used order
//
CF_TABLE_BEGIN(g_ObjectInfo)

    CF_TABLE_ENTRY(&CLSID_InternetToolbar,         CInternetToolbar_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_BrandBand,               CBrandBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_MenuBandSite,            CMenuBandSite_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_MenuDeskBar,                CMenuDeskBar_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_AugmentedShellFolder,    CAugmentedISF_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_AugmentedShellFolder2,   CAugmentedISF2_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_AddressBand,             CAddressBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_AddressEditBox,          CAddressEditBox_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_BandProxy,               CBandProxy_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY_NOFLAGS( &CLSID_RebarBandSite,           CBandSite_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_ALLOWAGGREGATION),

    CF_TABLE_ENTRY(&CLSID_DeskBarApp,              CDeskBarApp_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_DeskBar,                 CDeskBar_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_AutoComplete,            CAutoComplete_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ACLHistory,              CACLHistory_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ACListISF,               CACLIShellFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ACLMRU,                  CACLMRU_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ACLMulti,                CACLMulti_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY_NOFLAGS( &CLSID_CCommonBrowser,           CCommonBrowser_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_ALLOWAGGREGATION),

    CF_TABLE_ENTRY(&CLSID_CDockingBarPropertyBag,   CDockingBarPropertyBag_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_CRegTreeOptions,          CRegTreeOptions_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_BrowserBand,             CBrowserBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_SearchBand,             CSearchBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_MediaBand,               CMediaBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_CommBand,                CCommBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_BandSiteMenu,            CBandSiteMenu_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ComCatCacheTask,           CComCatCacheTask_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ComCatConditionalCacheTask,CComCatConditionalCacheTask_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ImgCtxThumbnailExtractor,  CImgCtxThumb_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ImageListCache,            CImageListCache_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ShellTaskScheduler,        CShellTaskScheduler_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_SharedTaskScheduler,       CSharedTaskScheduler_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_BrowseuiPreloader,         CBitmapPreload_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ShellSearchExt,            CShellSearchExt_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_WebSearchExt,              CWebSearchExt_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_OrderListExport,           COrderList_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_UserAssist,                CUserAssist_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_GlobalFolderSettings,      CGlobalFolderSettings_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ProgressDialog,            CProgressDialog_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ACLCustomMRU,              CACLCustomMRU_CreateInstance,
        COCREATEONLY),
        
    CF_TABLE_ENTRY_NOFLAGS( &CLSID_MenuBand,        CMenuBand_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_DONTIECREATE), // legacy component, dont default to browseui's impl

    CF_TABLE_ENTRY_NOFLAGS( &CLSID_QuickLinks,      CQuickLinks_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_DONTIECREATE), // legacy component, dont default to browseui's impl

    CF_TABLE_ENTRY_NOFLAGS( &CLSID_ISFBand,         CISFBand_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_DONTIECREATE), // legacy component, dont default to browseui's impl

    CF_TABLE_ENTRY_NOFLAGS( &CLSID_Thumbnail,       CThumbnail_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_DONTIECREATE),  // legacy component, dont default to browseui's impl

    CF_TABLE_ENTRY_NOFLAGS(&CLSID_TrackShellMenu,            CTrackShellMenu_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_DONTIECREATE),  // legacy component, dont default to browseui's impl

CF_TABLE_END(g_ObjectInfo)

// constructor for CObjectInfo.

CObjectInfo::CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein, IID const* piidIn,
                         IID const* piidEventsIn, long lVersionIn, DWORD dwOleMiscFlagsIn,
                         DWORD dwClassFactFlagsIn)
{
    pclsid            = pclsidin;
    pfnCreateInstance = pfnCreatein;
    piid              = piidIn;
    piidEvents        = piidEventsIn;
    lVersion          = lVersionIn;
    dwOleMiscFlags    = dwOleMiscFlagsIn;
    dwClassFactFlags  = dwClassFactFlagsIn;
}


// static class factory (no allocs!)

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;

        if (punkOuter && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hres = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hres))
        {
            hres = punk->QueryInterface(riid, ppv);
            punk->Release();
        }

        ASSERT(FAILED(hres) ? *ppv == NULL : TRUE);
        return hres;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    TraceMsg(DM_TRACE, "sccls: LockServer(%s) to %d", fLock ? TEXT("LOCK") : TEXT("UNLOCK"), g_cRefThisDll);
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    TraceMsg(TF_SHDLIFE, "DllGetClassObject called with riid=%x (%x)", riid, &riid);

    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls;
                DllAddRef();        // class factory holds DLL ref count
                return NOERROR;
            }
        }

#ifdef ATL_ENABLED
        // Try the ATL class factory
        if (SUCCEEDED(AtlGetClassObject(rclsid, riid, ppv)))
            return NOERROR;
#endif
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI DllCanUnloadNow(void)
{
#ifndef UNIX
    // special case for the system scheduler we hang onto
    if ( g_cRefThisDll == 1 && SHIsThereASystemScheduler() == S_OK )
    {
        // this will drop the ref count by one to zero....
        SHFreeSystemScheduler();
    }

#ifdef ATL_ENABLED
    if (0 != g_cRefThisDll || 0 != AtlGetLockCount())
        return S_FALSE;
#else
    if (0 != g_cRefThisDll)
        return S_FALSE;
#endif

#else
    if (g_cRefThisDll)
        return S_FALSE;
#endif

    TraceMsg(DM_TRACE, "DllCanUnloadNow returning S_OK (bye, bye...)");
    return S_OK;
}

// DllGetVersion
//
// All we have to do is declare this puppy and CCDllGetVersion does the rest
//
DLLVER_SINGLEBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);

UINT g_msgMSWheel;
#ifdef DEBUG
EXTERN_C DWORD g_TlsMem = 0xffffffff;
#endif

// imports from isfband.cpp
STDAPI_(void) CLogoBase_Initialize( void );
STDAPI_(void) CLogoBase_Cleanup( void );

//
//  Table of all window classes we register so we can unregister them
//  at DLL unload.
//

const LPCTSTR c_rgszClasses[] = {
    TEXT("BaseBar"),                // basebar.cpp
    TEXT("MenuSite"),               // menusite.cpp
    DESKTOPPROXYCLASS,              // proxy.cpp
    c_szExploreClass,               // shbrows2.cpp
    c_szIExploreClass,              // shbrows2.cpp
    c_szCabinetClass,               // shbrows2.cpp
    c_szAutoSuggestClass,           // autocomp.cpp
    TEXT("MediaPane"),              //Mediaband.cpp
    TEXT("MediaPopupPane"),         //Mediaband.cpp
    TEXT("MediaLayoutPane")         //Mediaband.cpp 
};

//
//  Since we are single-binary, we have to play it safe and do
//  this cleanup (needed only on NT, but harmless on Win95).
//
#define UnregisterWindowClasses() \
    SHUnregisterClasses(HINST_THISDLL, c_rgszClasses, ARRAYSIZE(c_rgszClasses))

void InitNFCtl()
{

    INITCOMMONCONTROLSEX icc;

    icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icc.dwICC = ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icc);
}
const LPCTSTR s_aryExplorerFileName[] =
{
    TEXT("iexplore.exe"),
};

BOOL IsRootExeExplorer(void)
{
    TCHAR szApp[MAX_PATH];
    LPCTSTR pszApp;
    GetModuleFileName(NULL, szApp, ARRAYSIZE(szApp));
    pszApp = PathFindFileName(szApp);
    if (pszApp)
    {
        for (int i = 0; i < ARRAYSIZE(s_aryExplorerFileName); i++)
        {
            if (!lstrcmpi(pszApp, s_aryExplorerFileName[i]))
                return TRUE;
        }
    }
    return FALSE;
}

//
// we use shlwapi as our delayload error handler.
// NOTE: this only works if we are statically linked to shlwapi!
//
void SetupDelayloadErrorHandler()
{
    HMODULE hmod = GetModuleHandleA("shlwapi.dll");
    ASSERTMSG(hmod != NULL, "BROWSEUI must be statically linked to shlwapi.dll for delayload failure handling to work!");
    __pfnDliFailureHook = (PfnDliHook)GetProcAddress(hmod, "DelayLoadFailureHook");
}

STDAPI_(BOOL) DllMain(HINSTANCE hDll, DWORD dwReason, void *fProcessUnload)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        SHFusionInitializeFromModule(hDll);

        SetupDelayloadErrorHandler();

#ifdef ATL_ENABLED
        AtlInit(hDll);
#endif
        DisableThreadLibraryCalls(hDll);    // perf

        g_hinst = hDll;
        InitializeCriticalSection(&g_csDll);
        g_msgMSWheel = RegisterWindowMessage(TEXT("MSWHEEL_ROLLMSG"));

        MLLoadResources(g_hinst, TEXT("browselc.dll"));
        g_fIE = IsRootExeExplorer();
        if (g_fIE)
            InitMUILanguage(MLGetUILanguage());
        
        // Don't put it under #ifdef DEBUG
        CcshellGetDebugFlags();

#ifdef DEBUG
        g_TlsMem = TlsAlloc();
        if (IsFlagSet(g_dwBreakFlags, BF_ONLOADED))
        {
            TraceMsg(TF_ALWAYS, "DllMain() - SHDOCVW.DLL has just loaded");
            DEBUG_BREAK;
        }
#endif
        g_fRunningOnNT = IsOS(OS_NT);

        if (g_fRunningOnNT)
        {
            g_bRunOnNT5 = IsOS(OS_WIN2000ORGREATER);
            g_fRunOnWhistler = IsOS(OS_WHISTLERORGREATER);
        }
        else
            g_bRunOnMemphis = IsOS(OS_WIN98ORGREATER);

        g_fRunOnFE = GetSystemMetrics(SM_DBCSENABLED);

        g_bMirroredOS = IS_MIRRORING_ENABLED();

        InitNFCtl();

        // See if perfmode is enabled
        g_dwStopWatchMode = StopWatchMode();

        // Cache a palette handle for use throughout shdocvw
        g_hpalHalftone = SHCreateShellPalette( NULL );
        CLogoBase_Initialize( );
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
#ifdef ATL_ENABLED
        AtlTerm();
#endif
        CBrandBand_CleanUp();
        CInternetToolbar_CleanUp();
        CUserAssist_CleanUp(dwReason, fProcessUnload);

        CLogoBase_Cleanup();

        // let go of the resource DLL...
        MLFreeResources(g_hinst);

        ENTERCRITICAL;

        DESTROY_OBJ_WITH_HANDLE(g_hpalHalftone, DeletePalette);
        DESTROY_OBJ_WITH_HANDLE(g_hCabStateChange, SHGlobalCounterDestroy);
        DESTROY_OBJ_WITH_HANDLE(g_hMutexHistory, CloseHandle);

        DestroyZoneIconNameCache();

        UnregisterWindowClasses();

        LEAVECRITICAL;

        DeleteCriticalSection(&g_csDll);

        SHFusionUninitialize();
    }

    return TRUE;
}

STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefThisDll);
}

STDAPI_(void) DllRelease(void)
{
    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
}

// IEUNIX
// CoCreateInstance is #defined as IECreateInstance #ifdef __cplusplus,
// so I #undef it  here to prevent the recursive call.
// On Windows it works, because this file is C file.

#ifdef CoCreateInstance
#undef CoCreateInstance
#endif

HRESULT IECreateInstance(REFCLSID rclsid, IUnknown *pUnkOuter,
                    DWORD dwClsContext, REFIID riid, void **ppv)
{
#ifndef NO_MARSHALLING
    if (dwClsContext == CLSCTX_INPROC_SERVER)
#else
    if (dwClsContext & CLSCTX_INPROC_SERVER)
#endif
    {
        LPCOBJECTINFO pcls;
        for (pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            // Note that we do pointer comparison (instead of IsEuqalGUID)
            if ((&rclsid == pcls->pclsid) && !(pcls->dwClassFactFlags & OIF_DONTIECREATE))
            {
                // const -> non-const expclit casting (this is OK)
                IClassFactory* pcf = GET_ICLASSFACTORY(pcls);
                return pcf->CreateInstance(pUnkOuter, riid, ppv);
            }
        }
    }
    // Use SHCoCreateInstanceAC to go through the app compat layer
    return SHCoCreateInstanceAC(rclsid, pUnkOuter, dwClsContext, riid, ppv);
}

#ifdef DEBUG

//
//  In DEBUG, make sure every class we register lives in the c_rgszClasses
//  table so we can clean up properly at DLL unload.  NT does not automatically
//  unregister classes when a DLL unloads, so we have to do it manually.
//
STDAPI_(BOOL) SHRegisterClassD(CONST WNDCLASS *pwc)
{
    for (int i = 0; i < ARRAYSIZE(c_rgszClasses); i++) 
    {
        if (lstrcmpi(c_rgszClasses[i], pwc->lpszClassName) == 0) 
        {
            return RealSHRegisterClass(pwc);
        }
    }
    AssertMsg(0, TEXT("Class %s needs to be added to the c_rgszClasses list"), pwc->lpszClassName);
    return 0;
}

STDAPI_(ATOM) RegisterClassD(CONST WNDCLASS *pwc)
{
    for (int i = 0; i < ARRAYSIZE(c_rgszClasses); i++) 
    {
        if (lstrcmpi(c_rgszClasses[i], pwc->lpszClassName) == 0) 
        {
            return RealRegisterClass(pwc);
        }
    }
    AssertMsg(0, TEXT("Class %s needs to be added to the c_rgszClasses list"), pwc->lpszClassName);
    return 0;
}

//
//  In DEBUG, send FindWindow through a wrapper that ensures that the
//  critical section is not taken.  FindWindow'ing for a window title
//  sends inter-thread WM_GETTEXT messages, which is not obvious.
//
STDAPI_(HWND) FindWindowD(LPCTSTR lpClassName, LPCTSTR lpWindowName)
{
    return FindWindowExD(NULL, NULL, lpClassName, lpWindowName);
}

STDAPI_(HWND) FindWindowExD(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpClassName, LPCTSTR lpWindowName)
{
    if (lpWindowName) 
    {
        ASSERTNONCRITICAL;
    }
    return RealFindWindowEx(hwndParent, hwndChildAfter, lpClassName, lpWindowName);
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\runonnt.c ===
#include "priv.h"

// no wrappers are needed on non-x86 since this is only for win9x interop
#ifdef _X86_

//============================================================================
// This file contains a bunch of Unicode/Ansi thunks to handle calling
// some internal functions that on Windows 95 the strings are Ansi,
// whereas the string on NT are unicode
//============================================================================

// First undefine everything that we are intercepting as to not forward back to us...
#undef ILCreateFromPath
#undef PathCleanupSpec
#undef PathQualify
#undef PathProcessCommand
#undef SHCLSIDFromString
#undef SHGetSpecialFolderPath
#undef SHILCreateFromPath
#undef SHSimpleIDListFromPath
#undef GetFileNameFromBrowse
#undef Win32DeleteFile
#undef PathYetAnotherMakeUniqueName
#undef PathResolve
#undef IsLFNDrive
#undef Shell_GetCachedImageIndex
#undef SHRunControlPanel
#undef PickIconDlg
#undef ILCreateFromPathW
#undef SHCreateDirectory

#if 0
#define TF_THUNK    TF_CUSTOM1
#else
#define TF_THUNK    0
#endif

#define THUNKMSG(psz)   TraceMsg(TF_THUNK, "shdv THUNK::%s", psz)

#ifndef ANSI_SHELL32_ON_UNIX

#ifdef DEBUG
#define UseUnicodeShell32() (g_fRunningOnNT && !(g_dwPrototype & PF_FORCEANSI))
#else
#define UseUnicodeShell32() g_fRunningOnNT
#endif

#else

#define UseUnicodeShell32() (FALSE)

#endif

int _AorW_SHRunControlPanel(LPCTSTR pszOrig_cmdline, HWND errwnd)
{
    if (g_fRunningOnNT)
    {
        WCHAR wzPath[MAX_PATH];

        SHTCharToUnicode(pszOrig_cmdline, wzPath, ARRAYSIZE(wzPath));
        return SHRunControlPanel((LPCTSTR)wzPath, errwnd);
    }
    else
    {
        CHAR szPath[MAX_PATH];

        SHTCharToAnsi(pszOrig_cmdline, szPath, ARRAYSIZE(szPath));
        return SHRunControlPanel((LPCTSTR)szPath, errwnd);
    }
}

int _AorW_Shell_GetCachedImageIndex(LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags)
{
    if (UseUnicodeShell32())
    {
        WCHAR wzPath[MAX_PATH];

        SHTCharToUnicode(pszIconPath, wzPath, ARRAYSIZE(wzPath));
        return Shell_GetCachedImageIndex((LPCTSTR)wzPath, iIconIndex, uIconFlags);
    }
    else
    {
        CHAR szPath[MAX_PATH];

        SHTCharToAnsi(pszIconPath, szPath, ARRAYSIZE(szPath));
        return Shell_GetCachedImageIndex((LPCTSTR)szPath, iIconIndex, uIconFlags);
    }
}

// the reverse, do it for wide strings also..
int _WorA_Shell_GetCachedImageIndex(LPCWSTR pwzIconPath, int iIconIndex, UINT uIconFlags)
{
    CHAR szPath[MAX_PATH];

    if (!g_fRunningOnNT)
    {
        SHUnicodeToAnsi(pwzIconPath, szPath, ARRAYSIZE(szPath));
        pwzIconPath = (LPCWSTR)szPath;  // overload the pointer to pass through...
    }

    return Shell_GetCachedImageIndex((LPCTSTR)pwzIconPath, iIconIndex, uIconFlags);
}

// Explicit prototype because only the A/W prototypes exist in the headers
STDAPI_(LPITEMIDLIST) ILCreateFromPath(LPCTSTR pszPath);

LPITEMIDLIST _AorW_ILCreateFromPath(LPCTSTR pszPath)
{
    WCHAR wzPath[MAX_PATH];
    CHAR szPath[MAX_PATH];

    THUNKMSG(TEXT("ILCreateFromPath"));

    if (g_fRunningOnNT)
    {
        SHTCharToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));
        pszPath = (LPCTSTR)wzPath;  // overload the pointer to pass through...
    }
    else
    {
        SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }

    return ILCreateFromPath(pszPath);
}

int _AorW_PathCleanupSpec(/*IN OPTIONAL*/ LPCTSTR pszDir, /*IN OUT*/ LPTSTR pszSpec)
{
    THUNKMSG(TEXT("PathCleanupSpec"));

    if (g_fRunningOnNT)
    {
        WCHAR wzDir[MAX_PATH];
        WCHAR wzSpec[MAX_PATH];
        LPWSTR pwszDir = wzDir;
        int iRet;

        if (pszDir)
            SHTCharToUnicode(pszDir, wzDir, ARRAYSIZE(wzDir));
        else
            pwszDir = NULL;

        SHTCharToUnicode(pszSpec, wzSpec, ARRAYSIZE(wzSpec));
        iRet = PathCleanupSpec((LPTSTR)pwszDir, (LPTSTR)wzSpec);

        SHUnicodeToTChar(wzSpec, pszSpec, MAX_PATH);
        return iRet;
    }
    else
    {
        CHAR szDir[MAX_PATH];
        CHAR szSpec[MAX_PATH];
        LPSTR pszDir2 = szDir;
        int iRet;

        if (pszDir)
            SHTCharToAnsi(pszDir, szDir, ARRAYSIZE(szDir));
        else
            pszDir2 = NULL;

        SHTCharToAnsi(pszSpec, szSpec, ARRAYSIZE(szSpec));
        iRet = PathCleanupSpec((LPTSTR)pszDir2, (LPTSTR)szSpec);

        SHAnsiToTChar(szSpec, pszSpec, MAX_PATH);
        return iRet;
    }
}

void _AorW_PathQualify(/*IN OUT*/ LPTSTR pszDir)
{
    THUNKMSG(TEXT("PathQualify"));
    if (g_fRunningOnNT)
    {
        WCHAR wszDir[MAX_PATH];

        SHTCharToUnicode(pszDir, wszDir, ARRAYSIZE(wszDir));
        PathQualify((LPTSTR)wszDir);
        SHUnicodeToTChar(wszDir, pszDir, MAX_PATH);
    }
    else
    {
        CHAR szDir[MAX_PATH];

        SHTCharToAnsi(pszDir, szDir, ARRAYSIZE(szDir));
        PathQualify((LPTSTR)szDir);
        SHAnsiToTChar(szDir, pszDir, MAX_PATH);
    }
}

LONG WINAPI _AorW_PathProcessCommand(/*IN*/ LPCTSTR pszSrc, /*OUT*/LPTSTR pszDest, int iDestMax, DWORD dwFlags)
{
    LONG    lReturnValue;

    THUNKMSG(TEXT("PathProcessCommand"));
    if (g_fRunningOnNT)
    {
        WCHAR wszSrc[MAX_PATH];
        WCHAR wszDest[MAX_PATH];

        SHTCharToUnicode(pszSrc, wszSrc, ARRAYSIZE(wszSrc));
        lReturnValue = PathProcessCommand((LPTSTR)wszSrc, (LPTSTR)wszDest, ARRAYSIZE(wszDest), dwFlags);
        SHUnicodeToTChar(wszDest, pszDest, iDestMax);
    }
    else
    {
        CHAR szSrc[MAX_PATH];
        CHAR szDest[MAX_PATH];

        SHTCharToAnsi(pszSrc, szSrc, ARRAYSIZE(szSrc));
        lReturnValue = PathProcessCommand((LPTSTR)szSrc, (LPTSTR)szDest, ARRAYSIZE(szDest), dwFlags);
        SHAnsiToTChar(szDest, pszDest, iDestMax);
    }

    return(lReturnValue);
}

// Explicit prototype because only the A/W prototypes exist in the headers
STDAPI_(BOOL) SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR lpszPath, int nFolder, BOOL fCreate);

BOOL _AorW_SHGetSpecialFolderPath(HWND hwndOwner, /*OUT*/ LPTSTR pszPath, int nFolder, BOOL fCreate)
{
    THUNKMSG(TEXT("SHGetSpecialFolderPath"));

    if (g_fRunningOnNT)
    {
        WCHAR wzPath[MAX_PATH];

        BOOL fRet = SHGetSpecialFolderPath(hwndOwner, (LPTSTR)wzPath, nFolder, fCreate);
        if (fRet)
            SHUnicodeToTChar(wzPath, pszPath, MAX_PATH);

        return fRet;
    }
    else
    {
        CHAR szPath[MAX_PATH];

        BOOL fRet = SHGetSpecialFolderPath(hwndOwner, (LPTSTR)szPath, nFolder, fCreate);
        if (fRet)
            SHAnsiToTChar(szPath, pszPath, MAX_PATH);

        return fRet;
    }
}

HRESULT _AorW_SHILCreateFromPath(/*IN OPTIONAL*/LPCTSTR pszPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut)
{
    WCHAR wzPath[MAX_PATH];
    CHAR szPath[MAX_PATH];

    THUNKMSG(TEXT("SHILCreateFromPath"));

    if (pszPath)
    {
        if (g_fRunningOnNT)
        {
            SHTCharToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));
            pszPath = (LPCTSTR)wzPath;  // overload the pointer to pass through...
        }
        else
        {
            SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
            pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
        }
    }

    return SHILCreateFromPath(pszPath, ppidl, rgfInOut);
}

LPITEMIDLIST _AorW_SHSimpleIDListFromPath(/*IN OPTIONAL*/ LPCTSTR pszPath)
{
    WCHAR wzPath[MAX_PATH];
    CHAR szPath[MAX_PATH];

    THUNKMSG(TEXT("SHSimpleIDListFromPath"));

    if (pszPath)
    {
        if (g_fRunningOnNT)
        {
            SHTCharToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));
            pszPath = (LPCTSTR)wzPath;  // overload the pointer to pass through...
        }
        else
        {
            SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
            pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
        }
    }

    return SHSimpleIDListFromPath(pszPath);
}

#define ISNOT_RESOURCE(pItem)      ((pItem) && HIWORD((pItem)) && LOWORD((pItem)))

int FindDoubleTerminator(LPCTSTR pszStr)
{
    int nIndex = 1;

    // Find the double terminator
    while (pszStr[nIndex] || pszStr[nIndex-1])
        nIndex++;

    return nIndex;
}

#define TEMP_SMALL_BUF_SZ  256

BOOL WINAPI _AorW_GetFileNameFromBrowse(HWND hwnd, /*IN OUT*/ LPTSTR pszFilePath, UINT cchFilePath,
        /*IN OPTIONAL*/ LPCTSTR pszWorkingDir, /*IN OPTIONAL*/ LPCTSTR pszDefExt, 
        /*IN OPTIONAL*/ LPCTSTR pszFilters, /*IN OPTIONAL*/ LPCTSTR pszTitle)
{
    WCHAR wszPath[MAX_PATH];
    WCHAR wszDir[MAX_PATH];
    WCHAR wszExt[TEMP_SMALL_BUF_SZ];
    WCHAR wszTitle[TEMP_SMALL_BUF_SZ];

#ifndef UNICODE
    WCHAR wszFilters[TEMP_SMALL_BUF_SZ*2];
#else // UNICODE
    CHAR szFilters[TEMP_SMALL_BUF_SZ*2];
#endif // UNICODE

    CHAR szPath[MAX_PATH];
    CHAR szDir[MAX_PATH];
    CHAR szExt[TEMP_SMALL_BUF_SZ];
    CHAR szTitle[TEMP_SMALL_BUF_SZ];
    BOOL    bResult;
    THUNKMSG(TEXT("GetFileNameFromBrowse"));

    // thunk strings to unicode 
    if (g_fRunningOnNT)
    {
        // always move pszFilePath stuff to wszPath buffer. Should never be a resourceid.
        SHTCharToUnicode(pszFilePath, wszPath, ARRAYSIZE(wszPath));
        pszFilePath = (LPTSTR)wszPath;

        if (ISNOT_RESOURCE(pszWorkingDir)) //not a resource
        {
            SHTCharToUnicode(pszWorkingDir, wszDir, ARRAYSIZE(wszDir));
            pszWorkingDir = (LPCTSTR)wszDir;
        }
        if (ISNOT_RESOURCE(pszDefExt)) //not a resource
        {
            SHTCharToUnicode(pszDefExt, wszExt, ARRAYSIZE(wszExt));
            pszDefExt = (LPCTSTR)wszExt;
        }
        if (ISNOT_RESOURCE(pszFilters)) //not a resource
        {
#ifndef UNICODE
            int nIndex = FindDoubleTerminator(pszFilters);

            // nIndex+1 looks like bunk unless it goes past the terminator
            MultiByteToWideChar(CP_ACP, 0, (LPCTSTR)pszFilters, nIndex+1, wszFilters, ARRAYSIZE(wszFilters));
            pszFilters = (LPCTSTR)wszFilters;
#endif // UNICODE
        }
        if (ISNOT_RESOURCE(pszTitle)) //not a resource
        {
            SHTCharToUnicode(pszTitle, wszTitle, ARRAYSIZE(wszTitle));
            pszTitle = (LPCTSTR)wszTitle;
        }
    }
    else
    {
        // always move pszFilePath stuff to wszPath buffer. Should never be a resourceid.
        SHTCharToAnsi(pszFilePath, szPath, ARRAYSIZE(szPath));
        pszFilePath = (LPTSTR)szPath;

        if (ISNOT_RESOURCE(pszWorkingDir)) //not a resource
        {
            SHTCharToAnsi(pszWorkingDir, szDir, ARRAYSIZE(szDir));
            pszWorkingDir = (LPCTSTR)szDir;
        }
        if (ISNOT_RESOURCE(pszDefExt)) //not a resource
        {
            SHTCharToAnsi(pszDefExt, szExt, ARRAYSIZE(szExt));
            pszDefExt = (LPCTSTR)szExt;
        }
        if (ISNOT_RESOURCE(pszFilters)) //not a resource
        {
#ifdef UNICODE
            int nIndex = FindDoubleTerminator(pszFilters);

            // nIndex+1 looks like bunk unless it goes past the terminator
            WideCharToMultiByte(CP_ACP, 0, (LPCTSTR)pszFilters, nIndex+1, szFilters, ARRAYSIZE(szFilters), NULL, NULL);
            pszFilters = (LPCTSTR)szFilters;
#endif // UNICODE
        }
        if (ISNOT_RESOURCE(pszTitle)) //not a resource
        {
            SHTCharToAnsi(pszTitle, szTitle, ARRAYSIZE(szTitle));
            pszTitle = (LPCTSTR)szTitle;
        }
    }

    bResult = GetFileNameFromBrowse(hwnd, pszFilePath, cchFilePath, pszWorkingDir, pszDefExt, pszFilters, pszTitle);

    // thunk string back to multibyte
    if (g_fRunningOnNT)
        SHUnicodeToTChar(wszPath, pszFilePath, cchFilePath);
    else
        SHAnsiToTChar(szPath, pszFilePath, cchFilePath);

    return bResult;
}

BOOL _AorW_Win32DeleteFile(/*IN*/ LPCTSTR pszFileName)
{
    WCHAR wzPath[MAX_PATH];
    CHAR szPath[MAX_PATH];

    THUNKMSG(TEXT("Win32DeleteFile"));
    if (g_fRunningOnNT)
    {
        SHTCharToUnicode(pszFileName, wzPath, ARRAYSIZE(wzPath));
        pszFileName = (LPCTSTR)wzPath;  // overload the pointer to pass through...
    }
    else
    {
        SHTCharToAnsi(pszFileName, szPath, ARRAYSIZE(szPath));
        pszFileName = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }

    return Win32DeleteFile(pszFileName);
}

BOOL _AorW_PathYetAnotherMakeUniqueName(LPTSTR pszUniqueName,
                                        LPCTSTR pszPath,
                                        LPCTSTR pszShort,
                                        LPCTSTR pszFileSpec)
{
    THUNKMSG(TEXT("PathYetAnotherMakeUniqueName"));
    if (UseUnicodeShell32())
    {
        WCHAR wszUniqueName[MAX_PATH];
        WCHAR wszPath[MAX_PATH];
        WCHAR wszShort[32];
        WCHAR wszFileSpec[MAX_PATH];
        BOOL fRet;

        SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));
        pszPath = (LPCTSTR)wszPath;  // overload the pointer to pass through...

        if (pszShort)
        {
            SHTCharToUnicode(pszShort, wszShort, ARRAYSIZE(wszShort));
            pszShort = (LPCTSTR)wszShort;  // overload the pointer to pass through...
        }

        if (pszFileSpec)
        {
            SHTCharToUnicode(pszFileSpec, wszFileSpec, ARRAYSIZE(wszFileSpec));
            pszFileSpec = (LPCTSTR)wszFileSpec;  // overload the pointer to pass through...
        }

        fRet = PathYetAnotherMakeUniqueName((LPTSTR)wszUniqueName, pszPath, pszShort, pszFileSpec);
        if (fRet)
            SHUnicodeToTChar(wszUniqueName, pszUniqueName, MAX_PATH);

        return fRet;
    }
    else
    {
        CHAR szUniqueName[MAX_PATH];
        CHAR szPath[MAX_PATH];
        CHAR szShort[32];
        CHAR szFileSpec[MAX_PATH];
        BOOL fRet;

        SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...

        if (pszShort)
        {
            SHTCharToAnsi(pszShort, szShort, ARRAYSIZE(szShort));
            pszShort = (LPCTSTR)szShort;  // overload the pointer to pass through...
        }

        if (pszFileSpec)
        {
            SHTCharToAnsi(pszFileSpec, szFileSpec, ARRAYSIZE(szFileSpec));
            pszFileSpec = (LPCTSTR)szFileSpec;  // overload the pointer to pass through...
        }

        fRet = PathYetAnotherMakeUniqueName((LPTSTR)szUniqueName, pszPath, pszShort, pszFileSpec);
        if (fRet)
            SHAnsiToTChar(szUniqueName, pszUniqueName, MAX_PATH);

        return fRet;
    }
}

BOOL _AorW_PathResolve(/*IN OUT*/ LPTSTR pszPath, /*IN OPTIONAL*/ LPCTSTR rgpszDirs[], UINT fFlags)
{
    THUNKMSG(TEXT("PathResolve"));
    if (g_fRunningOnNT)
    {
        WCHAR wzPath[MAX_PATH];
        WCHAR wzDir[MAX_PATH];
        BOOL fRet;

        SHTCharToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));

        if (rgpszDirs && rgpszDirs[0])
        {
            SHTCharToUnicode(rgpszDirs[0], wzDir, ARRAYSIZE(wzDir));
            rgpszDirs[0] = (LPCTSTR)wzDir;  // overload the pointer to pass through...

            if (rgpszDirs[1])
            {
                // Super Hack, we assume dirs has only one element since it's the only case
                // this is called in SHDOCVW.
                AssertMsg(0, TEXT("PathResolve thunk needs to be fixed to handle more than one dirs."));
                rgpszDirs[1] = NULL;
            }
        }

        fRet = PathResolve((LPTSTR)wzPath, rgpszDirs, fFlags);
        if (fRet)
            SHUnicodeToTChar(wzPath, pszPath, MAX_PATH);

        return fRet;
    }
    else
    {
        CHAR szPath[MAX_PATH];
        CHAR szDir[MAX_PATH];
        BOOL fRet;

        SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));

        if (rgpszDirs && rgpszDirs[0])
        {
            SHTCharToAnsi(rgpszDirs[0], szDir, ARRAYSIZE(szDir));
            rgpszDirs[0] = (LPCTSTR)szDir;  // overload the pointer to pass through...

            if (rgpszDirs[1])
            {
                // Super Hack, we assume dirs has only one element since it's the only case
                // this is called in SHDOCVW.
                AssertMsg(0, TEXT("PathResolve thunk needs to be fixed to handle more than one dirs."));
                rgpszDirs[1] = NULL;
            }
        }

        fRet = PathResolve((LPTSTR)szPath, rgpszDirs, fFlags);
        if (fRet)
            SHAnsiToTChar(szPath, pszPath, MAX_PATH);

        return fRet;
    }
}


// Explicit prototype because only the A/W prototypes exist in the headers
BOOL IsLFNDrive(LPCTSTR pszPath);



BOOL _AorW_IsLFNDrive(/*IN*/ LPTSTR pszPath)
{
    THUNKMSG(TEXT("IsLFNDrive"));

    if (g_fRunningOnNT)
    {
        WCHAR wszPath[MAX_PATH];

        SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));
        return IsLFNDrive((LPTSTR)wszPath);
    }
    else
    {
        CHAR szPath[MAX_PATH];

        SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        return IsLFNDrive((LPTSTR)szPath);
    }
}


int _AorW_PickIconDlg(
    IN     HWND  hwnd, 
    IN OUT LPTSTR pszIconPath, 
    IN     UINT  cchIconPath, 
    IN OUT int * piIconIndex)
{
    int nRet;
    WCHAR wszPath[MAX_PATH];
    CHAR szPath[MAX_PATH];
    LPTSTR psz = pszIconPath;
    UINT cch = cchIconPath;
    
    if (g_fRunningOnNT)
    {
        SHTCharToUnicode(pszIconPath, wszPath, ARRAYSIZE(wszPath));
        psz = (LPTSTR)wszPath;  // overload the pointer to pass through...
        cch = SIZECHARS(wszPath);
    }
    else
    {
        SHTCharToAnsi(pszIconPath, szPath, ARRAYSIZE(wszPath));
        psz = (LPTSTR)szPath;  // overload the pointer to pass through...
        cch = SIZECHARS(szPath);
    }

    nRet = PickIconDlg(hwnd, psz, cch, piIconIndex);

    if (g_fRunningOnNT)
        SHUnicodeToTChar(wszPath, pszIconPath, cchIconPath);
    else
        SHAnsiToTChar(szPath, pszIconPath, cchIconPath);

    return nRet;
}

//
//  Now the thunks that allow us to run on Windows 95.
//
//

//
//  This thunks a unicode string to ANSI, but if it's an ordinal, then
//  we just leave it alone.
//
LPSTR Thunk_UnicodeToAnsiOrOrdinal(LPCWSTR pwsz, LPSTR pszBuf, UINT cchBuf)
{
    if (HIWORD64(pwsz)) {
        SHUnicodeToAnsi(pwsz, pszBuf, cchBuf);
        return pszBuf;
    } else {
        return (LPSTR)pwsz;
    }
}

#define THUNKSTRING(pwsz, sz) Thunk_UnicodeToAnsiOrOrdinal(pwsz, sz, ARRAYSIZE(sz))


//
//  This function is new for IE4, so on IE3,
//  we emulate (poorly) with ExtractIcon.
//

//
//  Win95 exported ILCreateFromPathA under the name ILCreateFromPath.
//  Fortunately, NT kept the same ordinal.
//
//
//  If linking with Win95 header files, then call it ILCreateFromPath.
//

#ifdef UNICODE
STDAPI_(LPITEMIDLIST) _ILCreateFromPathA(LPCSTR pszPath)
{
    if (g_fRunningOnNT) {
        WCHAR wszPath[MAX_PATH];
        SHAnsiToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));
        return ILCreateFromPath((LPVOID)wszPath);
    } else {
        return ILCreateFromPath((LPVOID)pszPath);
    }
}
#else
STDAPI_(LPITEMIDLIST) _ILCreateFromPathW(LPCWSTR pszPath)
{
    if (g_fRunningOnNT) {
        return ILCreateFromPath((LPVOID)pszPath);
    } else {
        CHAR szPath[MAX_PATH];
        SHUnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        return ILCreateFromPath((LPVOID)szPath);
    }
}
#endif

        
STDAPI_(int) _AorW_SHCreateDirectory(HWND hwnd, LPCTSTR pszPath)
{
    if (g_fRunningOnNT)
    {
        WCHAR wsz[MAX_PATH];

        SHTCharToUnicode(pszPath, wsz, ARRAYSIZE(wsz));
        return SHCreateDirectory(hwnd, (LPCTSTR)wsz);
    }
    else
    {
        CHAR  sz[MAX_PATH];

        SHTCharToAnsi(pszPath, sz, ARRAYSIZE(sz));
        return SHCreateDirectory(hwnd, (LPCTSTR)sz);
    }
}

#ifdef UNICODE

//
//  Either ptsz1 or ptsz2 can be NULL, so be careful when thunking.
//
STDAPI_(int) _AorW_ShellAbout(HWND hWnd, LPCTSTR ptsz1, LPCTSTR ptsz2, HICON hIcon)
{
    if (g_fRunningOnNT)
    {
        return ShellAboutW(hWnd, ptsz1, ptsz2, hIcon);
    }
    else
    {
        CHAR  sz1[MAX_PATH], sz2[MAX_PATH];
        LPSTR psz1, psz2;

        if (ptsz1) {
            psz1 = sz1;
            SHTCharToAnsi(ptsz1, sz1, ARRAYSIZE(sz1));
        } else {
            psz1 = NULL;
        }

        if (ptsz2) {
            psz2 = sz2;
            SHTCharToAnsi(ptsz2, sz2, ARRAYSIZE(sz2));
        } else {
            psz2 = NULL;
        }

        return ShellAboutA(hWnd, psz1, psz2, hIcon);
    }
}

#endif

#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\rgtreeop.cpp ===
#include "priv.h"
#include "resource.h"
#include "tmschema.h"
#include "uxtheme.h"
#include "uxthemep.h"
#include "mluisupp.h"
#include <oleacc.h>
#include <cowsite.h>
#include <apithk.h>

const struct
{
    TREE_TYPE   type;
    LPCTSTR     name;
} c_aTreeTypes[] =
{
    {TREE_CHECKBOX, TEXT("checkbox")},
    {TREE_RADIO, TEXT("radio")},
    {TREE_GROUP, TEXT("group")}
};

const TCHAR c_szType[]              = TEXT("Type");
const TCHAR c_szText[]              = TEXT("Text");
const TCHAR c_szPlugUIText[]        = TEXT("PlugUIText");
const TCHAR c_szDefaultBitmap[]     = TEXT("Bitmap");
const TCHAR c_szHKeyRoot[]          = TEXT("HKeyRoot");
const TCHAR c_szValueName[]         = TEXT("ValueName");
const TCHAR c_szCheckedValue[]      = TEXT("CheckedValue");
const TCHAR c_szUncheckedValue[]    = TEXT("UncheckedValue");
const TCHAR c_szDefaultValue[]      = TEXT("DefaultValue");
const TCHAR c_szSPIActionGet[]      = TEXT("SPIActionGet");
const TCHAR c_szSPIActionSet[]      = TEXT("SPIActionSet");
const TCHAR c_szCLSID[]             = TEXT("CLSID");
const TCHAR c_szCheckedValueNT[]    = TEXT("CheckedValueNT");
const TCHAR c_szCheckedValueW95[]   = TEXT("CheckedValueW95");
const TCHAR c_szMask[]              = TEXT("Mask");
const TCHAR c_szOffset[]            = TEXT("Offset");
const TCHAR c_szHelpID[]            = TEXT("HelpID");
const TCHAR c_szWarning[]           = TEXT("WarningIfNotDefault");


#define BITMAP_WIDTH    16
#define BITMAP_HEIGHT   16
#define NUM_BITMAPS     5
#define MAX_KEY_NAME    64

DWORD RegTreeType(LPCTSTR pszType);
BOOL AppendStatus(LPTSTR pszText, UINT cchText, BOOL fOn);
BOOL IsScreenReaderEnabled();

class CRegTreeOptions : public IRegTreeOptions, public CObjectWithSite
{
public:
    CRegTreeOptions();
    IUnknown *GetUnknown() { return SAFECAST(this, IRegTreeOptions*); }

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
   
    // IRegTreeOptions Methods
    STDMETHODIMP InitTree(HWND hwndTree, HKEY hkeyRoot, LPCSTR pszRegKey, LPCSTR pszParam);
    STDMETHODIMP WalkTree(WALK_TREE_CMD cmd);
    STDMETHODIMP ShowHelp(HTREEITEM hti, DWORD dwFlags);
    STDMETHODIMP ToggleItem(HTREEITEM hti);

protected:
    ~CRegTreeOptions();

    void    _RegEnumTree(HUSKEY huskey, HTREEITEM htviparent, HTREEITEM htvins);
    int     _DefaultIconImage(HUSKEY huskey, int iImage);
    DWORD   _GetCheckStatus(HUSKEY huskey, BOOL *pbChecked, BOOL bUseDefault);
    DWORD   _GetSetByCLSID(REFCLSID clsid, BOOL *pbData, BOOL fGet);
    DWORD   _GetSetByRegKey(HUSKEY husKey, DWORD *pType, LPBYTE pData, DWORD *pcbData, REG_CMD cmd);
    DWORD   _RegGetSetSetting(HUSKEY husKey, DWORD *pType, LPBYTE pData, DWORD *pcbData, REG_CMD cmd);
    BOOL    _WalkTreeRecursive(HTREEITEM htvi,WALK_TREE_CMD cmd);
    DWORD   _SaveCheckStatus(HUSKEY huskey, BOOL bChecked);
    BOOL    _RegIsRestricted(HUSKEY hussubkey);
    UINT        _cRef;
    HWND        _hwndTree;
    LPTSTR      _pszParam;
    HIMAGELIST  _hIml;
};

//////////////////////////////////////////////////////////////////////////////
//
// CRegTreeOptions Object
//
//////////////////////////////////////////////////////////////////////////////

STDAPI CRegTreeOptions_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    TraceMsg(DM_TRACE, "rto - CreateInstance(...) called");
    
    CRegTreeOptions *pTO = new CRegTreeOptions();
    if (pTO)
    {
        *ppunk = pTO->GetUnknown();
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

CRegTreeOptions::CRegTreeOptions() 
{
    TraceMsg(DM_TRACE, "rto - CRegTreeOptions() called.");
    _cRef = 1;
    DllAddRef();
}       

CRegTreeOptions::~CRegTreeOptions()
{
    ASSERT(_cRef == 0);                 // should always have zero
    TraceMsg(DM_TRACE, "rto - ~CRegTreeOptions() called.");

    Str_SetPtr(&_pszParam, NULL);
                
    DllRelease();
}    

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CRegTreeOptions::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CRegTreeOptions, IRegTreeOptions),        // IID_IRegTreeOptions
        QITABENT(CRegTreeOptions, IObjectWithSite),        // IID_IObjectWithSite
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CRegTreeOptions::AddRef()
{
    TraceMsg(DM_TRACE, "rto - AddRef() called.");
    
    return ++_cRef;
}

ULONG CRegTreeOptions::Release()
{

    TraceMsg(DM_TRACE, "rto - Release() called.");
    
    if (--_cRef)
        return _cRef;

    // destroy the imagelist
    if (_hwndTree)
    {
        ImageList_Destroy(TreeView_SetImageList(_hwndTree, NULL, TVSIL_NORMAL));

        // Clean up the accessibility stuff
        RemoveProp(_hwndTree, TEXT("MSAAStateImageMapCount"));
        RemoveProp(_hwndTree, TEXT("MSAAStateImageMapAddr"));
    }

    delete this;
    return 0;   
}


//////////////////////////////////
//
// IRegTreeOptions Methods...
//

//
//  Accessibility structure so it knows how to convert treeview state images
//  into accessibility roles and states.
//
struct MSAASTATEIMAGEMAPENT
{
    DWORD dwRole;
    DWORD dwState;
};

const struct MSAASTATEIMAGEMAPENT c_rgimeTree[] =
{
  { ROLE_SYSTEM_CHECKBUTTON, STATE_SYSTEM_CHECKED }, // IDCHECKED
  { ROLE_SYSTEM_CHECKBUTTON, 0 },                    // IDUNCHECKED
  { ROLE_SYSTEM_RADIOBUTTON, STATE_SYSTEM_CHECKED }, // IDRADIOON
  { ROLE_SYSTEM_RADIOBUTTON, 0 },                    // IDRADIOOFF
  { ROLE_SYSTEM_OUTLINE, 0 },                        // IDUNKNOWN
};

HBITMAP CreateDIB(HDC h, int cx, int cy, RGBQUAD** pprgb)
{
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    return CreateDIBSection(h, &bi, DIB_RGB_COLORS, (void**)pprgb, NULL, 0);
}

HRESULT CRegTreeOptions::InitTree(HWND hwndTree, HKEY hkeyRoot, LPCSTR pszRegKey, LPCSTR pszParam)
{
    // all callers pass HKEY_LOCAL_MACHINE, yay what a cool interface
    // assert that this is so, since the HUSKEY code now relies on being able to switch between
    // HKCU and HKLM.
    ASSERT(hkeyRoot == HKEY_LOCAL_MACHINE);
    
    TCHAR szParam[MAX_URL_STRING];
    TraceMsg(DM_TRACE, "rto - InitTree called().");
    UINT flags = ILC_MASK | (IsOS(OS_WHISTLERORGREATER)?ILC_COLOR32:ILC_COLOR);

    if (!hkeyRoot || !pszRegKey)
        return E_INVALIDARG;

    if (pszParam)
    {
        SHAnsiToTChar(pszParam, szParam, ARRAYSIZE(szParam));
        Str_SetPtr(&_pszParam, szParam);      // be sure to free in destructor
    }
    
    _hwndTree = hwndTree;
    if(IS_WINDOW_RTL_MIRRORED(_hwndTree))
    {
        flags |= ILC_MIRROR;
    }
    _hIml = ImageList_Create(BITMAP_WIDTH, BITMAP_HEIGHT, flags, NUM_BITMAPS, 4);

    // Initialize the tree view window.
    SHSetWindowBits(_hwndTree, GWL_STYLE, TVS_CHECKBOXES, 0);

    HBITMAP hBitmap = 0;

#ifdef UNIX
    // IEUNIX (Varma): an ugly hack to workaround _AddMasked api problems while
    // creating masked bitmaps.  Need to create DIBSection from 
    // CreateMappedBitmap.  This is to fix buttons visibility on mono when black
    if (SHGetCurColorRes() < 2) 
    {
        hBitmap = CreateMappedBitmap(g_hinst, IDB_BUTTONS, CMB_MASKED, NULL, 0);
        if (hBitmap)
        {
            ImageList_Add(_hIml, hBitmap, NULL);
            // Delete hBitmap in common further down this codepath
        }
    }
    else 
#endif
    {
        HTHEME hTheme = OpenThemeData(NULL, L"Button");
        if (hTheme)
        {
            HDC hdc = CreateCompatibleDC(NULL);
            if (hdc)
            {
                HBITMAP hbmp = CreateDIB(hdc, BITMAP_WIDTH, BITMAP_HEIGHT, NULL);
                if (hbmp)
                {
                    RECT rc = {0, 0, BITMAP_WIDTH, BITMAP_HEIGHT};
                    static const s_rgParts[] = {BP_CHECKBOX,BP_CHECKBOX,BP_RADIOBUTTON,BP_RADIOBUTTON};
                    static const s_rgStates[] = {CBS_CHECKEDNORMAL, CBS_UNCHECKEDNORMAL, RBS_CHECKEDNORMAL, RBS_UNCHECKEDNORMAL};
                    for (int i = 0; i < ARRAYSIZE(s_rgParts); i++)
                    {
                        HBITMAP hOld = (HBITMAP)SelectObject(hdc, hbmp);
                        SHFillRectClr(hdc, &rc, RGB(0,0,0));
                        DTBGOPTS dtbg = {sizeof(DTBGOPTS), DTBG_DRAWSOLID, 0,};   // tell drawthemebackground to preserve the alpha channel

                        DrawThemeBackgroundEx(hTheme, hdc, s_rgParts[i], s_rgStates[i], &rc, &dtbg);
                        SelectObject(hdc, hOld);

                        ImageList_Add(_hIml, hbmp, NULL);
                    }

                    DeleteObject(hbmp);

                    // Hate this. Maybe get an authored icon?
                    hBitmap = CreateMappedBitmap(g_hinst, IDB_GROUPBUTTON, 0, NULL, 0);
                    if (hBitmap)
                    {
                        ImageList_AddMasked(_hIml, hBitmap, CLR_DEFAULT);
                        // Delete hBitmap in common further down the codepath
                    }

                }
                DeleteDC(hdc);
            }
            CloseThemeData(hTheme);
        }
        else
        {
            hBitmap = CreateMappedBitmap(g_hinst, IDB_BUTTONS, 0, NULL, 0);
            if (hBitmap)
            {
                ImageList_AddMasked(_hIml, hBitmap, CLR_DEFAULT);
                // Delete hBitmap in common further down the codepath
            }
        }
    }

    if (hBitmap)
        DeleteObject(hBitmap);

    // Associate the image list with the tree.
    HIMAGELIST himl = TreeView_SetImageList(_hwndTree, _hIml, TVSIL_NORMAL);
    if (himl)
        ImageList_Destroy(himl);

    // Let accessibility know about our state images
    SetProp(_hwndTree, TEXT("MSAAStateImageMapCount"), LongToPtr(ARRAYSIZE(c_rgimeTree)));
    SetProp(_hwndTree, TEXT("MSAAStateImageMapAddr"), (HANDLE)c_rgimeTree);

    HUSKEY huskey;
    if (ERROR_SUCCESS == SHRegOpenUSKeyA(pszRegKey, KEY_ENUMERATE_SUB_KEYS, NULL, &huskey, FALSE))
    {
        _RegEnumTree(huskey, NULL, TVI_ROOT);
        SHRegCloseUSKey(huskey);
    }

    return S_OK;
}

HRESULT CRegTreeOptions::WalkTree(WALK_TREE_CMD cmd)
{
    HTREEITEM htvi = TreeView_GetRoot(_hwndTree);
    
    // and walk the list of other roots
    while (htvi)
    {
        // recurse through its children
        _WalkTreeRecursive(htvi, cmd);

        // get the next root
        htvi = TreeView_GetNextSibling(_hwndTree, htvi);
    }
    
    return S_OK;    // success?
}

HRESULT _LoadUSRegUIString(HUSKEY huskey, PCTSTR pszValue, PTSTR psz, UINT cch)
{
    psz[0] = 0;

    HRESULT hr = E_FAIL;
    TCHAR szIndirect[MAX_PATH];
    DWORD cb = sizeof(szIndirect);
    if (ERROR_SUCCESS == SHRegQueryUSValue(huskey, pszValue, NULL, szIndirect, &cb, FALSE, NULL, 0))
    {
        hr = SHLoadIndirectString(szIndirect, psz, cch, NULL);
    }
    return hr;
}

HRESULT CRegTreeOptions::ToggleItem(HTREEITEM hti)
{
    TV_ITEM tvi;
    TCHAR szText[MAX_PATH];
    
    tvi.hItem = hti;
    tvi.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_PARAM;
    tvi.pszText = szText;
    tvi.cchTextMax = ARRAYSIZE(szText);
    
    if (hti && TreeView_GetItem(_hwndTree, &tvi))
    {
        BOOL bScreenReaderEnabled = IsScreenReaderEnabled();
        HUSKEY huskey = (HUSKEY)tvi.lParam;

        TCHAR szMsg[512];
        if (SUCCEEDED(_LoadUSRegUIString(huskey, c_szWarning, szMsg, ARRAYSIZE(szMsg))))
        {
            BOOL bDefaultState, bCurrentState = (tvi.iImage == IDCHECKED) || (tvi.iImage == IDRADIOON);

            if (ERROR_SUCCESS == _GetCheckStatus(huskey, &bDefaultState, TRUE))
            {
                // trying to change the current state to the non recomended state?
                if (bDefaultState == bCurrentState)
                {
                    if (MLShellMessageBox(_hwndTree, szMsg, MAKEINTRESOURCE(IDS_WARNING), (MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION)) != IDYES)
                    {
                        return S_FALSE;
                    }
                }
            }
        }

        if (tvi.iImage == IDUNCHECKED)
        {
            tvi.iImage         = IDCHECKED;
            tvi.iSelectedImage = IDCHECKED;
            //See if we need to add status text
            if (bScreenReaderEnabled)
            {
                AppendStatus(szText, ARRAYSIZE(szText), TRUE);
            }
            TraceMsg(TF_GENERAL, "rto::ToggleItem() - Checked!");
        }
        else if (tvi.iImage == IDCHECKED)
        {
            tvi.iImage         = IDUNCHECKED;
            tvi.iSelectedImage = IDUNCHECKED;
            //See if we need to add status text
            if (bScreenReaderEnabled)
            {
                AppendStatus(szText, ARRAYSIZE(szText), FALSE);
            }
            TraceMsg(TF_GENERAL, "rto::ToggleItem() - Unchecked!");
        }
        else if ((tvi.iImage == IDRADIOON) || (tvi.iImage == IDRADIOOFF))
        {
            HTREEITEM htvi;
            TV_ITEM   otvi; // other tvi-s
            TCHAR     szOtext[MAX_PATH];
        
            // change all the "on" radios to "off"
            htvi = TreeView_GetParent(_hwndTree, tvi.hItem);
            htvi = TreeView_GetChild(_hwndTree, htvi);
        
            // hunt for the "on"s
            while (htvi)
            {
                // get info about item
                otvi.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;
                otvi.hItem = htvi;
                otvi.pszText = szOtext;
                otvi.cchTextMax = ARRAYSIZE(szOtext);
                if (TreeView_GetItem(_hwndTree, &otvi))
                {
                    // is it a radio button that is on?
                    if (otvi.iImage == IDRADIOON)
                    {   // yes.. turn it off
                        otvi.iImage         = IDRADIOOFF;
                        otvi.iSelectedImage = IDRADIOOFF;
                        //See if we need to add status text
                        if (bScreenReaderEnabled)
                        {
                            AppendStatus(szOtext,ARRAYSIZE(szOtext), FALSE);
                        }
                
                        TreeView_SetItem(_hwndTree, &otvi);
                    }
                }
            
                // find the next child
                htvi = TreeView_GetNextSibling(_hwndTree, htvi);
            }  
        
            // turn on the item that was hit
            tvi.iImage         = IDRADIOON;
            tvi.iSelectedImage = IDRADIOON;
        
            //See if we need to add status text
            if (bScreenReaderEnabled)
            {
                AppendStatus(szText,ARRAYSIZE(szText), TRUE);
            }
        
        } 
    
        // change only if it is a checkbox or radio item
        if (tvi.iImage <= IDUNKNOWN)
        {
            TreeView_SetItem(_hwndTree, &tvi);
        }
    }
    return S_OK;
}

HRESULT CRegTreeOptions::ShowHelp(HTREEITEM hti, DWORD dwFlags)
{
    TV_ITEM tvi;

    tvi.mask  = TVIF_HANDLE | TVIF_PARAM;
    tvi.hItem = hti;

    if (hti && TreeView_GetItem(_hwndTree, &tvi))
    {
        HUSKEY huskey = (HUSKEY)tvi.lParam;

        TCHAR szHelpID[MAX_PATH+10]; // max path for helpfile + 10 for the help id
        DWORD cbHelpID = sizeof(szHelpID);
    
        if (SHRegQueryUSValue(huskey, c_szHelpID, NULL, szHelpID, &cbHelpID, FALSE, NULL, 0) == ERROR_SUCCESS)
        {
            LPTSTR psz = StrChr(szHelpID, TEXT('#'));
            if (psz)
            {
                DWORD mapIDCToIDH[4];

                *psz++ = 0; // NULL the '#'
        
                mapIDCToIDH[0] = GetDlgCtrlID(_hwndTree);
                mapIDCToIDH[1] = StrToInt(psz);
                mapIDCToIDH[2] = 0;
                mapIDCToIDH[3] = 0;
            
                SHWinHelpOnDemandWrap(_hwndTree, szHelpID, dwFlags, (DWORD_PTR)mapIDCToIDH);
                return S_OK;
            }
        }
    }
    return E_FAIL;
}


int CRegTreeOptions::_DefaultIconImage(HUSKEY huskey, int iImage)
{
    TCHAR szIcon[MAX_PATH + 10];   // 10 = ",XXXX" plus some more
    DWORD cb = sizeof(szIcon);

    if (ERROR_SUCCESS == SHRegQueryUSValue(huskey, c_szDefaultBitmap, NULL, szIcon, &cb, FALSE, NULL, 0))
    {
        LPTSTR psz = StrRChr(szIcon, szIcon + lstrlen(szIcon), TEXT(','));
        ASSERT(psz);   // shouldn't be zero
        if (!psz)
            return iImage;

        *psz++ = 0; // terminate and move over
        int image = StrToInt(psz); // get ID

        HICON hicon = NULL;
        if (!*szIcon)
        {
            hicon = (HICON)LoadIcon(g_hinst, (LPCTSTR)(INT_PTR)image);
        }
        else
        {
            // get the bitmap from the library
            ExtractIconEx(szIcon, (UINT)(-1*image), NULL, &hicon, 1);
            if (!hicon)
                ExtractIconEx(szIcon, (UINT)(-1*image), &hicon, NULL, 1);
                
        }
        
        if (hicon)
        {
            iImage = ImageList_AddIcon(_hIml, (HICON)hicon);

            // NOTE: The docs say you don't need to do a delete object on icons loaded by LoadIcon, but
            // you do for CreateIcon.  It doesn't say what to do for ExtractIcon, so we'll just call it anyway.
            DestroyIcon(hicon);
        }
    }

    return iImage;
}

//
//  The CLSID can either be a service ID (which we will QS for) or a CLSID
//  that we CoCreateInstance.
//
DWORD CRegTreeOptions::_GetSetByCLSID(REFCLSID clsid, BOOL* pbData, BOOL fGet)
{
    IRegTreeItem *pti;
    HRESULT hr;

    if (SUCCEEDED(hr = IUnknown_QueryService(_punkSite, clsid, IID_PPV_ARG(IRegTreeItem, &pti))) ||
        SUCCEEDED(hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IRegTreeItem, &pti))))
    {
        hr = fGet ? pti->GetCheckState(pbData) : pti->SetCheckState(*pbData);
        pti->Release();
    }
    return SUCCEEDED(hr) ? ERROR_SUCCESS : ERROR_BAD_FORMAT;
}

DWORD CRegTreeOptions::_GetSetByRegKey(HUSKEY husKey, DWORD *pType, LPBYTE pData, DWORD *pcbData, REG_CMD cmd)
{
    // support for masks 
    DWORD dwMask;
    DWORD cb = sizeof(dwMask);
    dwMask = 0xFFFFFFFF;        // Default value
    BOOL fMask = (SHRegQueryUSValue(husKey, c_szMask, NULL, &dwMask, &cb, FALSE, NULL, 0) == ERROR_SUCCESS);
    
    // support for structures
    DWORD dwOffset;
    cb = sizeof(dwOffset);
    dwOffset = 0;               // Default value
    BOOL fOffset = (SHRegQueryUSValue(husKey, c_szOffset, NULL, &dwOffset, &cb, FALSE, NULL, 0) == ERROR_SUCCESS);
    
    HKEY hkRoot = HKEY_CURRENT_USER; // Preinitialize to keep Win64 happy    
    cb = sizeof(DWORD); // DWORD, not sizeof(HKEY) or Win64 will get mad
    DWORD dwError = SHRegQueryUSValue(husKey, c_szHKeyRoot, NULL, &hkRoot, &cb, FALSE, NULL, 0);
    hkRoot = (HKEY) LongToHandle(HandleToLong(hkRoot));
    if (dwError != ERROR_SUCCESS)
    {
        // use default
        hkRoot = HKEY_CURRENT_USER;
    }
    
    // allow "RegPath9x" to override "RegPath" when running on Win9x
    TCHAR szPath[MAX_PATH];
    cb = sizeof(szPath);
    if (!g_fRunningOnNT)
    {
        dwError = SHRegQueryUSValue(husKey, TEXT("RegPath9x"), NULL, szPath, &cb, FALSE, NULL, 0);
        if (ERROR_SUCCESS != dwError)
        {
            cb = sizeof(szPath);
            dwError = SHRegQueryUSValue(husKey, TEXT("RegPath"), NULL, szPath, &cb, FALSE, NULL, 0);
        }
    }
    else
    {
        dwError = SHRegQueryUSValue(husKey, TEXT("RegPath"), NULL, szPath, &cb, FALSE, NULL, 0);
    }

    TCHAR szBuf[MAX_PATH];
    LPTSTR pszPath;
    if (ERROR_SUCCESS == dwError)
    {
        if (_pszParam)
        {
            HRESULT hr = StringCchPrintf(szBuf, ARRAYSIZE(szBuf), szPath, _pszParam);
            if (FAILED(hr))
            {
                return ERROR_INSUFFICIENT_BUFFER;
            }

            pszPath = szBuf;
        }
        else
        {
            pszPath = szPath;
        }
    }
    else
    {
        if (cmd == REG_GET)
            return SHRegQueryUSValue(husKey, c_szDefaultValue, pType, pData, pcbData, FALSE, NULL, 0);
        else
            return dwError;
    }
    
    TCHAR szName[MAX_PATH];
    cb = sizeof(szName);
    dwError = SHRegQueryUSValue(husKey, c_szValueName, NULL, szName, &cb, FALSE, NULL, 0);
    if (dwError == ERROR_SUCCESS)
    {
        HKEY hKeyReal;
        DWORD dw;
        REGSAM samDesired = KEY_QUERY_VALUE;
        if (cmd == REG_SET)
        {
            samDesired |= KEY_SET_VALUE;
        }

        dwError = RegCreateKeyEx(hkRoot, pszPath, 0, NULL, 0, samDesired, NULL, &hKeyReal, &dw);
        if (dwError == ERROR_SUCCESS)
        {
            switch (cmd)
            {
            case REG_SET:
                if (fOffset || fMask)
                {
                    DWORD cbData;
                    
                    // Note: It so happens that the Valuename maynot be in the registry so we
                    // to make sure  that we have the valuename already in the registry.
                    
                    //Try to do a SHRegQueryValue 
                    dwError = SHQueryValueEx(hKeyReal, szName, NULL, NULL, NULL, &cbData);
                    
                    //Does the Value exists ?
                    if (dwError == ERROR_FILE_NOT_FOUND)                   
                    {                        
                        //We dont have the Valuename in the registry so create it.
                        DWORD dwTypeDefault, dwDefault, cbDefault = sizeof(dwDefault);
                        dwError = SHRegQueryUSValue(husKey, c_szDefaultValue, &dwTypeDefault, &dwDefault, &cbDefault, FALSE, NULL, 0);
                        
                        //This should succeed . if not then someone messed up the registry setting
                        if (dwError == ERROR_SUCCESS)
                        {
                            dwError = SHSetValue(hKeyReal, NULL, szName, dwTypeDefault, &dwDefault, cbDefault);
                            
                            //By setting this value we dont have to do the failed (see above) Query again
                            cbData = cbDefault;
                        }
                    }
                    
                    // Now we know for sure  that the value exists in the registry.
                    // Do the usual stuff.
                    
                    // grab the size of the entry
                    if (dwError == ERROR_SUCCESS)
                    {
                        // alloc enough space for it
                        DWORD *pdwData = (DWORD *)LocalAlloc(LPTR, cbData);
                        if (pdwData)
                        {
                            // get the data
                            dwError = SHQueryValueEx(hKeyReal, szName, NULL, pType, pdwData, &cbData);
                            if (dwError == ERROR_SUCCESS && dwOffset < cbData / sizeof(DWORD))
                            {
                                // NOTE: offset defaults to 0 and mask defaults to 0xffffffff, so if there's only
                                // a mask or only an offset, we'll do the right thing
                            
                                *(pdwData + dwOffset) &= ~dwMask;             // clear the bits
                                *(pdwData + dwOffset) |= *((DWORD *)pData);  // set the bits

                                dwError = SHSetValue(hKeyReal, NULL, szName, *pType, pdwData, cbData);
                            }
                            LocalFree(pdwData);
                        }
                        else
                            return ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                else
                {
                    dwError = SHSetValue(hKeyReal, NULL, szName, *pType, pData, *pcbData);
                }
                
                break;
                
            case REG_GET:
                // grab the value that we have
                if (fOffset)
                {
                    DWORD cbData;
                    
                    if (SHQueryValueEx(hKeyReal, szName, NULL, NULL, NULL, &cbData) == ERROR_SUCCESS)
                    {
                        DWORD *pdwData = (DWORD*)LocalAlloc(LPTR, cbData);
                        if (pdwData)
                        {
                            dwError = SHQueryValueEx(hKeyReal, szName, NULL, pType, pdwData, &cbData);
                            if (dwOffset < cbData / sizeof(DWORD))
                                *((DWORD *)pData) = *(pdwData + dwOffset);
                            else
                                *((DWORD *)pData) = 0;  // Invalid offset, return something vague
                            *pcbData = sizeof(DWORD);
                            LocalFree(pdwData);
                        }
                        else
                            return ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                else
                {                    
                    dwError = SHQueryValueEx(hKeyReal, szName, NULL, pType, pData, pcbData);
                }
                
                if ((dwError == ERROR_SUCCESS) && fMask)
                {
                    *((DWORD *)pData) &= dwMask;
                }
                break;
            }
            
            RegCloseKey(hKeyReal);
        }
    }
    
    if ((cmd == REG_GET) && (dwError != ERROR_SUCCESS))
    {
        // get the default setting
        dwError = SHRegQueryUSValue(husKey, c_szDefaultValue, pType, pData, pcbData, FALSE, NULL, 0);
    }
    
    return dwError;
}

DWORD CRegTreeOptions::_RegGetSetSetting(HUSKEY husKey, DWORD *pType, LPBYTE pData, DWORD *pcbData, REG_CMD cmd)
{
    UINT uiAction;
    DWORD cbAction = sizeof(uiAction);
    TCHAR szCLSID[80];
    DWORD cbCLSID = sizeof(szCLSID);

    if (cmd == REG_GETDEFAULT)
    {
        return SHRegQueryUSValue(husKey, c_szDefaultValue, pType, pData, pcbData, FALSE, NULL, 0);
    }
    else if (SHRegQueryUSValue(husKey, (cmd == REG_GET) ? c_szSPIActionGet : c_szSPIActionSet,
                NULL, &uiAction, &cbAction, FALSE, NULL, 0) == ERROR_SUCCESS)
    {
        *pcbData = sizeof(DWORD);
        *pType = REG_DWORD;
        SHBoolSystemParametersInfo(uiAction, (DWORD*)pData);
        return ERROR_SUCCESS;
    }
    else if (SHRegQueryUSValue(husKey, c_szCLSID, NULL, &szCLSID, &cbCLSID, FALSE, NULL, 0) == ERROR_SUCCESS)
    {
        *pcbData = sizeof(DWORD);
        *pType = REG_DWORD;

        CLSID clsid;
        GUIDFromString(szCLSID, &clsid);

        return _GetSetByCLSID(clsid, (BOOL*)pData, (cmd == REG_GET));
    }
    else
    {
        return _GetSetByRegKey(husKey, pType, pData, pcbData, cmd);
    }
}

DWORD CRegTreeOptions::_GetCheckStatus(HUSKEY huskey, BOOL *pbChecked, BOOL bUseDefault)
{
    DWORD dwError, cbData, dwType;
    BYTE rgData[32];
    DWORD cbDataCHK, dwTypeCHK;
    BYTE rgDataCHK[32];
    BOOL bCompCHK = TRUE;

    // first, get the setting from the specified location.    
    cbData = sizeof(rgData);
    
    dwError = _RegGetSetSetting(huskey, &dwType, rgData, &cbData, bUseDefault ? REG_GETDEFAULT : REG_GET);
    if (dwError == ERROR_SUCCESS)
    {
        // second, get the value for the "checked" state and compare.
        cbDataCHK = sizeof(rgDataCHK);
        dwError = SHRegQueryUSValue(huskey, c_szCheckedValue, &dwTypeCHK, rgDataCHK, &cbDataCHK, FALSE, NULL, 0);
        if (dwError != ERROR_SUCCESS)
        {
            // ok, we couldn't find the "checked" value, is it because
            // it's platform dependent?
            cbDataCHK = sizeof(rgDataCHK);
            dwError = SHRegQueryUSValue(huskey,
                g_fRunningOnNT ? c_szCheckedValueNT : c_szCheckedValueW95,
                &dwTypeCHK, rgDataCHK, &cbDataCHK, FALSE, NULL, 0);
        }
        
        if (dwError == ERROR_SUCCESS)
        {
            // make sure two value types match.
            if ((dwType != dwTypeCHK) &&
                    (((dwType == REG_BINARY) && (dwTypeCHK == REG_DWORD) && (cbData != 4))
                    || ((dwType == REG_DWORD) && (dwTypeCHK == REG_BINARY) && (cbDataCHK != 4))))
                return ERROR_BAD_FORMAT;
                
            switch (dwType) {
            case REG_DWORD:
                *pbChecked = (*((DWORD*)rgData) == *((DWORD*)rgDataCHK));
                break;
                
            case REG_SZ:
                if (cbData == cbDataCHK)
                    *pbChecked = !lstrcmp((LPTSTR)rgData, (LPTSTR)rgDataCHK);
                else
                    *pbChecked = FALSE;
                    
                break;
                
            case REG_BINARY:
                if (cbData == cbDataCHK)
                    *pbChecked = !memcmp(rgData, rgDataCHK, cbData);
                else
                    *pbChecked = FALSE;
                    
                break;
                
            default:
                return ERROR_BAD_FORMAT;
            }
        }
    }
    
    return dwError;
}

DWORD CRegTreeOptions::_SaveCheckStatus(HUSKEY huskey, BOOL bChecked)
{
    DWORD dwError, cbData, dwType;
    BYTE rgData[32];

    cbData = sizeof(rgData);
    dwError = SHRegQueryUSValue(huskey, bChecked ? c_szCheckedValue : c_szUncheckedValue, &dwType, rgData, &cbData, FALSE, NULL, 0);
    if (dwError != ERROR_SUCCESS)   // was it because of a platform specific value?
    {
        cbData = sizeof(rgData);
        dwError = SHRegQueryUSValue(huskey, bChecked ? (g_fRunningOnNT ? c_szCheckedValueNT : c_szCheckedValueW95) : c_szUncheckedValue,
                                    &dwType, rgData, &cbData, FALSE, NULL, 0);
    }
    if (dwError == ERROR_SUCCESS)
    {
        dwError = _RegGetSetSetting(huskey, &dwType, rgData, &cbData, REG_SET);
    }
    
    return dwError;
}


HTREEITEM Tree_AddItem(HTREEITEM hParent, LPTSTR pszText, HTREEITEM hInsAfter, 
                       int iImage, HWND hwndTree, HUSKEY huskey, BOOL *pbExisted)
{
    HTREEITEM hItem;
    TV_ITEM tvI;
    TV_INSERTSTRUCT tvIns;
    TCHAR szText[MAX_URL_STRING];

    ASSERT(pszText != NULL);
    HRESULT hr = StringCchCopy(szText, ARRAYSIZE(szText), pszText);
    if (FAILED(hr))
    {
        return NULL;
    }

    // NOTE:
    //  This code segment is disabled because we only enum explorer
    //  tree in HKCU, so there won't be any duplicates.
    //  Re-able this code if we start to also enum HKLM that could potentially
    //  result in duplicates.
    
    // We only want to add an item if it is not already there.
    // We do this to handle reading out of HKCU and HKLM.
    //
    TCHAR szKeyName[MAX_KEY_NAME];
    
    tvI.mask        = TVIF_HANDLE | TVIF_TEXT;
    tvI.pszText     = szKeyName;
    tvI.cchTextMax  = ARRAYSIZE(szKeyName);
    
    for (hItem = TreeView_GetChild(hwndTree, hParent);
        hItem != NULL;
        hItem = TreeView_GetNextSibling(hwndTree, hItem)
       )
    {
        tvI.hItem = hItem;
        if (TreeView_GetItem(hwndTree, &tvI))
        {
            if (!StrCmp(tvI.pszText, szText))
            {
                // We found a match!
                //
                *pbExisted = TRUE;
                return hItem;
            }
        }
    }

    // Create the item
    tvI.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvI.iImage         = iImage;
    tvI.iSelectedImage = iImage;
    tvI.pszText        = szText;
    tvI.cchTextMax     = lstrlen(szText);

    // lParam contains the HUSKEY for this item:
    tvI.lParam = (LPARAM)huskey;

    // Create insert item
    tvIns.item         = tvI;
    tvIns.hInsertAfter = hInsAfter;
    tvIns.hParent      = hParent;

    // Insert the item into the tree.
    hItem = (HTREEITEM) SendMessage(hwndTree, TVM_INSERTITEM, 0, 
                                    (LPARAM)(LPTV_INSERTSTRUCT)&tvIns);

    *pbExisted = FALSE;
    return (hItem);
}

BOOL _IsValidKey(HKEY hkeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValue)
{
    TCHAR szPath[MAX_PATH];
    DWORD dwType, cbSize = sizeof(szPath);

    if (ERROR_SUCCESS == SHGetValue(hkeyRoot, pszSubKey, pszValue, &dwType, szPath, &cbSize))
    {
        // Zero in the DWORD case or NULL in the string case
        // indicates that this item is not available.
        if (dwType == REG_DWORD)
            return *((DWORD *)szPath) != 0;
        else
            return szPath[0] != 0;
    }

    return FALSE;
}

#define REGSTR_POLICIES_EXPLORER TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer")

BOOL CRegTreeOptions::_RegIsRestricted(HUSKEY hussubkey)
{
    HUSKEY huskey;
    BOOL fRet = FALSE;
    // Does a "Policy" Sub key exist?
    if (SHRegOpenUSKey(TEXT("Policy"), KEY_ENUMERATE_SUB_KEYS, hussubkey, &huskey, FALSE) == ERROR_SUCCESS)
    {
        // Yes; Enumerate this key. The Values are Policy keys or 
        // Full reg paths.
        DWORD cb;
        TCHAR szKeyName[MAX_KEY_NAME];

        for (int i=0; 
            cb = ARRAYSIZE(szKeyName),
            ERROR_SUCCESS == SHRegEnumUSKey(huskey, i, szKeyName, &cb, SHREGENUM_HKLM)
            && !fRet; i++)
        {
            TCHAR szPath[MAXIMUM_SUB_KEY_LENGTH];
            DWORD dwType, cbSize = sizeof(szPath);

            HUSKEY huskeyTemp;
            if (ERROR_SUCCESS == SHRegOpenUSKey(szKeyName, KEY_QUERY_VALUE, huskey, &huskeyTemp, FALSE))
            {
                if (ERROR_SUCCESS == SHRegQueryUSValue(huskeyTemp, TEXT("RegKey"), &dwType, szPath, &cbSize, FALSE, NULL, 0))
                {
                    if (_IsValidKey(HKEY_LOCAL_MACHINE, szPath, szKeyName))
                    {
                        fRet = TRUE;
                        break;
                    }
                }
                SHRegCloseUSKey(huskeyTemp);
            }

            // It's not a full Key, try off of policies
            if (_IsValidKey(HKEY_LOCAL_MACHINE, REGSTR_POLICIES_EXPLORER, szKeyName) ||
                _IsValidKey(HKEY_CURRENT_USER, REGSTR_POLICIES_EXPLORER, szKeyName))
            {
                fRet = TRUE;
                break;
            }
        }
        SHRegCloseUSKey(huskey);
    }

    return fRet;
}

void CRegTreeOptions::_RegEnumTree(HUSKEY huskey, HTREEITEM htviparent, HTREEITEM htvins)
{
    TCHAR szKeyName[MAX_KEY_NAME];    
    DWORD cb;
    BOOL bScreenReaderEnabled = IsScreenReaderEnabled();

    // we must search all the sub-keys
    for (int i=0;                    // always start with 0
        cb=ARRAYSIZE(szKeyName),   // string size
        ERROR_SUCCESS == SHRegEnumUSKey(huskey, i, szKeyName, &cb, SHREGENUM_HKLM);
        i++)                    // get next entry
    {
        HUSKEY hussubkey;
        // get more info on the entry
        if (ERROR_SUCCESS == SHRegOpenUSKey(szKeyName, KEY_QUERY_VALUE, huskey, &hussubkey, FALSE))
        {
            HUSKEY huskeySave = NULL;

            if (!_RegIsRestricted(hussubkey))
            {
                TCHAR szTemp[MAX_PATH];
                // Get the type of items under this root
                cb = ARRAYSIZE(szTemp);
                if (ERROR_SUCCESS == SHRegQueryUSValue(hussubkey, c_szType, NULL, szTemp, &cb, FALSE, NULL, 0))
                {
                    int     iImage;
                    BOOL    bChecked;
                    DWORD   dwError = ERROR_SUCCESS;

                    // get the type of node
                    DWORD dwTreeType = RegTreeType(szTemp);
                    
                    // get some more info about the this item
                    switch (dwTreeType)
                    {
                        case TREE_GROUP:
                            iImage = _DefaultIconImage(hussubkey, IDUNKNOWN);
                            huskeySave = hussubkey;
                            break;
                    
                        case TREE_CHECKBOX:
                            dwError = _GetCheckStatus(hussubkey, &bChecked, FALSE);
                            if (dwError == ERROR_SUCCESS)
                            {
                                iImage = bChecked ? IDCHECKED : IDUNCHECKED;
                                huskeySave = hussubkey;
                            }
                            break;

                        case TREE_RADIO:
                            dwError = _GetCheckStatus(hussubkey, &bChecked, FALSE);
                            if (dwError == ERROR_SUCCESS)
                            {
                                iImage = bChecked ? IDRADIOON : IDRADIOOFF;
                                huskeySave = hussubkey;
                            }
                            break;

                        default:
                            dwError = ERROR_INVALID_PARAMETER;
                    }

                    if (dwError == ERROR_SUCCESS)
                    {
                        BOOL bItemExisted = FALSE;
                        LPTSTR pszText;

                        // try to get the plugUI enabled text
                        // otherwise we want the old data from a
                        // different value

                        int cch = ARRAYSIZE(szTemp);
                        HRESULT hr = _LoadUSRegUIString(hussubkey, c_szPlugUIText, szTemp, cch);
                        if (SUCCEEDED(hr) && szTemp[0] != TEXT('@'))
                        {
                            pszText = szTemp;
                        }
                        else 
                        {
                            // try to get the old non-plugUI enabled text
                            hr = _LoadUSRegUIString(hussubkey, c_szText, szTemp, cch);
                            if (SUCCEEDED(hr))
                            {
                                pszText = szTemp;
                            }
                            else
                            {
                                // if all else fails, the key name itself
                                // is a little more useful than garbage

                                pszText = szKeyName;
                                cch = ARRAYSIZE(szKeyName);
                            }
                        }

                        //See if we need to add status text
                        if (bScreenReaderEnabled && (dwTreeType != TREE_GROUP))
                        {
                            AppendStatus(pszText, cch, bChecked);
                        }

                        // add root node
                        HTREEITEM htviroot = Tree_AddItem(htviparent, pszText, htvins, iImage, _hwndTree, huskeySave, &bItemExisted);
                        if (htviroot != NULL)
                        {
                            if (bItemExisted)
                                huskeySave = NULL;

                            if (dwTreeType == TREE_GROUP)
                            {
                                HUSKEY huskeySubTree;
                                if (ERROR_SUCCESS == SHRegOpenUSKey(szKeyName, KEY_ENUMERATE_SUB_KEYS, huskey, &huskeySubTree, FALSE))
                                {
                                    _RegEnumTree(huskeySubTree, htviroot, TVI_FIRST);
                                    SHRegCloseUSKey(huskeySubTree);
                                }

                                TreeView_Expand(_hwndTree, htviroot, TVE_EXPAND);
                            }
                        }
                    } // if (dwError == ERROR_SUCCESS
                }
            }   // if (!_RegIsRestricted(hsubkey))

            if (huskeySave != hussubkey)
                SHRegCloseUSKey(hussubkey);
        }
    }

    // Sort all keys under htviparent
    SendMessage(_hwndTree, TVM_SORTCHILDREN, 0, (LPARAM)htviparent);
}


BOOL CRegTreeOptions::_WalkTreeRecursive(HTREEITEM htvi, WALK_TREE_CMD cmd)
{
    // step through the children
    HTREEITEM hctvi = TreeView_GetChild(_hwndTree, htvi);
    while (hctvi)
    {
        _WalkTreeRecursive(hctvi, cmd);
        hctvi = TreeView_GetNextSibling(_hwndTree, hctvi);
    }

    TV_ITEM tvi = {0};
    // get ourselves
    tvi.mask  = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvi.hItem = htvi;
    TreeView_GetItem(_hwndTree, &tvi);

    HUSKEY huskey;
    switch (cmd)
    {
    case WALK_TREE_DELETE:
        // if we are destroying the tree...
        // do we have something to clean up?
        if (tvi.lParam)
        {
            // close the reg key
            SHRegCloseUSKey((HUSKEY)tvi.lParam);
        }
        break;
    
    case WALK_TREE_SAVE:
        huskey = (HUSKEY)tvi.lParam;
        
        // now save ourselves (if needed)
        // what are we?
        if (tvi.iImage == IDCHECKED || tvi.iImage == IDRADIOON)
        {   
            // checkbox or radio that is checked
            _SaveCheckStatus(huskey, TRUE);
        }
        else if (tvi.iImage == IDUNCHECKED)
        {   
            // checkbox that is unchecked
            _SaveCheckStatus(huskey, FALSE);
        }
        // else radio that is "off" is ignored
        // else icons are ignored
        
        break;
        
    case WALK_TREE_RESTORE:
    case WALK_TREE_REFRESH:
        huskey = (HUSKEY)tvi.lParam;
        if ((tvi.iImage == IDCHECKED)   ||
            (tvi.iImage == IDUNCHECKED) ||
            (tvi.iImage == IDRADIOON)   ||
            (tvi.iImage == IDRADIOOFF))
        {
            BOOL bChecked = FALSE;
            _GetCheckStatus(huskey, &bChecked, cmd == WALK_TREE_RESTORE ? TRUE : FALSE);
            tvi.iImage = (tvi.iImage == IDCHECKED) || (tvi.iImage == IDUNCHECKED) ?
                         (bChecked ? IDCHECKED : IDUNCHECKED) :
                         (bChecked ? IDRADIOON : IDRADIOOFF);
            tvi.iSelectedImage = tvi.iImage;
            TreeView_SetItem(_hwndTree, &tvi);
        }        
        break;
    }

    return TRUE;    // success?
}


DWORD RegTreeType(LPCTSTR pszType)
{
    for (int i = 0; i < ARRAYSIZE(c_aTreeTypes); i++)
    {
        if (!lstrcmpi(pszType, c_aTreeTypes[i].name))
            return c_aTreeTypes[i].type;
    }
    
    return TREE_UNKNOWN;
}

BOOL AppendStatus(LPTSTR pszText,UINT cchText, BOOL fOn)
{
    LPTSTR pszTemp;
    UINT cchStrLen , cchStatusLen;
    
    //if there's no string specified then return
    if (!pszText)
        return FALSE;
    
    //Calculate the string lengths
    cchStrLen = lstrlen(pszText);
    cchStatusLen = fOn ? lstrlen(TEXT("-ON")) : lstrlen(TEXT("-OFF"));
   

    //Remove the old status appended
    pszTemp = StrRStrI(pszText,pszText + cchStrLen, TEXT("-ON"));

    if(pszTemp)
    {
        *pszTemp = (TCHAR)0;
        cchStrLen = lstrlen(pszText);
    }

    pszTemp = StrRStrI(pszText,pszText + cchStrLen, TEXT("-OFF"));

    if(pszTemp)
    {
        *pszTemp = (TCHAR)0;
        cchStrLen = lstrlen(pszText);
    }

    //check if we append status text, we'll explode or not
    if (cchStrLen + cchStatusLen > cchText)
    {
        //We'll explode 
        return FALSE;
    }

    if (fOn)
    {
        StringCchCat(pszText, cchText, TEXT("-ON"));
    }
    else
    {
        StringCchCat(pszText, cchText, TEXT("-OFF"));
    }
    return TRUE;
}

BOOL IsScreenReaderEnabled()
{
    BOOL bRet = FALSE;
    SystemParametersInfoA(SPI_GETSCREENREADER, 0, &bRet, 0);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\runonnt.h ===
// no wrappers are needed on non-x86 since this is only for win9x interop
#ifdef _X86_

#define _SHELL32_

#define PathCleanupSpec         _AorW_PathCleanupSpec
#define SHCLSIDFromString       _use_GUIDFromString_instead
#define SHCLSIDFromStringA      _use_GUIDFromStringA_instead
#define SHILCreateFromPath      _AorW_SHILCreateFromPath
#define SHSimpleIDListFromPath  _AorW_SHSimpleIDListFromPath
#define GetFileNameFromBrowse   _AorW_GetFileNameFromBrowse
#define PathQualify             _AorW_PathQualify
#define PathProcessCommand      _AorW_PathProcessCommand
#define Win32DeleteFile         _AorW_Win32DeleteFile
#define PathYetAnotherMakeUniqueName    _AorW_PathYetAnotherMakeUniqueName
#define PathResolve             _AorW_PathResolve
#define Shell_GetCachedImageIndex _AorW_Shell_GetCachedImageIndex
#define SHRunControlPanel       _AorW_SHRunControlPanel
#define PickIconDlg             _AorW_PickIconDlg
#define SHCreateDirectory       _AorW_SHCreateDirectory

// The following functions were originally only TCHAR versions
// in Win95, but now have A/W versions.  Since we still need to
// run on Win95, we need to treat them as TCHAR versions and
// undo the A/W #define
#ifdef ILCreateFromPath
#undef ILCreateFromPath
#endif
#define ILCreateFromPath        _AorW_ILCreateFromPath

#ifdef SHGetSpecialFolderPath
#undef SHGetSpecialFolderPath
#endif
#define SHGetSpecialFolderPath  _AorW_SHGetSpecialFolderPath

#ifdef IsLFNDrive
#undef IsLFNDrive
#endif
#define IsLFNDrive              _AorW_IsLFNDrive

#ifdef UNICODE                  // Wrapper needed only on UNICODE build
#undef ShellAbout
#define ShellAbout              _AorW_ShellAbout
#endif

// Define the prototypes for each of these forwarders...

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */
extern int _WorA_Shell_GetCachedImageIndex(LPCWSTR pszIconPath, int iIconIndex, UINT uIconFlags);
extern int _AorW_Shell_GetCachedImageIndex(LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags);
extern int _AorW_SHRunControlPanel(LPCTSTR pszOrig_cmdline, HWND errwnd);
extern LPITEMIDLIST _AorW_ILCreateFromPath(LPCTSTR pszPath);
extern int _AorW_PathCleanupSpec(LPCTSTR pszDir, LPTSTR pszSpec);
extern void _AorW_PathQualify(LPTSTR pszDir);
extern LONG WINAPI _AorW_PathProcessCommand(LPCTSTR lpSrc, LPTSTR lpDest, int iDestMax, DWORD dwFlags);
extern BOOL _AorW_SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR pszPath, int nFolder, BOOL fCreate);
extern HRESULT _AorW_SHILCreateFromPath(LPCTSTR pszPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut);
extern LPITEMIDLIST _AorW_SHSimpleIDListFromPath(LPCTSTR pszPath);
extern BOOL WINAPI _AorW_GetFileNameFromBrowse(HWND hwnd, LPTSTR szFilePath, UINT cchFilePath,
        LPCTSTR szWorkingDir, LPCTSTR szDefExt, LPCTSTR szFilters, LPCTSTR szTitle);

extern BOOL _AorW_Win32DeleteFile(LPCTSTR lpszFileName);

extern BOOL _AorW_PathYetAnotherMakeUniqueName(LPTSTR  pszUniqueName,
                                         LPCTSTR pszPath,
                                         LPCTSTR pszShort,
                                         LPCTSTR pszFileSpec);

extern BOOL _AorW_PathResolve(LPTSTR lpszPath, LPCTSTR dirs[], UINT fFlags);

extern BOOL _AorW_IsLFNDrive(LPTSTR lpszPath);
extern int  _AorW_PickIconDlg(HWND hwnd, LPTSTR pszIconPath, UINT cchIconPath, int * piIconIndex);
extern int  _AorW_SHCreateDirectory(HWND hwnd, LPCTSTR pszPath);
extern int  _AorW_ShellAbout(HWND hWnd, LPCTSTR szApp, LPCTSTR szOtherStuff, HICON hIcon);


//
//  This is the "RunOn95" section, which thunks UNICODE functions
//  back down to ANSI so we can run on Win95 in browser-only mode.
//

#ifdef UNICODE
#define ILCreateFromPathA       _ILCreateFromPathA
#define ILCreateFromPathW        ILCreateFromPath
extern LPITEMIDLIST _ILCreateFromPathA(LPCSTR pszPath);
#else
#define ILCreateFromPathA        ILCreateFromPath
#define ILCreateFromPathW       _ILCreateFromPathW
extern LPITEMIDLIST _ILCreateFromPathW(LPCWSTR pszPath);
#endif


#define OpenRegStream       SHOpenRegStream     // shlwapi.dll

//
//  Miracle of miracles - We don't need to wrap SHStartNetConnectionDialogW
//  because Win9x/IE4 actually implements the thunk!
//

//
//  You cannot send these messages because Win95 doesn't understand them.
//
#undef BFFM_SETSELECTIONW
#undef BFFM_SETSTATUSTEXTW


#ifdef __cplusplus
}

#endif  /* __cplusplus */

#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\schedule.h ===
#ifndef _SCHEDULE_H
#define _SCHEDULE_H

#ifdef __cplusplus
extern "C" {
#endif

// global function for allocating a task scheduler.
// any object that uses it must make sure that its tasks are removed from the queue
// before it exits.
// NOTE: use CoCreateInstance - thread pool removes need for global scheduler
HRESULT SHGetSystemScheduler( LPSHELLTASKSCHEDULER * ppScheduler );


#ifdef DEBUG
VOID SHValidateEmptySystemScheduler(void);
#else
#define SHValidateEmptySystemScheduler()
#endif

#ifdef __cplusplus
};
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\schedule.cpp ===
#include "priv.h"
#include "schedule.h"

// debug stuff for tracking critical section owners.....
#ifdef DEBUG
#define DECLARE_CRITICAL_SECTION(x)         CRITICAL_SECTION x;                              \
                                            DWORD dwThread##x;

#define STATIC_DECLARE_CRITICAL_SECTION(x)  static CRITICAL_SECTION x;                      \
                                            static DWORD dwThread##x;

#define STATIC_INIT_CRITICAL_SECTION(c,x)   CRITICAL_SECTION c::x = {0};             \
                                            DWORD c::dwThread##x;

#define ASSERT_CRITICAL_SECTION(x)          ASSERT( dwThread##x == GetCurrentThreadId() );

#define OBJECT_ASSERT_CRITICAL_SECTION(o,x) ASSERT( o->dwThread##x == GetCurrentThreadId() );

#define ENTER_CRITICAL_SECTION(x)           EnterCriticalSection(&x);                        \
                                            dwThread##x = GetCurrentThreadId();

#define OBJECT_ENTER_CRITICAL_SECTION(o,x)  EnterCriticalSection(&o->x);                        \
                                            o->dwThread##x = GetCurrentThreadId();

#define LEAVE_CRITICAL_SECTION(x)           ASSERT_CRITICAL_SECTION(x);    \
                                            LeaveCriticalSection(&x);

#define OBJECT_LEAVE_CRITICAL_SECTION(o,x)  OBJECT_ASSERT_CRITICAL_SECTION(o,x);    \
                                            LeaveCriticalSection(&o->x);
#else
#define DECLARE_CRITICAL_SECTION(x)         CRITICAL_SECTION x;

#define STATIC_DECLARE_CRITICAL_SECTION(x)  static CRITICAL_SECTION x;

#define STATIC_INIT_CRITICAL_SECTION(c,x)   CRITICAL_SECTION c::x = {0};

#define ASSERT_CRITICAL_SECTION(x)

#define OBJECT_ASSERT_CRITICAL_SECTION(o,x)

#define ENTER_CRITICAL_SECTION(x)           EnterCriticalSection(&x);

#define OBJECT_ENTER_CRITICAL_SECTION(o,x)  EnterCriticalSection(&o->x);

#define LEAVE_CRITICAL_SECTION(x)           LeaveCriticalSection(&x);

#define OBJECT_LEAVE_CRITICAL_SECTION(o,x)  LeaveCriticalSection(&o->x);
#endif

#define TF_SCHEDULER     0x20

// struct to hold the details for each task that is to be executed....
struct TaskNode
{
    LPRUNNABLETASK pTask;
    TASKOWNERID toid;
    DWORD dwPriority;
    DWORD_PTR dwLParam;
    BOOL fSuspended;
};


class CShellTaskScheduler : public IShellTaskScheduler2
{
    public:
        CShellTaskScheduler( HRESULT * pHr );
        ~CShellTaskScheduler();

        STDMETHOD (QueryInterface) (REFIID riid, LPVOID * ppvObj );
        STDMETHOD_(ULONG, AddRef)( void );
        STDMETHOD_(ULONG,Release)( void );

        STDMETHOD (AddTask)(IRunnableTask * pTask,
                   REFTASKOWNERID rtoid,
                   DWORD_PTR lParam,
                   DWORD dwPriority );
        STDMETHOD (RemoveTasks)( REFTASKOWNERID rtoid,
                   DWORD_PTR dwLParam,
                   BOOL fWaitIfRunning );
        STDMETHOD (Status)( DWORD dwStatus, DWORD dwThreadTimeout );
        STDMETHOD_(UINT, CountTasks)(REFTASKOWNERID rtoid);

        STDMETHOD (AddTask2)(IRunnableTask * pTask,
                   REFTASKOWNERID rtoid,
                   DWORD_PTR lParam,
                   DWORD dwPriority,
                   DWORD grfFlags);
        STDMETHOD (MoveTask)(REFTASKOWNERID rtoid,
                   DWORD_PTR dwLParam,
                   DWORD dwPriority,
                   DWORD grfFlags );

    protected:

        // data held by a task scheduler to refer to the current worker that it has....
        struct WorkerData
        {
            BOOL Init(CShellTaskScheduler *pts);

            // this (pThis) is used to pass the controlling
            // object back and forth to the thread, so that threads can be moved
            // back and forth from objects as they need them.
            CShellTaskScheduler *   pThis;

#ifdef DEBUG
            DWORD                   dwThreadID;
#endif
        };

        friend UINT CShellTaskScheduler_ThreadProc( LPVOID pParam );
        friend int CALLBACK ListDestroyCallback( LPVOID p, LPVOID pData );

        VOID _KillScheduler( BOOL bKillCurTask );
        BOOL _WakeScheduler( void );

        BOOL _RemoveTasksFromList( REFTASKOWNERID rtoid, DWORD_PTR dwLParam );


        // create a worker thread data block that can be associated with a task scheduler....
        WorkerData * FetchWorker( void );

        // from a worker thread, let go of the scheduler it is associated...
        static BOOL ReleaseWorker( WorkerData * pThread );


        /***********PERINSTANCE DATA ************/
        DECLARE_CRITICAL_SECTION( m_csListLock )
        BOOL m_bListLockInited;
        HDPA m_hTaskList;

        WorkerData * m_pWorkerThread;

        // the currently running task...
        TaskNode * m_pRunning;

        // a semaphore that counts, so that all waiters canbe released...
        HANDLE m_hCurTaskEnded;

        DWORD m_dwStatus;

        int m_iSignalCurTask;                // - tell the thread to signal when the
                                             //   current task is finished if non-zero
                                             //   the other thread will signal the 
                                             //   handle as many times as this variable
                                             //   holds.
        BOOL m_fEmptyQueueAndSleep;          // - tell the thread to empty itself and
                                             //   go to sleep (usually it is dying....

        int m_iGoToSleep;                    // - tell the tread to go to sleep without emptying the queue

        long m_cRef;

#ifdef DEBUG
        void AssertForNoOneWaiting( void )
        {
            // no one should be queued for waiting
            ASSERT( m_iSignalCurTask == 0 );

            // release the semaphore by zero to get the current count....
            LONG lPrevCount = 0;
            ReleaseSemaphore( m_hCurTaskEnded, 0, &lPrevCount );
            ASSERT( lPrevCount == 0 );
        };
#endif
        
        void IWantToKnowWhenCurTaskDone( void )
        {
            m_iSignalCurTask ++;
        };
};

// private messages sent to the scheduler thread...
#define WM_SCH_WAKEUP       WM_USER + 0x600
#define WM_SCH_TERMINATE    WM_USER + 0x601

STDAPI CShellTaskScheduler_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    if ( pUnkOuter )
    {
        return CLASS_E_NOAGGREGATION;
    }

    HRESULT hr = NOERROR;
    CShellTaskScheduler * pScheduler = new CShellTaskScheduler( & hr );
    if ( !pScheduler )
    {
        return E_OUTOFMEMORY;
    }
    if ( FAILED( hr ))
    {
        delete pScheduler;
        return hr;
    }

    *ppunk = SAFECAST(pScheduler, IShellTaskScheduler *);
    return NOERROR;
}

// Global ExplorerTaskScheduler object that is used by multiple components.
IShellTaskScheduler * g_pTaskScheduler = NULL;


// This is the class factory routine for creating the one and only ExplorerTaskScheduler object.
// We have a static object (g_pTaskScheduler) that everyone who wants to use it shares.
STDAPI CSharedTaskScheduler_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr = NOERROR;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    ENTERCRITICAL;
    if (g_pTaskScheduler)
    {
        g_pTaskScheduler->AddRef();
    }
    else
    {
        hr = CShellTaskScheduler_CreateInstance(NULL, (LPUNKNOWN*)&g_pTaskScheduler, NULL);
        if (SUCCEEDED(hr))
        {
            // set timeout to be 1 minute.....
            g_pTaskScheduler->Status( ITSSFLAG_KILL_ON_DESTROY, 1 * 60 * 1000 );

            // keep an additional ref for us..
            g_pTaskScheduler->AddRef();
        }
    }

    *ppunk = SAFECAST(g_pTaskScheduler, IShellTaskScheduler*);
    LEAVECRITICAL;

    return hr;
}

STDAPI SHIsThereASystemScheduler( void )
{
    return ( g_pTaskScheduler ? S_OK : S_FALSE );
}

// use CoCreateInstance - thread pool removes need for global scheduler
STDAPI SHGetSystemScheduler( LPSHELLTASKSCHEDULER * ppScheduler )
{
    if ( !ppScheduler )
    {
        return E_INVALIDARG;
    }

    return CSharedTaskScheduler_CreateInstance(NULL, (IUnknown **)ppScheduler, NULL );
}

// use CoCreateInstance - thread pool removes need for global scheduler
STDAPI SHFreeSystemScheduler( void )
{
    TraceMsg(TF_SCHEDULER, "SHfss: g_pTaskSched=%x", g_pTaskScheduler);

    IShellTaskScheduler * pSched;

    ENTERCRITICAL;
    pSched = g_pTaskScheduler;
    g_pTaskScheduler = NULL;
    LEAVECRITICAL;
    if ( pSched )
    {
        // assume the scheduler is empty....
        pSched->RemoveTasks( TOID_NULL, ITSAT_DEFAULT_LPARAM, FALSE );

        pSched->Release();
    }
    return NOERROR;
}

#ifdef DEBUG
STDAPI_(void) SHValidateEmptySystemScheduler()
{
    if ( g_pTaskScheduler )
    {
        ASSERT( g_pTaskScheduler->CountTasks( TOID_NULL ) == 0 );
    }
}
#endif

int InsertInPriorityOrder( HDPA hTaskList, TaskNode * pNewNode, BOOL fBefore );
int CALLBACK ListDestroyCallback( LPVOID p, LPVOID pData )
{
    ASSERT( p != NULL );
    if ( ! p )
    {
        TraceMsg( TF_ERROR, "ListDestroyCallback() - p is NULL!" );
        return TRUE;
    }

    CShellTaskScheduler * pThis = (CShellTaskScheduler *) pData;
    ASSERT( pThis );
    if ( ! pThis )
    {
        TraceMsg( TF_ERROR, "ListDestroyCallback() - pThis is NULL!" );
        return TRUE;
    }

    TaskNode * pNode = (TaskNode *) p;
    ASSERT( pNode != NULL );
    ASSERT( pNode->pTask != NULL );

#ifdef DEBUG
    if ( pThis->m_pWorkerThread )
    {
        // notify the thread that we are emptying the list from here, so remove these
        // items from its mem track list
    }
#endif

    // if it is suspended, kill it. If it is not suspended, then it has
    // probably never been started..
    if ( pNode->fSuspended )
    {
        pNode->pTask->Kill( pThis->m_dwStatus == ITSSFLAG_COMPLETE_ON_DESTROY );
    }
    pNode->pTask->Release();
    delete pNode;

    return TRUE;
}

STDMETHODIMP CShellTaskScheduler::QueryInterface( REFIID riid, LPVOID * ppvObj )
{
    static const QITAB qit[] = {
        QITABENT(CShellTaskScheduler, IShellTaskScheduler),
        QITABENT(CShellTaskScheduler, IShellTaskScheduler2),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_ (ULONG) CShellTaskScheduler::AddRef()
{
    return InterlockedIncrement( &m_cRef );
}
STDMETHODIMP_ (ULONG) CShellTaskScheduler::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement( &m_cRef );
    if ( 0 == cRef)
    {
        delete this;
    }
    return cRef;
}

CShellTaskScheduler::CShellTaskScheduler( HRESULT * pHr) : m_cRef(1)
{
    *pHr = S_OK;
    
    ASSERT(!m_bListLockInited);
    __try
    {
        InitializeCriticalSection(&m_csListLock);
        m_bListLockInited = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        *pHr = E_OUTOFMEMORY;
    }

    ASSERT(m_pWorkerThread == NULL);
    ASSERT(m_pRunning == NULL);

    m_dwStatus = ITSSFLAG_COMPLETE_ON_DESTROY;

    // grow queue by five each time...
    m_hTaskList = DPA_Create( 5 );
    if ( !m_hTaskList )
    {
        *pHr = E_OUTOFMEMORY;
    }

    m_hCurTaskEnded = CreateSemaphoreWrap( NULL, 0, 0xffff, NULL );
    if ( !m_hCurTaskEnded )
    {
        *pHr = E_FAIL;
    }

    DllAddRef();

}

CShellTaskScheduler::~CShellTaskScheduler()
{
    // if we don't have a tasklist and semaphore (constructor failure), we can't have a workerthread
    ASSERT((m_hTaskList && m_hCurTaskEnded) || !m_pWorkerThread);

    // but if we have a task list...
    if ( m_hTaskList )
    {
        EnterCriticalSection( &m_csListLock );

        // if we have a background worker thread, then it MUST be doing something as we
        // are now in the crit section so it can't go away
        if ( m_pWorkerThread )
        {
            // we tell the object we need to know when it has done with its stuff....
            // we reuse the event we already have...
            m_fEmptyQueueAndSleep = TRUE;

#ifdef DEBUG
            AssertForNoOneWaiting();
#endif

            IWantToKnowWhenCurTaskDone();
            
            // tell the cur task to go away.....
            TraceMsg(TF_SCHEDULER, "(%x)csts.dtor: call _KillScheduler", GetCurrentThreadId());
            _KillScheduler( m_dwStatus == ITSSFLAG_KILL_ON_DESTROY );

            // free the thread. At this point there is always
            LeaveCriticalSection( &m_csListLock );

            TraceMsg(TF_SCHEDULER, "csts.dtor: call u.WFSMT(m_hCurTaskEnded=%x)", m_hCurTaskEnded);

            DWORD dwRes = SHWaitForSendMessageThread(m_hCurTaskEnded, INFINITE);
            ASSERT(dwRes == WAIT_OBJECT_0);
            TraceMsg(TF_SCHEDULER, "csts.dtor: u.WFSMT() done");

            ASSERT( !m_pWorkerThread );
        }
        else
        {
            LeaveCriticalSection( &m_csListLock );
        }

        // empty the list incase it is not empty (it should be)
        DPA_EnumCallback( m_hTaskList, ListDestroyCallback, this );
        DPA_DeleteAllPtrs( m_hTaskList );

        DPA_Destroy( m_hTaskList );
        m_hTaskList = NULL;
    }

    if ( m_hCurTaskEnded )
        CloseHandle( m_hCurTaskEnded );

    if (m_bListLockInited)
        DeleteCriticalSection( &m_csListLock );

    DllRelease();

}

STDMETHODIMP CShellTaskScheduler::AddTask( IRunnableTask * pTask,
                                      REFTASKOWNERID rtoid,
                                      DWORD_PTR dwLParam,
                                      DWORD dwPriority )
{
    return AddTask2(pTask, rtoid, dwLParam, dwPriority, ITSSFLAG_TASK_PLACEINBACK);
}

STDMETHODIMP CShellTaskScheduler::AddTask2( IRunnableTask * pTask,
                                      REFTASKOWNERID rtoid,
                                      DWORD_PTR dwLParam,
                                      DWORD dwPriority,
                                      DWORD grfFlags )
{                                      
    if ( !pTask )
        return E_INVALIDARG;

    HRESULT hr = E_OUTOFMEMORY;   // assume failure

    TaskNode * pNewNode = new TaskNode;
    if ( pNewNode )
    {
        pNewNode->pTask = pTask;
        pTask->AddRef();
        pNewNode->toid = rtoid;
        pNewNode->dwPriority = dwPriority;
        pNewNode->dwLParam = dwLParam;
        pNewNode->fSuspended = FALSE;

        EnterCriticalSection( &m_csListLock );

        int iPos = -1;

        if (grfFlags & ITSSFLAG_TASK_PLACEINFRONT)
        {
            iPos = InsertInPriorityOrder( m_hTaskList, pNewNode, TRUE );
        }
        else if (grfFlags & ITSSFLAG_TASK_PLACEINBACK)
        {
            iPos = InsertInPriorityOrder( m_hTaskList, pNewNode, FALSE );
        }

        if ( iPos != -1 && m_pRunning )
        {
            if ( m_pRunning->dwPriority < dwPriority )
            {
                // try to suspend the current task. If this works, the task will
                // return to the scheduler with E_PENDING. It will then be added
                // suspended in the queue to be Resumed later....
                m_pRunning->pTask->Suspend();
            }
        }

        BOOL bRes = FALSE;

        if ( iPos != -1 )
        {
            // get a worker thread and awaken it...
            // we do this in the crit section because we need to test m_pWorkerThread and
            // to save us from releasing and grabbing it again...
            bRes = _WakeScheduler();

#ifdef DEBUG
            if ( bRes && m_pWorkerThread )
            {
                //
                // We are putting this memory block in a linked list and it will most likely be freed
                // from the background thread. Remove it from the per-thread memory list to avoid
                // detecting it as a memory leak.
                //
                // WARNING - WARNING - WARNING:
                // We cannot...
                // assume that when pTask is Released it will be deleted, so move it
                // to the other thread's memory list.
                // 
                // This will be incorrect some of the time and we don't want to investigate
                // fake leaks. -BryanSt
                //transfer_to_thread_memlist( m_pWorkerThread->dwThreadID, pNewNode->pTask );
            }
#endif
        }
        LeaveCriticalSection( &m_csListLock );

        // we failed to add it to the list
        if ( iPos == -1 )
        {
            // we failed to add it to the list, must have been a memory failure...
            pTask->Release();       // for the AddRef above
            delete pNewNode;
            goto Leave;
        }

        hr = bRes ? NOERROR : E_FAIL;
    }
Leave:
    return hr;
}

STDMETHODIMP CShellTaskScheduler::RemoveTasks( REFTASKOWNERID rtoid,
                                               DWORD_PTR dwLParam,
                                               BOOL fWaitIfRunning )
{
    BOOL fRemoveAll = IsEqualGUID( TOID_NULL, rtoid );
    BOOL fAllItems = (dwLParam == ITSAT_DEFAULT_LPARAM );
    BOOL fWaitOnHandle = FALSE;

    // note, this ignores the current
    EnterCriticalSection( &m_csListLock );

    _RemoveTasksFromList( rtoid, dwLParam );

    if ( m_pRunning && ( fWaitIfRunning || m_dwStatus == ITSSFLAG_KILL_ON_DESTROY ))
    {
        // kill the current task ...
        if (( fRemoveAll || IsEqualGUID( rtoid, m_pRunning->toid )) &&
            ( fAllItems || dwLParam == m_pRunning->dwLParam ))
        {
            ASSERT( m_pRunning->pTask );
            if ( m_dwStatus == ITSSFLAG_KILL_ON_DESTROY )
            {
                m_pRunning->pTask->Kill( fWaitIfRunning );
            }

            // definitive support for waiting until they are done...
            // (note, only do it is there is a task running, otherwise we'll sit
            // on a handle that will never fire)
            if ( fWaitIfRunning )
            {
                IWantToKnowWhenCurTaskDone();

                // don't use this directly outside of the cirtical section because it can change...
                ASSERT ( m_iSignalCurTask );

                fWaitOnHandle = TRUE;
                m_iGoToSleep++;
            }
        }
    }

    LeaveCriticalSection( &m_csListLock );

    // now wait if we need to......
    if ( fWaitOnHandle )
    {
        DWORD dwRes = SHWaitForSendMessageThread(m_hCurTaskEnded, INFINITE);
        ASSERT(dwRes == WAIT_OBJECT_0);

        EnterCriticalSection( &m_csListLock );

        // Remove tasks that might have been added while the last task was finishing
        _RemoveTasksFromList( rtoid, dwLParam );

        m_iGoToSleep--;
        // See if we need to wake the thread now.
        if ( m_iGoToSleep == 0 && DPA_GetPtrCount( m_hTaskList ) > 0 )
            _WakeScheduler();

        LeaveCriticalSection( &m_csListLock );
    }

    return NOERROR;
}

BOOL CShellTaskScheduler::_RemoveTasksFromList( REFTASKOWNERID rtoid, DWORD_PTR dwLParam )
{
    // assumes that we are already holding the critical section
    
    BOOL fRemoveAll = IsEqualGUID( TOID_NULL, rtoid );
    BOOL fAllItems = (dwLParam == ITSAT_DEFAULT_LPARAM );
    int iIndex = 0;

    do
    {
        TaskNode * pNode = (TaskNode *) DPA_GetPtr( m_hTaskList, iIndex );
        if ( !pNode )
        {
            break;
        }

        ASSERT( pNode );
        ASSERT( pNode->pTask );

        if (( fRemoveAll || IsEqualGUID( pNode->toid, rtoid )) && ( fAllItems || dwLParam == pNode->dwLParam ))
        {
            // remove it
            DPA_DeletePtr( m_hTaskList, iIndex );

            if ( pNode->fSuspended )
            {
                // kill it just incase....
                pNode->pTask->Kill( FALSE );
            }
            pNode->pTask->Release();
            delete pNode;
        }
        else
        {
            iIndex ++;
        }
    }
    while ( TRUE );
    return TRUE;
}

//
// CShellTaskScheduler::MoveTask
//
STDMETHODIMP CShellTaskScheduler::MoveTask( REFTASKOWNERID rtoid,
                                            DWORD_PTR dwLParam,
                                            DWORD dwPriority,
                                            DWORD grfFlags )
{
    int  iInsert;
    int  iIndex;
    BOOL fMoveAll  = IsEqualGUID( TOID_NULL, rtoid );
    BOOL fAllItems = (dwLParam == ITSAT_DEFAULT_LPARAM );
    BOOL bMatch    = FALSE ;
    int  iIndexStart;
    int  iIndexInc;

    EnterCriticalSection( &m_csListLock );

    // Init direction of search
    if (grfFlags & ITSSFLAG_TASK_PLACEINFRONT)
    {
        iIndexStart = 0;
        iInsert = DPA_GetPtrCount( m_hTaskList );
        iIndexInc = 1;
    }
    else if (grfFlags & ITSSFLAG_TASK_PLACEINBACK)
    {
        iIndexStart = iInsert = DPA_GetPtrCount( m_hTaskList );
        iIndexInc = -1;
    }

    // Find insert point (based on priority)
    iIndex = 0;
    do
    {
        TaskNode * pNode = (TaskNode *) DPA_GetPtr( m_hTaskList, iIndex );
        if ( !pNode )
        {
            break;
        }

        if (grfFlags & ITSSFLAG_TASK_PLACEINFRONT)
        {
            if (pNode->dwPriority <= dwPriority)
            {
                iInsert = iIndex;
                break;
            }
        }
        else if (grfFlags & ITSSFLAG_TASK_PLACEINBACK)
        {
            if (pNode->dwPriority > dwPriority)
            {
                iInsert = iIndex;
            }
            else
            {
                break;
            }
        }

        iIndex++;
    }
    while (TRUE);

    // Now try and locate any items.
    iIndex = iIndexStart;
    do
    {
        TaskNode * pNode = (TaskNode *) DPA_GetPtr( m_hTaskList, iIndex );
        if ( !pNode )
        {
            break;
        }

        if (( fMoveAll || IsEqualGUID( pNode->toid, rtoid )) && 
            ( fAllItems || dwLParam == pNode->dwLParam ))
        {
            bMatch = TRUE;

            // Can we move this node?
            if ( iIndex != iInsert )
            {
                int iPos = DPA_InsertPtr( m_hTaskList, iInsert, pNode );
                if (iPos != -1)
                {
                    if ( iIndex > iInsert )
                    {
                        DPA_DeletePtr( m_hTaskList, iIndex + 1);  // Will have shifted one
                    }
                    else
                    {
                        DPA_DeletePtr( m_hTaskList, iIndex);
                    }
                }
            }
        }
        iIndex += iIndexInc;
    }
    while ( !bMatch );
    
    LeaveCriticalSection( &m_csListLock );

    return (bMatch ? S_OK : S_FALSE);
}

BOOL CShellTaskScheduler::_WakeScheduler( )
{
    // assume we are in the object's critsection.....

    if ( NULL == m_pWorkerThread )
    {
        // we need a worker quick ....
        m_pWorkerThread = FetchWorker();
    }

    return ( NULL != m_pWorkerThread );
}

VOID CShellTaskScheduler::_KillScheduler( BOOL bKillCurTask )
{
    // assumes that we are already holding the critical section
    if ( m_pRunning != NULL && bKillCurTask )
    {
        ASSERT( m_pRunning->pTask );

        // tell the currently running task that it should die
        // quickly, because we are a separate thread than the
        // one that is running the task, it can be notified
        m_pRunning->pTask->Kill( FALSE );
    }
}

UINT CShellTaskScheduler_ThreadProc( LPVOID pParam )
{
    // make sure we have a message QUEUE // BOGUS - why do we need this?
    MSG msg;
    PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE );

    ASSERT( pParam );

    HRESULT hrInit = SHCoInitialize();

    CShellTaskScheduler::WorkerData * pWorker = (CShellTaskScheduler::WorkerData *) pParam;
    DWORD dwRes = 0;

    TraceMsg(TF_SCHEDULER, "(?%x)ShellTaskScheduler::Thread Started", GetCurrentThreadId());

#ifdef DEBUG
    pWorker->dwThreadID = GetCurrentThreadId();
#endif

    // figure out who we are attatched to (where the queue is we get tasks from)
    CShellTaskScheduler * pThis = pWorker->pThis;

    // we must always have a valid parent object at this point....
    ASSERT( pThis && IS_VALID_WRITE_PTR( pThis, CShellTaskScheduler ));

    do
    {
        MSG msg;
        HRESULT hr = NOERROR;
        TaskNode * pTask = NULL;

        OBJECT_ENTER_CRITICAL_SECTION( pThis, m_csListLock );

        // this means we are being told to quit...
        if ( pThis->m_fEmptyQueueAndSleep )
        {
            // we are being told to empty the queue .....
            DPA_EnumCallback( pThis->m_hTaskList, ListDestroyCallback, pThis );
            DPA_DeleteAllPtrs( pThis->m_hTaskList );
        }
        else if ( !pThis->m_iGoToSleep )
        {
            // get the first item...
            pTask = (TaskNode *) DPA_GetPtr( pThis->m_hTaskList, 0 );
        }

        if ( pTask )
        {
            // remove from the list...
            DPA_DeletePtr( pThis->m_hTaskList, 0 );
        }
        pThis->m_pRunning = pTask;

        OBJECT_LEAVE_CRITICAL_SECTION( pThis, m_csListLock );

        if ( pTask == NULL )
        {
            // cache the scheduler pointer, as we need it to leave the crit section
            CShellTaskScheduler * pScheduler = pThis;

            // queue is empty, go back on the thread pool.....
            // we are about to enter a deep deep sleep/coma, so remove us from the object....
            OBJECT_ENTER_CRITICAL_SECTION( pScheduler, m_csListLock );

            HANDLE hSleep = pThis->m_fEmptyQueueAndSleep ? pThis->m_hCurTaskEnded : NULL;
            BOOL fEmptyAndLeave = pThis->m_fEmptyQueueAndSleep;

            // make sure they didn't just add something to the queue, or have we been asked to go to sleep
            if ( pThis->m_iGoToSleep || DPA_GetPtrCount( pThis->m_hTaskList ) == 0)
            {
                if ( CShellTaskScheduler::ReleaseWorker( pWorker ))
                {
                    pThis = NULL;
                }
            }
            OBJECT_LEAVE_CRITICAL_SECTION( pScheduler, m_csListLock );

            if ( pThis && !fEmptyAndLeave )
            {
                // they must have added something at the last moment...
                continue;
            }

            // we are being emptied, tell them we are no longer attatched....
            if ( hSleep )
            {
                ReleaseSemaphore( hSleep, 1, NULL);
            }

            break;
        }
        else
        {
#ifndef DEBUG
            //__try
            {
#endif
                if ( pTask->fSuspended )
                {
                    pTask->fSuspended = FALSE;
                    hr = pTask->pTask->Resume();
                }
                else
                {
                    // run the task...
                    hr = pTask->pTask->Run( );
                }
#ifndef DEBUG
            }
            //__except( EXCEPTION_EXECUTE_HANDLER )
           // {
                // ignore it.... and pray we are fine...
            //}
           // __endexcept
#endif

            BOOL fEmptyQueue;
            OBJECT_ENTER_CRITICAL_SECTION( pThis, m_csListLock );
            {
                pThis->m_pRunning = NULL;

                // check to see if we have been asked to notify them
                // on completion....
                // NOTE: the NOT clause is needed so that we release ourselves
                // NOTE: and signal them at the right point, if we do it here,
                // NOTE: they leave us stranded, delete the crit section and
                // NOTE: we fault.
                if ( pThis->m_iSignalCurTask && !pThis->m_fEmptyQueueAndSleep )
                {
                    LONG lPrevCount = 0;

                    // release all those that are waiting. (we are using a semaphore
                    // because we are a free threaded object and God knows how many
                    // threads are waiting, and he passed on the information in the
                    // iSignalCurTask variable
                    ReleaseSemaphore( pThis->m_hCurTaskEnded, pThis->m_iSignalCurTask, &lPrevCount );

                    // reset the count.
                    pThis->m_iSignalCurTask = 0;
                }
                fEmptyQueue = pThis->m_fEmptyQueueAndSleep;
            }
            OBJECT_LEAVE_CRITICAL_SECTION( pThis, m_csListLock );

            if ( hr != E_PENDING || fEmptyQueue )
            {
                ULONG cRef = pTask->pTask->Release();
                delete pTask;
                pTask = NULL;
            }

            // empty the message queue...
            while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ))
            {
                {
#ifdef DEBUG
                    if (msg.message == WM_ENDSESSION)
                        TraceMsg(TF_SCHEDULER, "(?%x)csts.tp: peek #2 got WM_ENDESSION", GetCurrentThreadId());
#endif
                    TranslateMessage( &msg );
                    DispatchMessage( &msg );
                }
            }

            ASSERT( pThis && IS_VALID_WRITE_PTR( pThis, CShellTaskScheduler ));

            // the task must have been suspended because a higher priority
            // task has been added to the queue..... (this only works if the
            // task supports the Suspend() method).
            if ( hr == E_PENDING && pTask && !fEmptyQueue )
            {
                // put the task on the Suspended Queue ....
                pTask->fSuspended = TRUE;
                OBJECT_ENTER_CRITICAL_SECTION( pThis, m_csListLock );
                int iIndex = InsertInPriorityOrder( pThis->m_hTaskList, pTask, TRUE );
                OBJECT_LEAVE_CRITICAL_SECTION( pThis, m_csListLock );

                if ( iIndex == -1 )
                {
                    // we are so low on memory, kill it...
                    pTask->pTask->Kill( FALSE );
                    pTask->pTask->Release();
                    delete pTask;
                }
                pTask = NULL;
           }
       }
    }
    while ( TRUE );

    TraceMsg(TF_SCHEDULER, "(?%x)ShellTaskScheduler::Thread Ended", GetCurrentThreadId());
    SHCoUninitialize(hrInit);

    return 0;
}


STDMETHODIMP CShellTaskScheduler::Status( DWORD dwStatus, DWORD dwThreadTimeout )
{
    m_dwStatus = dwStatus & ITSSFLAG_FLAGS_MASK;
    if ( dwThreadTimeout != ITSS_THREAD_TIMEOUT_NO_CHANGE )
    {
/*
 * We don't support thread termination or pool timeout any more

        if ( dwStatus & ITSSFLAG_THREAD_TERMINATE_TIMEOUT )
        {
            m_dwThreadRlsKillTimeout = dwThreadTimeout;
        }
        else if ( dwStatus & ITSSFLAG_THREAD_POOL_TIMEOUT )
        {
            CShellTaskScheduler::s_dwComaTimeout = dwThreadTimeout;
        }
*/
    }
    return NOERROR;
}

STDMETHODIMP_(UINT) CShellTaskScheduler::CountTasks(REFTASKOWNERID rtoid)
{
    UINT iMatch = 0;
    BOOL fMatchAll = IsEqualGUID( TOID_NULL, rtoid );

    ENTER_CRITICAL_SECTION( m_csListLock );
    if ( fMatchAll )
    {
        iMatch = DPA_GetPtrCount( m_hTaskList );
    }
    else
    {
        int iIndex = 0;
        do
        {
            TaskNode * pNode = (TaskNode * )DPA_GetPtr( m_hTaskList, iIndex ++ );
            if ( !pNode )
            {
                break;
            }

            if ( IsEqualGUID( pNode->toid, rtoid ))
            {
                iMatch ++;
            }
        }
        while ( TRUE );
    }

    if ( m_pRunning )
    {
        if ( fMatchAll || IsEqualGUID( rtoid, m_pRunning->toid ))
        {
            iMatch ++;
        }
    }

    LEAVE_CRITICAL_SECTION( m_csListLock );

    return iMatch;

}


////////////////////////////////////////////////////////////////////////////////////
int InsertInPriorityOrder( HDPA hTaskList, TaskNode * pNewNode, BOOL fStart )
{
    // routine assumes that we are thread safe, therfore grab the crit-section
    // prior to calling this function

    int iPos = -1;
    int iIndex = 0;
    do
    {
        TaskNode * pNode = (TaskNode *) DPA_GetPtr( hTaskList, iIndex );
        if ( !pNode )
        {
            break;
        }

        // the fStart allows us to either add it before other tasks of the same
        // priority or after.
        if ((( pNode->dwPriority < pNewNode->dwPriority ) && !fStart ) || (( pNode->dwPriority <= pNewNode->dwPriority ) && fStart ))
        {
            iPos = DPA_InsertPtr( hTaskList, iIndex, pNewNode );
            break;
        }
        iIndex ++;
    }
    while ( TRUE );

    if ( iPos == -1 )
    {
        // add item to end of list...
        iPos = DPA_AppendPtr( hTaskList, pNewNode );
    }

    return iPos;
}


CShellTaskScheduler::WorkerData * CShellTaskScheduler::FetchWorker()
{
    WorkerData * pWorker = new WorkerData;

    if ( pWorker )
    {
        // call to Shlwapi thread pool
        if ( pWorker->Init(this) && SHQueueUserWorkItem( (LPTHREAD_START_ROUTINE)CShellTaskScheduler_ThreadProc,
                                                     pWorker,
                                                     0,
                                                     (DWORD_PTR)NULL,
                                                     (DWORD_PTR *)NULL,
                                                     "browseui.dll",
                                                     TPS_LONGEXECTIME | TPS_DEMANDTHREAD
                                                     ) )
        {
            return pWorker;
        }
        else
            delete pWorker;
    }

    return NULL;
}


// used by main thread proc to release its link the the task scheduler because it
// has run out of things to do....
BOOL CShellTaskScheduler::ReleaseWorker( WorkerData * pWorker )
{
    ASSERT( pWorker && IS_VALID_WRITE_PTR( pWorker, WorkerData ));

    CShellTaskScheduler * pThis = pWorker->pThis;

    OBJECT_ASSERT_CRITICAL_SECTION( pThis, m_csListLock );

    ASSERT( pWorker && IS_VALID_WRITE_PTR( pWorker, CShellTaskScheduler::WorkerData ));

    if ( DPA_GetPtrCount( pThis->m_hTaskList ) > 0 )
    {
        // something was added to the queue at the last minute....
        return FALSE;
    }

    // we assume we have entered the critsection of pThis
    pThis->m_pWorkerThread = NULL;
    pWorker->pThis = NULL;

    delete pWorker;

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CShellTaskScheduler::WorkerData::Init(CShellTaskScheduler *pts)
{
    pThis = pts;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\searchext.cpp ===
#include "priv.h"
#include "varutil.h"

// static context menu for the start.search menu. note, this gets invoked directly
// by a number of clients (in shell32 for example)

class CShellSearchExt : public IContextMenu, public IObjectWithSite
{
public:
    CShellSearchExt();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT wFlags, UINT *pwReserved, LPSTR pszName, UINT cchMax);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *pUnkSite);        
    STDMETHODIMP GetSite(REFIID riid, void **ppvSite);

protected:
    virtual ~CShellSearchExt(); // for a derived class

private:    
    virtual BOOL _GetSearchUrls(GUID *pguid, LPTSTR psz, DWORD cch, 
                                LPTSTR pszUrlNavNew, DWORD cchNavNew, BOOL *pfRunInProcess);
    HRESULT _IsShellSearchBand(REFGUID guidSearch);
    HRESULT _ShowShellSearchResults(IWebBrowser2* pwb2, BOOL fNewFrame, REFGUID guidSearch);

    LONG _cRef;
    IUnknown *_pSite;
};

STDAPI CShellSearchExt_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CShellSearchExt* psse = new CShellSearchExt(); 
    if (psse)
    {
        *ppunk = SAFECAST(psse, IContextMenu*);
        return S_OK;
    }
    else
    {
        *ppunk = NULL;
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CShellSearchExt::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShellSearchExt, IContextMenu),         
        QITABENT(CShellSearchExt, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CShellSearchExt::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellSearchExt::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CShellSearchExt::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    return E_NOTIMPL;
}

#define SZ_SHELL_SEARCH TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FindExtensions\\Static\\ShellSearch")

BOOL CShellSearchExt::_GetSearchUrls(GUID *pguidSearch, LPTSTR pszUrl, DWORD cch, 
                                     LPTSTR pszUrlNavNew, DWORD cchNavNew, BOOL *pfRunInProcess)
{
    BOOL bRet = FALSE;

    *pfRunInProcess = FALSE;        // Assume that we are not forcing it to run in process.
    if (pszUrl == NULL || IsEqualGUID(*pguidSearch, GUID_NULL) || pszUrlNavNew == NULL)
        return bRet;

    *pszUrlNavNew = 0;

    HKEY hkey;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_SHELL_SEARCH, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        TCHAR szSubKey[32];
        HKEY  hkeySub;

        for (int i = 0; SUCCEEDED(StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%d"), i)) && (RegOpenKeyEx(hkey, szSubKey, NULL, KEY_QUERY_VALUE, &hkeySub) == ERROR_SUCCESS); i++)
        {
            TCHAR szSearchGuid[MAX_PATH];
            DWORD dwType, cb = sizeof(szSearchGuid);
            if (SHGetValue(hkeySub, TEXT("SearchGUID"), NULL, &dwType, (BYTE*)szSearchGuid, &cb) == ERROR_SUCCESS)
            {
                GUID guid;
                
                if (GUIDFromString(szSearchGuid, &guid) &&
                    IsEqualGUID(guid, *pguidSearch))
                {
                    cb = cch * sizeof(TCHAR);
                    bRet = (SHGetValue(hkeySub, TEXT("SearchGUID\\Url"), NULL, &dwType, (BYTE*)pszUrl, &cb) == ERROR_SUCCESS);
                    if (bRet || IsEqualGUID(*pguidSearch, SRCID_SFileSearch))
                    {
                        if (!bRet)
                        {
                            *pszUrl = 0;
                            // in file search case we don't need url but we still succeed
                            bRet = TRUE;
                        }
                        // See if there is a URL that we should navigate to if we
                        // are navigating to a new 
                        cb = cchNavNew * sizeof(TCHAR);
                        SHGetValue(hkeySub, TEXT("SearchGUID\\UrlNavNew"), NULL, &dwType, (BYTE*)pszUrlNavNew, &cb);

                        // likewise try to grab the RunInProcess flag, if not there or zero then off, else on
                        // reuse szSearchGuid for now...
                        *pfRunInProcess = (BOOL)SHRegGetIntW(hkeySub, L"RunInProcess", 0);
                    }
                    RegCloseKey(hkeySub);
                    break;
                }
            }
            RegCloseKey(hkeySub);
        }
        RegCloseKey(hkey);
    }
    if (!bRet)
        pszUrl[0] = 0;
    
    return bRet;
}

STDMETHODIMP CShellSearchExt::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    TCHAR szUrl[MAX_URL_STRING], szUrlNavNew[MAX_URL_STRING];
    BOOL bNewFrame = FALSE;

    // First get the Urls such that we can see which class we should create...
    GUID guidSearch = GUID_NULL;
    BOOL fRunInProcess = FALSE;
    CLSID clsidBand; // deskband object for search

    // Retrieve search ID from invoke params
    if (pici->lpParameters)
        GUIDFromStringA(pici->lpParameters, &guidSearch);

    HRESULT hr = S_OK;
    BOOL fShellSearchBand = (S_OK == _IsShellSearchBand(guidSearch));
    if (fShellSearchBand)
    {
        clsidBand = CLSID_FileSearchBand;
        if (SHRestricted(REST_NOFIND) && IsEqualGUID(guidSearch, SRCID_SFileSearch))
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // user saw the error        
    }
    else
    {
        clsidBand = CLSID_SearchBand;
        //  retrieve search URLs from registry
        if (!_GetSearchUrls(&guidSearch, szUrl, ARRAYSIZE(szUrl), szUrlNavNew, ARRAYSIZE(szUrlNavNew), &fRunInProcess))
            hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        // if invoked from within a browser reuse it, else open a new browser
        IWebBrowser2 *pwb2;
        hr = IUnknown_QueryServiceForWebBrowserApp(_pSite, IID_PPV_ARG(IWebBrowser2, &pwb2));

        if (FAILED(hr))
        {
            //  Note: we want the frame to display shell characteristics (CLSID_ShellBrowserWindow),
            //  including persistence behavior, if we're loading shell search (CLSID_FileSearchBand).
            if (fRunInProcess || IsEqualGUID(clsidBand, CLSID_FileSearchBand))
                hr = CoCreateInstance(CLSID_ShellBrowserWindow, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWebBrowser2, &pwb2));
            else
                hr = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWebBrowser2, &pwb2));
            bNewFrame = TRUE;
        }

        if (SUCCEEDED(hr))
        {
            // show html-hosting band
            VARIANT var, varEmpty = {0};
            hr = InitBSTRVariantFromGUID(&var, clsidBand);
            if (SUCCEEDED(hr))
            {
                hr = pwb2->ShowBrowserBar(&var, &varEmpty, &varEmpty);
                VariantClear(&var);
            }

            if (SUCCEEDED(hr))
            {
                if (fShellSearchBand)
                {
                    hr = _ShowShellSearchResults(pwb2, bNewFrame, guidSearch);
                }
                else
                {
                    LBSTR::CString          strUrl;
                    VARIANT varFlags;
                    varFlags.vt = VT_I4;
                    varFlags.lVal = navBrowserBar;

                    LPTSTR          pstrUrl = strUrl.GetBuffer( MAX_URL_STRING );

                    if ( strUrl.GetAllocLength() < MAX_URL_STRING )
                    {
                        TraceMsg( TF_WARNING, "CShellSearchExt::InvokeCommand() - strUrl Allocation Failed!" );

                        strUrl.Empty();
                    }
                    else
                    {
                        SHTCharToUnicode( szUrl, pstrUrl, MAX_URL_STRING );

                        // Let CString class own the buffer again.
                        strUrl.ReleaseBuffer();
                    }

                    var.vt = VT_BSTR;
                    var.bstrVal = strUrl;

                    // if we opened a new window, navigate the right side to about.blank
                    if (bNewFrame)
                    {
                        LBSTR::CString          strNavNew;

                        if ( szUrlNavNew[0] )
                        {
                            LPTSTR          pstrNavNew = strNavNew.GetBuffer( MAX_URL_STRING );

                            if ( strNavNew.GetAllocLength() < MAX_URL_STRING )
                            {
                                TraceMsg( TF_WARNING, "CShellSearchExt::InvokeCommand() - strNavNew Allocation Failed!" );

                                strNavNew.Empty();
                            }
                            else
                            {
                                SHTCharToUnicode( szUrlNavNew, pstrNavNew, MAX_URL_STRING );

                                // Let CString class own the buffer again.
                                strNavNew.ReleaseBuffer();
                            }
                        }
                        else
                        {
                            strNavNew = L"about:blank";
                        }

                        // we don't care about the error here
                        pwb2->Navigate( strNavNew, &varEmpty, &varEmpty, &varEmpty, &varEmpty );
                    }

                    // navigate the search bar to the correct url
                    hr = pwb2->Navigate2( &var, &varFlags, &varEmpty, &varEmpty, &varEmpty );
                }
            }

            if (SUCCEEDED(hr) && bNewFrame)
                hr = pwb2->put_Visible(TRUE);

            pwb2->Release();
        }
    }
    return hr;
}

HRESULT CShellSearchExt::_IsShellSearchBand(REFGUID guidSearch)
{
    if (IsEqualGUID(guidSearch, SRCID_SFileSearch) ||
        IsEqualGUID(guidSearch, SRCID_SFindComputer) || 
        IsEqualGUID(guidSearch, SRCID_SFindPrinter))
        return S_OK;
    return S_FALSE;
}

HRESULT CShellSearchExt::_ShowShellSearchResults(IWebBrowser2* pwb2, BOOL bNewFrame, REFGUID guidSearch)
{
    VARIANT varBand;
    HRESULT hr = InitBSTRVariantFromGUID(&varBand, CLSID_FileSearchBand);
    if (SUCCEEDED(hr))
    {
        // Retrieve the FileSearchBand's unknown from the browser frame as a VT_UNKNOWN property;
        // (FileSearchBand initialized and this when he was created and hosted.)
        VARIANT varFsb;
        hr = pwb2->GetProperty(varBand.bstrVal, &varFsb);
        if (SUCCEEDED(hr))
        {
            IFileSearchBand* pfsb;
            if (SUCCEEDED(QueryInterfaceVariant(varFsb, IID_PPV_ARG(IFileSearchBand, &pfsb))))
            {
                // Assign the correct search type to the band
                VARIANT varSearchID;
                if (SUCCEEDED(InitBSTRVariantFromGUID(&varSearchID, guidSearch)))
                {
                    VARIANT varNil = {0};
                    VARIANT_BOOL bNavToResults = bNewFrame ? VARIANT_TRUE : VARIANT_FALSE ;
                    pfsb->SetSearchParameters(&varSearchID.bstrVal, bNavToResults, &varNil, &varNil);
                    VariantClear(&varSearchID);
                }
                pfsb->Release();
            }
            VariantClear(&varFsb);
        }
        VariantClear(&varBand);
    }
    return hr;
}

STDMETHODIMP CShellSearchExt::GetCommandString(UINT_PTR idCmd, UINT wFlags, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellSearchExt::SetSite(IUnknown *pUnkSite)
{
    IUnknown_Set(&_pSite, pUnkSite);
    return S_OK;
}
    
STDMETHODIMP CShellSearchExt::GetSite(REFIID riid, void **ppvSite)
{
    if (_pSite)
        return _pSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_NOINTERFACE;
}

CShellSearchExt::CShellSearchExt() : _cRef(1), _pSite(NULL)
{
}

CShellSearchExt::~CShellSearchExt()
{
    ATOMICRELEASE(_pSite);
}

class CWebSearchExt : public CShellSearchExt
{
public:
    CWebSearchExt();

private:
    virtual BOOL _GetSearchUrls(GUID *pguidSearch, LPTSTR pszUrl, DWORD cch, 
                                LPTSTR pszUrlNavNew, DWORD cchNavNew, BOOL *pfRunInProcess);
};

STDAPI CWebSearchExt_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CWebSearchExt* pwse;

    pwse = new CWebSearchExt();
    if (pwse)
    {
        *ppunk = SAFECAST(pwse, IContextMenu*);
        return S_OK;
    }
    else
    {
        *ppunk = NULL;
        return E_OUTOFMEMORY;
    }
}

CWebSearchExt::CWebSearchExt() : CShellSearchExt()
{
}

BOOL CWebSearchExt::_GetSearchUrls(GUID *pguidSearch, LPTSTR pszUrl, DWORD cch, 
                                   LPTSTR pszUrlNavNew, DWORD cchNavNew, BOOL *pfRunInProcess)
{
    // Currently does not support NavNew, can be extended later if desired, likewise for RunInProcess...
    *pfRunInProcess = FALSE;
    if (pszUrlNavNew && cchNavNew)
        *pszUrlNavNew = 0;

    return GetDefaultInternetSearchUrl(pszUrl, cch, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\shbrowse.h ===
#ifndef _SHBROWSE_H
#define _SHBROWSE_H

#include "iface.h"




#endif  // _SHBROWSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

# Build a browseuip.lib
BUILD_PRIVLIB   = 1

SELFREGNAME     = $(O)\selfreg_browseui.inf
MISCFILES       = $(MISCFILES) $(SELFREGNAME)

NO_BROWSER_FILE = 1
SYNCHRONIZE_DRAIN=1
TARGET_BOTH     = 1

!include $(CCSHELL_DIR)\browseui\browseui.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\browseui\browseui.inc

# For RC to find exdisp.TLB and brdispp.tlb
INCLUDES        = $(INCLUDES);$(SDK_LIB_PATH);$(O);$(CCSHELL_DIR)\lib\$(O)

TARGETNAME      = browseui
TARGETPATH      = obj
TARGETTYPE      = DYNLINK

#VERIFY_LC       = 1
LC_PATH         = $(PROJECT_ROOT)\lcinf

DLLDEF          = $(O)\browseui.def
DLLBASE         = 0x71500000

# NOTE!! We deliberately link to an NT4 compatible shell32.lib
#        so browseui can be loaded in the browser-only installations.
#        We use the NT version because it contains lego info.
#        The debug version of browseui links to the Win95 version
#        of shell32.lib simply so we can verify that we load in the
#        browser-only installations on Win95.
#
# Note:  Do *not* link to ntdll.  Win95 has an extremely minimal
#        implementation of ntdll.
#
# Note:  Do not link to uxtheme here. It needs to be in apithk.c. This file needs
#        to run downlevel where themes don't exist
#
TARGETLIBS      = $(SDK_LIB_PATH)\kernel32.lib      \
                  $(SHELL_LIB_PATH)\shlwapip.lib    \
                  $(SHELL_LIB_PATH)\shdocvwp.lib    \
                  $(SDK_LIB_PATH)\gdi32.lib         \
                  $(SDK_LIB_PATH)\user32.lib        \
                  $(SDK_LIB_PATH)\advapi32.lib      \
                  $(SDK_LIB_PATH)\uuid.lib          \
                  $(SDK_LIB_PATH)\ole32.lib         \
                  $(SDK_LIB_PATH)\oleaut32.lib      \
                  $(SDK_LIB_PATH)\htmlhelp.lib      \
                  $(CCSHELL_DIR)\lib\$(O)\ieguidp.lib \
                  $(CCSHELL_DIR)\lib\$(O)\shguid.lib  \
                  $(CCSHELL_DIR)\lib\$(O)\shfusion4.lib \
                  $(SDK_LIB_PATH)\mpr.lib           \
                  $(SDK_LIB_PATH)\shell32.lib       \
                  $(SDK_LIB_PATH)\wininet.lib       \
                  $(SDK_LIB_PATH)\uxtheme.lib       \
                  $(INETCORE_LIB_PATH)\urlmonp.lib  \
                  $(SDK_LIB_PATH)\msimg32.lib       \
                  $(SDK_LIB_PATH)\imm32.lib         \
                  $(SDK_LIB_PATH)\winmm.lib

DLLENTRY        = _DllMainCRTStartup

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

LINKLIBS        = ..\srcc\$(O)\srcc.lib         \
                  ..\srccpp\$(O)\srccpp.lib     \
                  ..\nt5api\$(O)\apithk.lib     \
                  ..\emclient\$(O)\emclient.lib \
                  ..\legacy\$O\legacy.lib       \
                  $(CCSHELL_DIR)\lib\$(O)\stock4.lib

# we want to force dlcheck.exe to run on browseui even though we don't use kernel32
# as our delayload handler
DLOAD_FORCE_ERROR_CHECK = 1

PRIVDEF         = $(O)\browseuip.def
PRIVDEFSRC      = ..\browseui.src
PRIVLIB         = browseuip.lib

# Maintain the sources list in the alphabetical order
SOURCES         = ..\browseui.rc

# Generate the selfreg file before compiling the RC file
NTTARGETFILE0  = $(SELFREGNAME)

NTTARGETFILES= $(CCSHELL_DIR)\lib\$(O)\browseui.lib \
               $(CCSHELL_DIR)\lib\$(O)\browseuip.lib

# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.BrowseUI
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\shbrows2.h ===
#ifndef _SHBROWS2_H
#define _SHBROWS2_H

#include "iface.h"
#include "commonsb.h"
#include "browmenu.h"
#include "bsmenu.h"
#include "fldset.h"
#include <iethread.h>

#define MAX_SB_TEXT_LEN 256

class CIEFrameAuto;


// Define structure to be used at head of state stream that is
// not dependent on 16 or 32 bits...
typedef struct _CABSHOLD       // Cabinet Stream header
{
    DWORD   dwSize;       // Offset to where the View streamed additional info

    // First stuff from the window placement
    DWORD  flags;
    DWORD  showCmd;
    POINTL ptMinPosition;
    POINTL ptMaxPosition;
    RECTL  rcNormalPosition;

    // Stuff from Folder Settings;
    DWORD   ViewMode;       // View mode (FOLDERVIEWMODE values)
    DWORD   fFlags;         // View options (FOLDERFLAGS bits)
    DWORD   TreeSplit;      // Position of split in pixels 

    // Hot Key
    DWORD   dwHotkey;        // Hotkey

    WINVIEW wv;
} CABSHOLD;

typedef struct _CABSH       // Cabinet Stream header
{
    DWORD   dwSize;       // Offset to where the View streamed additional info

    // First stuff from the window placement
    DWORD  flags;
    DWORD  showCmd;
    POINTL ptMinPosition;
    POINTL ptMaxPosition;
    RECTL  rcNormalPosition;

    // Stuff from Folder Settings;
    DWORD   ViewMode;       // View mode (FOLDERVIEWMODE values)
    DWORD   fFlags;         // View options (FOLDERFLAGS bits)
    DWORD   TreeSplit;      // Position of split in pixels 

    // Hot Key
    DWORD   dwHotkey;        // Hotkey

    WINVIEW wv;

    DWORD   fMask;          // Flags specifying which fields are valid
    SHELLVIEWID vid;        // extended view id
    DWORD   dwVersionId;    // CABSH_VER below
    DWORD   dwRevCount;     // rev count of default settings when the folder was saved to the stream
} CABSH;

#define CABSHM_VIEWID  0x00000001
#define CABSHM_VERSION 0x00000002
#define CABSHM_REVCOUNT 0x00000004

#define CABSH_VER 1 // change this version whenever we want to change defaults
#define CABSH_WIN95_VER 0 // this was the pre-ie4 version number

class CTheater;

#define CSBSUPERCLASS CCommonBrowser

#define CSHELLBROWSER CShellBrowser2
class CShellBrowser2 :
    public CSBSUPERCLASS
{
public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CSBSUPERCLASS::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) { return CSBSUPERCLASS::Release(); };

    // IShellBrowser (same as IOleInPlaceFrame)
    virtual STDMETHODIMP InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    virtual STDMETHODIMP SetMenuSB(HMENU hmenuShared, HOLEMENU holemenuReserved, HWND hwnd);
    virtual STDMETHODIMP RemoveMenusSB(HMENU hmenuShared);
    virtual STDMETHODIMP EnableModelessSB(BOOL fEnable);
    virtual STDMETHODIMP GetViewStateStream(DWORD grfMode, IStream **ppstm);
    virtual STDMETHODIMP GetControlWindow(UINT id, HWND * lphwnd);
    virtual STDMETHODIMP SendControlMsg(UINT id, UINT uMsg, WPARAM wParam,
                                        LPARAM lParam, LRESULT *pret);
    virtual STDMETHODIMP SetToolbarItems(LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags);
    virtual STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);
    virtual STDMETHODIMP OnViewWindowActive(IShellView * psv);

    // IServiceProvider
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void ** ppvObj);

    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IBrowserService
    virtual STDMETHODIMP ShowControlWindow(UINT id, BOOL fShow);
    virtual STDMETHODIMP IsControlWindowShown(UINT id, BOOL *pfShown);
    virtual STDMETHODIMP SetTitle(IShellView* psv, LPCWSTR pszName);
    virtual STDMETHODIMP UpdateWindowList(void);
    virtual STDMETHODIMP SetFlags(DWORD dwFlags, DWORD dwFlagMask);
    virtual STDMETHODIMP GetFlags(DWORD *pdwFlags);
    virtual STDMETHODIMP RegisterWindow(BOOL fUnregister, int swc);
    virtual STDMETHODIMP Offline(int iCmd);
    virtual STDMETHODIMP SetReferrer ( LPITEMIDLIST pidl) ;
    virtual STDMETHODIMP_(LRESULT) WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP OnCreate(LPCREATESTRUCT pcs);
    virtual STDMETHODIMP_(LRESULT) OnCommand(WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP OnDestroy();
    virtual STDMETHODIMP_(LRESULT) OnNotify(NMHDR * pnm);
    virtual STDMETHODIMP OnSetFocus();
    virtual STDMETHODIMP ReleaseShellView();
    virtual STDMETHODIMP ActivatePendingView();
    virtual STDMETHODIMP CreateViewWindow(IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd);
    virtual STDMETHODIMP UpdateBackForwardState () ;
    virtual STDMETHODIMP CreateBrowserPropSheetExt(REFIID, LPVOID *);
    virtual STDMETHODIMP SetAsDefFolderSettings();

    virtual STDMETHODIMP _TryShell2Rename( IShellView* psv, LPCITEMIDLIST pidlNew);
    virtual STDMETHODIMP _NavigateToPidl( LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags);
    virtual STDMETHODIMP v_MayTranslateAccelerator( MSG* pmsg);
    virtual STDMETHODIMP _SwitchActivationNow( );
    virtual STDMETHODIMP _Initialize(HWND hwnd, IUnknown *pauto);
    virtual STDMETHODIMP _GetEffectiveClientArea(LPRECT lprectBorder, HMONITOR hmon);

    virtual STDMETHODIMP_(LPSTREAM) v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName); 
    
    // IDockingWindowSite
    virtual STDMETHODIMP SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);

    // IInputSite
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);
    virtual STDMETHODIMP ShowToolbar(IUnknown* punkSrc, BOOL fShow);

        //IShellBrowserService
    virtual STDMETHODIMP GetPropertyBag(DWORD dwFlags, REFIID riid, void** ppv);


    BOOL IsCShellBrowser2() { return !_fSubclassed; };

protected:
    CShellBrowser2();
    virtual ~CShellBrowser2();

    friend HRESULT CShellBrowser2_CreateInstance(HWND hwnd, void ** ppsb);

    // topmost CBaseBrowser2 in a frameset (IE3/AOL/CIS/VB)
    virtual STDMETHODIMP v_CheckZoneCrossing(LPCITEMIDLIST pidl){return _CheckZoneCrossing(pidl);};
    virtual HRESULT     _CheckZoneCrossing(LPCITEMIDLIST pidl);

    // CShellBrowser2 virtuals
    virtual LRESULT     v_ForwardMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual DWORD       v_ShowControl(UINT iControl, int iCmd);
    virtual STDMETHODIMP        v_ShowHideChildWindows(BOOL fChildOnly = FALSE);
    virtual void        v_InitMembers();
    virtual void        v_SetIcon();
    virtual void        v_GetAppTitleTemplate(LPTSTR pszBuffer, size_t cchBuffer, LPTSTR pszTitle);
    virtual LRESULT     v_OnInitMenuPopup(HMENU hmenuPopup, int nIndex, BOOL fSystemMenu);
    virtual void        v_HandleFileSysChange(LONG lEvent, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2);
    virtual DWORD       v_RestartFlags();
    virtual void        v_FillCabStateHeader(CABSH* pcabsh, FOLDERSETTINGS *pfs);
    virtual void        v_ParentFolder();
    virtual BOOL        v_OnContextMenu(WPARAM wParam, LPARAM lParam);
    virtual BOOL        v_IsIEModeBrowser();    
    virtual BOOL        _CreateToolbar();
    virtual STDMETHODIMP _PositionViewWindow(HWND hwnd, LPRECT prc);
    virtual IStream *   _GetITBarStream(BOOL fWebBrowser, DWORD grfMode);

    //ViewStateStream related
    virtual void        v_GetDefaultSettings(IETHREADPARAM *pcv);

    void         _FillIEThreadParam(LPCITEMIDLIST pidl, IETHREADPARAM *piei);
    virtual void _UpdateFolderSettings(LPCITEMIDLIST pidl);

    BOOL        _ShouldAllowNavigateParent();
    BOOL        _ShouldSaveWindowPlacement();
    HRESULT     _GetBSForBar(LPCWSTR pwszItem, IBandSite **ppbs);
    void        _UpdateBackForwardStateNow();
    void        _ExecAllBands(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    void        _HideToolbar(IUnknown *punk);
    void        _BandClosed(IUnknown *punk, DWORD dwBandID);
    void        _ShowHideProgress();
    void        _CloseAllParents();
    void        _OnConfirmedClose();
    void        _OnClose(BOOL fPushed);
    void        _AfterWindowCreated(IETHREADPARAM *piei);
    BOOL        _ValidTargetPidl(LPCITEMIDLIST pidl, BOOL *pfTranslateRoot);
    LPITEMIDLIST _TranslateRoot(LPCITEMIDLIST pidl);
    BOOL        _GetVID(SHELLVIEWID *pvid);
    void         _UpdateRegFlags();

    void        _SaveState();
    void        _PropertyBagSaveState();
    void        _OldSaveState();
    HRESULT     _FillCabinetStateHeader(IStream *pstm, CABSH *cabsh);
    BOOL        _ReadSettingsFromStream(IStream *pstm, IETHREADPARAM *piei);
    BOOL        _ReadSettingsFromPropertyBag(IPropertyBag* ppb, IETHREADPARAM *piei);
    BOOL        _FillIEThreadParamFromCabsh(CABSH* pcabsh, IETHREADPARAM *piei);
    HRESULT     _CreateFakeNilPidl(LPITEMIDLIST *ppidl);
    BOOL        _IsPageInternet(LPCITEMIDLIST pidl);
    HRESULT     _GetPropertyBag(LPCITEMIDLIST pidl, DWORD dwFlags, REFIID riid, void** ppv);
    LPCITEMIDLIST _GetPidl();
    BOOL        _DoesPidlRoam(LPCITEMIDLIST pidl);
    void        _LoadBrowserWindowSettings(IETHREADPARAM *piei, LPCITEMIDLIST pidl);
    IDockingWindow* _GetITBar() { return _GetToolbarItem(ITB_ITBAR)->ptbar; }
    HMENU       _GetMenuFromID(UINT uID);
    void        _UpdateChildWindowSize(void);
    void        _GetAppTitle(LPTSTR pszBuffer, DWORD dwSize);
    IMenuBand*  _GetMenuBand(BOOL bDestroy);
    BOOL        _TranslateMenuMessage(HWND hwnd, UINT uMsg, WPARAM * pwParam, LPARAM * plParam, LRESULT * plRet);
    void        _ReloadTitle();
    void        _ReloadStatusbarIcon();

    BOOL        _OnTimer(UINT_PTR idTimer);
    LRESULT     _ToolbarOnNotify(LPNMHDR pnm);
    LRESULT     _OnInitMenuPopup(HMENU hmenuPopup, int nIndex, BOOL fSystemMenu);
    BOOL        _OnSysMenuClick(BOOL bLeftButton, WPARAM wParam, LPARAM lParam);
    LRESULT     _OnMenuSelect(WPARAM wParam, LPARAM lParam, UINT uHelpFlags);
    void        _SetMenuHelp(HMENU hmenu, UINT wID, LPCTSTR pszHelp);
    void        _SetBrowserBarMenuHelp(HMENU hmenu, UINT wID);
    void        _SetExternalBandMenuHelp(HMENU hmenu, UINT wID);
    void        _PruneMailNewsItems(HMENU hmenu);
    void        _SetTitle( LPCWSTR pwszName);
    HRESULT     _CreateFrameServices(void);

    void        _FavoriteOnCommand(HMENU hmenu, UINT idCmd);

    void        _CommonHandleFileSysChange(LONG lEvent, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2);
    void        _FSChangeCheckClose(LPCITEMIDLIST pidl, BOOL fDisconnect);
    void        _OnFSNotify(WPARAM, LPARAM);
//    replaced by CBaseBrowser2::NavigateToTLItem()
//    void        _RecentOnCommand(UINT idCmd);
    LRESULT     _FwdTBNotify(LPTBNOTIFY ptbn);
    void        _ToolTipFromCmd(LPTOOLTIPTEXT pnm);
    void        _AddFolderOptionsPage(PROPSHEETHEADER *ppsh);
    void        _AddAdvancedOptionsPage(PROPSHEETHEADER *ppsh);
    
    void        _IncrNetSessionCount();
    void        _DecrNetSessionCount();

    friend LRESULT CALLBACK IEFrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend void CALLBACK BrowserThreadProc(IETHREADPARAM* piei);
    
    void        _ExecFileContext(UINT idCmd);
    void        _EnableFileContext(HMENU hmenuPopup);
    LPITEMIDLIST _GetSubscriptionPidl();
    HRESULT     _GetBrowserBar(int idBar, BOOL fShow, IBandSite** ppbs, const CLSID* pclsid);

    BANDCLASSINFO* _BandClassInfoFromCmdID(UINT idCmd);

    void        _AddBrowserBarMenuItems(HMENU hmenu);
    HMENU       _GetBrowserBarMenu();
    int         _IdBarFromCmdID(UINT idCmd);
    int         _eOnOffNotMunge(int eOnOffNot, UINT idCmd, UINT idBar);
    void        _SetBrowserBarState(UINT idCmd, const CLSID *pclsid, int eOnOffNot, LPCITEMIDLIST pidl = NULL);
    const CLSID * _ShowHideBrowserBar(int idBar, const CLSID *pclsid, int eOnOff, LPCITEMIDLIST pidl);
    HRESULT     _GetBandSite(int idBar, IBandSite** ppbsSite, const CLSID *pclsid, int eOnOff);
    HRESULT     _EnsureAndNavigateBand(IBandSite* pbsSite, const CLSID* pclsid, LPCITEMIDLIST pidl = NULL);
    const CLSID * _InfoShowClsid(int idBar, const CLSID *pclsid, int eOnOff, LPCITEMIDLIST pidl = NULL);
    const CLSID * _InfoIdmToCLSID(UINT idCmd);
    const CATID * _InfoIdmToCATID(UINT idCmd);
    UINT        _InfoCLSIDToIdm(const CLSID *pguid);
    BOOL        _IsSameToolbar(LPWSTR wszBarName, IUnknown *punkBar);
    HRESULT     _AddInfoBands(IBandSite *punkBandSite);
    HRESULT     _AddSearchBand(IBandSite *punkBandSite);
    HRESULT     DoCopyData(COPYDATASTRUCT *pCDS);
    HRESULT     DoRemoteNavigate();
    void        _OrganizeFavorites();    
    BOOL        _ShouldForwardMenu(UINT uMsg, WPARAM wParam, LPARAM lParam);
    void        _TheaterMode(BOOL fShow, BOOL fRestorePrevious);
#ifdef DEBUG
    void        _DumpMenus(LPCTSTR pszMsg, BOOL bMsg);
#endif
    BOOL        _LoadBrowserHelperObjects(void);

    void        _CreateBrowserBarClose(HWND hwndParent);
    void        _SetTheaterBrowserBar();
    void        _SetMenu(HMENU hmenu);
    HWND        _GetCaptionWindow();
    LRESULT     _ThunkTTNotify(LPTOOLTIPTEXTA pnmTTTA);
    BOOL        _PrepareInternetToolbar(IETHREADPARAM* piei);
    HRESULT     _SaveITbarLayout(void);
    static LRESULT CALLBACK DummyTBWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    DWORD       _GetTempZone();
    void        _UpdateZonesPane(VARIANT *pvar);
    void        _DisplayFavoriteStatus(LPCITEMIDLIST pidl);
    void        _SendCurrentPage(DWORD dwSendAs);
    void        _OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam); 
    HRESULT     _FreshenComponentCategoriesCache( BOOL bForceUpdate ) ;
    void        _QueryHKCRChanged() ;    

    void        _PruneGoSubmenu(HMENU hmenu);
    HMENU       _MenuTemplate(int id, BOOL fShell);

    void        _MungeGoMyComputer(HMENU hmenuPopup);
    void        _OnGoMenuPopup(HMENU hmenuPopup);
    void        _OnViewMenuPopup(HMENU hmenuPopup);
    void        _OnToolsMenuPopup(HMENU hmenuPopup);
    void        _OnFileMenuPopup(HMENU hmenuPopup);
    void        _OnSearchMenuPopup(HMENU hmenuPopup);
    void        _OnHelpMenuPopup(HMENU hmenuPopup);
    void        _OnMailMenuPopup(HMENU hmenuPopup);
    void        _OnEditMenuPopup(HMENU hmenuPopup);
    void        _OnFindMenuPopup(HMENU hmenuPopup);
    void        _OnExplorerBarMenuPopup(HMENU hmenuPopup);
    void        _InsertTravelLogItems(HMENU hmenu, int nPos);

    // methods and members for monitoring the current status bar code page and font
    HRESULT _GetCodePage(UINT * puiCodePage, DWORD dwCharSet);

    int         _GetIconIndex(void);
    HRESULT     _QIExplorerBand(REFIID riid, void ** ppvObj);
    virtual BOOL _CanHandleAcceleratorNow(void) {return _fActivated;}

    bool        _IsExplorerBandVisible (void);

#ifdef UNIX
    BOOL        _HandleActivation( WPARAM wParam );
#endif

    void        _GetDefaultWindowPlacement(HWND hwnd, HMONITOR hmon, WINDOWPLACEMENT* pwp);

    // NT5 specific message handling:
    BOOL        _OnAppCommand(WPARAM wParam, LPARAM lParam);
    LPARAM      _WndProcBSNT5(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    

    // Menus: see dochost.h for an explanation from the dochost perspective.
    //        REARCHITECT (scotth): difference b/t _hmenuTemplate and _hmenuFull?
    //        

    HMENU       _hmenuTemplate;
    HMENU       _hmenuFull;
    HMENU       _hmenuBrowser;          // Provided from dochost, used for _menulist
    HMENU       _hmenuCur;              // Used to keep track.  Needed when in Kiosk mode...
    HMENU       _hmenuPreMerged;
#ifdef DEBUG    
    HMENU       _hmenuHelp;             // Our help menu
#endif

    HICON       _hZoneIcon;
    HANDLE      _hEventComCat;

    CMenuList   _menulist;              // Menu list for dispatching

    IContextMenu2 *_pcmNsc;             // iff we've popped up File Menu w/ NSC context item
    IOleCommandTarget *_poctNsc;       // iff we have visible name space control band
    int         _idMenuBand;
    HWND        _hwndStatus;
    HWND        _hwndProgress;
    int         _iTBOffset[3];
    
    CBandSiteMenu *_pbsmInfo;
    UINT        _idmInfo;               // selected View.BrowserBar submenu

    IMenuBand* _pmb;                   // Use _GetMenuBand to access this

    LPITEMIDLIST _pidlReferrer;

    WINDOWPLACEMENT _wndpl;             // Used to go into and out of full screen mode.
    CLSID           _clsidThis;         // browser class ID
    
    BITBOOL     _fStatusBar : 1;
    BITBOOL     _fAutomation : 1;       // was it launched from automation?
    BITBOOL     _fShowMenu : 1;         // should we show menus?
    BITBOOL     _fForwardMenu : 1;      // should we be forwarding menu messages?
    BITBOOL     _fNoLocalFileWarning: 1; // Do we directly execute local files without warning?
    BITBOOL     _fDispatchMenuMsgs:1;   // TRUE: forward menu messages as appropriate
    BITBOOL     _fUISetByAutomation: 1; // has ui (things that go in view options) been set by automation?
    BITBOOL     _fDontSaveViewOptions:1;   // Set if we should not save the view options on exit
    BITBOOL     _fSBWSaved :1;          // single browser window saved yet?
    BITBOOL     _fInternetStart :1;     // did we start on a net site?
    BITBOOL     _fWin95ViewState:1;
    BITBOOL     _fSubclassed :1;        // are we subclassed?
    BITBOOL     _fVisitedNet :1;        // did we ever hit the net in this session?
    BITBOOL     _fUnicode :1;           // is our view window unicode?
    BITBOOL     _fKioskMode : 1;        // Are we in full screen kiosk mode?  (not the same as fullscreen/theater mode)
    BITBOOL     _fTitleSet :1;          // has our content changed our title?
    BITBOOL     _fMarshalledDispatch:1; // have we marshalled dispatch?
    BITBOOL     _fMinimized :1;         // Minimized or not. 
    BITBOOL     _fReceivedDestroy: 1;   // Received WM_DESTROY message
    BITBOOL     _fDisallowSizing: 1;
    BITBOOL     _fShowNetworkButtons:1; // Based off the registry, we display the network connect button 
    BITBOOL     _fIgnoreNextMenuDeselect:1; // TRUE: Ignore the next deselection WM_MENUSELECT (hack)
    
    BITBOOL     _fActivated:1; // TRUE: the frame is set active, FALSE: the frame is inactive
    BITBOOL     _fClosingWindow:1; // TRUE: while closing, to avoid double-save and fault

    BITBOOL     _fDidRegisterWindow:1;  // called RegisterWindow() which registers the window with the winlist
#ifdef UNIX
    BITBOOL     _fSetAddressBarFocus:1;   
#endif
#ifdef NO_MARSHALLING
    BITBOOL     _fDelayedClose:1;  // Used to mark windows for delay close.
    BITBOOL     _fOnIEThread:1;    // used to flag if we are not running on the main thread
#endif
    BITBOOL     _fUpdateBackForwardPosted:1; // have we posted to update the back/forward state?
    BITBOOL     _fValidComCatCache ;         // Have we ensured that the component cache is valid

    BITBOOL     _fShowFortezza : 1;          // status of the Fortezza menu
    BITBOOL     _fRunningInIexploreExe:1;    // are we running in iexplore.exe
    BITBOOL     _fShowSynchronize : 1;       // should we show Tools|Synchronize?
    BITBOOL     _fNilViewStream : 1;         // CabView settings were loaded for unknown pidl.

    BITBOOL     _fAppendIEToCaptionBar : 1;  // Does the NSE want Append " - IE" to the captionbar display name?  See IBrowserFrameOptions
    BITBOOL     _fAddDialUpRef : 1;          // Does the NSE want a ref on the modem connection while browsed to this folder?  See IBrowserFrameOptions
    BITBOOL     _fUseIEToolbar : 1;          // Does the NSE want to use the IE style toolbar?  See IBrowserFrameOptions
    BITBOOL     _fEnableOfflineFeature : 1;  // Does the NSE want to enable the IE Offline feature?  See IBrowserFrameOptions
    BITBOOL     _fUseIEPersistence : 1;      // Does the NSE want to use IE type persistence?  Window pos, size, icon layout. See IBrowserFrameOptions
    BITBOOL     _fInRefresh : 1;             // Ignore refresh messages (FCIDM_REFRESH) if we are currently processing a refresh. (Prevents recursion death)

    UINT        _idmComm;               // selected View.BrowserBar submenu
    UINT        _iCommOffset;           // Start position in dynamically loaded comp categories

    ULONG _uFSNotify;

    int     _iSynchronizePos;
    TCHAR   *_pszSynchronizeText;       // What is Tools|Synchronize in your language?

    // Window list related (also _fMarshalledDispatch above)
    IShellWindows*   _psw;
    int         _swcRegistered;         // the SWC_* that this window is in the winlist as
    
    // Item ContextMenu 
    IContextMenu3 * _pcm;
    long  _dwRegisterWinList;  // Have we registered with the windows list

    HWND            _hwndDummyTB;
    IExplorerToolbar* _pxtb;
    int             _nTBTextRows; 

    // For the two members below, see notes above CShellBrowser2::_SwitchActivationNow
    TBBUTTON *  _lpButtons;
    int         _nButtons;

    TBBUTTON *  _lpPendingButtons;
    int         _nButtonsPending;

    IContextMenu3*   _pcmSearch;// new style
    IContextMenu*    _pcmFind;  // old style find context menu
        
    CTheater *_ptheater;

    LPITEMIDLIST    _pidlLastHist;
    LPITEMIDLIST    _pidlMenuSelect;

    UINT            _uiZonePane;
    IInternetSecurityManager * _pism;
    HMENU                      _hfm;

    DWORD       _dwRevCount;     // rev count of the global window settings
    UINT  _nMBIgnoreNextDeselect;
    IUnknown *_punkMsgLoop;

#ifdef NO_MARSHALLING
    BOOL  _fReallyClosed;
#endif

    // _PositionViewWindow
    HWND _hwndDelayedSize;
    RECT _rcDelayedSize;
    BOOL _fHaveDelayedSize;

private:
    HRESULT _SetBrowserFrameOptions(LPCITEMIDLIST pidl);
    HRESULT _ReplaceCmdLine(LPTSTR pszCmdLine, DWORD cchSize);
};

BOOL FindBrowserWindow(void);

//
// Useful functions.
//

STDAPI_(BOOL) AddToRestartList(UINT flags, LPCITEMIDLIST pidl);
STDAPI_(BOOL) OpenFolderWindow(IETHREADPARAM* pieiIn);
HMENU _MenuTemplate(int id, BOOL bNukeTools);

#define INFOBAR_TBNAME  L"BrowserBar"
#ifndef UNIX
#define INFOBAR_WIDTH   204
#else
#define INFOBAR_WIDTH   277
#endif
#define COMMBAR_TBNAME  L"CommBar"
#define COMMBAR_HEIGHT  100

// Constants for different Browser/Info BARs
#define IDBAR_INFO         1
#define IDBAR_COMM         2
#define IDBAR_VERTICAL     IDBAR_INFO
#define IDBAR_HORIZONTAL   IDBAR_COMM
#define IDBAR_INVALID      42

#endif  // _SHBROWS2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\shellurl.h ===
/**************************************************************\
    FILE: shellurl.h

    DESCRIPTION:
    Handle dealing with Shell Urls.  Include: Generating from PIDL, 
    Generating from preparsed Url String, and parsing from a user
    entered Url String.
\**************************************************************/

#ifndef _SHELLURL_H
#define _SHELLURL_H

#define STR_REGKEY_APPPATH   TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths")


// Parameters for ::SetUrl()'s dwGenType parameter
#define GENTYPE_FROMPATH    0x00000001
#define GENTYPE_FROMURL     0x00000002

class CShellUrl;

BOOL IsShellUrl(LPCTSTR pcszUrl, BOOL fIncludeFileUrls);
BOOL IsSpecialFolderChild(LPCITEMIDLIST pidlToTest, int nFolder, BOOL fImmediate);
HRESULT SetDefaultShellPath(CShellUrl * psu);


/**************************************************************\
    CLASS: CShellUrl

    DESCRIPTION:
        This object was created to keep track of a FULL SHELL URL.
    This includes any object in the shell name space and how
    to interact with that object.  Objects can be specified as
    PIDLs and then will be handled appropriately when executed,
    which means it will Navigate to the object if the object
    supports navigation or "browse in place" (registered DocHost, 
    Shell Folder, Internet URL)
    otherwise the Shell Url will be executed (files, shell items).

         If a string is inputed by the user, the ::ParseFromOutsideSource()
    method should be called.  This will take all of the environment
    information into consideration (CurrWorkDir & Path) and parse
    the URL.  If the string needs to be shell executed, it will
    generate the command line arguments and current working directory
    string.  If the object is to be navigated to, it will determine
    the navigation flags (for AutoSearch and similar things).

    PERF:
        This object was build so that if you specify a PIDL or String,
    it should be able to hold that information without a perf hit.
    If you want to take advantage of ::ParseFromOutsideSource() or
    ::Execute(), it will require a little more CPU time to do the
    full functionality.

    GOAL:
        The goal of the parsing is to make it into a normal internet
    URL unless the algorithm can with certainty assume that the string
    entered is specifying a Shell Name Space item or action.  This means
    that CShellUrl will only assume the entered text is a Shell Item to be
    Navigated to if it can successfully bind to the destination pidl.
    It will assume it's an item to be executed and use the end of the
    string as Command Line Arguments if: 1) It can bind to the end PIDL,
    and 2) The end pidl is not "Browsable" or "Navigatible", and 3)
    the char after the string specifying the PIDL is a Space.
\**************************************************************/
class CShellUrl : public IAddressBarParser
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IAddressBarParser
    STDMETHODIMP ParseFromOutsideSource(LPCTSTR pcszUrlIn, DWORD dwParseFlags, PBOOL pfWasCorrected = NULL, PBOOL pfWasCanceled = NULL);
    STDMETHODIMP GetUrl(LPTSTR pszUrlOut, DWORD cchUrlOutSize);
    STDMETHODIMP SetUrl(LPCTSTR pcszUrlIn, DWORD dwGenType);       // Reset CShellUrl to this URL
    STDMETHODIMP GetDisplayName(LPTSTR pszUrlOut, DWORD cchUrlOutSize);
    STDMETHODIMP GetPidl(LPITEMIDLIST * ppidl);
    STDMETHODIMP SetPidl(LPCITEMIDLIST pidl);       // Reset CShellUrl to this PIDL
    STDMETHODIMP GetArgs(LPTSTR pszArgsOut, DWORD cchArgsOutSize);
    STDMETHODIMP AddPath(LPCITEMIDLIST pidl);

    // Constructor / Destructor
    CShellUrl();
    ~CShellUrl(void);  

    HRESULT Clone(CShellUrl * pShellUrl);

    HRESULT Execute(IBandProxy * pbp, BOOL * pfDidShellExec, DWORD dwExecFlags);

    BOOL IsWebUrl(void);

    HRESULT SetCurrentWorkingDir(LPCITEMIDLIST pidlCWD);
    HRESULT Reset(void);
    void SetMessageBoxParent(HWND hwnd);

#ifdef UNICODE
    HRESULT ParseFromOutsideSource(LPCSTR pcszUrlIn, DWORD dwParseFlags, PBOOL pfWasCorrected);
#endif // UNICODE

    HRESULT GetPidlNoGenerate(LPITEMIDLIST * ppidl);

private:
    // Parsing Methods
    HRESULT _ParseRelativePidl(LPCTSTR pcszUrlIn, BOOL * pfPossibleWebUrl, DWORD dwFlags, LPCITEMIDLIST pidl, BOOL fAllowRelative, BOOL fQualifyDispName);
    HRESULT _ParseUNC(LPCTSTR pcszUrlIn, BOOL * pfPossibleWebUrl, DWORD dwFlags, BOOL fQualifyDispName);
    HRESULT _ParseSeparator(LPCITEMIDLIST pidlParent, LPCTSTR pcszSeg, BOOL * pfPossibleWebUrl, BOOL fAllowRelative, BOOL fQualifyDispName);
    HRESULT _ParseNextSegment(LPCITEMIDLIST pidlParent, LPCTSTR pcszStrToParse, BOOL * pfPossibleWebUrl, BOOL fAllowRelative, BOOL fQualifyDispName);
    HRESULT _CheckItem(IShellFolder * psfFolder, LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlRelative, 
                       LPITEMIDLIST * ppidlChild, LPCTSTR pcszStrToParse, LPTSTR * ppszRemaining, DWORD dwFlags);
    HRESULT _GetNextPossibleSegment(LPCTSTR pcszFullPath, LPTSTR * ppszSegIterator, LPTSTR pszSegOut, DWORD cchSegOutSize, BOOL fSkipShare);
    HRESULT _GetNextPossibleFullPath(LPCTSTR pcszFullPath, LPTSTR * ppszSegIterator, LPTSTR pszSegOut, DWORD cchSegOutSize, BOOL * pfContinue);
    HRESULT _QualifyFromPath(LPCTSTR pcszFilePathIn, DWORD dwFlags);
    HRESULT _QualifyFromDOSPath(LPCTSTR pcszFilePathIn, DWORD dwFlags);
    HRESULT _QualifyFromAppPath(LPCTSTR pcszFilePathIn, DWORD dwFlags);
    HRESULT _QuickParse(LPCITEMIDLIST pidlParent, LPTSTR pszParseChunk, LPTSTR pszNext, BOOL * pfPossibleWebUrl, BOOL fAllowRelative, BOOL fQualifyDispName);
    BOOL _CanUseAdvParsing(void);
    BOOL _ParseURLFromOutsideSource(LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL, LPBOOL pbWasCorrected);
    HRESULT _TryQuickParse(LPCTSTR pszUrl, DWORD dwParseFlags);

    // Accessor Methods
    HRESULT _SetPidl(LPCITEMIDLIST pidl);       // Set PIDL w/o modifying URL
    HRESULT _GeneratePidl(LPCTSTR pcszUrl, DWORD dwGenType);
    HRESULT _SetUrl(LPCTSTR pcszUrlIn, DWORD dwGenType);       // Set URL w/o modifying PIDL
    HRESULT _GenerateUrl(LPCITEMIDLIST pidl);
    HRESULT _GenDispNameFromPidl(LPCITEMIDLIST pidl, LPCTSTR pcszArgs);

    // Other Methods
    HRESULT _PidlShellExec(LPCITEMIDLIST pidl, ULONG ulShellExecFMask);
    HRESULT _UrlShellExec(void);
    BOOL _IsFilePidl(LPCITEMIDLIST pidl);

    HWND _GetWindow(void) { return (IsFlagSet(m_dwFlags, SHURL_FLAGS_NOUI) ? NULL : GetDesktopWindow()); }


    //////////////////////////////////////////////////////
    //  Private Member Variables 
    //////////////////////////////////////////////////////

    LPTSTR          m_pszURL;
    LPTSTR          m_pszDisplayName;       // The nice display name of the entity.
    LPTSTR          m_pszArgs;
    LPTSTR          m_pstrRoot;
    LPITEMIDLIST    m_pidl;
    DWORD           m_dwGenType;
    DWORD           m_dwFlags;

    LPITEMIDLIST    m_pidlWorkingDir;
    HDPA            m_hdpaPath;             // DPA of PIDLs
    HWND            m_hwnd;                 // parent window for message boxes
    LONG            _cRef;
};


#endif /* _SHELLURL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\shellurl.cpp ===
/**************************************************************\
    FILE: shellurl.cpp

    DESCRIPTION:
        Implements CShellUrl.
\**************************************************************/

#include "priv.h"
#include "resource.h"
#include "util.h"
#include "shellurl.h"

#include "bandprxy.h"

#include "mluisupp.h"


// We need to reroute radio urls
#define WZ_RADIO_PROTOCOL   L"vnd.ms.radio:"


//#define FEATURE_WILDCARD_SUPPORT

#define CH_DOT                TEXT('.')
#define CH_SPACE              TEXT(' ')
#define CH_SEPARATOR          TEXT('/')
#define CH_FRAGMENT           TEXT('#')

#ifdef FEATURE_WILDCARD_SUPPORT
#define CH_ASTRISK            TEXT('*')
#define CH_QUESTIONMARK       TEXT('?')
#endif // FEATURE_WILDCARD_SUPPORT

#define SZ_SPACE              TEXT(" ")
#define SZ_SEPARATOR          TEXT("/")
#define SZ_UNC                TEXT("\\\\")


#define CH_FILESEPARATOR      TEXT('\\')
#define SZ_FILESEPARATOR      TEXT("\\")

#define CE_PATHGROW 1

#define IS_SHELL_SEPARATOR(ch) ((CH_SEPARATOR == ch) || (CH_FILESEPARATOR == ch))

// Private Functions
BOOL _FixDriveDisplayName(LPCTSTR pszStart, LPCTSTR pszCurrent, LPCITEMIDLIST pidl);

#define TF_CHECKITEM 0 // TF_BAND|TF_GENERAL


/****************************************************\
    CShellUrl Constructor
\****************************************************/
CShellUrl::CShellUrl()
{
    TraceMsg(TF_SHDLIFE, "ctor CShellUrl %x", this);

    // Don't want this object to be on the stack
    ASSERT(!m_pszURL);
    ASSERT(!m_pszArgs);
    ASSERT(!m_pstrRoot);
    ASSERT(!m_pidl);
    ASSERT(!m_pidlWorkingDir);
    ASSERT(!m_hdpaPath);
    ASSERT(!m_dwGenType);
    ASSERT(!m_hwnd);
}


/****************************************************\
    CShellUrl destructor
\****************************************************/
CShellUrl::~CShellUrl()
{
    Reset();
    if (m_pstrRoot)
    {
        LocalFree(m_pstrRoot);
        m_pstrRoot = NULL;
    }

    if (m_pidlWorkingDir)
        ILFree(m_pidlWorkingDir);

    _DeletePidlDPA(m_hdpaPath);
    TraceMsg(TF_SHDLIFE, "dtor CShellUrl %x", this);
}


//***   CShellUrl::IUnknown::* {

ULONG CShellUrl::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CShellUrl::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CShellUrl::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShellUrl, IAddressBarParser),         // IID_IUserAssist
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

/****************************************************\
    FUNCTION: Clone

    PARAMETERS
         pShellUrl - This is the pointer to object that
               we want to clone

    DESCRIPTION:
        This function will make a deep copy of the passed
        object into 'this'
\****************************************************/
HRESULT CShellUrl::Clone(CShellUrl * pShellUrl)
{
    HRESULT hr = S_OK;
    if (!pShellUrl)
    {
        hr = E_POINTER;
        goto exit;
    }

    Str_SetPtr(&m_pszURL, pShellUrl->m_pszURL);
    Str_SetPtr(&m_pszDisplayName, pShellUrl->m_pszDisplayName);
    Str_SetPtr(&m_pszArgs, pShellUrl->m_pszArgs);
    Str_SetPtr(&m_pstrRoot, pShellUrl->m_pstrRoot);
    
    m_dwGenType = pShellUrl->m_dwGenType;
    m_dwFlags = pShellUrl->m_dwFlags;
    m_hwnd = pShellUrl->m_hwnd;

    if (m_pidl)
    {
        ILFree(m_pidl);
        m_pidl = NULL;
    }

    if (pShellUrl->m_pidl)
    {
        m_pidl = ILClone(pShellUrl->m_pidl);
        if (!m_pidl)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

    if (m_pidlWorkingDir)
    {
        ILFree(m_pidlWorkingDir);
        m_pidlWorkingDir = NULL;
    }

    if (pShellUrl->m_pidlWorkingDir)
    {
        m_pidlWorkingDir = ILClone(pShellUrl->m_pidlWorkingDir);
        if (!m_pidlWorkingDir)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

    _DeletePidlDPA(m_hdpaPath);
    m_hdpaPath = NULL;
    if (pShellUrl->m_hdpaPath)
    {
        m_hdpaPath = DPA_Create(CE_PATHGROW);
        for(int nPathIndex = 0; nPathIndex < DPA_GetPtrCount(pShellUrl->m_hdpaPath); nPathIndex++)
        {
            LPITEMIDLIST pidlCurrPath = (LPITEMIDLIST) DPA_GetPtr(pShellUrl->m_hdpaPath, nPathIndex);
            LPITEMIDLIST pidlNew = ILClone(pidlCurrPath);
            if (pidlNew)
                DPA_AppendPtr(m_hdpaPath, pidlNew);
            else
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }
    }

exit:
    return hr;
}



/****************************************************\
    FUNCTION: Execute

    PARAMETERS
         pbp - This is the pointer to the interface
               which is needed to find a new topmost
               window or the associated browser window.
         pfDidShellExec (Out Optional) - This parameter
               can be NULL.  If not NULL, it will be set
               to TRUE if this Execute() called ShellExec.
               This is needed by callers that wait for
               DISPID_NAVIGATECOMPLETE which will never happen
               in this case.

    DESCRIPTION:
        This command will determine if the current
    shell url needs to be shell executed or navigated
    to.  If it needs to be navigated to, it will try
    to navigate to the PIDL, otherwise, it will navigate
    to the string version.
\****************************************************/
HRESULT CShellUrl::Execute(IBandProxy * pbp, BOOL * pfDidShellExec, DWORD dwExecFlags)
{
    HRESULT hr = S_FALSE;       // S_FALSE until navigation occurs.
    ULONG ulShellExecFMask = (IsFlagSet(dwExecFlags, SHURL_EXECFLAGS_SEPVDM)) ? SEE_MASK_FLAG_SEPVDM : 0;

    ASSERT(IS_VALID_CODE_PTR(pbp, IBandProxy *));
    ASSERT(!pfDidShellExec || IS_VALID_WRITE_PTR(pfDidShellExec, BOOL));

    if (!EVAL(pbp))
        return E_INVALIDARG;

    // Is the following true: 1) The caller wants other browsers to be able to handle the URLs,
    // 2) The ShellUrl is a Web Url, and 3) IE doesn't own HTML files.
    // If all of these are true, then we will just ShellExec() the URL String so the
    // default handler can handle it.
    // Also if the user wants us to browse in a new process and we are currently in the shell process,
    // we will launch IE to handle the url.

    if ((IsFlagSet(dwExecFlags, SHURL_EXECFLAGS_DONTFORCEIE) && IsWebUrl() && !IsIEDefaultBrowser())
#ifdef BROWSENEWPROCESS_STRICT // "Nav in new process" has become "Launch in new process", so this is no longer needed
    ||  (IsWebUrl() && IsBrowseNewProcessAndExplorer())
#endif
       )
    {
        hr = _UrlShellExec();
        ASSERT(S_OK == hr);
    }

    if ((S_OK != hr) && m_pidl && _CanUseAdvParsing())
    {
        // We will only Shell Exec it if:
        // 1. We want to Force IE (over other web browsers) and it's not browsable, even by non-default owners.
        // 2. It's not browsable by default owners.
        if (!ILIsBrowsable(m_pidl, NULL))
        {
            if (pfDidShellExec)
                *pfDidShellExec = TRUE;

            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
            TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: Execute() Going to _PidlShellExec(>%s<)", Dbg_PidlStr(m_pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
            // If NULL == m_pidl, then the String will be used.
            hr = _PidlShellExec(m_pidl, ulShellExecFMask);
        }
    }

    if (S_OK != hr)
    {
        VARIANT vFlags = {0};

        vFlags.vt = VT_I4;
        vFlags.lVal = navAllowAutosearch;

        if (pfDidShellExec)
            *pfDidShellExec = FALSE;

        // We prefer pidls, thank you
        if (m_pidl)
        {
            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
            TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: Execute() Going to pbp->NavigateToPIDL(>%s<)", Dbg_PidlStr(m_pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
            hr = pbp->NavigateToPIDL(m_pidl);
        }
        else
        {
            ASSERT(m_pszURL);
            TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: Execute() Going to pbp->NavigateToURL(%s)", m_pszURL);
#ifdef UNICODE
            hr = pbp->NavigateToURL(m_pszURL, &vFlags);
#else
            WCHAR wszURL[MAX_URL_STRING];
            SHTCharToUnicode(m_pszURL, wszURL, ARRAYSIZE(wszURL));
            hr = pbp->NavigateToURL(wszURL, &vFlags);
#endif
        }

        VariantClearLazy(&vFlags);
    }

    return hr;
}


/****************************************************\
    FUNCTION: _PidlShellExec

    PARAMETERS
        pidl - The Pidl to execute.

    DESCRIPTION:
        This function will call ShellExecEx() on the
    pidl specified.  It will also fill in the Current
    Working Directory and Command Line Arguments if there
    are any.
\****************************************************/
HRESULT CShellUrl::_PidlShellExec(LPCITEMIDLIST pidl, ULONG ulShellExecFMask)
{
    HRESULT hr = E_FAIL;
    SHELLEXECUTEINFO sei = {0};

    ASSERT(IS_VALID_PIDL(pidl));

    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _PidlShellExec() Going to execute pidl=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

    if (m_pidlWorkingDir)
    {
        // note, this must be MAX_URL_STRING since IEGetDisplayName can return a URL.
        WCHAR szCWD[MAX_URL_STRING];

        IEGetDisplayName(m_pidlWorkingDir, szCWD, SHGDN_FORPARSING);
        if (PathIsFilePath(szCWD))
        {
            sei.lpDirectory = szCWD;
        }
    }
    /**** TODO: Get the Current Working Directory of top most window
    if (!sei.lpDirectory || !sei.lpDirectory[0])
    {
        GetCurrentDirectory(SIZECHARS(szCurrWorkDir), szCurrWorkDir);
        sei.lpDirectory = szCurrWorkDir;
    }
    *****/

    sei.cbSize          = sizeof(SHELLEXECUTEINFO);
    sei.lpIDList        = (LPVOID) pidl;
    sei.lpParameters    = m_pszArgs;
    sei.nShow           = SW_SHOWNORMAL;
    sei.fMask           = SEE_MASK_FLAG_NO_UI | (pidl ? SEE_MASK_INVOKEIDLIST : 0) | ulShellExecFMask;
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _PidlShellExec() Cmd=>%s<, Args=>%s<, WorkDir=>%s<",
                GEN_DEBUGSTR(sei.lpFile), GEN_DEBUGSTR(sei.lpParameters), GEN_DEBUGSTR(sei.lpDirectory));

    if (ShellExecuteEx(&sei))
        hr = S_OK;
    else
    {
#ifdef DEBUG
        DWORD dwGetLastError = GetLastError();
        TraceMsg(TF_ERROR, "ShellUrl: _PidlShellExec() ShellExecuteEx() failed for this item. Cmd=>%s<; dwGetLastError=%lx", GEN_DEBUGSTR(sei.lpParameters), dwGetLastError);
#endif // DEBUG
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************\
    FUNCTION: _UrlShellExec

    DESCRIPTION:
        This function will call ShellExecEx() on the
    URL.  This is so other popular browsers can handle
    the URL if they own HTML and other web files.
\****************************************************/
HRESULT CShellUrl::_UrlShellExec(void)
{
    HRESULT hr = E_FAIL;
    SHELLEXECUTEINFO sei = {0};

    ASSERT(m_pszURL);
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _UrlShellExec() Going to execute URL=>%s<", m_pszURL);

    sei.cbSize          = sizeof(sei);
    sei.lpFile          = m_pszURL;
    sei.nShow           = SW_SHOWNORMAL;
    sei.fMask           = SEE_MASK_FLAG_NO_UI;

    if (m_pszURL && ShellExecuteEx(&sei))
        hr = S_OK;
    else
        hr = E_FAIL;

    return hr;
}

// The following function is identical to ParseURLFromOutsideSource except that it
// enables autocorrect and sets pbWasCorrected to TRUE if the string was corrected
BOOL CShellUrl::_ParseURLFromOutsideSource
(
    LPCWSTR psz,
    LPWSTR pszOut,
    LPDWORD pcchOut,
    LPBOOL pbWasSearchURL,  // if converted to a search string
    LPBOOL pbWasCorrected   // if url was autocorrected
    )
{
    // This is our hardest case.  Users and outside applications might
    // type fully-escaped, partially-escaped, or unescaped URLs at us.
    // We need to handle all these correctly.  This API will attempt to
    // determine what sort of URL we've got, and provide us a returned URL
    // that is guaranteed to be FULLY escaped.

    IURLQualify(psz, UQF_DEFAULT | UQF_AUTOCORRECT, pszOut, pbWasSearchURL, pbWasCorrected);

    //
    //  Go ahead and canonicalize this appropriately
    //
    if (FAILED(UrlCanonicalize(pszOut, pszOut, pcchOut, URL_ESCAPE_SPACES_ONLY)))
    {
        //
        //  we cant resize from here.
        //  NOTE UrlCan will return E_POINTER if it is an insufficient buffer
        //
        return FALSE;
    }

    return TRUE;
}
#ifdef UNICODE
HRESULT CShellUrl::ParseFromOutsideSource(LPCSTR pcszUrlIn, DWORD dwParseFlags, PBOOL pfWasCorrected)
{
    WCHAR wzUrl[MAX_URL_STRING];

    SHAnsiToUnicode(pcszUrlIn, wzUrl, ARRAYSIZE(wzUrl));
    return ParseFromOutsideSource(wzUrl, dwParseFlags, pfWasCorrected);
}
#endif // UNICODE


/****************************************************\
    FUNCTION: _TryQuickParse

    PARAMETERS
        pcszUrlIn - String to parse.
        dwParseFlags - Flags to modify parsing. (Defined in iedev\inc\shlobj.w)

    DESCRIPTION:
        We prefer to call g_psfDesktop->ParseDisplayName()
    and have it do the parse really quickly and without
    enumerating the name space.  We need this for things
    that are parsed but not enumerated, which includes:
    a) hidden files, b) other.

    However, we need to not parse URLs if the caller
    doesn't want to accept them.
\****************************************************/
HRESULT CShellUrl::_TryQuickParse(LPCTSTR pszUrl, DWORD dwParseFlags)
{
    HRESULT hr = E_FAIL;  // E_FAIL means we don't know yet.
    int nScheme = GetUrlScheme(pszUrl);

    // Don't parse unknown schemes because we may
    // want to "AutoCorrect" them later.
    if (URL_SCHEME_UNKNOWN != nScheme)
    {
        if ((dwParseFlags & SHURL_FLAGS_NOWEB) &&
            (URL_SCHEME_INVALID != nScheme) &&
            (URL_SCHEME_UNKNOWN != nScheme) &&
            (URL_SCHEME_MK != nScheme) &&
            (URL_SCHEME_SHELL != nScheme) &&
            (URL_SCHEME_LOCAL != nScheme) &&
            (URL_SCHEME_RES != nScheme) &&
            (URL_SCHEME_ABOUT != nScheme))
        {
            // Skip parsing this because it's a web item, and
            // the caller wants to filter those out.
        }
        else
        {
            hr = IEParseDisplayNameWithBCW(CP_ACP, pszUrl, NULL, &m_pidl);
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: ParseFromOutsideSource

    PARAMETERS
        pcszUrlIn - String to parse.
        dwParseFlags - Flags to modify parsing. (Defined in iedev\inc\shlobj.w)
        pfWasCorrected - [out] if url was autocorrected (can be null)

    DESCRIPTION:
        Convert a string to a fully qualified shell url.  Parsing
    falls into one of the following categories:

    1. If the URL starts with "\\", check if it's a UNC Path.
    2. If the URL starts something that appears to indicate that it starts
       from the root of the shell name space (Desktop), then check if it
       is an absolute ShellUrl.
    (Only do #3 and #4 if #2 was false)
    3. Check if the string is relative to the Current Working Directory.
    4. Check if the string is relative to one of the items in the
       "Shell Path".
    5. Check if the string is in the system's AppPath or DOS Path.
    6. Check if this is a URL to Navigate to.  This call will pretty much
        always succeeded, because it will accept anything as an AutoSearch
        URL.
\****************************************************/
HRESULT CShellUrl::ParseFromOutsideSource(LPCTSTR pcszUrlIn, DWORD dwParseFlags, PBOOL pfWasCorrected, PBOOL pfWasCanceled)
{
    HRESULT hr = E_FAIL;  // E_FAIL means we don't know yet.
    TCHAR szUrlExpanded[MAX_URL_STRING];
    LPTSTR pszUrlInMod = (LPTSTR) szUrlExpanded; // For iteration only
    LPTSTR pszErrorURL = NULL;
    BOOL fPossibleWebUrl = FALSE;
    int nScheme;
    BOOL fDisable = SHRestricted(REST_NORUN);
    m_dwFlags = dwParseFlags;

    if (pfWasCorrected)
        *pfWasCorrected = FALSE;

    if (!pcszUrlIn[0])
        return E_FAIL;

    if (!StrCmpNIW(WZ_RADIO_PROTOCOL, pcszUrlIn, ARRAYSIZE(WZ_RADIO_PROTOCOL)-1))
    {
        // We need to reroute vnd.ms.radio: urls to the regular player, since we don't support the radio bar anymore.
        // (Media bar or the external player)
        StringCchCopy(szUrlExpanded,  SIZECHARS(szUrlExpanded), pcszUrlIn+ARRAYSIZE(WZ_RADIO_PROTOCOL)-1);
    }
    else
    {
        SHExpandEnvironmentStrings(pcszUrlIn, szUrlExpanded, SIZECHARS(szUrlExpanded));
    }

    PathRemoveBlanks(pszUrlInMod);

    Reset(); // Empty info because we will fill it in if successful or leave empty if we fail.
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: ParseFromOutsideSource() Begin. pszUrlInMod=%s", pszUrlInMod);
    // The display Name will be exactly what the user entered.
    Str_SetPtr(&m_pszDisplayName, pszUrlInMod);

    nScheme = GetUrlScheme(pszUrlInMod);
    if ((URL_SCHEME_FILE != nScheme) || !fDisable)  // Don't parse FILE: URLs if Start->Run is disabled.
    {
        // For HTTP and FTP we can make a few minor corrections
        if (IsFlagSet(dwParseFlags, SHURL_FLAGS_AUTOCORRECT) &&
            (URL_SCHEME_HTTP == nScheme || URL_SCHEME_FTP == nScheme || URL_SCHEME_HTTPS == nScheme))
        {
            if (S_OK == UrlFixupW(szUrlExpanded, szUrlExpanded, ARRAYSIZE(szUrlExpanded)) &&
                pfWasCorrected)
            {
                *pfWasCorrected = TRUE;
            }
        }

        hr = _TryQuickParse(szUrlExpanded, dwParseFlags);
        if (FAILED(hr))
        {
            // Does this string refer to something in the shell namespace that is
            // not a standard URL AND can we do shell namespace parsing AND
            // can we use advanced parsing on it?
            if (((URL_SCHEME_UNKNOWN == nScheme) ||
                 (URL_SCHEME_SHELL == nScheme) ||
                 (URL_SCHEME_INVALID == nScheme)) &&
                !(SHURL_FLAGS_NOSNS & dwParseFlags) && _CanUseAdvParsing())
            {
                fPossibleWebUrl = TRUE;

                // Yes; is this URL absolute (e.g., "\foo" or "Desktop\foo")?
                if (IS_SHELL_SEPARATOR(pszUrlInMod[0]) ||
                    (S_OK == StrCmpIWithRoot(pszUrlInMod, FALSE, &m_pstrRoot)))
                {
                    // Yes

                    // CASE #1.
                    // It starts with "\\", so it's probably a UNC,
                    // so _ParseUNC() will call _ParseRelativePidl() with the Network
                    // Neighborhood PIDL as the relative location.  This is needed
                    // because commands like this "\\bryanst2\public\program.exe Arg1 Arg2"
                    // that need to be shell executed.
                    if (PathIsUNC(pszUrlInMod))
                    {
                        hr = _ParseUNC(pszUrlInMod, &fPossibleWebUrl, dwParseFlags, FALSE);
                        // If we got this far, don't pass off to Navigation if _ParseUNC() failed.
                        fPossibleWebUrl = FALSE;
                    }

                    if (FAILED(hr))
                    {
                        if (IS_SHELL_SEPARATOR(pszUrlInMod[0]))
                        {
                            pszErrorURL = pszUrlInMod;  // We want to keep the '\' for the error message.
                            pszUrlInMod++;    // Skip past '\'.
                        }

                        // See if we need to advance past a "Desktop".
                        if (S_OK == StrCmpIWithRoot(pszUrlInMod, FALSE, &m_pstrRoot))
                        {
                            pszUrlInMod += lstrlen(m_pstrRoot);
                            if (IS_SHELL_SEPARATOR(pszUrlInMod[0]))
                                pszUrlInMod++;
                            if (!pszUrlInMod[0])
                            {
                                // The only thing the user entered was [...]"desktop"[\]
                                // so just clone the Root pidl.
                                return _SetPidl(&s_idlNULL);
                            }
                        }

                        // CASE #2.  Passing NULL indicates that it should test relative
                        //           to the root.
                        hr = _ParseRelativePidl(pszUrlInMod, &fPossibleWebUrl, dwParseFlags, NULL, FALSE, FALSE);
                    }
                }
                else
                {
                    // No; it is relative
                    int nPathCount = 0;
                    int nPathIndex;

                    if (m_hdpaPath)
                        nPathCount = DPA_GetPtrCount(m_hdpaPath);

                    // CASE #3.  Parse relative to the Current Working Directory.
                    //           Only valid if this object's ::SetCurrentWorkingDir()
                    //           method was called.
                    if (m_pidlWorkingDir)
                    {
                        hr = _ParseRelativePidl(pszUrlInMod, &fPossibleWebUrl, dwParseFlags, m_pidlWorkingDir, TRUE, TRUE);
    #ifdef FEATURE_WILDCARD_SUPPORT
                        if (FAILED(hr) && m_pidlWorkingDir &&
                            !StrChr(pszUrlInMod, CH_SEPARATOR) && !StrChr(pszUrlInMod, CH_FILESEPARATOR))
                        {
                            LPTSTR pszWildCard = StrChr(pszUrlInMod, CH_ASTRISK);
                            if (!pszWildCard)
                                pszWildCard = StrChr(pszUrlInMod, CH_QUESTIONMARK);

                            if (pszWildCard)
                            {
                                IOleWindow * pow;
                                m_pidlWorkingDir
                            }
                        }
    #endif // FEATURE_WILDCARD_SUPPORT

                        if (FAILED(hr))
                        {
                            //
                            // Check if the place we are navigating to is the same as the current
                            // working directory.  If so then there is a good chance that the user just
                            // pressed the enter key / go button in the addressbar and we should simply
                            // refresh the current directory.
                            //
                            WCHAR szCurrentDir[MAX_URL_STRING];
                            HRESULT hr2 = IEGetNameAndFlags(m_pidlWorkingDir, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szCurrentDir, ARRAYSIZE(szCurrentDir), NULL);
                            if (FAILED(hr2))
                            {
                                // Sometimes SHGDN_FORPARSING fails and the addressbar then tries SHGDN_NORMAL
                                hr2 = IEGetNameAndFlags(m_pidlWorkingDir, SHGDN_NORMAL | SHGDN_FORADDRESSBAR, szCurrentDir, ARRAYSIZE(szCurrentDir), NULL);
                            }
    
                            if (SUCCEEDED(hr2))
                            {
                                if (0 == StrCmpI(pszUrlInMod, szCurrentDir))
                                {
                                    // It matches so stay in the current working directory
                                    _SetPidl(m_pidlWorkingDir);
                                    hr = S_OK;
                                }
                            }

                        }
                    }
                    else
                    {
                        // TODO: Get the Current Working Directory of the top most window.
                        // hr = _ParseRelativePidl(pszUrlInMod, &fPossibleWebUrl, dwParseFlags, pshurlCWD, TRUE, TRUE);
                    }

                    // CASE #4.  Parse relative to the entries in the "Shell Path".
                    //           Only valid if this object's ::AddPath() method was
                    //           called at least once.
                    for (nPathIndex = 0; FAILED(hr) && nPathIndex < nPathCount; nPathIndex++)
                    {
                        LPITEMIDLIST pidlCurrPath = (LPITEMIDLIST) DPA_GetPtr(m_hdpaPath, nPathIndex);

                        if (EVAL(pidlCurrPath))
                        {
                            ASSERT(IS_VALID_PIDL(pidlCurrPath));
                            hr = _ParseRelativePidl(pszUrlInMod, &fPossibleWebUrl, dwParseFlags, pidlCurrPath, FALSE, FALSE);
                        }
                    }


                    // CASE #5.  We need to see if the beginning of the string matches
                    //           the entry in the AppPaths or DOS Path

                    if (FAILED(hr) && IsFlagClear(dwParseFlags, SHURL_FLAGS_NOPATHSEARCH))
                        hr = _QualifyFromPath(pszUrlInMod, dwParseFlags);
                }
            }
            else
            {
                if (URL_SCHEME_FILE != nScheme)
                    fPossibleWebUrl = TRUE;
            }
        }
    }

    if (FAILED(hr) && !fPossibleWebUrl && !fDisable)
    {
        // Did the caller want to suppress UI (Error Messages)
        if (IsFlagClear(dwParseFlags, SHURL_FLAGS_NOUI))
        {
            if(!(pfWasCanceled && *pfWasCanceled))
            {
                if (!pszErrorURL)
                    pszErrorURL = pszUrlInMod;
                ASSERT(pszErrorURL);

                // We were able to parse part of it, but failed parsing the second or
                // later segment.  This means we need to inform the user of their
                // misspelling.  They can force AutoSearch with "go xxx" or "? xxx"
                // if they are trying to AutoSearch something that appears in their
                // Shell Name Space.
                MLShellMessageBox(m_hwnd, MAKEINTRESOURCE(IDS_SHURL_ERR_PARSE_FAILED),
                    MAKEINTRESOURCE(IDS_SHURL_ERR_TITLE),
                    (MB_OK | MB_ICONERROR), pszErrorURL);
            }
        }
    }
    else if (S_OK != hr)
    {
        if (!(dwParseFlags & SHURL_FLAGS_NOWEB))
        {
            TCHAR szQualifiedUrl[MAX_URL_STRING];
            DWORD cchSize = SIZECHARS(szQualifiedUrl);

            SHExpandEnvironmentStrings(pcszUrlIn, szUrlExpanded, SIZECHARS(szUrlExpanded));
            PathRemoveBlanks(szUrlExpanded);

            // Unintialized szQualifiedUrl causes junk characters to appear on
            // addressbar.
            szQualifiedUrl[0] = TEXT('\0');

            // CASE #6. Just check if this is a URL to Navigate to.  This call will
            //          pretty much always succeeded, because it will accept
            //          anything as a search URL.
            if (IsFlagSet(dwParseFlags, SHURL_FLAGS_AUTOCORRECT))
            {
                hr = (_ParseURLFromOutsideSource(szUrlExpanded, szQualifiedUrl, &cchSize, NULL, pfWasCorrected) ? S_OK : E_FAIL);
            }
            else
            {
                hr = (ParseURLFromOutsideSource(szUrlExpanded, szQualifiedUrl, &cchSize, NULL) ? S_OK : E_FAIL);
            }
            if (SUCCEEDED(hr))
            {
                SetUrl(szQualifiedUrl, GENTYPE_FROMURL);
                Str_SetPtr(&m_pszDisplayName, szQualifiedUrl);    // The display Name will be exactly what the user entered.
            }

            ASSERT(!m_pidl);
            if (fDisable && SUCCEEDED(hr))
            {
                nScheme = GetUrlScheme(szQualifiedUrl);
                // We will allow all but the following schemes:
                if ((URL_SCHEME_SHELL != nScheme) &&
                    (URL_SCHEME_FILE != nScheme) &&
                    (URL_SCHEME_UNKNOWN != nScheme) &&
                    (URL_SCHEME_INVALID != nScheme))
                {
                    fDisable = FALSE;
                }
            }
        }
    }

    if (fDisable && ((URL_SCHEME_FILE == nScheme) || (URL_SCHEME_INVALID == nScheme) || (URL_SCHEME_UNKNOWN == nScheme))) 
    {
        if (IsFlagClear(dwParseFlags, SHURL_FLAGS_NOUI))
        {
            MLShellMessageBox(m_hwnd, MAKEINTRESOURCE(IDS_SHURL_ERR_PARSE_NOTALLOWED),
                MAKEINTRESOURCE(IDS_SHURL_ERR_TITLE),
                (MB_OK | MB_ICONERROR), pszUrlInMod);
        }
        hr = E_ACCESSDENIED;
        Reset(); // Just in case the caller ignores the return value.
    }

    return hr;
}


/****************************************************\
    FUNCTION: _QualifyFromPath

    PARAMETERS:
        pcszFilePathIn - String that may be in the Path.
        dwFlags - Parse Flags, not currently used.

    DESCRIPTION:
        This function will call _QualifyFromAppPath()
    to see if the item exists in the AppPaths.  If not,
    it will check in the DOS Path Env. variable with a
    call to _QualifyFromDOSPath().
\****************************************************/
HRESULT CShellUrl::_QualifyFromPath(LPCTSTR pcszFilePathIn, DWORD dwFlags)
{
    HRESULT hr = _QualifyFromAppPath(pcszFilePathIn, dwFlags);

    if (FAILED(hr))
        hr = _QualifyFromDOSPath(pcszFilePathIn, dwFlags);

    return hr;
}


/****************************************************\
    FUNCTION: _QualifyFromDOSPath

    PARAMETERS:
        pcszFilePathIn - String that may be in the Path.
        dwFlags - Parse Flags, not currently used.

    DESCRIPTION:
        See if pcszFilePathIn exists in the DOS Path Env
    variable.  If so, set the ShellUrl to that location.
\****************************************************/
HRESULT CShellUrl::_QualifyFromDOSPath(LPCTSTR pcszFilePathIn, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    TCHAR szPath[MAX_PATH];
    LPTSTR pszEnd = (LPTSTR) pcszFilePathIn;
    BOOL fContinue = TRUE;

    do
    {
        hr = _GetNextPossibleFullPath(pcszFilePathIn, &pszEnd, szPath, SIZECHARS(szPath), &fContinue);
        if (SUCCEEDED(hr))
        {
            if (PathFindOnPathEx(szPath, NULL, (PFOPEX_OPTIONAL | PFOPEX_COM | PFOPEX_BAT | PFOPEX_PIF | PFOPEX_EXE)))
            {
                _GeneratePidl(szPath, GENTYPE_FROMPATH);
                if (!ILIsFileSysFolder(m_pidl))
                {
                    Str_SetPtr(&m_pszArgs, pszEnd);        // Set aside Args
                    break;
                }
            }
            if (fContinue)
                pszEnd = CharNext(pszEnd);
            hr = E_FAIL;
        }
    }
    while (FAILED(hr) && fContinue);

    return hr;
}


/****************************************************\
    FUNCTION: _QualifyFromAppPath

    PARAMETERS:
        pcszFilePathIn - String that may be in the Path.
        dwFlags - Parse Flags, not currently used.

    DESCRIPTION:
        See if pcszFilePathIn exists in the AppPaths
    Registry Section.  If so, set the ShellUrl to that location.
\****************************************************/
HRESULT CShellUrl::_QualifyFromAppPath(LPCTSTR pcszFilePathIn, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    TCHAR szFileName[MAX_PATH];
    TCHAR szRegKey[MAX_PATH];
    DWORD dwType;
    DWORD cbData = sizeof(szFileName);
    DWORD cchNewPathSize;

    StringCchCopy(szFileName,  SIZECHARS(szFileName), pcszFilePathIn);
    PathRemoveArgs(szFileName);     // Get Rid of Args (Will be added later)
    cchNewPathSize = lstrlen(szFileName);   // Get size so we known where to find args in pcszFilePathIn
    PathAddExtension(szFileName, TEXT(".exe")); // Add extension if needed.

    StringCchPrintf(szRegKey, ARRAYSIZE(szRegKey), TEXT("%s\\%s"), STR_REGKEY_APPPATH, szFileName);
    if (NOERROR == SHGetValue(HKEY_LOCAL_MACHINE, szRegKey, TEXT(""), &dwType, (LPVOID) szFileName, &cbData))
    {
        // 1. Create Pidl from String.
        hr = _GeneratePidl(szFileName, GENTYPE_FROMPATH);

        // 2. Set aside Args
        ASSERT((DWORD)lstrlen(pcszFilePathIn) >= cchNewPathSize);
        Str_SetPtr(&m_pszArgs, &(pcszFilePathIn[cchNewPathSize]));
    }

    return hr;
}


/****************************************************\
    FUNCTION: _ParseUNC

    PARAMETERS:
        pcszUrlIn - URL, which can be a UNC path.
        pfPossibleWebUrl - Set to FALSE if we find that the user has attempted
                           to enter a Shell Url or File url but misspelled one
                           of the segments.
        dwFlags - Parse Flags
        fQualifyDispName - If TRUE when we known that we need to force the
                           URL to be fully qualified if we bind to the destination.
                           This is needed because we are using state information to
                           find the destination URL and that state information won't
                           be available later.

    DESCRIPTION:
        See if the URL passed in is a valid path
    relative to "SHELL:Desktop/Network Neighborhood".
\****************************************************/
HRESULT CShellUrl::_ParseUNC(LPCTSTR pcszUrlIn, BOOL * pfPossibleWebUrl, DWORD dwFlags, BOOL fQualifyDispName)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlNN = NULL;

    SHGetSpecialFolderLocation(NULL, CSIDL_NETWORK, &pidlNN);  // Get Pidl for "Network Neighborhood"
    if (pidlNN)
    {
        hr = _ParseRelativePidl(pcszUrlIn, pfPossibleWebUrl, dwFlags, pidlNN, FALSE, fQualifyDispName);
        ILFree(pidlNN);
    }

    return hr;
}


/****************************************************\
    FUNCTION: _ParseSeparator

    PARAMETERS:
        pidl - PIDL to ISF that has been parsed so far.
        pcszSeg - Str of rest of Url to parse.
        pfPossibleWebUrl - Set to FALSE if we know that the user attempted
                           but failed to enter a correct Shell Url.
        fQualifyDispName - If TRUE when we known that we need to force the
                           URL to be fully qualified if we bind to the
                           destination. This is needed because we are using
                           state information to find the destination URL and
                           that state information won't be available later.

    DESCRIPTION:
        This function is called after at least one
    segment in the SHELL URL has bound to a valid
    Shell Item/Folder (i.e., ITEMID).  It is called
    each time a segment in the Shell Url binds to a PIDL.
    It will then evaluate the rest of the string and
    determine if:
        1. The URL has been completely parsed
            and is valid.  This will include getting
            the command line arguments if appropriate.
        2. More segments in the URL exist and ::_ParseNextSegment()
           needs to be called to continue the recursive parsing
           of the URL.
        3. The rest of the URL indicates that it's an invalid url.

   This function is always called by ::_ParseNextSegment() and basically
   decides if it wants to continue the recursion by calling back into
   ::_ParseNextSegment() or not.  Recursion is used because it's necessary
   to back out of parsing something and go down a path if we received
   a false positive.
\****************************************************/
HRESULT CShellUrl::_ParseSeparator(LPCITEMIDLIST pidl, LPCTSTR pcszSeg, BOOL * pfPossibleWebUrl, BOOL fAllowRelative, BOOL fQualifyDispName)
{
    HRESULT hr = S_OK;
    BOOL fIgnoreArgs = FALSE;

    ASSERT(pidl && IS_VALID_PIDL(pidl));

    // Does anything follow this separator?
    if ((CH_FRAGMENT == pcszSeg[0]) || (IS_SHELL_SEPARATOR(pcszSeg[0]) && pcszSeg[1]))
    {
        // Yes, continue parsing recursively.

        // Do we need to skip the '/' or '\' separator?
        if (CH_FRAGMENT != pcszSeg[0])
            pcszSeg++;      // Skip separator

        hr = _ParseNextSegment(pidl, pcszSeg, pfPossibleWebUrl, fAllowRelative, fQualifyDispName);
        DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
        TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _ParseSeparator() Current Level pidl=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

        if (FAILED(hr) && pfPossibleWebUrl)
        {
            *pfPossibleWebUrl = FALSE;
            // We bound to at least one level when parsing, so don't do a web search because
            // of a failure.
        }
    }
    else
    {
        // No, we will see if we have reached a valid Shell Item.

        // Is the remaining string args?
        if (CH_SPACE == pcszSeg[0])
        {
            // If there are still chars left in the string, we need to
            // verify the first one is a space to indicate Command line args.
            // Also, we need to make sure the PIDL isn't browsable because browsable
            // Shell folders/items don't take Cmd Line Args.

            if (ILIsBrowsable(pidl, NULL))
            {
                // No
                //
                // The remaining chars cannot be Command Line Args if the PIDL
                // doesn't point to something that is shell executable.  This
                // case actually happens often.
                // Example: (\\bryanst\... and \\bryanst2\.. both exist and
                //          user enters \\bryanst2\... but parsing attempts
                //          to use \\bryanst because it was found first.  This
                //          will cause recursion to crawl back up the stack and try \\bryanst2.
                hr = E_FAIL;
            }
        }
        else if (pcszSeg[0])
        {
            // No
            // The only time we allow a char after a folder segment is if it is a Shell Separator
            // Example: "E:\dir1\"

            if (IS_SHELL_SEPARATOR(*pcszSeg) && 0 == pcszSeg[1])
                fIgnoreArgs = TRUE;
            else
                hr = E_FAIL;    // Invalid because there is more to be parsed.
        }

        if (SUCCEEDED(hr))
        {
            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
            TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _ParseSeparator() Parsing Finished.  pidl=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
            _SetPidl(pidl);

            if (!fIgnoreArgs && pcszSeg[0])
                Str_SetPtr(&m_pszArgs, pcszSeg);

            if (fQualifyDispName)
                _GenDispNameFromPidl(pidl, pcszSeg);
        }
    }

    return hr;
}


//
// Returns TRUE is the pidl is a network server
//
BOOL _IsNetworkServer(LPCITEMIDLIST pidl)
{
    BOOL fRet = FALSE;

    // First see if this is a network pidl
    if (IsSpecialFolderChild(pidl, CSIDL_NETWORK, FALSE))
    {
        // See if it ends in a share name
        WCHAR szUrl[MAX_URL_STRING];
        HRESULT hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), NULL);
        if (FAILED(hr))
        {
            // On non-integrated browsers SHGDN_FORPARSING may fail so try
            // again without this flag.  The preceeding back slashes will be
            // missing so we add them ourselves
            szUrl[0] = CH_FILESEPARATOR;
            szUrl[1] = CH_FILESEPARATOR;
            hr = IEGetNameAndFlags(pidl, SHGDN_NORMAL | SHGDN_FORADDRESSBAR, szUrl+2, ARRAYSIZE(szUrl)-2, NULL);
        }

        fRet = SUCCEEDED(hr) && PathIsUNCServer(szUrl);
    }
    return fRet;
}


/****************************************************\
    FUNCTION: _ParseNextSegment

    PARAMETERS:
        pidlParent - Fully Qualified PIDL to ISF to find next ITEMID in pcszStrToParse.
        pcszStrToParse - pcszStrToParse will begin with either
                      a valid display name of a child ITEMID of pidlParent
                      or the Shell URL is invalid relative to pidlParent.
        fAllowRelative - Should relative moves be allowed?
        fQualifyDispName - If TRUE when we known that we need to force the
                           URL to be fully qualified if we bind to the destination.
                           This is needed because we are using state information to
                           find the destination URL and that state information won't
                           be available later.

    DESCRIPTION/PERF:
        This function exists to take the string (pcszStrToParse)
    passed in and attempt to bind to a ITEMID which
    has a DisplayName that matches the beginning of
    pcszStrToParse.  This function will check all the
    ITEMIDs under the pidlParent section of the Shell
    Name Space.

      The only two exceptions to the above method is if
    1) the string begins with "..", in which case, we
       bind to the pidlParent's Parent ITEMID. - or -
    2) The pidlParent passes the ::_IsFilePidl()
       test and we are guaranteed the item is in the
       File System or a UNC item.  This will allow us
       to call IShellFolder::ParseDisplayName() to
       find the child ITEMID of pidlParent.

    This function will iterate through the items under
    pidlParent instead of call IShellFolder::ParseDisplayName
    for two reasons: 1) The ::ParseDisplayName for "The Internet"
    will accept any string because of AutoSearch, and
    2) We never know the location of the end of one segment and
    the beginning of the next segment in pcszStrToParse.  This is
    because DisplayNames for ISFs can contain almost any character.

    If this function has successfully bind to a child ITEMID
    of pidlParent, it will call ::_ParseSeparator() with the
    rest of pcszStrToParse to parse.  _ParseSeparator() will determine
    if the end of the URL has been parsed or call back into this function
    recursively to continue parsing segments.  In the former case,
    _ParseSeparator() will set this object's PIDL and arguments which
    can be used later.  In the latter case, the recursion stack will
    unwind and my take a different path (Cases exists that require this).
\****************************************************/
HRESULT CShellUrl::_ParseNextSegment(LPCITEMIDLIST pidlParent,
            LPCTSTR pcszStrToParse, BOOL * pfPossibleWebUrl,
            BOOL fAllowRelative, BOOL fQualifyDispName)
{
    HRESULT hr = E_FAIL;

    if (!pidlParent || !pcszStrToParse)
        return E_INVALIDARG;

    // Is this ".."?
    if (fAllowRelative && CH_DOT == pcszStrToParse[0] && CH_DOT == pcszStrToParse[1])
    {
        // Yes
        LPITEMIDLIST pidl = ILClone(pidlParent);
        if (pidl && !ILIsEmpty(pidl))
        {
            ILRemoveLastID(pidl);  // pidl/psfFolder now point to the new shell item, which is the parent in this case.
            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
            TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _ParseNextSegment() Nav '..'. PIDL=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

            // Parse the next segment or finish up if we reached the end
            // (we're skipping the ".." here)
            hr = _ParseSeparator(pidl, &(pcszStrToParse[2]), pfPossibleWebUrl, fAllowRelative, fQualifyDispName);
            ILFree(pidl);
        }
    }
    else
    {
        // No
        LPTSTR pszNext = NULL; // Remove const because we will iterate only.
        long i = 0;

        // Can we parse this display name quickly?
        if (!ILIsRooted(pidlParent) && _IsFilePidl(pidlParent) &&
            
            // Quick way fails for shares right off of the network server
            !_IsNetworkServer(pidlParent))
        {       
            // Yes
            TCHAR szParseChunk[MAX_PATH+1];

            do
            {
                ++i;

                hr = _GetNextPossibleSegment(pcszStrToParse, &pszNext, szParseChunk, SIZECHARS(szParseChunk), TRUE);
                if (S_OK == hr)
                {
                    hr = _QuickParse(pidlParent, szParseChunk, pszNext, pfPossibleWebUrl, fAllowRelative, fQualifyDispName);

                    //
                    // Certain network shares like \\foo\Printers and "\\foo\Scheduled Tasks" will fail the if we
                    // combine the server and share in a segment.  So we try parsing the server separately.
                    //
                    if ((S_OK != hr) && (i == 1) && PathIsUNCServerShare(szParseChunk))
                    {
                        pszNext = NULL;
                        hr = _GetNextPossibleSegment(pcszStrToParse, &pszNext, szParseChunk, SIZECHARS(szParseChunk), FALSE);
                        if (S_OK == hr)
                        {
                            hr = _QuickParse(pidlParent, szParseChunk, pszNext, pfPossibleWebUrl, fAllowRelative, fQualifyDispName);
                        }
                    }

#ifdef FEATURE_SUPPORT_FRAGS_INFILEURLS
                    // Did we fail to parse the traditional way and the first char of this
                    // next chunk indicates it's probably a URL Fragment?
                    if (FAILED(hr) && (CH_FRAGMENT == pcszStrToParse[0]))
                    {
                        TCHAR szUrl[MAX_URL_STRING];
                        // Yes, so try parsing in another way that will work
                        // with URL fragments.

                        hr = ::IEGetDisplayName(pidlParent, szUrl, SHGDN_FORPARSING);
                        if (EVAL(SUCCEEDED(hr)))
                        {
                            TCHAR szFullUrl[MAX_URL_STRING];
                            DWORD cchFullUrlSize = ARRAYSIZE(szFullUrl);

                            hr = UrlCombine(szUrl, szParseChunk, szFullUrl, &cchFullUrlSize, 0);
                            if (EVAL(SUCCEEDED(hr)))
                            {
                                LPITEMIDLIST pidl = NULL;

                                hr = IEParseDisplayName(CP_ACP, szFullUrl, &pidl);
                                if (SUCCEEDED(hr))
                                {
                                    _SetPidl(pidl);

                                    if (fQualifyDispName)
                                        _GenDispNameFromPidl(pidl, szFullUrl);

                                    ILFree(pidl);
                                }
                                else
                                    ASSERT(!pidl);  // Verify IEParseDisplayName() didn't fail but return a pidl.
                            }
                        }
                    }
#endif // FEATURE_SUPPORT_FRAGS_INFILEURLS
                }
            }
            while (FAILED(hr));

            if (S_OK != hr)
                hr = E_FAIL;    // Not Found
        }
        else if (FAILED(hr))
        {
            // No; use the slow method
            IShellFolder * psfFolder = NULL;

            DWORD dwAttrib = SFGAO_FOLDER;
            IEGetAttributesOf(pidlParent, &dwAttrib);

            if (IsFlagSet(dwAttrib, SFGAO_FOLDER))
            {
                IEBindToObject(pidlParent, &psfFolder);
                ASSERT(psfFolder);
            }

            if (psfFolder)
            {
                LPENUMIDLIST penumIDList = NULL;
                HWND hwnd = _GetWindow();

                // Is this an FTP Pidl?
                if (IsFTPFolder(psfFolder))
                {
                    // NT #274795: Yes so, we need to NULL out the hwnd to prevent
                    // displaying UI because enumerator of that folder may need to display
                    // UI (to collect passwords, etc.).  This is not valid because pcszStrToParse
                    // may be an absolute path and psfFolder points to the current location which
                    // isn't valid.  This should probaby be done for all IShellFolder::EnumObjects()
                    // calls, but it's too risky right before ship.
                    hwnd = NULL;
                }

                // Warning Docfind returns S_FALSE to indicate no enumerator and returns NULL..
                if (S_OK == IShellFolder_EnumObjects(psfFolder, hwnd, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN, &penumIDList))
                {
                    LPITEMIDLIST pidlRelative;   // NOT a FULLY Qualified Pidl
                    LPITEMIDLIST pidlResult; // PIDL after it has been made Fully Qualified
                    ULONG cFetched;
                    LPTSTR pszRemaining = NULL;

                    while (FAILED(hr) && NOERROR == penumIDList->Next(1, &pidlRelative, &cFetched) && cFetched)
                    {
                        // The user will have entered the name in one of the three formats and they need to be
                        // checked from the longest string to the smallest.  This is necessary because the
                        // parser will check to see if the item's DisplayName is the first part of the user
                        // string.
                        //
                        // #1. (FORPARSING): This will be the full name.
                        //     Example: razzle.lnk on desktop = D:\nt\public\tools\razzle.lnk.
                        // #2. (FORPARSING | SHGDN_INFOLDER): This will be only the full name w/Extension.
                        //     Example: razzle.lnk on desktop = razzle.lnk
                        // #3. (SHGDN_INFOLDER): This will be the full name w/o extension if "Hide File Extensions for Known File Types" is on.
                        //     Example: razzle.lnk on desktop = D:\nt\public\tools\razzle.lnk.
                        // The user may have entered the "SHGDN_FORPARSING" Display Name or the "SHGDN_INFOLDER", so we need
                        // to check both.
                        hr = _CheckItem(psfFolder, pidlParent, pidlRelative, &pidlResult, pcszStrToParse, &pszRemaining, SHGDN_FORPARSING);
                        if (FAILED(hr))     // Used for file items w/extensions. (Like razzle.lnk on the Desktop)
                            hr = _CheckItem(psfFolder, pidlParent, pidlRelative, &pidlResult, pcszStrToParse, &pszRemaining, SHGDN_FORPARSING | SHGDN_INFOLDER);
                        if (FAILED(hr))
                            hr = _CheckItem(psfFolder, pidlParent, pidlRelative, &pidlResult, pcszStrToParse, &pszRemaining, SHGDN_INFOLDER);

                        if (SUCCEEDED(hr))
                        {
                            // See if the Display Name for a Drive ate the separator for the next segment.
                            if (_FixDriveDisplayName(pcszStrToParse, pszRemaining, pidlResult))
                            {
                                // FIX: "E:\dir1\dir2".  We expent display names to not claim the '\' separator between
                                //                       names.  The problem is that drive letters claim to be "E:\" instead
                                //                       of "E:".  So, we need to back up so we use the '\' as a separator.
                                pszRemaining--;
                            }

                            // Our root is equal to a separator.
                            ASSERT(pcszStrToParse != pszRemaining);

                            // Parse the next segment or finish up if we reached the end.
                            hr = _ParseSeparator(pidlResult, pszRemaining, pfPossibleWebUrl, fAllowRelative, fQualifyDispName);

                            if (pidlResult)
                                ILFree(pidlResult);
                        }

                        ILFree(pidlRelative);
                    }
                    penumIDList->Release();
                }
                psfFolder->Release();
            }
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: _GetNextPossibleSegment

    PARAMETERS:
        pcszFullPath - Full Path
        ppszSegIterator - Pointer to iterator to maintain state.
                          WARNING: This needs to be NULL on first call.
        pszSegOut - Of S_OK is returned, this will contain the next possible segment
        cchSegOutSize - char Size of pszSegOut buffer

    DESCRIPTION:
        Generate the next possible segment that can
    be parsed.  If "one two three/four five" is passed
    in, this function will return S_OK three times
    with these values in pszSegOut:
    1) "one two three",
    2) "one two", and
    3) "one".

    In this example, S_OK will be returned for the first
    three calls, and S_FALSE will be returned for the
    fourth to indicate that no more possible segments can be obtained
    from that string.
\****************************************************/
HRESULT CShellUrl::_GetNextPossibleSegment(LPCTSTR pcszFullPath,
        LPTSTR * ppszSegIterator, LPTSTR pszSegOut, DWORD cchSegOutSize, BOOL fSkipShare)
{
    HRESULT hr = S_OK;
    LPTSTR szStart = (LPTSTR) pcszFullPath;

    // We need to treat UNCs Specially.
    if (PathIsUNC(szStart))
    {
        LPTSTR szUNCShare;
        // This is a UNC so we need to make the "Segment" include
        // the "\\server\share" because Network Neighborhood's
        // IShellFolder::ParseDisplayName() is increadibly slow
        // and makes mistakes when it parses "server" and then "share"
        // separately.

        // This if clause will advance szStart past the Server
        // section of the UNC path so the rest of the algorithm will
        // naturally continue working on the share section of the UNC.
        szStart += 2;   // Skip past the "\\" UNC header.

        // Is there a share?
        if (fSkipShare && (szUNCShare = StrChr(szStart, CH_FILESEPARATOR)))
        {
            // Yes, so advanced to the first char in the share
            // name so the algorithm below works correctly.
            szStart = szUNCShare + 1;
        }
    }

    // Do we need to initialize the iterator?  If so, set it to the
    // largest possible segment in the string because we will be
    // working backwards.
    ASSERT(ppszSegIterator);
    if (*ppszSegIterator)
    {
        *ppszSegIterator = StrRChr(szStart, *ppszSegIterator, CH_SPACE);
        if (!*ppszSegIterator)
        {
            pszSegOut[0] = TEXT('\0');  // Make sure caller doesn't ignore return and recurse infinitely.
            return S_FALSE;
        }
    }
    else
    {
        // We have not yet started the iteration, so set the ppszSegIterator to the end of the possible
        // segment.  This will be a segment separator character ('\' || '/') or the end of the string
        // if either of those don't exist.  This will be the first segment to try.

        *ppszSegIterator = StrChr(szStart, CH_FILESEPARATOR);
        if (!*ppszSegIterator)
            *ppszSegIterator = StrChr(szStart, CH_SEPARATOR);

        LPTSTR pszFrag = StrChr(szStart, CH_FRAGMENT);
        // Is the next separator a fragment?
        if (pszFrag && (!*ppszSegIterator || (pszFrag < *ppszSegIterator)))
        {
            TCHAR szFile[MAX_URL_STRING];

            StringCchCopy(szFile, (int)(pszFrag - szStart + 1), szStart);
            if (PathIsHTMLFile(szFile))
                *ppszSegIterator = pszFrag;
        }

        if (!*ppszSegIterator)
        {
            // Go to end of the string because this is the last seg.
            *ppszSegIterator = (LPTSTR) &((szStart)[lstrlen(szStart)]);
        }
    }

    // Fill the pszSegOut parameter.
    ASSERT(*ppszSegIterator);

    // This is weird but correct.  pszEnd - pszBeginning results count of chars, not
    // count of bytes.
    if (cchSegOutSize >= (DWORD)((*ppszSegIterator - pcszFullPath) + 1))
        StringCchCopy(pszSegOut,  (int)(*ppszSegIterator - pcszFullPath + 1), pcszFullPath);
    else
        StringCchCopy(pszSegOut, cchSegOutSize - 1, pcszFullPath);

    return hr;
}


/****************************************************\
    FUNCTION: _GetNextPossibleFullPath

    DESCRIPTION:
        This function will attempt to see if strParseChunk
    is a Parsible DisplayName under pidlParent.
\****************************************************/
HRESULT CShellUrl::_GetNextPossibleFullPath(LPCTSTR pcszFullPath,
    LPTSTR * ppszSegIterator, LPTSTR pszSegOut, DWORD cchSegOutSize,
    BOOL * pfContinue)
{
    HRESULT hr = S_OK;
    LPTSTR pszNext = StrChr(*ppszSegIterator, CH_SPACE);
    DWORD cchAmountToCopy = cchSegOutSize;

    if (TEXT('\0') == (*ppszSegIterator)[0])
    {
        if (pfContinue)
            *pfContinue = FALSE;
        return E_FAIL;  // Nothing Left.
    }

    if (!pszNext)
        pszNext = &((*ppszSegIterator)[lstrlen(*ppszSegIterator)]);   // Go to end of the string because this is the last seg.

    // Copy as much of the string as we have room for.
    // The compiler will take care of adding '/ sizeof(TCHAR)'.
    if ((cchAmountToCopy-1) > (DWORD)(pszNext - pcszFullPath + 1))
        cchAmountToCopy = (int)(pszNext - pcszFullPath + 1);

    StringCchCopy(pszSegOut,  cchAmountToCopy, pcszFullPath);

    if (CH_SPACE == pszNext[0])
    {
        *pfContinue = TRUE;
    }
    else
        *pfContinue = FALSE;

    *ppszSegIterator = pszNext;
    return hr;
}


/****************************************************\
    FUNCTION: _QuickParse

    PARAMETERS:
        pidlParent - Pidl to ISF to parse from.
        pszParseChunk - Display Name of item in pidlParent.
        pszNext - Rest of string to parse if we succeed at parsing pszParseChunk.
        pfPossibleWebUrl - Set to FALSE if we find that the user has attempted to enter
                           a Shell Url or File url but misspelled one of the segments.
        fAllowRelative - Allow relative parsing. ("..")
        fQualifyDispName - If TRUE when we known that we need to force the
                           URL to be fully qualified if we bind to the destination.
                           This is needed because we are using state information to
                           find the destination URL and that state information won't
                           be available later.

    DESCRIPTION:
        This function will attempt to see if strParseChunk
    is a Parsible DisplayName under pidlParent.
\****************************************************/
HRESULT CShellUrl::_QuickParse(LPCITEMIDLIST pidlParent, LPTSTR pszParseChunk,
    LPTSTR pszNext, BOOL * pfPossibleWebUrl, BOOL fAllowRelative,
    BOOL fQualifyDispName)
{
    HRESULT hr;
    IShellFolder * psfFolder;

    hr = IEBindToObject(pidlParent, &psfFolder);
    if (SUCCEEDED(hr))
    {
        ULONG ulEatten; // Not used.
        SHSTRW strParseChunkThunked;

        hr = strParseChunkThunked.SetStr(pszParseChunk);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl = NULL;

            // TODO: In the future, we may want to cycle through commonly used extensions in case the
            //       user doesn't add them.
            hr = psfFolder->ParseDisplayName(_GetWindow(), NULL, strParseChunkThunked.GetInplaceStr(), &ulEatten, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                // IShellFolder::ParseDisplayName() only generates PIDLs that are relative to the ISF.  We need
                // to make them Absolute.
                LPITEMIDLIST pidlFull = ILCombine(pidlParent, pidl);

                if (pidlFull)
                {
                    // Parse the next segment or finish up if we reached the end.
                    hr = _ParseSeparator(pidlFull, pszNext, pfPossibleWebUrl, fAllowRelative, fQualifyDispName);
                    ILFree(pidlFull);
                }
                ILFree(pidl);
            }
        }
        psfFolder->Release();
    }

    return hr;
}


/****************************************************\
    FUNCTION: _CheckItem

    DESCRIPTION:
        This function will obtain the Display Name
    of the ITEMID (pidlRelative) which is a child of
    psfFolder.  If it's Display Name matches the first
    part of pcszStrToParse, we will return successful
    and set ppszRemaining to the section of pcszStrToParse
    after the segment just parsed.

    This function will also see if the Display Name ends
    in something that would indicate it's executable.
    (.EXE, .BAT, .COM, ...).  If so, we will match if
    pcszStrToParse matches the Display Name without the
    Extension.
\****************************************************/
HRESULT CShellUrl::_CheckItem(IShellFolder * psfFolder,
    LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlRelative,
    LPITEMIDLIST * ppidlChild, LPCTSTR pcszStrToParse,
    LPTSTR * ppszRemaining, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;

    *ppidlChild = NULL;

    TCHAR szISFName[MAX_URL_STRING];
    if (SUCCEEDED(DisplayNameOf(psfFolder, pidlRelative, dwFlags, szISFName, SIZECHARS(szISFName))))
    {
        DWORD  cchISFLen     = lstrlen(szISFName);
        DWORD  cchStrToParse = lstrlen(pcszStrToParse);
        BOOL   fEqual = FALSE;

        // Either the item needs to match exactly, or it needs to do a partial match
        // if the Shell Object is an executable file.  For Example: "msdev" should match the
        // "msdev.exe" file object.
        if (cchISFLen > 0)
        {
            // We want to see if pcszStrToParse is a match to the first part of szISFName.

            // First we will try to see if it's a direct match.
            // Example: User="file.exe" Shell Item="file.exe"
            // But we DON'T want to match if the StrToParse is longer than
            // ISFName, unless the next char in StrToParse is a separator.
            // If StrToParse is shorter than ISFName, then it can't be an exact match.
            if (cchStrToParse >= cchISFLen &&
                0 == StrCmpNI(szISFName, pcszStrToParse, cchISFLen) &&
                (cchStrToParse == cchISFLen || IS_SHELL_SEPARATOR(pcszStrToParse[cchISFLen])))
            {
                fEqual = TRUE;
            }
            else
            {
                int cchRoot = (int)((PathFindExtension(szISFName)-szISFName));
                // If that failed, we try to see if the Shell Item is
                // executable (.EXE, .COM, .BAT, .CMD, ...) and if so,
                // we will see if pcszStrToParse matches Shell Item w/o the file
                // extension.

                // REARCHITECT this will match if there happens to be a space in the user's
                //  filename that doesn't denote commandline arguments.
                //  Example: User="foo file.doc" Shell Item="foo.exe"

                if (PathIsExe(szISFName) &&                         // shell object is executable
                    (!((dwFlags & SHGDN_INFOLDER) && !(dwFlags & SHGDN_FORPARSING))) && // we didn't strip extension
                    ((lstrlen(pcszStrToParse) >= cchRoot) &&        // and user entered at least root chars
                     ((pcszStrToParse[cchRoot] == TEXT('\0')) ||    // and user entered exact root
                      (pcszStrToParse[cchRoot] == TEXT(' ')))) &&   //     or possible commandline args
                    (0 == StrCmpNI(szISFName, pcszStrToParse, cchRoot)))    // and the root matches
                {
                    // This wasn't a direct match, but we found that the segment entered
                    // by the user (pcszStrToParse) matched

                    // We found that the ISF item is an executable object and the
                    // string matched w/o the extension.
                    fEqual = TRUE;
                    cchISFLen = cchRoot;        // So that we generate *ppszRemaining correctly
                }
            }
        }

        if (fEqual)
        {
            hr = S_OK;    // We were able to navigate to this shell item token.
            *ppszRemaining = (LPTSTR) &(pcszStrToParse[cchISFLen]); // We will only iterate over the string, so it's ok that we loose the const.
            *ppidlChild = ILCombine(pidlParent, pidlRelative);
            TraceMsg(TF_CHECKITEM, "ShellUrl: _CheckItem() PIDL=>%s< IS EQUAL TO StrIn=>%s<", pcszStrToParse, szISFName);
        }
        else
            TraceMsg(TF_CHECKITEM, "ShellUrl: _CheckItem() PIDL=>%s< not equal to StrIn=>%s<", pcszStrToParse, szISFName);
    }

    return hr;
}


/****************************************************\
    FUNCTION: _IsFilePidl

    PARAMETERS:
        pidl (IN) - Pidl to check if it is a File Pidl

    DESCRIPTION:
        The PIDL is a file pidl if:
    1. The pidl equals "Network Neighborhood" or descendent
    2. The pidl's grandparent or farther removed from "My Computer".

    This algorithm only allows "Network Neighborhood" because
    that ISF contains a huge number of PIDLs and takes for ever
    to enumerate.  The second clause will work in any part of the
    file system except for the root drive (A:\, C:\).  This is
    because we need to allow other direct children of "My Computer"
    to use the other parsing.
\****************************************************/
BOOL CShellUrl::_IsFilePidl(LPCITEMIDLIST pidl)
{
    BOOL fResult = FALSE;
    BOOL fNeedToSkip = FALSE;

    if (!pidl || ILIsEmpty(pidl))
        return fResult;

    // Test for Network Neighborhood because it will take forever to enum.
    fResult = IsSpecialFolderChild(pidl, CSIDL_NETWORK, FALSE);

    if (!fResult)
    {
        // We only want to do this if we are not the immediate
        // child.
        if (IsSpecialFolderChild(pidl, CSIDL_DRIVES, FALSE))
        {
            TCHAR szActualPath[MAX_URL_STRING];        // IEGetDisplayName() needs the buffer to be this large.
            IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szActualPath, SIZECHARS(szActualPath), NULL);

            DWORD dwOutSize = MAX_URL_STRING;
            if (SUCCEEDED(PathCreateFromUrl(szActualPath, szActualPath, &dwOutSize, 0)))
            {
                PathStripToRoot(szActualPath);
                fResult = PathIsRoot(szActualPath);
            }
        }
    }

    return fResult;
}



/****************************************************\
    FUNCTION: IsWebUrl

    PARAMETERS
         none.

    DESCRIPTION:
         Return TRUE if the URL is a Web Url (http,
    ftp, other, ...).  Return FALSE if it's a Shell Url
    or File Url.
\****************************************************/
BOOL CShellUrl::IsWebUrl(void)
{
    if (m_pidl)
    {
        if (!IsURLChild(m_pidl, TRUE))
            return FALSE;
    }
    else
    {
        ASSERT(m_pszURL);   // This CShellUrl hasn't been set.
        if (m_pszURL && IsShellUrl(m_pszURL, TRUE))
            return FALSE;
    }

    return TRUE;
}


/****************************************************\
    FUNCTION: SetCurrentWorkingDir

    PARAMETERS
         pShellUrlNew - Pointer to a CShellUrl that will
                        be the "Current Working Directory"

    DESCRIPTION:
         This Shell Url will have a new current working
    directory, which will be the CShellUrl passed in.

    MEMORY ALLOCATION:
         The caller needs to Allocate pShellUrlNew and
    this object will take care of freeing it.  WARNING:
    this means it cannot be on the stack.
\****************************************************/
HRESULT CShellUrl::SetCurrentWorkingDir(LPCITEMIDLIST pidlCWD)
{
    Pidl_Set(&m_pidlWorkingDir, pidlCWD);

    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: SetCurrentWorkingDir() pidl=>%s<", Dbg_PidlStr(m_pidlWorkingDir, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    return S_OK;
}


/****************************************************\
    PARAMETERS
         pvPidl1 - First pidl to compare
         pvPidl2 - Second pidl to compare

    DESCRIPTION:
         Return if the pidl matches.  This doesn't work
    for sorted lists (because we can't determine less
    than or greater than).
\****************************************************/
int DPAPidlCompare(LPVOID pvPidl1, LPVOID pvPidl2, LPARAM lParam)
{
    // return < 0 for pvPidl1 before pvPidl2.
    // return == 0 for pvPidl1 equals pvPidl2.
    // return > 0 for pvPidl1 after pvPidl2.
    return (ILIsEqual((LPCITEMIDLIST)pvPidl1, (LPCITEMIDLIST)pvPidl2) ? 0 : 1);
}


/****************************************************\
    PARAMETERS
         pShellUrlNew - Pointer to a CShellUrl that will
                        be added to the "Shell Path"

    DESCRIPTION:
         This Shell Url will have the ShellUrl that's
    passed in added to the "Shell Path", which will be
    searched when trying to qualify the Shell Url during
    parsing.

    MEMORY ALLOCATION:
         The caller needs to Allocate pShellUrlNew and
    this object will take care of freeing it.  WARNING:
    this means it cannot be on the stack.
\****************************************************/
HRESULT CShellUrl::AddPath(LPCITEMIDLIST pidl)
{
    ASSERT(IS_VALID_PIDL(pidl));

    //  we dont want to add any paths that arent derived from
    //  our root.
    if (ILIsRooted(m_pidlWorkingDir) && !ILIsParent(m_pidlWorkingDir, pidl, FALSE))
        return S_FALSE;

    if (!m_hdpaPath)
    {
        m_hdpaPath = DPA_Create(CE_PATHGROW);
        if (!m_hdpaPath)
            return E_OUTOFMEMORY;
    }

    // Does the path already exist in our list?
    if (-1 == DPA_Search(m_hdpaPath, (void *)pidl, 0, DPAPidlCompare, NULL, 0))
    {
        // No, so let's add it.
        LPITEMIDLIST pidlNew = ILClone(pidl);
        if (pidlNew)
            DPA_AppendPtr(m_hdpaPath, pidlNew);
    }

    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: AddPath() pidl=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    return S_OK;
}


/****************************************************\
    FUNCTION: Reset

    PARAMETERS:
        none.

    DESCRIPTION:
        This function will "Clean" out the object and
    reset it.  Normally called when the caller is about
    to set new values.
\****************************************************/
HRESULT CShellUrl::Reset(void)
{
    Pidl_Set(&m_pidl, NULL);
    Str_SetPtr(&m_pszURL, NULL);
    Str_SetPtr(&m_pszArgs, NULL);
    Str_SetPtr(&m_pszDisplayName, NULL);
    m_dwGenType = 0;

    return S_OK;
}


/****************************************************\
    FUNCTION: _CanUseAdvParsing

    PARAMETERS:
        none.

    DESCRIPTION:
        This function will return TRUE if Advanced
    Parsing (Shell URLs) should be supported.  This
    function will keep track of whether the user
    has turn off Shell Parsing from the Control Panel.
\****************************************************/
#define REGSTR_USEADVPARSING_PATH  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Band\\Address")
#define REGSTR_USEADVPARSING_VALUE TEXT("UseShellParsing")

BOOL CShellUrl::_CanUseAdvParsing(void)
{
    // WARNING: Since this is static, changes to the registry entry won't be
    //          read in until the time the process is launched.  This is okay,
    //          because this feature will probably be removed from the released
    //          product and can be added back in as power toy.
    static TRI_STATE fCanUseAdvParsing = TRI_UNKNOWN;

    if (TRI_UNKNOWN == fCanUseAdvParsing)
        fCanUseAdvParsing = (TRI_STATE) SHRegGetBoolUSValue(REGSTR_USEADVPARSING_PATH, REGSTR_USEADVPARSING_VALUE, FALSE, TRUE);

    return fCanUseAdvParsing;
}


/****************************************************\
    FUNCTION: _FixDriveDisplayName

    PARAMETERS:
        pszStart - Pointer to the beginning of the URL string.
        pszCurrent - Pointer into current location in the URL string.
        pidl - PIDL pointing to location of Shell Name space that
               has been parsed so far.

    DESCRIPTION:
        This function exists to check if we are parsing
    a drive letter.  This is necessary because the Display
    Name of drive letters end in '\', which will is needed
    later to determine the start of the next segment.
\****************************************************/

#define DRIVE_STRENDING     TEXT(":\\")
#define DRIVE_STRSIZE       3 // "C:\"

BOOL _FixDriveDisplayName(LPCTSTR pszStart, LPCTSTR pszCurrent, LPCITEMIDLIST pidl)
{
    BOOL fResult = FALSE;

    ASSERT(pszCurrent >= pszStart);


    // The compiler will take care of adding '/ sizeof(TCHAR)'.
    if (((pszCurrent - pszStart) == DRIVE_STRSIZE) &&
        (0 == StrCmpN(&(pszStart[1]), DRIVE_STRENDING, SIZECHARS(DRIVE_STRENDING)-1)))
    {
        if (IsSpecialFolderChild(pidl, CSIDL_DRIVES, TRUE))
            fResult = TRUE;
    }

    return fResult;
}



/****************************************************\
    FUNCTION: _ParseRelativePidl

    PARAMETERS:
        pcszUrlIn - Pointer to URL to Parse.
        dwFlags - Flags to modify the way the string is parsed.
        pidl - This function will see if pcszUrlIn is a list of display names
               relative to this pidl.
        fAllowRelative - Do we allow relative parsing, which
                         means strings containing "..".
        fQualifyDispName - If TRUE when we known that we need to force the
                           URL to be fully qualified if we bind to the destination.
                           This is needed because we are using state information to
                           find the destination URL and that state information won't
                           be available later.

    DESCRIPTION:
        Start the parsing by getting the pidl of ShellUrlRelative
    and call _ParseNextSegment().  _ParseNextSegment() will
    recursively parse each segment of the PIDL until either
    it fails to fully parse of it finishes.
\****************************************************/
HRESULT CShellUrl::_ParseRelativePidl(LPCTSTR pcszUrlIn,
    BOOL * pfPossibleWebUrl, DWORD dwFlags, LPCITEMIDLIST pidl,
    BOOL fAllowRelative, BOOL fQualifyDispName)
{
    HRESULT hr;
    BOOL fFreePidl = FALSE;

    if (!pcszUrlIn)
        return E_INVALIDARG;

    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _ParseRelativePidl() Begin. pcszUrlIn=%s", pcszUrlIn);

    hr = _ParseNextSegment(pidl, pcszUrlIn, pfPossibleWebUrl, fAllowRelative, fQualifyDispName);

    if (pidl && fFreePidl)
        ILFree((LPITEMIDLIST)pidl);

    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _ParseRelativePidl() m_pidl=>%s<", Dbg_PidlStr(m_pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    return hr;
}



/****************************************************\
    FUNCTION: IsShellUrl

    PARAMETERS:
        LPCTSTR szUrl - URL from Outside Source.
        return - Whether the URL is an Internet URL.

    DESCRIPTION:
        This function will determine if the URL is
    a shell URL which includes the following:
    1. File Urls (E;\dir1\dir2)
    2. Shell Urls (shell:desktop)
\****************************************************/
BOOL IsShellUrl(LPCTSTR pcszUrl, BOOL fIncludeFileUrls)
{
    int nSchemeBefore, nSchemeAfter;
    TCHAR szParsedUrl[MAX_URL_STRING];

    nSchemeBefore = GetUrlScheme(pcszUrl);
    IURLQualifyT(pcszUrl, UQF_GUESS_PROTOCOL, szParsedUrl, NULL, NULL);
    nSchemeAfter = GetUrlScheme(szParsedUrl);

    // This is a "shell url" if it is a file: (and fIncludeFileUrls is
    // set), or it is a shell:, or it is an invalid scheme (which
    // occurs for things like "My Computer" and "Control Panel").

    return ((fIncludeFileUrls && URL_SCHEME_FILE == nSchemeAfter) ||
            URL_SCHEME_SHELL == nSchemeAfter ||
            URL_SCHEME_INVALID == nSchemeBefore);
}


/****************************************************\
    FUNCTION: IsSpecialFolderChild

    PARAMETERS:
        pidlToTest (In) - Is this PIDL to test and see if it's
                     a child of SpecialFolder(nFolder).
        psfParent (In Optional)- The psf passed to
                     SHGetSpecialFolderLocation() if needed.
        nFolder (In) - Special Folder Number (CSIDL_INTERNET, CSIDL_DRIVES, ...).
        pdwLevels (In Optional) - Pointer to DWORD to receive levels between
                    pidlToTest and it's parent (nFolder) if S_OK is returned.

    DESCRIPTION:
        This function will see if pidlToTest is a child
    of the Special Folder nFolder.
\****************************************************/
BOOL IsSpecialFolderChild(LPCITEMIDLIST pidlToTest, int nFolder, BOOL fImmediate)
{
    LPITEMIDLIST pidlThePidl = NULL;
    BOOL fResult = FALSE;

    if (!pidlToTest)
        return FALSE;

    ASSERT(IS_VALID_PIDL(pidlToTest));
    if (NOERROR == SHGetSpecialFolderLocation(NULL, nFolder, &pidlThePidl))
    {
        fResult = ILIsParent(pidlThePidl, pidlToTest, fImmediate);
        ILFree(pidlThePidl);
    }
    return fResult;        // Shell Items (My Computer, Control Panel)
}


/****************************************************\
    FUNCTION: GetPidl

    PARAMETERS
         ppidl - Pointer that will receive the current PIDL.

    DESCRIPTION:
         This function will retrieve the pidl that the
    Shell Url is set to.

    MEMORY ALLOCATION:
         This function will allocate the PIDL that ppidl
    points to, and the caller needs to free the PIDL when
    done with it.
\****************************************************/
HRESULT CShellUrl::GetPidl(LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;

    if (ppidl)
        *ppidl = NULL;
    if (!m_pidl)
        hr = _GeneratePidl(m_pszURL, m_dwGenType);

    if (ppidl)
    {
        if (m_pidl)
        {
            *ppidl = ILClone(m_pidl);
            if (!*ppidl)
                hr = E_FAIL;
        }
        else
            hr = E_FAIL;
    }

    // Callers only free *ppidl if SUCCEDED(hr), so assert we act this way.
    ASSERT((*ppidl && SUCCEEDED(hr)) || (!*ppidl && FAILED(hr)));

    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: GetPidl() *ppidl=>%s<", Dbg_PidlStr(*ppidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    return hr;
}

//
// This is a wacky class!  If GetPidl member of this class is called and
// a m_pidl is generated from and url and then Execute() assumes we have
// a valid location in our namespace and  calls code that will not autoscan.
// This hacky function is used to return a pidl only if we have one to
// avoid the above problem.
//
HRESULT CShellUrl::GetPidlNoGenerate(LPITEMIDLIST * ppidl)
{
    HRESULT hr = E_FAIL;
    if (m_pidl && ppidl)
    {
        *ppidl = ILClone(m_pidl);
        if (*ppidl)
        {
            hr = S_OK;
        }
    }

    return hr;
}

/****************************************************\
    FUNCTION: _GeneratePidl

    PARAMETERS
         pcszUrl - This URL will be used to generate the m_pidl.
         dwGenType - This is needed to know how to parse pcszUrl
                     to generate the PIDL.

    DESCRIPTION:
        This CShellUrl maintains a pointer to the object
    in the Shell Name Space by using either the string URL
    or the PIDL.  When this CShellUrl is set to one, we
    delay generating the other one for PERF reasons.
    This function generates the PIDL from the string URL
    when we do need the string.
\****************************************************/

HRESULT CShellUrl::_GeneratePidl(LPCTSTR pcszUrl, DWORD dwGenType)
{
    HRESULT hr;

    if (!pcszUrl && m_pidl)
        return S_OK;      // The caller only wants the PIDL to be created if it doesn't exist.

    if (pcszUrl && m_pidl)
    {
        ILFree(m_pidl);
        m_pidl = NULL;
    }

    switch (dwGenType)
    {
        case GENTYPE_FROMURL:
            if (ILIsRooted(m_pidlWorkingDir))
                hr = E_FAIL;    // MSN Displays error dialogs on IShellFolder::ParseDisplayName()
            // fall through
        case GENTYPE_FROMPATH:
            hr = IECreateFromPath(pcszUrl, &m_pidl);
            // This may fail if it's something like "ftp:/" and not yet valid".
            break;

        default:
            hr = E_INVALIDARG;
            break;
    }

    if (!m_pidl && SUCCEEDED(hr))
        hr = E_FAIL;

    return hr;
}


/****************************************************\
    FUNCTION: SetPidl

    PARAMETERS
         pidl - New pidl to use.

    DESCRIPTION:
         The shell url will now consist of the new pidl
    passed in.

    MEMORY ALLOCATION:
         The caller is responsible for Allocating and Freeing
    the PIDL parameter.
\****************************************************/
HRESULT CShellUrl::SetPidl(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    ASSERT(!pidl || IS_VALID_PIDL(pidl));

    Reset();        // External Calls to this will reset the entire CShellUrl.
    return _SetPidl(pidl);
}


/****************************************************\
    FUNCTION: _SetPidl

    PARAMETERS
         pidl - New pidl to use.

    DESCRIPTION:
         This function will reset the m_pidl member
    variable without modifying m_szURL.  This is only used
    internally, and callers that want to reset the entire
    CShellUrl to a PIDL should call the public method
    SetPidl().

    MEMORY ALLOCATION:
         The caller is responsible for Allocating and Freeing
    the PIDL parameter.
\****************************************************/
HRESULT CShellUrl::_SetPidl(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _SetPidl() pidl=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

    Pidl_Set(&m_pidl, pidl);
    if (!m_pidl)
        hr = E_FAIL;

    return hr;
}


/****************************************************\
    FUNCTION: GetUrl

    PARAMETERS
         pszUrlOut (Out Optional) - If the caller wants the string.
         cchUrlOutSize (In) - Size of String Buffer Passed in.

    DESCRIPTION:
         This function will retrieve the string value of
    the shell url.  This will not include the command line
    arguments or other information needed for correct navigation
    (AutoSearch=On/Off, ...).  Note that this may be of the
    form "Shell:/desktop/My Computer/...".
\****************************************************/
HRESULT CShellUrl::GetUrl(LPTSTR pszUrlOut, DWORD cchUrlOutSize)
{
    HRESULT hr = S_OK;

    if (!m_pszURL)
    {
        if (m_pidl)
            hr = _GenerateUrl(m_pidl);
        else
            hr = E_FAIL;  // User never set the CShellUrl.
    }

    if (SUCCEEDED(hr) && pszUrlOut)
        StringCchCopy(pszUrlOut,  cchUrlOutSize, m_pszURL);

    return hr;
}

/****************************************************\
!!! WARNING - extremely specific to the ShellUrl/AddressBar - ZekeL - 18-NOV-98
!!!           it depends on the bizarre pathology of the ShellUrl in order
!!!           to be reparsed into a pidl later.  cannot be used for anything else

    PARAMETERS:
        pidlIn - Pointer to PIDL to generate Display Names.
        pszUrlOut - String Buffer to store list of Display Names for ITEMIDs
                    in pidlIn.
        cchUrlOutSize - Size of Buffer in characters.

    DESCRIPTION:
        This function will take the PIDL passed in and
    generate a string containing the ILGDN_ITEMONLY Display names
    of each ITEMID in the pidl separated by '\'.
\****************************************************/
#define SZ_SEPARATOR TEXT("/")

HRESULT MutantGDNForShellUrl(LPCITEMIDLIST pidlIn, LPTSTR pszUrlOut, int cchUrlOutSize)
{
    HRESULT hr = S_OK;
    LPCITEMIDLIST pidlCur;
    IShellFolder *psfCur = NULL;

    if (ILIsRooted(pidlIn))
    {
        //  need to start off with our virtual root
        LPITEMIDLIST pidlFirst = ILCloneFirst(pidlIn);
        if (pidlFirst)
        {
            IEBindToObject(pidlFirst, &psfCur);
            ILFree(pidlFirst);
        }

        pidlCur = _ILNext(pidlIn);
    }
    else
    {
        SHGetDesktopFolder(&psfCur);
        pidlCur = pidlIn;
    }

    ASSERT(pidlCur && IS_VALID_PIDL(pidlCur));
    while (psfCur && SUCCEEDED(hr) && !ILIsEmpty(pidlCur) && (cchUrlOutSize > 0))
    {
        LPITEMIDLIST pidlCopy = ILCloneFirst(pidlCur);
        if (pidlCopy)
        {
            StringCchCopy(pszUrlOut,  cchUrlOutSize, SZ_SEPARATOR);
            cchUrlOutSize -= SIZECHARS(SZ_SEPARATOR);

            TCHAR szCurrDispName[MAX_PATH];
            hr = DisplayNameOf(psfCur, pidlCopy, SHGDN_NORMAL, szCurrDispName, SIZECHARS(szCurrDispName));

            if (SUCCEEDED(hr))
            {
                if (TBOOL((int)cchUrlOutSize > lstrlen(szCurrDispName)))
                {
                    StringCchCat(pszUrlOut,  cchUrlOutSize, szCurrDispName);
                    cchUrlOutSize -= lstrlen(szCurrDispName);
                }

                // may fail, in that case we terminate the loop
                IShellFolder *psfCurNew = NULL; // for buggy BindToObject impls
                hr = psfCur->BindToObject(pidlCopy, NULL, IID_IShellFolder, (void **)&psfCurNew);

                psfCur->Release();
                psfCur = psfCurNew;
            }
            pidlCur = _ILNext(pidlCur);
            ILFree(pidlCopy);
        }
        else
            hr = E_FAIL;
    }
    if (psfCur)
        psfCur->Release();

    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: MutantGDNForShellUrl() End. pszUrlOut=%s", pszUrlOut);
    return hr;
}


/****************************************************\
    FUNCTION: _GenerateUrl

    PARAMETERS
         pidl - This PIDL will be used to generate the m_pszURL, string URL.

    DESCRIPTION:
        This CShellUrl maintains a pointer to the object
    in the Shell Name Space by using either the string URL
    or the PIDL.  When this CShellUrl is set to one, we
    delay generating the other one for PERF reasons.
    This function generates the string URL from the PIDL
    when we do need the string.
\****************************************************/
#define SZ_THEINTERNET_PARSENAME         TEXT("::{")

HRESULT CShellUrl::_GenerateUrl(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    TCHAR szUrl[MAX_URL_STRING];

    ASSERT(IS_VALID_PIDL(pidl));
    if (IsURLChild(pidl, TRUE) || _IsFilePidl(pidl))
    {
        hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szUrl, SIZECHARS(szUrl), NULL);
        if (SUCCEEDED(hr))
        {
            // Was the pidl pointing to "The Internet"?
            if (0 == StrCmpN(szUrl, SZ_THEINTERNET_PARSENAME, (ARRAYSIZE(SZ_THEINTERNET_PARSENAME) - 1)))
            {
                // Yes, so we don't want the SHGDN_FORPARSING name
                // because the user doesn't know what the heck it is.  Since we
                // navigate to the home page, let's display that.
                hr = IEGetNameAndFlags(pidl, SHGDN_NORMAL, szUrl, SIZECHARS(szUrl), NULL);
            }
        }
    }
    else
    {
//        hr = MutantGDNForShellUrl(pidl, szUrl, SIZECHARS(szUrl));
        hr = IEGetNameAndFlags(pidl, SHGDN_NORMAL, szUrl, SIZECHARS(szUrl), NULL);
    }

    if (SUCCEEDED(hr))
        Str_SetPtr(&m_pszURL, szUrl);

    if (!m_pszURL)
        hr = E_OUTOFMEMORY;

    if (FAILED(hr))
        Str_SetPtr(&m_pszURL, NULL);        // Clear it

    return hr;
}


/****************************************************\
    FUNCTION: SetUrl

    PARAMETERS
         szUrlOut (Out) - Url

    DESCRIPTION:
         Set the ShellUrl from a string that is parsible from
    the root (desktop) ISF.  This is normally used for
    File Paths.
\****************************************************/
HRESULT CShellUrl::SetUrl(LPCTSTR pcszUrlIn, DWORD dwGenType)
{
    Reset();        // External Calls to this will reset the entire CShellUrl.
    return _SetUrl(pcszUrlIn, dwGenType);
}


/****************************************************\
    FUNCTION: _SetUrl

    PARAMETERS
         pcszUrlIn (In) - The string URL for this CShellUrl
         dwGenType (In) - Method to use when generating the PIDL
                          from pcszUrlIn.

    DESCRIPTION:
         This function will reset the m_pszURL member
    variable without modifying m_pidl.  This is only used
    internally, and callers that want to reset the entire
    CShellUrl to an URL should call the public method
    SetUrl().
\****************************************************/
HRESULT CShellUrl::_SetUrl(LPCTSTR pcszUrlIn, DWORD dwGenType)
{
    m_dwGenType = dwGenType;

    return Str_SetPtr(&m_pszURL, pcszUrlIn) ? S_OK : E_OUTOFMEMORY;
}


/****************************************************\
    FUNCTION: GetDisplayName

    PARAMETERS
         pszUrlOut (Out) - Get the Shell Url in String Form.
         cchUrlOutSize (In) - Size of String Buffer Passed in.

    DESCRIPTION:
         This function will Fill in pszUrlOut with nice
    versions of the Shell Url that can be displayed in
    the AddressBar or in the Titles of windows.
\****************************************************/
HRESULT CShellUrl::GetDisplayName(LPTSTR pszUrlOut, DWORD cchUrlOutSize)
{
    HRESULT hr = S_OK;

    if (!m_pszDisplayName)
    {
        if (m_pidl)
        {
            LPITEMIDLIST pidl = NULL;

            hr = GetPidl(&pidl);
            if (SUCCEEDED(hr))
            {
                hr = _GenDispNameFromPidl(pidl, NULL);
                ILFree(pidl);
            }
        }
        else if (m_pszURL)
        {
            // In this case, we will just give back the URL.
            Str_SetPtr(&m_pszDisplayName, m_pszURL);

            if (NULL == m_pszDisplayName)
                hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr) && pszUrlOut && m_pszDisplayName)
        StringCchCopy(pszUrlOut,  cchUrlOutSize, m_pszDisplayName);

    return hr;
}


/****************************************************\
    FUNCTION: _GenDispNameFromPidl

    PARAMETERS
         pidl (In) - This will be used to generate the Display Name.
         pcszArgs (In) - These will be added to the end of the Display Name

    DESCRIPTION:
        This function will generate the Display Name
    from the pidl and pcszArgs parameters.  This is
    normally not needed when this CShellUrl was parsed
    from an outside source, because the Display Name
    was generated at that time.
\****************************************************/
HRESULT CShellUrl::_GenDispNameFromPidl(LPCITEMIDLIST pidl, LPCTSTR pcszArgs)
{
    HRESULT hr;
    TCHAR szDispName[MAX_URL_STRING];

    hr = GetUrl(szDispName, SIZECHARS(szDispName));
    if (SUCCEEDED(hr))
    {
        if (pcszArgs)
            StringCchCat(szDispName,  ARRAYSIZE(szDispName), pcszArgs);
        PathMakePretty(szDispName);

        hr = Str_SetPtr(&m_pszDisplayName, szDispName) ? S_OK : E_OUTOFMEMORY;
    }

    return hr;
}


/****************************************************\
    FUNCTION: GetArgs

    PARAMETERS
         pszArgsOut - The arguments to the Shell Url. (Only
                     for ShellExec().
         cchArgsOutSize - Size of pszArgsOut in chars.

    DESCRIPTION:
         Get the arguments that will be passed to
    ShellExec() if 1) the Pidl is navigated to, 2) it's
    a File URL, and 3) it's not navigatable.
\****************************************************/
HRESULT CShellUrl::GetArgs(LPTSTR pszArgsOut, DWORD cchArgsOutSize)
{
    ASSERT(pszArgsOut);

    if (m_pszArgs)
        StringCchCopy(pszArgsOut,  cchArgsOutSize, m_pszArgs);
    else
        *pszArgsOut = 0;

    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: GetArgs() pszArgsOut=%s", pszArgsOut);
    return S_OK;
}


/****************************************************\
    FUNCTION: SetDefaultShellPath

    PARAMETERS
         psu - CShellUrl to set path.

    DESCRIPTION:
         "Desktop";"Desktop/My Computer" is the
    most frequently used Shell Path for parsing.  This
    function will add those two items to the CShellUrl
    passed in the paramter.
\****************************************************/
HRESULT SetDefaultShellPath(CShellUrl * psu)
{
    ASSERT(psu);
    LPITEMIDLIST pidl;

    // We need to set the "Shell Path" which will allow
    // the user to enter Display Names of items in Shell
    // Folders that are frequently used.  We add "Desktop"
    // and "Desktop/My Computer" to the Shell Path because
    // that is what users use most often.

    // _pshuUrl will free pshuPath, so we can't.
    psu->AddPath(&s_idlNULL);

    SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidl);  // Get Pidl for "My Computer"
    if (pidl)
    {
        // psu will free pshuPath, so we can't.
        psu->AddPath(pidl);
        ILFree(pidl);
    }

    // Add favorites folder too
    SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &pidl);
    if (pidl)
    {
        // psu will free pshuPath, so we can't.
        psu->AddPath(pidl);
        ILFree(pidl);
    }

    return S_OK;
}

void CShellUrl::SetMessageBoxParent(HWND hwnd)
{
    // Find the topmost window so that the messagebox disables
    // the entire frame
    HWND hwndTopmost = NULL;
    while (hwnd)
    {
        hwndTopmost = hwnd;
        hwnd = GetParent(hwnd);
    }

    m_hwnd = hwndTopmost;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\snslist.cpp ===
/**************************************************************\
    FILE: snslist.cpp

    DESCRIPTION:
        SNSList implements the Shell Name Space List or DriveList.
    This will store a pidl and be able to populate the AddressBand
    combobox with the shell name space that includes that PIDL.
\**************************************************************/

#include "priv.h"

#ifndef UNIX

#include "addrlist.h"
#include "itbar.h"
#include "itbdrop.h"
#include "util.h"
#include "autocomp.h"
#include <urlhist.h>
#include <winbase.h>
#include <wininet.h>



///////////////////////////////////////////////////////////////////
// Data Structures
typedef struct {
    LPITEMIDLIST pidl;          // the pidl
    TCHAR szName[MAX_URL_STRING];     // pidl's display name
    int iImage;                 // pidl's icon
    int iSelectedImage;         // pidl's selected icon
} PIDLCACHE, *PPIDLCACHE;


/**************************************************************\
    CLASS: CSNSList

    DESCRIPTION:
        This object supports IAddressList and can populate
    the Address Band/Bar with the Shell Name Space (DriveList)
    heirarchy.
\**************************************************************/
class CSNSList  : public CAddressList
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IAddressList methods ***
    virtual STDMETHODIMP Connect(BOOL fConnect, HWND hwnd, IBrowserService * pbs, IBandProxy * pbp, IAutoComplete * pac);
    virtual STDMETHODIMP NavigationComplete(LPVOID pvCShellUrl);
    virtual STDMETHODIMP Refresh(DWORD dwType);
    virtual STDMETHODIMP SetToListIndex(int nIndex, LPVOID pvShelLUrl);
    virtual STDMETHODIMP FileSysChangeAL(DWORD dw, LPCITEMIDLIST* ppidl);

protected:
    //////////////////////////////////////////////////////
    // Private Member Functions
    //////////////////////////////////////////////////////

    // Constructor / Destructor
    CSNSList();
    ~CSNSList(void);        // This is now an OLE Object and cannot be used as a normal Class.


    // Address Band Specific Functions
    LRESULT _OnNotify(LPNMHDR pnm);
    LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);

    // Address List Modification Functions
    void _AddItem(LPITEMIDLIST pidl, int iInsert, int iIndent);
    LPITEMIDLIST _GetFullIDList(int iItem);
    int _GetIndent(int iItem);
    void _FillOneLevel(int iItem, int iIndent, int iDepth);
    void _ExpandMyComputer(int iDepth);
    LPITEMIDLIST _GetSelectedPidl(void);
    BOOL _SetCachedPidl(LPCITEMIDLIST pidl);
    BOOL _GetPidlUI(LPCITEMIDLIST pidl, LPTSTR pszName, int cchName, int *piImage, int *piSelectedImage, DWORD dwFlags, BOOL fIgnoreCache);
    BOOL _GetPidlImage(LPCITEMIDLIST pidl, int *piImage, int *piSelectedImage);
    LRESULT _OnGetDispInfoA(PNMCOMBOBOXEXA pnmce);
    LRESULT _OnGetDispInfoW(PNMCOMBOBOXEXW pnmce);
    void _PurgeComboBox();
    void _PurgeAndResetComboBox();

    LPITEMIDLIST CSNSList::_GetDragDropPidl(LPNMCBEDRAGBEGINW pnmcbe);
    HRESULT _GetURLToolTip(LPTSTR pszUrl, DWORD dwStrSize);        
    HRESULT _GetPIDL(LPITEMIDLIST* ppidl);
    BOOL _IsSelectionValid(void);
    HRESULT _PopulateOneItem(BOOL fIgnoreCache = FALSE);
    HRESULT _Populate(void);
    void _InitCombobox(void);
    // Friend Functions
    friend IAddressList * CSNSList_Create(void);

    //////////////////////////////////////////////////////
    //  Private Member Variables 
    //////////////////////////////////////////////////////
    PIDLCACHE           _cache;             // cache of pidl UI information

    BOOL                _fFullListValid:1;  // TRUE when the full combo is correctly populated
    BOOL                _fPurgePending:1;   // TRUE if we should purge when the combo closes up
    BOOL                _fInPopulate;       // TRUE when we're currently doing a _PopulateOneItem
};



//================================================================= 
// Implementation of CSNSList
//=================================================================


/****************************************************\
    FUNCTION: CSNSList_Create
  
    DESCRIPTION:
        This function will create an instance of the
    CSNSList COM object.
\****************************************************/
IAddressList * CSNSList_Create(void)
{
    CSNSList * p = new CSNSList();
    return p;
}


/****************************************************\
  
    Address Band Constructor
  
\****************************************************/
CSNSList::CSNSList()
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!_cache.pidl);
}


/****************************************************\
  
    Address Band destructor
  
\****************************************************/
CSNSList::~CSNSList()
{
    if (_cache.pidl)
        ILFree(_cache.pidl);

    _PurgeComboBox();

    TraceMsg(TF_SHDLIFE, "dtor CSNSList %x", this);
}


//================================
// *** IAddressList Interface ***


void CSNSList::_PurgeComboBox()
{
    if (_hwnd)
    {
        // Deleting items from the combobox trashes the edit button if something was
        // previously selected from the combobox.  So we want to restore the editbox
        // when we are done
        WCHAR szBuf[MAX_URL_STRING];
        *szBuf = NULL;
        GetWindowText(_hwnd, szBuf, ARRAYSIZE(szBuf));
        SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);

        // Delete the PIDL of every item and then free the item
        INT iMax = (int)SendMessage(_hwnd, CB_GETCOUNT, 0, 0);
        
        while(iMax > 0)
        {
            // Each call to DeleteItem results in a callback
            // which frees the corresponding PIDL
            // if you simply use CB_RESETCONTENT - you don't get the callback
            iMax = (int)SendMessage(_hwnd, CBEM_DELETEITEM, (WPARAM)0, (LPARAM)0);
        }

        // Restore the contents of the editbox
        SetWindowText(_hwnd, szBuf);
        SendMessage(_hwnd, WM_SETREDRAW, TRUE, 0);
        InvalidateRect(_hwnd, NULL, FALSE);
    }
    _fFullListValid = FALSE;
}

void CSNSList::_PurgeAndResetComboBox()
{
    _PurgeComboBox();
    if (_hwnd)
    {
        SendMessage(_hwnd, CB_RESETCONTENT, 0, 0L);
    }
}

/****************************************************\
    DESCRIPTION:
        We are either becoming the selected list for
    the AddressBand's combobox, or lossing this status.
    We need to populate or unpopulate the combobox
    as appropriate.
\****************************************************/
HRESULT CSNSList::Connect(BOOL fConnect, HWND hwnd, IBrowserService * pbs, IBandProxy * pbp, IAutoComplete * pac)
{
    _PurgeComboBox();

    HRESULT hr = CAddressList::Connect(fConnect, hwnd, pbs, pbp, pac);
    
    if (fConnect)
    {
        _PopulateOneItem();
    }
    else
    {
        // Get the pidl of the currently displayed item and destroy it
        COMBOBOXEXITEM cbexItem = {0};
        cbexItem.iItem = -1;
        cbexItem.mask = CBEIF_LPARAM;
        SendMessage(_hwnd, CBEM_GETITEM, 0, (LPARAM)&cbexItem);
        LPITEMIDLIST pidlPrev = (LPITEMIDLIST)cbexItem.lParam;
        if (pidlPrev)
        {
            ILFree(pidlPrev);
            cbexItem.lParam = NULL;
            SendMessage(_hwnd, CBEM_SETITEM, 0, (LPARAM)&cbexItem);
        }
    }

    return hr;
}



/****************************************************\
    FUNCTION: _InitCombobox
    
    DESCRIPTION:
        Prepare the combo box for this list.  This normally
    means that the indenting and icon are either turned
    on or off.
\****************************************************/
void CSNSList::_InitCombobox()
{
    HIMAGELIST himlSysSmall;
    Shell_GetImageLists(NULL, &himlSysSmall);

    SendMessage(_hwnd, CBEM_SETIMAGELIST, 0, (LPARAM)himlSysSmall);
    SendMessage(_hwnd, CBEM_SETEXSTYLE, 0, 0);
    CAddressList::_InitCombobox();    
}


/****************************************************\
  
    FUNCTION: _IsSelectionValid
  
    DESCRIPTION:
        Is the current selection valid?
\****************************************************/
BOOL CSNSList::_IsSelectionValid(void)
{
    LPITEMIDLIST pidlCur, pidlSel;
    BOOL fValid;

    _GetPIDL(&pidlCur);
    pidlSel = _GetSelectedPidl();

    if (pidlCur == pidlSel)
    {
        fValid = TRUE;
    }
    else if ((pidlCur == NULL) || (pidlSel == NULL))
    {
        fValid = FALSE;
    }
    else
    {
        //
        // ILIsEqual faults on NULL pidls, sigh
        //
        fValid = ILIsEqual(pidlCur, pidlSel);
    }
    ILFree(pidlCur);

    return fValid;
}


/****************************************************\
    FUNCTION: NavigationComplete
  
    DESCRIPTION:
        Update the URL in the Top of the list.
\****************************************************/
HRESULT CSNSList::NavigationComplete(LPVOID pvCShellUrl)
{
    CShellUrl * psu = (CShellUrl *) pvCShellUrl;
    ASSERT(pvCShellUrl);
    LPITEMIDLIST pidl;
    HRESULT hr = psu->GetPidl(&pidl);
    if (SUCCEEDED(hr))
    {
        // Update current PIDL.
        if (_SetCachedPidl(pidl))
            hr = _PopulateOneItem();

        ILFree(pidl);
    }

    return hr;
}


/****************************************************\
    FUNCTION: Refresh
  
    DESCRIPTION:
        This call will invalidate the contents of the
    contents of the drop down as well as refresh the
    Top Most icon and URL.
\****************************************************/
HRESULT CSNSList::Refresh(DWORD dwType)
{
    if (!_hwnd)
        return S_OK;    // Don't need to do any work.

    // Since it doesn't make much sense to refresh with the box down,
    // we force the box to close and then let _PopulateOneItem do
    // its thing.  
    if(SendMessage(_hwnd, CB_GETDROPPEDSTATE, 0, 0))
    {
        SendMessage(_hwnd, CB_SHOWDROPDOWN, 0, 0);
    }

    // Full refresh (ignore the cache) because the full path
    // style bit may have changed
    return _PopulateOneItem(TRUE);
}


/****************************************************\
  
    DESCRIPTION:
        Puts the current pidl into the combobox.
    This is a sneaky perf win.  Since most of the time users
    don't drop down the combo, we only fill it in with the
    (visible) current selection.
    We need to destroy the PIDL of the currently displayed item
    first though
  
\****************************************************/
HRESULT CSNSList::_PopulateOneItem(BOOL fIgnoreCache)
{
    HRESULT hr = S_OK;

    _fFullListValid = FALSE;

    // we can get reentered here when we do our sendmessages, which lets other notifies come in
    // and we get called between "LPITEMIDLIST pidlPrev = (LPITEMIDLIST)cbexItem.lParam" and
    // "ILFree(pidlPrev)".  since we dont have a refcounted pidl this causes a double-free.
    // since its not trivial to change the refcounting, block out all reentrant callers.  this
    // is okay since multiple calls are redundant anyway.
    if (!_fInPopulate)
    {
        _fInPopulate = TRUE;
        // First easy out - if there is no current pidl,
        // do nothing.
        LPITEMIDLIST pidlCur;
        if (SUCCEEDED(_GetPIDL(&pidlCur)) && pidlCur)
        {
            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
            TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _PopulateOneItem(), and Pidl not in ComboBox. PIDL=>%s<", Dbg_PidlStr(pidlCur, szDbgBuffer, SIZECHARS(szDbgBuffer)));
            ASSERT(_hwnd);
            TCHAR szURL[MAX_URL_STRING];

            COMBOBOXEXITEM cbexItem = {0};
            // Get the pidl of the currently displayed item and destroy it
            cbexItem.iItem = -1;
            cbexItem.mask = CBEIF_LPARAM;
            SendMessage(_hwnd, CBEM_GETITEM, 0, (LPARAM)&cbexItem);
            // we only free pidlPrev if we can sucessfully set the new item in...
            LPITEMIDLIST pidlPrev = (LPITEMIDLIST)cbexItem.lParam;
        
            // Done - so go insert the new item
            cbexItem.iItem = -1;
            cbexItem.pszText = szURL;
            cbexItem.cchTextMax = ARRAYSIZE(szURL);
            cbexItem.iIndent = 0;
            cbexItem.lParam = (LPARAM)ILClone(pidlCur);
            cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE | CBEIF_INDENT | CBEIF_LPARAM;

            _GetPidlUI(pidlCur, szURL, cbexItem.cchTextMax, &cbexItem.iImage,
                       &cbexItem.iSelectedImage, SHGDN_FORPARSING, fIgnoreCache);
            if (!*szURL)
            {
                // Navigating to a net unc in browser-only doesn't work so try again without cache and FORPARSING
                _GetPidlUI(pidlCur, szURL, cbexItem.cchTextMax, &cbexItem.iImage,
                       &cbexItem.iSelectedImage, SHGDN_NORMAL, TRUE);
            }

            TraceMsg(TF_BAND|TF_GENERAL, "CSNSList::_PopulateOneItem(), Name=>%s<", cbexItem.pszText);

            // We need to set the current selection to -1 or the icon of the current selection
            // will be displayed instead of this new one
            SendMessage(_hwnd, CB_SETCURSEL, (WPARAM)-1, 0L);
            LRESULT lRes = SendMessage(_hwnd, CBEM_SETITEM, 0, (LPARAM)&cbexItem);
            if ((CB_ERR == lRes) || (0 == lRes))
            {
                if (cbexItem.lParam)
                {
                    // Since we didn't insert the item, free the cloned pidl
                    ILFree((LPITEMIDLIST) cbexItem.lParam);
                }
            }
            else
            {
                // since we inserted the item, free the previous one
                if (pidlPrev)
                {
                    ILFree(pidlPrev);
                }
            }

            ILFree(pidlCur);
        }
        _fInPopulate = FALSE;
    }
    return hr;
}

/****************************************************\
  
    DESCRIPTION:
        fills in the entire combo.
  
    WARNING!!!!!!!!:
    *** This is expensive, don't do it unless absolutely necessary! ***
  
\****************************************************/
HRESULT CSNSList::_Populate(void)
{
    LPITEMIDLIST pidl = NULL;
    int iIndent, iDepth;
    HRESULT hr = S_OK;

    if (_fFullListValid)
        return S_OK;  // Not needed, the drop down is already up todate.

    ASSERT(_hwnd);
    _PurgeAndResetComboBox();

    //
    // Fill in the current pidl and all it's parents.
    //
    hr = _GetPIDL(&pidl);

    iDepth = 0;
    iIndent = 0;

    if (pidl)
    {
        //
        // Compute the relative depth of pidl from the root.
        //
        LPITEMIDLIST pidlChild = pidl;
        if (ILIsRooted(pidl))
            pidlChild = ILGetNext(pidl);

        ASSERT(pidlChild);

        if (pidlChild)
        {
            //
            // Compute the maximum indentation level.
            //
            while (!ILIsEmpty(pidlChild))
            {
                pidlChild = _ILNext(pidlChild);
                iIndent++;
            }

            //
            // Save the maximum level.
            //
            iDepth = iIndent;
            
            //
            // Insert all those pidls.
            //
            LPITEMIDLIST pidlTemp = ILClone(pidl);
            if (pidlTemp)
            {
                do
                {
                    _AddItem(pidlTemp, 0, iIndent);

                    ILRemoveLastID(pidlTemp);
                    iIndent--;
                } while (iIndent >= 0);
                ILFree(pidlTemp);
            }
        }
        
        // Expand the root item.
        _FillOneLevel(0, 1, iDepth);

        // If this is not a rooted explorer, we expand MyComputer as well.
        // This is where we get our name "the drives dropdown".
        if (!ILIsRooted(pidl))
            _ExpandMyComputer(iDepth);
    }

    ILFree(pidl);
    _fFullListValid = TRUE;
    return hr;
} 


//================================
// *** Internal/Private Methods ***

//=================================================================
// General Band Functions
//=================================================================


/****************************************************\
    FUNCTION: _OnNotify
  
    DESCRIPTION:
        This function will handle WM_NOTIFY messages.
\****************************************************/
LRESULT CSNSList::_OnNotify(LPNMHDR pnm)
{
    LRESULT lReturn = 0;
    // HACKHACK: combobox (comctl32\comboex.c) will pass a LPNMHDR, but it's really
    // a PNMCOMBOBOXEX (which has a first element of LPNMHDR).  This function
    // can use this type cast iff it's guaranteed that this will only come from
    // a function that behaves in this perverse way.
    PNMCOMBOBOXEX pnmce = (PNMCOMBOBOXEX)pnm;

    ASSERT(pnm);
    switch (pnm->code)
    {
        case TTN_NEEDTEXT:
        {
            LPTOOLTIPTEXT pnmTT = (LPTOOLTIPTEXT)pnm;
            _GetURLToolTip(pnmTT->szText, ARRAYSIZE(pnmTT->szText));
            break;
        }

        case CBEN_DRAGBEGINA:
        {
            LPNMCBEDRAGBEGINA pnmbd = (LPNMCBEDRAGBEGINA)pnm;
            _OnDragBeginA(pnmbd);
            break;
        }

        case CBEN_DRAGBEGINW:

        {
            LPNMCBEDRAGBEGINW pnmbd = (LPNMCBEDRAGBEGINW)pnm;
            _OnDragBeginW(pnmbd);
            break;
        }

        case CBEN_GETDISPINFOW:
            _OnGetDispInfoW((PNMCOMBOBOXEXW)pnmce);
            break;

        case CBEN_GETDISPINFOA:
            _OnGetDispInfoA((PNMCOMBOBOXEXA) pnmce);
            break;

        case CBEN_DELETEITEM:
            if (pnmce->ceItem.lParam)
                ILFree((LPITEMIDLIST)pnmce->ceItem.lParam);
            break;

        default:
            lReturn = CAddressList::_OnNotify(pnm);
            break;
    }

    return lReturn;
}

/****************************************************\
    FUNCTION: _OnCommand
  
    DESCRIPTION:
        This function will handle WM_COMMAND messages.
\****************************************************/
LRESULT CSNSList::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch (GET_WM_COMMAND_CMD(wParam, lParam))
    {
    case CBN_CLOSEUP:
        if (_fPurgePending)
        {
            _fPurgePending = FALSE;
            _PurgeAndResetComboBox();
        }
        break;
    }

    return CAddressList::_OnCommand(wParam, lParam);
}

/****************************************************\
    PARAMETERS:
        LPSTR pszUrl - String Buffer that will contain the
                      URL as output.
        DWORD dwStrSize - Size of String buffer in characters.
  
    DESCRIPTION:
        Get the current URL.
\****************************************************/
HRESULT CSNSList::_GetURLToolTip(LPTSTR pszUrl, DWORD dwStrSize)
{
    ASSERT(pszUrl);
    if (!pszUrl)
        return E_INVALIDARG;

    LPITEMIDLIST pidlCur;
    HRESULT hr = _GetPIDL(&pidlCur); 
    if (S_OK == hr)
    {
        TCHAR szPidlName[MAX_URL_STRING];
        _GetPidlUI(pidlCur, szPidlName, ARRAYSIZE(szPidlName), NULL, NULL, SHGDN_FORPARSING, FALSE);
        lstrcpyn(pszUrl, szPidlName, dwStrSize);
        ILFree(pidlCur);
    }
    else
        pszUrl[0] = 0;

    return hr; 
}


/****************************************************\
    FUNCTION: _GetPIDL
  
    DESCRIPTION:
        This function returns a pointer to the current
    PIDL.  The caller will need to free the PIDL when
    it's no longer needed.  S_FALSE will be returned
    if there isn't a current PIDL.
\****************************************************/
HRESULT CSNSList::_GetPIDL(LPITEMIDLIST * ppidl)
{
    TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _GetPIDL() Begin");
    ASSERT(ppidl);
    if (!ppidl)
        return E_INVALIDARG;

    *ppidl = NULL;

    if (!_pbs)
    {
        DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
        TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _GetPIDL(), _cache.pidl=>%s<", Dbg_PidlStr(_cache.pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
        if (_cache.pidl)
            *ppidl = ILClone(_cache.pidl);
    }
    else
    {
        _pbs->GetPidl(ppidl);

        DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
        TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _GetPIDL(), Current Pidl in TravelLog. PIDL=>%s<", Dbg_PidlStr(*ppidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    }

    if (*ppidl)
        return S_OK;

    TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _GetPIDL() End");
    return S_FALSE;
}




/****************************************************\
  
    _AddItem - Adds one pidl to the address window
  
    Input:
        pidl - the pidl to add
        iInsert - where to insert
        iIndent - indentation level of pidl
  
\****************************************************/
void CSNSList::_AddItem(LPITEMIDLIST pidl, int iInsert, int iIndent)
{
    COMBOBOXEXITEM cei = { 0 };
    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _AddItem(). PIDL=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

    cei.pszText = LPSTR_TEXTCALLBACK;
    cei.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE | CBEIF_INDENT | CBEIF_LPARAM;
    cei.lParam = (LPARAM)ILClone(pidl);
    cei.iIndent = iIndent;
    cei.iItem = iInsert;
    cei.iImage = I_IMAGECALLBACK;
    cei.iSelectedImage = I_IMAGECALLBACK;
    ASSERT(_hwnd);
    SendMessage(_hwnd, CBEM_INSERTITEM, 0, (LPARAM)&cei);
}


/****************************************************\
  
    _GetFullIDList - Get the pidl associated with a combo index
  
    Input:
        iItem - the item to retrieve
  
    Return:
        The pidl at that index.
        NULL on error.
  
\****************************************************/
LPITEMIDLIST CSNSList::_GetFullIDList(int iItem)
{
    LPITEMIDLIST pidl;
    
    ASSERT(_hwnd);
    pidl = (LPITEMIDLIST)SendMessage(_hwnd, CB_GETITEMDATA, iItem, 0);
    if (pidl == (LPITEMIDLIST)CB_ERR)
    {
        pidl = NULL;
    }
    
    return pidl;
}


/****************************************************\
  
    _GetIndent - Get the indentation level of a combo index
  
    Input:
        iItem - the item to retrieve
  
    Return:
        The indentation level.
        -1 on error.
  
\****************************************************/
int CSNSList::_GetIndent(int iItem)
{
    int iIndent;
    COMBOBOXEXITEM cbexItem;

    cbexItem.mask = CBEIF_INDENT;
    cbexItem.iItem = iItem;
    ASSERT(_hwnd);
    if (SendMessage(_hwnd, CBEM_GETITEM, 0, (LPARAM)&cbexItem))
    {
        iIndent = cbexItem.iIndent;
    }
    else
    {
        iIndent = -1;
    }
    
    return iIndent;
}


/****************************************************\
    FUNCTION: _ExpandMyComputer
  
    DESCRIPTION:
        Find the "My Computer" entry in the drop down
    list and expand it.
\****************************************************/
void CSNSList::_ExpandMyComputer(int iDepth)
{
    LPITEMIDLIST pidlMyComputer = NULL;
    
    SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlMyComputer);
    if (pidlMyComputer)
    {
        LPITEMIDLIST pidl = NULL;
        BOOL fFound = FALSE;
        int nIndex = 0;

        while (pidl = _GetFullIDList(nIndex))
        {
            if (ILIsEqual(pidl, pidlMyComputer))
            {
                fFound = TRUE;
                break;
            }
            nIndex++;
        }
    
        if (fFound)
        {
            _FillOneLevel(nIndex, 2, iDepth);
        }

        ILFree(pidlMyComputer);
    }
}

/****************************************************\
  
    _FillOneLevel - find and add all of the children of one combo item
  
    Input:
        iItem - the item to expand
        iIndent - the indentation level of the children to add
        iDepth - the deepest indented item currently in the list
  
\****************************************************/
void CSNSList::_FillOneLevel(int iItem, int iIndent, int iDepth)
{
    LPITEMIDLIST pidl;
    
    pidl = _GetFullIDList(iItem);
    
    if (pidl)
    {
        HDPA hdpa;

        //
        // Fill hdps with all the children of this pidl.
        //
        hdpa = GetSortedIDList(pidl);
        if (hdpa)
        {
            int iCount, iInsert, i;
            LPITEMIDLIST pidlAlreadyThere;

            iCount = DPA_GetPtrCount(hdpa);

            //
            // The insert point starts right after parent.
            //
            iInsert = iItem + 1;

            //
            // Examine the next item.  If it is at the same level as
            // our soon-to-be-added children, remember it so we don't add
            // it twice.
            //
            pidlAlreadyThere = _GetFullIDList(iInsert);
            if (pidlAlreadyThere && (_GetIndent(iInsert) != iIndent))
            {
                pidlAlreadyThere = NULL;
            }

            //
            // Loop through each child.
            //
            for (i=0; i<iCount; i++, iInsert++)
            {
                LPITEMIDLIST pidlChild = (LPITEMIDLIST)DPA_GetPtr(hdpa, i);
                LPITEMIDLIST pidlInsert = ILClone(pidl);

                if (pidlInsert)
                {
                    ASSERT((LPVOID)pidlChild == (LPVOID)&pidlChild->mkid);
                    pidlInsert = ILAppendID(pidlInsert, &pidlChild->mkid, TRUE);
                    if (pidlInsert)
                    {
                        //
                        // If this item was already added, we need to skip over it
                        // and all of its children that have been inserted.
                        // Because we know how this list was constructed,
                        // we know the number of items is iDepth-iIndent.
                        //
                        if (pidlAlreadyThere && ILIsEqual(pidlInsert, pidlAlreadyThere))
                        {
                            //
                            // Skip over this item (it's already been added) and
                            // its children.
                            //
                            iInsert += iDepth - iIndent;
                        }
                        else
                        {
                            _AddItem(pidlInsert, iInsert, iIndent);
                        }
                        ILFree(pidlInsert);
                    }
                }
            }
            
            FreeSortedIDList(hdpa);
        }
    }
}


/****************************************************\
  
    _GetSelectedPidl - return the pidl of the combo selection
  
    Return:
        The selected pidl.
        NULL on error.
  
\****************************************************/
LPITEMIDLIST CSNSList::_GetSelectedPidl(void)
{
    LPITEMIDLIST pidl = NULL;
    
    ASSERT(_hwnd);
    int iSel = ComboBox_GetCurSel(_hwnd);
    if (iSel >= 0)
    {
        pidl = _GetFullIDList(iSel);
    }

    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _GetSelectedPidl(). PIDL=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    return pidl;
}


/****************************************************\
    FUNCTION: _GetPidlImage
  
    PARAMETERS:
        pidl - the pidl to get the icon index.
        piImage - Pointer to location to store result. (OPTIONAL)
        piSelectedImage - Pointer to location to store result. (OPTIONAL)
  
    DESCRIPTION:
        This function will retrieve information about the
    icon index for the pidl.
\****************************************************/
BOOL CSNSList::_GetPidlImage(LPCITEMIDLIST pidl, int *piImage, int *piSelectedImage)
{
    int * piImagePriv = piImage;
    int * piSelectedImagePriv = piSelectedImage;
    int iNotUsed;
    BOOL fFound = FALSE;

    if (!piImagePriv)
        piImagePriv = &iNotUsed;

    if (!piSelectedImagePriv)
        piSelectedImagePriv = &iNotUsed;

    *piImagePriv = -1;
    *piSelectedImagePriv = -1;

    // PERF OPTIMIZATION: We will call directly to the browser window
    // which is a performance savings.  We can only do this in the
    // following situation:
    // 1. We are connected to a browser window.  (Bar only).
    // 2. The current pidl in the browser window is equal to the pidlParent.
    
    if (_pbp && (_pbp->IsConnected() == S_OK) && _cache.pidl && ILIsEqual(pidl, _cache.pidl))
    {
        IOleCommandTarget * pcmdt;
        if (SUCCEEDED(_pbs->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pcmdt))))
        {
            VARIANT var = {0};
            HRESULT hresT = pcmdt->Exec(&CGID_ShellDocView, SHDVID_GETSYSIMAGEINDEX, 0, NULL, &var);
            if (SUCCEEDED(hresT)) 
            {
                if (var.vt==VT_I4) 
                {
                    *piImagePriv = var.lVal;
                    *piSelectedImagePriv = var.lVal;
                } 
                else 
                {
                    ASSERT(0);
                    VariantClearLazy(&var);
                }
            }
            pcmdt->Release();
        }
    }

    if (-1 == *piImagePriv || -1 == *piSelectedImagePriv)
    {
        _GetPidlIcon(pidl, piImagePriv, piSelectedImagePriv) ;
    }
    return TRUE;
}

// NOTE: show full file system path if we're running with IE4's shell32
// (the Win95/NT4 shell and the Win2000 shell don't show the
//  full file system path in the address bar by default)

HRESULT _GetAddressBarText(LPCITEMIDLIST pidl, DWORD dwFlags, LPTSTR pszName, UINT cchName)
{
    HRESULT hr;
    *pszName = 0;

    if ((GetUIVersion() >= 5) &&
        ((dwFlags & (SHGDN_INFOLDER | SHGDN_FORPARSING)) == SHGDN_FORPARSING))
    {
        // NOTE: we are under GetUIVersion() >= 5 so we can use the "SH" versions of these API
        DWORD dwAttrib = SFGAO_FOLDER | SFGAO_LINK;
        SHGetAttributesOf(pidl, &dwAttrib);
        if (dwAttrib & SFGAO_FOLDER)
        {
            // folder objects respect the FullPathAddress flag, files (.htm) do not
            BOOL bFullTitle = TRUE; // As of WinXP, we default to true for Show Full Path In Address Bar
            DWORD cbData = SIZEOF(bFullTitle);
            SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT( "\\CabinetState"), TEXT("FullPathAddress"), NULL, &bFullTitle, &cbData);
            if (!bFullTitle)
                dwFlags = SHGDN_INFOLDER;       // convert parsing name into normal name

            if ((dwFlags & SHGDN_FORPARSING) && (dwAttrib & SFGAO_LINK))
            {
                // folder shortcut special case
                IShellLinkA *psl;  // Use A version for W95.
                if (SUCCEEDED(SHGetUIObjectFromFullPIDL(pidl, NULL, IID_PPV_ARG(IShellLinkA, &psl))))
                {
                    LPITEMIDLIST pidlTarget;
                    if (SUCCEEDED(psl->GetIDList(&pidlTarget)) && pidlTarget)
                    {
                        hr = SHGetNameAndFlags(pidlTarget, dwFlags | SHGDN_FORADDRESSBAR, pszName, cchName, NULL);
                        ILFree(pidlTarget);
                    }
                    psl->Release();
                }
            }
        }
    }

    if (0 == *pszName)
    {
        if (!ILIsRooted(pidl))
            dwFlags |= SHGDN_FORADDRESSBAR;
    
        hr = IEGetNameAndFlags(pidl, dwFlags, pszName, cchName, NULL);
        if (SUCCEEDED(hr))
        {
            SHRemoveURLTurd(pszName);
            SHCleanupUrlForDisplay(pszName);
        }
    }
    return hr;
}

// This function will retrieve information about the
// pidl so the ComboBox item can be displayed.
//        pidl - the pidl to examine.
//        pszName - gets the name. (OPTIONAL)
//        cchName - size of pszName buffer. (OPTIONAL)
//        piImage - gets the icon index. (OPTIONAL)
//        dwFlags - SHGDN_ flags
//        piSelectedImage - gets selected icon index. (OPTIONAL)

BOOL CSNSList::_GetPidlUI(LPCITEMIDLIST pidl, LPTSTR pszName, int cchName, int *piImage, int *piSelectedImage, DWORD dwFlags, BOOL fIgnoreCache)
{
    ASSERT(pidl);
    if (pszName && cchName)
        *pszName = 0;

    if (!fIgnoreCache && _cache.pidl && (pidl == _cache.pidl || ILIsEqual(pidl, _cache.pidl)))
    {
        lstrcpyn(pszName, _cache.szName, cchName);
        if (piImage)
            *piImage = _cache.iImage;
        if (piSelectedImage)
            *piSelectedImage = _cache.iSelectedImage;
    }
    else 
    {
        if (pszName && cchName)
             _GetAddressBarText(pidl, dwFlags, pszName, cchName);

        if (piImage || piSelectedImage)
        {
            _GetPidlImage(pidl, piImage, piSelectedImage);
        }
    }
    return TRUE;
}

/****************************************************\
    PARAMETERS:
        pidl - the pidl to examine.

    RETURN:
        TRUE if cached pidl is changed, FALSE o/w.
  
    DESCRIPTION:
        This function will set the cache to the pidl
    that was passed in.  The cached pidl will be freeded.
    The caller still needs to free the pidl that was passed
    in because it will be cloned.
\****************************************************/
BOOL CSNSList::_SetCachedPidl(LPCITEMIDLIST pidl)
{
    BOOL fCacheChanged = FALSE;
    
    if ((_cache.pidl == NULL) || !ILIsEqual(_cache.pidl, pidl))
    {
        fCacheChanged = TRUE;

        _GetPidlUI(pidl, _cache.szName, ARRAYSIZE(_cache.szName), 
            &_cache.iImage, &_cache.iSelectedImage, SHGDN_FORPARSING, FALSE);

        if (_cache.pidl)
            ILFree(_cache.pidl);

        _cache.pidl = ILClone(pidl);
    }

    return fCacheChanged;
}


/****************************************************\
    PARAMETER:
        pnmce - PNMCOMBOBOXEXA which will come from the ComboBoxEx
                when in AddressBand mode.  The AddressBar uses
                the ANSI version of this data structure.

    DESCRIPTION:
        Handle the WM_NOTIFY/CBEN_GETDISPINFO message.
    We will call into _OnGetDispInfoW() to handle the
    call and then thunk the Text back into ANSI on
    the way out.
  
    Return:
        Standard WM_NOTIFY result.
\****************************************************/
LRESULT CSNSList::_OnGetDispInfoA(PNMCOMBOBOXEXA pnmce)
{
    LRESULT lResult = 0;
    LPWSTR  pszUniTemp;
    LPSTR pszAnsiDest;

    if (pnmce->ceItem.mask & (CBEIF_TEXT))
    {
        pszUniTemp = (LPWSTR)LocalAlloc(LPTR, pnmce->ceItem.cchTextMax * SIZEOF(WCHAR));
        if (pszUniTemp)
        {
            pszAnsiDest = pnmce->ceItem.pszText;
            ((PNMCOMBOBOXEXW)pnmce)->ceItem.pszText = pszUniTemp;

            lResult = _OnGetDispInfoW((PNMCOMBOBOXEXW)pnmce);
            SHUnicodeToAnsi(pszUniTemp, pszAnsiDest, pnmce->ceItem.cchTextMax);
            pnmce->ceItem.pszText = pszAnsiDest;
            LocalFree((VOID*)pszUniTemp);
        }
    }

    return lResult;
}


/****************************************************\
    Handle the WM_NOTIFY/CBEN_GETDISPINFO message.
  
    Input:
        pnmce - the notify message.
  
    Return:
        Standard WM_NOTIFY result.
\****************************************************/
LRESULT CSNSList::_OnGetDispInfoW(PNMCOMBOBOXEXW pnmce)
{
    if (pnmce->ceItem.lParam &&
        pnmce->ceItem.mask & (CBEIF_SELECTEDIMAGE | CBEIF_IMAGE | CBEIF_TEXT))
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)pnmce->ceItem.lParam;

        // Normal case - ask shell to give us icon and text of a pidl.
        if (_GetPidlUI(pidl, pnmce->ceItem.pszText, pnmce->ceItem.cchTextMax,
                             &pnmce->ceItem.iImage, &pnmce->ceItem.iSelectedImage, 
                             SHGDN_INFOLDER, TRUE))
        {
            pnmce->ceItem.mask = CBEIF_DI_SETITEM | CBEIF_SELECTEDIMAGE |
                                 CBEIF_IMAGE | CBEIF_TEXT;
        }
    }

    return 0;
}


/*******************************************************************
    DESCRIPTION:
        This function will set the CShellUrl parameter to the item
    in the Drop Down list that is indexed by nIndex.
********************************************************************/
HRESULT CSNSList::SetToListIndex(int nIndex, LPVOID pvShelLUrl)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl = _GetFullIDList(nIndex);
    CShellUrl * psuURL = (CShellUrl *) pvShelLUrl;

    if (pidl)
        hr = psuURL->SetPidl(pidl);
    ASSERT(SUCCEEDED(hr));  // Should Always Succeed.

    return hr;
}


LPITEMIDLIST CSNSList::_GetDragDropPidl(LPNMCBEDRAGBEGINW pnmcbe)
{
    LPITEMIDLIST pidl;
    
    if (pnmcbe->iItemid == -1) 
    {
        pidl = ILClone(_cache.pidl);
    }
    else 
    {
        pidl = ILClone(_GetFullIDList(pnmcbe->iItemid));
    }
    return pidl;
}

HRESULT CSNSList::FileSysChangeAL(DWORD dw, LPCITEMIDLIST *ppidl)
{
    switch (dw)
    {
    case SHCNE_UPDATEIMAGE:
    case SHCNE_UPDATEITEM:
        _PopulateOneItem(TRUE);
        break;
    
    default:

        // Don't purge the combo box if it is dropped; that confuses
        // too many people.  For example, addrlist.cpp caches the
        // *index* of the current item, and purging causes all the indexes
        // to change...

        if (SendMessage(_hwnd, CB_GETDROPPEDSTATE, 0, 0)) {
            _fPurgePending = TRUE;
        } else {
            _PurgeAndResetComboBox();
        }
        break;
    }
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information


#include "priv.h"

#ifndef FAVORITESTOSHDOCVW

#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif

#include "stdafx.h"

// HACKHACK (scotth): windowsx.h #define SubclassWindow.  ATL 2.1 headers
//  (namely atlwin.h and atlwin.cpp) have a member function with the
//  same name.
#ifdef SubclassWindow
#undef SubclassWindow
#endif

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#undef ATL_DEBUG_QI 
#include <atlimpl.cpp>

//HACK!!!!
#ifndef ATL_ENABLED
#define OleCreatePropertyFrame(a, b, c, d, e, f, g, h, i, j, k) S_OK
#endif


#include <atlctl.cpp>
#include <atlwin.cpp>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\shbrows2.cpp ===
#include "priv.h"

#include "apithk.h"
#include "sccls.h"
#include "shbrows2.h"
#include "commonsb.h"
#include "resource.h"
#include "explore2.h"
#include <isguids.h>
#include "desktop.h"
#include <ntverp.h>
#include "bands.h"
#include "browbar.h"
#include "itbdrop.h"
#include "theater.h"
#include "itbar.h"
#include "idispids.h"
#include "bsmenu.h"
#include "legacy.h"
#include "mshtmcid.h"
#include <desktray.h>   // IDeskTray
#include "commonsb.h"
#include "onetree.h"
#include "cnctnpt.h"
#include "comcatex.h"
#include "util.h"
#include "uemapp.h"
#include <shobjidlp.h>
#include <subsmgr.h>
#include "trayp.h"
#include "oleacc.h"
// (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include <htmlhelp.h>
#include <varutil.h>
#include "idhidden.h"
#include "mediautil.h"

#include "mluisupp.h"

#define CWM_THEATERMODE                 (WM_USER + 400)
#define CWM_UPDATEBACKFORWARDSTATE      (WM_USER + 401)

#define SUPERCLASS CCommonBrowser

#define PERF_LOGGING 1

HRESULT IUnknown_GetClientDB(IUnknown *punk, IUnknown **ppdbc);

// Timer IDs
#define SHBTIMER_MENUSELECT     100

#define MENUSELECT_TIME         500     // .5 seconds for the menuselect delay

// Command group for private communication with CITBar
// 67077B95-4F9D-11D0-B884-00AA00B60104
const GUID CGID_PrivCITCommands = { 0x67077B95L, 0x4F9D, 0x11D0, 0xB8, 0x84, 0x00, 0xAA, 0x00, 0xB6, 0x01, 0x04 };
// Guid of Office's discussion band
// {BDEADE7F-C265-11d0-BCED-00A0C90AB50F}
EXTERN_C const GUID CLSID_DiscussionBand = { 0xbdeade7fL, 0xc265, 0x11d0, 0xbc, 0xed, 0x00, 0xa0, 0xc9, 0x0a, 0xb5, 0x0f };
// Guid of the Tip of the Day
//{4D5C8C25-D075-11d0-B416-00C04FB90376}
const GUID CLSID_TipOfTheDay =    { 0x4d5c8c25L, 0xd075, 0x11d0, 0xb4, 0x16, 0x00, 0xc0, 0x4f, 0xb9, 0x03, 0x76 };

// Used to see if the discussion band is registered for the CATID_CommBand
const LPCTSTR c_szDiscussionBandReg = TEXT("CLSID\\{BDEADE7F-C265-11d0-BCED-00A0C90AB50F}\\Implemented Categories\\{00021494-0000-0000-C000-000000000046}");

// FEATURE: Way back from 1997, ralphw thinks we should remove >iedefault from the following string
const TCHAR c_szHtmlHelpFile[]  = TEXT("%SYSTEMROOT%\\Help\\iexplore.chm>iedefault");

// Increment this when the saved structure changes
const WORD c_wVersion = 0x8002;

// This value will be initialized to 0 only when we are under IExplorer.exe
UINT g_tidParking = 0;

#define MAX_NUM_ZONES_ICONS         12
#define MAX_ZONE_DISPLAYNAME        260
UINT_PTR g_sysmenuTimer = 0;

void ITBar_ShowDW(IDockingWindow * pdw, BOOL fTools, BOOL fAddress, BOOL fLinks);
void RestrictItbarViewMenu(HMENU hmenu, IUnknown *punkBar);
BOOL IsExplorerWindow(HWND hwnd);
void _SetWindowIcon(HWND hwnd, HICON hIcon, BOOL bLarge);

//
// A named mutex is being used to determine if a critical operation exist, such as a file download.
// When we detect this we can prevent things like going offline while a download is in progress.
// To start the operation Create the named mutex. When the op is complete, close the handle.
// To see if any pending operations are in progress, Open the named mutex. Success/fail will indicate
// if any pending operations exist.  This mechanism is being used to determine if a file download is
// in progress when the user attempts to go offline.  If so, we prompt them to let them know that going 
// offline will cancel the download(s).
//
// Note:  (SECURITY)
//  If a malicious app squats on the "CritOpMutex" named mutex, there are two
//  potential ways this would impact us:
//  1)  If they squat as an object other than a mutex, then all our calls to
//      IsCriticalOperationPending() will return FALSE.  The impact of this
//      is negligable, and means that if the user is downloading a file and
//      they attempt to switch to "offline" mode we will not prompt the user
//      that switching to "offline" mode will cancel any/all file transfers
//      in progress (which we normally do) and simply silently end them.
//  2)  If they squat as a mutex object, then basically the opposite is true.
//      All our calls to IsCriticalOperationPending() will return TRUE.  The
//      impact of this is again negligable, and means that if a user attempts
//      to switch to "offline" mode, regardless of whether or not they may be
//      downloading a file they will be prompted to cancel any/all file
//      transfers in progress.
HANDLE g_hCritOpMutex = NULL;
const LPCSTR c_szCritOpMutexName = "CritOpMutex";
#define StartCriticalOperation()     ((g_hCritOpMutex = CreateMutexA(NULL, TRUE, c_szCritOpMutexName)) != (HANDLE)NULL)
#define EndCriticalOperation()       (CloseHandle(g_hCritOpMutex))
#define IsCriticalOperationPending() (((g_hCritOpMutex = OpenMutexA(MUTEX_ALL_ACCESS, TRUE, c_szCritOpMutexName)) != (HANDLE)NULL) && CloseHandle(g_hCritOpMutex))

#define REG_PATH_ZONEMAP              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap")
#define REG_VAL_HARDEN                TEXT("IEHarden")

#define MAX_FILECONTEXT_STRING (40)

#define VALIDATEPENDINGSTATE() ASSERT((_pbbd->_psvPending && _pbbd->_psfPending) || (!_pbbd->_psvPending && !_pbbd->_psfPending))

#define DM_NAV              TF_SHDNAVIGATE
#define DM_ZONE             TF_SHDNAVIGATE
#define DM_IEDDE            TF_SHDAUTO
#define DM_CANCELMODE       0
#define DM_UIWINDOW         0
#define DM_ENABLEMODELESS   0
#define DM_EXPLORERMENU     0
#define DM_BACKFORWARD      0
#define DM_PROTOCOL         0
#define DM_ITBAR            0
#define DM_STARTUP          0
#define DM_AUTOLIFE         0
#define DM_PALETTE          0
#define DM_SESSIONCOUNT     0
#define DM_FOCUS            0
#define DM_PREMERGEDMENU    DM_TRACE
#define DM_ONSIZE           DM_TRACE
#define DM_SSL              0
#define DM_SHUTDOWN         DM_TRACE
#define DM_MISC             0    // misc/tmp

extern IDeskTray * g_pdtray;
#define ISRECT_EQUAL(rc1, rc2) (((rc1).top == (rc2).top) && ((rc1).bottom == (rc2).bottom) && ((rc1).left == (rc2).left) && ((rc1).right == (rc2).right))

BOOL ViewIDFromViewMode(UINT uViewMode, SHELLVIEWID *pvid);

typedef struct _NAVREQUEST
{
    int cbNavData;
    BYTE *lpNavData;
    struct _NAVREQUEST *pnext;
} NAVREQUEST;

// copied from explore/cabwnd.h
#define MH_POPUP        0x0010
#define MH_TOOLBAR      0x0020

#define TBOFFSET_NONE   50
#define TBOFFSET_STD    0
#define TBOFFSET_HIST   1
#define TBOFFSET_VIEW   2

extern DWORD g_dwStopWatchMode;  // Shell performance mode


// Suite Apps Registry keys duplicated from dochost.cpp
#define NEW_MAIL_DEF_KEY            TEXT("Mail")
#define NEW_NEWS_DEF_KEY            TEXT("News")
#define NEW_CONTACTS_DEF_KEY        TEXT("Contacts")
#define NEW_CALL_DEF_KEY            TEXT("Internet Call")
#define NEW_APPOINTMENT_DEF_KEY     TEXT("Appointment")
#define NEW_MEETING_DEF_KEY         TEXT("Meeting")
#define NEW_TASK_DEF_KEY            TEXT("Task")
#define NEW_TASKREQUEST_DEF_KEY     TEXT("Task Request")
#define NEW_JOURNAL_DEF_KEY         TEXT("Journal")
#define NEW_NOTE_DEF_KEY            TEXT("Note")


#define SHELLBROWSER_FSNOTIFY_FLAGS (SHCNE_DRIVEADDGUI | SHCNE_SERVERDISCONNECT |     \
                                     SHCNE_MEDIAREMOVED | SHCNE_RMDIR | SHCNE_DELETE | \
                                     SHCNE_UPDATEDIR | SHCNE_NETUNSHARE |             \
                                     SHCNE_DRIVEREMOVED | SHCNE_UPDATEITEM |          \
                                     SHCNE_RENAMEFOLDER | SHCNE_UPDATEIMAGE |         \
                                     SHCNE_MEDIAINSERTED | SHCNE_DRIVEADD)

#define FAV_FSNOTIFY_FLAGS          (SHCNE_DISKEVENTS | SHCNE_UPDATEIMAGE)

#define GOMENU_RECENT_ITEMS         15
//
// Prototypes for "reset web settings" code
//
extern "C" HRESULT ResetWebSettings(HWND hwnd, BOOL *pfHomePageChanged);
extern "C" BOOL IsResetWebSettingsRequired(void);

const TCHAR c_szMenuItemCust[]      = TEXT("Software\\Policies\\Microsoft\\Internet Explorer");
const TCHAR c_szWindowUpdateName[]  = TEXT("Windows Update Menu Text");

#pragma warning(disable:4355)  // using 'this' in constructor

void CShellBrowser2::_PruneGoSubmenu(HMENU hmenu)
{
    // get by position since SHGetMenuFromID does a DFS and we are interested
    // in the one that is a direct child of hmenu and not some random menu
    // elsewhere in the hierarchy who might happen to have the same ID.

    int iPos = SHMenuIndexFromID(hmenu, FCIDM_MENU_EXPLORE);
    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;

    if (iPos >= 0 && GetMenuItemInfo(hmenu, iPos, TRUE, &mii) && mii.hSubMenu) {
        HMENU hmenuGo = mii.hSubMenu;

        // Remove everything after the first separator

        MENUITEMINFO mii;
        int iItem = 0;

        while (TRUE) {

            TCHAR szTmp[100];
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_TYPE;
            mii.dwTypeData = szTmp;
            mii.cch = ARRAYSIZE(szTmp);
        
            if (!GetMenuItemInfoWrap(hmenuGo, iItem++, TRUE, &mii))
                break;
        
            if (mii.fType == MFT_SEPARATOR) {
                // we must have hit the first seperator, delete the rest of the menu...
                for (int iDel = GetMenuItemCount(hmenuGo) - 1; iDel >= iItem; iDel--)
                    RemoveMenu(hmenuGo, iDel, MF_BYPOSITION);

                break;
            }
        }
    }
}

//
//  Okay, menus are weird because of the fifteen bazillion scenarios we
//  need to support.
//
//  There are several functions involved in menu editing.  _MenuTemplate,
//  and all the _OnXxxMenuPopup functions.
//
//  The job of _MenuTemplate is to do global menu munging.  These munges
//  once performed are permanent, so don't munge anything that changes
//  based on some random ambient condition.  The job of the _OnXxxMenuPopup
//  functions is to do per-instance last-minute munging.
//
//  Also, _MenuTemplate is the only place you can add or remove top-level
//  menu items.
//
//  fShell = TRUE means that this menu will be used for shell objects.
//  fShell = FALSE means that this menu will be used for web objects.
//
//  Now the rules...
//
//  NT5:
//      Tools present.
//      Shell: "Folder Options" on Tools (not View).
//      Web: "Internet Options" on Tools (not View).
//      FTP: "Internet Options" & "Folder Options" on Tools (not View).
//      Go under View (not top-level).
//
//  Non-NT5, fShell = TRUE, IsCShellBrowser() = TRUE (Single-pane)
//      Tools removed.
//      Shell: "Folder Options" on View (not Tools).
//      Web: "Internet Options" on View (not Tools).
//      FTP: "Internet Options" & "Folder Options" on View (not Tools).
//      Go on top-level (not under View).
//
//  Non-NT5, fShell = TRUE, IsCShellBrowser() = FALSE (Dual-pane)
//      Tools present.
//      Shell: "Folder Options" on View (not Tools).
//      Web: "Internet Options" on View (not Tools).
//      FTP: "Internet Options" & "Folder Options" on View (not Tools).
//      Go on top-level (not under View).
//
//  Non-NT5, fShell = FALSE, viewing web page:
//      Tools present.
//      Shell: "Folder Options" on Tools (not View).
//      Web: "Internet Options" on Tools (not View).
//      FTP: "Internet Options" & "Folder Options" on Tools (not View).
//      Go under View (not top-level).
//
//  Bonus details:
//      Restrictions.
//      Shell Options disabled if browser-only.
//

HMENU CShellBrowser2::_MenuTemplate(int id, BOOL fShell)
{
    HMENU hmenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(id));
    if (hmenu)
    {
        //
        //  According to the chart, there is only one scenario where
        //  we need to nuke the Tools menu:  Non-NT5 shell single-pane
        //
        if (IsCShellBrowser2() && fShell && GetUIVersion() < 5)
            DeleteMenu(hmenu, FCIDM_MENU_TOOLS, MF_BYCOMMAND);

        //
        //  According to the chart, Go vanishes from top-level on NT5
        //  and on non-shell scenarios.  It also vanishes if restricted.
        //
        if (GetUIVersion() >= 5 || !fShell || SHRestricted(REST_CLASSICSHELL)) {
            // get by position since DeleteMenu does a DFS & there are dup FCIDM_MENU_EXPLORE's
            int iPos = SHMenuIndexFromID(hmenu, FCIDM_MENU_EXPLORE);

            if (iPos >= 0)
                DeleteMenu(hmenu, iPos, MF_BYPOSITION);

        }

        // Nuke file menu if restricted
        if (SHRestricted(REST_NOFILEMENU))
            DeleteMenu(hmenu, FCIDM_MENU_FILE, MF_BYCOMMAND);

        // Nuke favorites menu if a rooted explorer or shell menu and classic shell is set
        // or if restricted
        if ((fShell && SHRestricted(REST_CLASSICSHELL)) 
            || SHRestricted2(REST_NoFavorites, NULL, 0))
            DeleteMenu(hmenu, FCIDM_MENU_FAVORITES, MF_BYCOMMAND);

        HMENU hmenuView = SHGetMenuFromID(hmenu, FCIDM_MENU_VIEW);
        if (hmenuView) {
            // Go appears in only one place, so this test is just
            // the reverse of the one that decided if Go stays
         