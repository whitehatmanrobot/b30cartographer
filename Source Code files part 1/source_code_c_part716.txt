(CSnapin*)pComponentData)->m_spConsole;
//    }
//    else  // We should have a non-null pComponent
//    {
         ATLASSERT(pComponent);         
         spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
//    }

         ATLASSERT(spConsole != NULL);

    hRc = RefreshItemInView(spConsole);
    if ( FAILED(hRc) )
    {
        //msgbox done by called func.
        goto Exit;
    }

    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    NodeMsgBox(IDS_MEMORY);
    
Exit:
    //
    // any way you get here, memory must be freed
    //
    delete pNotification;
    
    
    return hRc;
}

/*
 -  CFaxOutboundRoutingRuleNode::RefreshItemInView
 -
 *  Purpose:
 *      Call IResultData::UpdateItem for single item
 *
 *  Arguments:
 *      [in]    pConsole - the console interface
 *
 *  Return: OLE error code
 */
HRESULT CFaxOutboundRoutingRuleNode::RefreshItemInView(IConsole *pConsole)
{
    DEBUG_FUNCTION_NAME( _T("FaxOutboundRoutingRuleNode::RefreshItemInView"));
    HRESULT     hRc = S_OK;

    //
    // Need IResultData
    //
    CComQIPtr<IResultData, &IID_IResultData> pResultData(pConsole);
    ATLASSERT(pResultData != NULL);

    //
    // Update the result item
    //
    hRc = pResultData->UpdateItem(m_resultDataItem.itemID);
    if ( FAILED(hRc) )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Failure on pResultData->UpdateItem, (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);
        goto Exit;
    }

Exit:
    return hRc;
}


/*
 +
 +  CFaxOutboundRoutingRuleNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxOutboundRoutingRuleNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_GROUPS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxdevicegeneral.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxDeviceGeneral.cpp                                 //
//                                                                         //
//  DESCRIPTION   : prop pages of Inbox archive                            //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 17 2000 yossg                                                  //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxDeviceGeneral.h"
#include "Device.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FaxMMCPropertyChange.h"

#include "FaxMMCGlobals.h"

#include "FxsValid.h"
#include "dlgutils.h"
#include <faxres.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxDeviceGeneral::CppFaxDeviceGeneral(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             CSnapInItem *pParentNode,
             DWORD       dwDeviceID,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxDeviceGeneral>(pNode, NULL)
                                
{
    m_lpNotifyHandle   = hNotificationHandle;
    
    m_pParentNode      = NULL; //in case static-cast failed and wont change the pointer
    m_pParentNode      = static_cast <CFaxDeviceNode *> (pNode);

    m_pGrandParentNode = pParentNode; 

    m_dwDeviceID       = dwDeviceID;

    m_pFaxDeviceConfig = NULL;

    m_fAllReadyToApply = FALSE;
    m_fIsDialogInitiated = FALSE;

}

//
// Destructor
//
CppFaxDeviceGeneral::~CppFaxDeviceGeneral()
{
    if (NULL != m_pFaxDeviceConfig)
    {
        FaxFreeBuffer( m_pFaxDeviceConfig );
    }
    
    // Note - This needs to be called only once per property sheet.  
    // In our convention called in the general tab.
    if (NULL != m_lpNotifyHandle)
    {
        MMCFreeNotifyHandle(m_lpNotifyHandle);
        m_lpNotifyHandle = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxDeviceGeneral message handlers

/*
 -  CppFaxDeviceGeneral::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxDeviceGeneral::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::InitRPC"));
    
    HRESULT        hRc        = S_OK;
    DWORD          ec         = ERROR_SUCCESS;

    
    //
    // get RPC Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to GetFaxServerHandle. (ec: %ld)"), 
            ec);

        goto Error;
    }

    //
    // Retrieve the Device configuration
    //
    if (!FaxGetPortEx(m_pFaxServer->GetFaxServerHandle(), 
                      m_dwDeviceID, 
                      &m_pFaxDeviceConfig)) 
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to get device configuration. (ec: %ld)"), 
            ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Network Error was found. (ec: %ld)"), 
                ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    //For max verification
    ATLASSERT(m_pFaxDeviceConfig);

    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
        _T("Succeed to get device configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
    
    PageError(GetFaxServerErrorMsg(ec), m_hWnd);
    
Exit:
    return (hRc);
}


/*
 -  CppFaxDeviceGeneral::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxDeviceGeneral::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::PageInitDialog"));
    
    DWORD   ec  = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER( uiMsg );
    UNREFERENCED_PARAMETER( wParam );
    UNREFERENCED_PARAMETER( lParam );
    UNREFERENCED_PARAMETER( fHandled );

    //
    // init controls
    // 
    m_DescriptionBox.Attach(GetDlgItem(IDC_DEVICE_DESCRIPTION_EDIT));
    m_TSIDBox.Attach(GetDlgItem(IDC_DEVICE_TSID_EDIT));
    m_CSIDBox.Attach(GetDlgItem(IDC_DEVICE_CSID_EDIT));
    m_RingsBox.Attach(GetDlgItem(IDC_DEVICE_RINGS_EDIT));
    m_RingsSpin.Attach(GetDlgItem(IDC_DEVICE_RINGS_SPIN));
   
    m_DescriptionBox.SetLimitText(MAX_FAX_STRING_LEN-1);
    m_TSIDBox.SetLimitText(FXS_TSID_CSID_MAX_LENGTH);
    m_CSIDBox.SetLimitText(FXS_TSID_CSID_MAX_LENGTH);
    m_RingsBox.SetLimitText(FXS_RINGS_LENGTH);


    ATLASSERT(m_pFaxDeviceConfig);

    //
    // Description
    //
    m_DescriptionBox.SetWindowText(m_pFaxDeviceConfig->lptstrDescription);

    //
    // Rings
    //
    m_RingsSpin.SetRange(FXS_RINGS_LOWER, FXS_RINGS_UPPER);
    m_RingsSpin.SetPos((int)m_pFaxDeviceConfig->dwRings);
    
    //
    // CSID
    //
    m_CSIDBox.SetWindowText(m_pFaxDeviceConfig->lptstrCsid);
        
    //
    // Receive
    //
    switch ( m_pFaxDeviceConfig->ReceiveMode ) 
    {
        case FAX_DEVICE_RECEIVE_MODE_OFF:    // Do not answer to incoming calls
            CheckDlgButton(IDC_RECEIVE_CHECK, BST_UNCHECKED);
            CheckDlgButton(IDC_RECEIVE_AUTO_RADIO1, BST_CHECKED);
            EnableReceiveControls (FALSE);    
            break;

        case FAX_DEVICE_RECEIVE_MODE_AUTO:   // Automatically answer to incoming calls after dwRings rings
            CheckDlgButton(IDC_RECEIVE_CHECK, BST_CHECKED);
            CheckDlgButton(IDC_RECEIVE_AUTO_RADIO1, BST_CHECKED);
            EnableRingsControls (TRUE);
            break;

        case FAX_DEVICE_RECEIVE_MODE_MANUAL: // Manually answer to incoming calls - only FaxAnswerCall answers the call
            CheckDlgButton(IDC_RECEIVE_CHECK, BST_CHECKED);
            CheckDlgButton(IDC_RECEIVE_MANUAL_RADIO2, BST_CHECKED);
            EnableRingsControls (FALSE);
            break;
        
        default:
            ATLASSERT(FALSE);
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Unexpected m_pFaxDeviceConfig->ReceiveMode"));

    }
    
    if(m_pFaxServer->GetServerAPIVersion() == FAX_API_VERSION_0)
    {
        //
        // The remote fax server is SBS/BOS 2000
        // is does not support manual answering
        //
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_RECEIVE_MANUAL_RADIO2), FALSE);

        ATLASSERT(IsDlgButtonChecked(IDC_RECEIVE_MANUAL_RADIO2) != BST_CHECKED);
    }

    //
    // TSID
    //
    m_TSIDBox.SetWindowText(m_pFaxDeviceConfig->lptstrTsid);
    
    //
    // Send
    //
    if (m_pFaxDeviceConfig->bSend) 
    {
        CheckDlgButton(IDC_SEND_CHECK, BST_CHECKED) ;
    }
    else
    {
        CheckDlgButton(IDC_SEND_CHECK, BST_UNCHECKED) ;
        ::EnableWindow(GetDlgItem(IDC_DEVICE_TSID_EDIT),  FALSE);    
    }

    m_fIsDialogInitiated = TRUE;

    return (1);

}

/*
 -  CppFaxDeviceGeneral::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxDeviceGeneral::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::SetProps"));

    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;

    HINSTANCE     hInst     = _Module.GetResourceInstance();

    CComBSTR    bstrDescription = L"";
    CComBSTR    bstrCSID        = L"";
    CComBSTR    bstrTSID        = L"";

    FAX_PORT_INFO_EX   FaxDeviceConfig;

    ATLASSERT(m_dwDeviceID == m_pFaxDeviceConfig->dwDeviceID);

    CFaxDevicePropertyChangeNotification * pDevicePropPageNotification = NULL;

    ATLASSERT(TRUE == m_fAllReadyToApply);
    m_fAllReadyToApply = FALSE;
    
    //
    // Step 1: Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    ZeroMemory (&FaxDeviceConfig, sizeof(FAX_PORT_INFO_EX));

    FaxDeviceConfig.dwSizeOfStruct      = sizeof(FAX_PORT_INFO_EX);
    FaxDeviceConfig.dwDeviceID          = m_dwDeviceID;
    FaxDeviceConfig.lpctstrDeviceName   = m_pFaxDeviceConfig->lpctstrDeviceName;

    FaxDeviceConfig.lpctstrProviderName = m_pFaxDeviceConfig->lpctstrProviderName;
    FaxDeviceConfig.lpctstrProviderGUID = m_pFaxDeviceConfig->lpctstrProviderGUID;

    //
    // Description
    //
    if ( !m_DescriptionBox.GetWindowText(&bstrDescription))
    {
        *pCtrlFocus = IDC_DEVICE_DESCRIPTION_EDIT;
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to GetWindowText(&bstrDescription)"));
        ec = ERROR_OUTOFMEMORY;
        goto Error;
    }
    // We allow empty description string!
    FaxDeviceConfig.lptstrDescription = bstrDescription;
 
    //
    // Receive
    //
    if (IsDlgButtonChecked(IDC_RECEIVE_CHECK) == BST_CHECKED)   
    {
        if (IsDlgButtonChecked(IDC_RECEIVE_AUTO_RADIO1) == BST_CHECKED)   
        {
            FaxDeviceConfig.ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;
            
            //
            // new Rings
            //
            FaxDeviceConfig.dwRings    = (DWORD)m_RingsSpin.GetPos();
        }
        else //(IDC_RECEIVE_MANUAL_RADIO2) == BST_CHECKED)
        {
            FaxDeviceConfig.ReceiveMode = FAX_DEVICE_RECEIVE_MODE_MANUAL;
        
            //
            // Rings and CSID stay as is
            //
            FaxDeviceConfig.dwRings    = m_pFaxDeviceConfig->dwRings;
        }

        //
        // new CSID
        //
        if ( !m_CSIDBox.GetWindowText(&bstrCSID))
        {
            *pCtrlFocus = IDC_DEVICE_CSID_EDIT;
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to GetWindowText(&bstrCSID)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
        //We allow empty CSID.
        FaxDeviceConfig.lptstrCsid = bstrCSID;
    }
    else
    {
        FaxDeviceConfig.ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
        
        //
        // Rings and CSID stay as is
        //
        FaxDeviceConfig.dwRings    = m_pFaxDeviceConfig->dwRings;
        FaxDeviceConfig.lptstrCsid = m_pFaxDeviceConfig->lptstrCsid;
    }
    
 
    //
    // Send
    //
    if (IsDlgButtonChecked(IDC_SEND_CHECK) == BST_CHECKED)   
    {
        FaxDeviceConfig.bSend = TRUE;

        //
        // new TSID
        //
        if ( !m_TSIDBox.GetWindowText(&bstrTSID))
        {
            *pCtrlFocus = IDC_DEVICE_TSID_EDIT;
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to GetWindowText(&bstrTSID)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
        //we allow empty TSID!
        FaxDeviceConfig.lptstrTsid = bstrTSID;
        
    }
    else
    {
        FaxDeviceConfig.bSend   = FALSE;
        //
        // TSID stay as is
        //
        FaxDeviceConfig.lptstrTsid = m_pFaxDeviceConfig->lptstrTsid;
    }
   
    //
    // Step 2: Set data via RPC
    //
    
    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to GetFaxServerHandle. (ec: %ld)"), 
            ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetPortEx(
                m_pFaxServer->GetFaxServerHandle(),
                m_dwDeviceID,
                &FaxDeviceConfig)) 
    {       
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to Set device configuration. (ec: %ld)"), 
            ec);

        if ( FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED == ec )
        {
            hRc = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            
            DlgMsgBox(this, IDS_ERR_ADMIN_DEVICE_LIMIT, MB_OK|MB_ICONEXCLAMATION);

            goto Exit;
        }
        
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Network Error was found. (ec: %ld)"), 
                ec);
            
            m_pFaxServer->Disconnect();       
        }
        
        goto Error;
    }

    DebugPrintEx( DEBUG_MSG,
        _T("Succeed to set device configuration."));

    //
    // Step 3: Update MMC
    //

    //
    // Prepare the notification fields before submit
    //
    pDevicePropPageNotification = new CFaxDevicePropertyChangeNotification();
    if (!pDevicePropPageNotification)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx( 
            DEBUG_ERR, 
            _T("Out of Memory - fail to operate new for CFaxDevicePropertyChangeNotification"));

        goto Error;
    }

    pDevicePropPageNotification->dwDeviceID = m_dwDeviceID;
    
    //
    // We have decided that we'll refresh all devices on a 
    // manual receive enabling. If it gets FALSE, just the single device is refreshed.
    //
    pDevicePropPageNotification->fIsToNotifyAdditionalDevices = 
        ( (FAX_DEVICE_RECEIVE_MODE_MANUAL == FaxDeviceConfig.ReceiveMode) ? TRUE : FALSE );

    pDevicePropPageNotification->pItem       = m_pGrandParentNode;
    pDevicePropPageNotification->enumType    = DeviceFaxPropNotification;

    //
    // Send notification from the property sheet thread to the main MMC thread
    //
    hRc = MMCPropertyChangeNotify(m_lpNotifyHandle, reinterpret_cast<LPARAM>(pDevicePropPageNotification));
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to call MMCPropertyChangeNotify. (hRc: %08X)"), 
            hRc);
        
        PageError(IDS_FAIL_NOTIFY_MMCPROPCHANGE,m_hWnd);
        
        goto Exit;
    }

    //
    // To prevent deletion on error since it will be deleted 
    // by the reciever of the notification.
    //
    pDevicePropPageNotification =  NULL; 

    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    PropSheet_SetCurSelByID( GetParent(), IDD);         
    ATLASSERT(::IsWindow(m_hWnd));
    PageError(GetFaxServerErrorMsg(ec),m_hWnd);

Exit:    
    return(hRc);
}

/*
 -  CppFaxDeviceGeneral::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxDeviceGeneral::PreApply(int *pCtrlFocus)
{
    HRESULT hRc = S_OK;
    
    //
    // PreApply Checks
    //
    if (!AllReadyToApply(/*fSilent =*/ FALSE))
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }

    return(hRc);
}


/*
 -  CppFaxDeviceGeneral::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxDeviceGeneral::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::OnApply"));


    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;

    hRc = PreApply(&CtrlFocus);
    if (FAILED(hRc))
    {
        //Error Msg by called func.
        if (CtrlFocus)
        {
            GotoDlgCtrl(GetDlgItem(CtrlFocus));
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus);
        if (FAILED(hRc)) 
        {
            //Error Msg by called func.
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }

}

/*
 -  CppFaxDeviceGeneral::OnReceiveCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the sub controls 
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxDeviceGeneral::OnReceiveCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::OnReceiveCheckboxClicked"));
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }

    State = ( IsDlgButtonChecked(IDC_RECEIVE_CHECK) == BST_CHECKED );

    EnableReceiveControls(State);
    
    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_RingsBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else
        {
            SetModified(TRUE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
        else
        {
            SetModified(FALSE);
        }
    }

    return 1;
}

/*
 -  CppFaxDeviceGeneral::OnReceiveRadioButtonClicked
 -
 *  Purpose:
 *      Check status OnReceiveRadioButtonClicked
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CppFaxDeviceGeneral::OnReceiveRadioButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER (wNotifyCode);
    UNREFERENCED_PARAMETER (wID);
    UNREFERENCED_PARAMETER (hWndCtl);
    UNREFERENCED_PARAMETER (bHandled);

    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::OnReceiveRadioButtonClicked"));
    
    if ( IsDlgButtonChecked(IDC_RECEIVE_AUTO_RADIO1) == BST_CHECKED )
    {        
        EnableRingsControls(TRUE);
        
        ::SetFocus(GetDlgItem(IDC_DEVICE_RINGS_EDIT));
    }
    else //IDC_RECEIVE_MANUAL_RADIO2
    {
        EnableRingsControls(FALSE);
    }
   
    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( 
             ( IsDlgButtonChecked(IDC_RECEIVE_AUTO_RADIO1) == BST_CHECKED )
             &&
             (!m_RingsBox.GetWindowTextLength() )
           )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else
        {
            SetModified(TRUE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
        else
        {
            SetModified(FALSE);
        }
    }

    return 1;
}



/*
 +  CppFaxDeviceGeneral::OnSendCheckboxClicked
 +
 *  Purpose:
 *      Gray/Ungray sub copntrols 
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 -      1
 -
 */
LRESULT CppFaxDeviceGeneral::OnSendCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::OnSendCheckboxClicked"));
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }

    State = ( IsDlgButtonChecked(IDC_SEND_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_DEVICE_TSID_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_TSID_STATIC),  State);    
    
    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }
    else
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
    }
    //this is due to the fact that we allow empty CSID

    return 1;
}


/*
 -  CppFaxDeviceGeneral::DeviceTextChanged
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxDeviceGeneral::DeviceTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }
    else
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
    }

    return(1);
}


/*
 +  CppFaxDeviceGeneral::AllReadyToApply
 +
 *  Purpose:
 *      This function validate that no zero length strings 
 *      are found data areas that should be saved.
 *
 *  Arguments:
 *      [in] fSilent - boolean who defines if to pop up messages (FALSE)
 *           or not.(TRUE)
 *
 *  Return:
 -      BOOOLEAN
 -
 */
BOOL CppFaxDeviceGeneral::AllReadyToApply(BOOL fSilent)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::AllReadyToApply"));
    
    DWORD         ec  = ERROR_SUCCESS;
    
    HINSTANCE     hInst = _Module.GetResourceInstance();
    
    if ( 
         (IsDlgButtonChecked(IDC_RECEIVE_CHECK) == BST_CHECKED)
        &&
         (IsDlgButtonChecked(IDC_RECEIVE_AUTO_RADIO1) == BST_CHECKED)
       )
    {
        if ( !m_RingsBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero text length - m_RingsBox. (ec: %ld)"), 
                ec);
        
            if (!fSilent)
            {
                PageError(IDS_DEVICE_RINGS_EMPTY, m_hWnd, hInst);
                ::SetFocus(GetDlgItem(IDC_DEVICE_RINGS_EDIT));
            }
            return FALSE;    
        }
    }

    //we allow empty tsid
    //we allow empty csid
    //we allow empty description
    
    ATLASSERT(ERROR_SUCCESS == ec);
    
    //
    // Cheers! 
    //      ...every thing ready to apply now.
    //
    return TRUE;           
}

/*
 -  CppFaxDeviceGeneral::EnableRingsControls
 -
 *  Purpose:
 *      Enable/disable the Rings controls.
 *
 *  Arguments:
 *      [in] state - boolean value to enable TRUE or FALSE to disable
 *
 *  Return:
 *      void
 */
void CppFaxDeviceGeneral::EnableRingsControls(BOOL fState)
{

    //
    // enable/disable controls
    //
    ::EnableWindow(GetDlgItem(IDC_DEVICE_RINGS_EDIT),   fState);    
    ::EnableWindow(GetDlgItem(IDC_DEVICE_RINGS_SPIN),   fState);    
    ::EnableWindow(GetDlgItem(IDC_DEVICE_RINGS_STATIC), fState);    
}

/*
 -  CppFaxDeviceGeneral::EnableReceiveControls
 -
 *  Purpose:
 *      Enable/disable the Rings controls.
 *
 *  Arguments:
 *      [in] state - boolean value to enable TRUE or FALSE to disable
 *
 *  Return:
 *      void
 */
void CppFaxDeviceGeneral::EnableReceiveControls(BOOL fState)
{

    //
    // enable/disable controls
    //
    if(m_pFaxServer->GetServerAPIVersion() == CURRENT_FAX_API_VERSION)
    {
        ::EnableWindow(GetDlgItem(IDC_RECEIVE_MANUAL_RADIO2), fState);    
    }

    ::EnableWindow(GetDlgItem(IDC_RECEIVE_AUTO_RADIO1),   fState);        
    
    
    ::EnableWindow(GetDlgItem(IDC_DEVICE_CSID_EDIT), fState);    
    ::EnableWindow(GetDlgItem(IDC_CSID_STATIC),      fState);    

    //
    // Combined state
    //
    fState = fState && (IsDlgButtonChecked(IDC_RECEIVE_AUTO_RADIO1) == BST_CHECKED);
    EnableRingsControls(fState);    
}

//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxDeviceGeneral::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxDeviceGeneral::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxDeviceGeneral::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxdevicegeneral.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxDeviceGeneral.h                                   //
//                                                                         //
//  DESCRIPTION   : Fax Server Inbox prop page header file                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg  Created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXDEVICE_GENERAL_H_
#define _PP_FAXDEVICE_GENERAL_H_



#include "MyCtrls.h"
#include <proppageex.h>

//#include <windows.h>

class CFaxServer;    
class CFaxServerNode;
    
class CFaxDeviceNode;    
/////////////////////////////////////////////////////////////////////////////
// CppFaxDeviceGeneral dialog

class CppFaxDeviceGeneral : public CPropertyPageExImpl<CppFaxDeviceGeneral>
{

public:
    //
    // Constructor
    //
    CppFaxDeviceGeneral(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             CSnapInItem    *pParentNode,
             DWORD          dwDeviceID,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxDeviceGeneral();

	enum { IDD = IDD_FAXDEVICE_GENERAL };

	BEGIN_MSG_MAP(CppFaxDeviceGeneral)
		MESSAGE_HANDLER( WM_INITDIALOG,                      OnInitDialog )

        COMMAND_HANDLER( IDC_DEVICE_DESCRIPTION_EDIT, 
                                                 EN_CHANGE,  DeviceTextChanged )

        COMMAND_HANDLER( IDC_RECEIVE_CHECK,      BN_CLICKED, OnReceiveCheckboxClicked )
        COMMAND_HANDLER( IDC_RECEIVE_AUTO_RADIO1  ,  BN_CLICKED, OnReceiveRadioButtonClicked)
        COMMAND_HANDLER( IDC_RECEIVE_MANUAL_RADIO2,  BN_CLICKED, OnReceiveRadioButtonClicked)
		COMMAND_HANDLER( IDC_DEVICE_RINGS_EDIT,  EN_CHANGE,  DeviceTextChanged )
        COMMAND_HANDLER( IDC_DEVICE_CSID_EDIT,   EN_CHANGE,  DeviceTextChanged )

		COMMAND_HANDLER( IDC_SEND_CHECK,         BN_CLICKED, OnSendCheckboxClicked )
        COMMAND_HANDLER( IDC_DEVICE_TSID_EDIT,   EN_CHANGE,  DeviceTextChanged )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxDeviceGeneral>)
	END_MSG_MAP()

	//
	// Dialog's Handler and events.
	//
	HRESULT InitRPC( );

    LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();


    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus);

private:
    //
    // Control members
    //
    CEdit         m_DescriptionBox;
    CEdit         m_CSIDBox;
    CEdit         m_TSIDBox;

    CEdit         m_RingsBox;
    CMyUpDownCtrl m_RingsSpin;

    //
    // Boolean members
    //
    BOOL  m_fAllReadyToApply;
    BOOL  m_fIsDialogInitiated;

    //
    // Config Structure member
    //
    PFAX_PORT_INFO_EX  m_pFaxDeviceConfig;
    DWORD              m_dwDeviceID;

    //
    // Handles
    //
    CFaxDeviceNode *   m_pParentNode;    
    CSnapInItem *      m_pGrandParentNode;
    LONG_PTR           m_lpNotifyHandle;

    //
    // Event methods
    //
    LRESULT OnReceiveCheckboxClicked    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnReceiveRadioButtonClicked (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSendCheckboxClicked       (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
 
    LRESULT DeviceTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    BOOL AllReadyToApply(BOOL fSilent);
    
    void EnableRingsControls(BOOL fState);
    void EnableReceiveControls(BOOL fState);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};




#endif // _PP_FAXDEVICE_GENERAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxinboundroutingmethodgeneral.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxInboundRoutingMethodGeneral.h                     //
//                                                                         //
//  DESCRIPTION   : Fax Server Inbox prop page header file                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 15 1999 yossg  Created                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include <proppageex.h>

#ifndef _PP_FAXINBOUNDROUTINGMETHOD_GENERAL_H_
#define _PP_FAXINBOUNDROUTINGMETHOD_GENERAL_H_



#include "InboundRoutingMethod.h"


class CFaxInboundRoutingMethodNode;    
/////////////////////////////////////////////////////////////////////////////
// CppFaxInboundRoutingMethod dialog

class CppFaxInboundRoutingMethod : public CPropertyPageExImpl<CppFaxInboundRoutingMethod>
{

public:
    //
    // Constructor
    //
    CppFaxInboundRoutingMethod(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxInboundRoutingMethod();

	enum { IDD = IDD_FAXINMETHOD_GENERAL };

	BEGIN_MSG_MAP(CppFaxInboundRoutingMethod)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxInboundRoutingMethod>)
	END_MSG_MAP()


    LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();


    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus);

private:
    
    CComBSTR   m_buf;

    //
    // Handles
    //
    CFaxInboundRoutingMethodNode *   m_pParentNode;    
 
    LONG_PTR   m_lpNotifyHandle;

    
    LRESULT SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};




#endif // _PP_FAXINBOUNDROUTINGMETHOD_GENERAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxoutboundroutingrule.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxOutboundRoutingRule.cpp                           //
//                                                                         //
//  DESCRIPTION   : prop pages of Outbound Routing Methods                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan  9 2000 yossg  Created                                         //
//      Jan 25 2000 yossg  Change the Dialog Design                        //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxOutboundRoutingRule.h"
#include "DlgSelectCountry.h"
#include "FaxMMCGlobals.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "dlgutils.h"
#include "FaxMMCPropertyChange.h" 

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxOutboundRoutingRule::CppFaxOutboundRoutingRule(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxOutboundRoutingRule>(pNode,NULL)
			                	
{
    m_lpNotifyHandle   = hNotificationHandle;

    m_pFaxDevicesConfig = NULL;
    m_dwNumOfDevices    = 0;

    m_pFaxGroupsConfig  = NULL;
    m_dwNumOfGroups     = 0;

    m_fAllReadyToApply  = FALSE;

    m_dwCountryCode     = 0;
    m_dwAreaCode        = 0;
    m_dwDeviceID        = 0;
    m_bstrGroupName     = L"";

    m_fIsDialogInitiated = FALSE;
    m_fIsDirty          = FALSE;

}

//
// Destructor
//
CppFaxOutboundRoutingRule::~CppFaxOutboundRoutingRule()
{
    if (NULL != m_pFaxDevicesConfig)
        FaxFreeBuffer(m_pFaxDevicesConfig);

    if (NULL != m_pFaxGroupsConfig)
        FaxFreeBuffer(m_pFaxGroupsConfig);
    
    // Note - This needs to be called only once per property sheet.  
    // In our convention called in the general tab.
    if (NULL != m_lpNotifyHandle)
    {
        MMCFreeNotifyHandle(m_lpNotifyHandle);
        m_lpNotifyHandle = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxOutboundRoutingRule message handlers


/*
 -  CppFaxOutboundRoutingRule::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxOutboundRoutingRule::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::PageInitDialog"));
    
	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );
    
    HRESULT hRc = S_OK;

    int k, l;
    k = l = 0;
    
    const int   iAllDevicesComboIndex     = 0;
    int         iAllDevicesRPCIndex       = 0;
    int         iGroupListIndexToSelect   = 0;
    
    HINSTANCE hInst = _Module.GetResourceInstance();
    PFAX_TAPI_LINECOUNTRY_ENTRYW pCountryEntries = NULL;

    WCHAR buf[FXS_MAX_DISPLAY_NAME_LEN+1];

    WCHAR buffAreaCode[FXS_MAX_AREACODE_LEN+1];
    int iCount;

    //
    // Attach controls
    //
    m_CountryCodeEdit.Attach(GetDlgItem(IDC_RULE_COUNTRYCODE_EDIT1));
    m_AreaCodeEdit.Attach(GetDlgItem(IDC_RULE_AREACODE_EDIT1));

    m_DeviceCombo.Attach(GetDlgItem(IDC_DEVICES4RULE_COMBO1));
    m_GroupCombo.Attach(GetDlgItem(IDC_GROUP4RULE_COMBO1));
        
    //
    // Set length limit to area code
    //
    m_CountryCodeEdit.SetLimitText(FXS_MAX_COUNTRYCODE_LEN -1);
    m_AreaCodeEdit.SetLimitText(FXS_MAX_AREACODE_LEN -1);

    //
    // Step 1: Init Lists
    //
    
    //
    // Init Country code edit box (below)
    //

    //
    // Init Devices
    //
    for (k = 0; (DWORD)k < m_dwNumOfDevices; k++ )
    {   
        hRc = AddComboBoxItem ( m_DeviceCombo, 
                                m_pFaxDevicesConfig[k].lpctstrDeviceName, 
                                m_pFaxDevicesConfig[k].dwDeviceID,
                                hInst);
        if (FAILED(hRc))
        {
		    DebugPrintEx(
			    DEBUG_ERR, _T("Fail to load device list."));
            PageError(IDS_FAIL2LOADDEVICELIST, m_hWnd, hInst);
            ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO1), FALSE);
            goto Cleanup;
        }

    }
        
    //
    // Init groups
    //
    for (l = 0; (DWORD)l < m_dwNumOfGroups; l++ )
    {   
        if ( 0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, m_pFaxGroupsConfig[l].lpctstrGroupName))
        {
            iAllDevicesRPCIndex = l;
            //Do not do any more;
		}
        else
		{
			hRc = AddComboBoxItem ( m_GroupCombo, 
									m_pFaxGroupsConfig[l].lpctstrGroupName, 
									(DWORD)l,
									hInst);
			if (FAILED(hRc))
			{
		        DebugPrintEx( DEBUG_ERR, _T("Fail to load group list."));
				PageError(IDS_FAIL2LOADDEVICELIST, m_hWnd, hInst);
                ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO), FALSE);
				goto Cleanup;
			}
		}

        //
        // Moreover we'll pick the the index of selected group
        //
        if ( m_fIsGroup)
        {
            if ( 0 == wcscmp( m_bstrGroupName, m_pFaxGroupsConfig[l].lpctstrGroupName))
            {
                iGroupListIndexToSelect = l;
            }
        }
    }
    if (!LoadString(hInst, IDS_ALL_DEVICES, buf, FXS_MAX_DISPLAY_NAME_LEN))
    {
        hRc = E_OUTOFMEMORY;
		DebugPrintEx( DEBUG_ERR, _T("Fail to load string. Out of memory."));
        PageError(IDS_FAXOUTOFMEMORY, m_hWnd, hInst);
        goto Cleanup;
    }
    //
    // insert "All Devices" Group as the first one in the groups list
    //
    ATLASSERT( 0 == iAllDevicesComboIndex );
    hRc = SetComboBoxItem ( m_GroupCombo, 
                            iAllDevicesComboIndex, 
                            buf, 
                            iAllDevicesRPCIndex,
                            hInst);
    if (FAILED(hRc))
    {
		DebugPrintEx( DEBUG_ERR, _T("Fail to load group list."));
        PageError(IDS_FAIL2LOADGROUPLIST, m_hWnd, hInst);
        ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO), FALSE);
        goto Cleanup;
    }


    //
    // Step 2: Set current status 
    //          (Select items in Lists, select radio button etc.)
    //          (Gray/UnGray controls)
    //

    //
    // Select Country in the list
    //
    if (ROUTING_RULE_COUNTRY_CODE_ANY != m_dwCountryCode)
    {
        int         iCountSring      =    0;
        WCHAR       szwCountryCode[FXS_MAX_COUNTRYCODE_LEN+1];

        iCountSring = swprintf(szwCountryCode, L"%ld", m_dwCountryCode);
        if( iCountSring <= 0 )
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to read member - m_dwCountryCode."));
            
            PageError(IDS_MEMORY, m_hWnd, hInst);
            
            goto Cleanup;
        }
        m_CountryCodeEdit.SetWindowText(szwCountryCode);

        if (ROUTING_RULE_AREA_CODE_ANY == m_dwAreaCode)
        {
            CheckDlgButton(IDC_COUNTRY_RADIO1, BST_CHECKED);
            ::EnableWindow(GetDlgItem(IDC_RULE_AREACODE_EDIT1), FALSE);
        }
        else
        {
            CheckDlgButton(IDC_AREA_RADIO1, BST_CHECKED);

            //
            // Set Area Code
            //
            iCount = swprintf(buffAreaCode,
                L"%ld", m_dwAreaCode);

            ATLASSERT(iCount > 0);
            if( iCount > 0 )
            {
                m_AreaCodeEdit.SetWindowText(buffAreaCode);
            }        
        }  

    }
    else //m_dwCountryCode == ROUTING_RULE_COUNTRY_CODE_ANY 
    {
        ::EnableWindow(GetDlgItem(IDC_RULETYPE_FSTATIC), FALSE);
        ::EnableWindow(GetDlgItem(IDC_COUNTRY1_STATIC), FALSE);
        ::EnableWindow(GetDlgItem(IDC_AREA_STATIC), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RULE_AREACODE_EDIT1), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RULE_SELECT_BUTTON1), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RULE_COUNTRYCODE_EDIT1), FALSE);
        ::EnableWindow(GetDlgItem(IDC_COUNTRY_RADIO1), FALSE);
        ::EnableWindow(GetDlgItem(IDC_AREA_RADIO1), FALSE);
    }


    if (!m_fIsGroup)
    {
        CheckDlgButton(IDC_DESTINATION_RADIO11, BST_CHECKED);
        
        //
        // Select device in the list
        //
        hRc = SelectComboBoxItemData(m_DeviceCombo, m_dwDeviceID);
        if ( FAILED(hRc))
        {
		    DebugPrintEx( DEBUG_ERR, _T("Fail to select device in combo box."));
            PageError(IDS_FAIL2LOADDEVICELIST, m_hWnd, hInst);
            ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO1), FALSE);
            
            goto Cleanup;
        }
        
        ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO1), FALSE);
    }
    else
    {
        CheckDlgButton(IDC_DESTINATION_RADIO21, BST_CHECKED) ;
        
        //
        // Select Group in list
        //
        hRc = SelectComboBoxItemData(m_GroupCombo, iGroupListIndexToSelect);
        if ( FAILED(hRc))
        {
            DebugPrintEx( DEBUG_ERR, _T("Fail to select group in combo box."));
            PageError(IDS_FAIL2LOADGROUPLIST, m_hWnd, hInst);
            ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO1), FALSE);
            
            goto Cleanup;
        }
        
        ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO1), FALSE);
        
    }  
    
    ATLASSERT(S_OK == hRc);
    m_fIsDialogInitiated = TRUE;        

Cleanup:

    return (1);

}

/*
 -  CppFaxOutboundRoutingRule::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxOutboundRoutingRule::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::SetProps"));

    HRESULT       hRc                  = S_OK;
    DWORD         ec                   = ERROR_SUCCESS;

    CComBSTR      bstrAreaCode;
    int           iCurrentSelectedItem = 0;
    
    DWORD         dwAreaCode           = 0;
    DWORD         dwCountryCode        = 0;

    BOOL          bUseGroup;
    DWORD         dwDeviceID           = 0;
    WCHAR         lpszGroupName[MAX_ROUTING_GROUP_NAME];
    
    LPCTSTR       lpctstrGroupName     = NULL;

    HINSTANCE     hInst;
    hInst = _Module.GetResourceInstance();
    
    CFaxRulePropertyChangeNotification * pRulePropPageNotification = NULL;
    CComBSTR bstrCountryName;
    
    //
    // Step 0: PreApply Checks
    //
    m_fAllReadyToApply = FALSE;
    if (!AllReadyToApply( FALSE))
    {
        SetModified(FALSE);  
        hRc = E_FAIL;
        goto Exit;
    }

    //
    // Step 1: get data
    //
    if (ROUTING_RULE_COUNTRY_CODE_ANY != m_dwCountryCode)
    {
        //
        // Country Code
        //

        CComBSTR bstrCountryCode;

        if ( !m_CountryCodeEdit.GetWindowText(&bstrCountryCode))
        {
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrCountryCode)"));
            DlgMsgBox(this, IDS_FAIL2READ_COUNTRYCODE);
            ::SetFocus(GetDlgItem(IDC_RULE_COUNTRYCODE_EDIT));
            hRc = S_FALSE;
        
            goto Exit;
        }
        dwCountryCode = (DWORD)wcstoul( bstrCountryCode, NULL, 10 );

        if (ROUTING_RULE_COUNTRY_CODE_ANY == dwCountryCode)
        {
            //
            // The user try to replace the country code to zero
            //
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT(" CountryCode == ROUTING_RULE_COUNTRY_CODE_ANY "));
            DlgMsgBox(this, IDS_ZERO_COUNTRYCODE);
            ::SetFocus(GetDlgItem(IDC_RULE_COUNTRYCODE_EDIT));
            hRc = S_FALSE;
        
            goto Exit;
        }

        //
        // Area Code
        //
        if ( IsDlgButtonChecked(IDC_COUNTRY_RADIO1) == BST_CHECKED )
        {
            dwAreaCode = (DWORD)ROUTING_RULE_AREA_CODE_ANY;        
        }
        else // IsDlgButtonChecked(IDC_AREA_RADIO1) == BST_CHECKED
        {	
            if ( !m_AreaCodeEdit.GetWindowText(&bstrAreaCode))
            {
		        DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Failed to GetWindowText(&bstrAreaCode)"));
                PageError(IDS_FAIL2READ_AREACODE, m_hWnd, hInst);
                ::SetFocus(GetDlgItem(IDC_RULE_AREACODE_EDIT1));
                hRc = E_FAIL ;
            
                goto Exit;
            }
            dwAreaCode = (DWORD)wcstoul( bstrAreaCode, NULL, 10 );
        }
        ATLASSERT(bstrCountryName);
    }
  
    if ( IsDlgButtonChecked(IDC_DESTINATION_RADIO11) == BST_CHECKED )
    {
        //
        // Use Group ?
        //
        bUseGroup = FALSE;
        
        //
        // Device
        //
        iCurrentSelectedItem = m_DeviceCombo.GetCurSel();
        ATLASSERT(iCurrentSelectedItem != CB_ERR); //should be chacked pre apply         
        dwDeviceID =  (DWORD)m_DeviceCombo.GetItemData (iCurrentSelectedItem);

    }
    else // IsDlgButtonChecked(IDC_DESTINATION_RADIO21) == BST_CHECKED
    {	
        //
        // Use Group ?
        //
        bUseGroup = TRUE;
 
        //
        // Group
        //
        
        iCurrentSelectedItem = m_GroupCombo.GetCurSel();
        //ATLASSERT(iCurrentSelectedItem != CB_ERR); //should be chacked pre apply        

        if (0 == iCurrentSelectedItem) //All Devices
        {
            lpctstrGroupName = ROUTING_GROUP_ALL_DEVICES;
        }
        else
        {
            ATLASSERT(MAX_ROUTING_GROUP_NAME > m_GroupCombo.GetLBTextLen(iCurrentSelectedItem)); //should be chacked by service before        
        
            m_GroupCombo.GetLBText( iCurrentSelectedItem, lpszGroupName );
            lpctstrGroupName = (LPCTSTR)lpszGroupName;
        }

    }

    
    //
    // Step 2: Configure Rule via RPC call
    //

    if (   
           (dwAreaCode != m_dwAreaCode) 
        || 
           (dwCountryCode != m_dwCountryCode)
       )
    {
        hRc = FaxReplaceRule(
                        dwAreaCode,       
                        dwCountryCode,    
                        bUseGroup,        
                        dwDeviceID,       
	                    lpctstrGroupName  
                        );
        if (FAILED(hRc))
        {
            //DebugPrint and MsgBox by called func.
            goto Exit;
        }
        else
        {
            m_dwAreaCode = dwAreaCode;
            m_dwCountryCode = dwCountryCode;
        }
    }
    else
    {
        //
        //(dwAreaCode == m_dwAreaCode) && 
        //(dwCountryCode == m_dwCountryCode)
        //
        hRc = FaxConfigureRule(
                        bUseGroup,       
                        dwDeviceID,
	                    lpctstrGroupName 
                        );
        if (FAILED(hRc))
        {
            //DebugPrint and MsgBox by called func.
            goto Exit;
        }
    }
    
        
    //
    // Step 3: Send notification to cause MMC view refresh  
    //	                      
   
    //
    // Prepare the notification fields before submit
    //
    pRulePropPageNotification = new CFaxRulePropertyChangeNotification();
    if (!pRulePropPageNotification)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx( DEBUG_ERR, _T("Out of Memory - fail to operate new"));

        goto Error;
    }

    pRulePropPageNotification->dwAreaCode = dwAreaCode;
    pRulePropPageNotification->dwCountryCode = dwCountryCode;
    pRulePropPageNotification->bstrCountryName = bstrCountryName;
    if (!pRulePropPageNotification->bstrCountryName)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx( DEBUG_ERR, _T("Out of Memory - fail to load string."));

        goto Error;
    }
    
    pRulePropPageNotification->fIsGroup = bUseGroup;
    if (pRulePropPageNotification->fIsGroup)
    {
        pRulePropPageNotification->bstrGroupName = lpctstrGroupName;
        if (!pRulePropPageNotification->bstrGroupName)
        {
            ec = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx( DEBUG_ERR, _T("Out of Memory - fail to load string."));

            goto Error;
        }
    }
    else
    {
        pRulePropPageNotification->dwDeviceID = dwDeviceID;
    }

    pRulePropPageNotification->pItem = (CSnapInItem *)m_pParentNode;
    pRulePropPageNotification->enumType = RuleFaxPropNotification;

    //
    // Notify MMC console thread
    //
    hRc = MMCPropertyChangeNotify(m_lpNotifyHandle, reinterpret_cast<LPARAM>(pRulePropPageNotification));
    if (FAILED(hRc))
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call MMCPropertyChangeNotify. (hRc: %08X)"), 
			hRc);
        
        ATLASSERT(NULL != m_pParentNode);
        PageError(IDS_FAIL_NOTIFY_MMCPROPCHANGE,m_hWnd);
        
        goto Exit;
    }

    //
    // To prevent deletion on error since it will be deleted 
    // by the reciever of the notification.
    //
    pRulePropPageNotification =  NULL; 
        
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    
    m_fIsDirty = FALSE;    
    
    DebugPrintEx( DEBUG_MSG,
		_T("The rule was added successfully."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    PropSheet_SetCurSelByID( GetParent(), IDD);         

    ATLASSERT(::IsWindow(m_hWnd));
    PageError(GetFaxServerErrorMsg(ec),m_hWnd);

    if (pRulePropPageNotification)
    {
        delete pRulePropPageNotification;
        pRulePropPageNotification = NULL;
    }

Exit:    
    return(hRc);
}

/*
 -  CppFaxOutboundRoutingRule::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxOutboundRoutingRule::PreApply(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::PreApply"));
    HRESULT  hRc  = S_OK;

    //
    // PreApply Checks
    //
    m_fAllReadyToApply = FALSE;
    if (!AllReadyToApply(/*fSilent =*/ FALSE))
    {
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        SetModified(TRUE);  
    }

    return(hRc);
}


/*
 -  CppFaxOutboundRoutingRule::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxOutboundRoutingRule::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::OnApply"));
    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;
        
    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = PreApply(&CtrlFocus);
    if (FAILED(hRc))
    {
        //Error Msg by called func.
        if (CtrlFocus)
        {
            GotoDlgCtrl(GetDlgItem(CtrlFocus));
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus);
        if (FAILED(hRc)) 
        {
            //Error Msg by called func.
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }
}


/*
 -  CppFaxOutboundRoutingRule::SetApplyButton
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1 (0)
 */
LRESULT CppFaxOutboundRoutingRule::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
      
    m_fIsDirty = TRUE;
    SetModified(TRUE);  
    bHandled = TRUE;
    
    return(1);
}

/*
 -  CppFaxOutboundRoutingRule::OnDestenationRadioClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxOutboundRoutingRule::OnDestenationRadioClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;


    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_DESTINATION_RADIO11) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO1), State);    
    
    ATLASSERT(!State == (IsDlgButtonChecked(IDC_DESTINATION_RADIO21) == BST_CHECKED)); 
    ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO1), !State);    

    if (State)//IsDlgButtonChecked(IDC_DESTINATION_RADIO11) == BST_CHECKED
    {
        if ( CB_ERR  ==  m_DeviceCombo.GetCurSel())
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);  
			goto Exit;
		}
		//else continue to whole controls check
    }
	else //IsDlgButtonChecked(IDC_DESTINATION_RADIO21) == BST_CHECKED
    {
		if ( CB_ERR  ==  m_GroupCombo.GetCurSel())
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);  
			goto Exit;
		}
		//else continue to whole controls check
    }

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
		else
		{
			//Should be EnableOK(FALSE);
		}
    }
Exit:
    return(1);
}

/*
 -  CppFaxOutboundRoutingRule::OnRuleTypeRadioClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxOutboundRoutingRule::OnRuleTypeRadioClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;


    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_COUNTRY_RADIO1) == BST_CHECKED );
    
    ATLASSERT(!State == ( IsDlgButtonChecked(IDC_AREA_RADIO1) == BST_CHECKED ) ); 
    ::EnableWindow(GetDlgItem(IDC_RULE_AREACODE_EDIT1), !State);    

    if (!State)//IsDlgButtonChecked(IDC_AREA_RADIO1) == BST_CHECKED
    {
        if ( !m_AreaCodeEdit.GetWindowTextLength() )
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);  
			goto Exit;
        }
		//else continue to whole controls check
    }
	//else //IsDlgButtonChecked(IDC_COUNTRY_RADIO1) == BST_CHECKED
    //Do noting - continue to whole controls check

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

Exit:
    return(1);
}


/*
 -  CppFaxOutboundRoutingRule::OnComboChanged
 -
 *  Purpose:
 *      Gray/Ungray the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT 
CppFaxOutboundRoutingRule::OnComboChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::OnComboChanged"));


    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return 0;
}

/*
 -  CppFaxOutboundRoutingRule::OnTextChanged
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CppFaxOutboundRoutingRule::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::OnTextChanged"));

    UINT fEnableOK = 0;
	

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    switch (wID)
	{
		case IDC_RULE_AREACODE_EDIT1:
			fEnableOK = ( m_AreaCodeEdit.GetWindowTextLength() );
			break;

		case IDC_RULE_COUNTRYCODE_EDIT1:
			fEnableOK = ( m_CountryCodeEdit.GetWindowTextLength() );

			break;

		default:
			ATLASSERT(FALSE);
	}
                    
    if(!!fEnableOK)
    {
        if (!m_fAllReadyToApply)
        {
            if (AllReadyToApply(TRUE))
            {
                m_fAllReadyToApply = TRUE;
                SetModified(TRUE);  
            }
        }
    }
    else
    {
        SetModified(FALSE);  
        m_fAllReadyToApply = FALSE;
    }

    return 0;
}

BOOL 
CppFaxOutboundRoutingRule::AllReadyToApply(BOOL fSilent)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::AllReadyToApply"));
	
    HINSTANCE     hInst;
    hInst = _Module.GetResourceInstance();

    if (ROUTING_RULE_COUNTRY_CODE_ANY != m_dwCountryCode)
    {
        if ( !m_CountryCodeEdit.GetWindowTextLength() )
        {
            if (!fSilent)
            {
                PageError(IDS_ZERO_COUNTRYCODE, m_hWnd, hInst);
                ::SetFocus(GetDlgItem(IDC_NEWRULE_COUNTRYCODE_EDIT));
            }
            return FALSE;
        }
        
        if ( IsDlgButtonChecked(IDC_AREA_RADIO1) == BST_CHECKED )
        {
            if ( !m_AreaCodeEdit.GetWindowTextLength() )
            {
                if (!fSilent)
                {
                    PageError(IDS_EMPTY_AREACODE, m_hWnd, hInst);
                    ::SetFocus(GetDlgItem(IDC_RULE_AREACODE_EDIT1));
                }
                return FALSE;    
            }
        }
        //else - Do noting
    }

    if ( IsDlgButtonChecked(IDC_DESTINATION_RADIO11) == BST_CHECKED )
    {
        if ( CB_ERR  ==  m_DeviceCombo.GetCurSel())
        {
            if (!fSilent)
            {
                PageError(IDS_PLEASESELECT_DEVICE, m_hWnd, hInst);
                ::SetFocus(GetDlgItem(IDC_DEVICES4RULE_COMBO1));
            }
            return FALSE;
        }
    }
    else if ( CB_ERR  ==  m_GroupCombo.GetCurSel())
    {
        if (!fSilent)
        {
            PageError(IDS_PLEASESELECT_GROUP, m_hWnd, hInst);
            ::SetFocus(GetDlgItem(IDC_GROUP4RULE_COMBO1));
        }
        return FALSE;
    }

    //
	// Cheers! 
	//		...every thing ready to apply now.
	//
	return TRUE;           
}


HRESULT CppFaxOutboundRoutingRule::InitFaxRulePP(CFaxOutboundRoutingRuleNode * pParentNode)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::InitFaxRulePP"));
    HRESULT      hRc        = S_OK; 
    DWORD        ec         = ERROR_SUCCESS;

    //
    // Step 0: Init Parent
    //
    m_pParentNode = pParentNode;
    
    
    //
    // Step 1: Init Lists from RPC
    //
    
    
    //
    // get Fax Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }
    
    //
    // Devices (id, name)
    //
    if (!FaxEnumPortsEx(m_pFaxServer->GetFaxServerHandle(), 
                        &m_pFaxDevicesConfig,
                        &m_dwNumOfDevices)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get devices configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	ATLASSERT(m_pFaxDevicesConfig);


    //
    // Groups (names)
    //
    if (!FaxEnumOutboundGroups(m_pFaxServer->GetFaxServerHandle(), 
                        &m_pFaxGroupsConfig,
                        &m_dwNumOfGroups)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get groups configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	ATLASSERT(m_pFaxGroupsConfig);


    //
    // Step 2 : Init members from parent
    //

    ATLASSERT(m_pParentNode);
    
    m_dwCountryCode = m_pParentNode->GetCountryCode();
    m_dwAreaCode    = m_pParentNode->GetAreaCode();
    m_fIsGroup      = m_pParentNode->GetIsGroup();
    
    if (m_fIsGroup)
    {
        m_bstrGroupName = m_pParentNode->GetGroupName();
        if (!m_bstrGroupName)
        {
            hRc = E_OUTOFMEMORY;
            goto Error;
        }
    }
    else
    {
        m_dwDeviceID = m_pParentNode->GetDeviceID();
    }


    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get all configurations."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
    
    //MsgBox will be done by calling Func.

Exit:
    return hRc;
}


/*
 -  CppFaxOutboundRoutingRule::FaxConfigureRule
 -
 *  Purpose:
 *      Configure the rule's device or group.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
HRESULT CppFaxOutboundRoutingRule::FaxConfigureRule(
                        BOOL fNewUseGroup,       
                        DWORD dwNewDeviceID,
	                    LPCTSTR lpctstrNewGroupName)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::FaxConfigureRule"));
    HRESULT      hRc          = S_OK; 
    DWORD        ec           = ERROR_SUCCESS;
    BOOL         fSkipMessage = FALSE;

    FAX_OUTBOUND_ROUTING_RULE     FaxRuleConfig;
    
    //
    // Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    ZeroMemory (&FaxRuleConfig, sizeof(FAX_OUTBOUND_ROUTING_RULE));

    //
    // Init the needed fields
    //
    FaxRuleConfig.dwSizeOfStruct = sizeof(FAX_OUTBOUND_ROUTING_RULE);

    FaxRuleConfig.dwAreaCode = m_dwAreaCode;
    FaxRuleConfig.dwCountryCode = m_dwCountryCode;

    FaxRuleConfig.bUseGroup = fNewUseGroup;
    if (fNewUseGroup)
    {
        FaxRuleConfig.Destination.lpcstrGroupName = lpctstrNewGroupName;
    }
    else
    {
        FaxRuleConfig.Destination.dwDeviceId = dwNewDeviceID;
    }

    //
    // get RPC Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        
        goto Error;
    }

    //
    // Configure the rule
    //
    if (!FaxSetOutboundRule (
	        m_pFaxServer->GetFaxServerHandle(),
	        &FaxRuleConfig))
    {
        ec = GetLastError();
        
        // specific
        if (FAX_ERR_BAD_GROUP_CONFIGURATION == ec)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("The group is empty or none of group devices is valid. (ec: %ld)"), 
			    ec);
            
            PageError(IDS_BAD_GROUP_CONFIGURATION, m_hWnd);
            fSkipMessage = TRUE;

            goto Error; 
        }
        
        //general
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to set rule %ld:%ld. (ec: %ld)"), 
			m_dwCountryCode, m_dwAreaCode, ec);
        
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("The rule was configured successfully."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
    
    if (!fSkipMessage)
    {
        PageError(GetFaxServerErrorMsg(ec),m_hWnd);
    }

Exit:    
    return(hRc);
}

/*
 -  CppFaxOutboundRoutingRule::FaxReplaceRule
 -
 *  Purpose:
 *      Configure the rule's device or group.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
HRESULT CppFaxOutboundRoutingRule::FaxReplaceRule(
                        DWORD   dwNewAreaCode,
                        DWORD   dwNewCountryCode,
                        BOOL    fNewUseGroup,       
                        DWORD   dwNewDeviceID,
	                    LPCTSTR lpctstrNewGroupName)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::FaxReplaceRule"));
    HRESULT      hRc        = S_OK; 
    DWORD        ec         = ERROR_SUCCESS;
    BOOL         fSkipMessage = FALSE;

    //
    // get RPC Handle
    //   
    
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Add the rule
    //
    if (!FaxAddOutboundRule (
	        m_pFaxServer->GetFaxServerHandle(),
	        dwNewAreaCode,
	        dwNewCountryCode,
	        dwNewDeviceID,
	        lpctstrNewGroupName,
	        fNewUseGroup))
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to add rule %ld:%ld. (ec: %ld)"), 
			m_dwCountryCode, m_dwAreaCode, ec);

        if (ERROR_DUP_NAME == ec) 
        {            
            DlgMsgBox(this, IDS_OUTRULE_EXISTS);
            goto Exit;
        }

        if (FAX_ERR_BAD_GROUP_CONFIGURATION == ec)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("The group is empty or none of group devices is valid. (ec: %ld)"), 
			    ec);
            
            PageError(IDS_BAD_GROUP_CONFIGURATION, m_hWnd);
            fSkipMessage = TRUE;

            goto Error; 
        }

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }

    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Step 1 - The new rule was added successfully."));
    
    if (!FaxRemoveOutboundRule (
	        m_pFaxServer->GetFaxServerHandle(),
	        m_dwAreaCode,
	        m_dwCountryCode))
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to remove rule. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Step 2 - The old rule was removed successfully."));
    
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
    if (!fSkipMessage)
    {
        PageError(GetFaxServerErrorMsg(ec),m_hWnd);
    }

Exit:    
    return(hRc);
}

/*
 -  CppFaxOutboundRoutingRule::OnSelectCountryCodeClicked
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
LRESULT
CppFaxOutboundRoutingRule::OnSelectCountryCodeClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)//(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::OnSelectCountryCodeClicked"));
    HRESULT     hRc         =    S_OK;
    INT_PTR     rc          =    IDOK;

    int         iCount      =    0;
    WCHAR       szwCountryCode[FXS_MAX_COUNTRYCODE_LEN+1];
    DWORD       dwCountryCode = 0;

    CDlgSelectCountry  DlgSelectCountry(m_pFaxServer);

    hRc = DlgSelectCountry.InitSelectCountryCodeDlg();
    if (S_OK != hRc)
    {
        //MsgBox + debug print by called func.
        goto Cleanup;
    }

    //
    // Dialog select country code
    //
    rc = DlgSelectCountry.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }

    //
    // Retreive CountryCode
    //
    dwCountryCode = DlgSelectCountry.GetCountryCode();

    iCount = swprintf(szwCountryCode, L"%ld", dwCountryCode);
    if( iCount <= 0 )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to read member - m_dwCountryCode."));
        goto Cleanup;
    }
    m_CountryCodeEdit.SetWindowText(szwCountryCode);

    //
    // EnableOK
    //
    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
		else
		{
			//Should be EnableOK(FALSE);
		}
    }

 
Cleanup:
    return hRc;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerSentItems::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxOutboundRoutingRule::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxOutboundRoutingRule::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxoutboundroutingrule.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxOutboundRoutingRule.h                             //
//                                                                         //
//  DESCRIPTION   : Fax Server Outbound routing rule prop page header file //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan  9 2000 yossg  Created                                         //
//      Jan 25 2000 yossg  Change the Dialog Design                        //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXOUTBOUNDROUTINGRULE_H_
#define _PP_FAXOUTBOUNDROUTINGRULE_H_

#include "OutboundRule.h"
#include "proppageex.h"
class CFaxOutboundRoutingRuleNode;    
/////////////////////////////////////////////////////////////////////////////
// CppFaxOutboundRoutingRule dialog

class CppFaxOutboundRoutingRule : public CPropertyPageExImpl<CppFaxOutboundRoutingRule>
{

public:
    //
    // Constructor
    //
    CppFaxOutboundRoutingRule(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxOutboundRoutingRule();

	enum { IDD = IDD_FAXOUTRULE_GENERAL };

	BEGIN_MSG_MAP(CppFaxOutboundRoutingRule)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )

        COMMAND_HANDLER(IDC_RULE_AREACODE_EDIT1, EN_CHANGE,     OnTextChanged)
        COMMAND_HANDLER(IDC_COUNTRY_RADIO1,      BN_CLICKED,    OnRuleTypeRadioClicked)
        COMMAND_HANDLER(IDC_AREA_RADIO1,         BN_CLICKED,    OnRuleTypeRadioClicked)
        COMMAND_HANDLER(IDC_DESTINATION_RADIO11, BN_CLICKED,    OnDestenationRadioClicked)
        COMMAND_HANDLER(IDC_DESTINATION_RADIO21, BN_CLICKED,    OnDestenationRadioClicked)

        COMMAND_HANDLER(IDC_RULE_COUNTRYCODE_EDIT1, EN_CHANGE,  OnTextChanged)
        COMMAND_HANDLER(IDC_RULE_SELECT_BUTTON1,    BN_CLICKED, OnSelectCountryCodeClicked)

        COMMAND_HANDLER(IDC_DEVICES4RULE_COMBO1, CBN_SELCHANGE, OnComboChanged)
        COMMAND_HANDLER(IDC_GROUP4RULE_COMBO1,   CBN_SELCHANGE, OnComboChanged)

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxOutboundRoutingRule>)
	END_MSG_MAP()


    LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();

    LRESULT OnTextChanged            (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnComboChanged           (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDestenationRadioClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRuleTypeRadioClicked   (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelectCountryCodeClicked (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    HRESULT InitFaxRulePP            (CFaxOutboundRoutingRuleNode * pParentNode);

    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus);


private:
    
    //
    // Handles
    //
    CFaxOutboundRoutingRuleNode *   m_pParentNode;    
    LONG_PTR                        m_lpNotifyHandle;
 
    //
    // Methods
    //
    LRESULT  SetApplyButton (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    BOOL     AllReadyToApply(BOOL fSilent);

    HRESULT FaxConfigureRule(BOOL fNewUseGroup, DWORD dwNewDeviceID, LPCTSTR lpctstrNewGroupName);
    HRESULT FaxReplaceRule(DWORD dwNewAreaCode, DWORD dwNewCountryCode, BOOL fNewUseGroup,       
                             DWORD dwNewDeviceID, LPCTSTR lpctstrNewGroupName);

    //
    // List members
    //
    PFAX_PORT_INFO_EX               m_pFaxDevicesConfig;
    DWORD                           m_dwNumOfDevices;

    PFAX_OUTBOUND_ROUTING_GROUP     m_pFaxGroupsConfig;
    DWORD                           m_dwNumOfGroups;

    //
    // Initial state members
    //
    DWORD                           m_dwCountryCode;
    DWORD                           m_dwAreaCode;

    DWORD                           m_dwDeviceID;
    CComBSTR                        m_bstrGroupName;
    BOOL                            m_fIsGroup;

    //
    // misc members 
    //
    CComBSTR                        m_buf;

    BOOL                            m_fAllReadyToApply;
    BOOL                            m_fIsDialogInitiated;
    BOOL                            m_fIsDirty;  

    //
    // Controls
    //
    CEdit                           m_CountryCodeEdit;

    CEdit                           m_AreaCodeEdit;

    CComboBox                       m_DeviceCombo;
    CComboBox                       m_GroupCombo;

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};




#endif // _PP_FAXOUTBOUNDROUTINGRULE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxprovidergeneral.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CppFaxProviderGeneral.cpp                              //
//                                                                         //
//  DESCRIPTION   : prop pages of Catalog's Inbox Routing Method           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 31 2000 yossg  Created                                         //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxProviderGeneral.h"
#include "FaxMMCGlobals.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxProvider::CppFaxProvider(
             long        hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxProvider>(pNode, NULL)
			                	
{
    m_lpNotifyHandle = hNotificationHandle;
}

//
// Destructor
//
CppFaxProvider::~CppFaxProvider()
{
    // Note - This needs to be called only once per property sheet.  
    // In our convention called in the general tab.
    if (NULL != m_lpNotifyHandle)
    {
        MMCFreeNotifyHandle(m_lpNotifyHandle);
        m_lpNotifyHandle = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxProvider message handlers


/*
 -  CppFaxProvider::Init
 -
 *  Purpose:
 *      Initiates all members
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxProvider::Init(CComBSTR bstrName, CComBSTR bstrStatus, CComBSTR bstrVersion, CComBSTR bstrPath)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxProvider::Init"));
    HRESULT hRc = S_OK;

    m_bstrName = bstrName;
    if (!m_bstrName)
    {
		DebugPrintEx( DEBUG_ERR, _T("Null m_bstrName - out of memory."));
        goto Error;
    }
    
    m_bstrStatus = bstrStatus;
    if (!m_bstrStatus)
    {
		DebugPrintEx( DEBUG_ERR, _T("Null m_bstrStatus - out of memory."));
        goto Error;
    }
    
    m_bstrVersion = bstrVersion;
    if (!m_bstrVersion)
    {
		DebugPrintEx( DEBUG_ERR, _T("Null m_bstrVersion - out of memory."));
        goto Error;
    }
    
    m_bstrPath = bstrPath;
    if (!m_bstrPath)
    {
		DebugPrintEx( DEBUG_ERR, _T("Null m_bstrPath - out of memory."));
        goto Error;
    }
    
    goto Exit;

Error:
    hRc = E_OUTOFMEMORY;

Exit:
    return hRc;
}



/*
 -  CppFaxProvider::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxProvider::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxProvider::PageInitDialog"));
    
	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );
    
    //
    // Version
    //
    SetDlgItemText(IDC_FSPVERSION_EDIT, m_bstrVersion);
   	
    //
    // Status
    //
    SetDlgItemText(IDC_FSPSTATUS_EDIT, m_bstrStatus);
   	
    //
    // DLL's full path
    //
    SetDlgItemText(IDC_FSPVPATH_EDIT, m_bstrPath);
   	
   	
    return (1);

}


/*
 -  CppFaxProvider::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxProvider::OnApply()
{

    return TRUE;
}


/*
 -  CppFaxProvider::SetApplyButton
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxProvider::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetModified(TRUE);  
    bHandled = TRUE;
    return(1);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxProvider::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxProvider::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxProvider::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxinboundroutingmethodgeneral.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxInboundRoutingMethodGeneral.cpp                   //
//                                                                         //
//  DESCRIPTION   : prop pages of Inbox archive                            //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 15 1999 yossg  Created                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxInboundRoutingMethodGeneral.h"
#include "FaxMMCGlobals.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxInboundRoutingMethod::CppFaxInboundRoutingMethod(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxInboundRoutingMethod>(pNode, NULL)
			                	
{
    m_pParentNode      = NULL; //in case static-cast failed and wont change the pointer
    m_pParentNode      = static_cast <CFaxInboundRoutingMethodNode *> (pNode);

    m_lpNotifyHandle   = hNotificationHandle;
}

//
// Destructor
//
CppFaxInboundRoutingMethod::~CppFaxInboundRoutingMethod()
{
    // Note - This needs to be called only once per property sheet.  
    // In our convention called in the general tab.
    if (NULL != m_lpNotifyHandle)
    {
        MMCFreeNotifyHandle(m_lpNotifyHandle);
        m_lpNotifyHandle = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxInboundRoutingMethod message handlers


/*
 -  CppFaxInboundRoutingMethod::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxInboundRoutingMethod::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxInboundRoutingMethod::PageInitDialog"));
    
	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );
    
    ATLASSERT(NULL != m_pParentNode);

    //
    // Name
    //
    SetDlgItemText(IDC_INMETHOD_NAME_STATIC,   
                     m_pParentNode->GetName());

    //
    // Status
    //    
    UINT uiIDS = ( m_pParentNode->GetStatus() ? IDS_INMETHOD_ENABLE : IDS_INMETHOD_DISABLE);

    if ( !m_buf.LoadString(_Module.GetResourceInstance(), uiIDS) )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to load string for status value."));
        //can not do nothing more here!
    }
    else
    {
        SetDlgItemText(IDC_INMETHOD_STATUS_STATIC, m_buf);
    }

    //
    // Extension
    //
    SetDlgItemText(IDC_INMETHOD_EXTENSION_STATIC, 
                     m_pParentNode->GetExtensionName());
    	
    return (1);

}

/*
 -  CppFaxInboundRoutingMethod::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxInboundRoutingMethod::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxInboundRoutingMethod::SetProps"));

    return (S_OK);
}

/*
 -  CppFaxInboundRoutingMethod::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxInboundRoutingMethod::PreApply(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxInboundRoutingMethod::PreApply"));

    return(S_OK);
}


/*
 -  CppFaxInboundRoutingMethod::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxInboundRoutingMethod::OnApply()
{

    return TRUE;
}


/*
 -  CppFaxInboundRoutingMethod::SetApplyButton
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxInboundRoutingMethod::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetModified(TRUE);  
    bHandled = TRUE;
    return(1);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxInboundRoutingMethod::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxInboundRoutingMethod::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxInboundRoutingMethod::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxprovidergeneral.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CppFaxProviderGeneral.h                                //
//                                                                         //
//  DESCRIPTION   : provider's property page header file.                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 31 2000 yossg  Created                                         //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXPROVIDERGENERAL_H_
#define _PP_FAXPROVIDERGENERAL_H_


#include "Provider.h"
#include "proppageex.h"

class CFaxProviderNode;    
/////////////////////////////////////////////////////////////////////////////
// CppFaxProvider dialog

class CppFaxProvider : public CPropertyPageExImpl<CppFaxProvider>
{

public:
    //
    // Constructor
    //
    CppFaxProvider(
             long           hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxProvider();

	enum { IDD = IDD_FAXPROVIDER_GENERAL };

	BEGIN_MSG_MAP(CppFaxProvider)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxProvider>)
	END_MSG_MAP()


    LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();

    HRESULT Init(CComBSTR bstrName, CComBSTR bstrStatus, CComBSTR bstrVersion, CComBSTR bstrPath);


private:
    
    //
    // Handles
    // 
    LONG_PTR     m_lpNotifyHandle;

    LRESULT      SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Members
    //
    CComBSTR     m_bstrName;
    CComBSTR     m_bstrStatus;    
    CComBSTR     m_bstrVersion;
    CComBSTR     m_bstrPath;


    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};




#endif // _PP_FAXPROVIDERGENERAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxserverevents.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerEvents.h                                    //
//                                                                         //
//  DESCRIPTION   : Fax Server Events prop page header file                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg   created                                        //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXSERVER_EVENTS_H_
#define _PP_FAXSERVER_EVENTS_H_

#include <proppageex.h>

class CFaxServerNode;

/////////////////////////////////////////////////////////////////////////////
// CppFaxServerEvents dialog

class CppFaxServerEvents : public CPropertyPageExImpl<CppFaxServerEvents>
{

public:
    //
    // Constructor
    //
    CppFaxServerEvents(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxServerEvents();

	enum { IDD = IDD_FAXSERVER_EVENTS };

	BEGIN_MSG_MAP(CppFaxServerEvents)
		MESSAGE_HANDLER( WM_INITDIALOG,  OnInitDialog )
		MESSAGE_HANDLER( WM_HSCROLL,     SliderMoved )
		
        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerEvents>)
	END_MSG_MAP()

	//
	// Dialog's Handler and events.
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();


    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus);
private:

    //
    // Control members
    //
    CTrackBarCtrl   m_InboundErrSlider;
    CTrackBarCtrl   m_OutboundErrSlider;
    CTrackBarCtrl   m_InitErrSlider;
    CTrackBarCtrl   m_GeneralErrSlider;

    //
    // Config Structure member
    //
    PFAX_LOG_CATEGORY  m_pFaxLogCategories;
    
    //
    // Handles and flags
    //
    CFaxServerNode *        m_pParentNode;    

    BOOL                    m_fIsDialogInitiated;
    BOOL                    m_fIsDirty;

    //
    // Event methods
    //
    LRESULT SliderMoved( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};


#endif // _PP_FAXSERVER_EVENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxserverevents.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerEvents.cpp                                  //
//                                                                         //
//  DESCRIPTION   : prop pages of event reports  policies                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov 24 1999 yossg  OnApply create call to all tabs from parent     //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerEvents.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxServerEvents::CppFaxServerEvents(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerEvents>(pNode, NULL)

{
    m_pParentNode           = static_cast <CFaxServerNode *> (pNode);
    m_pFaxLogCategories     = NULL;

    m_fIsDialogInitiated    = FALSE;
    m_fIsDirty              = FALSE;
}								


//
// Destructor
//
CppFaxServerEvents::~CppFaxServerEvents()
{
    if (NULL != m_pFaxLogCategories)
    {
        FaxFreeBuffer( m_pFaxLogCategories);
    }
}

#define FXS_NUM_OF_CATEGORIES 4
/////////////////////////////////////////////////////////////////////////////
// CppFaxServerEvents message handlers

/*
 -  CppFaxServerEvents::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerEvents::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerEvents::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;




    DWORD dwNumCategories;

    //
    // get RPC Handle
    //   


    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
	// Retrieve the fax Event Reports /Logging Policy configuration
	//
    if (!FaxGetLoggingCategories(m_pFaxServer->GetFaxServerHandle(), 
                           &m_pFaxLogCategories,
                           &dwNumCategories)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Logging Categories configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	// for max verification
	ATLASSERT(m_pFaxLogCategories);

    // internal assumeption in this version
    ATLASSERT( FXS_NUM_OF_CATEGORIES == dwNumCategories);
	
    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get Logging Categories configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}


/*
 -  CppFaxServerEvents::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxServerEvents::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerEvents::OnInitDialog"));
    
	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );

    int     iInboundLevel = 0,
            iOutboundLevel = 0,
            iInitLevel = 0,
            iGeneralLevel = 0;

    // Retrieve the Number of Categories
    const int iNumCategories = FXS_NUM_OF_CATEGORIES;

    int i;   // index

    //
    // Attach Controls
    //
    m_InitErrSlider.Attach(GetDlgItem(IDC_SLIDER4));
    m_InboundErrSlider.Attach(GetDlgItem(IDC_SLIDER2));
    m_OutboundErrSlider.Attach(GetDlgItem(IDC_SLIDER3));
    m_GeneralErrSlider.Attach(GetDlgItem(IDC_SLIDER1));
        
    //
    // Init sliders
    //
    m_InboundErrSlider.SetRange(0,FXS_MAX_LOG_REPORT_LEVEL - 1,TRUE);
    m_OutboundErrSlider.SetRange(0,FXS_MAX_LOG_REPORT_LEVEL - 1,TRUE);
    m_InitErrSlider.SetRange(0,FXS_MAX_LOG_REPORT_LEVEL - 1,TRUE);
    m_GeneralErrSlider.SetRange(0,FXS_MAX_LOG_REPORT_LEVEL - 1,TRUE);
    
    //
	// Verify the Number of Categories is the same 
    // as the code assumes (This version).
    // To avoid replacement of defined contant elsewhere
	//
    ATLASSERT (iNumCategories == 4);
        
    for (i = 0; i < iNumCategories; i++)
    {
        //for each category
        switch (m_pFaxLogCategories[i].Category)
        {
            case FAXLOG_CATEGORY_INIT:
                iInitLevel= m_pFaxLogCategories[i].Level;
                break;
            case FAXLOG_CATEGORY_OUTBOUND:
                iOutboundLevel= m_pFaxLogCategories[i].Level;
                break;
            case FAXLOG_CATEGORY_INBOUND:
                iInboundLevel= m_pFaxLogCategories[i].Level;
                break;
            case FAXLOG_CATEGORY_UNKNOWN:
                 iGeneralLevel= m_pFaxLogCategories[i].Level;
                break;
        }
    }
                
    //
    // Init slider Positions
    //
    m_InboundErrSlider.SetPos(iInboundLevel);
    m_OutboundErrSlider.SetPos(iOutboundLevel);
    m_InitErrSlider.SetPos(iInitLevel);
    m_GeneralErrSlider.SetPos(iGeneralLevel);

    m_fIsDialogInitiated = TRUE;

    return 1;
}

/*
 -  CppFaxServerEvents::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerEvents::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerEvents::SetProps"));
    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;



    int     iInboundErrPos, 
            iOutboundErrPos, 
            iInitErrPos, 
            iGeneralErrPos;

    FAX_LOG_CATEGORY  FaxLogCategories[FXS_NUM_OF_CATEGORIES] = {0};

    //
    // Our base assumption for this version
    //
    const int iNumCategories = FXS_NUM_OF_CATEGORIES;    
    ATLASSERT (iNumCategories == 4);

    //
    // Collect All Slider Positions
    //
    iInitErrPos     =  m_InitErrSlider.GetPos();
    iInboundErrPos  =  m_InboundErrSlider.GetPos();
    iOutboundErrPos =  m_OutboundErrSlider.GetPos();
    iGeneralErrPos  =  m_GeneralErrSlider.GetPos();

    //
    // Prepare all structure fields
	//
	// notice: legacy EnumLoggingChanges in the server's code depends on the order only!
    //         our code indentifies the categories by their unique id number - the Category DWORD field
    //
    FaxLogCategories[0].Name = L"Initialization/Termination"; //NOT to be localized a registry info only
    FaxLogCategories[0].Category = FAXLOG_CATEGORY_INIT;
    FaxLogCategories[0].Level = (DWORD)iInitErrPos;

    FaxLogCategories[1].Name = L"Outbound"; //NOT to be localized a registry info only
    FaxLogCategories[1].Category = FAXLOG_CATEGORY_OUTBOUND;
    FaxLogCategories[1].Level = (DWORD)iOutboundErrPos;

    FaxLogCategories[2].Name = L"Inbound";  //NOT to be localized a registry info only
    FaxLogCategories[2].Category = FAXLOG_CATEGORY_INBOUND;;
    FaxLogCategories[2].Level = (DWORD)iInboundErrPos;

    FaxLogCategories[3].Name = L"Unknown";  //NOT to be localized a registry info only
    FaxLogCategories[3].Category = FAXLOG_CATEGORY_UNKNOWN;
    FaxLogCategories[3].Level = (DWORD)iGeneralErrPos;

    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetLoggingCategories(
                m_pFaxServer->GetFaxServerHandle(),
                FaxLogCategories, 
                (DWORD)iNumCategories)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Set Logging Categories. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }
        
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    m_fIsDirty = FALSE;

    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set Logging Categories configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    PropSheet_SetCurSelByID( GetParent(), IDD);         

    ATLASSERT(::IsWindow(m_hWnd));
    PageError(GetFaxServerErrorMsg(ec),m_hWnd);

Exit:    
    return(hRc);
}


/*
 -  CppFaxServerEvents::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerEvents::PreApply(int *pCtrlFocus)
{
   return(S_OK);
}

/*
 -  CppFaxServerEvents::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerEvents::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerEvents::OnApply"));

    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = SetProps(&CtrlFocus);
    if (FAILED(hRc)) 
    {
        //Error Msg by called func.
        if (CtrlFocus)
        {
            GotoDlgCtrl(GetDlgItem(CtrlFocus));
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        return TRUE;
    }

}

/*
 -  CppFaxServerEvents::SliderMoved
 -
 *  Purpose:
 *      set Apply buttom modified.
 *  Arguments:
 *      IN pParentNode - parent node pointer
 *
 *  Return:
 *      none
 */
LRESULT CppFaxServerEvents::SliderMoved ( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    SetModified(TRUE);  
    fHandled = TRUE;
    return(1);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerEvents::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerEvents::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerEvents::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxservergeneral.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerGeneral.cpp                                 //
//                                                                         //
//  DESCRIPTION   : prop pages of                                          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov 22 1999 yossg  Call RPC func                                   //
//      Nov 24 1999 yossg  OnApply create call to all tabs from parent     //
//      Mar 15 2000 yossg  New design add controls                         //
//      Mar 20 2000 yossg  Add activity notification                       //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerGeneral.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CSnapinNode;

//
// Constructor
//
CppFaxServerGeneral::CppFaxServerGeneral(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerGeneral>(pNode, NULL)
			                	
{
	
    m_pParentNode = static_cast<CFaxServerNode *> (pNode);

    m_FaxVersionConfig.dwSizeOfStruct = sizeof(FAX_VERSION);

    m_hActivityNotification = NULL;
    m_fIsDialogInitiated    = FALSE;

    m_fIsDirty              = FALSE;

    m_lpNotifyHandle = hNotificationHandle;
}

//
// Destructor
//
CppFaxServerGeneral::~CppFaxServerGeneral()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerGeneral::~CppFaxServerGeneral()"));
    if (m_hActivityNotification)
    {
        //
        // Unregister server notifications
        //
        if (!FaxUnregisterForServerEvents (m_hActivityNotification))
        {
            DWORD ec = GetLastError ();
            
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Fail to Unregister For Server Events. (ec: %ld)"), 
			    ec);
        }
    }
    
    // Note - This needs to be called only once per property sheet.  
    // In our convention called in the general tab.
    if (NULL != m_lpNotifyHandle)
    {
        MMCFreeNotifyHandle(m_lpNotifyHandle);
        m_lpNotifyHandle = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxServerGeneral message handlers

/*
 -  CppFaxServerGeneral::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerGeneral::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerGeneral::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;



    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

	//
	// Retrieve the fax Archive configuration
	//
    if (!FaxGetVersion(m_pFaxServer->GetFaxServerHandle(), 
                        &m_FaxVersionConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get version configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }

    ZeroMemory (&m_FaxServerActivityConfig, sizeof(FAX_SERVER_ACTIVITY));
    m_FaxServerActivityConfig.dwSizeOfStruct = sizeof(FAX_SERVER_ACTIVITY);
    
    if (!FaxGetServerActivity(
                                m_pFaxServer->GetFaxServerHandle(), 
                                &m_FaxServerActivityConfig
                             )
       ) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Server Activity configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }

    
    
    if (!FaxGetQueueStates(
                                m_pFaxServer->GetFaxServerHandle(), 
                                &m_dwQueueStates
                           )
       ) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Queue States configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }

	
    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get version configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}


/*
 -  CFaxServerNode::UpdateActivityCounters
 -
 *  Purpose:
 *      Inits and updates the activity counters: Queued, outgoing and incoming faxes.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerGeneral::UpdateActivityCounters()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerGeneral::UpdateActivityCounters"));
    HRESULT hRc = S_OK;
    int count;
    
    WCHAR szQueuedMessagesBuff[FXS_DWORD_LEN +1];
    WCHAR szOutgoingMessagesBuff[FXS_DWORD_LEN +1];
    WCHAR szIncomingMessagesBuff[FXS_DWORD_LEN +1];
    
    //
    // QueuedMessages
    //
    count =0;
    count = swprintf( szQueuedMessagesBuff, 
                      L"%ld", 
                      m_FaxServerActivityConfig.dwQueuedMessages
                    );
    
    if( count > 0 )
    {
        m_QueuedEdit.SetWindowText(szQueuedMessagesBuff);
    }
    else
    {
		DebugPrintEx(
			DEBUG_ERR,
			_T("Out of memory. Failed to allocate string."));
        
        PageError(IDS_MEMORY,m_hWnd);

        goto Exit;
    }

    //
    // OutgoingMessages
    //
    count =0;
    count = swprintf( szOutgoingMessagesBuff, 
                      L"%ld", 
                      ( m_FaxServerActivityConfig.dwOutgoingMessages +
                      m_FaxServerActivityConfig.dwDelegatedOutgoingMessages )
                    );
    
    if( count > 0 )
    {
        m_OutgoingEdit.SetWindowText(szOutgoingMessagesBuff);
    }
    else
    {
		DebugPrintEx(
			DEBUG_ERR,
			_T("Out of memory. Failed to allocate string."));
        
        PageError(IDS_MEMORY,m_hWnd); 

        goto Exit;
    }

    //
    // IncomingMessages
    //
    count =0;
    count = swprintf( szIncomingMessagesBuff, 
                      L"%ld", 
                      ( m_FaxServerActivityConfig.dwIncomingMessages + 
                      m_FaxServerActivityConfig.dwRoutingMessages )
                    );
    
    if( count > 0 )
    {
        m_IncomingEdit.SetWindowText(szIncomingMessagesBuff);
    }
    else
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Out of memory. Failed to allocate string."));
        
        PageError(IDS_MEMORY,m_hWnd); 

        goto Exit;
    }    

    
Exit:    
    return hRc;
}

/*
 -  CFaxServerNode::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxServerGeneral::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerGeneral::OnInitDialog"));

    UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );
     
    CComBSTR bstrVersion, bstrChecked;
    // a Buffer to collect all version DWORDs in
    // 256 >> 4*DWORD in chars +3*char ('.') + chars of (" (Checked)")
    WCHAR buffer[256];
    int count;

    DWORD ec = ERROR_SUCCESS;
    HRESULT hRc = S_OK;



    //
    // init controls
    //

    //
    // Version
    //
 
    //bstrVersion = L"5.0.813.0 (Chk)" or L"5.0.813.0"
    count = swprintf(
                  buffer,
                  L"%ld.%ld.%ld.%ld",
                  m_FaxVersionConfig.wMajorVersion,
                  m_FaxVersionConfig.wMinorVersion,
                  m_FaxVersionConfig.wMajorBuildNumber,
                  m_FaxVersionConfig.wMinorBuildNumber
                  );

    bstrVersion = SysAllocString (buffer);

    if (m_FaxVersionConfig.dwFlags & FAX_VER_FLAG_CHECKED)
    {
        
        if (!bstrChecked.LoadString(IDS_CHK))
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    _T("Out of memory. Failed to load string."));
            m_pParentNode->NodeMsgBox(IDS_MEMORY);
            
            goto Exit;
        }
        
        bstrVersion += bstrChecked;
    }
    
    SetDlgItemText(IDC_VERSION_DTEXT, bstrVersion);
    
    //
    // Queue states
    //
    
    // submission
    if( m_dwQueueStates & FAX_OUTBOX_BLOCKED ) 
    {
        CheckDlgButton(IDC_SUBMISSION_CHECK, BST_CHECKED);
    }
    
    //transmission
    if( m_dwQueueStates & FAX_OUTBOX_PAUSED ) 
    {
        CheckDlgButton(IDC_TRANSSMI_CHECK, BST_CHECKED);
    }
    
    // reception
    if( m_dwQueueStates & FAX_INCOMING_BLOCKED ) 
    {
        CheckDlgButton(IDC_RECEPTION_CHECK, BST_CHECKED);
    }

    //
    // Activity
    //
    m_QueuedEdit.Attach(   GetDlgItem(IDC_QUED_ROEDIT)            );
    m_OutgoingEdit.Attach( GetDlgItem(IDC_OUTGOING_INPROC_ROEDIT) );
    m_IncomingEdit.Attach( GetDlgItem(IDC_INCOM_INPROC_ROEDIT)    );

    hRc = UpdateActivityCounters();
    if (S_OK != hRc)
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to UpdateActivityCounters()"));
        
        goto Exit;
    }

    //
    // Register for Queue states changes notification
    //
    ATLASSERT(::IsWindow(m_hWnd));

    if (!m_hActivityNotification)
    {
        //
        // get RPC Handle
        //   

        if (!m_pFaxServer->GetFaxServerHandle())
        {
            ec= GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			    ec);

            goto Exit; //Error;
        }

    
        if (!FaxRegisterForServerEvents (   
                                          m_pFaxServer->GetFaxServerHandle(),
                                          FAX_EVENT_TYPE_ACTIVITY,               
                                          NULL,                       
                                          0,                          
                                          m_hWnd,                     
                                          WM_ACTIVITY_STATUS_CHANGES, 
                                          &m_hActivityNotification
                                        )                   
            )
        {
            ec = GetLastError();

            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Fail to Register For Server Events (ec: %ld)"), ec);
        
            m_hActivityNotification = NULL;
        
            goto Exit;
        }
    }
    m_fIsDialogInitiated = TRUE;
    
Exit:      
    return(1);
}


/*
 -  CFaxServerNode::OnActivityStatusChange
 -
 *  Purpose:
 *      Treats notifications about changes in Queue States.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxServerGeneral::OnActivityStatusChange( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( fHandled );

    DEBUG_FUNCTION_NAME( _T("CppFaxServerGeneral::OnActivityStatusChange"));
    HRESULT hRc = S_OK;
    
    ATLASSERT( uiMsg == WM_ACTIVITY_STATUS_CHANGES );
    
    PFAX_EVENT_EX   pFaxEvent = NULL;
	pFaxEvent = reinterpret_cast<PFAX_EVENT_EX>(lParam);
    ATLASSERT( pFaxEvent );
    
    //
    // Updating the required fields
    //
    m_FaxServerActivityConfig.dwIncomingMessages   = pFaxEvent->EventInfo.ActivityInfo.dwIncomingMessages;
	m_FaxServerActivityConfig.dwRoutingMessages    = pFaxEvent->EventInfo.ActivityInfo.dwRoutingMessages;

    m_FaxServerActivityConfig.dwOutgoingMessages   = pFaxEvent->EventInfo.ActivityInfo.dwOutgoingMessages;
    m_FaxServerActivityConfig.dwDelegatedOutgoingMessages = 
                                        pFaxEvent->EventInfo.ActivityInfo.dwDelegatedOutgoingMessages;

    m_FaxServerActivityConfig.dwQueuedMessages     = pFaxEvent->EventInfo.ActivityInfo.dwQueuedMessages;

    hRc = UpdateActivityCounters();
    if (S_OK != hRc)
    {
        DebugPrintEx(
           DEBUG_ERR,
           _T("Failed to UpdateActivityCounters()"));
    }
    
    
    
    
    if (pFaxEvent) 
    {
        FaxFreeBuffer (pFaxEvent);
        pFaxEvent = NULL;
    }

    return(1);
}

/*
 -  CFaxServerGeneral::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      IN pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerGeneral::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerGeneral::SetProps"));

    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;

    DWORD  dwQueueStates;
	
    //
    // Collects Queue states
    //
    
    //init
    dwQueueStates = 0;        
	
    //Submission
    if (IsDlgButtonChecked(IDC_SUBMISSION_CHECK) == BST_CHECKED)   
    {
        dwQueueStates |= FAX_OUTBOX_BLOCKED;
    }
    
    //Transmission
    if (IsDlgButtonChecked(IDC_TRANSSMI_CHECK) == BST_CHECKED)   
    {
        dwQueueStates |= FAX_OUTBOX_PAUSED;
    }
    
    //Reception
    if (IsDlgButtonChecked(IDC_RECEPTION_CHECK) == BST_CHECKED)   
    {
        dwQueueStates |= FAX_INCOMING_BLOCKED;
    }
    
    //
    // Set Queue States through RPC call
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    
    if (!FaxSetQueue(
                        m_pFaxServer->GetFaxServerHandle(), 
                        dwQueueStates
                    )
       ) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Queue States configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }

    ATLASSERT(S_OK == hRc);
    m_fIsDirty = FALSE;

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    PropSheet_SetCurSelByID( GetParent(), IDD);         

    ATLASSERT(::IsWindow(m_hWnd));
    PageError(GetFaxServerErrorMsg(ec),m_hWnd);
    
Exit:
    return(hRc);
}

/*
 -  CFaxServerNode::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerGeneral::PreApply(int *pCtrlFocus)
{
    return(S_OK);
}

/*
 -  CppFaxServerGeneral::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerGeneral::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::OnApply"));

    HRESULT hRc = S_OK;
    int     CtrlFocus = 0;
    
    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = SetProps(&CtrlFocus);
    if (FAILED(hRc)) 
    {
        //Error Msg by called func.
        if (CtrlFocus)
        {
            GotoDlgCtrl(GetDlgItem(CtrlFocus));
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        return TRUE;
    }
}



/*
 -  CppFaxServerGeneral::SetApplyButton
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerGeneral::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
    
    SetModified(TRUE);  
    bHandled = TRUE;
    return(1);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerGeneral::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerGeneral::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerGeneral::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxserverinbox.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerInbox.h                                     //
//                                                                         //
//  DESCRIPTION   : Fax Server Inbox prop page header file                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg  Created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXSERVER_INBOX_H_
#define _PP_FAXSERVER_INBOX_H_

#include "MyCtrls.h"
#include <windows.h>
#include <proppageex.h>
    
class CFaxServerNode;
class CFaxServer;
/////////////////////////////////////////////////////////////////////////////
// CppFaxServerInbox dialog

class CppFaxServerInbox : public CPropertyPageExImpl<CppFaxServerInbox>
{

public:
    //
    // Constructor
    //
    CppFaxServerInbox(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           fIsLocalServer,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxServerInbox();

	enum { IDD = IDD_FAXSERVER_INBOX_ARCHIVE };

	BEGIN_MSG_MAP(CppFaxServerInbox)
		MESSAGE_HANDLER( WM_INITDIALOG,     OnInitDialog )

        COMMAND_HANDLER( IDC_INBOX_BROWSE_BUTTON,  BN_CLICKED, BrowseForDirectory)
        
        COMMAND_HANDLER( IDC_TO_ARCHIVE_CHECK,     BN_CLICKED, ToArchiveCheckboxClicked)
		COMMAND_HANDLER( IDC_INBOX_FOLDER_EDIT,    EN_CHANGE,  EditChanged )

		COMMAND_HANDLER( IDC_GENERATE_WARNING_CHECK,  BN_CLICKED, GenerateEventLogCheckboxClicked)
        COMMAND_HANDLER( IDC_LOW_EDIT,             EN_CHANGE,  EditChanged )
		COMMAND_HANDLER( IDC_HIGH_EDIT,            EN_CHANGE,  EditChanged )
		
		COMMAND_HANDLER( IDC_AUTODEL_CHECK,        BN_CLICKED, AutoDelCheckboxClicked)
        COMMAND_HANDLER( IDC_AUTODEL_EDIT,         EN_CHANGE,  EditChanged )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerInbox>)
	END_MSG_MAP()

	//
	// Dialog's Handler and events.
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();


    HRESULT SetProps(int *pCtrlFocus, UINT * puIds);
    HRESULT PreApply(int *pCtrlFocus, UINT * puIds);

private:
    //
    // Control members
    //
    CEdit         m_FolderBox;
    CButton       m_BrowseButton;

    CMyUpDownCtrl m_HighWatermarkSpin;
    CMyUpDownCtrl m_LowWatermarkSpin;
    CMyUpDownCtrl m_AutoDelSpin;
    
    CEdit         m_HighWatermarkBox;
    CEdit         m_LowWatermarkBox;
    CEdit         m_AutoDelBox;

    //
    // Boolean members
    //
    BOOL  m_fAllReadyToApply;
    BOOL  m_fIsDialogInitiated;
    BOOL  m_fIsDirty;

    BOOL  m_fIsLocalServer;


    //
    // Config Structure member
    //
    PFAX_ARCHIVE_CONFIG    m_pFaxArchiveConfig ; 
    
    CComBSTR  m_bstrLastGoodFolder;
    DWORD     m_dwLastGoodSizeQuotaHighWatermark;
    DWORD     m_dwLastGoodSizeQuotaLowWatermark;

    //
    // Handles
    //
    CFaxServerNode * m_pParentNode;    

    //
    // Browse
    //
    BOOL BrowseForDirectory(WORD wNotifyCode, WORD wID, HWND hwndDlg, BOOL& bHandled);

    //
    // Event methods
    //
    LRESULT ToArchiveCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT GenerateEventLogCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT AutoDelCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT EditChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    BOOL AllReadyToApply(BOOL fSilent, int *pCtrlFocus = NULL, UINT *pIds = NULL);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};




#endif // _PP_FAXSERVER_INBOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxservergeneral.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerGeneral.h                                   //
//                                                                         //
//  DESCRIPTION   : Fax Server general prop page header file               //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov 22 1999 yossg  Call RPC func                                   //
//      Mar 15 2000 yossg  New design add controls                         //
//      Mar 20 2000 yossg  Add activity notification                       //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#ifndef _PP_FAXSERVER_GENERAL_H_
#define _PP_FAXSERVER_GENERAL_H_

#include "proppageex.h"

const int WM_ACTIVITY_STATUS_CHANGES = WM_USER + 2;



class CFaxServer;
class CFaxServerNode;

/////////////////////////////////////////////////////////////////////////////
// CppFaxServerGeneral dialog

class CppFaxServerGeneral : public CPropertyPageExImpl<CppFaxServerGeneral>
{

public:
    //
    // Construction
    //
    CppFaxServerGeneral(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destraction
    //
    ~CppFaxServerGeneral();

	enum { IDD = IDD_FAXSERVER_GENERAL };

	BEGIN_MSG_MAP(CppFaxServerGeneral)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
		MESSAGE_HANDLER( WM_ACTIVITY_STATUS_CHANGES, OnActivityStatusChange )

        COMMAND_HANDLER( IDC_SUBMISSION_CHECK, BN_CLICKED, SetApplyButton )
		COMMAND_HANDLER( IDC_TRANSSMI_CHECK,   BN_CLICKED, SetApplyButton )
		COMMAND_HANDLER( IDC_RECEPTION_CHECK,  BN_CLICKED, SetApplyButton )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerGeneral>)
	END_MSG_MAP()

	//
	// Dialog's Handlers 
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );    
	LRESULT OnActivityStatusChange( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );    
    BOOL    OnApply();

    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus);

private:

    //
    // Configuration Structure members
    //
    FAX_VERSION             m_FaxVersionConfig;
    FAX_SERVER_ACTIVITY     m_FaxServerActivityConfig;
    DWORD                   m_dwQueueStates;

    //
    // Handles
    //
    CFaxServerNode *        m_pParentNode; 
    HANDLE                  m_hActivityNotification;       // Notification registration handle
    LONG_PTR                m_lpNotifyHandle;
    
    BOOL                    m_fIsDialogInitiated;
    BOOL                    m_fIsDirty;

    //
    // Controls
    //
    CEdit                   m_QueuedEdit;
    CEdit                   m_OutgoingEdit;
    CEdit                   m_IncomingEdit;
    

    HRESULT UpdateActivityCounters();

    LRESULT SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};


#endif // _PP_FAXSERVER_GENERAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxserverinbox.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerInbox.cpp                                   //
//                                                                         //
//  DESCRIPTION   : prop pages of Inbox archive                            //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Nov 24 1999 yossg  OnApply create call to all tabs from parent     //
//      Oct 17 2000 yossg                                                  //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerInbox.h"
#include "FaxMMCGlobals.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FxsValid.h"
#include "dlgutils.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxServerInbox::CppFaxServerInbox(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        fIsLocalServer,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerInbox>(pNode, NULL)
			                	
{
    m_pParentNode        = static_cast <CFaxServerNode *> (pNode);
    m_pFaxArchiveConfig  = NULL;

    m_fAllReadyToApply   = FALSE;
    m_fIsDialogInitiated = FALSE;
    
    m_fIsDirty           = FALSE;

    m_fIsLocalServer     = fIsLocalServer;
}

//
// Destructor
//
CppFaxServerInbox::~CppFaxServerInbox()
{
    if (NULL != m_pFaxArchiveConfig)
    {
        FaxFreeBuffer( m_pFaxArchiveConfig );
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxServerInbox message handlers

/*
 -  CppFaxServerInbox::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerInbox::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;

      //
    // get RPC Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
	// Retrieve the fax Archive configuration
	//
    if (!FaxGetArchiveConfiguration(m_pFaxServer->GetFaxServerHandle(), 
                                    FAX_MESSAGE_FOLDER_INBOX, 
                                    &m_pFaxArchiveConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get inbox configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(m_pFaxArchiveConfig);

    //
    // Init specific members for set proprties follow-up
    //
    m_dwLastGoodSizeQuotaHighWatermark = m_pFaxArchiveConfig->dwSizeQuotaHighWatermark;
    m_dwLastGoodSizeQuotaLowWatermark  = m_pFaxArchiveConfig->dwSizeQuotaLowWatermark;
    m_bstrLastGoodFolder               = m_pFaxArchiveConfig->lpcstrFolder;
    if (!m_bstrLastGoodFolder)
    {
		DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Failed to allocate string (m_bstrLastGoodFolder)."));
        ec = ERROR_OUTOFMEMORY;
        
        goto Error;
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get inbox configuration."));
	
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);

}

/*
 -  CppFaxServerInbox::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxServerInbox::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::PageInitDialog"));
    
    DWORD   ec  = ERROR_SUCCESS;

	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );

    int  iLow,
         iHigh,
         iAgeLimit;

    ATLASSERT(m_pFaxArchiveConfig);

    //
    // init controls
    // 
    m_FolderBox.Attach(GetDlgItem(IDC_INBOX_FOLDER_EDIT));
    m_FolderBox.SetLimitText(MAX_ARCHIVE_FOLDER_PATH);
    SHAutoComplete (GetDlgItem(IDC_INBOX_FOLDER_EDIT), SHACF_FILESYSTEM);

    m_HighWatermarkBox.Attach(GetDlgItem(IDC_HIGH_EDIT));
    m_LowWatermarkBox.Attach(GetDlgItem(IDC_LOW_EDIT));
    m_AutoDelBox.Attach(GetDlgItem(IDC_AUTODEL_EDIT));

    m_HighWatermarkBox.SetLimitText(FXS_QUOTA_LENGTH);
    m_LowWatermarkBox.SetLimitText(FXS_QUOTA_LENGTH);
    m_AutoDelBox.SetLimitText(FXS_DIRTYDAYS_LENGTH);

    m_HighWatermarkSpin.Attach(GetDlgItem(IDC_HIGH_SPIN));
    m_LowWatermarkSpin.Attach(GetDlgItem(IDC_LOW_SPIN));
    m_AutoDelSpin.Attach(GetDlgItem(IDC_AUTODEL_SPIN));
   
    //
    // FOLDER_EDIT
    //
    m_FolderBox.SetWindowText(m_pFaxArchiveConfig->lpcstrFolder);

    //
    // Disable Browse button for remote admin
    //
    if (!m_fIsLocalServer)
    {
        ::EnableWindow(GetDlgItem(IDC_INBOX_BROWSE_BUTTON), FALSE); 
    }

    //
    // TO_ARCHIVE_CHECK
    //
    if (m_pFaxArchiveConfig->bUseArchive) 
    {
        CheckDlgButton(IDC_TO_ARCHIVE_CHECK, BST_CHECKED) ;
    }
    else
    {
        CheckDlgButton(IDC_TO_ARCHIVE_CHECK, BST_UNCHECKED) ;
        ::EnableWindow(GetDlgItem(IDC_INBOX_FOLDER_EDIT), FALSE);    
        ::EnableWindow(GetDlgItem(IDC_INBOX_BROWSE_BUTTON), FALSE);    
    }

    //
    // Quota size - Low
    //
    iLow = (int)m_pFaxArchiveConfig->dwSizeQuotaLowWatermark;

    m_LowWatermarkSpin.SetRange(FXS_QUOTA_LOW_LOWER, FXS_QUOTA_LOW_UPPER);
    m_LowWatermarkSpin.SetPos(iLow);
    //
    // Quota size - High
    //    
    iHigh = (int)m_pFaxArchiveConfig->dwSizeQuotaHighWatermark;
    m_HighWatermarkSpin.SetRange(FXS_QUOTA_HIGH_LOWER, FXS_QUOTA_HIGH_UPPER);
    m_HighWatermarkSpin.SetPos(iHigh);// Set Position
    
    //
    //Generate event log warning
    //
    if (m_pFaxArchiveConfig->bSizeQuotaWarning) 
    {
        CheckDlgButton(IDC_GENERATE_WARNING_CHECK, BST_CHECKED) ;
    }
    else
    {
        CheckDlgButton(IDC_GENERATE_WARNING_CHECK, BST_UNCHECKED) ;
        ::EnableWindow(GetDlgItem(IDC_HIGH_EDIT), FALSE);    
        ::EnableWindow(GetDlgItem(IDC_HIGH_SPIN), FALSE);    

        ::EnableWindow(GetDlgItem(IDC_LOW_EDIT), FALSE);    
        ::EnableWindow(GetDlgItem(IDC_LOW_SPIN), FALSE);    
    }


    //
    // message life-time (dirty days)
    //
    iAgeLimit = (int)m_pFaxArchiveConfig->dwAgeLimit;

    m_AutoDelSpin.SetRange(FXS_DIRTYDAYS_LOWER, FXS_DIRTYDAYS_UPPER);
    m_AutoDelSpin.SetPos(iAgeLimit);

    //
    // Auto Delete
    //
    if (FXS_DIRTYDAYS_ZERO == iAgeLimit)
    {
      CheckDlgButton(IDC_AUTODEL_CHECK, BST_UNCHECKED);

      ::EnableWindow(GetDlgItem(IDC_AUTODEL_EDIT), FALSE);
      ::EnableWindow(GetDlgItem(IDC_AUTODEL_SPIN), FALSE);
    }
    else
    {
      CheckDlgButton(IDC_AUTODEL_CHECK, BST_CHECKED);
    }

    m_fIsDialogInitiated = TRUE;
    
    return (1);
}

/*
 -  CppFaxServerInbox::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerInbox::SetProps(int *pCtrlFocus, UINT * puIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::SetProps"));

    HRESULT      hRc = S_OK;
    DWORD        ec  = ERROR_SUCCESS;
    HINSTANCE    hInst     = _Module.GetResourceInstance();


    CComBSTR     bstrFolder = L"";

    BOOL         fSkipMessage = FALSE;
    
    FAX_ARCHIVE_CONFIG   FaxArchiveConfig;

    ATLASSERT(TRUE == m_fAllReadyToApply);
    m_fAllReadyToApply = FALSE;

    //
    // Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    ZeroMemory (&FaxArchiveConfig, sizeof(FAX_ARCHIVE_CONFIG));

    //
    // Size of struct.
    //
    FaxArchiveConfig.dwSizeOfStruct = sizeof(FAX_ARCHIVE_CONFIG);

    //
    // IDC_TO_ARCHIVE_CHECK
    //
    if (IsDlgButtonChecked(IDC_TO_ARCHIVE_CHECK) == BST_CHECKED)   
    {
        FaxArchiveConfig.bUseArchive = TRUE;
        
        //IDC_INBOX_FOLDER_EDIT
        if ( !m_FolderBox.GetWindowText(&bstrFolder))
        {
            *pCtrlFocus = IDC_INBOX_FOLDER_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrFolder)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
        if (!IsNotEmptyString(bstrFolder))
        {
            *pCtrlFocus = IDC_INBOX_FOLDER_EDIT;
            *puIds = IDS_INBOX_ARCHIVE_PATH_EMPTY;            

            DebugPrintEx( DEBUG_ERR,
			    _T("Archive path string is empty or includes spaces only."));
            
            fSkipMessage = TRUE;

            ec = ERROR_INVALID_DATA;
        
            goto Error;
        }
        FaxArchiveConfig.lpcstrFolder = bstrFolder;
        
        //
        // follow-up for an OnApply following submition
        // with unchecked IDC_TO_ARCHIVE_CHECK
        //
        m_bstrLastGoodFolder          = bstrFolder; 
        if (!m_bstrLastGoodFolder)
        {
            *pCtrlFocus = IDC_INBOX_FOLDER_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to allocate string (m_bstrLastGoodFolder)."));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
    }
    else
    {
        FaxArchiveConfig.bUseArchive  = FALSE;
        FaxArchiveConfig.lpcstrFolder = m_bstrLastGoodFolder; 
    }
    
    //
    // IDC_GENERATE_WARNING_CHECK
    //
    if (IsDlgButtonChecked(IDC_GENERATE_WARNING_CHECK) == BST_CHECKED)   
    {
        FaxArchiveConfig.bSizeQuotaWarning = TRUE;

        int iHigh = m_HighWatermarkSpin.GetPos();
        FaxArchiveConfig.dwSizeQuotaHighWatermark = (DWORD) iHigh;

        int iLow = m_LowWatermarkSpin.GetPos();
        FaxArchiveConfig.dwSizeQuotaLowWatermark = (DWORD) iLow;

        if (iHigh <= iLow)
        {
            *pCtrlFocus = IDC_SENT_HIGH_EDIT;
            *puIds = IDS_INBOX_WATERMARK_HI_LOW;            
            
            DebugPrintEx( DEBUG_ERR,
			    _T("Watermark High < Low."));
            
            fSkipMessage = TRUE;

            ec = ERROR_INVALID_DATA;
        
            goto Error;
        }
        //
        // follow-up for an OnApply following submition
        // with unchecked IDC_SENT_GENERATE_WARNING_CHECK
        //
        m_dwLastGoodSizeQuotaHighWatermark = (DWORD)iHigh;
        m_dwLastGoodSizeQuotaLowWatermark  = (DWORD)iLow;
    }
    else
    {
        FaxArchiveConfig.bSizeQuotaWarning = FALSE;

        FaxArchiveConfig.dwSizeQuotaHighWatermark = m_dwLastGoodSizeQuotaHighWatermark;
        FaxArchiveConfig.dwSizeQuotaLowWatermark  = m_dwLastGoodSizeQuotaLowWatermark;
    }
    
    //
    // IDC_AUTODEL_CHECK  - AutoDelete Messages
    //
    if (IsDlgButtonChecked(IDC_AUTODEL_CHECK) == BST_CHECKED)   
    {       
        int iAgeLimit = m_AutoDelSpin.GetPos();
        FaxArchiveConfig.dwAgeLimit = (DWORD) iAgeLimit;
    }
    else
    {
        FaxArchiveConfig.dwAgeLimit = (DWORD)FXS_DIRTYDAYS_ZERO;
    }
    
    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetArchiveConfiguration(
                m_pFaxServer->GetFaxServerHandle(),
                FAX_MESSAGE_FOLDER_INBOX,
                &FaxArchiveConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR, _T("Fail to Set inbox configuration. (ec: %ld)"), ec);

        //
        // Try to adjust folder
        // 
        PropSheet_SetCurSelByID( GetParent(), IDD);
        GotoDlgCtrl(GetDlgItem(IDC_INBOX_FOLDER_EDIT));

        ec = AskUserAndAdjustFaxFolder(m_hWnd, 
                                       m_pFaxServer->GetServerName(), 
                                       FaxArchiveConfig.lpcstrFolder, 
                                       ec);
        if(ERROR_SUCCESS != ec)
        {
            if(ERROR_BAD_PATHNAME == ec)
            {
                //
                // The error message has been shown by AskUserAndAdjustFaxFolder
                //
                fSkipMessage = TRUE;
            }

            goto Error;
        }

        //
        // The folder has been adjusted, set it again
        //
        if (!FaxSetArchiveConfiguration(m_pFaxServer->GetFaxServerHandle(),
                                        FAX_MESSAGE_FOLDER_INBOX,
                                        &FaxArchiveConfig)) 
	    {		
            ec = GetLastError();
            DebugPrintEx(DEBUG_ERR, _T("Fail to Set inbox configuration. (ec: %ld)"), ec);
            goto Error;
        }
    }

    ATLASSERT(S_OK == hRc);
    m_fIsDirty = FALSE;
    
    DebugPrintEx( DEBUG_MSG, _T("Succeed to set inbox configuration."));

    return hRc;

Error:

    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    DWORD dwIDS = 0;        
    switch (ec)
    {
        case ERROR_DISK_FULL:
            DebugPrintEx( DEBUG_ERR, _T("ERROR_DISK_FULL == ec"));
            dwIDS = IDS_INBOX_ERROR_DISK_FULL;
            break;
        
        case FAX_ERR_NOT_NTFS:                
            DebugPrintEx( DEBUG_ERR, _T("FAX_ERR_NOT_NTFS == ec"));
            dwIDS = IDS_INBOX_FAX_ERR_NOT_NTFS;
            break;

        case FAX_ERR_FILE_ACCESS_DENIED:
            DebugPrintEx( DEBUG_ERR, _T("FAX_ERR_FILE_ACCESS_DENIED == ec"));
            dwIDS = IDS_INBOX_FAX_ERR_FILE_ACCESS_DENIED;
            break;

        default:
            dwIDS = GetFaxServerErrorMsg(ec);
            break;
    }
            
    if (dwIDS && !fSkipMessage)
    {
        PropSheet_SetCurSelByID( GetParent(), IDD);
        PageError(dwIDS, m_hWnd);
    }
            
    if (IsNetworkError(ec))
    {
        DebugPrintEx(DEBUG_ERR, _T("Network Error was found. (ec: %ld)"), ec);        
        m_pFaxServer->Disconnect();       
    }
    
    return hRc;
}

/*
 -  CppFaxServerInbox::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerInbox::PreApply(int *pCtrlFocus, UINT * puIds)
{
    HRESULT hRc = S_OK;
    
    //
    // PreApply Checks
    //
    if (!AllReadyToApply(/*fSilent =*/ FALSE, pCtrlFocus , puIds))
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }

    return(hRc);
}

/*
 -  CppFaxServerInbox::ToArchiveCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerInbox::ToArchiveCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }


    State = ( IsDlgButtonChecked(IDC_TO_ARCHIVE_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_INBOX_FOLDER_EDIT),   State);    
    ::EnableWindow(GetDlgItem(IDC_INBOX_BROWSE_BUTTON), State && m_fIsLocalServer);    

    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_FolderBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return 1;
}

/*
 -  CppFaxServerInbox::GenerateEventLogCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the spin buttons and edit boxes
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerInbox::GenerateEventLogCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_GENERATE_WARNING_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_HIGH_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_HIGH_SPIN), State);    
    ::EnableWindow(GetDlgItem(IDC_QUOTA_HIGH_STATIC), State);    
    ::EnableWindow(GetDlgItem(IDC_MB1_STATIC), State);    

    ::EnableWindow(GetDlgItem(IDC_LOW_EDIT),  State);    
    ::EnableWindow(GetDlgItem(IDC_LOW_SPIN),  State);    
    ::EnableWindow(GetDlgItem(IDC_QUOTA_LOW_STATIC), State);    
    ::EnableWindow(GetDlgItem(IDC_MB2_STATIC), State);    


    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_HighWatermarkBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else if ( 0 != HIWORD( m_HighWatermarkSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else if ( !m_LowWatermarkBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}

/*
 -  CppFaxServerInbox::AutoDelCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the spin button and edit box
 *      and enable apply button after Auto Delete Checkbox 
 *      status was changed.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerInbox::AutoDelCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_AUTODEL_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_AUTODEL_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_AUTODEL_SPIN), State);    

    if (m_fAllReadyToApply)//only last change should be considered
    {
        if (State)
		{
			if ( !m_AutoDelBox.GetWindowTextLength() )    
			{
				m_fAllReadyToApply = FALSE;
				SetModified(FALSE);
			}
			else if ( 0 != HIWORD( m_AutoDelSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
			{
				m_fAllReadyToApply = FALSE;
				SetModified(FALSE);
			}
		}
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}

/*
 +  Routine Description:
 +
 *      Browse for a directory
 *
 *  Arguments:
 *
 *      hwndDlg - Specifies the dialog window on which the Browse button is displayed
 *
 *  Return Value:
 *  
 *      TRUE if successful, FALSE if the user presses Cancel
 -
 -
 */
BOOL
CppFaxServerInbox::BrowseForDirectory( WORD wNotifyCode, WORD wID, HWND hwndDlg, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER( wNotifyCode );
	UNREFERENCED_PARAMETER( wID );
	UNREFERENCED_PARAMETER( hwndDlg );
	UNREFERENCED_PARAMETER( bHandled );

    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::BrowseForDirectory"));

    BOOL            fResult = FALSE;

    WCHAR           szBrowseFolder[MAX_PATH]={0};
    WCHAR           szBrowseDlgTitle[FXS_MAX_TITLE_LEN];
    CComBSTR        bstrOldPath;
    unsigned int    len;

    unsigned long   ulBrowseFlags;

    //
    // Collecting the browse dialog headline
    //
    if (!LoadString( _Module.GetResourceInstance(), 
                IDS_GET_ARCHIVE_DIRECTORY, 
                szBrowseDlgTitle, 
                FXS_MAX_TITLE_LEN))
    {
        DWORD ec;
        ec = GetLastError();
        if (ec == ERROR_NOT_ENOUGH_MEMORY)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Out of Memory - fail to load string."));
            DlgMsgBox(this, IDS_MEMORY);
            return fResult;
        }
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to load titile string - unexpected behavior."));
        
        szBrowseDlgTitle[0] = 0;
    }

    //
    // Collecting the old path from the calling dialog edit box
    //
    if(! GetDlgItemText( IDC_INBOX_FOLDER_EDIT, bstrOldPath.m_str))
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to collect old path from the property page edit box."));
         
        szBrowseFolder[0] = 0;
    }
    else
    {
         len = bstrOldPath.Length();
         if ( len > MAX_PATH )
         {
             DebugPrintEx(
		        DEBUG_ERR,
		        _T("Old Path Length is bigger then alowed maximal path."));
             szBrowseFolder[0] = 0;
         }
         else 
         {
             wcsncpy(szBrowseFolder, bstrOldPath, ARR_SIZE(szBrowseFolder)-1);
         }
    }
    //
    // Preparing the browse dialog style flags.
    //
    ulBrowseFlags       = BIF_RETURNONLYFSDIRS  | 
                          BIF_STATUSTEXT        | 
                          BIF_NEWDIALOGSTYLE    | 
                          BIF_NONEWFOLDERBUTTON |
                          BIF_VALIDATE;

    //
    // Invoke the browse dialog with a function based on 
    // Shell functions.
    //  
    if (InvokeBrowseDialog(szBrowseFolder, 
                           MAX_ARCHIVE_FOLDER_PATH,
                           szBrowseDlgTitle,
                           ulBrowseFlags,
                           this))
    {
        SetDlgItemText(IDC_INBOX_FOLDER_EDIT, szBrowseFolder);
        fResult = TRUE;
    }

    return fResult;
}


/*
 -  CppFaxServerInbox::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerInbox::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::OnApply"));

    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;
    UINT    uIds = 0;

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = PreApply(&CtrlFocus, &uIds);
    if (FAILED(hRc))
    {
        if (PropSheet_SetCurSelByID( GetParent(), IDD) )
        {
            PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus, &uIds);
        if (FAILED(hRc)) 
        {
            if (uIds)
            {
                if (PropSheet_SetCurSelByID( GetParent(), IDD) )
                {
                    PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
                    if (CtrlFocus)
                    {
                        GotoDlgCtrl(GetDlgItem(CtrlFocus));
                    }
                }
            }
            //else Error Msg by called func.
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }

}


/*
 -  CppFaxServerInbox::EditChanged
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerInbox::EditChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (!m_fIsDialogInitiated)
    {
        return 1;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
        
        
    if (m_fAllReadyToApply) //only last change should be considered
    {
        switch (wID)
        {
            case IDC_INBOX_FOLDER_EDIT:
                if ( !m_FolderBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
				break;

            case IDC_HIGH_EDIT:
                if ( !m_HighWatermarkBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }		
                else if ( 0 != HIWORD( m_HighWatermarkSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                break;

            case IDC_LOW_EDIT:
                if ( !m_LowWatermarkBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
				break;

            case IDC_AUTODEL_EDIT:
                if ( !m_AutoDelBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                else if ( 0 != HIWORD( m_AutoDelSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
                {
                    m_fAllReadyToApply = FALSE;
                    SetModified(FALSE);
                }

				break;

            default:
                return 1;
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return 1;
}


/*
 -  CppFaxServerInbox::AllReadyToApply
 -
 *  Purpose:
 *      This function validate that no zero length strings 
 *      are found data areas that should be saved.
 *
 *  Arguments:
 *      [in] fSilent - boolean who defines if to pop up messages (FALSE)
 *           or not.(TRUE)
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerInbox::AllReadyToApply(BOOL fSilent, int *pCtrlFocus, UINT *pIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::AllReadyToApply"));
	
    DWORD         ec  = ERROR_SUCCESS;
    
    HINSTANCE     hInst = _Module.GetResourceInstance();
    
    
    if (IsDlgButtonChecked(IDC_TO_ARCHIVE_CHECK) == BST_CHECKED)
    {
        if ( !m_FolderBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero text length - m_FolderBox. (ec: %ld)"), 
			    ec);
        
            if (!fSilent)
            {
                *pIds = IDS_INBOX_ARCHIVE_PATH_EMPTY;
                *pCtrlFocus = IDC_INBOX_FOLDER_EDIT;
            }
            return FALSE;    
        }
    }

    if (IsDlgButtonChecked(IDC_GENERATE_WARNING_CHECK) == BST_CHECKED)
    {
        if ( !m_HighWatermarkBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero text length - m_HighWatermarkBox. (ec: %ld)"), 
                ec);
        
            if (!fSilent)
            {
                *pIds = IDS_INBOX_WATERMARK_EMPTY;
                *pCtrlFocus = IDC_HIGH_EDIT;
            }
            return FALSE;    
        }
        else if ( 0 != HIWORD( m_HighWatermarkSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS    
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero value - m_HighWatermarkBox. (ec: %ld)"));
        
            if (!fSilent)
            {
                *pIds = IDS_INBOX_HIGH_WATERMARK_ZERO;
                *pCtrlFocus = IDC_HIGH_EDIT;
            }
            return FALSE;    
        }

        if ( !m_LowWatermarkBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero text length - m_LowWatermarkBox. (ec: %ld)"), 
                ec);
        
            if (!fSilent)
            {
                *pIds = IDS_INBOX_WATERMARK_EMPTY;
                *pCtrlFocus = IDC_SENT_LOW_EDIT;
            }
            return FALSE;    
        }
    }

    if (IsDlgButtonChecked(IDC_AUTODEL_CHECK) == BST_CHECKED)
    {
        if ( !m_AutoDelBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero text length - m_AutoDelBox. (ec: %ld)"), 
                ec);
        
            if (!fSilent)
            {
                *pIds = IDS_INBOX_AUTODEL_EMPTY;
                *pCtrlFocus = IDC_AUTODEL_EDIT;
            }
            return FALSE;    
        }
        else if ( 0 != HIWORD( m_AutoDelSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero value - m_AutoDelBox."));
        
            if (!fSilent)
            {
                *pIds = IDS_INBOX_AUTODEL_EMPTY;
                *pCtrlFocus = IDC_AUTODEL_EDIT;
            }
            return FALSE;    
        }
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    
    //
	// Cheers! 
	//		...every thing ready to apply now.
	//
	return TRUE;           
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerInbox::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerInbox::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerInbox::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxserverlogging.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerLogging.cpp                                 //
//                                                                         //
//  DESCRIPTION   : prop pages of                                          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Nov 24 1999 yossg  OnApply create call to all tabs from parent     //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerLogging.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FxsValid.h"
#include "dlgutils.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxServerLogging::CppFaxServerLogging(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        fIsLocalServer,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerLogging>(pNode, NULL)
{
    m_pParentNode        = static_cast <CFaxServerNode *> (pNode);
    m_pFaxActLogConfig   = NULL;

    m_fIsDialogInitiated = FALSE;
    m_fIsDirty           = FALSE;

    m_fIsLocalServer     = fIsLocalServer;
}


//
// Destructor
//
CppFaxServerLogging::~CppFaxServerLogging()
{
    if (NULL != m_pFaxActLogConfig)
    {
        FaxFreeBuffer( m_pFaxActLogConfig );
    }
}

//////////////////////////////////////////////////////////////////////////////
// CppFaxServerLogging message handlers

/*
 -  CppFaxServerLogging::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerLogging::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerLogging::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;

    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Retrieve the fax activity logging configuration structure
    //
    if (!FaxGetActivityLoggingConfiguration(m_pFaxServer->GetFaxServerHandle(), 
                                           &m_pFaxActLogConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Activity logging configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(m_pFaxActLogConfig);

    m_bstrLastGoodFolder = m_pFaxActLogConfig->lptstrDBPath ? m_pFaxActLogConfig->lptstrDBPath : TEXT("");
    if (!m_bstrLastGoodFolder)
    {
		DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Failed to allocate string (m_bstrLastGoodFolder)."));
        ec = ERROR_OUTOFMEMORY;
        
        goto Error;
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get acitivity logging configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
Exit:
    return (hRc);
}
   

 /*
 -  CppFaxServerLogging::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
LRESULT CppFaxServerLogging::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerLogging::PageInitDialog"));

	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );

    BOOL        fToCheck;
    UINT        CheckState1;
    UINT        CheckState2;


    //
    // Attach & limit length
    //
    m_LogFileBox.Attach(GetDlgItem(IDC_LOG_FILE_EDIT));
    m_LogFileBox.SetLimitText(MAX_DIR_PATH);
    SHAutoComplete (GetDlgItem(IDC_LOG_FILE_EDIT), SHACF_FILESYSTEM);
    
    //
    // init controls
    //
    ATLASSERT(NULL != m_pFaxActLogConfig);

    //
    // To-log activity checkboxes
    //    
    fToCheck = m_pFaxActLogConfig->bLogIncoming;
    CheckState1 = (fToCheck) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(IDC_INCOMING_LOG_CHECK, CheckState1);

    fToCheck = m_pFaxActLogConfig->bLogOutgoing;
    CheckState2 = (fToCheck) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(IDC_OUTGOING_LOG_CHECK, CheckState2);

    //
    //  Log file address
    //
    m_LogFileBox.SetWindowText(m_pFaxActLogConfig->lptstrDBPath ? m_pFaxActLogConfig->lptstrDBPath : TEXT(""));

    //
    // Inactivate m_LogFileBox
    //
    if ( !(CheckState1 || CheckState2) )
    {
        EnableDataBasePath(FALSE);
    }
    else
    {
        EnableDataBasePath(TRUE); // To check IsLocalServer for Browse button
    }

    m_fIsDialogInitiated = TRUE;

    return(1);
}

/*
 -  CppFaxServerLogging::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      IN pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerLogging::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerLogging::SetProps"));
    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;
    BOOL        fSkipMessage = FALSE;

    CComBSTR    bstrLogFile;

    UINT        uRetIDS   = 0;

    FAX_ACTIVITY_LOGGING_CONFIG   FaxActLogConfig;

    HINSTANCE      hInst  = _Module.GetResourceInstance();

    //
    // Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    ZeroMemory (&FaxActLogConfig, sizeof(FAX_ACTIVITY_LOGGING_CONFIG));

    //
    // Size of struct.
    //
    FaxActLogConfig.dwSizeOfStruct = sizeof(FAX_ACTIVITY_LOGGING_CONFIG);

    //
    // To log incoming activity
    //
    if (IsDlgButtonChecked(IDC_INCOMING_LOG_CHECK) == BST_CHECKED)   
    {
        FaxActLogConfig.bLogIncoming = TRUE;
    }
    else
    {
        FaxActLogConfig.bLogIncoming = FALSE;
    }

    //
    // To log outgoing activity
    //
    if (IsDlgButtonChecked(IDC_OUTGOING_LOG_CHECK) == BST_CHECKED)   
    {
        FaxActLogConfig.bLogOutgoing = TRUE;
    }
    else
    {
        FaxActLogConfig.bLogOutgoing = FALSE;
    }

    if ( FaxActLogConfig.bLogIncoming || FaxActLogConfig.bLogOutgoing )
    {
        //
        // Log file
        //
        if ( !m_LogFileBox.GetWindowText(&bstrLogFile) )
        {
            *pCtrlFocus = IDC_LOG_FILE_EDIT;
            DebugPrintEx(
		            DEBUG_ERR,
		            TEXT("Failed to GetWindowText(&bstrLogFile)"));
        }
        
        if (!IsNotEmptyString(bstrLogFile))
        {
            DebugPrintEx( DEBUG_ERR,
			    _T("Log file path string empty or spaces only."));
            uRetIDS = IDS_LOG_PATH_EMPTY;

            *pCtrlFocus = IDC_LOG_FILE_EDIT;
        
            goto Error;
        }
        FaxActLogConfig.lptstrDBPath = bstrLogFile;
        
        //
        // follow-up for an OnApply following submition
        // with both unchecked IDC_OUTGOING_LOG_CHECK and IDC_INCOMING_LOG_CHECK
        //
        m_bstrLastGoodFolder         = bstrLogFile; 
        if (!m_bstrLastGoodFolder)
        {
            *pCtrlFocus = IDC_LOG_FILE_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to allocate string (m_bstrLastGoodFolder)."));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
    }
    else
    {
        FaxActLogConfig.lptstrDBPath = m_bstrLastGoodFolder; 
    }

    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetActivityLoggingConfiguration(m_pFaxServer->GetFaxServerHandle(),
                                            &FaxActLogConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR, _T("Fail to Set Activity Logging configuration. (ec: %ld)"), ec);

        //
        // Try to adjust folder
        // 
        PropSheet_SetCurSelByID( GetParent(), IDD);
        GotoDlgCtrl(GetDlgItem(IDC_LOG_FILE_EDIT));

        ec = AskUserAndAdjustFaxFolder(m_hWnd, 
                                       m_pFaxServer->GetServerName(), 
                                       FaxActLogConfig.lptstrDBPath, 
                                       ec);
        if(ERROR_SUCCESS != ec)
        {
            if(ERROR_BAD_PATHNAME == ec)
            {
                //
                // The error message has been shown by AskUserAndAdjustFaxFolder
                //
                fSkipMessage = TRUE;
            }
            goto Error;
        }

        //
        // The folder has been adjusted, set it again
        //
        if (!FaxSetActivityLoggingConfiguration(m_pFaxServer->GetFaxServerHandle(),
                                                &FaxActLogConfig)) 
	    {		
            ec = GetLastError();
            DebugPrintEx(DEBUG_ERR, _T("Fail to Set Activity Logging configuration. (ec: %ld)"), ec);
            goto Error;
        }
    }        


    ATLASSERT(S_OK == hRc);
    m_fIsDirty = FALSE;

    DebugPrintEx(DEBUG_MSG, _T("Succeed to set Activity Logging configuration."));

    return hRc;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    DWORD dwIDS = 0;
    switch (ec)
    {
        case ERROR_DISK_FULL:
            DebugPrintEx( DEBUG_ERR, _T("ERROR_DISK_FULL == ec"));
            dwIDS = IDS_LOGGING_ERROR_DISK_FULL;
            break;

        case FAX_ERR_FILE_ACCESS_DENIED:
            DebugPrintEx( DEBUG_ERR, _T("FAX_ERR_FILE_ACCESS_DENIED == ec"));
            dwIDS = IDS_LOGGING_FAX_ERR_FILE_ACCESS_DENIED;
            break;

        default:
            dwIDS = GetFaxServerErrorMsg(ec);
            break;
    }

    if (dwIDS && !fSkipMessage)
    {
        PropSheet_SetCurSelByID( GetParent(), IDD);         
        ATLASSERT(::IsWindow(m_hWnd));
        PageError(dwIDS, m_hWnd);
    }

    if (IsNetworkError(ec))
    {
        DebugPrintEx(DEBUG_ERR, _T("Network Error was found. (ec: %ld)"), ec);        
        m_pFaxServer->Disconnect();       
    }            

    return hRc;
}


/*
 -  CppFaxServerLogging::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerLogging::PreApply(int *pCtrlFocus, UINT * puIds)
{
    HRESULT hRc = S_OK;
    
    //
    // PreApply Checks
    //
    if (!AllReadyToApply(/*fSilent =*/ FALSE, pCtrlFocus , puIds))
    {
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        SetModified(TRUE);  
    }

    return(hRc);
}

/*
 -  CppFaxServerLogging::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerLogging::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerLogging::OnApply"));

    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;
    UINT    uIds = 0;

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = PreApply(&CtrlFocus, &uIds);
    if (FAILED(hRc))
    {
        if (PropSheet_SetCurSelByID( GetParent(), IDD) )
        {
            PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus);
        if (FAILED(hRc)) 
        {
            //Error Msg by called func.
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }

}


/*
 +  Routine Description:
 +
 *      Browse for a directory
 *
 *  Arguments:
 *
 *      hwndDlg - Specifies the dialog window on which the Browse button is displayed
 *
 *  Return Value:
 *  
 *      TRUE if successful, FALSE if the user presses Cancel
 -
 -
 */
BOOL
CppFaxServerLogging::BrowseForFile( WORD wNotifyCode, WORD wID, HWND hwndDlg, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER( wNotifyCode );
	UNREFERENCED_PARAMETER( wID );
	UNREFERENCED_PARAMETER( hwndDlg );
	UNREFERENCED_PARAMETER( bHandled );

    DEBUG_FUNCTION_NAME( _T("CppFaxServerLogging::BrowseForFile"));

    BOOL            fResult = FALSE;

    WCHAR           szBrowseFile[MAX_PATH]={0};
    WCHAR           szBrowseDlgTitle[FXS_MAX_TITLE_LEN];
    CComBSTR        bstrOldPath;
    unsigned int    len;

    unsigned long   ulBrowseFlags;

    //
    // Collecting the browse dialog headline
    //
    if (!LoadString( _Module.GetResourceInstance(), 
                IDS_GET_LOG_FILE, 
                szBrowseDlgTitle, 
                FXS_MAX_TITLE_LEN))
    {
        DWORD ec;
        ec = GetLastError();
        if (ec == ERROR_NOT_ENOUGH_MEMORY)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Out of Memory - fail to load string."));
            DlgMsgBox(this, IDS_MEMORY);
            return fResult;
        }
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to load titile string - unexpected behavior."));
        
        szBrowseDlgTitle[0] = 0;
    }

    //
    // Collecting the old path from the calling dialog edit box
    //
    if(! GetDlgItemText( IDC_LOG_FILE_EDIT, bstrOldPath.m_str))
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to collect old path from the property page edit box."));
        szBrowseFile[0] = 0;
    }
    else
    {
         len = bstrOldPath.Length();
         if ( len > MAX_PATH )
         {
             DebugPrintEx(
		        DEBUG_ERR,
		        _T("Old Path Length is bigger then alowed maximal path."));
             szBrowseFile[0] = 0;
         }
         else 
         {
             wcsncpy(szBrowseFile, bstrOldPath, ARR_SIZE(szBrowseFile)-1);
         }
    }

    //
    // Preparing the browse dialog style flags.
    //
    ulBrowseFlags       = BIF_BROWSEINCLUDEFILES | //the files also flag
                          BIF_STATUSTEXT         | 
                          BIF_NEWDIALOGSTYLE     | 
                          BIF_NONEWFOLDERBUTTON  |
                          BIF_VALIDATE;

    //
    // Invoke the browse dialog with a function based on 
    // Shell functions.
    //
    if (InvokeBrowseDialog(szBrowseFile, 
                           MAX_DIR_PATH,
                           szBrowseDlgTitle,
                           ulBrowseFlags,
                           this))
    {
        SetDlgItemText(IDC_LOG_FILE_EDIT, szBrowseFile);
        fResult = TRUE;
    }


    return fResult;
}

/*
 -  CppFaxServerLogging::SetApplyButton
 -
 *  Purpose:
 *      Modify Apply buttton.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerLogging::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
    
    SetModified(TRUE);  
    bHandled = TRUE;
    return(1);
}


/*
 -  CppFaxServerLogging::OnCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray controls
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerLogging::OnCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL fActivate = FALSE;
    
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 1;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
    

    if ( 
        BST_CHECKED == IsDlgButtonChecked(IDC_INCOMING_LOG_CHECK) 
      ||
        BST_CHECKED == IsDlgButtonChecked(IDC_OUTGOING_LOG_CHECK)  
       )
    {
        if (AllReadyToApply(TRUE))
        {
            SetModified(TRUE);  
        }
        else
        {
            SetModified(FALSE);  
        }
        
        fActivate = TRUE;

    }
    else
    {
        SetModified(TRUE);  
    }
    EnableDataBasePath(fActivate);

    return(1);
}


/*
 -  CppFaxServerLogging::OnCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray controls
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerLogging::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL fActivate = FALSE;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 1;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
    

    if (AllReadyToApply(TRUE))
    {
        SetModified(TRUE);  
    }
    else
    {
        SetModified(FALSE);  
    }

    return(1);
}


/*
 -  CppFaxServerLogging::AllReadyToApply
 -
 *  Purpose:
 *      This function validate that no zero length strings 
 *      are found data areas that should be saved.
 *
 *  Arguments:
 *      [in] fSilent - boolean who defines if to pop up messages (FALSE)
 *           or not.(TRUE)
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerLogging::AllReadyToApply(BOOL fSilent, int *pCtrlFocus, UINT *pIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerLogging::AllReadyToApply"));
	
    DWORD  ec  = ERROR_SUCCESS;
    
    if ( 
            BST_CHECKED == IsDlgButtonChecked(IDC_INCOMING_LOG_CHECK) 
          ||
            BST_CHECKED == IsDlgButtonChecked(IDC_OUTGOING_LOG_CHECK)  
        )
    {
        if ( !m_LogFileBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero text length - m_LogFileBox. (ec: %ld)"), 
			    ec);
        
            if (!fSilent)
            {
                *pCtrlFocus = IDC_LOG_FILE_EDIT;
                *pIds = IDS_LOG_PATH_EMPTY;
            }
            return FALSE;    
        }
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    
    //
	// Cheers! 
	//		...every thing ready to apply now.
	//
	return TRUE;           
}

/*
 -  CppFaxServerLogging::EnableDataBasePath
 -
 *  Purpose:
 *      Enable/dissable the data base path controls.
 *
 *  Arguments:
 *      [in] state - boolean value to enable TRUE or FALSE to disable
 *
 *  Return:
 *      void
 */
void CppFaxServerLogging::EnableDataBasePath(BOOL fState)
{
    ::EnableWindow(GetDlgItem(IDC_LOG_FILE_EDIT), fState);
    ::EnableWindow(GetDlgItem(IDC_LOG_BROWSE_BUTTON), fState && m_fIsLocalServer);
    ::EnableWindow(GetDlgItem(IDC_DATABASE_FSTATIC), fState);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerLogging::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerLogging::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerLogging::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxserverlogging.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerLogging.h                                   //
//                                                                         //
//  DESCRIPTION   : Fax Server general prop page header file               //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXSERVER_LOGGING_H_
#define _PP_FAXSERVER_LOGGING_H_

#include <proppageex.h>
class CFaxServerNode;
class CFaxServer;
/////////////////////////////////////////////////////////////////////////////
// CppFaxServerLogging dialog

class CppFaxServerLogging : public CPropertyPageExImpl<CppFaxServerLogging>
{

public:
    //
    // Constructor
    //
    CppFaxServerLogging(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           fIsLocalServer,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxServerLogging();

	enum { IDD = IDD_FAXSERVER_LOGGING };

	BEGIN_MSG_MAP(CppFaxServerLogging)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )

        COMMAND_HANDLER( IDC_LOG_BROWSE_BUTTON,  BN_CLICKED, BrowseForFile  )
        COMMAND_HANDLER( IDC_INCOMING_LOG_CHECK, BN_CLICKED, OnCheckboxClicked )
        COMMAND_HANDLER( IDC_OUTGOING_LOG_CHECK, BN_CLICKED, OnCheckboxClicked )
        COMMAND_HANDLER( IDC_LOG_FILE_EDIT,      EN_CHANGE,  OnTextChanged )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerLogging>)
	END_MSG_MAP()

	//
	// Dialog's Handlers and events.
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL OnApply();

    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus, UINT * puIds);

private:
    //
    // Control members
    //
    CEdit   m_LogFileBox;
    
    BOOL    m_fIsDialogInitiated;
    BOOL    m_fIsDirty;

    BOOL    m_fIsLocalServer;

    //
    // Config Structure member
    //
    PFAX_ACTIVITY_LOGGING_CONFIG    m_pFaxActLogConfig;
    
    CComBSTR                        m_bstrLastGoodFolder;

    //
    // Handles
    //
    CFaxServerNode * m_pParentNode;    

    //
    // Browse
    //
    BOOL BrowseForFile(WORD wNotifyCode, WORD wID, HWND hwndDlg, BOOL& bHandled);

    //
    // Event methods
    //
    LRESULT SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    void EnableDataBasePath(BOOL fState);
    
    BOOL AllReadyToApply(BOOL fSilent, int *pCtrlFocus = NULL, UINT *pIds = NULL);
    
    LRESULT OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);


    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};

#endif // _PP_FAXSERVER_LOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxserveroutbox.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerOutbox.cpp                                  //
//                                                                         //
//  DESCRIPTION   : prop pages of                                          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Nov 24 1999 yossg  OnApply create call to all tabs from parent     //
//                         add Branding                                    //
//      Apr 24 2000 yossg  Add discount rate time                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerOutbox.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FxsValid.h"
#include "dlgutils.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxServerOutbox::CppFaxServerOutbox(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerOutbox>(pNode, NULL)
			                	
{
    m_pParentNode = static_cast <CFaxServerNode *> (pNode);
    m_pFaxOutboxConfig = NULL;

    m_fAllReadyToApply  = FALSE;
    m_fIsDialogInitiated = FALSE;
    
    m_fIsDirty              = FALSE;
}


//
// Destructor
//
CppFaxServerOutbox::~CppFaxServerOutbox()
{
    if (NULL != m_pFaxOutboxConfig)
    {
        FaxFreeBuffer( m_pFaxOutboxConfig );
    }
}


/////////////////////////////////////////////////////////////////////////////
// CppFaxServerOutbox message handlers

/*
 -  CppFaxServerOutbox::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerOutbox::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerOutbox::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;

    //
    // get RPC Handle
    //   


    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

	//
	// Retrieve the fax Archive configuration
	//
    if (!FaxGetOutboxConfiguration(m_pFaxServer->GetFaxServerHandle(), 
                                    &m_pFaxOutboxConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get SMTP configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(m_pFaxOutboxConfig);


	
    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get outbox configuration."));

    goto Exit;

Error:
	ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));

Exit:
    return (hRc);
    
}

    
 /*
 -  CppFaxServerOutbox::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
LRESULT CppFaxServerOutbox::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerOutbox::PageInitDialog"));

	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );

    BOOL        fToCheck;
    UINT        CheckState;
    int         iRetries,
                iRetryDelay,
                iAgeLimit;
    
    TCHAR       tszSecondsFreeTimeFormat[FXS_MAX_TIMEFORMAT_LEN];
    SYSTEMTIME  stStart;
    SYSTEMTIME  stStop;


    //
    // Attach controls
    // 
    m_RetriesBox.Attach(GetDlgItem(IDC_RETRIES_EDIT));
    m_RetryDelayBox.Attach(GetDlgItem(IDC_RETRYDELAY_EDIT));
    m_DaysBox.Attach(GetDlgItem(IDC_DAYS_EDIT));

    m_RetriesBox.SetLimitText(FXS_RETRIES_LENGTH);
    m_RetryDelayBox.SetLimitText(FXS_RETRYDELAY_LENGTH);
    m_DaysBox.SetLimitText(FXS_DIRTYDAYS_LENGTH);

    m_RetriesSpin.Attach(GetDlgItem(IDC_RETRIES_SPIN));
    m_RetryDelaySpin.Attach(GetDlgItem(IDC_RETRYDELAY_SPIN));
    m_DaysSpin.Attach(GetDlgItem(IDC_DAYS_SPIN));

    m_StartTimeCtrl.Attach(GetDlgItem(IDC_DISCOUNT_START_TIME));
    m_StopTimeCtrl.Attach(GetDlgItem(IDC_DISCOUNT_STOP_TIME));

    //
    // Set Time Format
    //
    
    //
    // GetSecondsFreeTimeFormat is a util func
    // which builds TimeFormat according UserLocal without seconds 
    // If any internal failure occures - an hardcoded default seconds free 
    // time format ("hh:mm tt") is retreived.
    //
    GetSecondsFreeTimeFormat(tszSecondsFreeTimeFormat, FXS_MAX_TIMEFORMAT_LEN);

    m_StartTimeCtrl.SetFormat(tszSecondsFreeTimeFormat);
    m_StopTimeCtrl.SetFormat(tszSecondsFreeTimeFormat);

    //
    // init controls
    // 
    ATLASSERT(NULL != m_pFaxOutboxConfig);
    
    //
    // Branding
    //
    fToCheck = m_pFaxOutboxConfig->bBranding;
    CheckState = (fToCheck) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(IDC_BRANDING_CHECK, CheckState) ;

    //
    //ALLOW_PERSONAL_CHECK
    //
    fToCheck = m_pFaxOutboxConfig->bAllowPersonalCP;
    CheckState = (fToCheck) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(IDC_ALLOW_PERSONAL_CHECK, CheckState) ;

    //
    //TSID_CHECK
    //
    fToCheck = m_pFaxOutboxConfig->bUseDeviceTSID;
    CheckState = (fToCheck) ? BST_CHECKED  : BST_UNCHECKED;
    CheckDlgButton(IDC_TSID_CHECK, CheckState) ;

    //
    // Retries
    //
    iRetries = (int)m_pFaxOutboxConfig->dwRetries;

    m_RetriesSpin.SetRange(FXS_RETRIES_LOWER, FXS_RETRIES_UPPER);
    m_RetriesSpin.SetPos(iRetries);

    //
    // Retry Delay
    //
    iRetryDelay = (int)m_pFaxOutboxConfig->dwRetryDelay;

    m_RetryDelaySpin.SetRange(FXS_RETRYDELAY_LOWER, FXS_RETRYDELAY_UPPER);
    m_RetryDelaySpin.SetPos(iRetryDelay);

    //
    // Message life-time / dirty days / age limit
    //
    iAgeLimit = (int)m_pFaxOutboxConfig->dwAgeLimit;

    m_DaysSpin.SetRange(FXS_DIRTYDAYS_LOWER, FXS_DIRTYDAYS_UPPER);
    m_DaysSpin.SetPos(iAgeLimit);

    //
    // Discount rate time
    //
    ::GetLocalTime(&stStart);
    ::GetLocalTime(&stStop);

    
    stStart.wHour   = m_pFaxOutboxConfig->dtDiscountStart.Hour;
    stStart.wMinute = m_pFaxOutboxConfig->dtDiscountStart.Minute;

    stStop.wHour    = m_pFaxOutboxConfig->dtDiscountEnd.Hour;
    stStop.wMinute  = m_pFaxOutboxConfig->dtDiscountEnd.Minute;

    if (!m_StartTimeCtrl.SetSystemTime(GDT_VALID, &stStart))
	{
		DebugPrintEx(DEBUG_ERR, _T("Fail to SetSystemTime for discount start."));
	}
    if (!m_StopTimeCtrl.SetSystemTime(GDT_VALID, &stStop))
	{
		DebugPrintEx(DEBUG_ERR, _T("Fail to SetSystemTime for discount end."));
	}

    //
    // Auto Delete
    //
    if (FXS_DIRTYDAYS_ZERO == iAgeLimit)
    {
      CheckDlgButton(IDC_DELETE_CHECK, BST_UNCHECKED);

      ::EnableWindow(GetDlgItem(IDC_DAYS_EDIT), FALSE);
      ::EnableWindow(GetDlgItem(IDC_DAYS_SPIN), FALSE);
    }
    else
    {
      CheckDlgButton(IDC_DELETE_CHECK, BST_CHECKED);
    }

    m_fIsDialogInitiated = TRUE;

    return(1);
}

/*
 -  CppFaxServerOutbox::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerOutbox::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerOutbox::SetProps"));
    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;

    HINSTANCE   hInst  = _Module.GetResourceInstance();


    SYSTEMTIME  stStart;
    SYSTEMTIME  stStop;

    FAX_OUTBOX_CONFIG   FaxOutboxConfig;

    ATLASSERT(TRUE == m_fAllReadyToApply);
    m_fAllReadyToApply = FALSE;

    //
    // Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    ZeroMemory (&FaxOutboxConfig, sizeof(FAX_OUTBOX_CONFIG));

    //
    // Size of struct.
    //
    FaxOutboxConfig.dwSizeOfStruct = sizeof(FAX_OUTBOX_CONFIG);

    //
    // Branding
    //
    if (IsDlgButtonChecked(IDC_BRANDING_CHECK) == BST_CHECKED)   
    {
        FaxOutboxConfig.bBranding = TRUE;
    }
    else
    {
        FaxOutboxConfig.bBranding = FALSE;
    }

    //
    // IDC_ALLOW_PERSONAL_CHECK
    //
    if (IsDlgButtonChecked(IDC_ALLOW_PERSONAL_CHECK) == BST_CHECKED)   
    {
        FaxOutboxConfig.bAllowPersonalCP = TRUE;
    }
    else
    {
        FaxOutboxConfig.bAllowPersonalCP = FALSE;
    }
    
    //
    // IDC_TSID_CHECK
    //
    if (IsDlgButtonChecked(IDC_TSID_CHECK) == BST_CHECKED)   
    {
        FaxOutboxConfig.bUseDeviceTSID = TRUE;
    }
    else
    {
        FaxOutboxConfig.bUseDeviceTSID = FALSE;
    }
    
    //
    // Retries, Retry Delay
    //
    int iRetries = m_RetriesSpin.GetPos();
    FaxOutboxConfig.dwRetries = (DWORD) iRetries;

    int iRetryDelay = m_RetryDelaySpin.GetPos();
    FaxOutboxConfig.dwRetryDelay = (DWORD) iRetryDelay;

    //
    // IDC_DELETE_CHECK  - AutoDelete Messages
    //
    if (IsDlgButtonChecked(IDC_DELETE_CHECK) == BST_CHECKED)   
    {
       int iAgeLimit = m_DaysSpin.GetPos();
       FaxOutboxConfig.dwAgeLimit = (DWORD) iAgeLimit;
    }
    else
    {
       FaxOutboxConfig.dwAgeLimit = (DWORD) FXS_DIRTYDAYS_ZERO;
    }
    
    //
    // Discount rate time
    //
    m_StartTimeCtrl.GetSystemTime(&stStart);
    m_StopTimeCtrl.GetSystemTime(&stStop);

    FaxOutboxConfig.dtDiscountStart.Hour    = stStart.wHour;
    FaxOutboxConfig.dtDiscountStart.Minute  = stStart.wMinute;
    FaxOutboxConfig.dtDiscountEnd.Hour      = stStop.wHour;
    FaxOutboxConfig.dtDiscountEnd.Minute    = stStop.wMinute;

    //
    // get RPC Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetOutboxConfiguration(
                m_pFaxServer->GetFaxServerHandle(),
                &FaxOutboxConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Set outbox configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }
        
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    m_fIsDirty = FALSE;

    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set outbox configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    PropSheet_SetCurSelByID( GetParent(), IDD);         
    ATLASSERT(::IsWindow(m_hWnd));
    PageError(GetFaxServerErrorMsg(ec),m_hWnd);

Exit:    
    return(hRc);
}


/*
 -  CppFaxServerOutbox::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerOutbox::PreApply(int *pCtrlFocus, UINT * puIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerOutbox::PreApply"));
    HRESULT hRc = S_OK;
    
    //
    // PreApply Checks
    //
    if (!AllReadyToApply(/*fSilent =*/ FALSE, pCtrlFocus , puIds))
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }

    return(hRc);
}

/*
 -  CppFaxServerOutbox::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerOutbox::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerOutbox::OnApply"));


    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;
    UINT    uIds = 0;

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = PreApply(&CtrlFocus, &uIds);
    if (FAILED(hRc))
    {
        if (PropSheet_SetCurSelByID( GetParent(), IDD) )
        {
            PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus);
        if (FAILED(hRc)) 
        {
            //Error Msg by called func.
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }

}


/*
 -  CppFaxServerOutbox::OnTimeChange
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerOutbox::OnTimeChange(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)
{

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
    

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}

/*
 -  CppFaxServerOutbox::CheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerOutbox::CheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}

/*
 -  CppFaxServerOutbox::AutoDelCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the spin button and edit box
 *      and enable apply button after Auto Delete Checkbox 
 *      status was changed.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerOutbox::AutoDelCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_DELETE_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_DAYS_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_DAYS_SPIN), State);    

    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_DaysBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else if ( 0 != HIWORD( m_DaysSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}


/*
 -  CppFaxServerOutbox::EditBoxChanged
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerOutbox::EditBoxChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (!m_fIsDialogInitiated)
    {
        return 1;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
        
        
    if (m_fAllReadyToApply) //only last change should be considered
    {
        switch (wID)
        {
            case IDC_RETRIES_EDIT:
                if ( !m_RetriesBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
				break;

            case IDC_RETRYDELAY_EDIT:
                if ( !m_RetryDelayBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
				break;

            case IDC_DAYS_EDIT:
                if ( !m_DaysBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                else if ( 0 != HIWORD( m_DaysSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
                {
                    m_fAllReadyToApply = FALSE;
                    SetModified(FALSE);
                }
				break;

            default:
                return 1;
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return 1;
}



/*
 -  CppFaxServerOutbox::AllReadyToApply
 -
 *  Purpose:
 *      This function validate that no zero length strings 
 *      are found data areas that should be saved.
 *
 *  Arguments:
 *      [in] fSilent - boolean who defines if to pop up messages (FALSE)
 *           or not.(TRUE)
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerOutbox::AllReadyToApply(BOOL fSilent, int *pCtrlFocus, UINT *pIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerOutbox::AllReadyToApply"));
	
    DWORD         ec  = ERROR_SUCCESS;
    
    HINSTANCE     hInst = _Module.GetResourceInstance();

    if ( !m_RetriesBox.GetWindowTextLength() )    
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Zero text length - m_RetriesBox. (ec: %ld)"), 
			ec);
    
        if (!fSilent)
        {
            *pIds = IDS_OUTB_RETRIES_EMPTY;
            *pCtrlFocus = IDC_RETRIES_EDIT;
        }
        return FALSE;    
    }

    if ( !m_RetryDelayBox.GetWindowTextLength() )    
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Zero text length - m_RetryDelayBox. (ec: %ld)"), 
			ec);
    
        if (!fSilent)
        {
            *pIds = IDS_OUTB_RETRYDELAY_EMPTY;
            *pCtrlFocus = IDC_RETRYDELAY_EDIT;
        }
        return FALSE;    
    }

    if (IsDlgButtonChecked(IDC_DELETE_CHECK) == BST_CHECKED)
    {
        if ( !m_DaysBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero text length - m_DaysBox. (ec: %ld)"), 
			    ec);
        
            if (!fSilent)
            {
                *pIds = IDS_OUTB_DAYS_EMPTY;
                *pCtrlFocus = IDC_DAYS_EDIT;
            }
            return FALSE;    
        }
        else if ( 0 != HIWORD( m_DaysSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero value - m_DaysBox."));
        
            if (!fSilent)
            {
                *pIds = IDS_OUTB_DAYS_EMPTY;
                *pCtrlFocus = IDC_DAYS_EDIT;
            }
            return FALSE;    
        }

    }

    ATLASSERT(ERROR_SUCCESS == ec);
    
    //
	// Cheers! 
	//		...every thing ready to apply now.
	//
	return TRUE;           
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerOutbox::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerOutbox::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerOutbox::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxserveroutbox.h ===
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  DESCRIPTION   : Fax Server Outbox prop page header file                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Apr 24 2000 yossg  Add discount rate time                          //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXSERVER_OUTBOX_H_
#define _PP_FAXSERVER_OUTBOX_H_

#include "MyCtrls.h"
#include <proppageex.h>

class CFaxServerNode;
class CFaxServer;
/////////////////////////////////////////////////////////////////////////////
// CppFaxServerOutbox dialog

class CppFaxServerOutbox : public CPropertyPageExImpl<CppFaxServerOutbox>
{

public:
    //
    // Constructor
    //
    CppFaxServerOutbox(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxServerOutbox();

	enum { IDD = IDD_FAXSERVER_OUTBOX };

	BEGIN_MSG_MAP(CppFaxServerOutbox)
		MESSAGE_HANDLER( WM_INITDIALOG,     OnInitDialog )

        COMMAND_HANDLER( IDC_BRANDING_CHECK,       BN_CLICKED, CheckboxClicked )
        COMMAND_HANDLER( IDC_ALLOW_PERSONAL_CHECK, BN_CLICKED, CheckboxClicked )

        COMMAND_HANDLER( IDC_TSID_CHECK,           BN_CLICKED, CheckboxClicked )
		
        COMMAND_HANDLER( IDC_RETRIES_EDIT,         EN_CHANGE,  EditBoxChanged  )
		COMMAND_HANDLER( IDC_RETRYDELAY_EDIT,      EN_CHANGE,  EditBoxChanged  )

        COMMAND_HANDLER( IDC_DELETE_CHECK,         BN_CLICKED, AutoDelCheckboxClicked)
        COMMAND_HANDLER( IDC_DAYS_EDIT,            EN_CHANGE,  EditBoxChanged  )

        NOTIFY_HANDLER ( IDC_DISCOUNT_START_TIME,  DTN_DATETIMECHANGE,  OnTimeChange )
        NOTIFY_HANDLER ( IDC_DISCOUNT_STOP_TIME,   DTN_DATETIMECHANGE,  OnTimeChange )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerOutbox>)
	END_MSG_MAP()

	//
	// Dialog's Handler and events.
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();

    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus, UINT * puIds);

private:
    //
    // Control members
    //
    CMyUpDownCtrl m_RetriesSpin;
    CMyUpDownCtrl m_RetryDelaySpin;
    CMyUpDownCtrl m_DaysSpin;

    CEdit m_RetriesBox;
    CEdit m_RetryDelayBox;
    CEdit m_DaysBox;

    CDateTimePickerCtrl m_StartTimeCtrl;
    CDateTimePickerCtrl m_StopTimeCtrl;

    //
    // Boolean members
    //
    BOOL  m_fAllReadyToApply;
    BOOL  m_fIsDialogInitiated;
    BOOL  m_fIsDirty;

    //
    // Config Structure member
    //
    PFAX_OUTBOX_CONFIG    m_pFaxOutboxConfig;

    //
    // Handles
    //
    CFaxServerNode * m_pParentNode;    

    //
    // Event methods
    //
    LRESULT CheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT EditBoxChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT AutoDelCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnTimeChange(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    BOOL AllReadyToApply(BOOL fSilent, int *pCtrlFocus = NULL, UINT *pIds = NULL);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};


#endif // _PP_FAXSERVER_OUTBOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxserverreceipts.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerReceipts.h                                  //
//                                                                         //
//  DESCRIPTION   : Fax Server Receipts prop page header file              //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 20 2000 yossg  New design - all delivery receipts options      //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXSERVER_RECEIPTS_H_
#define _PP_FAXSERVER_RECEIPTS_H_

class CFaxServerNode;
class CFaxServer;
/////////////////////////////////////////////////////////////////////////////
// CppFaxServerReceipts dialog

#include <proppageex.h>
class CppFaxServerReceipts : public CPropertyPageExImpl<CppFaxServerReceipts>
{

public:
    //
    // Constructor
    //
    CppFaxServerReceipts(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxServerReceipts();

	enum { IDD = IDD_FAXSERVER_RECEIPTS };

	BEGIN_MSG_MAP(CppFaxServerReceipts)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )

        COMMAND_HANDLER( IDC_SMTP_EDIT,     EN_CHANGE, OnTextChanged )
		COMMAND_HANDLER( IDC_PORT_EDIT,     EN_CHANGE, OnTextChanged )
		COMMAND_HANDLER( IDC_ADDRESS_EDIT,  EN_CHANGE, OnTextChanged )
		
        COMMAND_HANDLER( IDC_RECEIPT_ENABLE_MSGBOX_CHECK, BN_CLICKED, OnMsgBoxDeliveryOptionChecked)
        COMMAND_HANDLER( IDC_RECEIPT_ENABLE_SMTP_CHECK,   BN_CLICKED, OnDeliveryOptionChecked)
        COMMAND_HANDLER( IDC_SMTP_ROUTE_CHECK,            BN_CLICKED, OnDeliveryOptionChecked)

        COMMAND_HANDLER( IDC_AUTHENTICATION_BUTTON, BN_CLICKED, OnAuthenticationButtonClicked)
	    
        NOTIFY_HANDLER ( IDC_RECEIPTS_HELP_LINK, NM_CLICK, OnHelpLinkClicked)

        MESSAGE_HANDLER( WM_CONTEXTMENU,    OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,           OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerReceipts>)
	END_MSG_MAP()


	//
	// Dialog's Handlers and events.
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();


    HRESULT SetProps(int *pCtrlFocus, UINT * puIds);
    HRESULT PreApply(int *pCtrlFocus, UINT * puIds);

    LRESULT OnHelpLinkClicked(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    
private:
    //
    // Control members
    //
    CEdit m_SmtpBox;     // SMTP Server address
    CEdit m_PortBox;     // SMTP port on the server
    CEdit m_AddressBox;  // From e-mail address to send receipts
    
    BOOL  m_fAllReadyToApply;

    BOOL  m_fIsDialogInitiated;

    //
    // members for advance dialog
    //
    FAX_ENUM_SMTP_AUTH_OPTIONS    m_enumSmtpAuthOption;
    
    CComBSTR       m_bstrUserName;
    CComBSTR       m_bstrPassword;

    //
    // Config Structure member
    //
    PFAX_RECEIPTS_CONFIG    m_pFaxReceiptsConfig;
    
    //
    // Handles
    //
    CFaxServerNode *    m_pParentNode;    

    BOOL                m_fIsDirty;
    BOOL                m_fLastGoodIsSMTPRouteConfigured;

    //
    // Event methods
    //
    LRESULT OnDeliveryOptionChecked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnMsgBoxDeliveryOptionChecked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnAuthenticationButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    void    EnableSmtpFields(BOOL state);

    BOOL    IsValidData(BSTR bstrSmtpSever, 
                     BSTR bstrPort, 
                     /*[OUT]*/DWORD *pdwPort,
                     BSTR bstrSenderAddress, 
                     /*[OUT]*/int *pCtrlFocus,
                     UINT *pIds);

    BOOL    AllReadyToApply(BOOL fSilent, int *pCtrlFocus = NULL, UINT *pIds = NULL);

    HRESULT IsUnderLocalUserAccount(OUT BOOL * pfIsUnderLocalUserAccount);
    LRESULT OpenBosAuthenticationDlg();

    BOOL    IsMsSMTPRoutingMethodStillAssigned();


    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};


#endif // _PP_FAXSERVER_RECEIPTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\proppageex.h ===
#include "FaxServer.h"
#include "FaxServerNode.h"

#ifndef _PP_PROPERTYPAGE_EX_
#define _PP_PROPERTYPAGE_EX_

#include <atlsnap.h>
#include <dlgutils.h>


template <class T, bool bAutoDelete = true>	
class ATL_NO_VTABLE CPropertyPageExImpl: public CSnapInPropertyPageImpl<T,bAutoDelete>
{
public:
	CPropertyPageExImpl(CSnapInItem * pParentNode,LPCTSTR lpszTitle = NULL):
		CSnapInPropertyPageImpl<T, bAutoDelete>(lpszTitle)
	{
		CSnapinItemEx * pItemEx;
		pItemEx = dynamic_cast<CSnapinItemEx *>(pParentNode);

		m_pFaxServer = (dynamic_cast<CFaxServerNode *>(pItemEx->GetRootNode()))->GetFaxServer();
		m_spConsole = ((CFaxServerNode *)pParentNode)->m_pComponentData->m_spConsole;
	}

	HRESULT
	ConsoleMsgBox(
		int ids,
		LPTSTR lptstrTitle = NULL,
		UINT fuStyle = MB_OK,
		int *piRetval = NULL,
		BOOL StringFromCommonDll = FALSE)
	{
		return ::ConsoleMsgBox(m_spConsole, ids, lptstrTitle, fuStyle, piRetval,StringFromCommonDll);
	}

protected:
	CComPtr<IConsole> m_spConsole;
	CFaxServer * m_pFaxServer;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxserversentitems.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerSentItems.cpp                               //
//                                                                         //
//  DESCRIPTION   : prop pages of Sent Items Archive                       //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Nov 24 1999 yossg  OnApply create call to all tabs from parent     //
//      Oct 17 2000 yossg                                                  //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerSentItems.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FxsValid.h"
#include "dlgutils.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// Constructor
//
CppFaxServerSentItems::CppFaxServerSentItems(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        fIsLocalServer,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerSentItems>(pNode, NULL)
{
    m_pParentNode = static_cast <CFaxServerNode *> (pNode);
    m_pFaxArchiveConfig  = NULL;

    m_fAllReadyToApply   = FALSE;
    m_fIsDialogInitiated = FALSE;
    m_fIsDirty           = FALSE;

    m_fIsLocalServer     = fIsLocalServer;
}

//
// Destructor
//
CppFaxServerSentItems::~CppFaxServerSentItems()
{
    if (NULL != m_pFaxArchiveConfig)
    {
        FaxFreeBuffer( m_pFaxArchiveConfig );
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxServerSentItems message handlers
/*
 -  CppFaxServerSentItems::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerSentItems::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerSentItems::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;

    //
    // get RPC Handle
    //   
    
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

	//
	// Retrieve the fax sent items configuration
	//
    if (!FaxGetArchiveConfiguration(m_pFaxServer->GetFaxServerHandle(), 
                                    FAX_MESSAGE_FOLDER_SENTITEMS, 
                                    &m_pFaxArchiveConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get sent items configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(m_pFaxArchiveConfig);

    //
    // Init specific members for set proprties follow-up
    //
    m_dwLastGoodSizeQuotaHighWatermark = m_pFaxArchiveConfig->dwSizeQuotaHighWatermark;
    m_dwLastGoodSizeQuotaLowWatermark  = m_pFaxArchiveConfig->dwSizeQuotaLowWatermark;
    m_bstrLastGoodFolder               = m_pFaxArchiveConfig->lpcstrFolder;
    if (!m_bstrLastGoodFolder)
    {
		DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Failed to allocate string (m_bstrLastGoodFolder)."));
        ec = ERROR_OUTOFMEMORY;
        
        goto Error;
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get sent items archive configuration."));
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}

/*
 -  CppFaxServerSentItems::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
LRESULT CppFaxServerSentItems::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerSentItems::PageInitDialog"));

	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );

    int          iLow,
                 iHigh,
                 iAgeLimit;

    //
    // init controls
    // 
    m_FolderBox.Attach(GetDlgItem(IDC_FOLDER_EDIT));
    m_FolderBox.SetLimitText(MAX_ARCHIVE_FOLDER_PATH);
    SHAutoComplete (GetDlgItem(IDC_FOLDER_EDIT), SHACF_FILESYSTEM);

    m_HighWatermarkBox.Attach(GetDlgItem(IDC_SENT_HIGH_EDIT));
    m_LowWatermarkBox.Attach(GetDlgItem(IDC_SENT_LOW_EDIT));
    m_AutoDelBox.Attach(GetDlgItem(IDC_SENT_AUTODEL_EDIT));

    m_HighWatermarkBox.SetLimitText(FXS_QUOTA_LENGTH);
    m_LowWatermarkBox.SetLimitText(FXS_QUOTA_LENGTH);
    m_AutoDelBox.SetLimitText(FXS_DIRTYDAYS_LENGTH);

    m_HighWatermarkSpin.Attach(GetDlgItem(IDC_SENT_HIGH_SPIN));
    m_LowWatermarkSpin.Attach(GetDlgItem(IDC_SENT_LOW_SPIN));
    m_AutoDelSpin.Attach(GetDlgItem(IDC_SENT_AUTODEL_SPIN));

    ATLASSERT(NULL != m_pFaxArchiveConfig);
    
    //
    // FOLDER_EDIT
    //
    m_FolderBox.SetWindowText(m_pFaxArchiveConfig->lpcstrFolder);

    //
    // Disable Browse button for remote admin
    //
    if (!m_fIsLocalServer)
    {
        ::EnableWindow(GetDlgItem(IDC_SENT_BROWSE_BUTTON), FALSE); 
    }

    //
    // TO_ARCHIVE_CHECK
    //
    if (m_pFaxArchiveConfig->bUseArchive) 
    {
        CheckDlgButton(IDC_SENT_TO_ARCHIVE_CHECK, BST_CHECKED) ;
    }
    else
    {
        CheckDlgButton(IDC_SENT_TO_ARCHIVE_CHECK, BST_UNCHECKED) ;
        ::EnableWindow(GetDlgItem(IDC_FOLDER_EDIT), FALSE);    
        ::EnableWindow(GetDlgItem(IDC_SENT_BROWSE_BUTTON), FALSE);    
    }

    //
    // Quota size - Low
    //
    iLow = (int)m_pFaxArchiveConfig->dwSizeQuotaLowWatermark;

    m_LowWatermarkSpin.SetRange(FXS_QUOTA_LOW_LOWER, FXS_QUOTA_LOW_UPPER);
    m_LowWatermarkSpin.SetPos(iLow);

    //
    // Quota size - High
    //    
    iHigh = (int)m_pFaxArchiveConfig->dwSizeQuotaHighWatermark;

    m_HighWatermarkSpin.SetRange(FXS_QUOTA_HIGH_LOWER, FXS_QUOTA_HIGH_UPPER);
    m_HighWatermarkSpin.SetPos(iHigh);
    
    //
    //Generate event log warning
    //
    if (m_pFaxArchiveConfig->bSizeQuotaWarning) 
    {
        CheckDlgButton(IDC_SENT_GENERATE_WARNING_CHECK, BST_CHECKED) ;
    }
    else
    {
        CheckDlgButton(IDC_SENT_GENERATE_WARNING_CHECK, BST_UNCHECKED) ;
        ::EnableWindow(GetDlgItem(IDC_SENT_HIGH_EDIT), FALSE);    
        ::EnableWindow(GetDlgItem(IDC_SENT_HIGH_SPIN), FALSE);    

        ::EnableWindow(GetDlgItem(IDC_SENT_LOW_EDIT), FALSE);    
        ::EnableWindow(GetDlgItem(IDC_SENT_LOW_SPIN), FALSE);    
    }

    //
    // message Age Limit (dirty days)
    //
    iAgeLimit = (int)m_pFaxArchiveConfig->dwAgeLimit;

    m_AutoDelSpin.SetRange(FXS_DIRTYDAYS_LOWER, FXS_DIRTYDAYS_UPPER);
    m_AutoDelSpin.SetPos(iAgeLimit);

    //
    // Auto Delete
    //
    if (FXS_DIRTYDAYS_ZERO == iAgeLimit)
    {
      CheckDlgButton(IDC_SENT_AUTODEL_CHECK, BST_UNCHECKED);

      ::EnableWindow(GetDlgItem(IDC_SENT_AUTODEL_EDIT), FALSE);
      ::EnableWindow(GetDlgItem(IDC_SENT_AUTODEL_SPIN), FALSE);
    }
    else
    {
      CheckDlgButton(IDC_SENT_AUTODEL_CHECK, BST_CHECKED);
    }

    m_fIsDialogInitiated = TRUE;
    
    return(1);
}

/*
 -  CppFaxServerSentItems::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerSentItems::SetProps(int *pCtrlFocus, UINT * puIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerSentItems::SetProps"));
    HRESULT       hRc = S_OK;
    DWORD         ec  = ERROR_SUCCESS;
    HINSTANCE     hInst     = _Module.GetResourceInstance();


    BOOL          fSkipMessage = FALSE;

    CComBSTR      bstrFolder = L"";

    FAX_ARCHIVE_CONFIG   FaxArchiveConfig;

    ATLASSERT(TRUE == m_fAllReadyToApply);
    m_fAllReadyToApply = FALSE;
    
    //
    // Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    ZeroMemory (&FaxArchiveConfig, sizeof(FAX_ARCHIVE_CONFIG));

    //
    // Size of struct.
    //
    FaxArchiveConfig.dwSizeOfStruct = sizeof(FAX_ARCHIVE_CONFIG);

    //
    // IDC_SENT_TO_ARCHIVE_CHECK
    //
    if (IsDlgButtonChecked(IDC_SENT_TO_ARCHIVE_CHECK) == BST_CHECKED)   
    {
        FaxArchiveConfig.bUseArchive = TRUE;
        
        //IDC_FOLDER_EDIT
        if ( !m_FolderBox.GetWindowText(&bstrFolder))
        {
            *pCtrlFocus = IDC_FOLDER_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrFolder)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
        if (!IsNotEmptyString(bstrFolder))
        {
            *pCtrlFocus = IDC_FOLDER_EDIT;
            * puIds = IDS_SENT_ARCHIVE_PATH_EMPTY;
            
            DebugPrintEx( DEBUG_ERR,
			    _T("Archive path string is empty or includes spaces only."));
            
            fSkipMessage = TRUE;

            ec = ERROR_INVALID_DATA;
        
            goto Error;
        }
        FaxArchiveConfig.lpcstrFolder = bstrFolder;
        
        //
        // follow-up for an OnApply following submition
        // with unchecked IDC_SENT_TO_ARCHIVE_CHECK
        //
        m_bstrLastGoodFolder          = bstrFolder; 
        if (!m_bstrLastGoodFolder)
        {
            *pCtrlFocus = IDC_FOLDER_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to allocate string (m_bstrLastGoodFolder)."));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
    }
    else
    {
        FaxArchiveConfig.bUseArchive  = FALSE;
        FaxArchiveConfig.lpcstrFolder = m_bstrLastGoodFolder; 
    }
    
    //
    // IDC_SENT_GENERATE_WARNING_CHECK
    //
    if (IsDlgButtonChecked(IDC_SENT_GENERATE_WARNING_CHECK) == BST_CHECKED)   
    {
        FaxArchiveConfig.bSizeQuotaWarning = TRUE;

        int iHigh = m_HighWatermarkSpin.GetPos();
        FaxArchiveConfig.dwSizeQuotaHighWatermark = (DWORD) iHigh;

        int iLow = m_LowWatermarkSpin.GetPos();
        FaxArchiveConfig.dwSizeQuotaLowWatermark = (DWORD) iLow;

        if (iHigh <= iLow)
        {
            *pCtrlFocus = IDC_SENT_HIGH_EDIT;
            * puIds = IDS_WATERMARK_HI_LOW;
            
            DebugPrintEx( DEBUG_ERR,
			    _T("Watermark High < Low."));
            
            fSkipMessage = TRUE;

            ec = ERROR_INVALID_DATA;
        
            goto Error;
        }
        //
        // follow-up for an OnApply following submition
        // with unchecked IDC_SENT_GENERATE_WARNING_CHECK
        //
        m_dwLastGoodSizeQuotaHighWatermark = (DWORD)iHigh;
        m_dwLastGoodSizeQuotaLowWatermark  = (DWORD)iLow;
    }
    else
    {
        FaxArchiveConfig.bSizeQuotaWarning = FALSE;

        FaxArchiveConfig.dwSizeQuotaHighWatermark = m_dwLastGoodSizeQuotaHighWatermark;
        FaxArchiveConfig.dwSizeQuotaLowWatermark  = m_dwLastGoodSizeQuotaLowWatermark;
    }
    
    //
    // IDC_SENT_AUTODEL_CHECK  - AutoDelete Messages
    //
    if (IsDlgButtonChecked(IDC_SENT_AUTODEL_CHECK) == BST_CHECKED)   
    {       
        int iAgeLimit = m_AutoDelSpin.GetPos();
        FaxArchiveConfig.dwAgeLimit = (DWORD) iAgeLimit;
    }
    else
    {
        FaxArchiveConfig.dwAgeLimit = (DWORD)FXS_DIRTYDAYS_ZERO;
    }
        
    //
    // get RPC Handle
    //   
    
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetArchiveConfiguration(
                m_pFaxServer->GetFaxServerHandle(),
                FAX_MESSAGE_FOLDER_SENTITEMS,
                &FaxArchiveConfig)) 
    {		
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR, _T("Fail to Set sent items configuration. (ec: %ld)"), ec);

        //
        // Try to adjust folder
        // 
        PropSheet_SetCurSelByID( GetParent(), IDD);
        GotoDlgCtrl(GetDlgItem(IDC_FOLDER_EDIT));

        ec = AskUserAndAdjustFaxFolder(m_hWnd, 
                                       m_pFaxServer->GetServerName(), 
                                       FaxArchiveConfig.lpcstrFolder, 
                                       ec);
        if(ERROR_SUCCESS != ec)
        {
            if(ERROR_BAD_PATHNAME == ec)
            {
                //
                // The error message has been shown by AskUserAndAdjustFaxFolder
                //
                fSkipMessage = TRUE;
            }
            goto Error;
        }

        //
        // The folder has been adjusted, set it again
        //
        if (!FaxSetArchiveConfiguration(m_pFaxServer->GetFaxServerHandle(),
                                        FAX_MESSAGE_FOLDER_SENTITEMS,
                                        &FaxArchiveConfig)) 
	    {		
            ec = GetLastError();
            DebugPrintEx(DEBUG_ERR, _T("Fail to Set inbox configuration. (ec: %ld)"), ec);
            goto Error;
        }
    }

    ATLASSERT(S_OK == hRc);
    m_fIsDirty = FALSE;

    DebugPrintEx( DEBUG_MSG, _T("Succeed to set sent-items archive configuration."));

    return hRc;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    DWORD dwIDS = 0;
    switch (ec)
    {
        case ERROR_DISK_FULL:
            DebugPrintEx( DEBUG_ERR, _T("ERROR_DISK_FULL == ec"));
            dwIDS = IDS_SENT_ERROR_DISK_FULL;
            break;
        
        case FAX_ERR_NOT_NTFS:            
            DebugPrintEx( DEBUG_ERR, _T("FAX_ERR_NOT_NTFS == ec"));
            dwIDS = IDS_SENT_FAX_ERR_NOT_NTFS;
            break;

        case FAX_ERR_FILE_ACCESS_DENIED:
            DebugPrintEx( DEBUG_ERR, _T("FAX_ERR_FILE_ACCESS_DENIED == ec"));
            dwIDS = IDS_SENT_FAX_ERR_FILE_ACCESS_DENIED;
            break;

        default:
            dwIDS = GetFaxServerErrorMsg(ec);
            break;
    }

    if (dwIDS && !fSkipMessage)
    {
        PropSheet_SetCurSelByID( GetParent(), IDD);         
        ATLASSERT(::IsWindow(m_hWnd));
        PageError(dwIDS, m_hWnd);
    }

    if (IsNetworkError(ec))
    {
        DebugPrintEx(DEBUG_ERR, _T("Network Error was found. (ec: %ld)"), ec);        
        m_pFaxServer->Disconnect();       
    }   
   
    return hRc;
}



/*
 -  CppFaxServerSentItems::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerSentItems::PreApply(int *pCtrlFocus, UINT * puIds)
{
    HRESULT hRc = S_OK;
    
    //
    // PreApply Checks
    //
    if (!AllReadyToApply(/*fSilent =*/ FALSE, pCtrlFocus , puIds))
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }

    return(hRc);
}


/*
 -  CppFaxServerSentItems::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerSentItems::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerSentItems::OnApply"));

    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;
    UINT    uIds = 0;

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = PreApply(&CtrlFocus, &uIds);
    if (FAILED(hRc))
    {
        if (PropSheet_SetCurSelByID( GetParent(), IDD) )
        {
            ATLASSERT(uIds);
            PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus, &uIds);
        if (FAILED(hRc)) 
        {
            if (uIds)
            {
                if (PropSheet_SetCurSelByID( GetParent(), IDD) )
                {
                    PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
                    if (CtrlFocus)
                    {
                        GotoDlgCtrl(GetDlgItem(CtrlFocus));
                    }
                }
            }
            //else Error Msg by called func.
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }

}

/*
 -  CppFaxServerInbox::ToArchiveCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerSentItems::ToArchiveCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;
    
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_SENT_TO_ARCHIVE_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_FOLDER_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_BROWSE_BUTTON), State && m_fIsLocalServer);    

    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_FolderBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return 1;
}

/*
 -  CppFaxServerSentItems::GenerateEventLogCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the spin buttons and edit boxes
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerSentItems::GenerateEventLogCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
    
    State = ( IsDlgButtonChecked(IDC_SENT_GENERATE_WARNING_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_SENT_HIGH_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_HIGH_SPIN), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_QUOTA_HIGH_STATIC), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_MB1_STATIC), State);    

    ::EnableWindow(GetDlgItem(IDC_SENT_LOW_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_LOW_SPIN), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_QUOTA_LOW_STATIC), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_MB2_STATIC), State);    

    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_HighWatermarkBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else if ( 0 != HIWORD( m_HighWatermarkSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else if ( !m_LowWatermarkBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}

/*
 -  CppFaxServerSentItems::AutoDelCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the spin button and edit box
 *      and enable apply button after Auto Delete Checkbox 
 *      status was changed.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerSentItems::AutoDelCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_SENT_AUTODEL_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_SENT_AUTODEL_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_AUTODEL_SPIN), State);    

    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_AutoDelBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else if ( 0 != HIWORD( m_AutoDelSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}

/*
 +  Routine Description:
 +
 *      Browse for a directory
 *
 *  Arguments:
 *
 *      hwndDlg - Specifies the dialog window on which the Browse button is displayed
 *
 *  Return Value:
 *  
 *      TRUE if successful, FALSE if the user presses Cancel
 -
 -
 */
BOOL
CppFaxServerSentItems::BrowseForDirectory( WORD wNotifyCode, WORD wID, HWND hwndDlg, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER( wNotifyCode );
	UNREFERENCED_PARAMETER( wID );
	UNREFERENCED_PARAMETER( hwndDlg );
	UNREFERENCED_PARAMETER( bHandled );

    DEBUG_FUNCTION_NAME( _T("CppFaxServerSentItems::BrowseForDirectory"));

    BOOL            fResult = FALSE;

    WCHAR           szBrowseFolder[MAX_PATH] = {0};
    WCHAR           szBrowseDlgTitle[FXS_MAX_TITLE_LEN];
    CComBSTR        bstrOldPath;
    unsigned int    len;

    unsigned long   ulBrowseFlags;

    //
    // Collecting the browse dialog headline
    //
    if (!LoadString( _Module.GetResourceInstance(), 
                IDS_GET_ARCHIVE_DIRECTORY, 
                szBrowseDlgTitle, 
                FXS_MAX_TITLE_LEN))
    {
        DWORD ec;
        ec = GetLastError();
        if (ec == ERROR_NOT_ENOUGH_MEMORY)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Out of Memory - fail to load string."));
            DlgMsgBox(this, IDS_MEMORY);
            return fResult;
        }
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to load titile string - unexpected behavior."));
        
        szBrowseDlgTitle[0] = 0;
    }

    //
    // Collecting the old path from the calling dialog edit box
    //
    if(! GetDlgItemText( IDC_FOLDER_EDIT, bstrOldPath.m_str))
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to collect old path from the property page edit box."));
        szBrowseFolder[0] = 0;
    }
    else
    {
         len = bstrOldPath.Length();
         if ( len > MAX_PATH )
         {
             DebugPrintEx(
		        DEBUG_ERR,
		        _T("Old Path Length is bigger then alowed maximal path."));
             szBrowseFolder[0] = 0;
         }
         else 
         {
             wcsncpy(szBrowseFolder, bstrOldPath, ARR_SIZE(szBrowseFolder)-1);
         }
    }

    //
    // Preparing the browse dialog style flags.
    //
    ulBrowseFlags       = BIF_RETURNONLYFSDIRS  | 
                          BIF_STATUSTEXT        | 
                          BIF_NEWDIALOGSTYLE    | 
                          BIF_NONEWFOLDERBUTTON |
                          BIF_VALIDATE;

    //
    // Invoke the browse dialog with a function based on 
    // Shell functions.
    //
    if (InvokeBrowseDialog(szBrowseFolder, 
                           MAX_ARCHIVE_FOLDER_PATH,
                           szBrowseDlgTitle,
                           ulBrowseFlags,
                           this))
    {
        SetDlgItemText(IDC_FOLDER_EDIT, szBrowseFolder);
        fResult = TRUE;
    }


    return fResult;
}

/*
 -  CppFaxServerSentItems::OnEditBoxChanged
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerSentItems::OnEditBoxChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (!m_fIsDialogInitiated)
    {
        return 1;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
        
        
    if (m_fAllReadyToApply) //only last change should be considered
    {
        switch (wID)
        {
            case IDC_FOLDER_EDIT:
                if ( !m_FolderBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                break;

            case IDC_SENT_HIGH_EDIT:
                if ( !m_HighWatermarkBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                else if ( 0 != HIWORD( m_HighWatermarkSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                break;

            case IDC_SENT_LOW_EDIT:
                if ( !m_LowWatermarkBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                break;

            case IDC_SENT_AUTODEL_EDIT:
                if ( !m_AutoDelBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                else if ( 0 != HIWORD( m_AutoDelSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
                {
                    m_fAllReadyToApply = FALSE;
                    SetModified(FALSE);
                }
                break;

            default:
                return 1;
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return 1;
}


/*
 -  CppFaxServerSentItems::AllReadyToApply
 -
 *  Purpose:
 *      This function validate that no zero length strings 
 *      are found data areas that should be saved.
 *
 *  Arguments:
 *      [in] fSilent - boolean who defines if to pop up messages (FALSE)
 *           or not.(TRUE)
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerSentItems::AllReadyToApply(BOOL fSilent, int *pCtrlFocus, UINT *pIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerSentItems::AllReadyToApply"));
	
    DWORD         ec  = ERROR_SUCCESS;
    
    if (IsDlgButtonChecked(IDC_SENT_TO_ARCHIVE_CHECK) == BST_CHECKED)
    {
        if ( !m_FolderBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero text length - m_FolderBox. (ec: %ld)"), 
			    ec);
        
            if (!fSilent)
            {
                *pCtrlFocus = IDC_FOLDER_EDIT;
                *pIds = IDS_SENT_ARCHIVE_PATH_EMPTY;
            }
            return FALSE;    
        }
    }

    if (IsDlgButtonChecked(IDC_SENT_GENERATE_WARNING_CHECK) == BST_CHECKED)
    {
        if ( !m_HighWatermarkBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero text length - m_HighWatermarkBox. (ec: %ld)"), 
                ec);
        
            if (!fSilent)
            {
                *pCtrlFocus = IDC_SENT_HIGH_EDIT;
                *pIds = IDS_WATERMARK_EMPTY;
            }
            return FALSE;    
        }
        else if ( 0 != HIWORD( m_HighWatermarkSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS    
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero value - m_HighWatermarkBox. (ec: %ld)"));
        
            if (!fSilent)
            {
                *pIds = IDS_SENT_HIGH_WATERMARK_ZERO;
                *pCtrlFocus = IDC_SENT_HIGH_EDIT;
            }
            return FALSE;    
        }

        if ( !m_LowWatermarkBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero text length - m_LowWatermarkBox. (ec: %ld)"), 
			    ec);
        
            if (!fSilent)
            {
                *pCtrlFocus = IDC_SENT_LOW_EDIT;
                *pIds = IDS_WATERMARK_EMPTY;
            }
            return FALSE;    
        }
    }

    if (IsDlgButtonChecked(IDC_SENT_AUTODEL_CHECK) == BST_CHECKED)
    {
        if ( !m_AutoDelBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero text length - m_AutoDelBox. (ec: %ld)"), 
			    ec);
        
            if (!fSilent)
            {
                *pCtrlFocus = IDC_SENT_AUTODEL_EDIT;
                *pIds = IDS_AUTODEL_EMPTY;
            }
            return FALSE;    
        }
        else if ( 0 != HIWORD( m_AutoDelSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero value - m_AutoDelBox."));
        
            if (!fSilent)
            {
                *pCtrlFocus = IDC_SENT_AUTODEL_EDIT;
                *pIds = IDS_AUTODEL_EMPTY;
            }
            return FALSE;    
        }
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    
    //
	// Cheers! 
	//		...every thing ready to apply now.
	//
	return TRUE;           
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerSentItems::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerSentItems::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerSentItems::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxserversentitems.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerSentItems.h                                 //
//                                                                         //
//  DESCRIPTION   : Fax Server Sent Items prop page header file            //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXSERVER_SENTITEMS_H_
#define _PP_FAXSERVER_SENTITEMS_H_

#include "MyCtrls.h"
#include <windows.h>
#include <proppageex.h>

class CFaxServerNode;
class CFaxServer;
/////////////////////////////////////////////////////////////////////////////
// CppFaxServerSentItems dialog

class CppFaxServerSentItems : public CPropertyPageExImpl<CppFaxServerSentItems>
{

public:
    //
    // Constructor
    //
    CppFaxServerSentItems(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           fIsLocalServer,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxServerSentItems();

	enum { IDD = IDD_FAXSERVER_SENTITEMS };

	BEGIN_MSG_MAP(CppFaxServerSentItems)
		MESSAGE_HANDLER( WM_INITDIALOG,            OnInitDialog )

        COMMAND_HANDLER( IDC_SENT_BROWSE_BUTTON,   BN_CLICKED, BrowseForDirectory)

        COMMAND_HANDLER( IDC_SENT_TO_ARCHIVE_CHECK,   BN_CLICKED, ToArchiveCheckboxClicked)
		COMMAND_HANDLER( IDC_FOLDER_EDIT,          EN_CHANGE,  OnEditBoxChanged )

		COMMAND_HANDLER( IDC_SENT_GENERATE_WARNING_CHECK,  BN_CLICKED, GenerateEventLogCheckboxClicked)
        COMMAND_HANDLER( IDC_SENT_LOW_EDIT,        EN_CHANGE,  OnEditBoxChanged )
		COMMAND_HANDLER( IDC_SENT_HIGH_EDIT,       EN_CHANGE,  OnEditBoxChanged )

		COMMAND_HANDLER( IDC_SENT_AUTODEL_CHECK,   BN_CLICKED, AutoDelCheckboxClicked)
		COMMAND_HANDLER( IDC_SENT_AUTODEL_EDIT,    EN_CHANGE,  OnEditBoxChanged )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

		CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerSentItems>)
	END_MSG_MAP()

	//
	// Dialog's Handler and events.
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();

    HRESULT SetProps(int *pCtrlFocus, UINT * puIds);
    HRESULT PreApply(int *pCtrlFocus, UINT * puIds);

private:
    //
    // Control members
    //
    CEdit         m_FolderBox;
    CButton       m_BrowseButton;
    
    CMyUpDownCtrl m_HighWatermarkSpin;
    CMyUpDownCtrl m_LowWatermarkSpin;
    CMyUpDownCtrl m_AutoDelSpin;
    
    CEdit         m_HighWatermarkBox;
    CEdit         m_LowWatermarkBox;
    CEdit         m_AutoDelBox;

    //
    // Boolean members
    //
    BOOL  m_fAllReadyToApply;
    BOOL  m_fIsDialogInitiated;
    BOOL  m_fIsDirty;

    BOOL  m_fIsLocalServer;

    //
    // Config Structure member
    //
    PFAX_ARCHIVE_CONFIG    m_pFaxArchiveConfig;
    
    CComBSTR  m_bstrLastGoodFolder;
    DWORD     m_dwLastGoodSizeQuotaHighWatermark;
    DWORD     m_dwLastGoodSizeQuotaLowWatermark;


    //
    // Handlers
    //
    CFaxServerNode * m_pParentNode;    

    //
    // Browse
    //
    BOOL BrowseForDirectory(WORD wNotifyCode, WORD wID, HWND hwndDlg, BOOL& bHandled);

    //
    // Event methods
    //
    LRESULT ToArchiveCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT GenerateEventLogCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT AutoDelCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnEditBoxChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    BOOL AllReadyToApply(BOOL fSilent, int *pCtrlFocus = NULL, UINT *pIds = NULL);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

};


#endif // _PP_FAXSERVER_SENTITEMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxserverreceipts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerReceipts.cpp                                //
//                                                                         //
//  DESCRIPTION   : prop pages of Fax Receipts server defaults             //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 20 2000 yossg  New design - all delivery receipts options      //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerReceipts.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "DlgSMTPConfig.h"
#include "BosSmtpConfigDlg.h"

#include "FxsValid.h"
#include "dlgutils.h"
#include <windns.h>    //DNS_MAX_NAME_BUFFER_LENGTH
#include <htmlHelp.h>  //HtmlHelp()
#include "resutil.h"
#include <shlobjp.h>
#include <shellapi.h>
#include <faxreg.h>
#include <faxres.h>

EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;
EXTERN_C BOOL WINAPI LinkWindow_UnregisterClass( HINSTANCE ) ;

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// Constructor
//
CppFaxServerReceipts::CppFaxServerReceipts(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerReceipts>(pNode,NULL)
			                	
{
    m_pParentNode        = static_cast <CFaxServerNode *> (pNode);
    m_pFaxReceiptsConfig = NULL;
    
    m_fAllReadyToApply   = FALSE;
    m_fIsDialogInitiated = FALSE;
    
    m_fIsDirty           = FALSE;

    m_enumSmtpAuthOption = FAX_SMTP_AUTH_ANONYMOUS;
    m_bstrUserName       = L"";

    m_fLastGoodIsSMTPRouteConfigured = FALSE;

}


//
// Destructor
//
CppFaxServerReceipts::~CppFaxServerReceipts()
{
    if (NULL != m_pFaxReceiptsConfig)
    {
        FaxFreeBuffer( m_pFaxReceiptsConfig );
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxServerReceipts message handlers

/*
 -  CppFaxServerReceipts::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerReceipts::InitRPC()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;

    //
    // get RPC Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Retrieve the fax SMTP configuration
    //
    if (!FaxGetReceiptsConfiguration(m_pFaxServer->GetFaxServerHandle(),
                                     &m_pFaxReceiptsConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get mail configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    //For max verification
    ATLASSERT(m_pFaxReceiptsConfig);

    
    //
    // Init members - for advance dialog or save operation
    //
    m_enumSmtpAuthOption = m_pFaxReceiptsConfig->SMTPAuthOption;
    
    m_bstrUserName       = m_pFaxReceiptsConfig->lptstrSMTPUserName;     
    if ( !m_bstrUserName) 
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        
        DebugPrintEx( DEBUG_ERR, 
            _T("Null bstr - out of memory."));
        
        goto Error;

    }
    // m_pszPassword is NULL from the constructor 
    // there is no need to read from the server.

    // init status for unselcting this feature 
    // with still assigned devices to this Microsoft SMTP method
    if ( m_pFaxReceiptsConfig->bIsToUseForMSRouteThroughEmailMethod )
    {
        m_fLastGoodIsSMTPRouteConfigured = TRUE;
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get mail configuration."));
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}

    
    
/*
 -  CppFaxServerReceipts::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxServerReceipts::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::OnInitDialog"));

	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );

    BOOL fIsUnderLocalUserAccount = FALSE;

    WCHAR   buff[100];
    int     count;

    //
    // Attach 
    //
    m_SmtpBox.Attach(GetDlgItem(IDC_SMTP_EDIT));
    m_PortBox.Attach(GetDlgItem(IDC_PORT_EDIT));
    m_AddressBox.Attach(GetDlgItem(IDC_ADDRESS_EDIT));
    
    //
    // Limit text length
    //
    m_PortBox.SetLimitText(FXS_MAX_PORT_NUM_LEN);
    m_SmtpBox.SetLimitText(DNS_MAX_NAME_BUFFER_LENGTH);
    m_AddressBox.SetLimitText(FXS_MAX_EMAIL_ADDRESS);

    //
    // init controls
    //
    ATLASSERT(NULL != m_pFaxReceiptsConfig);
    
    //
    // Port
    //
    count = swprintf(buff,
    L"%ld", m_pFaxReceiptsConfig->dwSMTPPort);
    
    ATLASSERT(count > 0);
    if( count > 0 )
    {
        m_PortBox.SetWindowText(buff);
    }
        
    //
    //
    //
    m_SmtpBox.SetWindowText   (m_pFaxReceiptsConfig->lptstrSMTPServer);
    m_AddressBox.SetWindowText(m_pFaxReceiptsConfig->lptstrSMTPFrom);

    if (m_fLastGoodIsSMTPRouteConfigured)
    {
        CheckDlgButton(IDC_SMTP_ROUTE_CHECK, BST_CHECKED);
    }

    DWORD dwReceiptsOptions = m_pFaxReceiptsConfig->dwAllowedReceipts; 
    if (DRT_NONE == dwReceiptsOptions && !m_fLastGoodIsSMTPRouteConfigured)
    {
        EnableSmtpFields(FALSE);
    }
    else
    {
        if( dwReceiptsOptions & DRT_EMAIL )
        {
            CheckDlgButton(IDC_RECEIPT_ENABLE_SMTP_CHECK, BST_CHECKED);
        }
        else
        {
            CheckDlgButton(IDC_RECEIPT_ENABLE_SMTP_CHECK, BST_UNCHECKED);
            if (!m_fLastGoodIsSMTPRouteConfigured)
            {
                EnableSmtpFields(FALSE); 
            }
            else
            {
                CheckDlgButton(IDC_SMTP_ROUTE_CHECK, BST_CHECKED);
            } 
        }

        if ( dwReceiptsOptions & DRT_MSGBOX ) 
        { 
            CheckDlgButton(IDC_RECEIPT_ENABLE_MSGBOX_CHECK, BST_CHECKED);
        }
        else
        {
            CheckDlgButton(IDC_RECEIPT_ENABLE_MSGBOX_CHECK, BST_UNCHECKED);
        }
    }

    m_fIsDialogInitiated = TRUE;

    return(1);
}

/*
 -  CppFaxServerReceipts::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      IN pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerReceipts::SetProps(int *pCtrlFocus, UINT * puIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::SetProps"));
    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;

    BOOL        fSkipMessage = FALSE;


    CComBSTR    bstrSmtpSever, 
                bstrPort,
                bstrSenderAddress;
    DWORD       dwPort;

    BOOL        fIsSMTPRouteConfigured = FALSE;
    BOOL        fIsSMTPReceiptsConfigured = FALSE;

    FAX_RECEIPTS_CONFIG   FaxReceiptsConfig;

    
    *pCtrlFocus = 0; //safty
    

    ATLASSERT(TRUE == m_fAllReadyToApply);
    m_fAllReadyToApply = FALSE;


    //
    // Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    
    //
    // This operation is very important for the case of unchecked email option
    // the service will neglect the SMTP fields.
    //
    ZeroMemory (&FaxReceiptsConfig, sizeof(FaxReceiptsConfig));

    FaxReceiptsConfig.dwSizeOfStruct = sizeof(FAX_RECEIPTS_CONFIG);

    FaxReceiptsConfig.dwAllowedReceipts = DRT_NONE; // 0x0000

    fIsSMTPRouteConfigured = (IsDlgButtonChecked(IDC_SMTP_ROUTE_CHECK) == BST_CHECKED);

    //
    // While tring to sumbmit unchecking of IDC_SMTP_ROUTE_CHECK
    // Special search for any left assigned devices' to Microsoft e-mail routing method
    //
    if ( !fIsSMTPRouteConfigured && m_fLastGoodIsSMTPRouteConfigured)
    {
        //Call function that will make loop on all FaxEnumPorts(/Ex) and FaxEnumRoutingMethods
        //and will pop-up ErrMsgBox in case in any Device The SMTP Microsoft Route 
        //Through e-mail method is still enabled while the user tries to unchecked. 
                    
        if (IsMsSMTPRoutingMethodStillAssigned())
        {
            PropSheet_SetCurSelByID( GetParent(), IDD);         
            ATLASSERT(::IsWindow(m_hWnd));
            PageError(IDS_MS_SMTPROUTINGMETHOD_ASSIGNED, m_hWnd);

            fSkipMessage = TRUE;

			goto Error;
        }
    }

    //
    // SMTP server details
    //
    if ( IsDlgButtonChecked(IDC_RECEIPT_ENABLE_SMTP_CHECK) == BST_CHECKED ) 
    {
        fIsSMTPReceiptsConfigured = TRUE;
        FaxReceiptsConfig.dwAllowedReceipts |= DRT_EMAIL;
    }
    
    if (
         fIsSMTPReceiptsConfigured
       ||
         fIsSMTPRouteConfigured 
       ) 
    {
        if ( !m_SmtpBox.GetWindowText(&bstrSmtpSever))
        {
            *pCtrlFocus = IDC_SMTP_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrSmtpSever)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
    
	    if ( !m_PortBox.GetWindowText(&bstrPort))
        {
            *pCtrlFocus = IDC_PORT_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrPort)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }

        if ( !m_AddressBox.GetWindowText(&bstrSenderAddress))
        {
            *pCtrlFocus = IDC_SMTP_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrSenderAddress)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
    
        //
        // Validation
        //
        if (!IsValidData(bstrSmtpSever, 
                         bstrPort,
                         &dwPort,
                         bstrSenderAddress, 
                         pCtrlFocus,
                         puIds)
           )
        {
            ATLASSERT(pCtrlFocus);
            ATLASSERT(puIds);
            ec = ERROR_INVALID_DATA;

            //in this case detailed message box was given by the called functions
            fSkipMessage = TRUE;
        
            goto Error;
        }
    
        //
        // subtitute all data
        //
        FaxReceiptsConfig.lptstrSMTPServer   = bstrSmtpSever;
    
        FaxReceiptsConfig.dwSMTPPort         = dwPort;

        FaxReceiptsConfig.lptstrSMTPFrom     = bstrSenderAddress;

        FaxReceiptsConfig.SMTPAuthOption     = m_enumSmtpAuthOption;

        FaxReceiptsConfig.lptstrSMTPUserName = m_bstrUserName;

        FaxReceiptsConfig.lptstrSMTPPassword = m_bstrPassword;

    }
    
    //
    // Set dwAllowedReceipts   
    //
    FaxReceiptsConfig.bIsToUseForMSRouteThroughEmailMethod = fIsSMTPRouteConfigured;

    
    //
    // Message box 
    //
    if (IsDlgButtonChecked(IDC_RECEIPT_ENABLE_MSGBOX_CHECK) == BST_CHECKED)
    {
        FaxReceiptsConfig.dwAllowedReceipts |= DRT_MSGBOX;
    }
    
    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        
        goto Error;
    }
    
    
    //
    // Set Config
    //
    if (!FaxSetReceiptsConfiguration(
                m_pFaxServer->GetFaxServerHandle(),
                &FaxReceiptsConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Set receipts configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Network Error was found. (ec: %ld)"), 
                ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }

    ATLASSERT(ERROR_SUCCESS == ec);

    m_fLastGoodIsSMTPRouteConfigured = fIsSMTPRouteConfigured;

    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set receipts configuration."));

    m_fIsDirty = FALSE;

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    if (!fSkipMessage)
    {
        PropSheet_SetCurSelByID( GetParent(), IDD);         
        ATLASSERT(::IsWindow(m_hWnd));
        PageError(GetFaxServerErrorMsg(ec), m_hWnd);
    }

Exit:    
    return hRc;
}


/*
 -  CppFaxServerReceipts::PreApply
 -
 *  Purpose:
 *      Checks data validity before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerReceipts::PreApply(int *pCtrlFocus, UINT * puIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::PreApply"));
    HRESULT hRc = S_OK;
    
    //
    // PreApply Checks
    //
    if (!AllReadyToApply(/*fSilent =*/ FALSE, pCtrlFocus , puIds))
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }

    return(hRc);
}


/*
 -  CppFaxServerReceipts::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerReceipts::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::OnApply"));
    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;
    UINT    uIds = 0;

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = PreApply(&CtrlFocus, &uIds);
    if (FAILED(hRc))
    {
        if (PropSheet_SetCurSelByID( GetParent(), IDD) )
        {
            PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus, &uIds);
        if (FAILED(hRc)) 
        {
            if (uIds)
            {
                if (PropSheet_SetCurSelByID( GetParent(), IDD) )
                {
                    PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
                    if (CtrlFocus)
                    {
                        GotoDlgCtrl(GetDlgItem(CtrlFocus));
                    }
                }
            }
            //else Error Msg by called func.
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }

}

/*
 -  CppFaxServerReceipts::SetApplyButton
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerReceipts::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetModified(TRUE);  
    bHandled = TRUE;
    return(1);
}

/*
 -  CppFaxServerReceipts::EnableSmtpFields
 -
 *  Purpose:
 *      Enable/dissable Authenticated Access dialog controls.
 *
 *  Arguments:
 *      [in] state - boolean value to enable TRUE or FALSE to disable
 *
 *  Return:
 *      void
 */
void CppFaxServerReceipts::EnableSmtpFields(BOOL state)
{

    ::EnableWindow(GetDlgItem(IDC_ADDRESS_STATIC), state);
    ::EnableWindow(GetDlgItem(IDC_ADDRESS_EDIT),   state);

    ::EnableWindow(GetDlgItem(IDC_SMTP_STATIC), state);
    ::EnableWindow(GetDlgItem(IDC_SMTP_EDIT),   state);
    
    ::EnableWindow(GetDlgItem(IDC_PORT_STATIC), state);
    ::EnableWindow(GetDlgItem(IDC_PORT_EDIT),   state);
    
    ::EnableWindow(GetDlgItem(IDC_AUTHENTICATION_BUTTON), state);

}

/*
 -  CppFaxServerReceipts::OnMsgBoxDeliveryOptionChecked
 -
 *  Purpose:
 *      Handles the checking/unchecking of the 'Msg box' receipt checkbox.
 *      Checks if the Messenger service is disabled.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerReceipts::OnMsgBoxDeliveryOptionChecked(
    WORD wNotifyCode, 
    WORD wID, 
    HWND hWndCtl, 
    BOOL& bHandled)
{
    if (!m_fIsDialogInitiated) 
    {
        //
        // Event receieved too early
        //
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    if (BST_CHECKED == IsDlgButtonChecked(IDC_RECEIPT_ENABLE_MSGBOX_CHECK))
    {
        //
        // The 'Allow message boxes receipt' check-box was just checked
        //
        DWORD dwMessengerStartupType;
        ATLASSERT(m_pParentNode);
        CComBSTR bstrServerName = m_pParentNode->GetServerName();
        if (ERROR_SUCCESS == GetServiceStartupType (bstrServerName, MESSENGER_SERVICE_NAME, &dwMessengerStartupType))
        {
            if (SERVICE_DISABLED == dwMessengerStartupType)
            {
                //
                // Ooops. The Messenger service is disabled. We can't send message boxes.
                // Ask the user if he want's us to enable the messenger service.
                //
                WCHAR wszTitle[MAX_PATH * 2];
                WCHAR wszQuestion[MAX_PATH * 2];
                
                if (LoadString( _Module.GetResourceInstance(), 
                                IDS_FAX_WRN_MESSENGER_TITLE, 
                                wszTitle, 
                                ARR_SIZE (wszTitle))            &&
                    LoadString( _Module.GetResourceInstance(), 
                                IDS_FAX_WRN_MESSENGER_DISABLED, 
                                wszQuestion, 
                                ARR_SIZE (wszQuestion)))
                                                              
                {
                    if (IDYES == AlignedMessageBox (m_hWnd, wszQuestion, wszTitle, MB_YESNO | MB_ICONWARNING))
                    {
                        //
                        // User chose to enble the Messenger service
                        //
                        HCURSOR hOldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
                        DWORD dwRes = SetServiceStartupType (bstrServerName, MESSENGER_SERVICE_NAME, SERVICE_AUTO_START);
                        if (ERROR_SUCCESS != dwRes)
                        {
                            PageError(GetErrorStringId(dwRes), m_hWnd, _Module.GetResourceInstance());                  
                        }
                        else
                        {
                            //
                            // Also start it
                            //
                            dwRes = StartServiceEx (bstrServerName, MESSENGER_SERVICE_NAME, 0, NULL, INFINITE);
                            if (ERROR_SUCCESS != dwRes)
                            {
                                PageError(GetErrorStringId(dwRes), m_hWnd, _Module.GetResourceInstance());                  
                            }
                        }
                        SetCursor (hOldCursor);
                    }
                }
            }                
        }
    }        
    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }
    else
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
    }

    return 1;
} // CppFaxServerReceipts::OnMsgBoxDeliveryOptionChecked



/*
 -  CppFaxServerReceipts::OnDeliveryOptionChecked
 -
 *  Purpose:
 *      Gray/Ungray controls
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerReceipts::OnDeliveryOptionChecked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL fState;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }


    fState = ( 
                IsDlgButtonChecked(IDC_RECEIPT_ENABLE_SMTP_CHECK) == BST_CHECKED
             ||
                IsDlgButtonChecked(IDC_SMTP_ROUTE_CHECK) == BST_CHECKED 
             );

    EnableSmtpFields(fState);

    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }
    else
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
    }

    return(1);
}

/*
 -  CppFaxServerReceipts::OnAuthenticationButtonClicked
 -
 *  Purpose:
 *      To allow opening of the advance SMTP configuration server.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerReceipts::OnAuthenticationButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::OnAuthenticationButtonClicked"));
    
    INT_PTR  rc    = IDCANCEL;
    HRESULT  hRc   = S_OK;
    DWORD    dwRet = ERROR_SUCCESS;
    
    if(m_pFaxServer->GetServerAPIVersion() == FAX_API_VERSION_0)
    {
        //
        // The remote fax server is SBS/BOS 2000
        // it uses different authentication mechanism
        //
        OpenBosAuthenticationDlg();
        return 1;
    }

    CDlgSMTPConfig    DlgSMTPConfig;


    //
    // Dialog to configure SMTP authentication mode
    //
    hRc = DlgSMTPConfig.InitSmtpDlg( 
                            m_enumSmtpAuthOption, 
                            m_bstrUserName);
    if (FAILED(hRc))
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
        goto Cleanup;
    }

    rc = DlgSMTPConfig.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }

    //else
    m_enumSmtpAuthOption = DlgSMTPConfig.GetAuthenticationOption();

    if ( 
         FAX_SMTP_AUTH_BASIC == m_enumSmtpAuthOption 
       || 
         FAX_SMTP_AUTH_NTLM == m_enumSmtpAuthOption
       )  
    {

        m_bstrUserName = DlgSMTPConfig.GetUserName();
        if (!m_bstrUserName)        
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrUserName."));
        
            m_pParentNode->NodeMsgBox(IDS_MEMORY);

            goto Cleanup;
        }
    
        if ( DlgSMTPConfig.IsPasswordModified() )
        {
            m_bstrPassword  = DlgSMTPConfig.GetPassword();
            if (!m_bstrPassword)
            {
                DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory while setting m_bstrPassword"));
                m_pParentNode->NodeMsgBox(IDS_MEMORY);

                goto Cleanup;
            }
        }
        else
        {
            m_bstrPassword.Empty();
        }
    }

    
    m_fIsDirty     = TRUE;
    

    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }

Cleanup:
    return 1;
}
  
/*
 -  CppFaxServerReceipts::OpenBosAuthenticationDlg
 -
 *  Purpose:
 *      Open the old (BOS/SBS 2000) version of Authentication dialog.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerReceipts::OpenBosAuthenticationDlg()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::OnAuthenticationButtonClicked"));
    
    INT_PTR  rc    = IDOK;
    HRESULT  hRc   = S_OK;
    DWORD    dwRet = ERROR_SUCCESS;
    
    CBosSmtpConfigDlg  DlgSMTPConfig;

    //
    // IsUnderLocalUserAccount.
    //
    BOOL fIsUnderLocalUserAccount = FALSE;

    hRc = IsUnderLocalUserAccount(&fIsUnderLocalUserAccount);
    if ( S_OK != hRc )
    {
        DebugPrintEx(DEBUG_ERR, 
           _T("IsUnderLocalUserAccount failed. (hRc: %08X)"), 
		   hRc);
        goto Cleanup;
    }



    //
    // Dialog to configure SMTP authentication mode
    //
    hRc = DlgSMTPConfig.InitSmtpDlg( 
                            m_enumSmtpAuthOption, 
                            m_bstrUserName, 
                            fIsUnderLocalUserAccount);
    if (FAILED(hRc))
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
        goto Cleanup;
    }

    rc = DlgSMTPConfig.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }

    //else

    m_bstrUserName = DlgSMTPConfig.GetUserName();
    if (!m_bstrUserName)        
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory while setting m_bstrUserName"));
        
        m_pParentNode->NodeMsgBox(IDS_MEMORY);

        goto Cleanup;
    }
    
    if (DlgSMTPConfig.IsPasswordModified())
    {
        m_bstrPassword  = DlgSMTPConfig.GetPassword();
        if (!m_bstrPassword)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Out of memory while setting m_bstrPassword"));
            m_pParentNode->NodeMsgBox(IDS_MEMORY);

            goto Cleanup;
        }
    }
    else
    {
        m_bstrPassword.Empty();
    }

    m_enumSmtpAuthOption = DlgSMTPConfig.GetAuthenticationOption();
    
    m_fIsDirty     = TRUE;
    

    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }


Cleanup:
    return 1;
}


/*
 -  CppFaxServerReceipts::IsUnderLocalUserAccount
 -
 *  Purpose:
 *      Check if fax service Is running Under LocalUser Account.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code.
 */
HRESULT CppFaxServerReceipts::IsUnderLocalUserAccount(OUT BOOL * pfIsUnderLocalUserAccount)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::IsUnderLocalUserAccount"));

    HRESULT hRc = S_OK;
    DWORD dwRet = ERROR_SUCCESS;
    
    ATLASSERT(m_pParentNode);
    CComBSTR bstrServerName = m_pParentNode->GetServerName();
    if (!bstrServerName)
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory. Failed to load server name string."));
        
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
        
        hRc = E_OUTOFMEMORY;
        
        goto Cleanup;
    }
    
    if (0 == bstrServerName.Length())
    {
        dwRet= IsFaxServiceRunningUnderLocalSystemAccount(NULL, pfIsUnderLocalUserAccount);
    }
    else
    {
        dwRet= IsFaxServiceRunningUnderLocalSystemAccount(bstrServerName.m_str, pfIsUnderLocalUserAccount);
    }
    if(ERROR_SUCCESS != dwRet)
    {
        DebugPrintEx(DEBUG_ERR, 
                     _T("IsFaxServiceRunningUnderLocalSystemAccount failed: %d\n"), 
					 dwRet);

        hRc = HRESULT_FROM_WIN32(dwRet);

        goto Cleanup;
    }
    ATLASSERT( S_OK == hRc);

Cleanup:

    return hRc;
}


/*
 -  CppFaxServerReceipts::IsValidData
 -
 *  Purpose:
 *      To validate all data types before save data.
 *      This level should be responsible that detailed 
 *      error description will be shown to user.
 *
 *  Arguments:
 *      [in]   BSTRs and DWORDs
 *      [out]  dwPort pointer to DWORD that 
 *             was derived from the port bstr if validation success.
 *      [out]  iFocus
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerReceipts::IsValidData(BSTR bstrSmtpSever, 
                                    BSTR bstrPort,
                                    DWORD *pdwPort,
                                    BSTR bstrSenderAddress, 
                                    int *pCtrlFocus,
                                    UINT *pIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::IsValidData"));

    UINT           uRetIDS   = 0;

    ATLASSERT(pdwPort);
    
    if (!IsValidPortNumber(bstrPort, pdwPort, &uRetIDS))
    {
        ATLASSERT(0 != uRetIDS);
        DebugPrintEx( DEBUG_ERR,
			_T("Invalid port number."));
        *pCtrlFocus = IDC_PORT_EDIT;
        
        goto Error;
    }
    
    if (!IsValidServerNameString(bstrSmtpSever, &uRetIDS, TRUE /*DNS NAME LENGTH*/))
    {
        ATLASSERT(0 != uRetIDS);
        DebugPrintEx( DEBUG_ERR,
			_T("Invalid SMTP server name."));
        *pCtrlFocus = IDC_SMTP_USERNAME_EDIT;
        
        goto Error;
    }
    
    if (!IsNotEmptyString(bstrSenderAddress))
    {
        DebugPrintEx( DEBUG_ERR,
			_T("Sender address string empty or spaces only."));
        uRetIDS = IDS_SENDER_ADDRESS_EMPTY;

        *pCtrlFocus = IDC_SMTP_PASSWORD_EDIT;
        
        goto Error;
    }


    ATLASSERT(0 == uRetIDS);
    goto Exit;
    
Error:    
    ATLASSERT(0 != uRetIDS);

    *pIds = uRetIDS;

    return FALSE;

Exit:
    return TRUE;
}



/*
 -  CppFaxServerReceipts::AllReadyToApply
 -
 *  Purpose:
 *      This function validate that no zero length strings 
 *      are found data areas that should be saved.
 *
 *  Arguments:
 *      [in] fSilent - boolean who defines if to pop up messages (FALSE)
 *           or not.(TRUE)
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerReceipts::AllReadyToApply(BOOL fSilent, int *pCtrlFocus, UINT *pIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::AllReadyToApply"));
	
    DWORD   ec  = ERROR_SUCCESS;
     
    if (
         IsDlgButtonChecked(IDC_RECEIPT_ENABLE_SMTP_CHECK) == BST_CHECKED
       ||
         IsDlgButtonChecked(IDC_SMTP_ROUTE_CHECK) == BST_CHECKED 
       ) 
    {
        if ( !m_SmtpBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
		        DEBUG_ERR,
		        _T("Zero text length - m_SmtpBox. (ec: %ld)"), 
		        ec);
    
            if (!fSilent)
            {
                *pIds = IDS_SERVERNAME_EMPTY_STRING;
                *pCtrlFocus = IDC_SMTP_EDIT;
            }
            return FALSE;    
        }

        if ( !m_PortBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
		        DEBUG_ERR,
		        _T("Zero text length - m_PortBox. (ec: %ld)"), 
		        ec);
    
            if (!fSilent)
            {
                *pIds = IDS_PORT_EMPTY_STRING;
                *pCtrlFocus = IDC_PORT_EDIT;
            }
            return FALSE;    
        }

        if ( !m_AddressBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
		        DEBUG_ERR,
		        _T("Zero text length - m_AddressBox. (ec: %ld)"), 
		        ec);
    
            if (!fSilent)
            {
                *pIds = IDS_SENDER_ADDRESS_EMPTY;
                *pCtrlFocus = IDC_ADDRESS_EDIT;
            }
            return FALSE;    
        }

    }
    ATLASSERT(ERROR_SUCCESS == ec);
    
    //
	// Cheers! 
	//		...every thing ready to apply now.
	//
	return TRUE;           
}


/*
 -  CppFaxServerReceipts::OnTextChanged
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerReceipts::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::OnTextChanged"));
                   
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }
    else
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
    }

    return 1;
}

/*
 -  CppFaxServerReceipts::IsMsSMTPRoutingMethodStillAssigned
 -
 *  Purpose:
 *      This function makes loop on all FaxEnumPortsEx and FaxEnumRoutingMethods
 *      and should pop-up ErrMsgBox in case in any Device The SMTP Microsoft Route 
 *      Through e-mail method is still enabled while the user tries to unchecked. 
 *
 *  Arguments:
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerReceipts::IsMsSMTPRoutingMethodStillAssigned()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::IsMsSMTPRoutingMethodStillAssigned"));
	     
    DWORD                   ec     = ERROR_SUCCESS;

    PFAX_PORT_INFO_EX       pFaxDevicesConfig;
    DWORD                   dwNumOfDevices;

    PFAX_ROUTING_METHOD     pFaxInboundMethodsConfig;
    DWORD                   dwNumOfInboundMethods;

    DWORD                   dwIndex = 0;

    //
    // get Fax Handle
    //   
    ATLASSERT(m_pFaxServer);

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Retrieve the fax devices configuration
    //
    if (!FaxEnumPortsEx(m_pFaxServer->GetFaxServerHandle(), 
                        &pFaxDevicesConfig,
                        &dwNumOfDevices)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get devices configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(pFaxDevicesConfig);

    for (dwIndex = 0; dwIndex < dwNumOfDevices; dwIndex++)
    {
        HANDLE		 hFaxPortHandle = NULL;
        
        //
        // only a PORT_OPEN_QUERY is needed to show the methods
        // the handle with PORT_OPEN_MODIFY priviledge will be 
        // given for limited short period for opertion required it.
        //

        if (!FaxOpenPort( m_pFaxServer->GetFaxServerHandle(), 
                            pFaxDevicesConfig[dwIndex].dwDeviceID, 
                            PORT_OPEN_QUERY, 
                            &hFaxPortHandle )) 
        {
		    ec = GetLastError();

            if (ERROR_INVALID_HANDLE ==  ec)
            {
                //Special case of ERROR_INVALID_HANDLE
		        DebugPrintEx(DEBUG_ERR,
			        _T("FaxOpenPort() failed with ERROR_INVALID_HANDLE. (ec:%ld)"),
			        ec);
            
                PropSheet_SetCurSelByID( GetParent(), IDD);         
                ATLASSERT(::IsWindow(m_hWnd));
                PageError(IDS_OPENPORT_INVALID_HANDLE, m_hWnd);
            
                goto Exit;
            }

		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("FaxOpenPort() failed. (ec:%ld)"),
			    ec);
            
            goto Error;
        } 
        ATLASSERT(NULL != hFaxPortHandle);

        //
        // Retrieve the fax Inbound Methods configuration
        //
        if (!FaxEnumRoutingMethods(hFaxPortHandle, 
                            &pFaxInboundMethodsConfig,
                            &dwNumOfInboundMethods)) 
	    {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Fail to get Inbound Methods configuration. (ec: %ld)"), 
			    ec);
            
            if (NULL != hFaxPortHandle)
            {
                if (!FaxClose( hFaxPortHandle ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("FaxClose() on port handle failed (ec: %ld)"),
                        GetLastError());
                }
            }


            if (IsNetworkError(ec))
            {
                DebugPrintEx(
			        DEBUG_ERR,
			        _T("Network Error was found. (ec: %ld)"), 
			        ec);
            
                m_pFaxServer->Disconnect();       
            }

            goto Error; 
        }
        //For max verification
        ATLASSERT(pFaxInboundMethodsConfig);

        //
        // Close Fax Port handle
        // 
        if (NULL != hFaxPortHandle)
        {
            if (!FaxClose( hFaxPortHandle ))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxClose() on port handle failed (ec: %ld)"),
                    GetLastError());
            }
        }

        //
        // Main loop search for MS email routing method's GUID
        //
        for ( DWORD dwMethodsIndex = 0; dwMethodsIndex < dwNumOfInboundMethods; dwMethodsIndex++ )
        {
            pFaxInboundMethodsConfig[dwMethodsIndex];
            if (CSTR_EQUAL == CompareString(LOCALE_INVARIANT,
                                            NORM_IGNORECASE, 
                                            pFaxInboundMethodsConfig[dwMethodsIndex].Guid,
                                            -1,
                                            REGVAL_RM_EMAIL_GUID,
                                            -1))
            {
                if (pFaxInboundMethodsConfig[dwMethodsIndex].Enabled)
                {
                    return TRUE;
                }
            }
        }
    }


    ATLASSERT(ERROR_SUCCESS == ec);

    goto Exit;

Error:


    PropSheet_SetCurSelByID( GetParent(), IDD);         
    ATLASSERT(::IsWindow(m_hWnd));
    PageError(GetFaxServerErrorMsg(ec), m_hWnd);

Exit:

    return FALSE;

}

/*
 -  CppFaxServerReceipts::OnHelpLinkClicked
 -
 *  Purpose:
 *      On HTML like link was clicked open chm help window.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
#define FAX_USER_ACCOUNT_HELP  FAX_ADMIN_HELP_FILE TEXT("::/FaxS_H_UserAcct.htm")
LRESULT CppFaxServerReceipts::OnHelpLinkClicked(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    
    ATLASSERT( IDC_RECEIPTS_HELP_LINK == idCtrl);

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }

    HtmlHelp(m_hWnd, FAX_USER_ACCOUNT_HELP, HH_DISPLAY_TOC, NULL);

    return 1;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerReceipts::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerReceipts::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerReceipts::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\proppageinfocookie.h ===
#ifndef _PROPPAGEINFOCOOKIE_
#define _PROPPAGEINFOCOOKIE_

typedef struct {
    long ItemId;
    long IconId;
} PropPageCookie;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\provider.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Provider.h                                             //
//                                                                         //
//  DESCRIPTION   : Header file for the Fax Provider snapin node class.    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg  Create                                          //
//      Jan 31 2000 yossg  add the functionality                           //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXPROVIDER_H
#define H_FAXPROVIDER_H

#include "snapin.h"
#include "snpnode.h"

#include "DevicesAndProviders.h"
#include "Providers.h"


class CFaxProvidersNode;
class CppFaxProvider;

class CFaxProviderNode : public CSnapinNode <CFaxProviderNode, FALSE>
{

public:


    BEGIN_SNAPINCOMMAND_MAP(CFaxProviderNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxProviderNode)
    END_SNAPINTOOLBARID_MAP()

    CFaxProviderNode (CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CSnapinNode<CFaxProviderNode, FALSE>(pParentNode, pComponentData )
    {
    }

    ~CFaxProviderNode()
    {
    }

    LPOLESTR GetResultPaneColInfo(int nCol);

    void InitParentNode(CFaxProvidersNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT  Init(PFAX_DEVICE_PROVIDER_INFO pProviderConfig);

    STDMETHOD(CreatePropertyPages)
        (LPPROPERTYSHEETCALLBACK    lpProvider,
         long                       handle,
         IUnknown*                  pUnk,
         DATA_OBJECT_TYPES          type);
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

    //
    // FillData
    //
    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);

    //
    // Clipboard Formats
    //
    static CLIPFORMAT m_CFFspGuid;
    static CLIPFORMAT m_CFServerName;


private:

    //
    // members
    //
    CComBSTR                          m_bstrProviderName;
    CComBSTR                          m_bstrImageName;
    CComBSTR                          m_bstrProviderGUID;

    FAX_ENUM_PROVIDER_STATUS          m_enumStatus;
    CComBSTR                          m_bstrStatus;

    FAX_VERSION                       m_verProviderVersion;
    CComBSTR                          m_bstrVersion;
    
    CComBSTR                          m_buf; 

    //
    // Parent node
    //
    CFaxProvidersNode *               m_pParentNode;

    //
    // Methods
    //
    HRESULT  InitMembers (PFAX_DEVICE_PROVIDER_INFO pProviderConfig);

    void InitIcons ();

    UINT GetStatusIDS(FAX_ENUM_PROVIDER_STATUS enumStatus);

};

//typedef CSnapinNode<CFaxProviderNode, FALSE> CBaseFaxProviderNode;

#endif  //H_OUTROUTINGRULE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\provider.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Provider.cpp                                           //
//                                                                         //
//  DESCRIPTION   : Header file for the Provider snapin node class.        //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg  Create                                          //
//      Jan 31 2000 yossg  add the functionality                           //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "snapin.h"

#include "Provider.h"
#include "Providers.h"

#include "ppFaxProviderGeneral.h"

#include "oaidl.h"
#include "Icons.h"
#include "faxmmc.h"

/////////////////////////////////////////////////////////////////////////////
static const GUID CFaxProviderNodeGUID_NODETYPE = FAXSRV_DEVICE_PROVIDER_NODETYPE_GUID;

const GUID*     CFaxProviderNode::m_NODETYPE        = &CFaxProviderNodeGUID_NODETYPE;
const OLECHAR*  CFaxProviderNode::m_SZNODETYPE      = FAXSRV_DEVICE_PROVIDER_NODETYPE_GUID_STR;
const CLSID*    CFaxProviderNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;

CLIPFORMAT CFaxProviderNode::m_CFFspGuid = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_FSP_GUID);
CLIPFORMAT CFaxProviderNode::m_CFServerName = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_SERVER_NAME);


/*
 -  CFaxProviderNode::Init
 -
 *  Purpose:
 *      Init all members icon etc.
 *
 *  Arguments:
 *      [in]    pProviderConfig - PFAX_DEVICE_PROVIDER_INFO
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxProviderNode::Init(PFAX_DEVICE_PROVIDER_INFO pProviderConfig)
{

    DEBUG_FUNCTION_NAME( _T("CFaxProviderNode::Init"));
    HRESULT hRc = S_OK;

    ATLASSERT(pProviderConfig);

    hRc = InitMembers( pProviderConfig );
    if (FAILED(hRc))
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to InitMembers"));
        
        //NodeMsgBox done by called func.
        
        goto Exit;
    }
    ATLASSERT(SUCCEEDED(hRc));

    //
    // Icon
    //
    InitIcons();

Exit:
    return hRc;
}

/*
 -  CFaxProviderNode::InitIcons
 -
 *  Purpose:
 *      Private method that initiate icons
 *      due to the status member state.
 *
 *  Arguments:
 *      No.
 *
 *  Return:
 *      No.
 */
void CFaxProviderNode::InitIcons ()
{
    DEBUG_FUNCTION_NAME( _T("CFaxProviderNode::InitIcons"));
    switch (m_enumStatus)
    {
        case FAX_PROVIDER_STATUS_SUCCESS:
            m_resultDataItem.nImage = IMAGE_FSP;
            break;

        case FAX_PROVIDER_STATUS_SERVER_ERROR:
        case FAX_PROVIDER_STATUS_BAD_GUID:
        case FAX_PROVIDER_STATUS_BAD_VERSION:
        case FAX_PROVIDER_STATUS_CANT_LOAD:
        case FAX_PROVIDER_STATUS_CANT_LINK:
        case FAX_PROVIDER_STATUS_CANT_INIT:
            m_resultDataItem.nImage = IMAGE_FSP_ERROR;
            break;

        default:
            ATLASSERT(0); // "this enumStatus is not supported "
            break; //currently 999

    } // endswitch (enumStatus)

    return;
}


/*
 -  CFaxProviderNode::InitMembers
 -
 *  Purpose:
 *      Private method to initiate members
 *      Must be called after init of m_pParentNode
 *
 *  Arguments:
 *      [in]    pProviderConfig - PFAX_DEVICE_PROVIDER_INFO structure
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxProviderNode::InitMembers(PFAX_DEVICE_PROVIDER_INFO pProviderConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxProviderNode::InitMembers"));
    HRESULT hRc = S_OK;

    int   iCount;

    UINT  idsStatus;

    CComBSTR bstrChk;

    WCHAR lpwszBuff [4*FXS_DWORD_LEN+3/*points*/+1/*NULL*/];
    
    ATLASSERT(pProviderConfig);
    
    //    
    // status    
    //    
    m_enumStatus          = pProviderConfig->Status;

    //    
    // status string   
    //    
    idsStatus = GetStatusIDS(m_enumStatus);
    if ( FXS_IDS_STATUS_ERROR == idsStatus)
    {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Invalid Status value."));
            goto Error;
    }
    else
    {
        if (!m_bstrStatus.LoadString(idsStatus))
        {
            hRc = E_OUTOFMEMORY;
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Out of memory. Failed to load status string."));
            goto Error;
        }
    }

    //
    // Provider name
    //
    m_bstrProviderName = pProviderConfig->lpctstrFriendlyName;
    if ( !m_bstrProviderName )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    //
    // Provider GUID
    //
    m_bstrProviderGUID = pProviderConfig->lpctstrGUID;
    if (!m_bstrProviderGUID)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }


    //
    // Version
    //
    m_verProviderVersion = pProviderConfig->Version;  
    
    //
    // Version string
    //
    
    //m_bstrVersion = L"5.0.813.0 (Chk)" or L"5.0.813.0"
    iCount = swprintf(
                  lpwszBuff,
                  L"%ld.%ld.%ld.%ld",
                  m_verProviderVersion.wMajorVersion,
                  m_verProviderVersion.wMinorVersion,
                  m_verProviderVersion.wMajorBuildNumber,
                  m_verProviderVersion.wMinorBuildNumber
                  );
    if( iCount <= 0 )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to read m_verProviderVersion."));
        goto Error;
    }

    m_bstrVersion = lpwszBuff;
    if (!m_bstrVersion)
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Null memeber BSTR - m_bstrVersion."));
        goto Error;
    }

    
    if (m_verProviderVersion.dwFlags & FAX_VER_FLAG_CHECKED)
    {
        if (!bstrChk.LoadString(IDS_CHK))
        {
            hRc = E_OUTOFMEMORY;
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Out of memory. Failed to load string."));
            goto Error;
        }
        
        m_bstrVersion += bstrChk; //L" (Chk)";

    }

    //
    // Path
    //
    m_bstrImageName = pProviderConfig->lpctstrImageName;
    if ( !m_bstrImageName )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
    }
    
Exit:
   return (hRc);
}

/*
 -  CFaxProviderNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxProviderNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxProviderNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    switch (nCol)
    {
    case 0:
        //
        // Provider Name
        //
        if (!m_bstrProviderName)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrProviderName."));
            goto Error;
        }
        else
        {
           return (m_bstrProviderName);
        }

        
    case 1:
        //
        // Status
        //
        if (!m_bstrStatus)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrStatus."));
            goto Error;
        }
        else
        {
            return (m_bstrStatus);
        }

    case 2:  
        //
        // Version
        //
        if (!m_bstrVersion)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrVersion."));
            goto Error;
        }
        else
        {
            return (m_bstrVersion);
        }
 
    case 3:
        //
        // Path
        //
        if (!m_bstrImageName)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrImageName."));
            goto Error;
        }
        else
        {
           return (m_bstrImageName);
        }

    default:
        ATLASSERT(0); // "this number of column is not supported "
        return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}


/*
 -  CFaxProviderNode::CreatePropertyPages
 -
 *  Purpose:
 *      Called when creating a property page of the object
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for routing notification
 *      [in]    pUnk       - Pointer to the data object
 *      [in]    type       - CCT_* (SCOPE, RESULT, ...)
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxProviderNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                    long                    handle,
                                    IUnknown                *pUnk,
                                    DATA_OBJECT_TYPES       type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxProviderNode::CreatePropertyPages"));
    HRESULT hRc = S_OK;

    HPROPSHEETPAGE hPage;
    CppFaxProvider * pPropPageProviderGeneral = NULL;
    
    ATLASSERT(lpProvider);
    ATLASSERT(type == CCT_RESULT || type == CCT_SCOPE);


    //
    // General tab
    //
    pPropPageProviderGeneral = new CppFaxProvider(
											 handle,
                                             this,
                                             TRUE,
                                             _Module.GetResourceInstance());

	if (!pPropPageProviderGeneral)
	{
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
	}
    
    
    hRc = pPropPageProviderGeneral->Init(   m_bstrProviderName, 
                                            m_bstrStatus, 
                                            m_bstrVersion, 
                                            m_bstrImageName);
    if (FAILED(hRc))
    {
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
    }
    
    hPage = pPropPageProviderGeneral->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for General tab. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pPropPageProviderGeneral ) 
    {
        delete  pPropPageProviderGeneral;    
        pPropPageProviderGeneral = NULL;    
    }

Exit:
    return hRc;
}


/*
 -  CFaxProviderNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxProviderNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Properties
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    //
    // We want the default verb to be Properties
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return hRc;
}



/*
 -  CFaxProviderNode::GetStatusIDS
 -
 *  Purpose:
 *      Transslate Status to IDS.
 *
 *  Arguments:
 *
 *            [in]  enumStatus    - unsigned int with the menu IDM value
 *
 *  Return:
 *            IDS of related status message 
 */
UINT CFaxProviderNode::GetStatusIDS(FAX_ENUM_PROVIDER_STATUS enumStatus)
{
    DEBUG_FUNCTION_NAME( _T("CFaxProviderNode::GetStatusIDS"));
    
    UINT uiIds;

    switch (enumStatus)
    {
       case FAX_PROVIDER_STATUS_SUCCESS:
            // Provider was successfully loaded
            uiIds = IDS_STATUS_PROVIDER_SUCCESS;
            break;

        case FAX_PROVIDER_STATUS_SERVER_ERROR:
            // An error occured on the server while loading FSP.
            uiIds = IDS_STATUS_PROVIDER_SERVER_ERROR;
            break;

        case FAX_PROVIDER_STATUS_BAD_GUID:
            // Provider's GUID is invalid
            uiIds = IDS_STATUS_PROVIDER_BAD_GUID;
            break;

        case FAX_PROVIDER_STATUS_BAD_VERSION:
            // Provider's API version is invalid
            uiIds = IDS_STATUS_PROVIDER_BAD_VERSION;
            break;

        case FAX_PROVIDER_STATUS_CANT_LOAD:
            // Can't load provider's DLL
            uiIds = IDS_STATUS_PROVIDER_CANT_LOAD;
            break;

        case FAX_PROVIDER_STATUS_CANT_LINK:
            // Can't find required exported function(s) in provider's DLL
            uiIds = IDS_STATUS_PROVIDER_CANT_LINK;
            break;

        case FAX_PROVIDER_STATUS_CANT_INIT:
            // Failed while initializing provider
            uiIds = IDS_STATUS_PROVIDER_CANT_INIT;
            break;

        default:
            ATLASSERT(0); // "this enumStatus is not supported "
            uiIds = FXS_IDS_STATUS_ERROR; //currently 999
            break;

    } // endswitch (enumStatus)
    
    return uiIds; 
}

/*
 +
 +  CFaxProviderNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxProviderNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{ 
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_DEVICES);
}

/*
 +
 +
 *
 *  CFaxDeviceNode::FillData
 *
 *
 *   Override CSnapInItem::FillData for private cliboard formats
 *
 *
 *   Parameters
 *
 *   Return Values
 *
 -
 -
 */

HRESULT  CFaxProviderNode::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
    DEBUG_FUNCTION_NAME( _T("CFaxProviderNode::FillData"));
	
    HRESULT hr = DV_E_CLIPFORMAT;
	ULONG   uWritten;

	if (cf == m_CFFspGuid)
	{
		hr = pStream->Write((VOID *)(LPWSTR)m_bstrProviderGUID, 
                            sizeof(WCHAR)*(m_bstrProviderGUID.Length()+1), 
                            &uWritten);
		return hr;
	}

	if (cf == m_CFServerName)
	{
        ATLASSERT(GetRootNode());
		CComBSTR bstrServerName = ((CFaxServerNode *)GetRootNode())->GetServerName();
        if (!bstrServerName)
        {
		    DebugPrintEx(DEBUG_ERR, TEXT("Out of memory. Failed to load string."));        
            return E_OUTOFMEMORY;
        }
		hr = pStream->Write((VOID *)(LPWSTR)bstrServerName, sizeof(WCHAR)*(bstrServerName.Length()+1), &uWritten);
		return hr;
	}

    return CSnapInItemImpl<CFaxProviderNode>::FillData(cf, pStream);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\resutil.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : resutil.h                                              //
//                                                                         //
//  DESCRIPTION   : resource utility functions for MMC use.                //
//                                                                         //
//  AUTHOR        : zvib                                                   //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun 30 1998 zvib    Init.                                          //
//      Jul 12 1998 adik    Add NEMMCUTIL_EXPORTED                         //
//      Jul 23 1998 adik    Include DefineExported.h                       //
//      Aug 24 1998 adik    Add methods to save and load.                  //
//      Aug 31 1998 adik    Add OnSnapinHelp.                              //
//      Mar 28 1999 adik    Redefine CColumnsInfo.                         //
//      Apr 27 1999 adik    Help support.                                  //
//                                                                         //
//      Oct 14 1999 yossg   Welcome to Fax								   //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESUTIL_H_
#define __RESUTIL_H_

#include <mmc.h>

#define LAST_IDS    0
struct ColumnsInfoInitData
{
    //
    // String id in the resource, or LAST_IDS.
    //
    int ids;

    //
    // Column width, can be HIDE_COLUMN, AUTO_WIDTH or 
    // specifies the width of the column in pixels.
    //
    int Width;
};

class  CColumnsInfo
{
public:
    CColumnsInfo();
    ~CColumnsInfo();

    //
    // Set the columns in the result pane
    //
    HRESULT InsertColumnsIntoMMC(IHeaderCtrl *pHeaderCtrl,
                                                    HINSTANCE hInst,
                                                    ColumnsInfoInitData aInitData[]);

private:
    //
    // Init the class with specific columns data
    //
    HRESULT Init(HINSTANCE hInst, ColumnsInfoInitData aInitData[]);

    //
    // Keep columns info
    //
    struct ColumnData { int Width; BSTR Header; };
    CSimpleArray<ColumnData> m_Data;

    //
    // One time initialization flag
    //
    BOOL m_IsInitialized;
};


WCHAR * __cdecl GetHelpFile();
HRESULT __cdecl OnSnapinHelp(IConsole *pConsole);

#endif //  __RESUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\providers.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Providers.h                                            //
//                                                                         //
//  DESCRIPTION   : Header file for the Fax Providers node                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   Create                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXPROVIDERS_H
#define H_FAXPROVIDERS_H

#include "snapin.h"
#include "snpnres.h"

#include "DevicesAndProviders.h"
#include "Provider.h"

class CFaxDevicesAndProvidersNode;
class CFaxProviderNode;

class CFaxProvidersNode : public CNodeWithResultChildrenList<
                                        CFaxProvidersNode,    
                                        CFaxProviderNode, 
                                        CSimpleArray<CFaxProviderNode*>, 
                                        FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxProvidersNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxProvidersNode)
    END_SNAPINTOOLBARID_MAP()

    CFaxProvidersNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithResultChildrenList<CFaxProvidersNode, CFaxProviderNode, CSimpleArray<CFaxProviderNode*>, FALSE>(pParentNode, pComponentData )
    {
    }

    ~CFaxProvidersNode()
    {
    }

    virtual HRESULT PopulateResultChildrenList();
    virtual HRESULT InsertColumns(IHeaderCtrl *pHeaderCtrl);
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    HRESULT InitRPC(PFAX_DEVICE_PROVIDER_INFO  *pFaxProvidersConfig);

    void InitParentNode(CFaxDevicesAndProvidersNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData *pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

    HRESULT InitDisplayName();

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:

    static CColumnsInfo             m_ColsInfo;
    
    DWORD                           m_dwNumOfProviders;

    //pointer to mmc parent node - Devices and Providers
    CFaxDevicesAndProvidersNode   * m_pParentNode;
};

typedef CNodeWithResultChildrenList<CFaxProvidersNode, CFaxProviderNode, CSimpleArray<CFaxProviderNode*>, FALSE>
        CBaseFaxProvidersNode;

#endif  //H_FAXPROVIDERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// Fax Admin Console resource ID file               //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [3000 - 4999]                                    //
//                                                  //
//////////////////////////////////////////////////////

#include "..\faxres\resource.h"

#define IDR_SNAPIN_MENU                 3000 
#define IDD_SNAPIN                      3001 
#define IDS_SNAPIN_DESC                 3002 
#define IDS_SNAPIN_PROVIDER             3003 
#define IDD_FAXOUTRULE_GENERAL          3004 
#define IDS_SNAPIN_VERSION              3005 
#define IDR_SNAPIN                      3006 
#define IDS_FAX_COL_HEAD                3007 
#define IDS_OUTRRULES_COL1              3008 
#define IDS_OUTRRULES_COL2              3009 
#define IDS_OUTRRULES_COL3              3010 
#define IDS_OUTRRULES_COL4              3011 
#define IDS_OUTRRULES_COL5              3012 
#define IDS_OUTRRULES_COL6              3013 
#define IDS_TASKPAD_TITLE               3014 
#define IDS_MPOUTOFMEMORY               3015 
#define IDS_FAXOUTOFMEMORY              3016 
#define IDS_CREATE_PROPPAGE             3017 
#define IDS_GENERAL                     3018 
#define IDS_PERMISSION                  3019 
#define IDS_MPFAILTOLOADVERBS           3020 
#define IDS_CONFIRM                     3021 
#define IDS_REFRESH_VIEW                3022 
#define IDS_ADD_DESCRIPTION             3023 
#define IDS_PROVIDER                    3025 
#define IDS_OTHER                       3026 
#define IDS_INTERNATIONAL               3027 
#define IDS_DOMESTIC                    3028 
#define IDS_LOCAL                       3029 
#define IDS_RETRIES_EXCEEDS_LIMIT       3030 
#define IDS_ALL                         3031 
#define IDS_EMPTY_OUTRULENAME           3032 
#define IDS_FAIL_ADD_OUTRULE            3033 
#define IDS_FAIL_ADD_RULE               3034 
#define IDS_DEL_OUTRULE                 3035 
#define IDS_FAIL_TO_REMOVE_RULE         3036 
#define IDS_OUTRULE_EXISTS              3037 
#define IDS_FAILTOSAVECHANGES_OUTRULE   3038 
#define IDS_INVALID_AREACODE            3039 
#define IDS_DEVICES_COL1                3040 
#define IDS_DEVICES_COL2                3041 
#define IDS_DEVICES_COL3                3042 
#define IDS_DEVICES_COL4                3043 
#define IDS_DEVICES_COL5                3044 
#define IDS_DEVICES_COL6                3045 
#define IDS_DEVICES_COL7                3046 
#define IDS_DEVICES_COL8                3047 
#define IDS_DEVICES_COL9                3048 
#define IDS_DEVICES_COL10               3049 
#define IDS_FAILTOADD_SENTITEMS         3050 
#define IDS_FAILTOADD_OUTRULE           3051 
#define IDS_FAILTOADD_AllDEVICES        3052 
#define IDS_FAILTOADD_DEVICES           3053 
#define IDS_ROUTINGMETHODS_COLUMN1      3054 
#define IDS_ROUTINGMETHODS_COLUMN2      3055 
#define IDR_TOOLBAR_16                  3056 
#define IDS_ROUTINGMETHODS_COLUMN3      3057 
#define IDS_ROUTINGMETHODS_COLUMN4      3058 
#define IDR_TOOLBAR_32                  3059 
#define IDS_ROUTINGMETHODS_COLUMN5      3060 
#define IDR_FAX_MENU                    3061 
#define IDS_ROUTINGMETHODS_COLUMN6      3062 
#define IDR_OUTRULES_MENU               3063 
#define IDS_ROUTINGMETHODS_COLUMN7      3064 
#define IDS_ROUTINGMETHODS_COLUMN8      3065 
#define IDD_OUTRULE_GENERAL             3066 
#define IDS_FAIL_ADD_DEVICE             3067 
#define IDD_OUTRULE_LOCATION            3068 
#define IDS_DEL_DEVICE                  3069 
#define IDI_OUTROUTINGRULES_32          3070 
#define IDS_DEVICE_EXISTS               3071 
#define IDS_FAILTOSAVECHANGES_DEVICE    3073 
#define IDD_DLGNEWOUTRULE               3074 
#define IDD_DLGNEWGROUP                 3075 
#define IDD_FAXDEVICE_GENERAL           3076 
#define IDD_FAXDEVICE_CONNECT           3077 
#define IDD_FAXDEVICE_ACTION            3078 
#define IDR_INMETHOD_MENU               3079 
#define IDR_OUTGROUP_MENU               3080 
#define IDR_OUTDEVICE_MENU              3081 
#define IDS_FAIL_TO_OPEN_OUTBOX         3082 
#define IDD_DLGNEWDEVICE                3084 
#define IDD_FAXDEVICE_ACTION_ADV        3085 
#define IDR_TOOLBAR_DEVICE_UD           3086 
#define IDD_MSFAXEXT_PRINT_DIALOG       3087 
#define IDR_DEVICE_MENU                 3088 
#define IDD_FAXSERVER_GENERAL           3089 
#define IDR_TOOLBAR_METHOD_UD           3090 
#define IDD_FAXSERVER_EMAIL             3091 
#define IDD_FAXSERVER_RECEIPTS          3092 
#define IDD_FAXSERVER_LOGGING           3093 
#define IDD_FAXSERVER_EVENTS            3094 
#define IDD_FAXSERVER_OUTBOX            3095 
#define IDD_FAXSERVER_INBOX_ARCHIVE     3096 
#define IDD_FAXSERVER_SENTITEMS         3097 
#define IDS_FAILED2ADD_PROVIDER         3098 
#define IDS_FAILED2INIT_PROVIDER        3099 
#define IDD_FAXSERVER_SECURITY          3100 
#define IDD_FAXINMETHOD_GENERAL         3101 
#define IDS_FAILTOADD_ROUTINGRULES      3102 
#define IDD_DLGNEWRULE                  3103 
#define IDS_FAILTOADD_REPORTS           3104 
#define IDR_OUTGROUPS_MENU              3105 
#define IDD_FAXCATALOGMETHOD_GENERAL    3106 
#define IDS_FAILTOADD_COVERPAGES        3107 
#define IDS_FAILTOADD_DELETEDITEMS      3108 
#define IDD_FAXPROVIDER_GENERAL         3109 
#define IDS_FAILTOADD_PROVIDERS         3110 
#define IDR_OUTRULE_MENU                3111 
#define IDS_FAILTOADD_INBOUNDROUTING    3112 
#define IDD_CONNECT_TO_WIZARD           3113 
#define IDS_FAILTOADD_OUTBOUNDROUTING   3114 
#define IDS_FAIL_TO_ADD_NODE            3115 
#define IDR_CATALOGMETHOD_MENU          3116 
#define IDS_MEMORY                      3117 
#define IDS_GET_ARCHIVE_DIRECTORY       3118 
#define IDR_COVERPAGES_MENU             3119 
#define IDS_CANT_CONNECT                3120 
#define IDR_COVERPAGE_MENU              3121 
#define IDS_FAIL_TO_OPEN_PROP_PAGE      3122 
#define IDS_MEMORY_FAIL_TO_OPEN_PP      3123 
#define IDS_FAXSERVER_APPLICATION_NAME  3124 
#define IDS_NETWORK_PROBLEMS            3125 
#define IDS_GENERAL_FAILURE             3126 
#define IDS_DISPLAY_STR_FAXSERVERNODE   3127 
#define IDS_INVALID_PARAMETER           3128 
#define IDS_ACCESS_DENIED               3129 
#define IDR_TOOLBAR_STARTSTOP           3130 
#define IDD_CONFIRM_PASSWORD            3131 
#define IDS_GET_LOG_FILE                3132 
#define IDS_INBOUND_METHODS_COL1        3133 
#define IDS_INBOUND_METHODS_COL2        3134 
#define IDS_INBOUND_METHODS_COL3        3135 
#define IDS_INBOUND_METHODS_COL4        3136 
#define IDS_INBOUND_METHODS_COL5        3137 
#define IDS_FAILTOADD_METHODS           3138 
#define IDS_DISPLAY_STR_DEVICESANDPROVIDERSNODE 3139 
#define IDS_DISPLAY_STR_DEVICESNODE     3140 
#define IDS_DISPLAY_STR_PROVIDERSNODE   3141 
#define IDS_DISPLAY_STR_INROUTEMETHODSNODE 3142 
#define IDS_FXS_YES                     3143 
#define IDS_FXS_NO                      3144 
#define IDS_FAIL_NOTIFY_MMCPROPCHANGE   3145 
#define IDS_FAILTOADD_INBOUNDROUTINGMETHODS 3146 
#define IDS_INMETHOD_ENABLE             3147 
#define IDS_INMETHOD_DISABLE            3148 
#define IDS_FAIL_TOREFRESH_INMETHOD_NODE 3149 
#define IDS_FAIL2REFRESH_GROUP          3150 
#define IDS_FAILTOADD_ROUTINGGROUPS     3151 
#define IDS_OUTBOUND_DEVICES_COL1       3152 
#define IDS_OUTBOUND_DEVICES_COL2       3153 
#define IDS_OUTBOUND_DEVICES_COL3       3154 
#define IDS_OUTBOUND_DEVICES_COL4       3155 
#define IDS_OUTBOUND_DEVICES_COL5       3156 
#define IDS_OUTBOUND_DEVICES_COL6       3157 
#define IDS_OUTBOUND_GROUPS_COL1        3158 
#define IDS_OUTBOUND_GROUPS_COL2        3159 
#define IDS_OUTBOUND_GROUPS_COL3        3160 
#define IDS_OUTBOUND_GROUPS_COL4        3161 
#define IDS_DISPLAY_STR_OUTBOUNDROUTINGNODE 3162 
#define IDS_DISPLAY_STR_OUTROUTEGROUPSNODE 3163 
#define IDS_COUNTRY_CODE_ANY            3164 
#define IDS_ALL_AREAS                   3165 
#define IDS_ALL_DEVICES                 3166 
#define IDS_STATUS_RULE_EMPTY           3167 
#define IDS_STATUS_RULE_VALID           3168 
#define IDS_STATUS_RULE_INVALID_DEVICE  3169 
#define IDS_STATUS_RULE_SOMEDEVICESINVALID 3170 
#define IDS_STATUS_RULE_ALLDEVICESINVALID 3171 
#define IDS_DISPLAY_STR_OUTBOUNDRULES   3172 
#define IDS_FAIL_TO_DISCOVERDEVICENAME  3173 
#define IDS_STATUS_GROUP_ALL_DEV_VALID  3174 
#define IDS_STATUS_GROUP_EMPTY          3175 
#define IDS_STATUS_GROUP_ALLDEVICESINVALID 3176 
#define IDS_STATUS_GROUP_SOMEDEVICESINVALID 3177 
#define IDS_CANNOT_FIND_DEVICE          3178 
#define IDS_FAILTOINIT_GROUP            3179 
#define IDS_FAILTOADD_GROUP             3180 
#define IDS_FAIL_TO_DISCOVERDEVICEFORGROUP 3181 
#define IDS_DISPLAY_STR_INBOUNDROUTINGNODE 3182 
#define IDS_INVALID_GROUP_NAME          3183 
#define IDS_FAIL_TO_REMOVE_GROUP        3184 
#define IDS_FAIL2OPEN_DLG               3185 
#define IDS_FAIL2LOADCOUNTRYLIST        3186 
#define IDS_ERROR                       3187 
#define IDS_FAIL2LOADDEVICELIST         3188 
#define IDS_FAIL2READ_AREACODE          3189 
#define IDS_PLEASESELECT_COUNTRY        3190 
#define IDS_PLEASESELECT_AREACODE       3191 
#define IDS_FAIL_TO_REMOVE_DEVICE       3192 
#define IDS_PLEASESELECT_DEVICE         3193 
#define IDS_PLEASESELECT_GROUP          3194 
#define IDS_EMPTY_AREACODE              3195 
#define IDS_FAIL2READ_GROUPNAME         3196 
#define IDS_OUTGROUP_EXISTS             3197 
#define IDS_FAIL2REPOPULATE_GROUPS      3198 
#define IDS_SELECT_ITEM                 3199 
#define IDS_FAIL2LOADGROUPLIST          3200 
#define IDS_FAIL2UPDATEITEM_GROUP       3201 
#define IDS_MODIFYRULE                  3202 
#define IDS_FAIL2REFRESH_THEVIEW        3203 
#define IDS_FAIL2ADD_OUTBOUNDRULE       3204 
#define IDS_FAIL2INIT_OUTBOUNDRULE      3205 
#define IDS_DISPLAY_STR_METHODSCATALOGNODE 3206 
#define IDS_CATALOG_INMETHODS_COL1      3207 
#define IDS_CATALOG_INMETHODS_COL2      3208 
#define IDS_CATALOG_INMETHODS_COL3      3209 
#define IDS_CATALOG_INMETHODS_COL4      3210 
#define IDS_CATALOG_INMETHODS_COL5      3211 
#define IDS_CATALOG_INMETHODS_COL6      3212 
#define IDS_CATALOG_INMETHODS_COL7      3213 
#define IDS_PROVIDERS_COL1              3214 
#define IDS_PROVIDERS_COL2              3215 
#define IDS_PROVIDERS_COL3              3216 
#define IDS_PROVIDERS_COL4              3217 
#define IDS_PROVIDERS_COL5              3218 
#define IDS_PROVIDERS_COL6              3219 
#define IDS_PROVIDERS_COL7              3220 
#define IDS_PROVIDERS_COL8              3221 
#define IDS_STATUS_PROVIDER_SUCCESS     3222 
#define IDS_STATUS_PROVIDER_SERVER_ERROR 3223 
#define IDS_STATUS_PROVIDER_BAD_GUID    3224 
#define IDS_STATUS_PROVIDER_BAD_VERSION 3225 
#define IDS_STATUS_PROVIDER_CANT_LOAD   3226 
#define IDS_STATUS_PROVIDER_CANT_LINK   3227 
#define IDS_STATUS_PROVIDER_CANT_INIT   3228 
#define IDS_CHK                         3229 
#define IDS_SECURITY_CAT_NODE_DESC      3230 
#define IDS_COVERPAGES_COL1             3236 
#define IDS_COVERPAGES_COL2             3237 
#define IDS_COVERPAGES_COL3             3238 
#define IDS_COVERPAGES_COL4             3239 
#define IDS_COVERPAGES_COL5             3240 
#define IDS_COVERPAGES_COL6             3241 
#define IDS_COVERPAGES_COL7             3242 
#define IDS_FAIL2ADD_COVERPAGE          3243 
#define IDS_DISPLAY_STR_COVERPAGES      3244 
#define IDS_FAIL2SET_SECURITYINFO       3254 
#define IDS_FAIL2INIT_COVERPAGE_DATA    3256 
#define IDS_FAIL2DELETE_COV             3257 
#define IDS_CP_FILETYPE                 3258 
#define IDS_BROWSE_COVERPAGE            3259 
#define IDS_BAD_CP_EXTENSION            3260 
#define IDS_CP_DUPLICATE                3261 
#define IDS_FAILED2COPY_COVERPAGE       3262 
#define IDS_FILENAME_TOOLONG            3263 
#define IDS_CP_DUP_YESNO                3264 
#define IDS_FAIL2GET_SERVER_CP_DIR      3265 
#define IDS_FAIL2STOP_SRV               3266 
#define IDS_FAIL2START_SRV              3267 
#define IDS_FAIL2UPDATE_SRVSTATUS_TOOLBAR 3268 
#define IDS_SRV_ALREADY_START           3269 
#define IDS_SRV_ALREADY_STOP            3270 
#define IDS_FAXCONSOLE_NOTFOUND         3271 
#define IDS_FAXCONSOLE_ACCESSDENIED     3272 
#define IDS_FAIL2LAUNCH_FAXCONSOLE_GEN  3273 
#define IDS_FAIL2REDRAW_GROUPSNODE      3274 
#define IDS_FAIL2REFERESH_GROUP         3275 
#define IDS_FAIL2REPOPULATE_DEVICES     3276 
#define IDS_FAIL2REDRAW_DEVICESNODE     3277 
#define IDS_FAIL2REFERESH_DEVICEINMETHODS 3278 
#define IDS_FAIL2ADD_DEVICENODE         3279 
#define IDS_SERVERNAME_STRING_CONTAINS_INVALID_CHARACTERS 3280 
#define IDS_SERVERNAME_EMPTY_STRING     3281 
#define IDS_SENDER_ADDRESS_EMPTY        3282 
#define IDS_DOMAIN_EMPTY                3283 
#define IDS_FAIL2ENABLE_METHOD_ERR      3284 
#define IDS_USERNAME_EMPTY              3285 
#define IDS_INVALID_PASSWORD            3286 
#define IDS_SERVERNAME_TOO_LONG         3287 
#define IDS_PORT_EMPTY_STRING           3288 
#define IDS_PORT_NOT_NUMERIC            3289 
#define IDS_INVALID_PORT_NUM            3290 
#define IDS_LOG_PATH_EMPTY              3291 
#define IDS_WATERMARK_EMPTY             3292 
#define IDI_ICON_FAXSERVER              3293 
#define IDS_WATERMARK_HI_LOW            3294 
#define IDI_INFO                        3295 
#define IDS_AUTODEL_EMPTY               3296 
#define IDB_FAX_BITMAP_32               3297 
#define IDS_SENT_ARCHIVE_PATH_EMPTY     3298 
#define IDB_FAX_BITMAP_16               3299 
#define IDS_INBOX_ARCHIVE_PATH_EMPTY    3300 
#define IDI_OUTBOX                      3301 
#define IDS_INBOX_WATERMARK_EMPTY       3302 
#define IDI_EVENTREPORT                 3303 
#define IDS_INBOX_WATERMARK_HI_LOW      3304 
#define IDS_INBOX_AUTODEL_EMPTY         3305 
#define IDI_INBOX                       3306 
#define IDS_OUTB_RETRIES_EMPTY          3307 
#define IDI_ACTIVITYLOGGING             3308 
#define IDS_OUTB_RETRYDELAY_EMPTY       3309 
#define IDI_RECEIPTS                    3310 
#define IDS_OUTB_DAYS_EMPTY             3311 
#define IDI_SENTITEMS                   3312 
#define IDS_DEVICE_RINGS_EMPTY          3313 
#define IDI_OUTRULE                     3314 
#define IDS_RESOURSE_IN_USE             3315 
#define IDI_INMETHOD                    3316 
#define IDI_DEVICE                      3317 
#define IDS_ERROR_DIRECTORY             3318 
#define IDI_PROVIDER                    3319 
#define IDS_ERROR_BAD_PATHNAME          3320 
#define IDI_CATALOG_INMETHOD            3321 
#define IDS_ERROR_EAS_NOT_SUPPORTED     3322 
#define IDS_LEFTBRACKET_PLUSSPACE       3323 
#define IDS_RIGHTBRACKET                3324 
#define IDS_LOCAL_PLUSBRACKET_PLUSSPACE 3325 
#define IDS_FAIL_TO_OPEN_TARGETING_WIZARD 3326 
#define IDS_FAIL2RENAME_NODE            3327 
#define IDS_FAX_CONNECT                 3328 
#define IDS_OPENPORT_INVALID_HANDLE     3329 
#define IDD_DLG_SMTP_SET                3330 
#define IDS_FAIL2UPDATE_SMTP_CONFIG     3331 
#define IDS_PASSWORD_NOT_MATCH          3332 
#define IDS_DEVICE_STATUS_RINGING       3333 
#define IDS_DEVICE_STATUS_IDLE          3334 
#define IDS_DEVICE_STATUS_RECEIVING     3335 
#define IDS_DEVICE_STATUS_SENDING       3336 
#define IDS_DEVICE_STATUS_POWERED_OFF   3337 
#define IDS_INBOX_HIGH_WATERMARK_ZERO   3338 
#define IDS_SENT_HIGH_WATERMARK_ZERO    3339 
#define IDS_FAIL2REFRESH_DEVICE         3340 
#define IDS_FAX_ERR_SRV_OUTOFMEMORY     3341 
#define IDS_FAX_ERR_GROUP_NOT_FOUND     3342 
#define IDS_FAX_ERR_BAD_GROUP_CONFIGURATION 3343 
#define IDS_FAX_ERR_GROUP_IN_USE        3344 
#define IDS_FAX_ERR_RULE_NOT_FOUND      3345 
#define IDS_ERROR_PATH_NOT_FOUND        3347 
#define IDS_ERROR_REGISTRY_CORRUPT      3348 
#define IDS_BAD_GROUP_CONFIGURATION     3349 
#define IDS_SENT_FAX_ERR_NOT_NTFS       3350 
#define IDS_INBOX_FAX_ERR_NOT_NTFS      3351 
#define IDS_SENT_FAX_ERR_FILE_ACCESS_DENIED     3352 
#define IDS_INBOX_FAX_ERR_FILE_ACCESS_DENIED    3353 
#define IDS_LOGGING_FAX_ERR_FILE_ACCESS_DENIED  3354 
#define IDS_SENT_ERROR_DISK_FULL                3355 
#define IDS_INBOX_ERROR_DISK_FULL               3356 
#define IDS_LOGGING_ERROR_DISK_FULL     3357 
#define IDS_SENT_ERROR_PATH_NOT_FOUND   3358 
#define IDS_INBOX_ERROR_PATH_NOT_FOUND  3359 
#define IDS_LOGGING_ERROR_PATH_NOT_FOUND 3360 
#define IDD_SELECT_COUNTRYCODE          3361 
#define IDS_FAIL2READ_COUNTRYCODE       3362 
#define IDS_MS_SMTPROUTINGMETHOD_ASSIGNED 3363 
#define IDS_ZERO_COUNTRYCODE            3364 
#define IDS_FAIL2ENABLE_METHOD          3365 
#define IDS_EVALUATION                  3366 
#define IDS_COVERPAGES_PATH_NOT_FOUND   3367 
#define IDS_DEVICE_AUTO                 3368 
#define IDS_DEVICE_MANUAL               3369 
#define IDS_ERR_ADMIN_DEVICE_LIMIT      3370 
#define IDS_FAX_ERR_INVALID_CSID        3371 
#define IDS_FAX_ERR_INVALID_TSID        3372 
#define IDC_LOCATION_RADIO1             3376 
#define IDC_COUNTRY_RADIO               3377 
#define IDC_COUNTRY_RADIO1              3378 
#define IDC_ANONIM_ACCESS_RADIO1        3379 
#define IDC_SMTP_ANONIM_RADIO1          3380 
#define IDC_RADIO2                      3381 
#define IDC_LOCATION_RADIO2             3382 
#define IDC_AREA_RADIO                  3383 
#define IDC_AREA_RADIO1                 3384 
#define IDC_SENT_QUOTA_LOW_STATIC       3385 
#define IDC_AUTENTICATE_ACCESS_RADIO2   3386 
#define IDC_DESTINATION_RADIO1          3387 
#define IDC_DESTINATION_RADIO11         3388 
#define IDC_DESTINATION_RADIO2          3389 
#define IDC_DESTINATION_RADIO21         3390 
#define IDC_PRIORITY_SPIN               3393 
#define IDC_RINGS_SPIN                  3395 
#define IDC_RECEIVE_CHECK               3396 
#define IDC_PAUSE_CHECK                 3397 
#define IDC_MB2_STATIC                  3398 
#define IDC_GENERATE_WARNING_CHECK      3400 
#define IDC_HIGH_SPIN                   3402 
#define IDC_AUTODEL_SPIN                3404 
#define IDC_RETRYDELAY_SPIN4            3405 
#define IDC_MB2_STATIC2                 3406 
#define IDC_SENT_MB2_STATIC             3407 
#define IDC_RETRYDELAY_SPIN5            3408 
#define IDC_SPIN2                       3411 
#define IDC_RINGS_EDIT                  3412 
#define IDC_DAY_EDIT                    3413 
#define IDC_HIGH_EDIT                   3414 
#define IDC_AUTODEL_EDIT                3416 
#define IDC_RETRYDELAY_EDIT4            3418 
#define IDC_DESCRIPTION_EDIT            3419 
#define IDC_TSID_EDIT                   3420 
#define IDC_MSFAXEXT_PRINT_EDIT1        3421 
#define IDC_SMTP_EDIT                   3422 
#define IDC_QUOTA_LOW_STATIC            3423 
#define IDC_LOG_FILE_EDIT               3424 
#define IDC_DEVICE_DESCRIPTION_EDIT     3425 
#define IDC_RULE_AREACODE_EDIT          3426 
#define IDC_EXTENSION_DLL_EDIT          3427 
#define IDC_FSPVERSION_EDIT             3428 
#define IDC_QUED_ROEDIT                 3429 
#define IDC_CSID_EDIT                   3430 
#define IDC_SMTP_USERNAME_EDIT          3431 
#define IDC_DEVICE_TSID_EDIT            3432 
#define IDC_FSPSTATUS_EDIT              3433 
#define IDC_OUTGOING_INPROC_ROEDIT      3434 
#define IDC_CONFIRM_PASSWORD_EDIT       3435 
#define IDC_SMTP_PASSWORD_EDIT          3436 
#define IDC_DEVICE_CSID_EDIT            3437 
#define IDC_FSPVPATH_EDIT               3438 
#define IDC_INCOM_INPROC_ROEDIT         3439 
#define IDC_DOMAIN_EDIT                 3440 
#define IDC_NAME_EDIT                   3441 
#define IDC_PORT_EDIT                   3442 
#define IDC_LOCATION_RADIO3             3443 
#define IDC_COUNTRYCODE_COMBO           3444 
#define IDC_SENT_TO_ARCHIVE_CHECK       3445 
#define IDC_SENT_GENERATE_WARNING_CHECK 3446 
#define IDC_AREACODE_EDIT               3447 
#define IDC_DOMESTIC_RADIO2             3448 
#define IDC_DOMESTIC_RADIO1             3449 
#define IDC_INTERNATIONAL_RADIO1        3450 
#define IDC_INTERNATIONAL_RADIO2        3451 
#define IDC_DOMESTIC_FRSTATIC           3452 
#define IDC_INTERNATIONAL_FRSTATIC      3453 
#define IDC_DEVICES_RADIO1              3454 
#define IDC_DEVICES_RADIO2              3455 
#define IDC_NAME_STATIC                 3456 
#define IDC_DESCRIPTION_STATIC          3457 
#define IDC_DEVICEID_STATIC             3458 
#define IDC_DEVICES_FRSTATIC            3459 
#define IDC_TYPE_STATIC                 3460 
#define IDC_M_LINE                      3461 
#define IDC_ROUTINGMETHOD_LIST          3462 
#define IDC_FAXDEVICE_METHODS_LISTVIEW  3463 
#define IDC_FAXDEVICE_NAME_STATIC       3464 
#define IDC_FAXDEVICE_NAME_DTEXT        3465 
#define IDC_FAXDEVICE_TYPE_DTEXT        3466 
#define IDC_FAXDEVICE_EXTNAME_DTEXT     3467 
#define IDC_FAXDEVICE_SERVERNAME_DTEXT  3468 
#define IDC_FAXDEVICE_TYPE_STATIC       3469 
#define IDC_SERVERNAME_STATIC           3470 
#define IDC_FAXDEVICE_DESCRIPTION_STATIC 3471 
#define IDC_HEADER_STATIC               3472 
#define IDC_SEND_CHECK                  3473 
#define IDC_SENDRECEIVE_FSTATIC         3474 
#define IDC_TSID_STATIC                 3475 
#define IDC_CSID_STATIC                 3476 
#define IDC_ADDRESS_EDIT                3477 
#define IDC_RINGS_STATIC                3478 
#define IDC_TSID_FSTATIC                3479 
#define IDC_LONGS_FSTATIC               3480 
#define IDC_FAXDEVICE_EDIT_BUTTON       3481 
#define IDC_NEWDEVICE_NAME_EDIT         3482 
#define IDC_NEWDEVICE_ID_EDIT           3483 
#define IDC_DEVICETYPE_COMBO            3484 
#define IDC_NEWDEVICE_SERVERNAME_EDIT   3485 
#define IDC_COUNTRYRULE_COMBO           3486 
#define IDC_FOIP_COMBO                  3487 
#define IDC_DEVICES4RULE_COMBO          3488 
#define IDC_DEVICES4RULE_COMBO1         3489 
#define IDC_FAXDEVICE_METHODS_HEADER    3490 
#define IDC_GROUP4RULE_COMBO            3491 
#define IDC_GROUP4RULE_COMBO1           3492 
#define IDC_STATUS_FSTATIC              3493 
#define IDC_ACTIVITY2_FSTATIC           3494 
#define IDC_VERSION_STATIC              3495 
#define IDC_ACTIVITY_FSTATIC            3496 
#define IDC_CONFIRM_PASSWORD_STATIC     3497 
#define IDC_ACTIVITY_DTEXT              3498 
#define IDC_STOP_BUTTON                 3499 
#define IDC_START_BUTTON                3500 
#define IDC_SERVER_STATIC               3501 
#define IDC_VERSION_DTEXT               3502 
#define IDC_STATUS_STATIC               3503 
#define IDC_STATUS_DTEXT                3504 
#define IDC_EMAILSERVER_STATIC          3505 
#define IDC_EMAILEXP_STATIC             3506 
#define IDC_SMTP_STATIC                 3507 
#define IDC_USERNAME                    3508 
#define IDC_USERNAME_STATIC             3509 
#define IDC_SMTP_USERNAME_STATIC        3510 
#define IDC_PORT_STATIC                 3511 
#define IDC_LOGGING_HEAD_STATIC         3512 
#define IDC_DOMAIN_STATIC               3513 
#define IDC_INCOMING_LOG_CHECK          3514 
#define IDC_OUTGOING_LOG_CHECK          3515 
#define IDC_DATABASE_FSTATIC            3516 
#define IDC_SENT_BROWSE_BUTTON          3517 
#define IDC_SLIDER1                     3518 
#define IDC_SLIDER2                     3519 
#define IDC_SLIDER3                     3520 
#define IDC_SLIDER4                     3521 
#define IDC_INBOUND_STATIC              3522 
#define IDC_OUTBAND_STATIC              3523 
#define IDC_INIT_STATIC                 3524 
#define IDC_GENERAL_STATIC              3525 
#define IDC_SENSITIVITY_HEAD_STATIC     3526 
#define IDC_OUTBOX_HEADER_STATIC        3527 
#define IDC_TRANS_FSTATIC               3528 
#define IDC_TSID_CHECK                  3529 
#define IDC_ACTIVITY_SETTINGS_STATIC    3531 
#define IDC_ALLOW_PERSONAL_CHECK        3532 
#define IDC_FOLDER_FSTATIC              3533 
#define IDC_SENT_QUOTA_HIGH_STATIC      3534 
#define IDC_FOLDER_EDIT                 3535 
#define IDC_ARCHIVE_QUOTA_FSTATIC       3536 
#define IDC_AUTODEL_CHECK               3537 
#define IDC_QUOTA_HIGH_STATIC           3538 
#define IDC_MB1_STATIC                  3539 
#define IDC_ADAYS_STATIC                3540 
#define IDC_MB1_STATIC2                 3541 
#define IDC_SENT_HEADER_STATIC          3542 
#define IDC_LOW_EDIT                    3543 
#define IDC_LOW_SPIN                    3544 
#define IDC_TBD_STATIC                  3545 
#define IDC_TO_ARCHIVE_CHECK            3546 
#define IDC_NONE1_STATIC                3547 
#define IDC_HIGH1_STATIC                3548 
#define IDC_NONE2_STATIC                3549 
#define IDC_HIGH2_STATIC                3550 
#define IDC_NONE3_STATIC                3551 
#define IDC_HIGH3_STATIC                3552 
#define IDC_NONE4_STATIC                3553 
#define IDC_HIGH4_STATIC                3554 
#define IDC_PASSWORD_STATIC             3555 
#define IDC_SMTP_PASSWORD_STATIC        3556 
#define IDC_TRANSSMISS_FSTATIC          3558 
#define IDC_DEVICE_RINGS_STATIC         3559 
#define IDC_DEVICE_RINGS_EDIT           3560 
#define IDC_DEVICE_RINGS_SPIN           3561 
#define IDC_GENERAL_HEAD_STATIC         3562 
#define IDC_INBOX_HEAD_STATIC           3563 
#define IDC_OUTRULE_HEAD_STATIC         3564 
#define IDC_NEWOUTRULE_HEAD_STATIC      3565 
#define IDC_NEWGROUP_HEAD_STATIC        3566 
#define IDC_NEWDEVICE_HEAD_STATIC       3567 
#define IDC_INMETHOD_NAME_STATIC        3568 
#define IDC_INMETHOD_STATUS_STATIC      3569 
#define IDC_INMETHOD_EXTENSION_STATIC   3570 
#define IDC_INMETOD_NAME_H_STATIC       3571 
#define IDC_INMETHOD_STATUS_H_STATIC    3572 
#define IDC_INMETHOD_EXT_H_STATIC       3573 
#define IDC_RULE_HEAD_STATIC            3574 
#define IDC_RULETYPE_FSTATIC            3575 
#define IDC_RULE_HEAD_STATIC2           3576 
#define IDC_COUNTRY1_STATIC             3577 
#define IDC_COUNTRY2_STATIC             3578 
#define IDC_AREA_STATIC                 3579 
#define IDC_RULEDESTINATION_STATIC      3580 
#define IDC_GROUPNAME_STATIC            3581 
#define IDC_GROUPNAME_EDIT              3582 
#define IDC_AV_DEVICES_LIST             3583 
#define IDC_DEVICESLIST_STATIC          3584 
#define IDC_DEVICE_LISTVIEW             3585 
#define IDC_SEPARATE_LINE               3586 
#define IDC_RULE_AREACODE_EDIT1         3587 
#define IDC_CATALOG_INBOX_STATIC        3588 
#define IDC_CATA_EXTENSION_STATIC       3589 
#define IDC_FSP_HEADER_STATIC           3590 
#define IDC_FSPSTATUS_STATIC            3591 
#define IDC_FSPPATH_STATIC              3592 
#define IDC_ADDRESS_STATIC              3593 
#define IDC_BASIC_AUTHEN_RADIO1         3594 
#define IDC_SMTP_BASIC_RADIO2           3595 
#define IDC_NTLM_AUTHEN_RADIO2          3596 
#define IDC_SMTP_NTLM_RADIO3            3597 
#define IDC_QUED_STATIC                 3598 
#define IDC_OUTGOING_INPROC_STATIC      3599 
#define IDC_INCOM_INPROC_STATIC         3600 
#define IDC_SUBMISSION_CHECK            3601 
#define IDC_TRANSSMI_CHECK              3602 
#define IDC_RECEPTION_CHECK             3603 
#define IDC_INBOX_BROWSE_BUTTON         3604 
#define IDC_LOG_BROWSE_BUTTON           3605 
#define IDC_SENT_HIGH_SPIN              3606 
#define IDC_SENT_LOW_SPIN               3607 
#define IDC_SENT_LOW_EDIT               3608 
#define IDC_SENT_HIGH_EDIT              3609 
#define IDC_SENT_AUTODEL_EDIT           3610 
#define IDC_SENT_AUTODEL_SPIN           3611 
#define IDC_SENT_AUTODEL_CHECK          3612 
#define IDC_INBOX_FOLDER_EDIT           3613 
#define IDC_SENT_MB1_STATIC             3614 
#define IDC_CONNECT_HEADER_STATIC       3619 
#define IDC_CONNECT_LOCAL_RADIO1        3620 
#define IDC_CONNECT_ANOTHER_RADIO2      3621 
#define IDC_CONNECT_COMPUTER_NAME_EDIT  3622 
#define IDC_CONNECT_BROWSE4SERVER_BUTTON 3623 
#define IDC_CONNECT_OVERRIDE_CHECK      3624 
#define IDC_CONNECT_MAIN_FSTATIC        3625 
#define IDC_SMTP_ANONYM_STATIC          3626 
#define IDC_SMTP_BASIC_STATIC           3627 
#define IDC_SMTP_NTLM_STATIC            3628 
#define IDC_RECEIPT_ENABLE_SMTP_CHECK   3629 
#define IDC_CHECK2                      3630 
#define IDC_RECEIPT_ENABLE_MSGBOX_CHECK 3631 
#define IDC_SMTP_HEADER_STATIC          3632 
#define IDC_AUTHENTICATION_BUTTON       3633 
#define IDC_SMTP_HEAD_STATIC            3634 
#define IDC_RECEIPTS_ICON               3635 
#define IDC_RECEIPTS_HELP_LINK          3636 
#define IDC_RECEIPT_SMTP_FSTATIC        3637 
#define IDC_RECEIPT_MESSAGEBOX_FSTATIC  3638 
#define IDC_CTALOG_INMETHOD_ICON        3639 
#define IDC_INBOX_ICON                  3640 
#define IDC_SENT_ITEMS_ICON             3641 
#define IDC_OUTBOX_ICON                 3642 
#define IDC_LOGGING_ICON                3643 
#define IDC_EVENTS_ICON                 3644 
#define IDC_PROVIDER_ICON               3645 
#define IDC_ROUTING_RULE_ICON           3646 
#define IDC_INMETHOD_ICON               3647 
#define IDC_FAX_DEVICE_ICON             3648 
#define IDC_FAXSERVER_ICON              3649 
#define IDC_EVENT_REPORT_ICON           3650 
#define IDC_SMTP_ROUTE_CHECK            3651 
#define IDC_SELECT_HEAD_STATIC          3652 
#define IDC_NEWRULE_COUNTRYCODE_EDIT    3653 
#define IDC_NEWRULE_SELECT_BUTTON       3654 
#define IDC_RULE_COUNTRYCODE_EDIT       3655 
#define IDC_RULE_SELECT_BUTTON          3656 
#define IDC_RULE_COUNTRYCODE_EDIT1      3657 
#define IDC_RULE_SELECT_BUTTON1         3658 
#define IDC_SMTP_CREDENTIALS_BASIC_BUTTON   3659 
#define IDC_SMTP_CREDENTIALS_NTLM_BUTTON    3660 
#define IDC_RECEIVE_MANUAL_RADIO2       3661 
#define IDC_RECEIVE_AUTO_RADIO1         3662 
#define ID_BUTTON32768                  3663 
#define ID_BUTTON32769                  3664 
#define ID_BUTTON32770                  3665 
#define ID_BUTTON32771                  3666 
#define IDM_NEW_OUTRULE                 3667 
#define IDM_NEW_FDEVICE                 3668 
#define ID_BUTTON32774                  3669 
#define ID_BUTTON32775                  3670 
#define ID_BUTTON32777                  3671 
#define ID_BUTTON32778                  3672 
#define ID_BUTTON32779                  3673 
#define IDM_FAX_DEVICE_SEND             3674 
#define IDM_FAX_INMETHOD_ENABLE         3675 
#define IDM_FAX_INMETHOD_DISABLE        3676 
#define ID_BUTTON32784                  3677 
#define ID_BUTTON32785                  3678 
#define ID_BUTTON32786                  3679 
#define ID_BUTTON32787                  3680 
#define ID_BUTTON32788                  3681 
#define ID_BUTTON32789                  3682 
#define ID_BUTTON32790                  3683 
#define ID_BUTTON32791                  3684 
#define ID_BUTTON32792                  3685 
#define ID_BUTTON32793                  3686 
#define ID_BUTTON32794                  3687 
#define IDM_NEW_GROUP                   3688 
#define IDM_NEW_DEVICES                 3689 
#define ID_MOVEUP_BUTTON                3690 
#define ID_MOVEDOWN_BUTTON              3691 
#define IDM_MOVEUP                      3692 
#define IDM_MOVEDOWN                    3693 
#define ID_BUTTON32801                  3694 
#define ID_BUTTON32802                  3695 
#define ID_BUTTON32803                  3696 
#define ID_BUTTON32804                  3697 
#define ID_BUTTON32805                  3698 
#define ID_BUTTON32806                  3699 
#define ID_BUTTON32807                  3700 
#define ID_BUTTON32808                  3701 
#define IDM_CONFIG_OUTRULE              3702 
#define IDM_CMETHOD_MOVEUP              3703 
#define IDM_CMETHOD_MOVEDOWN            3704 
#define ID_BUTTON32812                  3705 
#define ID_BUTTON32813                  3706 
#define ID_BUTTON32814                  3707 
#define ID_BUTTON32815                  3708 
#define ID_BUTTON32816                  3709 
#define ID_BUTTON32818                  3710 
#define ID_BUTTON32820                  3711 
#define ID_BUTTON32821                  3712 
#define IDM_OPEN_COVERPAGE              3713 
#define IDM_NEW_COVERPAGE               3714 
#define IDM_EDIT_COVERPAGE              3715 
#define IDM_SRV_START                   3716 
#define IDM_SRV_STOP                    3717 
#define ID_START_BUTTON                 3718 
#define ID_STOP_BUTTON                  3719 
#define ID_CLIENTCONSOLE_BUTTON         3720 
#define IDM_LAUNCH_CONSOLE              3721 
#define IDM_FAX_DEVICE_RECEIVE_AUTO     3722 
#define IDM_FAX_DEVICE_RECEIVE_MANUAL   3723 
#define IDS_ERR_API_NEW_VERSION         3724 
#define IDD_DLG_BOS_SMTP_SET            3725 
#define IDC_SMTP_INFO_ICON              3726 
#define IDC_SMTP_NTLM_TIP_STATIC        3727
#define IDS_ERR_DESKTOP_SKU_CONNECTION  3728
#define IDS_FAX_WRN_MESSENGER_DISABLED  3729
#define IDS_FAX_WRN_MESSENGER_TITLE     3730
#define IDS_FAX_ADMIN_SNAPIN_NAME       3731 // Do not change. Used by RGS file.

#include "..\..\admin\faxres\resource.h"
 

//////////////////////////////////////////////////////
//                                                  //
// Fax Admin Console resource ID file               //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [3000 - 4999]                                    //
//                                                  //
//////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\providers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Providers.cpp                                          //
//                                                                         //
//  DESCRIPTION   : Fax Providers MMC node.                                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   create                                         //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "DevicesAndProviders.h"
#include "Providers.h"
#include "Provider.h"

#include "Icons.h"
#include "oaidl.h"

///////////////////////////////////////////////////////////////////////////////////////////////
// {3EC48359-53C9-4881-8109-AEB3D99BAF23}
static const GUID CFaxProvidersNodeGUID_NODETYPE = 
{ 0x3ec48359, 0x53c9, 0x4881, { 0x81, 0x9, 0xae, 0xb3, 0xd9, 0x9b, 0xaf, 0x23 } };

const GUID*    CFaxProvidersNode::m_NODETYPE = &CFaxProvidersNodeGUID_NODETYPE;
const OLECHAR* CFaxProvidersNode::m_SZNODETYPE = OLESTR("3EC48359-53C9-4881-8109-AEB3D99BAF23");
const CLSID*   CFaxProvidersNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxProvidersNode::m_ColsInfo;

/*
 -  CFaxProvidersNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxProvidersNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    HRESULT hRc = S_OK;
    DEBUG_FUNCTION_NAME( _T("CFaxProvidersNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_PROVIDERS_COL1, FXS_LARGE_COLUMN_WIDTH},
        {IDS_PROVIDERS_COL2, AUTO_WIDTH},
        {IDS_PROVIDERS_COL3, FXS_WIDE_COLUMN_WIDTH},
        {IDS_PROVIDERS_COL4, FXS_LARGE_COLUMN_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}


/*
 -  CFaxProvidersNode::initRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxProvidersNode::InitRPC(PFAX_DEVICE_PROVIDER_INFO  *pFaxProvidersConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxProvidersNode::InitRPC"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;

    ATLASSERT(NULL == (*pFaxProvidersConfig) );
    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }
    

    //
	// Retrieve the fax providers configuration
	//
    if (!FaxEnumerateProviders(pFaxServer->GetFaxServerHandle(), 
                        pFaxProvidersConfig,
                        &m_dwNumOfProviders)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get providers configuration. (ec: %ld)"), 
			ec);


        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }


        goto Error; 
    }
    //For max verification
    ATLASSERT(*pFaxProvidersConfig);

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get providers configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}



/*
 -  CFaxProvidersNode::PopulateResultChildrenList
 -
 *  Purpose:
 *      Create the FaxProviders children nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxProvidersNode::PopulateResultChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxProvidersNode::PopulateResultChildrenList"));
    HRESULT hRc = S_OK;

    CFaxProviderNode *   pProvider = NULL;
                       
    PFAX_DEVICE_PROVIDER_INFO  pFaxProvidersConfig = NULL ;
    DWORD i;

    //
    // Get the Config. structure with FaxEnumerateProviders
    //
    hRc = InitRPC(&pFaxProvidersConfig);
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        pFaxProvidersConfig = NULL;
        
        goto Error;
    }
    ATLASSERT(NULL != pFaxProvidersConfig);

    
    for ( i=0; i< m_dwNumOfProviders; i++ )
    {
            pProvider = new CFaxProviderNode(this, m_pComponentData);
            if (!pProvider)
            {
                hRc = E_OUTOFMEMORY;
                NodeMsgBox(IDS_MEMORY);
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. (hRc: %08X)"),
			        hRc);
                goto Error;
            }
            else
            {
	            pProvider->InitParentNode(this);

                hRc = pProvider->Init(&pFaxProvidersConfig[i]);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add provider node. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAILED2INIT_PROVIDER);
                    goto Error;
	            }
	            hRc = this->AddChildToList(pProvider);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add provider to the view. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAILED2ADD_PROVIDER);
                    goto Error;
	            }
                else
                {
                    pProvider = NULL;
                }
            }
    }
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pProvider ) 
    {
        delete  pProvider;    
        pProvider = NULL;    
    }
    
    //
    // Get rid of what we had.
    //
    {
        // Delete each node in the list of children
        int iSize = m_ResultChildrenList.GetSize();
        for (int j = 0; j < iSize; j++)
        {
            pProvider = (CFaxProviderNode *)
                                    m_ResultChildrenList[j];
            ATLASSERT(pProvider);
            delete pProvider;
            pProvider = NULL;
        }

        // Empty the list
        m_ResultChildrenList.RemoveAll();

        // We no longer have a populated list.
        m_bResultChildrenListPopulated = FALSE;
    }
    
Exit:
    if (NULL != pFaxProvidersConfig)
    {
        FaxFreeBuffer(pFaxProvidersConfig);
    }       
    
    return hRc;
}


/*
 -  CFaxProvidersNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxProvidersNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    //  Refresh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}

/*
 -  CFaxProvidersNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxProvidersNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxProvidersNode::OnRefresh"));
    HRESULT hRc = S_OK;


    //
    // Call the base class
    //
    hRc = CBaseFaxProvidersNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call base class's OnRefresh. (hRc: %08X)"),
			hRc);
        goto Exit;
    }


Exit:
    return hRc;
}

/*
 -  CFaxProvidersNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxProvidersNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}



/*
 -  CFaxProvidersNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxProvidersNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxProvidersNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                    IDS_DISPLAY_STR_PROVIDERSNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

/*
 +
 +  CFaxProvidersNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxProvidersNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_DEVICES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\resutil.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : resutil.cpp                                            //
//                                                                         //
//  DESCRIPTION   : resource utility functions for MMC use.                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun 30 1998 zvib    Init.                                          //
//      Aug 24 1998 adik    Add methods to save and load.                  //
//      Aug 31 1998 adik    Add GetChmFile & OnSnapinHelp.                 //
//      Mar 28 1999 adik    Redefine CColumnsInfo.                         //
//      Apr 27 1999 adik    Help support.                                  //
//      Jun 02 1999 adik    Change the path to comet.chm.                  //
//      Jun 22 1999 adik    Change the path to comet.chm to full path.     //
//                                                                         //
//      Oct 14 1999 yossg   Welcome to Fax								   //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resutil.h"
#include "commctrl.h"
#include <HtmlHelp.h>

#define MAX_COLUMN_LENGTH 300

/*
 -  CColumnsInfo::CColumnsInfo
 -
 *  Purpose:
 *      Constructor
 */

CColumnsInfo::CColumnsInfo()
{
    m_IsInitialized = FALSE;
}

/*
 -  CColumnsInfo::~CColumnsInfo
 -
 *  Purpose:
 *      Destructor
 */

CColumnsInfo::~CColumnsInfo()
{
    int i;

    for (i=0; i < m_Data.GetSize(); i++)
    {
        SysFreeString(m_Data[i].Header);
    }
}

/*
 -  CColumnsInfo::InsertColumnsIntoMMC
 -
 *  Purpose:
 *      Add columns to the default result pane
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - console provided result pane header
 *      [in]    hInst       - resource handle
 *      [in]    aInitData   - columns init data: array of ids & width.
 *                            the last ids must be LAST_IDS.
 *
 *  Return:
 *      S_OK for success
 *      + return value from IHeaderCtrl::InsertColumn
 */
HRESULT
CColumnsInfo::InsertColumnsIntoMMC(IHeaderCtrl *pHeaderCtrl,
                                   HINSTANCE hInst, 
                                   ColumnsInfoInitData aInitData[])
{
     int        i;
     HRESULT    hRc = S_OK;

     DEBUG_FUNCTION_NAME( _T("CColumnsInfo::InsertColumnsIntoMMC"));
     ATLASSERT(pHeaderCtrl);

     //
     // First time init
     //
     if (! m_IsInitialized)
     {
         hRc = Init(hInst, aInitData);
         if ( FAILED(hRc) )
         {
             DebugPrintEx(DEBUG_ERR,_T("Failed to Init. (hRc: %08X)"), hRc);
             goto Cleanup;
         }
     }
     ATLASSERT(m_IsInitialized);

     //
     // Set all columns headers
     //
     for (i=0; i < m_Data.GetSize(); i++ )
     {
         //
         // Insert the column
         //
         hRc = pHeaderCtrl->InsertColumn(i, 
                                         m_Data[i].Header,
                                         LVCFMT_LEFT,
                                         m_Data[i].Width);
         if ( FAILED(hRc) )
         {
             DebugPrintEx(DEBUG_ERR,_T("Failed to InsertColumn. (hRc: %08X)"), hRc);
             goto Cleanup;
         }
     }
Cleanup:
     return hRc;
}

/*
 -  CColumnsInfo::Init
 -
 *  Purpose:
 *      Init the class with columns info
 *
 *  Arguments:
 *      [in]    hInst     - resource handle
 *      [in]    aInitData - columns init data: array of ids & width.
 *                          the last ids must be LAST_IDS.
 *
 *  Return:
 *      S_OK for success
 *      + return value from LoadString
 *      + E_OUTOFMEMORY
 */
HRESULT 
CColumnsInfo::Init(HINSTANCE hInst, ColumnsInfoInitData aInitData[])
{
    WCHAR               buf[MAX_COLUMN_LENGTH];
    ColumnsInfoInitData *pData;
    int                 rc, ind;
    BOOL                fOK;
    HRESULT             hRc = S_OK;
    ColumnData          dummy;
    
    DEBUG_FUNCTION_NAME( _T("CColumnsInfo::Init"));
               
    ATLASSERT(aInitData);
    ATLASSERT(! m_IsInitialized);

    //
    // Insert all column headers
    //
    ZeroMemory(&dummy, sizeof dummy);
    for (pData = &aInitData[0]; pData->ids != LAST_IDS; pData++)
    {
        //
        // Load the string from the resource
        //
        rc = LoadString(hInst, pData->ids , buf, MAX_COLUMN_LENGTH);
        if (rc == 0)
        {
            DWORD dwErr = GetLastError();
            hRc = HRESULT_FROM_WIN32(dwErr);
            DebugPrintEx(DEBUG_ERR,_T("Failed to LoadString. (hRc: %08X)"), hRc);
            goto Cleanup;
        }

        //
        // Duplicates the empty struct into the array
        //
        fOK = m_Data.Add(dummy);
        if (! fOK)
        {
            hRc = E_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR,_T(" m_Data.Add failed. (hRc: %08X)"), hRc);
            goto Cleanup;
        }

        //
        // Set the data
        //
        ind = m_Data.GetSize()-1;
        ATLASSERT(ind >= 0);
        m_Data[ind].Width = pData->Width;
        m_Data[ind].Header = SysAllocString(buf);
        if (! m_Data[ind].Header)
        {
            hRc = E_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR,_T("Failed to SysAllocString. (hRc: %08X)"), hRc);
            goto Cleanup;
        }
    } // endfor

    m_IsInitialized = TRUE;

Cleanup:
    return hRc;
}

/*
 -  GetHelpFile
 -
 *  Purpose:
 *      Get full path to the comet CHM file
 *
 *  Arguments:
 *      [out]   pwszChmFile - fullath of the CHM file
 *
 *  Return:
 *      OLE error code translated from registry open/query error
 */
WCHAR * __cdecl
GetHelpFile()
{
    static  WCHAR szFile[MAX_PATH] = {0};

    DEBUG_FUNCTION_NAME( _T("GetHelpFile"));

    if (szFile[0] == L'\0')
    {
        ExpandEnvironmentStrings(L"%windir%\\help\\FxsAdmin.chm", szFile, MAX_PATH);
    }

    return (szFile[0])? szFile: NULL;
}

/*
 -  OnSnapinHelp
 -
 *  Purpose:
 *      Display Comet.chm help file. This method gets called when the
 *      MMCN_SNAPINHELP Notify message is sent for IComponent object.
 *      MMC sends this message when the user requests help about
 *      the snap-in.
 *
 *  Arguments:
 *      [in]    pConsole - MMC console interface
 *
 *  Return:
 *      Errors returned from GetChmFile
 */
HRESULT __cdecl
OnSnapinHelp(IConsole *pConsole)
{
    WCHAR   *pszChmFile;
    HWND    hWnd = NULL;
    HRESULT hRc = E_FAIL;

    //
    // Get the caller window
    //
    ATLASSERT(pConsole);
    pConsole->GetMainWindow(&hWnd);

    //
    // Get the CHM file name
    //
    pszChmFile = GetHelpFile();

    //
    // Use HtmlHelp API to display the help.
    //
    if ( pszChmFile && *pszChmFile )
    {
        hRc = S_OK;
//        HtmlHelp(hWnd, pszChmFile, HH_DISPLAY_TOPIC,  (DWORD)0);
    }

    return hRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\root.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Root.cpp                                               //
//                                                                         //
//  DESCRIPTION   : Implementation of the Fax extension snapin             //
//                  The snapin root is a hidden node that use to extend    //
//                  comet node.                                            //
//                                                                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg   create                                         //
//      Dec  9 1999 yossg   Call InitDisplayName from parent			   //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "snapin.h"
#include "snpnode.h"

#include "Root.h"

#include "FaxServerNode.h"

#include "Icons.h"
#include "resource.h"


/****************************************************

CSnapinRoot Class

 ****************************************************/
// {89A457D1-FDF9-11d2-898A-00104B3FF735}
static const GUID CSnapinRootGUID_NODETYPE = 
{ 0x89a457d1, 0xfdf9, 0x11d2, { 0x89, 0x8a, 0x0, 0x10, 0x4b, 0x3f, 0xf7, 0x35 } };

const GUID*  CSnapinRoot::m_NODETYPE = &CSnapinRootGUID_NODETYPE;
const OLECHAR* CSnapinRoot::m_SZNODETYPE = OLESTR("89A457D1-FDF9-11d2-898A-00104B3FF735");
const OLECHAR* CSnapinRoot::m_SZDISPLAY_NAME = OLESTR("root");
const CLSID* CSnapinRoot::m_SNAPIN_CLASSID = &CLSID_Snapin;


/*
 -  CSnapinRoot::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create the Fax Server snapin root node
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CSnapinRoot::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CSnapinRoot::PopulateScopeChildrenList()"));
    HRESULT hr = S_OK;

    //
    // Add the Fax Node
    //
    CFaxServerNode  *  pI;

    pI = new CFaxServerNode(this, m_pComponentData, m_bstrServerName.m_str);
    if (pI == NULL)
    {
        hr = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
        goto Cleanup;
    }

    pI->SetIcons(IMAGE_FAX, IMAGE_FAX);
    hr = pI->InitDisplayName();
    if ( FAILED(hr) )
    {
        DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hr);                       
        NodeMsgBox(IDS_FAIL_TO_ADD_NODE);
        delete pI;
        goto Cleanup;
    }

    hr = AddChild(pI, &pI->m_scopeDataItem);
    if ( FAILED(hr) )
    {
        DebugPrintEx(DEBUG_ERR,_T("Failed to AddChild. (hRc: %08X)"), hr);                       
        NodeMsgBox(IDS_FAIL_TO_ADD_NODE);
        delete pI;
        goto Cleanup;
    }

Cleanup:
    return hr;
}


/*
 -  CSnapinRoot::SetServerName
 -
 *  Purpose:
 *      Set the Server machine name
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CSnapinRoot::SetServerName(BSTR bstrServerName)
{
    DEBUG_FUNCTION_NAME( _T("CSnapinRoot::SetServerName"));
    HRESULT hRc = S_OK;

    m_bstrServerName = bstrServerName;
    if (!m_bstrServerName)
    {
        hRc = E_OUTOFMEMORY;
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to allocate string - out of memory"));
        
        NodeMsgBox(IDS_MEMORY);
       
        m_bstrServerName = L"";
    }

    return hRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\root.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Root.h                                                 //
//                                                                         //
//  DESCRIPTION   : Header file for the CSnapinRoot class.                 //
//                  This is the Comet Fax extension root                   //
//                  of Comet snapin                                        //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 16 1998 yossg   first implement for modem pooling              //
//      Jan 12 1999 adik    Add support fot parent array.                  //
//      Mar 30 1999 adik    Supporting ICometSnapinNode.                   //
//                                                                         //
//      Sep 22 1999 yossg   welcome To Fax Server                           //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef ROOT_H_INCLUDED
#define ROOT_H_INCLUDED

#include "snapin.h"
#include "snpnscp.h"

class CSnapinRoot : public CNodeWithScopeChildrenList<CSnapinRoot, TRUE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CSnapinRoot, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CSnapinRoot)
    END_SNAPINTOOLBARID_MAP()

    CSnapinRoot(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CSnapinRoot, TRUE>(pParentNode, pComponentData )
    {
        memset(&m_scopeDataItem,  0, sizeof(SCOPEDATAITEM));
        memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));

        m_bstrServerName       =  L"";
    }

    ~CSnapinRoot()
    {
    }

    //
    // Create the first extention level snapin root nodes
    //
    virtual HRESULT PopulateScopeChildrenList();

    HRESULT SetServerName(BSTR bstrServerName);

//    static const GUID*    m_NODETYPE;
//    static const OLECHAR* m_SZNODETYPE;
//    static const OLECHAR* m_SZDISPLAY_NAME;
//    static const CLSID*   m_SNAPIN_CLASSID;

private:
    //
    // Server Name
    //
    CComBSTR                 m_bstrServerName;

};

#endif // ! ROOT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\snapin.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Snapin.h                                               //
//                                                                         //
//  DESCRIPTION   : Header file for                                        //
//                    includes of comet\inc\c_Snapin.h                     //
//                                                                         //
//  AUTHOR        : ATL Snapin class wizard                                //
//                                                                         //
//  HISTORY       :                                                        //
//      May 25 1998 adik    Init.                                          //
//      Aug 24 1998 adik    Use Comet version.                             //
//      Sep 14 1998 yossg   seperate common source to an included file     //
//                                                                         //
//      Sep 22 1999 yossg   welcome To Fax Server                           //
//																		   //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef SNAPIN_H_INCLUDED
#define SNAPIN_H_INCLUDED

//EXTERN_C const CLSID CLSID_Snapin;
//EXTERN_C const CLSID CLSID_SnapinAbout;

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
#include "C_Snapin.h"
/////////////////////////////////////////////////////////////////////////////


#endif // ! SNAPIN_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\securityinfo.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : SecurityInfo.cpp                                       //
//                                                                         //
//  DESCRIPTION   : The ISecurityInformation implmentation used to         //
//                  instantiate a security page.                           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Feb  7 2000 yossg   Create                                         //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "SecurityInfo.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "MsFxsSnp.h"


//#pragma hdrstop

const GENERIC_MAPPING gc_FaxGenericMapping =
{
        (STANDARD_RIGHTS_READ | FAX_GENERIC_READ),
        (STANDARD_RIGHTS_WRITE | FAX_GENERIC_WRITE),
        (STANDARD_RIGHTS_EXECUTE | FAX_GENERIC_EXECUTE),
        (READ_CONTROL | WRITE_DAC | WRITE_OWNER | FAX_GENERIC_ALL)
};

CFaxSecurityInformation::CFaxSecurityInformation()
{
    DebugPrint(( TEXT("CFaxSecurityInfo Created") ));
}

CFaxSecurityInformation::~CFaxSecurityInformation()
{
    DebugPrint(( TEXT("CFaxSecurityInfo Destroyed") ));    
}

/////////////////////////////////////////////////////////////////////////////
// CFaxSecurityInformation
// *** ISecurityInformation methods implementation ***

/*
 -  CFaxSecurityInformation::GetObjectInformation
 -
 *  Purpose:
 *      Performs an access check against the fax service security descriptor
 *
 *  Arguments:
 *      [in]   pObjectInfo      - pointer to object information structure.
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::GetObjectInformation(
                                             IN OUT PSI_OBJECT_INFO pObjectInfo 
                                             )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::GetObjectInformation"));

    DWORD       ec          = ERROR_SUCCESS;
    
    CFaxServer * pFaxServer = NULL;

    HINSTANCE   hInst;

    HANDLE      hPrivBeforeSE_TAKE_OWNERSHIP = INVALID_HANDLE_VALUE;
    HANDLE      hPrivBeforeSE_SECURITY       = INVALID_HANDLE_VALUE;

    ATLASSERT( pObjectInfo != NULL );
    if( pObjectInfo == NULL ) 
    {
        DebugPrintEx( DEBUG_ERR,
			_T("Invalid parameter - pObjectInfo == NULL"));
        return E_POINTER;
    }

    //
    // Set Flags
    //
    pObjectInfo->dwFlags =  SI_EDIT_ALL       | 
                            SI_NO_TREE_APPLY  | 
                            SI_NO_ACL_PROTECT |
                            SI_ADVANCED;
    


    pFaxServer = m_pFaxServerNode->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Check if to add SI_READONLY 
    //
    if (!FaxAccessCheckEx(
                        pFaxServer->GetFaxServerHandle(),
                        WRITE_DAC, 
                        NULL))
    {
		ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
		    pObjectInfo->dwFlags |= SI_READONLY;
        }
        else 
        {
            DebugPrintEx(
			DEBUG_ERR,
			_T("Fail check access for WRITE_DAC."));
            goto Error;
        }
    }

    //
    // Check if to add SI_OWNER_READONLY 
    //
    hPrivBeforeSE_TAKE_OWNERSHIP = EnablePrivilege (SE_TAKE_OWNERSHIP_NAME);
    //
    // No error checking - If we failed we will get ERROR_ACCESS_DENIED in the access check
    // 
    if (!FaxAccessCheckEx(
                        pFaxServer->GetFaxServerHandle(),
                        WRITE_OWNER, 
                        NULL))
    {
		ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
		    pObjectInfo->dwFlags |= SI_OWNER_READONLY;
        }
        else 
        {
            DebugPrintEx(
			DEBUG_ERR,
			_T("Fail check access for WRITE_OWNER."));
            goto Error;
        }
    }

    //
    // Check if to remove SI_EDIT_AUDITS 
    //
    hPrivBeforeSE_SECURITY = EnablePrivilege (SE_SECURITY_NAME);
    //
    // No error checking - If we failed we will get ERROR_ACCESS_DENIED in the access check
    // 

    if (!FaxAccessCheckEx(
                        pFaxServer->GetFaxServerHandle(),
                        ACCESS_SYSTEM_SECURITY, 
                        NULL))
    {
		ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
		    pObjectInfo->dwFlags &= ~SI_EDIT_AUDITS;
        }
        else 
        {
            DebugPrintEx(
			DEBUG_ERR,
			_T("Fail check access for ACCESS_SYSTEM_SECURITY."));
            goto Error;
        }
    }


    //
    // Set all other fields
    //
    hInst = _Module.GetResourceInstance();
    pObjectInfo->hInstance = hInst;
    
    m_bstrServerName = m_pFaxServerNode->GetServerName();
    if ( 0 == m_bstrServerName.Length() )
    {
        pObjectInfo->pszServerName = NULL;
		DebugPrintEx( DEBUG_MSG, 
            _T("NULL ServerName ie: Local machine."));
    }
    else
    {
        pObjectInfo->pszServerName = m_bstrServerName;
		DebugPrintEx( DEBUG_MSG, 
            _T("ServerName is: %s."), 
            pObjectInfo->pszServerName);
    }
    
    if (!m_bstrObjectName.LoadString(IDS_SECURITY_CAT_NODE_DESC))
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory. Failed to load string."));
        goto Error;
    }
    pObjectInfo->pszObjectName = m_bstrObjectName;

    ATLASSERT ( ERROR_SUCCESS == ec );
    ReleasePrivilege (hPrivBeforeSE_SECURITY);
    ReleasePrivilege (hPrivBeforeSE_TAKE_OWNERSHIP);
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    ReleasePrivilege (hPrivBeforeSE_SECURITY);
    ReleasePrivilege (hPrivBeforeSE_TAKE_OWNERSHIP);
    return HRESULT_FROM_WIN32(ec);

Exit:
    return S_OK;
}

/*
 -  CFaxSecurityInformation::GetSecurity
 -
 *  Purpose:
 *      requests a security descriptor for the securable object whose 
 *      security descriptor is being edited. The access control editor 
 *      calls this method to retrieve the object's current or default security descriptor.
 *
 *  Arguments:
 *      [in]   RequestedInformation  - security information.
 *      [out]  ppSecurityDescriptor  - pointer to security descriptor.
 *      [in]   fDefault              - not implemented
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::GetSecurity(
                                    IN SECURITY_INFORMATION RequestedInformation,
                                    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                                    IN BOOL fDefault 
                                    )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::GetSecurity"));
    HRESULT hRc = S_OK;
    CFaxServer *         pFaxServer     = NULL;
	PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD                ec             = ERROR_SUCCESS;
    BOOL                 bResult;
    HANDLE      hPrivBeforeSE_SECURITY       = INVALID_HANDLE_VALUE;


    ATLASSERT( ppSecurityDescriptor);
	   
    if( fDefault == TRUE ) 
    {
        DebugPrintEx( DEBUG_MSG,
			_T("Non implemeted feature -> fDefault == TRUE"));
        return E_NOTIMPL;
    }  

	if (RequestedInformation & SACL_SECURITY_INFORMATION)
	{
		hPrivBeforeSE_SECURITY = EnablePrivilege (SE_SECURITY_NAME);    
	}

    pFaxServer = m_pFaxServerNode->GetFaxServer();
    ATLASSERT(pFaxServer);

	if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        
        hRc = HRESULT_FROM_WIN32(ec);
        goto Exit;
    }

	//
    // Get the current relative descriptor from the fax server
    //
    bResult = FaxGetSecurityEx( pFaxServer->GetFaxServerHandle(), 
                                RequestedInformation,
                                &pSecurityDescriptor);
    if( bResult == FALSE ) 
    {
        ec = GetLastError();
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. Failed to set security info.(ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }
        else
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed while call to FaxGetSecurityEx. (ec: %ld)"), 
			    ec);
        }
        hRc = HRESULT_FROM_WIN32(ec);
        goto Exit;
    }

	//
    // return a self relative descriptor copy allocated with LocalAlloc()
    //
	hRc = MakeSelfRelativeCopy( pSecurityDescriptor, ppSecurityDescriptor );
    if( FAILED( hRc ) ) 
    {
        DebugPrintEx( 
            DEBUG_ERR,
			_T("MakeSelfRelativeCopy Failed. (hRc : %08X)"),
            hRc);
        goto Exit;
    }    
    
    ATLASSERT(S_OK == hRc);
    

Exit:
	if (NULL != pSecurityDescriptor)
	{
		FaxFreeBuffer(pSecurityDescriptor);
	}
	ReleasePrivilege (hPrivBeforeSE_SECURITY);
    return hRc;
}

/*
 -  CFaxSecurityInformation::SetSecurity
 -
 *  Purpose:
 *      Provides a security descriptor containing the security information 
 *      the user wants to apply to the securable object. The access control 
 *      editor calls this method when the user clicks the Okay or Apply buttons.
 *
 *  Arguments:
 *      [in]   SecurityInformation - security information structure.
 *      [in]   pSecurityDescriptor - pointer to security descriptor.
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::SetSecurity(
                                    IN SECURITY_INFORMATION SecurityInformation,
                                    IN PSECURITY_DESCRIPTOR pSecurityDescriptor 
                                    )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::SetSecurity"));
    HRESULT              hRc            = S_OK;
    DWORD                ec             = ERROR_SUCCESS;
    BOOL                 bResult;

    HINSTANCE            hInst = _Module.GetResourceInstance();
    PSECURITY_DESCRIPTOR psdSelfRelativeCopy = NULL;
    
    CFaxServer *         pFaxServer     = NULL;

	HANDLE      hPrivBeforeSE_TAKE_OWNERSHIP = INVALID_HANDLE_VALUE;
    HANDLE      hPrivBeforeSE_SECURITY       = INVALID_HANDLE_VALUE;
 
    ATLASSERT( NULL != pSecurityDescriptor ); 
    ATLASSERT( IsValidSecurityDescriptor( pSecurityDescriptor ) );     
	
	//
    // Prepare self relative descriptor
    //
	hRc = MakeSelfRelativeCopy( pSecurityDescriptor, &psdSelfRelativeCopy );
    if( FAILED( hRc ) ) 
    {
        DebugPrintEx( 
            DEBUG_ERR,
			_T("MakeSelfRelativeCopy Failed. (hRc : %08X)"),
            hRc);
        goto Exit;
    }

	if (SecurityInformation & OWNER_SECURITY_INFORMATION)
	{
		hPrivBeforeSE_TAKE_OWNERSHIP = EnablePrivilege (SE_TAKE_OWNERSHIP_NAME);    
	}

	if (SecurityInformation & SACL_SECURITY_INFORMATION)
	{
		hPrivBeforeSE_SECURITY = EnablePrivilege (SE_SECURITY_NAME);
	}
	
    pFaxServer = m_pFaxServerNode->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        
        hRc = HRESULT_FROM_WIN32(ec);
        goto Exit;
    }

    //
    // save the new relative descriptor to the fax server
    //
    bResult = FaxSetSecurity( pFaxServer->GetFaxServerHandle(), 
                              SecurityInformation,
                              psdSelfRelativeCopy);
    if( bResult == FALSE ) 
    {
        ec = GetLastError();
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. Failed to set security info.(ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }
        else
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed while call to FaxSetSecurity. (ec: %ld)"), 
			    ec);
        }
        hRc = HRESULT_FROM_WIN32(ec);
        goto Exit;
    }

    ATLASSERT( S_OK == hRc || E_ACCESSDENIED == hRc);	

Exit:
    if (NULL != psdSelfRelativeCopy)
	{
		::LocalFree(psdSelfRelativeCopy);
		psdSelfRelativeCopy = NULL;
	}

	ReleasePrivilege (hPrivBeforeSE_SECURITY);
    ReleasePrivilege (hPrivBeforeSE_TAKE_OWNERSHIP);

		
	return hRc;
}

/*
 -  CFaxSecurityInformation::GetAccessRights
 -
 *  Purpose:
 *      Requests information about the access rights that can be 
 *      controlled for a securable object. The access control 
 *      editor calls this method to retrieve display strings and 
 *      other information used to initialize the property pages.
 *
 *  Arguments:
 *      [in] pguidObjectType  - Pointer to a GUID structure that 
 *                              identifies the type of object for which 
 *                              access rights are being requested. 
 *      [in] dwFlags -          A set of bit flags that indicate the property
 *                              page being initialized
 *      [out] ppAccess -        Pointer to a variable that you should 
 *                              set to a pointer to an array of SI_ACCESS 
 *                              structures. 
 *      [out] pcAccesses -      Pointer to a variable that you should set 
 *                              to indicate the number of entries in the ppAccess array. 
 *      [out] piDefaultAccess - Pointer to a variable that you should set 
 *                              to indicate the zero-based index of the array entry that contains 
 *                              the default access rights. 
 *                              The access control editor uses this entry as the initial access rights in a new ACE. 
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::GetAccessRights(
                                        IN const GUID* pguidObjectType,
                                        IN DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                        OUT PSI_ACCESS *ppAccess,
                                        OUT ULONG *pcAccesses,
                                        OUT ULONG *piDefaultAccess 
                                        )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::GetAccessRights"));
	ATLASSERT( ppAccess );
    ATLASSERT( pcAccesses );
    ATLASSERT( piDefaultAccess );
	
	//
    // Access rights for the Advanced security page
    //
	static SI_ACCESS siFaxAccesses[] =
	{
		// 0 submit permission
		{   
			&GUID_NULL, 
			FAX_ACCESS_SUBMIT ,
			MAKEINTRESOURCE(IDS_FAXSEC_SUB_LOW),
			SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
		},
		// 1 submit normal permission
		{   
			&GUID_NULL, 
			FAX_ACCESS_SUBMIT_NORMAL ,
			MAKEINTRESOURCE(IDS_FAXSEC_SUB_NORMAL),
			SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
		},
		// 2 submit high permission
		{   
			&GUID_NULL, 
			FAX_ACCESS_SUBMIT_HIGH ,
			MAKEINTRESOURCE(IDS_FAXSEC_SUB_HIGH),
			SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
		},
		// 3 query jobs 
		{   
			&GUID_NULL, 
			FAX_ACCESS_QUERY_JOBS,
			MAKEINTRESOURCE(IDS_FAXSEC_JOB_QRY),    
			SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
		},
		// 4 Manage jobs
		{   
			&GUID_NULL, 
			FAX_ACCESS_MANAGE_JOBS,
			MAKEINTRESOURCE(IDS_FAXSEC_JOB_MNG),
			SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
		},
		// 5 query configuration
		{   
			&GUID_NULL, 
			FAX_ACCESS_QUERY_CONFIG,
			MAKEINTRESOURCE(IDS_FAXSEC_CONFIG_QRY),    
			SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
		},
		// 6 Manage configuration
		{   
			&GUID_NULL, 
			FAX_ACCESS_MANAGE_CONFIG,
			MAKEINTRESOURCE(IDS_FAXSEC_CONFIG_SET),
			SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
		},    
		// 7 Query incoming faxes archive
		{   
			&GUID_NULL, 
			FAX_ACCESS_QUERY_IN_ARCHIVE,
			MAKEINTRESOURCE(IDS_FAXSEC_QRY_IN_ARCH),    
			SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
		},
		// 8 Manage incoming faxes archive
		{   
			&GUID_NULL, 
			FAX_ACCESS_MANAGE_IN_ARCHIVE,
			MAKEINTRESOURCE(IDS_FAXSEC_MNG_IN_ARCH),    
			SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
		},
		// 9 Query outgoing faxes archive
		{   
			&GUID_NULL, 
			FAX_ACCESS_QUERY_OUT_ARCHIVE,
			MAKEINTRESOURCE(IDS_FAXSEC_QRY_OUT_ARCH),    
			SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
		},
		// 10 Manage outgoing faxes archive
		{   
			&GUID_NULL, 
			FAX_ACCESS_MANAGE_OUT_ARCHIVE,
			MAKEINTRESOURCE(IDS_FAXSEC_MNG_OUT_ARCH),    
			SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
		},
		// specific permissions
		// 11 Read permission
		{   
			&GUID_NULL, 
			READ_CONTROL,
			MAKEINTRESOURCE(IDS_FAXSEC_READ_PERM),
			SI_ACCESS_SPECIFIC 
		},
		// 12 Change Permissions
		{   
			&GUID_NULL, 
			WRITE_DAC,
			MAKEINTRESOURCE(IDS_FAXSEC_CHNG_PERM),
			SI_ACCESS_SPECIFIC 
		},
		// 13 Take ownership
		{   
			&GUID_NULL, 
			WRITE_OWNER,
			MAKEINTRESOURCE(IDS_FAXSEC_CHNG_OWNER),
			SI_ACCESS_SPECIFIC
		}
	};

	//
    // Access rights for the Basic security page
    //
	static SI_ACCESS siFaxBasicAccess[] =
    {
        // 0 Fax
        {   
            &GUID_NULL, 
            FAX_ACCESS_SUBMIT_NORMAL | FAX_ACCESS_SUBMIT,
            MAKEINTRESOURCE(IDS_RIGHT_FAX),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 1 Manage fax configuration
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_CONFIG | FAX_ACCESS_QUERY_CONFIG,
            MAKEINTRESOURCE(IDS_RIGHT_MNG_CFG),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 2 Manage fax documents
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_JOBS			| FAX_ACCESS_QUERY_JOBS			|
            FAX_ACCESS_MANAGE_IN_ARCHIVE	| FAX_ACCESS_QUERY_IN_ARCHIVE	|
            FAX_ACCESS_MANAGE_OUT_ARCHIVE	| FAX_ACCESS_QUERY_OUT_ARCHIVE,
            MAKEINTRESOURCE(IDS_RIGHT_MNG_DOC),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        }
    };

    *ppAccess        = (0 == dwFlags) ? siFaxBasicAccess : siFaxAccesses;   
    *pcAccesses      = ULONG((0 == dwFlags) ? ARR_SIZE(siFaxBasicAccess) : ARR_SIZE(siFaxAccesses));    
    *piDefaultAccess = (0 == dwFlags) ? 0 : 1;

    return S_OK;
}

/*
 -  CFaxSecurityInformation::MapGeneric
 -
 *  Purpose:
 *      Requests that the generic access rights in an access mask 
 *      be mapped to their corresponding standard and specific access rights.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::MapGeneric(
                                   IN const GUID *pguidObjectType,
                                   IN UCHAR *pAceFlags,
                                   IN OUT ACCESS_MASK *pMask
                                   )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::MapGeneric"));

    MapGenericMask( pMask, const_cast<PGENERIC_MAPPING>(&gc_FaxGenericMapping) );

    return S_OK;
}


/*
 -  CFaxSecurityInformation::GetInheritTypes
 -
 *  Purpose:
 *      Not implemented. 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::GetInheritTypes(
                                        OUT PSI_INHERIT_TYPE *ppInheritTypes,
                                        OUT ULONG *pcInheritTypes 
                                        )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::GetInheritTypes  --- Not implemented"));
    return E_NOTIMPL;
}

/*
 -  CFaxSecurityInformation::PropertySheetPageCallback
 -
 *  Purpose:
 *      Notifies an EditSecurity or CreateSecurityPage caller 
 *      that an access control editor property page is being created or destroyed. 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::PropertySheetPageCallback(
                                                  IN HWND hwnd, 
                                                  IN UINT uMsg, 
                                                  IN SI_PAGE_TYPE uPage 
                                                  )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::PropertySheetPageCallback"));	
    return S_OK;
}



/*
 -  CFaxSecurityInformation::MakeSelfRelativeCopy
 -
 *  Purpose:
 *      This pravite method copies Security descriptors 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxSecurityInformation::MakeSelfRelativeCopy(
                                                     PSECURITY_DESCRIPTOR  psdOriginal,
                                                     PSECURITY_DESCRIPTOR* ppsdNew 
                                                     )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::MakeSelfRelativeCopy"));
    ATLASSERT( NULL != psdOriginal );

    // we have to find out whether the original is already self-relative
    SECURITY_DESCRIPTOR_CONTROL         sdc                 = 0;
    PSECURITY_DESCRIPTOR                psdSelfRelativeCopy = NULL;
    DWORD                               dwRevision          = 0;
    DWORD                               cb                  = 0;

    ATLASSERT( IsValidSecurityDescriptor( psdOriginal ) ); 

    if( !::GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) ) 
    {
        DWORD err = ::GetLastError();
                    DebugPrintEx( DEBUG_ERR,
			            _T("Invalid security descriptor."));

        return HRESULT_FROM_WIN32( err );
    }

    if( sdc & SE_SELF_RELATIVE )
	{
        // the original is in self-relative format, just byte-copy it

        // get size
        cb = ::GetSecurityDescriptorLength( psdOriginal );

        // alloc the memory
        psdSelfRelativeCopy = (PSECURITY_DESCRIPTOR) ::LocalAlloc( LMEM_ZEROINIT, cb );
        if(NULL == psdSelfRelativeCopy) 
        {
	        DebugPrintEx(
		        DEBUG_ERR,
		        TEXT("Out of memory."));
            //GetRootNode()->NodeMsgBox(IDS_MEMORY);
            return E_OUTOFMEMORY;
        }

        // make the copy
        ::memcpy( psdSelfRelativeCopy, psdOriginal, cb );
    } 
    else 
    {
        // the original is in absolute format, convert-copy it

        // get new size - it will fail and set cb to the correct buffer size
        ::MakeSelfRelativeSD( psdOriginal, NULL, &cb );

        // alloc the new amount of memory
        psdSelfRelativeCopy = (PSECURITY_DESCRIPTOR) ::LocalAlloc( LMEM_ZEROINIT, cb );
        if(NULL == psdSelfRelativeCopy) 
        {
	        DebugPrintEx(
		        DEBUG_ERR,
		        TEXT("Out of memory."));
            //GetRootNode()->NodeMsgBox(IDS_MEMORY);
            return E_OUTOFMEMORY; // just in case the exception is ignored
        }

        if( !::MakeSelfRelativeSD( psdOriginal, psdSelfRelativeCopy, &cb ) ) 
        {
	        DebugPrintEx(
		        DEBUG_ERR,
		        _T("::MakeSelfRelativeSD returned NULL"));

            if( NULL == ::LocalFree( psdSelfRelativeCopy ) ) 
            {
                DWORD err = ::GetLastError();
                return HRESULT_FROM_WIN32( err );
            }
            psdSelfRelativeCopy = NULL;
        }
    }

    *ppsdNew = psdSelfRelativeCopy;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\securityinfo.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : SecurityInfo.cpp                                       //
//                                                                         //
//  DESCRIPTION   : The header file of the ISecurityInformation interface  //
//                  used to instantiate a security page.                   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //                                                                         //
//  HISTORY       :                                                        //
//      Feb  7 2000 yossg   Create                                         //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __FAX_SECURITY_INFO_H_
#define __FAX_SECURITY_INFO_H_

//#include <atlcom.h>
#include "MsFxsSnp.h"
#include <aclui.h>              // ACL UI editor

class CFaxServerNode; // forward decl

class ATL_NO_VTABLE CFaxSecurityInformation : 
    public CComObjectRootEx<CComSingleThreadModel>,
    //public CComCoClass<CFaxSecurityInformation, &CLSID_FaxSecurityInformation>,
    public ISecurityInformation 
{
public:
    CFaxSecurityInformation::CFaxSecurityInformation();
    CFaxSecurityInformation::~CFaxSecurityInformation();
	void Init(CFaxServerNode * pFaxServerNode)
	{
		ATLASSERT(pFaxServerNode);
		m_pFaxServerNode = pFaxServerNode;
	}

    DECLARE_NOT_AGGREGATABLE(CFaxSecurityInformation)

    BEGIN_COM_MAP(CFaxSecurityInformation)
      //COM_INTERFACE_ENTRY(ISecurityInformation)
      COM_INTERFACE_ENTRY_IID(IID_ISecurityInformation,ISecurityInformation)
    END_COM_MAP()

    public:    
    // *** ISecurityInformation methods ***
    virtual HRESULT STDMETHODCALLTYPE GetObjectInformation(
                                                   OUT PSI_OBJECT_INFO pObjectInfo );

    virtual HRESULT STDMETHODCALLTYPE GetSecurity(
                                                   IN SECURITY_INFORMATION RequestedInformation,
                                                   OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                                                   IN BOOL fDefault );

    virtual HRESULT STDMETHODCALLTYPE SetSecurity(
                                                   IN SECURITY_INFORMATION SecurityInformation,
                                                   IN PSECURITY_DESCRIPTOR pSecurityDescriptor );

    virtual HRESULT STDMETHODCALLTYPE GetAccessRights(
                                                   IN const GUID* pguidObjectType,
                                                   IN DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                                   OUT PSI_ACCESS *ppAccess,
                                                   OUT ULONG *pcAccesses,
                                                   OUT ULONG *piDefaultAccess );

    virtual HRESULT STDMETHODCALLTYPE MapGeneric(
                                                   IN const GUID *pguidObjectType,
                                                   IN UCHAR *pAceFlags,
                                                   IN OUT ACCESS_MASK *pMask);

    virtual HRESULT STDMETHODCALLTYPE PropertySheetPageCallback(
                                                   IN HWND hwnd, 
                                                   IN UINT uMsg, 
                                                   IN SI_PAGE_TYPE uPage );

    // no need to implement 
    virtual HRESULT STDMETHODCALLTYPE GetInheritTypes(
                                                   OUT PSI_INHERIT_TYPE *ppInheritTypes,
                                                   OUT ULONG *pcInheritTypes );

    // internal methods
	HRESULT MakeSelfRelativeCopy(
                                PSECURITY_DESCRIPTOR  psdOriginal,
                                PSECURITY_DESCRIPTOR* ppsdNew 
                                );

private:
	CFaxServerNode *		m_pFaxServerNode;

    CComBSTR    m_bstrServerName; // Computer on which to look up account names and SIDs.
    CComBSTR    m_bstrObjectName; // This name appears in the title of the advanced security property sheet.
};

#endif //__FAX_SECURITY_INFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\snpnode.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    snpnode.h

Abstract:

    Header for the CSnapinNode class.

    This is our virtual base class for an MMC Snap-in node.

    As this is a template class and is all implemented inline,
    there is no SnapinNode.cpp for implementation.


Author:

    Original: Michael A. Maguire
    Modifications: RaphiR

Changes:
    Specific MSMQ support:
        Default images
        Default columns
    Support for Extension snapins
    Add a CComponentData pointer
    SetIcons method
    Move m_pParentNode to CSnapinItem

    zvib - Add RefreshSingleResultItem

    Jun 10 1999 adik    Change bitmap mask to white.
    Jun 14 1999 roytal  used UNREFERENCED_PARAMETER to fix build wrn
    Jun 24 1999 adik    Handle MMCN_COLUMNS_CHANGED
    Jun 30 1999 adik    More detailed DPF in CSnapinNode::Notify

//                                                                         //
//      Sep 22 1999 yossg   welcome To Fax Server                           //
//      Oct 11 1999 yossg   replace DPF with fax's DebugPrintfEx           //
--*/
/////////////////////////////////////////////////////////////////////////////

#if !defined(_SNAPIN_NODE_H_)
#define _SNAPIN_NODE_H_

#include <dlgutils.h>
class CSnapin;



class CSnapinItemEx
{

protected:
	
		CSnapinItemEx * m_pParentNodeEx;
public:

	CSnapinItemEx(CSnapinItemEx * pParent)
	{
		m_pParentNodeEx = (CSnapinItemEx *)pParent;
	}
	CSnapinItemEx * GetRootNode()
	{
		if (m_pParentNodeEx)
		{
			return m_pParentNodeEx->GetRootNode();
		}
		else
		{
			return this;
		}
	}
	virtual void dummy(){}; // To support dynamic_cast

	CSnapinItemEx  * GetParent()
	{
		return m_pParentNodeEx;
	}
};



template <class T, BOOL bIsExtension>
class CSnapinNode : public CSnapInItemImpl< T, bIsExtension>,
					public CSnapinItemEx
{
protected:
    // Constructor/Destructor
    CSnapinNode(CSnapInItem *pParentNode, CSnapin *pComponentData);
    ~CSnapinNode();

public:
    // For IDataObject handling.
    IDataObject* m_pDataObject;
    void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault);

    //
    // Change the default icon id
    //
    void SetIcons(DWORD idStandard, DWORD idOpen);

    // Clipboard formats which IDataObjects on all MMC nodes must support.
    static const GUID* m_NODETYPE;
    static const TCHAR* m_SZNODETYPE;
    static const TCHAR* m_SZDISPLAY_NAME;
    static const CLSID* m_SNAPIN_CLASSID;

    // Pointer to parent node.  This is passed in the call to our
    // constructor.  Needed so that a node can access its parent.
    // For example, when we receive the MMCN_DELETE notification, we might tell
    // our parent node to remove us from its list of children.
    // The member is initialize in the constructor of CSnapinNode
    CSnapInItem * m_pParentNode;

    //
    // Pointer to the component data. Allow us to
    // access Snapin global data
    //
    CSnapin *     m_pComponentData;

    HRESULT NodeMsgBox(int ids, UINT fuStyle = MB_OK | MB_ICONERROR, int *piRetval = NULL, BOOL StringFromCommonDll = FALSE);
    HRESULT RefreshSingleResultItem(CSnapInObjectRootBase *pRoot);
    HRESULT RefreshSingleResultItem(IConsole *spConsole);
    HRESULT RefreshSingleResultItem(IComponentData *pComponentData, IComponent * pComponent);

public:
    // Standard MMC functionality -- override if you need to.
    STDMETHOD(CreatePropertyPages)(
          LPPROPERTYSHEETCALLBACK lpProvider
        , LONG_PTR handle
        , IUnknown* pUnk
        , DATA_OBJECT_TYPES type
        );
    STDMETHOD(QueryPagesFor)( DATA_OBJECT_TYPES type );
    void* GetDisplayName();
    STDMETHOD(GetScopePaneInfo)( SCOPEDATAITEM *pScopeDataItem );
    STDMETHOD(GetResultPaneInfo)( RESULTDATAITEM *pResultDataItem );
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );


    // Notify method will call notification handlers below -- shouldn't need to override.
    STDMETHOD( Notify ) (
              MMC_NOTIFY_TYPE event
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );


    // Notification handlers -- override when you want to intercept.
    virtual HRESULT OnActivate(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnAddImages(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnButtonClick(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnClick(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnContextHelp(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnShowContextHelp(
                  IDisplayHelp* pDisplayHelp
                , LPOLESTR helpFile);
    virtual HRESULT OnContextMenu(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnDoubleClick(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnDelete(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                , BOOL fSilent = FALSE
                );
    virtual HRESULT OnExpand(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnHelp(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnMenuButtonClick(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnMinimized(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnPaste(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnPropertyChange(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnQueryPaste(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnRefresh(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnRemoveChildren(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnRename(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnSelect(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnShow(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnViewChange(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnColumnsChanged(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );


    // Special notification handler -- saves off the currently selected node.
    HRESULT PreOnShow(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );



    // Taskpad functionality.
    STDMETHOD(TaskNotify)(
                  IDataObject * pDataObject
                , VARIANT * pvarg
                , VARIANT * pvparam
                );
    STDMETHOD(EnumTasks)(
                  IDataObject * pDataObject
                , BSTR szTaskGroup
                , IEnumTASK** ppEnumTASK
                );
};




//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:SetIcons

    Specify the Open and Close icons of the snapin node

Remarks:


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
void CSnapinNode<T, bIsExtension>::SetIcons(DWORD idStandard, DWORD idOpen)
{
    m_scopeDataItem.nImage = idStandard;
    m_scopeDataItem.nOpenImage = idOpen;

    m_resultDataItem.nImage = idStandard;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:CreatePropertyPages

Adds pages to a property sheet.


HRESULT CreatePropertyPages(
  LPPROPERTYSHEETCALLBACK lpProvider,
                              // Pointer to the callback interface
  long handle,                // Handle for routing notification
  LPDATAOBJECT lpIDataObject  // Pointer to the data object
);


Remarks:


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::CreatePropertyPages(
      LPPROPERTYSHEETCALLBACK lpProvider
    , LONG_PTR handle
    , IUnknown* pUnk
    , DATA_OBJECT_TYPES type
    )
{
    DEBUG_FUNCTION_NAME(TEXT("CreatePropertyPages"));

    UNREFERENCED_PARAMETER (lpProvider);
    UNREFERENCED_PARAMETER (handle);
    UNREFERENCED_PARAMETER (pUnk);
    UNREFERENCED_PARAMETER (type);

    DebugPrintEx(DEBUG_MSG,
        _T("CSnapinNode::CreatePropertyPages -- override in your derived class"));

    return E_NOTIMPL;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:QueryPagesFor

Determines whether the object requires pages.


HRESULT QueryPagesFor(  DATA_OBJECT_TYPES type  );


Parameters

    void


Return Value

    S_OK
    Properties exist for this cookie.

    E_UNEXPECTED
    An unexpected error occurred.

    E_INVALID
    The parameter is invalid.

    ISSUE: So what do we return if an item doesn't have property pages?
        S_FALSE is used in sburns' localsec code

Remarks

    The console calls this method to determine whether the Properties menu
    item should be added to the context menu.


  Override this in your derived class, if your object supports menu

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::QueryPagesFor( DATA_OBJECT_TYPES type )
{
    DEBUG_FUNCTION_NAME(TEXT("QueryPagesFor"));
	
	UNREFERENCED_PARAMETER (type);

    DebugPrintEx(DEBUG_MSG,
        _T("CSnapinNode::QueryPagesFor -- override in your derived class if you have property pages"));

    // this method should be overriden and should return S_OK if you
    // have property pages for this node otherwise it should return S_FALSE.

    return S_FALSE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:InitDataClass

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
void CSnapinNode<T, bIsExtension>::InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
{
    UNREFERENCED_PARAMETER (pDefault);

    // The default code stores off the pointer to the Dataobject the class is wrapping
    // at the time.
    // Alternatively you could convert the dataobject to the internal format
    // it represents and store that information

    m_pDataObject = pDataObject;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetDisplayName

ISSUE: what are the parameters to this function?  Why not void?

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
void* CSnapinNode<T, bIsExtension>::GetDisplayName()
{
    DEBUG_FUNCTION_NAME( 
		_T("CSnapinNode::GetDisplayName"));

//      ISSUE: It looks as thought the m_SZDISPLAY_NAME is a totally
//      bogus variable -- we should think about eliminating it
//      Problematic -- const m_SZDISPLAY_NAME can't be localized
//      return (void*)m_SZDISPLAY_NAME;

    return (void*)m_bstrDisplayName;
}

//  void* GetSnapInCLSID()
//  {
//      DPF(5, DBG_MMC,(_T("CSnapinNode::GetSnapInCLSID"));
//
//      return (void*)m_SNAPIN_CLASSID;
//  }



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetScopePaneInfo


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::GetScopePaneInfo( SCOPEDATAITEM *pScopeDataItem )
{
//    DEBUG_FUNCTION_NAME( _T("CSnapinNode::GetScopePaneInfo"));

    if (pScopeDataItem->mask & SDI_STR)
        pScopeDataItem->displayname = m_bstrDisplayName;
    if (pScopeDataItem->mask & SDI_IMAGE)
        pScopeDataItem->nImage = m_scopeDataItem.nImage;
    if (pScopeDataItem->mask & SDI_OPENIMAGE)
        pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
    if (pScopeDataItem->mask & SDI_PARAM)
        pScopeDataItem->lParam = m_scopeDataItem.lParam;
    if (pScopeDataItem->mask & SDI_STATE )
        pScopeDataItem->nState = m_scopeDataItem.nState;

    // TODO : Add code for SDI_CHILDREN
    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetResultPaneInfo


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::GetResultPaneInfo( RESULTDATAITEM *pResultDataItem )
{
    DEBUG_FUNCTION_NAME( _T("CSnapinNode::GetResultPaneInfo"));

    if (pResultDataItem->bScopeItem)
    {
        if (pResultDataItem->mask & RDI_STR)
        {
            pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
        }
        if (pResultDataItem->mask & RDI_IMAGE)
        {
            pResultDataItem->nImage = m_scopeDataItem.nImage;
        }
        if (pResultDataItem->mask & RDI_PARAM)
        {
            pResultDataItem->lParam = m_scopeDataItem.lParam;
        }

        return S_OK;
    }

    if (pResultDataItem->mask & RDI_STR)
    {
        pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
    }
    if (pResultDataItem->mask & RDI_IMAGE)
    {
        pResultDataItem->nImage = m_resultDataItem.nImage;
    }
    if (pResultDataItem->mask & RDI_PARAM)
    {
        pResultDataItem->lParam = m_resultDataItem.lParam;
    }
    if (pResultDataItem->mask & RDI_INDEX)
    {
        pResultDataItem->nIndex = m_resultDataItem.nIndex;
    }

    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::Notify


This method is this node's response to the MMC calling Notify on
IComponent or IComponentData.


STDMETHOD( Notify ) (
          MMC_NOTIFY_TYPE event
        , LPARAM arg
        , LPARAM param
        , IComponentData * pComponentData
        , IComponent * pComponent
        , DATA_OBJECT_TYPES type


        )


Parameters

    event
    [in] Identifies an action taken by a user. IComponent::Notify and
    IComponentData::Notify can receive the following notifications for a
    specific node:

        MMCN_ACTIVATE
        MMCN_ADD_IMAGES
        MMCN_BTN_CLICK
        MMCN_CLICK
        MMCN_CONTEXTMENU
        MMCN_DBLCLICK
        MMCN_DELETE
        MMCN_EXPAND
        MMCN_HELP
        MMCN_MENU_BTNCLICK
        MMCN_MINIMIZED
        MMCN_PROPERTY_CHANGE
        MMCN_REFRESH
        MMCN_REMOVE_CHILDREN
        MMCN_RENAME
        MMCN_SELECT
        MMCN_SHOW
        MMCN_VIEW_CHANGE
        MMCN_CONTEXTHELP

    See CSnapinNode::OnActivate, OnAddImages, OnButtonClick, etc. for
    a detailed explanation of each of these notify events

    arg
    Depends on the notification type.

    param
    Depends on the notification type.


Return Values

    S_OK
    Depends on the notification type.

    E_UNEXPECTED
    An unexpected error occurred.


Remarks

    Our IComponentData and IComponent implementations were passed a LPDATAOBJECT
    which corresponds to a node.  This was converted to a pointer to
    a node object.  Below is the Notify method on this node object, were
    the node object can deal with the Notify event itself.

    Our implementation of Notify is a large switch statement which delegates the
    task of dealing with virtual OnXxxxxx methods which can overridden in
    derived classes.  As all events are dealt with this way here, you shouldn't
    need to implement a Notify method for any of your derived nodes.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>:: Notify (
          MMC_NOTIFY_TYPE event
        , LPARAM arg
        , LPARAM param
        , IComponentData * pComponentData
        , IComponent * pComponent
        , DATA_OBJECT_TYPES type
        )
{
    DEBUG_FUNCTION_NAME(TEXT("CSnapinNode<..>:: Notify"));

    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (type);
        
	DebugPrintEx(DEBUG_MSG,
        _T("CSnapinNode::Notify, event=0x%X, pComponentData=0x%X, pComponent=0x%X"), 
        event, pComponentData, pComponent);

    HRESULT hr = S_FALSE;

    // this makes for faster code.
    T* pT = static_cast<T*> (this);

    switch( event )
    {

    case MMCN_ACTIVATE:
        hr = pT->OnActivate( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_ADD_IMAGES:
        hr = pT->OnAddImages( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_BTN_CLICK:
        hr = pT->OnButtonClick( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_CLICK:
        hr = pT->OnClick( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_CONTEXTHELP:
        hr = pT->OnContextHelp( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_CONTEXTMENU:
        hr = pT->OnContextMenu( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_CUTORMOVE:
        hr = pT->OnDelete( arg, param, pComponentData, pComponent, type, TRUE );
        break;

    case MMCN_DBLCLICK:
        hr = pT->OnDoubleClick( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_DELETE:
        hr = pT->OnDelete( arg, param, pComponentData, pComponent, type, FALSE );
        break;

    case MMCN_EXPAND:
        hr = pT->OnExpand( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_HELP:
        hr = pT->OnHelp( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_MENU_BTNCLICK:
        hr = pT->OnMenuButtonClick( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_MINIMIZED:
        hr = pT->OnMinimized( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_PASTE:
        hr = pT->OnPaste( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_PROPERTY_CHANGE:
		DebugPrintEx(DEBUG_MSG,_T("+++ MMCN_PROPERTY_CHANGE +++ \n"));
        hr = pT->OnPropertyChange( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_QUERY_PASTE:
        hr = pT->OnQueryPaste( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_REFRESH:
        hr = pT->OnRefresh( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_REMOVE_CHILDREN:
        hr = pT->OnRemoveChildren( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_RENAME:
        hr = pT->OnRename( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_SELECT:
        // For nodes with result-pane children
        hr = pT->OnSelect( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_SHOW:
        // For nodes with result-pane children
        // We call PreOnShow which will then call OnShow.
        // PreOnShow will save away the selected node in a member variable
        // of out CComponent class.
        //hr = pT->PreOnShow( arg, param, pComponentData, pComponent, type );
        hr = pT->OnShow( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_VIEW_CHANGE:
        hr = pT->OnViewChange( arg, param, pComponentData, pComponent, type );
        break;

    //
    // MMC 1.2, Win200 build 2059 support
    //
    case MMCN_COLUMNS_CHANGED:
        hr = pT->OnColumnsChanged(arg, param, pComponentData, pComponent, type);
        break;

    default:
        // Unhandled notify event.
        //  MMC wants E_NOTIMPL if you can't do something or it will crash
        hr = E_NOTIMPL;
        break;

    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:CSnapinNode

Constructor

This class is to be the virtual base class for all our nodes
We never want people instantiating it so the constructor is protected

--*/
//////////////////////////////////////////////////////////////////////////////
class CSnapinNode;

template <class T, BOOL bIsExtension>
CSnapinNode<T, bIsExtension>::CSnapinNode(CSnapInItem *pParentNode, CSnapin * pComponentData)
                            : CSnapInItemImpl<T, bIsExtension>(),
							  CSnapinItemEx(dynamic_cast<CSnapinItemEx *>(pParentNode))

{
    DEBUG_FUNCTION_NAME(_T("CSnapinNode::CSnapinNode"));
		
	DebugPrintEx(DEBUG_MSG,
		_T("CSnapinNode::CSnapinNode, this=0x%X"), this);

    // Set the componet data
    m_pComponentData = pComponentData;

    // Set the parent node (in the base class CSnapinItem)
    m_pParentNode = pParentNode;

    // We set cookie for both scope and result pane data items,
    // as this class can be subclassed for either a scope-pane
    // or a result-pane-only node.

    // Sridhar moved this initialization code out of SnapInItemImpl
    memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
    m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
    m_scopeDataItem.displayname = MMC_CALLBACK;
    m_scopeDataItem.nImage = 0;         // May need modification
    m_scopeDataItem.nOpenImage = 0;     // May need modification
    // If this node is inserted in to the scope pane using
    // IConsoleNamespace->InsertItem, the value stored in lParam
    // will be what MMC later passes back as the cookie for this node.
    m_scopeDataItem.lParam = (LPARAM) this;

    // Sridhar moved this initialization code out of SnapInItemImpl
    memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
    m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    m_resultDataItem.str = MMC_CALLBACK;
    m_resultDataItem.nImage = 0;        // May need modification
    // If this node is inserted in to the result pane using
    // IResultData->InsertItem, the value stored in lParam will
    // be what MMC later passes back as the cookie for this node.
    m_resultDataItem.lParam = (LPARAM) this;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:~CSnapinNode

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CSnapinNode<T, bIsExtension>::~CSnapinNode()
{
    DEBUG_FUNCTION_NAME( _T("--- CSnapinNode::~CSnapinNode"));
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetResultPaneColInfo


  By default, we return the display name in the first column, and blank ("")
  for other columns.
  Override in your derived class if you want more columns support
--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
LPOLESTR CSnapinNode<T, bIsExtension>::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CSnapinNode::GetResultPaneColInf"));

    if (nCol == 0)
    {
        return m_bstrDisplayName;
    }

    // Return the blank for other columns
    return OLESTR(" ");
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnActivate

virtual HRESULT OnActivate(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_ACTIVATE
Notify message is sent for this node.

MMC sends this message to the snap-in's IComponent::Notify method when a window is
being activated or deactivated.


Parameters

    arg
    TRUE if the window is activated; otherwise, it is FALSE.

    param
    Not used.


Return Values

    Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnActivate(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME( _T("CSnapinNode::OnActivate  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnAddImages

virtual HRESULT OnAddImages(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

We have chosen to handle this on a per-IComponent object basis, since it has
very little to do (for us at least) with the particular IDataObject.

See CComponent::OnAddImages for where we add images.


This method loads the default ImageList we have
Override this, if you want different imagelist

By default, Loads specific images for this project

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnAddImages(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnAddImages"));

    HRESULT hr;

    IImageList* pImageList = (IImageList*) arg;
    hr = E_FAIL;
    // Load bitmaps associated with the scope pane
    // and add them to the image list
    // Loads the default bitmaps generated by the wizard
    // Change as required
    HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_TOOLBAR_16));
    if (hBitmap16 != NULL)
    {
        HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_TOOLBAR_32));
        if (hBitmap32 != NULL)
        {
            hr = pImageList->ImageListSetStrip((LONG_PTR*)hBitmap16,
                                               (LONG_PTR*)hBitmap32,
                                               0, 
                                               RGB(0, 128, 128));
            if (FAILED(hr))
            {
                DebugPrintEx(DEBUG_ERR, 
					_T("IImageList::ImageListSetStrip failed"));
            }

            DeleteObject(hBitmap32);
        }
        DeleteObject(hBitmap16);
    }
    return(hr);
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnButtonClick

virtual HRESULT OnButtonClick(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_BTN_CLICK Notify message is
sent for this node.

MMC sends this message to the snap-in's IComponent, IComponentData,
or IExtendControlbar implementation when a user clicks on one of the
toolbar buttons.


Parameters

For IComponent::Notify or IComponentData::Notify:

    arg
    Must be zero.

    param
    CmdID of the button equal to a value of the MMC_CONSOLE_VERB enumeration.

For IExtendControlBar::ControlbarNotify:

    arg
    Data object of the currently selected scope or result pane item.

    param
    [in] CmdID of the button equal to a value of the MMC_CONSOLE_VERB enumeration.


Return Values

    Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnButtonClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnButtonClick  -- Override in your derived class"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnClick

virtual HRESULT OnClick(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_CLICK Notify message is
sent for this node.

MMC sends this message to IComponent when a user clicks a mouse button
on a list view item.


Parameters

    arg
    Not used.

    param
    Not used.


Return Values

    Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnClick  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnContextHelp

virtual HRESULT OnContextHelp(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_CONTEXTHELP Notify message is
sent for this node.

MMC sends this message when the user requests help about a selected item


Parameters

    arg
    0.

    param
    0.


Return Values

  Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnContextHelp(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    HRESULT hr;
    PWSTR pszFilePath = ::GetHelpFile();

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnContextHelp"));

    // But to get that, first we need IConsole
    CComPtr<IConsole> spConsole;
    if( pComponentData != NULL )
    {
         spConsole = ((CSnapin*)pComponentData)->m_spConsole;
    }
    else
    {
        // We should have a non-null pComponent
         spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
    }
    ATLASSERT( spConsole != NULL );
    CComPtr<IDisplayHelp> spDisplayHelp;

    hr = spConsole->QueryInterface(IID_IDisplayHelp, (void**)&spDisplayHelp);
    if(FAILED(hr))
    return hr;

    return OnShowContextHelp(spDisplayHelp, pszFilePath);
}

template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnShowContextHelp(
              IDisplayHelp* /*pDisplayHelp*/, LPOLESTR /*helpFile*/)
{
     DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnShowContextHelp -- Override in your derived class"));


     return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnContextMenu

virtual HRESULT OnContextMenu(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_CONTEXTMENU Notify
message is sent for this node.

In the Fall 97 Platform SDK documentation, this event is listed as not used.


Parameters

    arg
    TBD

    param
    TBD

Return Values

    Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnContextMenu(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnContextMenu  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnDoubleClick

virtual HRESULT OnDoubleClick(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_DBLCLICK Notify message is
sent for this node.

MMC sends this message to IComponent when a user double clicks a mouse
button on a list view item.


Parameters

    arg
    Not used.

    param
    Not used.


Return Values

    Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnDoubleClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnDoubleClick  -- Override in your derived class if you don't want default verb action"));

    // Through speaking with Eugene Baucom, I discovered that if you return S_FALSE
    // here, the default verb action will occur when the user double clicks on a node.
    // For the most part we have Properties as default verb, so a double click
    // will cause property sheet on a node to pop up.
    return S_FALSE;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnDelete

virtual HRESULT OnDelete(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_DELETE Notify
message is sent for this node.

MMC sends this message to the snap-in's IComponent and IComponentData implementation to inform the snap-in that the object should be deleted.


Parameters

    arg
    Not used.

    param
    Not used.

Return Values

    Not used.


Remarks

    This message is generated when the user presses the delete key or uses
    the mouse to click on the toolbar's delete button.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnDelete(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            , BOOL fSilent
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);
    UNREFERENCED_PARAMETER (fSilent);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnDelete  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnExpand

virtual HRESULT OnExpand(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

If your node will have scope-pane children,
this method should be overidden in your derived class.

In our implementation, this method gets called when the MMCN_EXPAND Notify message is
sent for this node.

MMC sends this message to the snap-in's IComponentData
implementation when a folder node needs to be expanded or contracted.


Parameters

    arg
    [in] If TRUE, the folder needs to be expanded. If FALSE, the folder needs to be contracted.

    Param
    [in] The HSCOPEITEM of the item that needs to be expanded.


Return Values

    HRESULT


Remarks

    On receipt of this notification the snap-in should enumerate the
    children (sub-containers only) of the specified scope item, if any,
    using IConsoleNameSpace methods. Subsequently, if a new item is added to
    or deleted from this scope object through some external means, then
    that item should also be added to or deleted from the console's
    namespace using IConsoleNameSpace methods.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnExpand(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnExpand  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnHelp

virtual HRESULT OnHelp(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_HELP Notify
message is sent for this node.

In the Fall 97 Platform SDK documentation, this event is listed as not used.

MMC sends this message when the user presses the F1 help key.


Parameters

    arg
    TBD

    param
    Pointer to a GUID. If NULL, the NodeType is used instead.


Return Values

    Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnHelp(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnHelp  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnMenuButtonClick

virtual HRESULT OnMenuButtonClick(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )


In our implementation, this method gets called when the MMCN_MENU_BTNCLICK Notify
message is sent for this node.

MMC sends this ify message is sent Sent to the snap-in's IExtendControlbar
interface when a user clicks on a menu button.


Parameters

    arg
    Data object of currently selected scope or result pane item.

    param
    [in] Pointer to a MENUBUTTONDATA structure.


Return Values

      Not Used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnMenuButtonClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnMenuButtonClick  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnMinimized

virtual HRESULT OnMinimized(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )


In our implementation, this method gets called when the MMCN_MINIMIZED Notify message is
sent for this node.

MMC sends this message to the snap-in's IComponent implementation when
a window is being minimized or maximized.


Parameters

    arg
    TRUE if the window has been minimized; otherwise, it is FALSE.

    Param
    Not used.


Return Values

  Not Used


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnMinimized(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnMinimized  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnPaste

virtual HRESULT OnPaste(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_PASTE
Notify message is sent for this node.

Called to ask the snap-ins folder to paste the selected items.


Parameters

    pDataobject
    The data object in which to paste the selected items provided by the snap-in.
    arg
    The data object of the selected item(s) provided by the source snap-in that need to be pasted.
    param
    NULL for move (as opposed to cut).
    For a single-item paste:

    BOOL* pPasted = (BOOL*)param; Set this to TRUE here if the item was successfully pasted.

    For a multiitem paste:

    LPDATAOBJECT* ppDataObj = (LPDATAOBJECT*)param;

    Use this to return a pointer to a data object consisting of the items successfully pasted. See MMCN_CUTORMOVE.


Return Values

    Not used.


See Also

    MMCN_CUTORMOVE


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnPaste(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnPaste  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnPropertyChange


  virtual HRESULT OnPropertyChange(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_PROPERTY_CHANGE
Notify message is sent for this node.

When the snap-in uses the MMCPropertyChangeNotify function to notify it's
views about changes, MMC_PROPERTY_CHANGE is sent to the snap-in's
IComponentData and IComponent implementations.


Parameters

    arg
    [in] TRUE if the property change is for a scope pane item.

    lParam
    This is the param passed into MMCPropertyChangeNotify.


Return Values

      Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnPropertyChange  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnQueryPaste

virtual HRESULT OnQueryPaste(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_QUERY_PASTE
Notify message is sent for this node.

Sent to the snap-in before pasting into the snap-in's folder to determine if the
snap-in can accept the data.


Parameters

    pdataobject
    The dataobject of the selected item provided by the snap-in.
    arg
    The dataobject of the item(s) provided by the source snap-in that need to be pasted.
    param
    Not used.


Return Values

    Not used.


See Also

    MMCN_PASTE


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnQueryPaste(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnQueryPaste  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRefresh

virtual HRESULT OnRefresh(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_REFRESH
Notify message is sent for this node.

In the Fall 97 Platform SDK documentation, this event is listed as TBD.


Parameters


Return Values

    Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnRefresh(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnRefresh  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRemoveChildren

virtual HRESULT OnRemoveChildren(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_REMOVE_CHILDREN
Notify message is sent for this node.

MMC sends this message to the snap-in's IComponentData implementation to inform
the snap-in that it must delete all the cookies (the entire subtree) it has
added below the specified node.


Parameters

    arg
    Specifies the HSCOPEITEM of the node whose children need to be deleted.

    param
    Not used.


Return Values

      Not used.


Remarks

    Use IConsoleNameSpace methods GetChildItem and GetNextItem to traverse
    the tree and determine the cookies to be deleted.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnRemoveChildren(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnRemoveChildren  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRename

virtual HRESULT OnRename(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_RENAME Notify
message is sent for this node.

ISSUE: I do not seem to be seeing the two-call behaviour documented below

MMC sends this message the first time to query for a rename and the
second time to do the rename.


Parameters

    arg
    Not used.

    param
    LPOLESTR for containing the new name.

Return Values

    S_OK
    Allows the rename.

    S_FALSE
    Disallows the rename.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnRename(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnRename  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnSelect

virtual HRESULT OnSelect(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

You shouldn't need to override this method.  The OnSelect method has common
behaviour for all nodes, only the verbs to be set are different.  Rather
than overriding OnSelect in each node, simply override SetVerbs, which this
implementation of OnSelect calls.

In our implementation, this method gets called when the MMCN_SELECT Notify message is
sent through IComponent::Notify for this node.

Note: MMC also sends the MMCN_SELECT message through IExtendControlbar::ControlbarNotify
but we don't respond to that here -- See CSnapInItem::ControlbarNotify for that.


Parameters

For IComponent::Notify:

    arg
    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelec = (BOOL) HIWORD(arg);

    bScope
    TRUE if an item in the scope pane is selected.
    FALSE if an item in the result view pane is selected.

    bSelect
    TRUE if the item is selected.
    FALSE if the item is deselected.

    param
    This parameter is ignored.

Return Values

    Not used.


Remarks

    When an IComponent::Notify method receives the MMCN_SELECT notification
    it should update the standard verbs.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnSelect(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME( _T("CSnapinNode::OnSelect"));

    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (type);

    _ASSERTE( pComponentData != NULL || pComponent != NULL );


    HRESULT hr = S_FALSE;
    CComPtr<IConsoleVerb> spConsoleVerb;

    BOOL bSelected = (BOOL) HIWORD( arg );

    if( bSelected )
    {

        // Need IConsoleVerb

        // But to get that, first we need IConsole
        CComPtr<IConsole> spConsole;
        if( pComponentData != NULL )
        {
             spConsole = ((CSnapin*)pComponentData)->m_spConsole;
        }
        else
        {
            // We should have a non-null pComponent
             spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
        }
        _ASSERTE( spConsole != NULL );

        hr = spConsole->QueryConsoleVerb( &spConsoleVerb );
        _ASSERT( SUCCEEDED( hr ) );

        hr = SetVerbs( spConsoleVerb );

    }
    else
    {

        // Anything to do here? Don't think so -- see sburns localsec example.

        hr = S_OK;

    }


    return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::SetVerbs

virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb )

Override this method in your derived class.

This method is called by our default implementation of OnSelect
when the verbs for this node need to be set.

Parameters

    IConsoleVerb * pConsoleVerb


Return Values

    HRESULT


Remarks

    The OnSelect method has common behaviour for all nodes, only the verbs
    to be set are different.  Rather than duplicate code by implementing OnSelect
    in each node, simply override this SetVerbs method

    Every time an item is selected, the verb states for all the commands
    are returned to disabled and visible. It is up to the snap-in writer
    to use IConsoleVerb to update the verb state every time an item is selected.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::SetVerbs( IConsoleVerb * pConsoleVerb )
{
    UNREFERENCED_PARAMETER (pConsoleVerb);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::SetVerbs -- Override in your derived class"));

    HRESULT hr = S_OK;

    // Override in your derived class and do something like:
/*
    // We want the user to be able to choose properties on this node
    hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

    // We want the default verb to be Properties
    hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    // We want the user to be able to rename this node
    hr = pConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );
*/
    return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::PreOnShow

virtual HRESULT PreOnShow(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

We call this instead of OnShow, so that we can save away the selected node.

This method will then just call OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::PreOnShow(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME(
         _T("CSnapinNode::PreOnShow  -- Don't override in your derived class"));


    if( NULL != pComponent )
    {

        CSnapinComponent * pMyComponent = static_cast<CSnapinComponent *>( pComponent );

        if( arg )
        {
            // We are being selected.

            // Save our 'this' pointer as the currently selected node for this result view.
            pMyComponent->m_pSelectedNode = static_cast<CSnapInItem *>( this );

        }
        else
        {
            // We are being deselected.

            // Check to make sure that our result view doesn't think
            // this node is the currently selected one.
            if( pMyComponent->m_pSelectedNode == static_cast<CSnapInItem *>( this ) )
            {
                // We don't want to be the selected node anymore.
                pMyComponent->m_pSelectedNode = NULL;
            }

        }

    }

    return OnShow( arg, param, pComponentData, pComponent, type );
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnShow

virtual HRESULT OnShow(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

If your node will have result-pane children,
this method should be overidden in your derived class.

In our implementation, this method gets called when the MMCN_SHOW Notify message is
sent for this node.

MMC sends this message when a scope item is selected or deselected for the
first time.


Parameters

    arg
    TRUE (<>0 ) if selecting; True indicates that the snap-in should set
    up the result pane and add the enumerated items.
    FALSE (0) if deselecting. indicates that the snap-in is going out of
    focus and that it should clean up all cookies the right hand side
    (the result pane), because current result pane will be replaced by a new one.

    param
    The HSCOPEITEM of the selected or deselected item.


Return Values

    Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnShow(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnShow  -- Override in your derived class"));

    // Returning E_NOTIMPL seems to be a bad thing here.
    // It caused all kinds of problems with toolbar buttons persisting to
    // the wrong node, as well as verbs not getting set correctly for nodes.
    // Basically, if you don't respond with S_OK to the MMCN_SHOW notification,
    // you won't get sent the appropriate MMCN_SELECT notification.
    // return E_NOTIMPL;
    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnViewChange

virtual HRESULT OnViewChange(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_VIEW_CHANGE Notify
message is sent for this node.

MMC sends this message to the snap-in's IComponent implementation so it
can update all views when a change occurs.  This node data object passed
to IConsole::UpdateAllViews.


Parameters

    arg
    [in] The data parameter passed to IConsole::UpdateAllViews.

    param
    [in] The hint parameter passed to IConsole::UpdateAllViews.


Return Values

    Not used.


Remarks

    This notification is generated when the snap-in (IComponent or
    IComponentData) calls IConsole::UpdateAllViews.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnViewChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnViewChange  -- Override in your derived class"));

    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnColumnsChanged

virtual HRESULT OnColumnsChanged(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_COLUMNS_CHANGED Notify
message is sent for this node.

MMC sends this message to the snap-in's IComponent implementation so it
can decide if it can accept the column changes.
If snapin refuses to accept column changes then it is upto the snapin to display a message box
explaining the user why it is unable to do so.



Parameters

    arg
    [in] The data parameter passed to IConsole::UpdateAllViews.

    param
    [in] The hint parameter passed to IConsole::UpdateAllViews.


Return Values

    S_OK, 
    A node can override this by returning E_UNEXPECTED that 
    discard user changes. In such a case display a message box
    explaining the user why it is unable to do so.


Remarks

    This notification is generated when the snap-in (IComponent or
    IComponentData) calls IConsole::UpdateAllViews.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnColumnsChanged(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::TaskNotify

Called when MMC wants to notify us that the user clicked on a task
on a taskpad belonging to this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::TaskNotify(
              IDataObject * pDataObject
            , VARIANT * pvarg
            , VARIANT * pvparam
            )
{
    UNREFERENCED_PARAMETER (pDataObject);
    UNREFERENCED_PARAMETER (pvarg);
    UNREFERENCED_PARAMETER (pvparam);

    DEBUG_FUNCTION_NAME( 
		_T("CSnapInItemImpl::TaskNotify - not impleneted"));

    return E_NOTIMPL;

}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::EnumTasks

Called when MMC wants us to enumerate the tasks on a taskpad
belonging to this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::EnumTasks(
              IDataObject * pDataObject
            , BSTR szTaskGroup
            , IEnumTASK** ppEnumTASK
            )
{
    UNREFERENCED_PARAMETER (pDataObject);
    UNREFERENCED_PARAMETER (szTaskGroup);
    UNREFERENCED_PARAMETER (ppEnumTASK);

    DEBUG_FUNCTION_NAME( 
		_T("CSnapInItemImpl::EnumTasks  - not impleneted"));

    return E_NOTIMPL;
}

#define COMET_MMC_COMMON_DLL L"nemmcutl.dll"

/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::NodeMsgBox

Calls IConsole::MessageBox


Parameters

    ids
    [in] string table (in rc) id of the text

    fuStyle
    [in] MB_* mask. See Win32 MessageBox

    piRetval
    [out] Message return value (see IConsole::MessageBox)

    StringFromCommonDll
    [in] if true the resource is taken from nemmcutil.dll (zvib)


Return Values

    The same as IConsole::MessageBox


Remarks

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension> HRESULT
CSnapinNode<T, bIsExtension>::NodeMsgBox(int ids,
                                         UINT fuStyle/*=MB_OK*/,
                                         int *piRetval/*=NULL*/,
                                         BOOL StringFromCommonDll
                                         )
{	
	ATLASSERT(m_pComponentData);
	ATLASSERT(m_pComponentData->m_spConsole);

    if(IsRTLUILanguage())
    {
        fuStyle |= MB_RTLREADING | MB_RIGHT;
    }

	return ::ConsoleMsgBox(m_pComponentData->m_spConsole, ids, m_bstrDisplayName, fuStyle, piRetval,StringFromCommonDll);

}

template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::RefreshSingleResultItem(CSnapInObjectRootBase *pRoot)
{
    HRESULT     hr = S_OK;
    CComPtr<IConsole>   spConsole;
    CSnapinComponent *pComponent;

//[yg] Dec 15 1999
//compiler err
//    error C2683: dynamic_cast : 'CSnapInObjectRootBase' is not a polymorphic type"    
//in code:
//    pComponent = dynamic_cast<CSnapinComponent*>(pRoot);
//changed to:

    pComponent =(CSnapinComponent*)(pRoot);

    _ASSERTE(pComponent != NULL);
    spConsole = pComponent->m_spConsole;
    _ASSERTE(spConsole != NULL);

    hr = RefreshSingleResultItem(spConsole);
    return(hr);
}

template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::RefreshSingleResultItem(IComponentData *pComponentData, IComponent * pComponent)
{
    HRESULT     hr = S_OK;
    CComPtr<IConsole>   spConsole;

    if ((pComponentData != NULL))
    {
        spConsole = ((CSnapin*)pComponentData)->m_spConsole;
    }
    else
    {
       // We should have a non-null pComponent
       spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
    }

    _ASSERTE(spConsole != NULL);
    hr = RefreshSingleResultItem(spConsole);
    return(hr);

}
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::RefreshSingleResultItem(IConsole *spConsole)
{
    HRESULT hr = S_OK;
    // Need IResultData
    CComQIPtr<IResultData, &IID_IResultData> pResultData(spConsole);
    ATLASSERT(pResultData != NULL);

    // Update the item
    hr = pResultData->SetItem(&m_resultDataItem);
    if (SUCCEEDED(hr))
        hr = pResultData->UpdateItem(m_resultDataItem.itemID);
    return(hr);
}

#endif // _SNAPIN_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\snapin.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Snapin.cpp                                             //
//                                                                         //
//  DESCRIPTION   : Implementation file for                                //
//                    CSnapin          class                               //
//                    CSnapinComponent class                               //
//                                                                         //
//  AUTHOR        : ATL Snapin wizard                                      //
//                                                                         //
//  HISTORY       :                                                        //
//      May 25 1998 adik    Init.                                          //
//      Sep 14 1998 yossg   seperate common source to an included file     //
//      Mar 28 1999 adik    Remove persistence support (done by mmc 1.2).  //
//                                                                         //
//      Sep 27 1999 yossg   Welcome to Fax Server			   //
//      Dec 12 1999 yossg   add CSnapin::Notify				   //
//      Apr 14 2000 yossg   add support for primary snapin mode		   //
//      Jun 25 2000 yossg   add stream and command line primary snapin 	   //
//                          machine targeting.                             //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "resource.h"

#include "MsFxsSnp.h"

#include "Snapin.h"
#include "root.h"

#include "FaxServerNode.h"
#include "FaxMMCPropertyChange.h"

static const GUID CSnapinExtGUID_NODETYPE = 
{ 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
const GUID*    CSnapinExtData::m_NODETYPE = &CSnapinExtGUID_NODETYPE;
const OLECHAR* CSnapinExtData::m_SZNODETYPE = OLESTR("476e6449-aaff-11d0-b944-00c04fd8d5b0");
const OLECHAR* CSnapinExtData::m_SZDISPLAY_NAME = OLESTR("Fax");
const CLSID*   CSnapinExtData::m_SNAPIN_CLASSID = &CLSID_Snapin;
/////////////////////////////////////////////////////////////////////////////
#include "resutil.h"
#include "c_snapin.cpp"
/////////////////////////////////////////////////////////////////////////////

//
// Clipboard Formats
//
const CLIPFORMAT gx_CCF_COMPUTERNAME = (CLIPFORMAT) RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));


BOOL ExtractComputerName(IDataObject* pDataObject, BSTR * pVal)
{
    DEBUG_FUNCTION_NAME( _T("ExtractComputerName"));

	//
	// Find the computer name from the ComputerManagement snapin
	//
	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { gx_CCF_COMPUTERNAME, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    //
    // Allocate memory for the stream
    //
    int len = 500;

    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);
	if(stgmedium.hGlobal == NULL)
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("GlobalAlloc Fail. stgmedium.hGlobal == NULL, can not extract computerName"));
		return FALSE;
    }


	HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium);

    if (!SUCCEEDED(hr))
    {
        ATLASSERT(FALSE);
        DebugPrintEx( DEBUG_ERR,
		    _T("Fail to GetDataHere"));
		return FALSE;
    }

	//
	// Get the computer name
	//
    *pVal = SysAllocString((WCHAR *)stgmedium.hGlobal);
    if (NULL == *pVal)
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Out of memory - fail to allocate server name !!!"));
        return FALSE;
    }

	GlobalFree(stgmedium.hGlobal);
    return TRUE;
}


/*
 -  CSnapinExtData::GetExtNodeObject
 -
 *  Purpose:
 *      Connect as an extension to root node.
 *
 *  Arguments
 *
 *  Return:
 *      The HTM path name
 */
CSnapInItem*
CSnapinExtData::GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
{
    DEBUG_FUNCTION_NAME( _T("MsFxsSnp.dll - CSnapinExtData::GetExtNodeObject"));


    CComBSTR        bstrComputer; 

    m_pDataObject = pDataObject;

    CSnapinRoot *pRoot = new CSnapinRoot(this, m_pComponentData);
    if (pRoot == NULL)
    {
        DebugPrintEx(DEBUG_ERR,_T("new CSnapinRoot"), E_OUTOFMEMORY);
        return pDefault;
    }

    if (!ExtractComputerName(pDataObject, &bstrComputer))
    {
		DebugPrintEx( DEBUG_MSG, 
            _T("Fail to extract computer name"));
        delete pRoot;
        pRoot = NULL;
        
        return pDefault;
    }
    ATLASSERT(bstrComputer);

    if (S_OK != pRoot->SetServerName(bstrComputer))
    {
        DebugPrintEx(DEBUG_ERR,_T("pRoot->SetServerName"), E_OUTOFMEMORY);
        delete pRoot;
        pRoot = NULL;
        
        return pDefault;
    }

    return pRoot;
}

/*
 -  CSnapin::GetHelpTopic
 -
 *  Purpose:
 *      Get the HTM file name within comet.chm that contains the info about this node.
 *
 *  Arguments
 *
 *  Return:
 *      The HTM path name
 */
WCHAR*
CSnapin::GetHelpTopic()
{
    return NULL;
}

/*
 -  CSnapin::Notify
 -
 *  Purpose:
 *      Override IComponentDataImpl::Notify for the special case with 
 *      (lpDataObject == NULL) && (event == MMCN_PROPERTY_CHANGE)
 *      were the assumption is that notification got from scope node TYPE == CCT_SCOPE
 *      this was done for the Device scope pane node refreshment of 
 *      result pane colmons data !
 *
 *  Arguments:
 *      [in]    lpDataObject
 *
 *      [in]    event
 *
 *      [in]    arg
 *
 *      [in]    param
 *
 *  Return:
 *      OLE error code.
 *
 */

HRESULT CSnapin::Notify( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
{
    DEBUG_FUNCTION_NAME( _T("++<<<<< CSnapin::Notify >>>>>++"));

	HRESULT hr = E_POINTER;
	CSnapInItem* pItem;
	//T* pT = static_cast<T*>(this);
	CSnapin * pT = this;


	if ( (NULL == lpDataObject) && (MMCN_PROPERTY_CHANGE == event) )
    {
        DebugPrintEx( DEBUG_MSG,
		    _T("Special case: (NULL == lpDataObject) && (MMCN_PROPERTY_CHANGE == event)"));

        CFaxPropertyChangeNotification * pNotification;
        pNotification = ( CFaxPropertyChangeNotification * ) param;
        ATLASSERT(pNotification);
          
        pItem = pNotification->pItem;
        ATLASSERT(pItem);
    	
        hr = pItem->Notify(event, arg, param, pT, NULL, CCT_SCOPE);
        
        return hr;
	    
    }
	else
	{
        return IComponentDataImpl<CSnapin, CSnapinComponent>::Notify(
                                            lpDataObject, event, arg, param);
    }
	
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\snpnres.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    snpres.h

Abstract:

    This is the header file for CNodeWithResultChildrenList, a class which
    implements a node that has a list of scope pane children.

    This is an inline template class.
    Include NodeWithScopeChildrenList.cpp in the .cpp files
    of the classes in which you use this template.

Author:

    Original: Michael A. Maguire
    Modifications: RaphiR

Changes:
    Support for Extension snapins
    Jun 14 1999 roytal  used UNREFERENCED_PARAMETER to fix build wrn
//                                                                         //
//      Sep 22 1999 yossg   welcome To Fax Server                           //


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NODE_WITH_RESULT_CHILDREN_LIST_H_)
#define _NODE_WITH_RESULT_CHILDREN_LIST_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "snpnode.h"
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


template < class T, class CChildNode, class TArray, BOOL bIsExtension>
class CNodeWithResultChildrenList : public CSnapinNode< T, bIsExtension>
{

    // Constructor/Destructor

public:
    CNodeWithResultChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData);
    ~CNodeWithResultChildrenList();


    // Child list management.

public:
    // Flag indicating whether list has been initially populated
    BOOL m_bResultChildrenListPopulated;

protected:
    // Override these in your derived classes
    virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );
    virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );
    virtual HRESULT PopulateResultChildrenList(void );

    // Stuff which must be accessible to subclasses.  These methods shouldn't need to be overidden.
    // zvib moved to public
    //virtual HRESULT RepopulateResultChildrenList(void);
    // virtual HRESULT AddChildToList( CChildNode * pChildNode );
    //virtual HRESULT EnumerateResultChildren( IResultData * pResultData );
    // zvib

    // Array of pointers to children nodes.
    // This is protected so that it can be visible in the derived classes.
    TArray m_ResultChildrenList;


    // Overrides for standard MMC functionality.
public:

    virtual HRESULT RepopulateResultChildrenList(void);
    virtual HRESULT EnumerateResultChildren( IResultData * pResultData );
    virtual HRESULT AddChildToList( CChildNode * pChildNode );

    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::RemoveChild

    Removes a child from the list of children.

    This has to be public so that child nodes can ask their parent to be deleted
    from the list of children when they receive the MMCN_DELETE notification.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT RemoveChild( CChildNode * pChildNode );

    virtual HRESULT OnShow(
                      LPARAM arg
                    , LPARAM param
                    , IComponentData * pComponentData
                    , IComponent * pComponent
                    , DATA_OBJECT_TYPES type
                    );
    virtual HRESULT OnRefresh(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );

    virtual HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

};


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::InsertColumns

Override this in your derived class.

This method is called by OnShow when it needs you to set the appropriate
column headers to be displayed in the result pane for this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithResultChildrenList::InsertColumns -- override in your derived class"));


    // Check for preconditions:
    _ASSERTE( pHeaderCtrl );


    HRESULT hr;

    // override in your derived class and do something like:
    hr = pHeaderCtrl->InsertColumn( 0, L"@Column 1 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 120 );
    _ASSERT( S_OK == hr );

    hr = pHeaderCtrl->InsertColumn( 1, L"@Column 2 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 300 );
    _ASSERT( S_OK == hr );

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnUnSelect

Override this in your derived class.

This method is called by OnShow when the node is unselected.
Useful to overidde this if you want to retreive columns header width for example


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithResultChildrenList::OnUnSelect -- override in your derived class"));

    UNREFERENCED_PARAMETER (pHeaderCtrl);

    // Check for preconditions:
    _ASSERTE( pHeaderCtrl != NULL );


    HRESULT hr = S_OK;

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::PopulateResultChildrenList

Override this in your derived class.

This is called by EnumerateResultChildren which is called by OnShow when
you need to populate the list of children of this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::PopulateResultChildrenList( void )
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithResultChildrenList::PopulateResultChildrenList -- override in your derived class"));


    // Check for preconditions:
    // None.


    // override in your derived class and do something like:
/*
    CSomeChildNode *myChild1 = new CSomeChildNode();
    AddChildToList(myChild1);

    CSomeChildNode *myChild2 = new CSomeChildNode();
    AddChildToList(myChild2);

    CSomeChildNode *myChild3 = new CSomeChildNode();
    AddChildToList(myChild3);
*/
    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::RepopulateResultChildrenList

DON'T Override this in your derived class.

Call this to empty the list of children and repopulate it.
This method will call PopulateResultChildrenList, which you should override.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::RepopulateResultChildrenList(void)
{

    DEBUG_FUNCTION_NAME( _T("CNodeWithResultChildrenList<..>::RepopulateResultChildrenList"));
    HRESULT hr;

    // Check for preconditions:
    // None.

    //
    // Clear our node list [Michael A. Maguire]
    //
    
    // Get rid of what we had.

    // Delete each node in the list of children
    CChildNode* pChildNode;
    int iSize = m_ResultChildrenList.GetSize();
    for (int i = 0; i < iSize; i++)
    {
        pChildNode = m_ResultChildrenList[i];
        delete pChildNode;
    }

    // Empty the list
    m_ResultChildrenList.RemoveAll();

    //
    // Update the views after the children removal
    //
    _ASSERTE( m_pComponentData != NULL );
    _ASSERTE( m_pComponentData->m_spConsole != NULL );
    m_pComponentData->m_spConsole->UpdateAllViews( NULL,(LPARAM) this, NULL);

    // We no longer have a populated list.
    m_bResultChildrenListPopulated = FALSE;

    // Repopulate the list.
    hr = PopulateResultChildrenList();

    // We've already loaded our children ClientNode objects with
    // data necessary to populate the result pane.
    m_bResultChildrenListPopulated = TRUE;  // We only want to do this once.

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::CNodeWithResultChildrenList

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
CNodeWithResultChildrenList<T,CChildNode, TArray,bIsExtension>::CNodeWithResultChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData): CSnapinNode<T,bIsExtension>(pParentNode, pComponentData)
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithResultChildrenList::CNodeWithResultChildrenList"));


    // Check for preconditions:
    // None.


    // We have not yet loaded the child nodes' data
    m_bResultChildrenListPopulated = FALSE;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::~CNodeWithResultChildrenList

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::~CNodeWithResultChildrenList()
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithResultChildrenList::~CNodeWithResultChildrenList"));


    // Check for preconditions:
    // None.



    // Delete each node in the list of children
    CChildNode* pChildNode;
    int iSize = m_ResultChildrenList.GetSize();
    for (int i = 0; i < iSize; i++)
    {
        pChildNode = m_ResultChildrenList[i];
        delete pChildNode;
    }

    // Empty the list
    m_ResultChildrenList.RemoveAll();

}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::AddChildToList

Adds a child to the list of children.  Does not cause a view update.

Use this in your PopulateResultChildrenList method.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode, TArray, bIsExtension>::AddChildToList( CChildNode * pChildNode )
{


    // Check for preconditions:
    // None.


    HRESULT hr = S_OK;

    if( m_ResultChildrenList.Add(pChildNode ) )
    {

        hr = S_OK;

    }
    else
    {
        // Failed to add => out of memory
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnShow

Don't override this in your derived class.  Instead, override methods
which it calls: InsertColumns and (indirectly) PopulateResultChildrenList

This method is an override of CSnapinNode::OnShow.  When MMC passes the
MMCN_SHOW method for this node, we are to add children into the
result pane.  In this class we add them from a list we maintain.

For more information, see CSnapinNode::OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::OnShow(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithResultChildrenList::OnShow"));

    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (type);

    // Check for preconditions:
    _ASSERTE( pComponentData != NULL || pComponent != NULL );


    HRESULT hr = S_FALSE;

    T * pT = static_cast<T*>( this );


    // Need IHeaderCtrl.

    // But to get that, first we need IConsole
    CComPtr<IConsole> spConsole;
    if( pComponentData != NULL )
    {
         spConsole = ((CSnapin*)pComponentData)->m_spConsole;
    }
    else
    {
        // We should have a non-null pComponent
         spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
    }
    _ASSERTE( spConsole != NULL );

    CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeaderCtrl(spConsole);
    _ASSERT( spHeaderCtrl != NULL );

    if( arg )
    {

        // arg <> 0 => we are being selected.

        // Note: This method will only get called with
        // arg <> 0 (i.e. selected) if you responded appropriately to
        // the MMCN_ADD_IMAGES method

        // We have been asked to display result pane nodes belonging under this node.

        // It appears we must do IResultData->InsertItems each time we receive
        // the MMCN_SHOW message -- MMC doesn't remember what nodes
        // we have previously inserted.


        // Set the column headers in the results pane
        // Note: if you don't set these, MMC will never
        // bother to put up your result-pane only items

        // When this Notify method is called from IComponentDataImpl, we
        // get pHeader (and pToolbar) passed in as NULL, so we aren't
        // going to bother using it and will instead always
        // QI pConsole for this pointer
        hr = pT->InsertColumns( spHeaderCtrl );
        _ASSERT( S_OK == hr );


        // Display our list of children in the result pane

        // Need IResultData
        CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
        _ASSERT( spResultData != NULL );

        hr = pT->EnumerateResultChildren(spResultData );
    }
    else
    {
        //
        // We are unselected
        //
        hr = OnUnSelect(spHeaderCtrl);
        _ASSERT( S_OK == hr );

    }

    return hr;


}


//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::DoRefresh(CSnapInObjectRootBase *pRoot)
{

    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnRefresh


You shouldn't need to override this in your derived method.  Simply
enable the MMC_VERB_REFRESH for your node.

In our implementation, this method gets called when the MMCN_REFRESH
Notify message is sent for this node.

For more information, see CSnapinNode::OnRefresh.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::OnRefresh(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithResultChildrenList::OnRefresh"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    HRESULT hr;

    // Rebuild our list of nodes from the uderlying data source.
    T * pT = static_cast<T*> (this);
    hr = pT->RepopulateResultChildrenList();


    // Update the views.

    // We weren't passed an IConsole pointer here, so
    // we use the one we saved in out CComponentData object.
    _ASSERTE( m_pComponentData != NULL );
    _ASSERTE( m_pComponentData->m_spConsole != NULL );

    // We pass in a pointer to 'this' because we want each
    // of our CComponent objects to update its result pane
    // view if 'this' node is the same as the saved currently
    // selected node.
    m_pComponentData->m_spConsole->UpdateAllViews( NULL,(LPARAM) this, NULL);

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::EnumerateResultChildren

Don't override this in your derived class. Instead, override the method
it calls, PopulateResultChildrenList.

This is called by the OnShow method.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::EnumerateResultChildren( IResultData * pResultData )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithResultChildrenList::EnumerateResultChildren"));


    // Check for preconditions:
    _ASSERTE( pResultData != NULL );


    HRESULT hr = S_OK;

    T * pT = static_cast<T*> (this);

    if ( FALSE == m_bResultChildrenListPopulated )
    {
        // We have not yet loaded all of our children into our list.
        // This call will add items to the list from whatever data source.
        hr = pT->PopulateResultChildrenList();
        if( FAILED(hr) )
        {
            return( hr );
        }

        // We've already loaded our children ClientNode objects with
        // data necessary to populate the result pane.
        m_bResultChildrenListPopulated = TRUE;  // We only want to do this once.

    }


    // From MeanGene's Step4 -- need to first remove all items from result pane
    hr = pResultData->DeleteAllRsltItems();
    if( FAILED(hr) )
    {
        return hr;
    }

    // The ResultChildrenList is already populated, so we
    // just need to show the CChildNode objects to the world
    // by populating the result pane.

    CChildNode* pChildNode;
    for (int i = 0; i < m_ResultChildrenList.GetSize(); i++)
    {
        pChildNode = m_ResultChildrenList[i];
        if ( NULL == pChildNode )
        {
            continue;
        }

        // Insert the item into the result pane.
        hr = pResultData->InsertItem( &(pChildNode->m_resultDataItem) );
        if (FAILED(hr))
        {
            return hr;
        }

        // Check: On return, the itemID member of 'm_resultDataItem'
        // contains the handle to the newly inserted item.
        _ASSERT( NULL != pChildNode->m_resultDataItem.itemID );

    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::RemoveChild

Removes a child from the list of children.

This is declared public because it must be accessed from a child node when that
node receives the MMCN_DELETE message and tries to delete itself.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::RemoveChild( CChildNode * pChildNode )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithResultChildrenList::RemoveChild"));


    // Check for preconditions:
    // None.


    HRESULT hr = S_OK;

    if( m_ResultChildrenList.Remove( pChildNode ) )
    {

        // We don't remove the item directly from the result pane now
        // using IResultData->RemoveItem, as we have no way of
        // removing it from all the possible views.
        // Instead, we call IConsole->UpdateAllViews which will
        // cause MMC to call Notify on each of our IComponent objects
        // with the MMCN_VIEW_CHANGE notification, and we will
        // repopulate the result view when we handle that notification.

        // We weren't passed an IConsole pointer here, so
        // we use the one we saved in out CComponentData object.
        _ASSERTE( m_pComponentData != NULL );
        _ASSERTE( m_pComponentData->m_spConsole != NULL );

        // We pass in a pointer to 'this' because we want each
        // of our CComponent objects to update its result pane
        // view if 'this' node is the same as the saved currently
        // selected node.
        m_pComponentData->m_spConsole->UpdateAllViews( NULL,(LPARAM) this, NULL);

    }
    else
    {
        // If we failed to remove, probably the child was never in the list
        // ISSUE: determine what do here -- this should never happen
        _ASSERTE( FALSE );
        hr = S_FALSE;
    }

    return hr;
}


#endif // _NODE_WITH_RESULT_CHILDREN_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

//                                                                         //
//      Sep 22 1999 yossg   welcome To Fax Server                           //
//

#if !defined(AFX_STDAFX_H__65929689_4B15_11D2_AC28_0060081EFE5C__INCLUDED_)
#define AFX_STDAFX_H__65929689_4B15_11D2_AC28_0060081EFE5C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED

    //
    // WARNING: THIS MAKES THE CHECKED BINARY TO GROW 
    //
        #define ATL_TRACE_LEVEL 4
        #define ATL_TRACE_CATEGORY 0xFFFFFFFF
    //    #define _ATL_DEBUG_INTERFACES

#include "resource.h"

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;


#include <atlcom.h>
#include <shellapi.h>
#include <shlobj.h>
#include <atlwin.h>
#include <atlbase.h>
#include <atlapp.h>
#include <atlctrls.h>

//#include <ATLSnap.h>
#include "..\inc\atlsnap.h"
#include <faxutil.h>
#include "FaxMMCUtils.h"

#include <fxsapip.h>  

#include "helper.h"
#include <FaxUiConstants.h>
#include "resutil.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__65929689_4B15_11D2_AC28_0060081EFE5C__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\snpnscp.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    NodeWithScopeChildrenList.h

Abstract:

    This is the header file for CNodeWithScopeChildrenList, a class which
    implements a node that has a list of scope pane children.

    This is an inline template class.
    Include NodeWithScopeChildrenList.cpp in the .cpp files
    of the classes in which you use this template.

Author:

    Original: Michael A. Maguire
    Modifications: RaphiR

Changes:
    Support for Extension snapins
    Enables multiple class of childs

//      Jun 14 1999 roytal  used UNREFERENCED_PARAMETER to fix build wrn   //
//                                                                         //
//      Sep 22 1999 yossg   Welcome To Fax Server                          //
//      Dec 30 1999 yossg   Fix RemoveChild                                //

--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NODE_WITH_SCOPE_CHILDREN_LIST_H_)
#define _NODE_WITH_SCOPE_CHILDREN_LIST_H_


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "snpnode.h"
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



template <class T,BOOL bIsExtension>
class CNodeWithScopeChildrenList : public CSnapinNode< T, bIsExtension >
{

public:



    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::AddChild

    Adds a child to the list of children.

    This has to be public as it must be accessible even from a separate dialog
    (e.g. a Connect to Server dialog) that may want to add a child.

    Here we add the child item to the list of children and call InsertItem
    to add the child to the scope pane.

    This is one difference between adding nodes into the scope
    pane and the result pane.  When we were inserting a child into
    the result pane, we didn't call InsertItem in the AddChild methods(s)
    because we needed to worry about sending an UpdataAllViews
    notification and repopulating the result pane in each view.

    Because MMC takes care of replicating scope pane changes to all views,
    we don't need to worry about this.  Instead, we just do InsertItem once here.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT AddChild(CSnapInItem * pChildNode, SCOPEDATAITEM* pScopeDataItem);



    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::RemoveChild

    Removes a child from the list of children.

    This has to be public so that child nodes can ask their parent to be deleted
    from the list of children when they receive the MMCN_DELETE notification.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT RemoveChild(CSnapInItem * pChildNode );



    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::OnShow

    Don't override this in your derived class.  Instead, override methods
    which it calls: InsertColumns

    This method is an override of CSnapinNode::OnShow.  When MMC passes the
    MMCN_SHOW method for this node.

    For more information, see CSnapinNode::OnShow.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT OnShow(
                      LPARAM arg
                    , LPARAM param
                    , IComponentData * pComponentData
                    , IComponent * pComponent
                    , DATA_OBJECT_TYPES type
                    );


    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildren::OnExpand

    Don't override this in your derived class.  Instead, override methods
    which it calls: PopulateScopeChildrenList

    This method is an override of CSnapinNode::OnExpand.  When MMC passes the
    MMCN_EXPAND method for this node, we are to add children into the
    scope pane.  In this class we add them from a list we maintain.

    For more information, see CSnapinNode::OnExpand.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT OnExpand(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );




protected:


    // Array of pointers to children nodes
    CSimpleArray<CSnapInItem*> m_ScopeChildrenList;

    // Flag indicating whether list has been initially populated
    BOOL m_bScopeChildrenListPopulated;


    /////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::CNodeWithScopeChildrenList

    Constructor

    This is an base class which we don't want instantiated on its own,
    so the contructor is protected

    --*/
    //////////////////////////////////////////////////////////////////////////////
    CNodeWithScopeChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData);



    /////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList

    Destructor

    --*/
    //////////////////////////////////////////////////////////////////////////////
    ~CNodeWithScopeChildrenList();



    /////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::PopulateScopeChildrenList

    Override this in your derived class to populate the list of children nodes.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT PopulateScopeChildrenList();

    // override in your derived class and do something like:

/*
    virtual HRESULT PopulateScopeChildrenList( void )
    {
        CSomeChildNode *myChild1 = new CSomeChildNode();
        AddChild(myChild1);

        CSomeChildNode *myChild2 = new CSomeChildNode();
        AddChild(myChild2);

        CSomeChildNode *myChild3 = new CSomeChildNode();
        AddChild(myChild3);

        return S_OK;
    }
*/


    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::InsertColumns

    Override this in your derived class.

    This method is called by OnShow when it needs you to set the appropriate
    column headers to be displayed in the result pane for this node.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );


    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::OnUnSelect

    Override this in your derived class.

    This method is called by OnShow when the node is unselected.
    Useful to overidde this if to retreive columns header width for example

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );


    /////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::EnumerateScopeChildren

    Don't override this in your derived class. Instead, override the method
    it calls, PopulateScopeChildrenList.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT EnumerateScopeChildren( IConsoleNameSpace* pConsoleNameSpace );


};




//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::AddChild

Adds a child to the list of children.

This has to be public as it must be accessible even from a separate dialog
(e.g. a Connect to Server dialog) that may want to add a child.

Here we add the child item to the list of children and call InsertItem
to add the child to the scope pane.

This is one difference between adding nodes into the scope
pane and the result pane.  When we were inserting a child into
the result pane, we didn't call InsertItem in the AddChild methods(s)
because we needed to worry about sending an UpdataAllViews
notification and repopulating the result pane in each view.

Because MMC takes care of replicating scope pane changes to all views,
we don't need to worry about this.  Instead, we just do InsertItem once here.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::AddChild(
                                             CSnapInItem*       pChildNode,
                                             SCOPEDATAITEM*     pScopeDataItem)
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithScopeChildrenList::AddChild"));


    // Check for preconditions:
    // None.


    HRESULT hr = S_OK;

    if( m_ScopeChildrenList.Add( pChildNode ) )
    {

        //
        // Get the Console
        //
        CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole);


        // We hand our HSCOPEITEM as the parent ID for this child.
        pScopeDataItem->relativeID = (HSCOPEITEM) m_scopeDataItem.ID;


        hr = spConsoleNameSpace->InsertItem(pScopeDataItem);
        if (FAILED(hr))
        {
            return hr;
        }

        // Check: On return, the ID member of 'm_scopeDataItem'
        // contains the handle to the newly inserted item.
        _ASSERT( NULL != pScopeDataItem->ID);

    }
    else
    {
        // Failed to add => out of memory
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::RemoveChild

Removes a child from the list of children.

This has to be public so that child nodes can ask their parent to be deleted
from the list of children when they receive the MMCN_DELETE notification.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T, bIsExtension>::RemoveChild(CSnapInItem * pChildNode )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithScopeChildrenList::RemoveChild"));


    // Check for preconditions:
    // None.


    HRESULT hr = S_OK;


    if( m_ScopeChildrenList.Remove( pChildNode ) )
    {
        //
        // Need IConsoleNameSpace
        //
        CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole);

        //
        // Need pScopeDataItem
        //
        SCOPEDATAITEM *pScopeDataItem;
        pChildNode->GetScopeData(&pScopeDataItem);

        //
        // DeleteItem
        //
        hr = spConsoleNameSpace->DeleteItem(pScopeDataItem->ID, TRUE );

        if (FAILED(hr))
        {
            return hr;
        }

    }
    else
    {
        // If we failed to remove, probably the child was never in the list
        // ISSUE: determine what do here -- this should never happen
        _ASSERTE( FALSE );

        hr = S_FALSE;
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::CNodeWithScopeChildrenList

Constructor

This is an base class which we don't want instantiated on its own,
so the contructor is protected

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CNodeWithScopeChildrenList<T,bIsExtension>::CNodeWithScopeChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData):
                CSnapinNode< T, bIsExtension >(pParentNode, pComponentData)
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithScopeChildrenList::CNodeWithScopeChildrenList"));


    // Check for preconditions:
    // None.


    // We have not yet loaded the child nodes' data
    m_bScopeChildrenListPopulated = FALSE;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CNodeWithScopeChildrenList<T, bIsExtension>::~CNodeWithScopeChildrenList()
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList"));


    // Check for preconditions:
    // None.



    // Delete each node in the list of children
    CSnapInItem* pChildNode;
    for (int i = 0; i < m_ScopeChildrenList.GetSize(); i++)
    {
        pChildNode = m_ScopeChildrenList[i];
        delete pChildNode;
    }

    // Empty the list
    m_ScopeChildrenList.RemoveAll();

}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::PopulateScopeChildrenList

Override this in your derived class to populate the list of children nodes.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T, bIsExtension>::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithScopeChildrenList::PopulateScopeChildren -- override in your derived class"));


    // Check for preconditions:
    // None.


    // override in your derived class and do something like:
/*
    CSomeChildNode *myChild1 = new CSomeChildNode();
    m_CChildrenList.Add(myChild1);

    CSomeChildNode *myChild2 = new CSomeChildNode();
    m_CChildrenList.Add(myChild2);

    CSomeChildNode *myChild3 = new CSomeChildNode();
    m_CChildrenList.Add(myChild3);
*/
    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::OnShow

Don't override this in your derived class.  Instead, override methods
which it calls: InsertColumns

This method is an override of CSnapinNode::OnShow.  When MMC passes the
MMCN_SHOW method for this node.

For more information, see CSnapinNode::OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T, bIsExtension>::OnShow(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeScopeChildrenList::OnShow"));

    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (type);

    // Check for preconditions:
    _ASSERTE( pComponentData != NULL || pComponent != NULL );


    HRESULT hr = S_FALSE;



    // Need IHeaderCtrl.

    // But to get that, first we need IConsole
    CComPtr<IConsole> spConsole;
    if( pComponentData != NULL )
    {
         spConsole = ((CSnapin*)pComponentData)->m_spConsole;
    }
    else
    {
        // We should have a non-null pComponent
         spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
    }
    _ASSERTE( spConsole != NULL );

    CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeaderCtrl(spConsole);
    _ASSERT( spHeaderCtrl != NULL );

    if( arg )
    {

        // arg <> 0 => we are being selected.
        hr = InsertColumns( spHeaderCtrl );
        _ASSERT( S_OK == hr );

    }
    else
    {
        //
        // We are unselected
        //
        hr = OnUnSelect(spHeaderCtrl);
        _ASSERT( S_OK == hr );
    }

    return hr;


}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::InsertColumns

Override this in your derived class.

This method is called by OnShow when it needs you to set the appropriate
column headers to be displayed in the result pane for this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithScopeChildrenList::InsertColumns -- override in your derived class"));


    // Check for preconditions:
    _ASSERTE( pHeaderCtrl != NULL );


    HRESULT hr;

    // override in your derived class and do something like:
    hr = pHeaderCtrl->InsertColumn( 0, L"@Column 1 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 120 );
    _ASSERT( S_OK == hr );

    hr = pHeaderCtrl->InsertColumn( 1, L"@Column 2 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 300 );
    _ASSERT( S_OK == hr );

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::OnUnSelect

Override this in your derived class.

This method is called by OnShow when the node is unselected.
Useful to overidde this if to retreive columns header width for example


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
    UNREFERENCED_PARAMETER (pHeaderCtrl);

    DEBUG_FUNCTION_NAME(
        _T("CNodeWithScopeChildrenList::OnUnSelect -- override in your derived class"));


    // Check for preconditions:
    _ASSERTE( pHeaderCtrl != NULL );


    HRESULT hr = S_OK;

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildren::OnExpand

Don't override this in your derived class.  Instead, override methods
which it calls: PopulateScopeChildrenList

This method is an override of CSnapinNode::OnExpand.  When MMC passes the
MMCN_EXPAND method for this node, we are to add children into the
scope pane.  In this class we add them from a list we maintain.

For more information, see CSnapinNode::OnExpand.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::OnExpand(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithScopeChildren::OnExpand"));

    UNREFERENCED_PARAMETER (type);

    // Check for preconditions:
    _ASSERTE( pComponentData != NULL || pComponent != NULL );



    HRESULT hr = S_FALSE;

    if( TRUE == arg )
    {

        // Need IConsoleNameSpace

        // But to get that, first we need IConsole
        CComPtr<IConsole> spConsole;
        if( pComponentData != NULL )
        {
             spConsole = ((CSnapin*)pComponentData)->m_spConsole;
        }
        else
        {
            // We should have a non-null pComponent
             spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
        }
        _ASSERTE( spConsole != NULL );


        CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
        _ASSERT( spConsoleNameSpace != NULL );

        if(bIsExtension)
        {
            //
            // For extensions, keep the scope
            //
            ATLASSERT(m_scopeDataItem.ID == 0);
            m_scopeDataItem.ID = (HSCOPEITEM) param;
        }
        else
        {
            m_scopeDataItem.ID = (HSCOPEITEM) param;
        }
        hr = EnumerateScopeChildren( spConsoleNameSpace );
    }
    else    // arg != TRUE so not expanding
    {

        // do nothing for now -- I don't think arg = FALSE is even implemented
        // for MMC v. 1.0 or 1.1

    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::EnumerateScopeChildren

Don't override this in your derived class. Instead, override the method
it calls, PopulateScopeChildrenList.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::EnumerateScopeChildren( IConsoleNameSpace* pConsoleNameSpace )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithScopeChildrenList::EnumerateScopeChildren"));

    UNREFERENCED_PARAMETER (pConsoleNameSpace);

    // Check for preconditions:
    // None.


    HRESULT hr;

    if ( FALSE == m_bScopeChildrenListPopulated )
    {
        // We have not yet loaded all of our children into our list.
        hr = PopulateScopeChildrenList();
        if( FAILED(hr) )
        {
            return( hr );
        }

        // We've already loaded our children objects with
        // data necessary to populate the result pane.
        m_bScopeChildrenListPopulated = TRUE;   // We only want to do this once.
    }


    // We don't need any code here to InsertItem the children into the
    // scope pane as we did in the EnumerateScopeChildren method
    // for CNodeWithResultChildrenList.
    // This is one difference between adding nodes into the scope
    // pane and the result pane.  Because MMC takes care of replicating
    // scope pane changes to all views, we don't need to worry about
    // sending an UpdateAllViews notification and handling insertion
    // there for each result pane.  Instead, we just do InsertItem once.
    // So for CNodeWithScopePaneChildren, we call InsertItem
    // in the AddChild method which is called by PopulateScopeChildrenList
    // above.

    return S_OK;
}



#endif // _NODE_WITH_SCOPE_CHILDREN_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\wzconnecttoserver.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : WzConnectToServer.cpp                                 //
//                                                                         //
//  DESCRIPTION   : This file implements the dialog for retargeting to     //
//                  another running Microsoft Fax Server.                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun 26 2000 yossg    Create                                        //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "WzConnectToServer.h"

#include "Snapin.h"

#include "FxsValid.h"
#include "dlgutils.h"

#include <Objsel.h> //DSOP_SCOPE_INIT_INFO for DsObjectPicker

#include <windns.h> //DNS_MAX_NAME_BUFFER_LENGTH
/////////////////////////////////////////////////////////////////////////////
// CWzConnectToServer

CWzConnectToServer::CWzConnectToServer(CSnapInItem   *pNode)
             : CSnapInPropertyPageImpl<CWzConnectToServer>(NULL) 
{
    m_pRoot = static_cast<CFaxServerNode *>(pNode);
}



CWzConnectToServer::~CWzConnectToServer()
{
}

/*
 +  CWzConnectToServer::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CWzConnectToServer::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CWzConnectToServer::OnInitDialog"));
    HRESULT hRc = S_OK;    

    //
    // Attach controls
    //
    m_ServerNameEdit.Attach(GetDlgItem(IDC_CONNECT_COMPUTER_NAME_EDIT));
        
    //
    // Set length limit 
    //
    m_ServerNameEdit.SetLimitText(DNS_MAX_NAME_BUFFER_LENGTH);
    
	//
	// Init the other controls
	//
	CheckDlgButton(IDC_CONNECT_LOCAL_RADIO1, BST_CHECKED);
    CheckDlgButton(IDC_CONNECT_ANOTHER_RADIO2, BST_UNCHECKED);
	CheckDlgButton(IDC_CONNECT_OVERRIDE_CHECK, BST_UNCHECKED);
    
    //
    // Disable remote computer controls
    //
    EnableSpecifiedServerControls(FALSE);
    
    return 1;  
}

/*
 +  CWzConnectToServer::OnSetActive
 +
 *  Purpose:
 *      
 *      
 *  Arguments:
 *
 -  Return:
 -      TRUE or FALSE
 */
BOOL CWzConnectToServer::OnSetActive()
{
    DEBUG_FUNCTION_NAME( _T("CWzConnectToServer::OnSetActive"));

    //
	// Must use post message during the setactive message.
	//
    CWindow( GetParent() ).PostMessage( PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH );
	
	return TRUE;
}

/*
 +  CWzConnectToServer::OnWizardFinish
 +
 *  Purpose:
 *      To apply data when wizard finish .
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
BOOL CWzConnectToServer::OnWizardFinish()
{
    DEBUG_FUNCTION_NAME( _T("CWzConnectToServer::OnWizardFinish"));
    
    ATLASSERT (m_pRoot);

    HRESULT       hRc                       = S_OK;
    DWORD         ec                        = ERROR_SUCCESS;
    BOOL          fIsLocalServer            = TRUE;
    CComBSTR      bstrServerName            = L"";
    BOOL          fAllowOverrideServerName  = FALSE;

    //
    // Step 1: get data
    //
    fIsLocalServer = ( IsDlgButtonChecked(IDC_CONNECT_LOCAL_RADIO1) == BST_CHECKED );

    if(fIsLocalServer)
    {
        bstrServerName = L"";
        if (!bstrServerName) 
        {
           hRc = E_OUTOFMEMORY;

           goto Exit;
        }
    }
    else //!fIsLocalServer => the other server radio button was clicked.
    {
        //
        // 1.a: PreApply Checks
        //
        if ( !m_ServerNameEdit.GetWindowText(&bstrServerName))
        {
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&m_bstrGroupName)"));
            DlgMsgBox(this, IDS_FAIL2READ_GROUPNAME);
            ::SetFocus(GetDlgItem(IDC_CONNECT_COMPUTER_NAME_EDIT));
            hRc = S_FALSE;
            
            goto Exit;
        }

        //
        // Server Name initial \\ trancation (if they are there)
        //
        if (  ( _tcslen(bstrServerName.m_str) > 2 ) && ( 0 == wcsncmp( bstrServerName.m_str , _T("\\\\") , 2 ))   )
        {
            CComBSTR bstrTmp = _tcsninc(bstrServerName.m_str, 2);
            if (!bstrTmp)
            {
                DebugPrintEx(DEBUG_ERR,
			            _T("Out of memory -bstr allocation error."));
                DlgMsgBox(this, IDS_MEMORY);
                ::SetFocus(GetDlgItem(IDC_CONNECT_COMPUTER_NAME_EDIT));

                hRc = S_FALSE;
                goto Exit;
            }
            bstrServerName.Empty();
            bstrServerName = bstrTmp; // operator = is actually copy() here.
        }

        //
        // Server Name validity checks
        //
        UINT uRetIDS   = 0;
    
        if (!IsValidServerNameString(bstrServerName, &uRetIDS, TRUE /*DNS Name Length*/))
        {
		    ATLASSERT ( 0 == uRetIDS); 
            DebugPrintEx(DEBUG_ERR,
			        _T("Non valid server name."));
            DlgMsgBox(this, uRetIDS);
            ::SetFocus(GetDlgItem(IDC_CONNECT_COMPUTER_NAME_EDIT));
            hRc = S_FALSE;
 
   
            goto Exit;
        }
        


        if ( IsLocalServerName(bstrServerName.m_str) )
        {
            DebugPrintEx( DEBUG_MSG,
		    _T("The computer name %ws is the same as the name of the current managed server."),
            bstrServerName.m_str);
        
            bstrServerName = L"";
        }
    }

    //
    // Allow override
    //
    if (IsDlgButtonChecked(IDC_CONNECT_OVERRIDE_CHECK) == BST_CHECKED)   
    {
        fAllowOverrideServerName = TRUE;
    }
    //else: fAllowOverrideServerName = FALSE is the default;

    
    //
    // Step 2: passed the machine name and the permission to override
    //
    
    //
    // Redraw main node display name
    //
	hRc = m_pRoot->SetServerNameOnSnapinAddition(bstrServerName, fAllowOverrideServerName);
    if (S_OK != hRc )
    {
        //error message given by the called function
		DebugPrintEx( DEBUG_ERR,
		_T("Failed to SetServerNameOnSnapinAddition(bstrServerName)"));

        goto Exit;
    }
                        
    //
    // Step 3: Close the dialog
    //
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("The connection to the new server was done successfully."));
    goto Exit;

Exit:
    
    return (S_OK != hRc) ? FALSE : TRUE;
}


/*
 -  CWzConnectToServer::OnComputerRadioButtonClicked
 -
 *  Purpose:
 *      Check status OnComputerRadioButtonClicked
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CWzConnectToServer::OnComputerRadioButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER (wNotifyCode);
    UNREFERENCED_PARAMETER (wID);
    UNREFERENCED_PARAMETER (hWndCtl);
    UNREFERENCED_PARAMETER (bHandled);

    DEBUG_FUNCTION_NAME( _T("CWzConnectToServer::OnComputerRadioButtonClicked"));
	
    if ( IsDlgButtonChecked(IDC_CONNECT_ANOTHER_RADIO2) == BST_CHECKED )
    {        
        EnableSpecifiedServerControls(TRUE);
	    
        ::SetFocus(GetDlgItem(IDC_CONNECT_COMPUTER_NAME_EDIT));
    }
    else //connect to local server
    {
        EnableSpecifiedServerControls(FALSE);
    }

    return 1;
}


/*
 -  CWzConnectToServer::OnTextChanged
 -
 *  Purpose:
 *      Check the validity of text in side the text box.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CWzConnectToServer::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER (wNotifyCode);
    UNREFERENCED_PARAMETER (wID);
    UNREFERENCED_PARAMETER (hWndCtl);
    UNREFERENCED_PARAMETER (bHandled);

    DEBUG_FUNCTION_NAME( _T("CWzConnectToServer::OnTextChanged"));

    //actually in the current design, do nothing

    return 1;
}

/*
 -  CWzConnectToServer::EnableSpecifiedServerControls
 -
 *  Purpose:
 *      Enable/disable the specified server controls.
 *
 *  Arguments:
 *      [in] state - boolean value to enable TRUE or FALSE to disable
 *
 *  Return:
 *      void
 */
void CWzConnectToServer::EnableSpecifiedServerControls(BOOL fState)
{

    //
    // enable/disable controls
    //
    ::EnableWindow(GetDlgItem(IDC_CONNECT_COMPUTER_NAME_EDIT),   fState);
    ::EnableWindow(GetDlgItem(IDC_CONNECT_BROWSE4SERVER_BUTTON), fState);
}


/*
 -  CWzConnectToServer::OnBrowseForMachine
 -
 *  Purpose:
 *      Enable/disable the specified server controls.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
static UINT g_cfDsObjectPicker =
        RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

LRESULT CWzConnectToServer::OnBrowseForMachine(UINT /*uMsg*/, WPARAM /*wParam*/, HWND /*hwnd*/, BOOL& /*bHandled*/)
{
    HRESULT hr = S_OK;
    static const int     SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    DEBUG_FUNCTION_NAME( _T("CWzConnectToServer::OnBrowseForMachine"));
    
    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Since we just want computer objects from every scope, combine them
    // all in a single scope initializer.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    IDsObjectPicker *pDsObjectPicker = NULL;
    IDataObject *pdo = NULL;
    bool fGotStgMedium = false;
    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    do
    {
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        if(FAILED(hr))
            break;

        hr = pDsObjectPicker->Initialize(&InitInfo);
        if(FAILED(hr))
            break;

        hr = pDsObjectPicker->InvokeDialog(m_hWnd, &pdo);
        if(FAILED(hr))
            break;
        // Quit if user hit Cancel

        if (hr == S_FALSE)
        {
            break;
        }

        FORMATETC formatetc =
        {
            (CLIPFORMAT)g_cfDsObjectPicker,
            NULL,
            DVASPECT_CONTENT,
            -1,
            TYMED_HGLOBAL
        };

        hr = pdo->GetData(&formatetc, &stgmedium);
        if(FAILED(hr))
            break;

        fGotStgMedium = true;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            break;
        }

        ATLASSERT(pDsSelList->cItems == 1);

        //
        // Put the machine name in the edit control
        //

        SetDlgItemText(IDC_CONNECT_COMPUTER_NAME_EDIT, pDsSelList->aDsSelection[0].pwzName);
        
        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\emailconfigpage.h ===
#ifndef __EMAIL_CONFIG_PAGE_H_
#define __EMAIL_CONFIG_PAGE_H_
#include "resource.h"
//#include <atlsnap.h>
#include "..\..\inc\atlsnap.h"
#include <atlapp.h>
#include <atlctrls.h>
#include <faxmmc.h>
#include <faxutil.h>
#include <fxsapip.h>
#include <RoutingMethodConfig.h>

class CEmailConfigPage : public CSnapInPropertyPageImpl<CEmailConfigPage>
{
public :
    CEmailConfigPage(LONG_PTR lNotifyHandle, bool bDeleteHandle = false, TCHAR* pTitle = NULL ) : 
        m_lNotifyHandle(lNotifyHandle),
        m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
    {
        m_hFax = NULL;

        m_fIsDialogInitiated = FALSE;
        m_fIsDirty           = FALSE;
    }

    HRESULT Init(LPCTSTR lpctstrServerName, DWORD dwDeviceId);

    ~CEmailConfigPage()
    {

        DEBUG_FUNCTION_NAME(TEXT("CEmailConfigPage::~CEmailConfigPage"));
        if (m_hFax)
        {
            if (!FaxClose(m_hFax))
            {
                DWORD ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                    m_hFax,
                    m_bstrServerName,
                    ec);
            }
            m_hFax = NULL;
        }
        if (m_bDeleteHandle)
        {
            MMCFreeNotifyHandle(m_lNotifyHandle);
        }
    }

    enum { IDD = IDD_EMAIL };

BEGIN_MSG_MAP(CEmailConfigPage)
    MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog )
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnHelpRequest)
    MESSAGE_HANDLER(WM_HELP,        OnHelpRequest)
    CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CEmailConfigPage>)
    COMMAND_HANDLER(IDC_EDIT_MAILTO,        EN_CHANGE,  OnFieldChange)
END_MSG_MAP()

    HRESULT PropertyChangeNotify(long param)
    {
        return MMCPropertyChangeNotify(m_lNotifyHandle, param);
    }

    BOOL OnApply();

    LRESULT OnFieldChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        if (!m_fIsDialogInitiated) //event receieved in too early stage
        {
            return 0;
        }
        else
        {
            m_fIsDirty = TRUE;
            SetModified(TRUE);
            return 0;
        }
    }

    LRESULT OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled );

    LRESULT OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

public:
    LONG_PTR m_lNotifyHandle;
    bool m_bDeleteHandle;

private:
    HANDLE   m_hFax;  // Handle to fax server connection
    CComBSTR m_bstrServerName;
    DWORD    m_dwDeviceId;

    CComBSTR m_bstrMailTo;

    //
    // Controls
    //
    CEdit    m_edtMailTo;
    
    BOOL  m_fIsDialogInitiated;
    BOOL  m_fIsDirty;


};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\printconfigpage.cpp ===
#include "stdafx.h"
#include "RoutingMethodProp.h"
#include "RoutingMethodConfig.h"
#include <faxutil.h>
#include <faxreg.h>
#include <faxres.h>
#include <PrintConfigPage.h>
#include <Util.h>

HRESULT 
CPrintConfigPage::Init(
    LPCTSTR lpctstrServerName,
    DWORD dwDeviceId
)
{
    DEBUG_FUNCTION_NAME(TEXT("CPrintConfigPage::Init"));
    
    DWORD ec = ERROR_SUCCESS;

    m_bstrServerName = lpctstrServerName;
    m_dwDeviceId = dwDeviceId;
    if (!m_bstrServerName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Out of memory while copying server name (ec: %ld)")
        );
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DisplayRpcErrorMessage(ERROR_NOT_ENOUGH_MEMORY, IDS_PRINT_TITLE, m_hWnd);
        goto exit;
    }

    if (!FaxConnectFaxServer(lpctstrServerName, &m_hFax))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxConnectFaxServer failed (ec: %ld)"),
            ec);
        DisplayRpcErrorMessage(ec, IDS_PRINT_TITLE, m_hWnd);
        goto exit;
    }
    //
    // Retrieve the data
    //
    ec = ReadExtStringData (
                    m_hFax,
                    m_dwDeviceId,
                    REGVAL_RM_PRINTING_GUID,
                    m_bstrPrinter,
                    TEXT(""),
                    IDS_PRINT_TITLE,
                    m_hWnd);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReadExtStringData() failed. (ec: %ld)"),
                ec);

        goto exit;
    }

exit:

    if ((ERROR_SUCCESS != ec) && m_hFax)
    {
        if (!FaxClose(m_hFax))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                m_hFax,
                m_bstrServerName,
                GetLastError());
        }
        m_hFax = NULL;
    }
    return HRESULT_FROM_WIN32(ec);
}   // CPrintConfigPage::Init

LRESULT CPrintConfigPage::OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled
)
{
    DEBUG_FUNCTION_NAME( _T("CPrintConfigPage::OnInitDialog"));
    HINSTANCE   hInst = _Module.GetResourceInstance();
 
    SetLTRComboBox(m_hWnd, IDC_PRINTERS_COMBO);

    //
    // Attach controls
    //
    m_PrintersCombo.Attach(GetDlgItem(IDC_PRINTERS_COMBO));
    m_PrintersCombo.LimitText(MAX_PATH-1);
    //
    // Init printers drop-down box
    //
    m_pPrinterNames = CollectPrinterNames (&m_dwNumOfPrinters, TRUE);
    if (!m_pPrinterNames)
    {
        if (ERROR_PRINTER_NOT_FOUND == GetLastError ())
        {
            //
            // No printers
            //
        }
        else
        {
            //
            // Real error
            //
        }
        m_PrintersCombo.SetCurSel(-1);
        m_PrintersCombo.SetWindowText(m_bstrPrinter);
    }
    else
    {
        //
        // Success - fill in the combo-box
        //
        DWORD dw;
        LPCWSTR lpcwstrMatchingText;

        for (dw = 0; dw < m_dwNumOfPrinters; dw++)
        {
            m_PrintersCombo.AddString (m_pPrinterNames[dw].lpcwstrDisplayName);
        }
        //
        // Now find out if we match the data the server has
        //
        if (lstrlen(m_bstrPrinter))
        {
            //
            // Server has some name for printer
            //
            lpcwstrMatchingText = FindPrinterNameFromPath (m_pPrinterNames, m_dwNumOfPrinters, m_bstrPrinter);
            if (!lpcwstrMatchingText)
            {
                //
                // No match, just fill in the text we got from the server
                //
                m_PrintersCombo.SetCurSel(-1);
                m_PrintersCombo.SetWindowText(m_bstrPrinter);
            }
            else
            {
                m_PrintersCombo.SelectString(-1, lpcwstrMatchingText);
            }
        }
        else
        {
            //
            // No server configuation - select nothing
            //
        }
    }        
    m_fIsDialogInitiated = TRUE;
    return 1;
}


BOOL 
CPrintConfigPage::OnApply()
{
    DEBUG_FUNCTION_NAME(TEXT("CPrintConfigPage::OnApply"));

    if (!m_fIsDirty)
    {
        return TRUE;
    }
    //
    // Get the selected printer name
    //
    if (!m_PrintersCombo.GetWindowText(&m_bstrPrinter))
    {
        DebugPrintEx( DEBUG_ERR, _T("Out of Memory - fail to set string."));
        DisplayErrorMessage (IDS_PRINT_TITLE, IDS_FAIL2READPRINTER, FALSE, m_hWnd);
        return FALSE;
    }
    //
    // Check data validity
    //
    if (0 == m_bstrPrinter.Length())
    {
        DebugPrintEx( DEBUG_ERR, _T("Zero length string."));
        DisplayErrorMessage (IDS_PRINT_TITLE, IDS_EMPTY_PRINTERNAME, FALSE, m_hWnd);
        return FALSE;
    }
    //
    // Attempt to convert printer name to path 
    //
    LPCWSTR lpcwstrPrinterPath = FindPrinterPathFromName (m_pPrinterNames, m_dwNumOfPrinters, m_bstrPrinter);
    if (lpcwstrPrinterPath)
    {
        //
        // We have a matching path - replace name with path.
        //
        m_bstrPrinter = lpcwstrPrinterPath;
        if (!m_bstrPrinter)
        {
            DebugPrintEx( DEBUG_ERR, _T("Out of Memory - fail to alloc string."));
            DisplayErrorMessage (IDS_PRINT_TITLE, IDS_FAIL2READPRINTER, FALSE, m_hWnd);
            return FALSE;
        }
    }
    //
    // Write the data using RPC
    //        
    if (ERROR_SUCCESS != WriteExtData (m_hFax,
                                       m_dwDeviceId, 
                                       REGVAL_RM_PRINTING_GUID, 
                                       (LPBYTE)(LPCWSTR)m_bstrPrinter, 
                                       sizeof (WCHAR) * (1 + m_bstrPrinter.Length()),
                                       IDS_PRINT_TITLE,
                                       m_hWnd))
    {
        return FALSE;
    }
    //        
    // Success
    //
    m_fIsDirty = FALSE;
    return TRUE;
}   // CPrintConfigPage::OnApply


/*
 +
 +
 *  CPrintConfigPage::OnComboChanged
 -
 -      
 */
LRESULT 
CPrintConfigPage::OnComboChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CPrintConfigPage::OnComboChanged"));


    if (!m_fIsDialogInitiated) //event was receieved in a too early stage
    {
        return 0;
    }
    else
    {
        switch (wNotifyCode)
        {
            case CBN_SELCHANGE:  //assumption: all the registered printer names are valid
                SetModified(TRUE);  
                m_fIsDirty = TRUE;

                break;

            case CBN_EDITCHANGE:
                if ( 0 == m_PrintersCombo.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                }
                else
                {
                    SetModified(TRUE);
                    m_fIsDirty = TRUE;
                }
                break;

            default:
                ATLASSERT(FALSE);
         }
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPrintConfigPage::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CPrintConfigPage::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CPrintConfigPage::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\wzconnecttoserver.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : WzConnectToServer.h                                   //
//                                                                         //
//  DESCRIPTION   : Header file for the CWzConnectToServer class.         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun 26 2000 yossg   Create                                         //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef WZ_CONNECT2SERVER_H_INCLUDED
#define WZ_CONNECT2SERVER_H_INCLUDED

#include "proppageex.h"

/////////////////////////////////////////////////////////////////////////////
// CWzConnectToServer
class CFaxServerNode;

class CWzConnectToServer : public CSnapInPropertyPageImpl<CWzConnectToServer>
{
public:
    
    //
    // Constructor
    //
    CWzConnectToServer(CSnapInItem  *pNode);
    ~CWzConnectToServer();

    enum { IDD = IDD_CONNECT_TO_WIZARD };

BEGIN_MSG_MAP(CWzConnectToServer)
    MESSAGE_HANDLER( WM_INITDIALOG,  OnInitDialog)
        
    COMMAND_HANDLER(IDC_CONNECT_COMPUTER_NAME_EDIT,    EN_CHANGE,  OnTextChanged)
    COMMAND_HANDLER(IDC_CONNECT_LOCAL_RADIO1  ,        BN_CLICKED, OnComputerRadioButtonClicked)
    COMMAND_HANDLER(IDC_CONNECT_ANOTHER_RADIO2,        BN_CLICKED, OnComputerRadioButtonClicked)

    COMMAND_HANDLER(IDC_CONNECT_BROWSE4SERVER_BUTTON,  BN_CLICKED, OnBrowseForMachine)
    
    CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CWzConnectToServer>)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    BOOL    OnWizardFinish(); //when the wizard finishes

    BOOL    OnSetActive();
    
    LRESULT OnTextChanged                (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnComputerRadioButtonClicked (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnBrowseForMachine(UINT uMsg, WPARAM wParam, HWND hwnd, BOOL& bHandled);

private:
    //
    // Methods
    //
    VOID      EnableSpecifiedServerControls(BOOL fState);

    //
    // Controls
    //
    CEdit     m_ServerNameEdit;

    //
    // Pointer to the node
    //
    CFaxServerNode * m_pRoot;
};

#endif // WZ_CONNECT2SERVER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// Incoming Routing Configuration resource ID file  //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [10000 - 10499]                                  //
//                                                  //
//////////////////////////////////////////////////////

#define IDD_STORE                       10001 
#define IDS_ROUTINGMETHODCONFIG_DESC    10002 
#define IDS_ROUTINGMETHODCONFIG_PROVIDER 10003 
#define IDR_ROUTINGMETHODCONFIG         10005 
#define IDS_ERR_BAD_ROUTINGMETHOD_CONFIGURATION 10006 
#define IDS_STORE_TITLE                 10007 
#define IDS_PRINT_TITLE                 10008 
#define IDS_EMAIL_TITLE                 10009 
#define IDS_FOLDER_EMPTY                10010 
#define IDS_PRINTER_INVALID             10011 
#define IDS_EMAIL_ADDR_INVALID          10012 
#define IDS_FAIL2LOADPRINTERLIST        10013 
#define IDS_SELECT_FOLDER               10015 
#define IDS_FAIL2READPRINTER            10016 
#define IDS_EMPTY_PRINTERNAME           10017 
#define IDS_FOLDER_INVALID              10018 
#define IDI_SMTP                        10019 
#define IDI_STORE                       10020 
#define IDI_PRINT                       10021 
#define IDC_EDIT_FOLDER                 10023 
#define IDD_PRINT                       10024 
#define IDC_BUT_BROWSE                  10025 
#define IDD_EMAIL                       10026 
#define IDC_PRINTERS_COMBO              10027 
#define IDC_EDIT_MAILTO                 10028 
#define IDC_USER_ACCOUNT_HELP_LINK      10029 
#define IDI_SNAPIN                      10030
#define IDS_FAX_ROUTING_SNAPIN_NAME     10031 // Do not change. Used by RGS file.

//////////////////////////////////////////////////////
//                                                  //
// Incoming Routing Configuration resource ID file  //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [10000 - 10499]                                  //
//                                                  //
//////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\printconfigpage.h ===
#ifndef __PRINT_CONFIG_PAGE_H_
#define __PRINT_CONFIG_PAGE_H_
#include "resource.h"
//#include <atlsnap.h>
#include "..\..\inc\atlsnap.h"
#include <atlapp.h>
#include <atlctrls.h>
#include <faxmmc.h>
#include <faxutil.h>
#include <fxsapip.h>
#include <RoutingMethodConfig.h>

class CPrintConfigPage : public CSnapInPropertyPageImpl<CPrintConfigPage>
{
public :
    CPrintConfigPage(LONG_PTR lNotifyHandle, bool bDeleteHandle = false, TCHAR* pTitle = NULL ) : 
        m_lNotifyHandle(lNotifyHandle),
        m_bDeleteHandle(bDeleteHandle), // Should be true for only page.
        m_pPrinterNames(NULL),
        m_hFax(NULL),
        m_fIsDialogInitiated(FALSE),
        m_fIsDirty(FALSE),
        m_dwNumOfPrinters(0)
    {}

    HRESULT Init(LPCTSTR lpctstrServerName, DWORD dwDeviceId);

    ~CPrintConfigPage()
    {

        DEBUG_FUNCTION_NAME(TEXT("CPrintConfigPage::~CPrintConfigPage"));

        if (m_pPrinterNames)
        {
            ReleasePrinterNames (m_pPrinterNames, m_dwNumOfPrinters);
        }

        if (m_hFax)
        {
            if (!FaxClose(m_hFax))
            {
                DWORD ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                    m_hFax,
                    m_bstrServerName,
                    ec);
            }
            m_hFax = NULL;
        }
        if (m_bDeleteHandle)
        {
            MMCFreeNotifyHandle(m_lNotifyHandle);
        }

    }

    enum { IDD = IDD_PRINT };

BEGIN_MSG_MAP(CPrintConfigPage)
    MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog )
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnHelpRequest)
    MESSAGE_HANDLER(WM_HELP,        OnHelpRequest)
    CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CPrintConfigPage>)
    COMMAND_HANDLER(IDC_PRINTERS_COMBO, CBN_SELCHANGE, OnComboChanged)
    COMMAND_HANDLER(IDC_PRINTERS_COMBO, CBN_EDITCHANGE,OnComboChanged)
END_MSG_MAP()

    HRESULT PropertyChangeNotify(long param)
    {
        return MMCPropertyChangeNotify(m_lNotifyHandle, param);
    }

    BOOL OnApply();

    LRESULT OnFieldChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        if (!m_fIsDialogInitiated) //event receieved in too early stage
        {
            return 0;
        }
        else
        {
            m_fIsDirty = TRUE;
            SetModified(TRUE);
            return 0;
        }

    }

    LRESULT OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled );

    LRESULT OnComboChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

public:
    LONG_PTR m_lNotifyHandle;
    bool m_bDeleteHandle;

private:
    HANDLE   m_hFax;  // Handle to fax server connection
    CComBSTR m_bstrServerName;
    DWORD    m_dwDeviceId;

    CComBSTR m_bstrPrinter;

    DWORD          m_dwNumOfPrinters;
    PPRINTER_NAMES m_pPrinterNames;
    
    //
    // Controls
    //
    CComboBox     m_PrintersCombo;

    BOOL          m_fIsDialogInitiated;
    BOOL          m_fIsDirty;

};



HRESULT 
SetComboBoxItem  (CComboBox    combo, 
                  DWORD        comboBoxIndex, 
                  LPCTSTR      lpctstrFieldText,
                  DWORD        dwItemData,
                  HINSTANCE    hInst = NULL);
HRESULT 
AddComboBoxItem  (CComboBox    combo, 
                  LPCTSTR      lpctstrFieldText,
                  DWORD        dwItemData,
                  HINSTANCE    hInst = NULL);

HRESULT 
SelectComboBoxItemData  (CComboBox combo, DWORD_PTR dwItemData);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\emailconfigpage.cpp ===
#include "stdafx.h"
#include "RoutingMethodProp.h"
#include "RoutingMethodConfig.h"
#include <faxutil.h>
#include <faxreg.h>
#include <faxres.h>
#include <EmailConfigPage.h>
#include <Util.h>

HRESULT 
CEmailConfigPage::Init(
    LPCTSTR lpctstrServerName,
    DWORD dwDeviceId
)
{
    DEBUG_FUNCTION_NAME(TEXT("CEmailConfigPage::Init"));
    
    DWORD ec = ERROR_SUCCESS;

    m_bstrServerName = lpctstrServerName;
    m_dwDeviceId = dwDeviceId;
    if (!m_bstrServerName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Out of memory while copying server name (ec: %ld)")
        );
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DisplayRpcErrorMessage(ERROR_NOT_ENOUGH_MEMORY, IDS_EMAIL_TITLE, m_hWnd);
        goto exit;
    }

    if (!FaxConnectFaxServer(lpctstrServerName, &m_hFax))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxConnectFaxServer failed (ec: %ld)"),
            ec);
        DisplayRpcErrorMessage(ec, IDS_EMAIL_TITLE, m_hWnd);
        goto exit;
    }
    //
    // Retrieve the data
    //
    ec = ReadExtStringData (
                    m_hFax,
                    m_dwDeviceId,
                    REGVAL_RM_EMAIL_GUID,
                    m_bstrMailTo,
                    TEXT(""),
                    IDS_EMAIL_TITLE,
                    m_hWnd);

exit:

    if ((ERROR_SUCCESS != ec) && m_hFax)
    {
        if (!FaxClose(m_hFax))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                m_hFax,
                m_bstrServerName,
                GetLastError());
        }
        m_hFax = NULL;
    }
    return HRESULT_FROM_WIN32(ec);
}   // CEmailConfigPage::Init

LRESULT CEmailConfigPage::OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled
)
{
    DEBUG_FUNCTION_NAME( _T("CEmailConfigPage::OnInitDialog"));

    //
    // An edit control should be LTR
    //
	SetLTREditDirection (m_hWnd,IDC_EDIT_MAILTO);

    //
    // Attach and set values to the controls
    //
    m_edtMailTo.Attach (GetDlgItem (IDC_EDIT_MAILTO));
    m_edtMailTo.SetWindowText (m_bstrMailTo);

    m_fIsDialogInitiated = TRUE;

    return 1;
}


BOOL 
CEmailConfigPage::OnApply()
{
    DEBUG_FUNCTION_NAME(TEXT("CEmailConfigPage::OnApply"));

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    //
    // Collect data from the controls
    //
    m_edtMailTo.GetWindowText (m_bstrMailTo.m_str);
    //
    // Check data validity
    //
    if (!m_bstrMailTo.Length())
    {
        DisplayErrorMessage (IDS_EMAIL_TITLE, IDS_EMAIL_ADDR_INVALID, FALSE, m_hWnd);
        return FALSE;
    }
    //
    // Validation passed. Now write the data using RPC
    //        
    if (ERROR_SUCCESS != WriteExtData (m_hFax,
                                       m_dwDeviceId, 
                                       REGVAL_RM_EMAIL_GUID, 
                                       (LPBYTE)(LPCWSTR)m_bstrMailTo, 
                                       sizeof (WCHAR) * (1 + m_bstrMailTo.Length()),
                                       IDS_EMAIL_TITLE,
                                       m_hWnd))
    {
        return FALSE;
    }
    
        
    //Success
    m_fIsDirty = FALSE;
    
    return TRUE;
}   // CEmailConfigPage::OnApply

//////////////////////////////////////////////////////////////////////////////
/*++

CEmailConfigPage::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CEmailConfigPage::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CEmailConfigPage::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\routingmethodconfig.cpp ===
#include "stdafx.h"
#include "RoutingMethodProp.h"
#include "RoutingMethodConfig.h"
#include <faxutil.h>
#include <faxreg.h>
#include <faxres.h>
#include <StoreConfigPage.h>
#include <PrintConfigPage.h>
#include <EmailConfigPage.h>
#include <Util.h>

/////////////////////////////////////////////////////////////////////////////
// CRoutingMethodConfigComponentData
static const GUID CRoutingMethodConfigExtGUID_NODETYPE = FAXSRV_ROUTING_METHOD_NODETYPE_GUID;

const GUID*    CRoutingMethodConfigExtData::m_NODETYPE = &CRoutingMethodConfigExtGUID_NODETYPE;
const OLECHAR* CRoutingMethodConfigExtData::m_SZNODETYPE = FAXSRV_ROUTING_METHOD_NODETYPE_GUID_STR;
const OLECHAR* CRoutingMethodConfigExtData::m_SZDISPLAY_NAME = OLESTR("RoutingMethodConfig");
const CLSID*   CRoutingMethodConfigExtData::m_SNAPIN_CLASSID = &CLSID_RoutingMethodConfig;

HRESULT 
CRoutingMethodConfigExtData::QueryPagesFor(
    DATA_OBJECT_TYPES type
)
{
    DEBUG_FUNCTION_NAME(TEXT("CRoutingMethodConfigExtData::QueryPagesFor"));
    return S_OK;
}   // CRoutingMethodConfigExtData::QueryPagesFor

HRESULT 
CRoutingMethodConfigExtData::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR                handle, 
    IUnknown               *pUnk,
    DATA_OBJECT_TYPES       type
)
{
    DEBUG_FUNCTION_NAME(TEXT("CRoutingMethodConfigExtData::CreatePropertyPages"));

    WCHAR szMethodGuid[FAXSRV_MAX_GUID_LEN + 1];
    WCHAR szServer[FAXSRV_MAX_SERVER_NAME + 1];
    DWORD dwDeviceId;

    HRESULT hr;


    hr = GetDWORDFromDataObject(m_pDataObject,m_CCF_DEVICE_ID,&dwDeviceId);
    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetDeviceIdFromDataObject failed. hr = 0x%08X"),
            hr);
        return hr;
    }

    //
    // only for device incoming methods 
    // will not showup while called under the catalog of the global methods
    //
    if (dwDeviceId == 0) //==FXS_GLOBAL_METHOD_DEVICE_ID
    {
        return E_UNEXPECTED;
    }

    hr = GetStringFromDataObject(m_pDataObject,
                                 m_CCF_METHOD_GUID, 
                                 szMethodGuid, 
                                 sizeof(szMethodGuid)/sizeof(WCHAR));
    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetStringFromDataObject for m_CCF_METHOD_GUID failed. hr = 0x%08X"),
            hr);
        return hr;
    }
    hr = GetStringFromDataObject(m_pDataObject, 
                                 m_CCF_SERVER_NAME, 
                                 szServer,
                                 sizeof(szServer)/sizeof(WCHAR));
    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetStringFromDataObject for m_CCF_SERVER_NAME failed. hr = 0x%08X"),
            hr);
        return hr;
    }

    //
    // This snap-in configures the following methods: Store / Print / Email
    //            
    CComBSTR bstrPageTitle;
    if (CSTR_EQUAL == CompareString(LOCALE_INVARIANT,
                                    NORM_IGNORECASE, 
                                    szMethodGuid,
                                    -1,
                                    REGVAL_RM_FOLDER_GUID,
                                    -1))
    {
        bstrPageTitle.LoadString(IDS_STORE_TITLE);
        if (!bstrPageTitle)
        {
            return E_UNEXPECTED;
        }
        CStoreConfigPage* pPage = new CStoreConfigPage(handle, true, bstrPageTitle); // true = only one page
        if (!pPage)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate CStoreConfigPage")
                );
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        hr = pPage->Init(szServer, dwDeviceId);
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to Init CStoreConfigPage (hr = 0x%08x)"),
                hr
                );
            delete pPage;
            return hr;
        }
        HPROPSHEETPAGE hPage = pPage->Create ();
        if (NULL == hPage)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to Create CStoreConfigPage (hr = 0x%08x)"),
                hr
                );
            delete pPage;
            return hr;
        }
        hr = lpProvider->AddPage (hPage);
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to add page (hr = 0x%08x)"),
                hr
                );
            DestroyPropertySheetPage (hPage);
            delete pPage;
            return hr;
        }
    }
    else if (CSTR_EQUAL == CompareString(LOCALE_INVARIANT,
                                         NORM_IGNORECASE, 
                                         szMethodGuid,
                                         -1,
                                         REGVAL_RM_PRINTING_GUID,
                                         -1))
    {
    
        bstrPageTitle.LoadString(IDS_PRINT_TITLE);
        if (!bstrPageTitle)
        {
            return E_UNEXPECTED;
        }
        CPrintConfigPage* pPage = new CPrintConfigPage(handle, true, bstrPageTitle); // true = only one page
        if (!pPage)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate CPrintConfigPage")
                );
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        hr = pPage->Init(szServer, dwDeviceId);
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to Init CPrintConfigPage (hr = 0x%08x)"),
                hr
                );
            delete pPage;
            return hr;
        }
        HPROPSHEETPAGE hPage = pPage->Create ();
        if (NULL == hPage)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to Create CPrintConfigPage (hr = 0x%08x)"),
                hr
                );
            delete pPage;
            return hr;
        }
        hr = lpProvider->AddPage (hPage);
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to add page (hr = 0x%08x)"),
                hr
                );
            DestroyPropertySheetPage (hPage);
            delete pPage;
            return hr;
        }
    }
    else if (CSTR_EQUAL == CompareString(LOCALE_INVARIANT,
                                         NORM_IGNORECASE, 
                                         szMethodGuid,
                                         -1,
                                         REGVAL_RM_EMAIL_GUID,
                                         -1))
    {
    
        bstrPageTitle.LoadString(IDS_EMAIL_TITLE);
        if (!bstrPageTitle)
        {
            return E_UNEXPECTED;
        }
        CEmailConfigPage* pPage = new CEmailConfigPage(handle, true, bstrPageTitle); // true = only one page
        if (!pPage)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate CEmailConfigPage")
                );
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        hr = pPage->Init(szServer, dwDeviceId);
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to Init CEmailConfigPage (hr = 0x%08x)"),
                hr
                );
            delete pPage;
            return hr;
        }
        HPROPSHEETPAGE hPage = pPage->Create ();
        if (NULL == hPage)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to Create CEmailConfigPage (hr = 0x%08x)"),
                hr
                );
            delete pPage;
            return hr;
        }
        hr = lpProvider->AddPage (hPage);
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to add page (hr = 0x%08x)"),
                hr
                );
            DestroyPropertySheetPage (hPage);
            delete pPage;
            return hr;
        }
    }
    else
    {
        //
        // Unsupported routing method
        //
        return S_FALSE;
    }
    return S_OK;
}   // CRoutingMethodConfigExtData::CreatePropertyPages
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\routingmethodconfig.h ===
#ifndef __ROUTINGMETHODCONFIG_H_
#define __ROUTINGMETHODCONFIG_H_
#include "resource.h"
//#include <atlsnap.h>
#include "..\..\inc\atlsnap.h"
#include "cVerNum.h"
#include <atlapp.h>
#include <atlctrls.h>
#include <faxmmc.h>
#include <faxutil.h>
#include <fxsapip.h>

class CRoutingMethodConfigExtData : public CSnapInItemImpl<CRoutingMethodConfigExtData, TRUE>
{
public:
    static const GUID* m_NODETYPE;
    static const OLECHAR* m_SZNODETYPE;
    static const OLECHAR* m_SZDISPLAY_NAME;
    static const CLSID* m_SNAPIN_CLASSID;
 
    CLIPFORMAT m_CCF_METHOD_GUID;
    CLIPFORMAT m_CCF_SERVER_NAME;
    CLIPFORMAT m_CCF_DEVICE_ID;

    
    CRoutingMethodConfigExtData()
    {
        memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
        memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
        m_CCF_METHOD_GUID = 0;
        m_CCF_SERVER_NAME = 0;
        m_CCF_DEVICE_ID = 0;
    }

    ~CRoutingMethodConfigExtData()
    {
    }

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type);

    IDataObject* m_pDataObject;
    virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
    {
        DEBUG_FUNCTION_NAME(TEXT("CRoutingMethodConfigExtData::InitDataClass"));
        m_pDataObject = pDataObject;
        // The default code stores off the pointer to the Dataobject the class is wrapping
        // at the time. 
        // Alternatively you could convert the dataobject to the internal format
        // it represents and store that information
        //
        // Register clipboard formats if they are not registered yet
        if (!m_CCF_METHOD_GUID)
        {
            m_CCF_METHOD_GUID = (CLIPFORMAT) RegisterClipboardFormat(CF_MSFAXSRV_ROUTING_METHOD_GUID);
            if (!m_CCF_METHOD_GUID)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to registet clipformat : %s (ec: %ld)"),
                    CF_MSFAXSRV_ROUTING_METHOD_GUID,
                    GetLastError());
            }
        }

        if (!m_CCF_SERVER_NAME)
        {
            m_CCF_SERVER_NAME = (CLIPFORMAT) RegisterClipboardFormat(CF_MSFAXSRV_SERVER_NAME);
            if (!m_CCF_SERVER_NAME)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to registet clipformat : %s (ec: %ld)"),
                    CF_MSFAXSRV_SERVER_NAME,
                    GetLastError());
            }
        }

        if (!m_CCF_DEVICE_ID)
        {
            m_CCF_DEVICE_ID = (CLIPFORMAT) RegisterClipboardFormat(CF_MSFAXSRV_DEVICE_ID);
            if (!m_CCF_DEVICE_ID)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to registet clipformat : %s (ec: %ld)"),
                    CF_MSFAXSRV_DEVICE_ID,
                    GetLastError());
            }
        }


    }

    CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
    {
        // Modify to return a different CSnapInItem* pointer.
        return pDefault;
    }

};
class CRoutingMethodConfig : public CComObjectRootEx<CComSingleThreadModel>,
public CSnapInObjectRoot<0, CRoutingMethodConfig>,
    public IExtendPropertySheetImpl<CRoutingMethodConfig>,
    public CComCoClass<CRoutingMethodConfig, &CLSID_RoutingMethodConfig>
{
public:
    CRoutingMethodConfig()
    {
        m_pComponentData = this;
    }

EXTENSION_SNAPIN_DATACLASS(CRoutingMethodConfigExtData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CRoutingMethodConfig)
    EXTENSION_SNAPIN_NODEINFO_ENTRY(CRoutingMethodConfigExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CRoutingMethodConfig)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_ROUTINGMETHODCONFIG)

DECLARE_NOT_AGGREGATABLE(CRoutingMethodConfig)


    static void WINAPI ObjectMain(bool bStarting)
    {
        if (bStarting)
            CSnapInItem::Init();
    }
};

class ATL_NO_VTABLE CRoutingMethodConfigAbout : public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass< CRoutingMethodConfigAbout, &CLSID_RoutingMethodConfigAbout>
{
public:
    DECLARE_REGISTRY(CRoutingMethodConfigAbout, _T("RoutingMethodConfigAbout.1"), _T("RoutingMethodConfigAbout.1"), IDS_ROUTINGMETHODCONFIG_DESC, THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CRoutingMethodConfigAbout)
        COM_INTERFACE_ENTRY(ISnapinAbout)
    END_COM_MAP()

    STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
    {
        USES_CONVERSION;
        TCHAR szBuf[256];
        if (::LoadString(_Module.GetResourceInstance(), IDS_ROUTINGMETHODCONFIG_DESC, szBuf, 256) == 0)
            return E_FAIL;

        *lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpDescription == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpDescription, T2OLE(szBuf));

        return S_OK;
    }

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
    {
        USES_CONVERSION;
        TCHAR szBuf[256];
        if (::LoadString(_Module.GetResourceInstance(), IDS_ROUTINGMETHODCONFIG_PROVIDER, szBuf, 256) == 0)
            return E_FAIL;

        *lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpName == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpName, T2OLE(szBuf));

        return S_OK;
    }

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
    {
        USES_CONVERSION;
        TCHAR szBuf[256];
        swprintf(szBuf, TEXT(" %d.%d.%d"), rmj, rmm, rup);
        *lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpVersion == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpVersion, T2OLE(szBuf));
    
        return S_OK;
    }

    STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
    {
        *hAppIcon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_SNAPIN));
        return S_OK;
    }

    STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
        HBITMAP *hSmallImageOpen,
        HBITMAP *hLargeImage,
        COLORREF *cMask)
    {
        *hSmallImageOpen = *hLargeImage = *hLargeImage = 0;
        return S_OK;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\t30ext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A10F8379_F7DD_40F2_9C23_5D7A631C3565__INCLUDED_)
#define AFX_STDAFX_H__A10F8379_F7DD_40F2_9C23_5D7A631C3565__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A10F8379_F7DD_40F2_9C23_5D7A631C3565__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\t30ext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A10F8379_F7DD_40F2_9C23_5D7A631C3565__INCLUDED_)
#define AFX_STDAFX_H__A10F8379_F7DD_40F2_9C23_5D7A631C3565__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A10F8379_F7DD_40F2_9C23_5D7A631C3565__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\routingmethodpropsheetext.cpp ===
// RoutingMethodPropSheetExt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f RoutingMethodPropSheetExtps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "RoutingMethodProp.h"
#include "RoutingMethodProp_i.c"
#include "RoutingMethodConfig.h"
#include <faxres.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RoutingMethodConfig,      CRoutingMethodConfig)
OBJECT_ENTRY(CLSID_RoutingMethodConfigAbout, CRoutingMethodConfigAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ROUTINGMETHODPROPSHEETEXTLib);
        DisableThreadLibraryCalls(hInstance);

        _Module.m_hInstResource = GetResInstance(hInstance);
        if(!_Module.m_hInstResource)
        {
            return FALSE;
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        FreeResInstance();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    //
    // registers object, typelib and all interfaces in typelib
    //
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\storeconfigpage.cpp ===
#include "stdafx.h"
#include "RoutingMethodProp.h"
#include "RoutingMethodConfig.h"
#include <shlobj.h>
#include <faxutil.h>
#include <faxreg.h>
#include <faxres.h>
#include <StoreConfigPage.h>
#include <Util.h>

HRESULT 
CStoreConfigPage::Init(
    LPCTSTR lpctstrServerName,
    DWORD dwDeviceId
)
{
    DEBUG_FUNCTION_NAME(TEXT("CStoreConfigPage::Init"));
    
    DWORD ec = ERROR_SUCCESS;

    m_bstrServerName = lpctstrServerName;
    m_dwDeviceId = dwDeviceId;
    if (!m_bstrServerName)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(DEBUG_ERR, TEXT("Out of memory while copying server name (ec: %ld)"), ec);
        DisplayRpcErrorMessage(ERROR_NOT_ENOUGH_MEMORY, IDS_STORE_TITLE, m_hWnd);
        goto exit;
    }

    if (!FaxConnectFaxServer(lpctstrServerName, &m_hFax))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxConnectFaxServer failed (ec: %ld)"),
            ec);
        DisplayRpcErrorMessage(ec, IDS_STORE_TITLE, m_hWnd);
        goto exit;
    }
    //
    // Retrieve the data
    //
    ec = ReadExtStringData (
                    m_hFax,
                    m_dwDeviceId,
                    REGVAL_RM_FOLDER_GUID,
                    m_bstrFolder,
                    TEXT(""),
                    IDS_STORE_TITLE,
                    m_hWnd);

exit:

    if ((ERROR_SUCCESS != ec) && m_hFax)
    {
        if (!FaxClose(m_hFax))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                m_hFax,
                m_bstrServerName,
                GetLastError());
        }
        m_hFax = NULL;
    }
    return HRESULT_FROM_WIN32(ec);
}   // CStoreConfigPage::Init

LRESULT CStoreConfigPage::OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled
)
{
    DEBUG_FUNCTION_NAME( _T("CStoreConfigPage::OnInitDialog"));

    //
    // An edit control should be LTR
    //
	SetLTREditDirection (m_hWnd,IDC_EDIT_FOLDER);

    //
    // Attach and set values to the controls
    //
    m_edtFolder.Attach (GetDlgItem (IDC_EDIT_FOLDER));
    m_edtFolder.SetWindowText (m_bstrFolder);
    m_edtFolder.SetLimitText (MAX_PATH);
    SHAutoComplete (GetDlgItem (IDC_EDIT_FOLDER), SHACF_FILESYSTEM);

    m_fIsDialogInitiated = TRUE;

    if ( 0 != m_bstrServerName.Length()) //not a local server
    {
        ::EnableWindow(GetDlgItem(IDC_BUT_BROWSE), FALSE); 
    }

    return 1;
}

BOOL
DirectoryExists(
    LPTSTR  pDirectoryName
    )

/*++

Routine Description:

    Check the existancy of given folder name

Arguments:

    pDirectoryName - point to folder name

Return Value:

    if the folder exists, return TRUE; else, return FALSE.

--*/

{
    DWORD   dwFileAttributes;

    if(!pDirectoryName || lstrlen(pDirectoryName) == 0)
    {
        return FALSE;
    }

    dwFileAttributes = GetFileAttributes(pDirectoryName);

    if ( dwFileAttributes != 0xffffffff &&
         dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) 
    {
        return TRUE;
    }
    return FALSE;
}


BOOL 
CStoreConfigPage::OnApply()
{
    DEBUG_FUNCTION_NAME(TEXT("CStoreConfigPage::OnApply"));

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    //
    // Collect data from the controls
    //
    m_edtFolder.GetWindowText (m_bstrFolder.m_str);

    if (!m_bstrFolder.Length())
    {
        DisplayErrorMessage (IDS_STORE_TITLE, IDS_FOLDER_EMPTY, FALSE, m_hWnd);
        return FALSE;
    }

    if(!FaxCheckValidFaxFolder(m_hFax, m_bstrFolder))
    {
        DWORD dwRes = ::GetLastError();
        DebugPrintEx(DEBUG_ERR, TEXT("FaxCheckValidFaxFolder failed (ec: %ld)"), dwRes);

        //
        // Try to adjust folder
        // 
        PropSheet_SetCurSelByID( GetParent(), IDD);
        GotoDlgCtrl(GetDlgItem(IDC_EDIT_FOLDER));

        dwRes = AskUserAndAdjustFaxFolder(m_hWnd, m_bstrServerName, m_bstrFolder, dwRes);
        if(ERROR_SUCCESS != dwRes) 
        {
            if(ERROR_BAD_PATHNAME != dwRes)
            {
                //
                // The error message has not been shown by AskUserAndAdjustFaxFolder
                //
                DisplayErrorMessage (IDS_STORE_TITLE, IDS_FOLDER_INVALID, FALSE, m_hWnd);
            }
            return FALSE;
        }
    }

    //
    // Validation passed. Now write the data using RPC
    //        
    if (ERROR_SUCCESS != WriteExtData (m_hFax,
                                       m_dwDeviceId, 
                                       REGVAL_RM_FOLDER_GUID, 
                                       (LPBYTE)(LPCWSTR)m_bstrFolder, 
                                       sizeof (WCHAR) * (1 + m_bstrFolder.Length()),
                                       IDS_STORE_TITLE,
                                       m_hWnd))
    {
        return FALSE;
    }
        
        
    //Success
    m_fIsDirty = FALSE;
    
    return TRUE;

}   // CStoreConfigPage::OnApply

CComBSTR CStoreConfigPage::m_bstrFolder;

int CALLBACK
BrowseCallbackProc(
    HWND hwnd,
    UINT uMsg,
    LPARAM lp, 
    LPARAM pData
) 
{
    switch(uMsg) 
    {
        case BFFM_INITIALIZED: 
        {
            LPCWSTR lpcwstrCurrentFolder = CStoreConfigPage::GetFolder();
            ::SendMessage (hwnd, 
                           BFFM_SETSELECTION,
                           TRUE,    // Passing a path string and not a pidl.
                           (LPARAM)(lpcwstrCurrentFolder));
            break;
        }

        case BFFM_SELCHANGED:
        {
            BOOL bFolderIsOK = FALSE;
            TCHAR szPath [MAX_PATH + 1];

            if (SHGetPathFromIDList ((LPITEMIDLIST) lp, szPath)) 
            {
                DWORD dwFileAttr = GetFileAttributes(szPath);
                if (-1 != dwFileAttr && (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY))
                {
                    //
                    // The directory exists - enable the 'Ok' button
                    //
                    bFolderIsOK = TRUE;
                }
            }
            //
            // Enable / disable the 'ok' button
            //
            ::SendMessage(hwnd, BFFM_ENABLEOK , 0, (LPARAM)bFolderIsOK);
            break;
        }


        default:
            break;
    }
    return 0;
}   // BrowseCallbackProc


LRESULT 
CStoreConfigPage::OnBrowseForFolder(
    WORD wNotifyCode, 
    WORD wID, 
    HWND hWndCtl, 
    BOOL& bHandled
)
{
    DEBUG_FUNCTION_NAME(TEXT("CStoreConfigPage::OnBrowseForFolder"));

    CComBSTR bstrSelectedFolder;
    BROWSEINFO bi = {0};
	HRESULT hr = NOERROR;
    TCHAR szDisplayName[MAX_PATH + 1];

    bi.hwndOwner = hWndCtl;
    bi.pidlRoot = NULL;
    bi.pszDisplayName = szDisplayName;
    bi.lpszTitle = AllocateAndLoadString (_pModule->m_hInstResource, IDS_SELECT_FOLDER);
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE | BIF_NONEWFOLDERBUTTON;
    bi.lpfn = BrowseCallbackProc;

    m_edtFolder.GetWindowText (m_bstrFolder.m_str);

    LPITEMIDLIST pItemIdList = SHBrowseForFolder (&bi);
    MemFree ((LPVOID)bi.lpszTitle);
    if (NULL == pItemIdList)
    {
        //
        // User pressed cancel
        //
        return hr;
    }
	if(!::SHGetPathFromIDList(pItemIdList, szDisplayName))
    {
        hr = HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE);
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SHGetPathFromIDList() failed. (hr = 0x%08X)"),
            hr);
    }
    else
    {
        m_edtFolder.SetWindowText (szDisplayName);
        SetModified(TRUE);
    }
    //
    // free pItemIdList
    //
	LPMALLOC pMalloc;
	HRESULT hRes = ::SHGetMalloc(&pMalloc);
    if(E_FAIL == hRes)
    {
        hr = HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE);
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SHGetMalloc() failed. (hr = 0x%08X)"),
            hr);
    }
    else
    {
	    pMalloc->Free(pItemIdList);
	    pMalloc->Release();
    }
    return hr;
}   // CStoreConfigPage::OnBrowseForFolder

//////////////////////////////////////////////////////////////////////////////
/*++

CStoreConfigPage::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CStoreConfigPage::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CStoreConfigPage::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\util.cpp ===
#include "stdafx.h"
#include "RoutingMethodProp.h"
#include "RoutingMethodConfig.h"
#include <faxutil.h>
#include <fxsapip.h>
#include <faxreg.h>
#include <faxres.h>
#include <faxuiconstants.h>
#include "Util.h"

DWORD 
WriteExtData(
    HANDLE          hFax,
    DWORD           dwDeviceId,
    LPCWSTR         lpcwstrGUID,
    LPBYTE          lpData,
    DWORD           dwDataSize,
    UINT            uTitleId,
    HWND            hWnd
)
{
    DEBUG_FUNCTION_NAME(TEXT("WriteExtData"));

    DWORD  ec = ERROR_SUCCESS;

    if (!FaxSetExtensionData (
            hFax,                       // Connection handle
            dwDeviceId,                 // Global extension data
            lpcwstrGUID,                // Data GUID
            lpData,                     // Buffer
            dwDataSize                  // Buffer size
    ))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxSetExtensionData() failed for GUID = %s (ec: %ld)"),
            lpcwstrGUID,
            ec);
        DisplayRpcErrorMessage(ec, uTitleId, hWnd);
    }
    return ec;
}   // WriteExtDWORDData


DWORD
ReadExtStringData(
    HANDLE          hFax,
    DWORD           dwDeviceId,
    LPCWSTR         lpcwstrGUID,
    CComBSTR       &bstrResult,
    LPCWSTR         lpcwstrDefault,
    UINT            uTitleId,
    HWND            hWnd
)
{
    DEBUG_FUNCTION_NAME(TEXT("ReadExtStringData"));

    DWORD  dwDataSize = 0;
    DWORD  ec = ERROR_SUCCESS;
    LPBYTE lpExtData = NULL;

    if (!FaxGetExtensionData (
            hFax,                       // Connection handle
            dwDeviceId,                 // Global extension data
            lpcwstrGUID,                // Data GUID
            (PVOID *)&lpExtData,        // Buffer
            &dwDataSize                 // Buffer size
    ))
    {
        ec = GetLastError();
        lpExtData = NULL;
        if (ERROR_FILE_NOT_FOUND == ec)
        {
			//
			// Try to read default values from unassociated data
			//
			ec = ERROR_SUCCESS;
			if (!FaxGetExtensionData (
					hFax,                       // Connection handle
					0,							// unassociated extension data
					lpcwstrGUID,                // Data GUID
					(PVOID *)&lpExtData,        // Buffer
					&dwDataSize                 // Buffer size
					))
			{
				ec = GetLastError();
				if (ERROR_FILE_NOT_FOUND == ec)
				{
					DebugPrintEx(
						DEBUG_WRN,
						TEXT("ROUTINGEXT Data not found for GUID: %s. Using default value (%s)"),
						lpcwstrGUID,
						lpcwstrDefault);
					ec = ERROR_SUCCESS;
					bstrResult = lpcwstrDefault;
					goto exit;
				}
			}            
        }
        
		if (ERROR_SUCCESS != ec &&
			ERROR_FILE_NOT_FOUND != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ROUTINGEXT FaxGetExtensionData() failed for GUID = %s (ec: %ld)"),
                lpcwstrGUID,
                ec);
            DisplayRpcErrorMessage(ec, uTitleId, hWnd);
			goto exit;
        }
        
    }
    bstrResult = (LPCWSTR)lpExtData;

exit:
    FaxFreeBuffer(lpExtData);
    return ec;
}   // ReadExtStringData

HRESULT 
GetDWORDFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPDWORD lpdwValue
)
{
    DEBUG_FUNCTION_NAME(TEXT("GetDWORDFromDataObject"));

    Assert(lpdwValue);
    Assert(0 != uFormat);

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = 
    { 
        uFormat, 
        NULL, 
        DVASPECT_CONTENT, 
        -1, 
        TYMED_HGLOBAL 
    };

    stgmedium.hGlobal = GlobalAlloc(0, sizeof(DWORD));
    if (stgmedium.hGlobal == NULL)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GlobalAlloc() failed. (ec: %ld)"),
            GetLastError());
        return E_OUTOFMEMORY;
    }

    HRESULT hr = lpDataObject->GetDataHere(&formatetc, &stgmedium);
    if (SUCCEEDED(hr))
    {
        *lpdwValue = *((LPDWORD)stgmedium.hGlobal);
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetDataHere() failed. (hr = 0x%08X)"),
            hr);
    }
    GlobalFree(stgmedium.hGlobal);
    return hr;
}   // GetDWORDFromDataObject

HRESULT 
GetStringFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPWSTR lpwstrBuf, 
    DWORD dwBufLen
)
{
    DEBUG_FUNCTION_NAME(TEXT("GetStringFromDataObject"));
    Assert(lpDataObject);
    Assert(lpwstrBuf);
    Assert(dwBufLen>0);

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = 
        {   
            uFormat, 
            NULL, 
            DVASPECT_CONTENT, 
            -1, 
            TYMED_HGLOBAL 
        };

    stgmedium.hGlobal = GlobalAlloc(0, dwBufLen*sizeof(WCHAR));
    if (stgmedium.hGlobal == NULL)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GlobalAlloc() failed. (ec: %ld)"),
            GetLastError());
        return E_OUTOFMEMORY;
    }

    HRESULT hr = lpDataObject->GetDataHere(&formatetc, &stgmedium);
    if (SUCCEEDED(hr))
    {
        lstrcpyn(lpwstrBuf,(LPWSTR)stgmedium.hGlobal,dwBufLen);
        lpwstrBuf[dwBufLen-1]=L'\0';
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetDataHere() failed. (hr = 0x%08X)"),
            hr);
    }
    GlobalFree(stgmedium.hGlobal);
    return hr;
}   // GetStringFromDataObject

void 
DisplayRpcErrorMessage(
    DWORD ec,
    UINT uTitleId,
    HWND hWnd
)
{
    
    UINT uMsgId;
    uMsgId = GetErrorStringId(ec);
    DisplayErrorMessage(uTitleId, uMsgId, TRUE, hWnd); // use the common error messages DLL
}   // DisplayRpcErrorMessage

void 
DisplayErrorMessage(
    UINT uTitleId,
    UINT uMsgId, 
    BOOL bCommon,
    HWND hWnd
)
{
    static CComBSTR bstrCaption = TEXT("");
    CComBSTR bstrMsg;
    
    if (!lstrcmp(bstrCaption.m_str,TEXT("")))
    {
        bstrCaption.LoadString(uTitleId);
        if (!bstrCaption)
        {
            bstrCaption = TEXT("");
            return;
        }
    }
    if (bCommon) 
    {
        bstrMsg.LoadString(_Module.GetResourceInstance(),uMsgId);
    }
    else
    {
        bstrMsg.LoadString(uMsgId);
    }
    if (bstrMsg)
    {
        AlignedMessageBox(hWnd, bstrMsg, bstrCaption, MB_OK | MB_ICONEXCLAMATION);
    }
}   // DisplayErrorMessage

DWORD 
WinContextHelp(
    ULONG_PTR dwHelpId, 
    HWND  hWnd
)
/*++

Routine name : WinContextHelp

Routine description:

	Open context sensetive help popup 'tooltip' with WinHelp

Arguments:

	dwHelpId                      [in]     - help ID
	hWnd                          [in]     - parent window handler

Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;

    if (0 == dwHelpId)
    {
        return dwRes;
    }
    
    WinHelp(hWnd, 
            FXS_ADMIN_HLP_FILE, 
            HELP_CONTEXTPOPUP, 
            dwHelpId);

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\t30ext\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// T30 MMC configuration resource ID file           //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [10500 - 10999]                                  //
//                                                  //
//////////////////////////////////////////////////////

#define IDB_T30CONFIG_16                10500 
#define IDB_T30CONFIG_32                10501 
#define IDD_T30CONFIG                   10502 
#define IDS_T30CONFIG_DESC              10503 
#define IDS_T30CONFIG_PROVIDER          10504 
#define IDR_T30CONFIG                   10506 
#define IDS_T30PAGE_TITLE               10507 
#define IDS_ERR_BAD_T30_CONFIGURATION   10508 
#define IDC_ADAPTIVE_ANSWERING          10509 
#define IDI_T30_INFO                    10510 
#define IDC_INFO_ICON                   10511 
#define IDC_INFO_TEXT                   10512 
#define IDC_ADAPTIVE_ANSWERING_WARN     10513
#define IDI_T30_SNAPIN                  10514
#define IDS_FAX_T30_SNAPIN_NAME         10515 // Do not change. Used by RGS file.

//////////////////////////////////////////////////////
//                                                  //
// T30 MMC configuration resource ID file           //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [10500 - 10999]                                  //
//                                                  //
//////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\util.h ===
#ifndef _UTIL_H_
#define _UTIL_H_


DWORD 
WriteExtData(
    HANDLE          hFax,
    DWORD           dwDeviceId,
    LPCWSTR         lpcwstrGUID,
    LPBYTE          lpData,
    DWORD           dwDataSize,
    UINT            uTitleId,
    HWND            hWnd
);


DWORD
ReadExtStringData(
    HANDLE          hFax,
    DWORD           dwDeviceId,
    LPCWSTR         lpcwstrGUID,
    CComBSTR       &bstrResult,
    LPCWSTR         lpcwstrDefault,
    UINT            uTitleId,
    HWND            hWnd
);

HRESULT 
GetDWORDFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPDWORD lpdwValue
);

HRESULT 
GetStringFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPWSTR lpwstrBuf, 
    DWORD dwBufLen
);

void 
DisplayRpcErrorMessage(
    DWORD ec,
    UINT uTitleId,
    HWND hWnd
);

void 
DisplayErrorMessage(
    UINT uTitleId,
    UINT uMsgId, 
    BOOL bCommon,
    HWND hWnd
);

DWORD 
WinContextHelp(
    ULONG_PTR dwHelpId, 
    HWND  hWnd
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\routingext\devicemethods\storeconfigpage.h ===
#ifndef __STORE_CONFIG_PAGE_H_
#define __STORE_CONFIG_PAGE_H_
#include "resource.h"
//#include <atlsnap.h>
#include "..\..\inc\atlsnap.h"
#include <atlapp.h>
#include <atlctrls.h>
#include <faxmmc.h>
#include <faxutil.h>
#include <fxsapip.h>
#include <RoutingMethodConfig.h>

class CStoreConfigPage : public CSnapInPropertyPageImpl<CStoreConfigPage>
{
public :
    CStoreConfigPage(LONG_PTR lNotifyHandle, bool bDeleteHandle = false, TCHAR* pTitle = NULL ) : 
        m_lNotifyHandle(lNotifyHandle),
        m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
    {
        m_hFax = NULL;

        m_fIsDialogInitiated = FALSE;
        m_fIsDirty           = FALSE;
    }

    HRESULT Init(LPCTSTR lpctstrServerName, DWORD dwDeviceId);

    ~CStoreConfigPage()
    {

        DEBUG_FUNCTION_NAME(TEXT("CStoreConfigPage::~CStoreConfigPage"));
        if (m_hFax)
        {
            if (!FaxClose(m_hFax))
            {
                DWORD ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                    m_hFax,
                    m_bstrServerName,
                    ec);
            }
            m_hFax = NULL;
        }
        if (m_bDeleteHandle)
        {
            MMCFreeNotifyHandle(m_lNotifyHandle);
        }
    }

    enum { IDD = IDD_STORE };

BEGIN_MSG_MAP(CStoreConfigPage)
    MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog )
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnHelpRequest)
    MESSAGE_HANDLER(WM_HELP,        OnHelpRequest)
    CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CStoreConfigPage>)
    COMMAND_HANDLER(IDC_EDIT_FOLDER,        EN_CHANGE,  OnFieldChange)
    COMMAND_HANDLER(IDC_BUT_BROWSE,         BN_CLICKED, OnBrowseForFolder)
END_MSG_MAP()

    LRESULT OnBrowseForFolder(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    HRESULT PropertyChangeNotify(long param)
    {
        return MMCPropertyChangeNotify(m_lNotifyHandle, param);
    }

    BOOL OnApply();

    LRESULT OnFieldChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        if (!m_fIsDialogInitiated) //event receieved in too early stage
        {
            return 0;
        }
        else
        {
            m_fIsDirty = TRUE;
            SetModified(TRUE);
            return 0;
        }
    }

    LRESULT OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled );

    LRESULT OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

public:
    LONG_PTR m_lNotifyHandle;
    bool m_bDeleteHandle;

    static CComBSTR &GetFolder ()  { return m_bstrFolder; }

private:
    HANDLE   m_hFax;  // Handle to fax server connection
    CComBSTR m_bstrServerName;
    DWORD    m_dwDeviceId;

    static CComBSTR m_bstrFolder;   // We're refering to this variable in the callback function BrowseCallbackProc

    //
    // Controls
    //
    CEdit    m_edtFolder;
   
    BOOL  m_fIsDialogInitiated;
    BOOL  m_fIsDirty;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\t30ext\t30config.h ===
#ifndef __T30CONFIG_H_
#define __T30CONFIG_H_
#include "resource.h"
//#include <atlsnap.h>
#include "..\inc\atlsnap.h"
#include "cVerNum.h"
#include <atlapp.h>
#include <atlctrls.h>
#include <faxmmc.h>
#include <faxutil.h>
#include <fxsapip.h>
class CT30ConfigPage : public CSnapInPropertyPageImpl<CT30ConfigPage>
{
public :
	CT30ConfigPage(LONG_PTR lNotifyHandle, bool bDeleteHandle = false, TCHAR* pTitle = NULL ) : 
		CSnapInPropertyPageImpl<CT30ConfigPage> (pTitle),
		m_lNotifyHandle(lNotifyHandle),
		m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
	{
        m_hFax = NULL;
        m_dwDeviceId = 0;
        m_bAdaptiveAnsweringEnabled = 0;

	}

    HRESULT Init(LPCTSTR lpctstrServerName, DWORD dwDeviceId);

    

	~CT30ConfigPage()
	{

        DEBUG_FUNCTION_NAME(TEXT("CT30ConfigPage::~CT30ConfigPage"));
        if (m_hFax)
        {
            if (!FaxClose(m_hFax))
            {
                DWORD ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                    m_hFax,
                    m_bstrServerName,
                    ec);
            }
            m_hFax = NULL;
        }
        if (m_bDeleteHandle)
			MMCFreeNotifyHandle(m_lNotifyHandle);
	}

	enum { IDD = IDD_T30CONFIG };

BEGIN_MSG_MAP(CT30ConfigPage)
    MESSAGE_HANDLER( WM_INITDIALOG,            OnInitDialog )
    COMMAND_HANDLER(IDC_ADAPTIVE_ANSWERING, BN_CLICKED, OnClickedAdaptiveAnswering)
    MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)
	CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CT30ConfigPage>)    	
END_MSG_MAP()
// Handler prototypes:
//	LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//	LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//	LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	HRESULT PropertyChangeNotify(long param)
	{
		return MMCPropertyChangeNotify(m_lNotifyHandle, param);
	}

    BOOL OnApply();

    LRESULT OnClickedAdaptiveAnswering(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
        SetModified(TRUE);
		return 0;
	}
    LRESULT OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled );

    LRESULT OnHelpRequest (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

public:
	LONG_PTR m_lNotifyHandle;
	bool m_bDeleteHandle;
	

private:
    CComBSTR m_bstrServerName;
    HANDLE m_hFax;  // Handle to fax server connection
    DWORD m_dwDeviceId; // The device id for which the properties are displayed
    BOOL m_bAdaptiveAnsweringEnabled; // Holds the AdaptiveAnswerEnable value untill we can put it in the ui.
    //
    // Controls
    //
    CButton m_btnAdaptiveEnabled;
    
};


class CT30ConfigExtData : public CSnapInItemImpl<CT30ConfigExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;
 
    CLIPFORMAT m_CCF_FSP_GUID;
    CLIPFORMAT m_CCF_FSP_DEVICE_ID;
    CLIPFORMAT m_CCF_SERVER_NAME;


    
	CT30ConfigExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
        m_CCF_FSP_GUID = 0;
        m_CCF_FSP_DEVICE_ID = 0;
        m_CCF_SERVER_NAME = 0;

	}

	~CT30ConfigExtData()
	{
	}

	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
		LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

	STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type);
	

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
        DEBUG_FUNCTION_NAME(TEXT("CT30ConfigExtData::InitDataClass"));
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
        //
        // Register clipboard formats if they are not registered yet
        if (!m_CCF_FSP_GUID)
        {
            m_CCF_FSP_GUID = (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_FSP_GUID);
            if (!m_CCF_FSP_GUID)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to registet clipformat : %s (ec: %ld)"),
                    CF_MSFAXSRV_FSP_GUID,
                    GetLastError());
            }
        }

        if (!m_CCF_FSP_DEVICE_ID)
        {
            m_CCF_FSP_DEVICE_ID = (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_DEVICE_ID);
            if (!m_CCF_FSP_DEVICE_ID)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to registet clipformat : %s (ec: %ld)"),
                    CF_MSFAXSRV_DEVICE_ID,
                    GetLastError());
            }
        }

        if (!m_CCF_SERVER_NAME)
        {
            m_CCF_SERVER_NAME = (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_SERVER_NAME);
            if (!m_CCF_SERVER_NAME)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to registet clipformat : %s (ec: %ld)"),
                    CF_MSFAXSRV_SERVER_NAME,
                    GetLastError());
            }
        }


	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}

};
class CT30Config : public CComObjectRootEx<CComSingleThreadModel>,
public CSnapInObjectRoot<0, CT30Config>,
	public IExtendPropertySheetImpl<CT30Config>,
	public CComCoClass<CT30Config, &CLSID_T30Config>
{
public:
	CT30Config()
	{
		m_pComponentData = this;
	}

EXTENSION_SNAPIN_DATACLASS(CT30ConfigExtData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CT30Config)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CT30ConfigExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CT30Config)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_T30CONFIG)

DECLARE_NOT_AGGREGATABLE(CT30Config)


	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}
};

class ATL_NO_VTABLE CT30ConfigAbout : public ISnapinAbout,
	public CComObjectRoot,
	public CComCoClass< CT30ConfigAbout, &CLSID_T30ConfigAbout>
{
public:
	DECLARE_REGISTRY(CT30ConfigAbout, _T("T30ConfigAbout.1"), _T("T30ConfigAbout.1"), IDS_T30CONFIG_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CT30ConfigAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_T30CONFIG_DESC, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_T30CONFIG_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
	{
        USES_CONVERSION;
        TCHAR szBuf[256];
        swprintf(szBuf, TEXT(" %d.%d.%d"), rmj, rmm, rup);
        *lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpVersion == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpVersion, T2OLE(szBuf));
    
        return S_OK;
	}

	STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
        *hAppIcon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_T30_SNAPIN));
		return S_OK;
	}

	STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
		HBITMAP *hSmallImageOpen,
		HBITMAP *hLargeImage,
		COLORREF *cMask)
	{
		*hSmallImageOpen = *hLargeImage = *hLargeImage = 0;
		return S_OK;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\t30ext\t30propsheetext.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Mon Dec 27 10:27:28 1999
 */
/* Compiler settings for t30propsheetext.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __t30propsheetext_h__
#define __t30propsheetext_h__

/* Forward Declarations */ 

#ifndef __T30Config_FWD_DEFINED__
#define __T30Config_FWD_DEFINED__

#ifdef __cplusplus
typedef class T30Config T30Config;
#else
typedef struct T30Config T30Config;
#endif /* __cplusplus */

#endif 	/* __T30Config_FWD_DEFINED__ */


#ifndef __T30ConfigAbout_FWD_DEFINED__
#define __T30ConfigAbout_FWD_DEFINED__

#ifdef __cplusplus
typedef class T30ConfigAbout T30ConfigAbout;
#else
typedef struct T30ConfigAbout T30ConfigAbout;
#endif /* __cplusplus */

#endif 	/* __T30ConfigAbout_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __T30PROPSHEETEXTLib_LIBRARY_DEFINED__
#define __T30PROPSHEETEXTLib_LIBRARY_DEFINED__

/* library T30PROPSHEETEXTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_T30PROPSHEETEXTLib;

EXTERN_C const CLSID CLSID_T30Config;

#ifdef __cplusplus

class DECLSPEC_UUID("84125C25-AD95-4A51-A472-41864AEC775E")
T30Config;
#endif

EXTERN_C const CLSID CLSID_T30ConfigAbout;

#ifdef __cplusplus

class DECLSPEC_UUID("B37E13AA-75DF-4EDF-900C-2D2E0B884DE8")
T30ConfigAbout;
#endif
#endif /* __T30PROPSHEETEXTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\t30ext\t30config.cpp ===
#include "stdafx.h"
#include "T30PropSheetExt.h"
#include "T30Config.h"
#include <t30ext.h>
#include <faxutil.h>
#include <faxreg.h>
#include <faxres.h>
#include <faxuiconstants.h>
/////////////////////////////////////////////////////////////////////////////
// CT30ConfigComponentData
static const GUID CT30ConfigExtGUID_NODETYPE = FAXSRV_DEVICE_NODETYPE_GUID;

//{ 0x3115a19a, 0x6251, 0x46ac, { 0x94, 0x25, 0x14, 0x78, 0x28, 0x58, 0xb8, 0xc9 } };
const GUID*  CT30ConfigExtData::m_NODETYPE = &CT30ConfigExtGUID_NODETYPE;
const OLECHAR* CT30ConfigExtData::m_SZNODETYPE = FAXSRV_DEVICE_NODETYPE_GUID_STR; 
//OLESTR("3115A19A-6251-46ac-9425-14782858B8C9");
const OLECHAR* CT30ConfigExtData::m_SZDISPLAY_NAME = OLESTR("T30Config");
const CLSID* CT30ConfigExtData::m_SNAPIN_CLASSID = &CLSID_T30Config;


void DisplayRpcErrorMessage(DWORD ec, HWND hWnd);
void DisplayErrorMessage(UINT uMsgId, HWND hWnd, BOOL bCommon = FALSE);

HRESULT GetDWORDFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPDWORD lpdwValue
    );

HRESULT GetStringFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPWSTR lpwstrBuf, 
    DWORD dwBufLen
    );


HRESULT CT30ConfigExtData::QueryPagesFor(DATA_OBJECT_TYPES type)

{
    DEBUG_FUNCTION_NAME(TEXT("CT30ConfigExtData::QueryPagesFor"));


	if (type == CCT_SCOPE || type == CCT_RESULT)
    {
        WCHAR szFSPGuid[FAXSRV_MAX_GUID_LEN + 1];
        HRESULT hr;

        hr = GetStringFromDataObject(m_pDataObject,m_CCF_FSP_GUID, szFSPGuid,sizeof(szFSPGuid)/sizeof(WCHAR));
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetFSPGUIDFromDataObject failed. hr = 0x%08X"),
                hr);
            return hr;
        }
    
        if (CSTR_EQUAL == CompareString(LOCALE_INVARIANT,
                                        NORM_IGNORECASE, 
                                        szFSPGuid,
                                        -1,
                                        REGVAL_T30_PROVIDER_GUID_STRING,
                                        -1))
        {
            return S_OK;
        }
        else
        {
            return S_FALSE;
        }

    }
	
	return S_FALSE;
}

HRESULT CT30ConfigExtData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME(TEXT("CT30ConfigExtData::CreatePropertyPages"));

    WCHAR szFSPGuid[FAXSRV_MAX_GUID_LEN + 1];
    WCHAR szServer[FAXSRV_MAX_SERVER_NAME + 1];

    DWORD dwDeviceId;
    HRESULT hr;

    hr = GetStringFromDataObject(m_pDataObject,m_CCF_FSP_GUID, szFSPGuid,sizeof(szFSPGuid)/sizeof(WCHAR));
    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFSPGUIDFromDataObject for m_CCF_FSP_GUID failed. hr = 0x%08X"),
            hr);
        return hr;
    }
    
    if (CSTR_EQUAL != CompareString(LOCALE_INVARIANT,
                                    NORM_IGNORECASE, 
                                    szFSPGuid,
                                    -1,
                                    REGVAL_T30_PROVIDER_GUID_STRING,
                                    -1))
    {
        return E_UNEXPECTED;
    }

    hr = GetStringFromDataObject(m_pDataObject,m_CCF_SERVER_NAME, szServer,sizeof(szServer)/sizeof(WCHAR));
    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFSPGUIDFromDataObject for m_CCF_SERVER_NAME failed. hr = 0x%08X"),
            hr);
        return hr;
    }
    

    hr = GetDWORDFromDataObject(m_pDataObject,m_CCF_FSP_DEVICE_ID,&dwDeviceId);

    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetDeviceIdFromDataObject failed. hr = 0x%08X"),
            hr);
        return hr;
    }

    CComBSTR bstrPageTitle;
    bstrPageTitle.LoadString(IDS_T30PAGE_TITLE);
    if (!bstrPageTitle)
    {
        return E_UNEXPECTED;
    }
	CT30ConfigPage* pPage = new CT30ConfigPage(handle, true, bstrPageTitle); // true = only one page
    if (!pPage)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate CT30ConfigPage")
            );
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

	hr = pPage->Init(szServer, dwDeviceId);
    if (SUCCEEDED(hr))
    {
        lpProvider->AddPage(pPage->Create());
    }
    else
    {
        return E_UNEXPECTED;
    }
	
	return S_OK;

	
}



HRESULT CT30ConfigPage::Init(LPCTSTR lpctstrServerName, DWORD dwDeviceId)
{
    DEBUG_FUNCTION_NAME(TEXT("CT30ConfigPage::Init"));
    
    LPT30_EXTENSION_DATA lpExtData = NULL;
    DWORD dwDataSize = 0;
    DWORD ec = ERROR_SUCCESS;

    m_dwDeviceId = dwDeviceId;

    m_bstrServerName = lpctstrServerName;
    if (!m_bstrServerName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Out of memory while copying server name (ec: %ld)")
        );
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DisplayRpcErrorMessage(ERROR_NOT_ENOUGH_MEMORY, m_hWnd);
        goto exit;
    }

    if (!FaxConnectFaxServer(lpctstrServerName,&m_hFax))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxConnectFaxServer failed (ec: %ld)"),
            ec);
        DisplayRpcErrorMessage(ec, m_hWnd);
        goto exit;
    }

    if(!FaxGetExtensionData(
            m_hFax,
            m_dwDeviceId,
            GUID_T30_EXTENSION_DATA,
            (PVOID *)&lpExtData,
            &dwDataSize
        ))
    {
        ec = GetLastError();
        lpExtData = NULL;
        if (ERROR_FILE_NOT_FOUND == ec)
        {
            DebugPrintEx(
            DEBUG_ERR,
            TEXT("T30 Data not found. Device: 0x%08X, GUID: %s"),
            m_dwDeviceId,
            GUID_T30_EXTENSION_DATA);
            ec = ERROR_SUCCESS;
            m_bAdaptiveAnsweringEnabled = FALSE;
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("T30 FaxGetExtensionData() failed. GUID = %s (ec: %ld)"),
                GUID_T30_EXTENSION_DATA,
                ec);
            DisplayRpcErrorMessage(ec, m_hWnd);
        }
        goto exit;
    }

    if (dwDataSize != sizeof(T30_EXTENSION_DATA))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("T30 FaxGetExtensionData() returned mismatched data size (%ld)"),
            dwDataSize);
        ec = ERROR_BAD_FORMAT;
        DisplayErrorMessage(IDS_ERR_BAD_T30_CONFIGURATION, m_hWnd);
        goto exit;
    }

    m_bAdaptiveAnsweringEnabled = lpExtData->bAdaptiveAnsweringEnabled;

    Assert(ERROR_SUCCESS == ec);

exit:

    if ((ERROR_SUCCESS != ec) && m_hFax)
    {
        if (!FaxClose(m_hFax))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                m_hFax,
                m_bstrServerName,
                GetLastError());
        }
        m_hFax = NULL;
    }

    if (lpExtData)
    {
        FaxFreeBuffer(lpExtData);
        lpExtData = NULL;
    }
    return HRESULT_FROM_WIN32(ec);
}

LRESULT CT30ConfigPage::OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CT30ConfigPage::OnInitDialog"));

    m_btnAdaptiveEnabled.Attach(GetDlgItem(IDC_ADAPTIVE_ANSWERING));
    m_btnAdaptiveEnabled.SetCheck(m_bAdaptiveAnsweringEnabled ? BST_CHECKED : BST_UNCHECKED);

    return 1;
}


BOOL CT30ConfigPage::OnApply()
{

    DEBUG_FUNCTION_NAME(TEXT("CT30ConfigPage::OnApply"));

    BOOL bRet = FALSE;


    T30_EXTENSION_DATA ExtData;
    
    memset(&ExtData,0,sizeof(ExtData));
    ExtData.bAdaptiveAnsweringEnabled = (BST_CHECKED == m_btnAdaptiveEnabled.GetCheck());


    if(!FaxSetExtensionData(
            m_hFax,
            m_dwDeviceId,
            GUID_T30_EXTENSION_DATA,
            (LPVOID)&ExtData,
            sizeof(ExtData)
        ))
    {
        DWORD ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("T30 FaxGetExtensionData() failed. GUID = %s (ec: %ld)"),
            GUID_T30_EXTENSION_DATA,
            ec);
        DisplayRpcErrorMessage(ec, m_hWnd);
    }
    else
    {
        bRet = TRUE;
    }
 
    return bRet;
}

HRESULT GetDWORDFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPDWORD lpdwValue
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetDWORDFromDataObject"));

    Assert(lpdwValue);
    Assert(0 != uFormat);

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
	FORMATETC formatetc = { 
        uFormat, 
		NULL, 
		DVASPECT_CONTENT, 
		-1, 
		TYMED_HGLOBAL 
	};

	stgmedium.hGlobal = GlobalAlloc(0, sizeof(DWORD));
	if (stgmedium.hGlobal == NULL)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GlobalAlloc() failed. (ec: %ld)"),
            GetLastError());
		return E_OUTOFMEMORY;
    }

	HRESULT hr = lpDataObject->GetDataHere(&formatetc, &stgmedium);
	if (SUCCEEDED(hr))
	{
        *lpdwValue = *((LPDWORD)stgmedium.hGlobal);
	}
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetDataHere() failed. (hr = 0x%08X)"),
            hr);
    }
	
	GlobalFree(stgmedium.hGlobal);

    return hr;
}



HRESULT GetStringFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPWSTR lpwstrBuf, 
    DWORD dwBufLen
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetStringFromDataObject"));
    Assert(lpDataObject);
    Assert(lpwstrBuf);
    Assert(dwBufLen>0);

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
	FORMATETC formatetc = 
        {   
            uFormat, 
		    NULL, 
		    DVASPECT_CONTENT, 
		    -1, 
		    TYMED_HGLOBAL 
	    };

	stgmedium.hGlobal = GlobalAlloc(0, dwBufLen*sizeof(WCHAR));
	if (stgmedium.hGlobal == NULL)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GlobalAlloc() failed. (ec: %ld)"),
            GetLastError());
		return E_OUTOFMEMORY;
    }

	HRESULT hr = lpDataObject->GetDataHere(&formatetc, &stgmedium);
	if (SUCCEEDED(hr))
	{
        lstrcpyn(lpwstrBuf,(LPWSTR)stgmedium.hGlobal,dwBufLen);
        lpwstrBuf[dwBufLen-1]=L'\0';
	}
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetDataHere() failed. (hr = 0x%08X)"),
            hr);
    }
	
	GlobalFree(stgmedium.hGlobal);
    return hr;
}

void DisplayRpcErrorMessage(DWORD ec, HWND hWnd)
{
    
    UINT uMsgId;
    uMsgId = GetErrorStringId(ec);
    DisplayErrorMessage(uMsgId, hWnd, TRUE); // use the common error messages DLL
}

void DisplayErrorMessage(UINT uMsgId, HWND hWnd, BOOL bCommon)
{
    static CComBSTR bstrCaption = TEXT("");
    
    CComBSTR bstrMsg;
    
    if (!lstrcmp(bstrCaption.m_str,TEXT("")))
    {
        bstrCaption.LoadString(IDS_T30PAGE_TITLE);
        if (!bstrCaption)
        {
            bstrCaption = TEXT("");
            return;
        }
    }
    
    if (bCommon) 
    {
        bstrMsg.LoadString(_Module.GetResourceInstance(), uMsgId);
    }
    else
    {
        bstrMsg.LoadString(uMsgId);
    }

    if (bstrMsg)
    {
        AlignedMessageBox(hWnd, bstrMsg, bstrCaption, MB_OK|MB_ICONEXCLAMATION);
    }
}

//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerOutbox::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CT30ConfigPage::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CT30ConfigPage::OnHelpRequest"));
    
    ULONG_PTR dwHelpId = 0;

    if(WM_HELP == uMsg)
    {
        dwHelpId = ((LPHELPINFO)lParam)->dwContextId;
    }
    else if(WM_CONTEXTMENU == uMsg)
    {
        dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
    }

    if(dwHelpId)
    {
        ::WinHelp(m_hWnd, 
                  FXS_ADMIN_HLP_FILE, 
                  HELP_CONTEXTPOPUP, 
                  dwHelpId);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\t30ext\t30propsheetext.cpp ===
// T30PropSheetExt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f T30PropSheetExtps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "T30PropSheetExt.h"

#include "T30Prop_i.c"
#include "T30Config.h"
#include <faxres.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_T30Config, CT30Config)
OBJECT_ENTRY(CLSID_T30ConfigAbout, CT30ConfigAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_T30PROPSHEETEXTLib);
        DisableThreadLibraryCalls(hInstance);

        _Module.m_hInstResource = GetResInstance(hInstance);
        if(!_Module.m_hInstResource)
        {
            return FALSE;
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        FreeResInstance();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    //
    // registers object, typelib and all interfaces in typelib
    //
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\clientconsole.h ===
// ClientConsole.h : main header file for the CLIENTCONSOLE application
//

#if !defined(AFX_CLIENTCONSOLE_H__5B27AC67_C003_40F4_A688_721D5534C391__INCLUDED_)
#define AFX_CLIENTCONSOLE_H__5B27AC67_C003_40F4_A688_721D5534C391__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif


#define CLIENT_CONSOLE_CLASS        TEXT("7a56577c-6143-43d9-bdcb-bcf234d86e98")

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleApp:
// See ClientConsole.cpp for the implementation of this class
//

class CClientConsoleApp : public CWinApp
{
public:
    CClientConsoleApp();

	DWORD SendMail(CString& cstrFile);
	BOOL  IsMapiEnable() 
		{ return  NULL != m_hInstMail ? TRUE : FALSE; }

    CMainFrame* GetMainFrame() { return (CMainFrame*)m_pMainWnd; } 
    CClientConsoleDoc* GetDocument() 
    {
        CMainFrame* pFrame = GetMainFrame();
        return (NULL != pFrame) ? (CClientConsoleDoc*)pFrame->GetActiveDocument() : NULL;
    }            

    BOOL IsCmdLineOpenFolder() { return m_cmdLineInfo.IsOpenFolder(); }
    FolderType GetCmdLineFolderType() { return m_cmdLineInfo.GetFolderType(); }
    DWORDLONG GetMessageIdToSelect()  { return m_cmdLineInfo.GetMessageIdToSelect(); }

    BOOL IsCmdLineSingleServer() { return m_cmdLineInfo.IsSingleServer(); }
    CString& GetCmdLineSingleServerName() { return m_cmdLineInfo.GetSingleServerName(); }

    BOOL LaunchConfigWizard(BOOL bExplicit);
    void LaunchFaxMonitor();
    void InboxViewed();
    void OutboxViewed();

    BOOL IsRTLUI() { return m_bRTLUI; }

    VOID PrepareForModal();
    VOID ReturnFromModal();

    CString &GetClassName()     { return m_PrivateClassName; }

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClientConsoleApp)
    public:
    virtual BOOL InitInstance();
	virtual int ExitInstance();
    //}}AFX_VIRTUAL

// Implementation
    //{{AFX_MSG(CClientConsoleApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:

    BOOL FirstInstance ();
    BOOL m_bClassRegistered;

    HINSTANCE m_hInstMail;       // handle to MAPI32.DLL

    CCmdLineInfo m_cmdLineInfo;

    CString      m_PrivateClassName;    // Name of the main frame window class. 
                                        // Composed of CLIENT_CONSOLE_CLASS + m_cmdLineInfo.GetSingleServerName()

    BOOL m_bRTLUI;

};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLIENTCONSOLE_H__5B27AC67_C003_40F4_A688_721D5534C391__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\clientconsoledoc.cpp ===
// ClientConsoleDoc.cpp : implementation of the CClientConsoleDoc class
//

#include "stdafx.h"
#define __FILE_ID__     2

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CClientConsoleApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleDoc

IMPLEMENT_DYNCREATE(CClientConsoleDoc, CDocument)

BEGIN_MESSAGE_MAP(CClientConsoleDoc, CDocument)
    //{{AFX_MSG_MAP(CClientConsoleDoc)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleDoc construction/destruction

//
// Static members:
//
HANDLE   CClientConsoleDoc::m_hShutdownEvent = NULL;
BOOL     CClientConsoleDoc::m_bShuttingDown = FALSE;


CClientConsoleDoc::CClientConsoleDoc() :
    m_bRefreshingServers (FALSE),
    m_bWin9xPrinterFormat(FALSE)
{}

CClientConsoleDoc::~CClientConsoleDoc()
{
    //
    // The list of servers is not freed and servers and their folders are not deleted.
    // The background threads may still be alive and use the CServerNode and CFolder objects.
    // The main thread doesnt wait for the background threads termination to prevent application hanging.
    //

    if (m_hShutdownEvent)
    {
        CloseHandle (m_hShutdownEvent);
        m_hShutdownEvent = NULL;
    }
}

DWORD
CClientConsoleDoc::Init ()
/*++

Routine name : CClientConsoleDoc::Init

Routine description:

    Initializes document events and maps

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CClientConsoleDoc::Init"), dwRes);

    //
    // Create the shutdown event. This event will be signaled when the app is
    // about to quit.
    //
    ASSERTION (NULL == m_hShutdownEvent);
    m_hShutdownEvent = CreateEvent (NULL,       // No security
                                    TRUE,       // Manual reset
                                    FALSE,      // Starts clear
                                    NULL);      // Unnamed
    if (NULL == m_hShutdownEvent)
    {
        dwRes = GetLastError ();
        CALL_FAIL (STARTUP_ERR, TEXT("CreateEvent"), dwRes);
        PopupError (dwRes);
        return dwRes;
    }
    //
    // Init the map of notification messages from the servers
    //
    dwRes = CServerNode::InitMsgsMap ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (MEM_ERR, TEXT("CServerNode::InitMsgsMap"), dwRes);
        PopupError (dwRes);
        return dwRes;
    }

    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CClientConsoleDoc::Init

BOOL CClientConsoleDoc::OnNewDocument()
{
    BOOL bRes = FALSE;
    DBG_ENTER(TEXT("CClientConsoleDoc::OnNewDocument"), bRes);

    if (!CDocument::OnNewDocument())
    {
        return bRes;
    }

    if(theApp.IsCmdLineSingleServer())
    {
        //
        // get command line server name
        //
        try
        {
            m_cstrSingleServer = theApp.GetCmdLineSingleServerName();
        }
        catch (...)
        {
            CALL_FAIL (MEM_ERR, TEXT("CString::operator ="), ERROR_NOT_ENOUGH_MEMORY);
            PopupError (ERROR_NOT_ENOUGH_MEMORY);
            return bRes;
        }
    }

    DWORD dwRes = Init ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CClientConsoleDoc::Init"), dwRes);
        return bRes;
    }

    bRes = TRUE;
    return bRes;
}


/////////////////////////////////////////////////////////////////////////////
// CClientConsoleDoc serialization

void CClientConsoleDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
}

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleDoc diagnostics

#ifdef _DEBUG
void CClientConsoleDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CClientConsoleDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleDoc commands

DWORD
CClientConsoleDoc::AddServerNode (
    LPCTSTR lpctstrServer
)
/*++

Routine name : CClientConsoleDoc::AddServerNode

Routine description:

    Adds a new server node to the servers list and initializes it

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    lpctstrServer      [in]     - Server name

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CClientConsoleDoc::AddServerNode"), dwRes, TEXT("%s"), lpctstrServer);

    CServerNode    *pServerNode = NULL;
    //
    // Create the new server node
    //
    try
    {
        pServerNode = new CServerNode;
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("new CServerNode"), dwRes);
        PopupError (dwRes);
        return dwRes;
    }
    //
    // Init the server
    //
    dwRes = pServerNode->Init (lpctstrServer);
    if (ERROR_SUCCESS != dwRes)
    {
        pServerNode->Destroy ();
        PopupError (dwRes);
        return dwRes;
    }
    //
    // Enter the (initialized) node at the end of the list
    //
    try
    {
        m_ServersList.push_back (pServerNode);
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("list::push_back"), dwRes);
        PopupError (dwRes);
        pServerNode->Destroy ();
        return dwRes;
    }

    pServerNode->AttachFoldersToViews();
    pServerNode->RefreshState();


    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        // Shutdown in progress
        //
        return dwRes;
    }

    CLeftView* pLeftView = pFrm->GetLeftView();
    ASSERTION(pLeftView);

    CFolderListView* pListView = pLeftView->GetCurrentView();
    if(NULL != pListView)
    {
        //
        // refresh current folder
        //
        FolderType type = pListView->GetType();
        CFolder* pFolder = pServerNode->GetFolder(type);
        ASSERTION(pFolder);

        pFolder->SetVisible();
    }

    return dwRes;
}   // CClientConsoleDoc::AddServerNode

DWORD 
CClientConsoleDoc::RefreshServersList()
/*++

Routine name : CClientConsoleDoc::RefreshServersList

Routine description:

    Refreshes the list of servers

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    None.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD           dwRes = ERROR_SUCCESS;
    DWORD           dwIndex;
    PRINTER_INFO_2 *pPrinterInfo2 = NULL;
    DWORD           dwNumPrinters;
    CServerNode*    pServerNode;

    DBG_ENTER(TEXT("CClientConsoleDoc::RefreshServersList"), dwRes);
    //
    // Prevent a new servers refresh request
    //
    if(m_bRefreshingServers )
    {
        return dwRes;
    }

    m_bRefreshingServers = TRUE;

    if (m_cstrSingleServer.IsEmpty ())
    {
        SetAllServersInvalid();

        //
        // Working in a multiple-servers mode (normal mode)
        // Enumerate the list of printers available on the system
        //
        dwRes = GetPrintersInfo(pPrinterInfo2, dwNumPrinters);
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("GetPrintersInfo"), dwRes);
            goto exit;
        }

        //
        // Iterate the printers
        //
        for (dwIndex=0; dwIndex < dwNumPrinters; dwIndex++) 
        {
            if(pPrinterInfo2[dwIndex].pDriverName)
            {
                if (_tcscmp(pPrinterInfo2[dwIndex].pDriverName, FAX_DRIVER_NAME))
                {
                    //
                    // This printer does not use the Fax Server driver
                    //
                    continue;
                }
            }
            //
            // Init the node's share and server name
            //
            if( (NULL == pPrinterInfo2[dwIndex].pShareName || 
                    0 == _tcslen(pPrinterInfo2[dwIndex].pShareName)) &&
                (NULL == pPrinterInfo2[dwIndex].pServerName || 
                    0 == _tcslen(pPrinterInfo2[dwIndex].pServerName)))
            {
                //
                // On Win9x machine, the share name and server name are NULL 
                // or empty string but the
                // port is valid and composed of \\servername\sharename
                //
                m_bWin9xPrinterFormat = TRUE;

                if ((_tcsclen(pPrinterInfo2[dwIndex].pPortName) >= 5) &&
                    (_tcsncmp(pPrinterInfo2[dwIndex].pPortName, TEXT("\\\\"), 2) == 0))
                {
                    //
                    // Port name is long enough and starts with "\\"
                    //
                    TCHAR* pServerStart = _tcsninc(pPrinterInfo2[dwIndex].pPortName,2);
                    TCHAR* pShareStart = _tcschr (pServerStart, TEXT('\\'));
                    if (pShareStart)
                    {
                        //
                        // Share was found after the server name.
                        // Seperate server from share and advance share name
                        //
                        TCHAR* ptcTmp = pShareStart;
                        pShareStart = _tcsinc(pShareStart);
                        *ptcTmp = TEXT('\0');
                        pPrinterInfo2[dwIndex].pShareName = pShareStart;
                        pPrinterInfo2[dwIndex].pServerName = pServerStart;
                    }
                }
            }

            pServerNode = FindServerByName(pPrinterInfo2[dwIndex].pServerName);
            if(NULL == pServerNode)
            {
                //
                // Create new server node
                //
                dwRes = AddServerNode (pPrinterInfo2[dwIndex].pServerName);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("AddServerNode"), dwRes);
                    goto exit;
                }
            }
            else
            {
                //
                // the server node already exists
                //
                pServerNode->SetValid(TRUE);
            }

        }   // End of printers loop

        dwRes = RemoveAllInvalidServers();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("RemoveAllInvalidServers"), dwRes);
            goto exit;
        }
    }
    else
    {
        //
        // Working in a single server mode (server name in m_cstrSingleServer).
        // Create new server node.
        //
        int nSize = m_ServersList.size();
        ASSERTION(0 == nSize || 1 == nSize);

        if(0 == nSize)
        {
            dwRes = AddServerNode (m_cstrSingleServer);
            if (ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("AddServerNode"), dwRes);
                goto exit;
            }
        }
        else
        {
            ASSERTION(FindServerByName(m_cstrSingleServer));
        }
    }    


    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    SAFE_DELETE_ARRAY (pPrinterInfo2);

    //
    // Enable a new servers refresh request
    //
    m_bRefreshingServers = FALSE;
    return dwRes;
}   // CClientConsoleDoc::RefreshServersList


void CClientConsoleDoc::OnCloseDocument() 
{
    DBG_ENTER(TEXT("CClientConsoleDoc::OnCloseDocument"));

    //
    // Signal the event telling all our thread the app. is shutting down
    //
    SetEvent (m_hShutdownEvent);
    m_bShuttingDown = TRUE;
    CDocument::OnCloseDocument();
}

void 
CClientConsoleDoc::ClearServersList()
/*++

Routine name : CClientConsoleDoc::ClearServersList

Routine description:

    Clears the list of servers

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CClientConsoleDoc::ClearServersList"));

    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        CServerNode *pServerNode = *it;
        pServerNode->Destroy ();
    }
    m_ServersList.clear ();

}   // CClientConsoleDoc::ClearServersList


void  
CClientConsoleDoc::SetAllServersInvalid()
{
    DBG_ENTER(TEXT("CClientConsoleDoc::SetAllServersInvalid"));

    CServerNode *pServerNode;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        pServerNode->SetValid(FALSE);
    }
}


DWORD 
CClientConsoleDoc::RemoveServerNode(
    CServerNode* pServer
)
/*++

Routine name : CClientConsoleDoc::RemoveServerNode

Routine description:

    remove the server from the servers list and from the tree view

Author:

    Alexander Malysh (AlexMay), Mar, 2000

Arguments:

    pServer                       [in]     - server node

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CClientConsoleDoc::RemoveServerNode"), dwRes);
    ASSERTION(pServer);

    dwRes = pServer->InvalidateSubFolders(TRUE);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::InvalidateSubFolders"), dwRes);
        return dwRes;
    }

    //
    // remove the server node from the list
    //
    try
    {
        m_ServersList.remove(pServer);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("list::remove"), dwRes);
        return dwRes;
    }

    //
    // delete the server node object
    //
    pServer->Destroy();

    return dwRes;
}

DWORD 
CClientConsoleDoc::RemoveAllInvalidServers()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CClientConsoleDoc::RemoveAllInvalidServers"), dwRes);

    BOOL bSrvFound;
    CServerNode *pServerNode;

    while(TRUE)
    {
        //
        // find invalid server node
        //
        bSrvFound = FALSE;
        for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
        {
            pServerNode = *it;
            if(!pServerNode->IsValid())
            {
                bSrvFound = TRUE;
                break;
            }
        }

        if(bSrvFound)
        {
            //
            // remove invalid server node
            //
            dwRes = RemoveServerNode(pServerNode);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("RemoveServerNode"), dwRes);
                break;
            }
        }
        else
        {
            break;
        }
    } 

    return dwRes;
}

CServerNode* 
CClientConsoleDoc::FindServerByName(
    LPCTSTR lpctstrServer
)
/*++

Routine name : CClientConsoleDoc::FindServerByName

Routine description:

    find CServerNode by machine name

Author:

    Alexander Malysh (AlexMay), Mar, 2000

Arguments:

    lpctstrServer                 [in] - machine name

Return Value:

    CServerNode*

--*/
{
    CServerNode *pServerNode = NULL;
    CServerNode *pResultNode = NULL;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        if(pServerNode->Machine().Compare(lpctstrServer ? lpctstrServer : TEXT("")) == 0)
        {
            pResultNode = pServerNode;
            break;
        }
    }

    return pResultNode;
}


void
CClientConsoleDoc::SetInvalidFolder(
    FolderType type
)
/*++

Routine name : CClientConsoleDoc::InvalidateFolder

Routine description:

    invalidate specific folder content

Author:

    Alexander Malysh (AlexMay), Apr, 2000

Arguments:

    type                          [in]     - folder type

Return Value:


--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CClientConsoleDoc::InvalidateFolder"));

    CFolder*     pFolder;
    CServerNode* pServerNode;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        pFolder = pServerNode->GetFolder(type);
        ASSERTION(pFolder);

        if (pFolder)
        {
            pFolder->SetInvalid();
        }
    }
}

void 
CClientConsoleDoc::ViewFolder(
    FolderType type
)
/*++

Routine name : CClientConsoleDoc::ViewFolder

Routine description:

    refresh specific folder in all servers

Author:

    Alexander Malysh (AlexMay), Apr, 2000

Arguments:

    type                          [in]     - folder type

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CClientConsoleDoc::ViewFolder"));


    CFolder*     pFolder;
    CServerNode *pServerNode;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        pFolder = pServerNode->GetFolder(type);
        ASSERTION(pFolder);

        pFolder->SetVisible();
    }
}

BOOL
CClientConsoleDoc::CanReceiveNow ()
/*++

Routine name : CClientConsoleDoc::CanReceiveNow

Routine description:

    Can the user apply the 'Recieve now' option?

Author:

    Eran Yariv (EranY), Mar, 2001

Arguments:


Return Value:

    TRUE if the user apply the 'Recieve now' option, FALSE otherwise.

--*/
{
    BOOL bEnable = FALSE;
    
    //
    // Locate the local fax server node
    //
    CServerNode* pServerNode = FindServerByName (NULL);
    if (pServerNode)
    {
        if(pServerNode->IsOnline() && pServerNode->CanReceiveNow())
        {
            bEnable = TRUE;
        }
    }
    return bEnable;
}   // CClientConsoleDoc::CanReceiveNow


BOOL 
CClientConsoleDoc::IsSendFaxEnable()
/*++

Routine name : CClientConsoleDoc::IsSendFaxEnable

Routine description:

    does user anable to send fax

Author:

    Alexander Malysh (AlexMay), Apr, 2000

Arguments:


Return Value:

    TRUE if anable send fax, FALSE otherwise.

--*/
{
    BOOL bEnable = FALSE;
    CServerNode* pServerNode;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        if(pServerNode->IsOnline() && pServerNode->CanSendFax())
        {
            bEnable = TRUE;
            break;
        }
    }

    return bEnable;
}

int 
CClientConsoleDoc::GetFolderDataCount(
    FolderType type
)
/*++

Routine name : CClientConsoleDoc::GetFolderDataCount

Routine description:

    get total message number in specific folder from all servers

Author:

    Alexander Malysh (AlexMay), Apr, 2000

Arguments:

    type                          [in]    - folder type

Return Value:

    message number

--*/
{
    int nCount=0;
    CFolder*     pFolder;
    CServerNode* pServerNode;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        pFolder = pServerNode->GetFolder(type);
        nCount += pFolder->GetDataCount();
    }
    return nCount;
}

BOOL 
CClientConsoleDoc::IsFolderRefreshing(
    FolderType type
)
/*++

Routine name : CClientConsoleDoc::IsFolderRefreshing

Routine description:

    if one of specific folders is refreshing

Author:

    Alexander Malysh (AlexMay), Apr, 2000

Arguments:

    type                          [TBD]    - folder type

Return Value:

    TRUE if one of specific folders is refreshing, FALSE otherwise.

--*/
{
    CFolder*     pFolder;
    CServerNode* pServerNode;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        pFolder = pServerNode->GetFolder(type);
        if (!pFolder)
        {
            DBG_ENTER(TEXT("CClientConsoleDoc::IsFolderRefreshing"));
            ASSERTION_FAILURE;
        }
        if(pFolder->IsRefreshing())
        {
            return TRUE;
        }
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\clientconsole.cpp ===
// ClientConsole.cpp : Defines the class behaviors for the application.
//


#include "stdafx.h"
#include "..\admin\cfgwzrd\FaxCfgWzExp.h"

#define __FILE_ID__     1

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CClientConsoleApp

BEGIN_MESSAGE_MAP(CClientConsoleApp, CWinApp)
    //{{AFX_MSG_MAP(CClientConsoleApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleApp construction

CClientConsoleApp::CClientConsoleApp(): 
    m_hInstMail(NULL),
    m_bRTLUI(FALSE),
    m_bClassRegistered(FALSE)
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CClientConsoleApp object

CClientConsoleApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleApp initialization

BOOL CClientConsoleApp::InitInstance()
{
    MODIFY_FORMAT_MASK(DBG_PRNT_THREAD_ID,0);

    BOOL bRes = FALSE;
    DBG_ENTER (TEXT("CClientConsoleApp::InitInstance"), bRes);

    if(IsRTLUILanguage())
    {
        //
        // Set Right-to-Left layout for RTL languages
        //
        m_bRTLUI = TRUE;
        SetRTLProcessLayout();
    }

    //
    // Parse command line for standard shell commands, DDE, file open
    //
    ParseCommandLine(m_cmdLineInfo);
    //
    // See if we need to active previous instance
    //
    try
    {
        m_PrivateClassName = CLIENT_CONSOLE_CLASS;
        if (m_cmdLineInfo.IsSingleServer())
        {
            //
            // Append server name to window class name
            //
            m_PrivateClassName += m_cmdLineInfo.GetSingleServerName();
        }
    }
    catch (...)
    {
        CALL_FAIL (MEM_ERR, TEXT("CString exception"), ERROR_NOT_ENOUGH_MEMORY);
        return bRes;
    }
    if (!m_cmdLineInfo.ForceNewInstance())
    {
        //
        // User did not force a new instance- check for previous instance
        //
        if(!FirstInstance())
        {
            //
            // Other instance located and activated
            //
            return bRes;
        }
    }
    //
    // Implicit launch of fax configuration wizard
    //
    if (!LaunchConfigWizard(FALSE))
    {
        //
        // User refused to enter a dialing location - stop the client console.
        //
        VERBOSE (DBG_MSG, TEXT("User refused to enter a dialing location - stop the client console."));
        return bRes;
    }
    //
    // Register our unique class name that you wish to use
    //

    WNDCLASS wndcls = {0};

    wndcls.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
    wndcls.lpfnWndProc = ::DefWindowProc;
    wndcls.hInstance = AfxGetInstanceHandle();
    wndcls.hIcon = LoadIcon(IDR_MAINFRAME); 
    wndcls.hCursor = LoadCursor(IDC_ARROW);
    wndcls.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wndcls.lpszMenuName = NULL;
    wndcls.lpszClassName = m_PrivateClassName;
    //
    // Register the new class and exit if it fails
    //
    if(!AfxRegisterClass(&wndcls))
    {
        CALL_FAIL (GENERAL_ERR, TEXT("AfxRegisterClass"), GetLastError());
        return bRes;
    }
    m_bClassRegistered = TRUE;
            
    //
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    // of your final executable, you should remove from the following
    // the specific initialization routines you do not need.
    //
#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif
    //
    // Change the app's resource to our resource DLL.
    //
    HINSTANCE hResource = GetResourceHandle();
    if(!hResource)
    {
        return FALSE;
    }
    AfxSetResourceHandle (hResource);
    //
    // Generate a really random seed
    //
    srand( (unsigned)time( NULL ) );
    //
    // Set the registry location or the app.
    //
    SetRegistryKey (REGKEY_CLIENT);
    //
    // Set application name
    //
    CString cstrAppName;
    DWORD dwRes = LoadResourceString (cstrAppName, AFX_IDS_APP_TITLE);
    if (ERROR_SUCCESS != dwRes)
    {
        return bRes;
    }
    ASSERTION (m_pszAppName);   // Loaded from exe name
    free((void*)m_pszAppName);
    m_pszAppName = _tcsdup(cstrAppName);
    //
    // Check for minimal version of ComCtl32.dll
    //
    #define COM_CTL_VERSION_4_70 PACKVERSION(4,70)

    DWORD dwComCtl32Version = GetDllVersion(TEXT("comctl32.dll"));
    VERBOSE (DBG_MSG, TEXT("COMCTL32.DLL Version is : 0x%08X"), dwComCtl32Version);
    if (dwComCtl32Version < COM_CTL_VERSION_4_70)
    {
        AlignedAfxMessageBox (IDS_BAD_COMCTL32, MB_OK | MB_ICONHAND); 
        return bRes;
    }
    //
    // Register the application's document templates.  Document templates
    // serve as the connection between documents, frame windows and views.
    //
    CSingleDocTemplate* pDocTemplate;
    try
    {
        pDocTemplate = new CSingleDocTemplate(
            IDR_MAINFRAME,
            RUNTIME_CLASS(CClientConsoleDoc),
            RUNTIME_CLASS(CMainFrame),       // main SDI frame window
            RUNTIME_CLASS(CLeftView));
    }
    catch (...)
    {
        CALL_FAIL (MEM_ERR, TEXT("new CSingleDocTemplate"), ERROR_NOT_ENOUGH_MEMORY);
        PopupError (ERROR_NOT_ENOUGH_MEMORY);
        return bRes;
    }

    AddDocTemplate(pDocTemplate);


    //
    // Read the initial settings
    //
    CMessageFolder::ReadConfiguration ();

    //
    // Load MAPI library
    //
    if (1 == ::GetProfileInt (TEXT("Mail"), TEXT("MAPI"), 0))
    {
        //
        // If there's an entry in WIN.INI under the [Mail] section saying MAPI=1, then 
        // and only then, MAPI is available to us.
        // Search MSDN for "Initializing a Simple MAPI Client" and read for yourself if
        // you don't believe me.
        //
        m_hInstMail = ::LoadLibrary(TEXT("MAPI32.DLL"));
        if(NULL == m_hInstMail)
        {
            dwRes = GetLastError();
            CALL_FAIL (GENERAL_ERR, TEXT("LoadLibrary(\"MAPI32.DLL\")"), dwRes);
        }
    }

    OnFileNew();

    // The one and only window has been initialized, so show and update it.
    m_pMainWnd->ShowWindow(SW_SHOW);
    m_pMainWnd->UpdateWindow();
    
    bRes = TRUE;

    return bRes;
}   // CClientConsoleApp::InitInstance

int 
CClientConsoleApp::ExitInstance() 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER (TEXT("CClientConsoleApp::ExitInstance"));
    
    if(NULL != m_hInstMail)
    {
        if(!FreeLibrary(m_hInstMail))
        {
            dwRes = GetLastError();
            CALL_FAIL (GENERAL_ERR, TEXT("FreeLibrary (MAPI32.DLL)"), dwRes);
        }
    }
    //
    // Remove left of temp preview files
    //
    DeleteTempPreviewFiles (NULL, TRUE);
    if(m_bClassRegistered)
    {
        //
        // Unregister our class
        //
        ::UnregisterClass(m_PrivateClassName, AfxGetInstanceHandle());
        m_bClassRegistered = FALSE;
    }

    FreeResInstance();

    return CWinApp::ExitInstance();
}


BOOL 
CClientConsoleApp::LaunchConfigWizard(
    BOOL bExplicit
)
/*++

Routine name : CClientConsoleApp::LaunchConfigWizard

Routine description:

    launch Fax Configuration Wizard for Windows XP platform only

Arguments:

    bExplicit     [in] - TRUE if it's explicit launch

Return Value:

    TRUE if the client console should continue.
    If FALSE, the user failed to set a dialing location and the client console should quit.

--*/
{
    DBG_ENTER(TEXT("CClientConsoleApp::LaunchConfigWizard"));

    if(!IsWinXPOS())
    {
        return TRUE;
    }

    HMODULE hConfigWizModule = LoadLibrary(FAX_CONFIG_WIZARD_DLL);
    if(hConfigWizModule)
    {
        FAX_CONFIG_WIZARD fpFaxConfigWiz;
        BOOL bAbort = FALSE;
        fpFaxConfigWiz = (FAX_CONFIG_WIZARD)GetProcAddress(hConfigWizModule, 
                                                           FAX_CONFIG_WIZARD_PROC);
        if(fpFaxConfigWiz)
        {
            if(!fpFaxConfigWiz(bExplicit, &bAbort))
            {
                CALL_FAIL (GENERAL_ERR, TEXT("FaxConfigWizard"), GetLastError());
            }
        }
        else
        {
            CALL_FAIL (GENERAL_ERR, TEXT("GetProcAddress(FaxConfigWizard)"), GetLastError());
        }

        if(!FreeLibrary(hConfigWizModule))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("FreeLibrary(FxsCgfWz.dll)"), GetLastError());
        }
        if (bAbort)
        {
            //
            // User refused to enter a dialing location - stop the client console.
            //
            return FALSE;
        }
    }
    else
    {
        CALL_FAIL (GENERAL_ERR, TEXT("LoadLibrary(FxsCgfWz.dll)"), GetLastError());
    }
    return TRUE;
}

void 
CClientConsoleApp::InboxViewed()
/*++

Routine name : CClientConsoleApp::InboxViewed

Routine description:

    Report to the Fax Monitor that the Inbox folder has been viewed

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("CClientConsoleApp::InboxViewed"));

    if(!IsWinXPOS())
    {
        return;
    }

    HWND hWndFaxMon = FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hWndFaxMon) 
    {
        PostMessage(hWndFaxMon, WM_FAXSTAT_INBOX_VIEWED, 0, 0);
    }
}

void 
CClientConsoleApp::OutboxViewed()
/*++

Routine name : CClientConsoleApp::OutboxViewed

Routine description:

    Report to the Fax Monitor that the Outbox folder has been viewed

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("CClientConsoleApp::InboxViewed"));

    if(!IsWinXPOS())
    {
        return;
    }

    HWND hWndFaxMon = FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hWndFaxMon) 
    {
        PostMessage(hWndFaxMon, WM_FAXSTAT_OUTBOX_VIEWED, 0, 0);
    }
}


VOID
CClientConsoleApp::PrepareForModal ()
/*++

Routine name : CClientConsoleApp::PrepareForModal

Routine description:

	Prepares for a modal dialog box.
    Call this function before displaying another process window or a modeless dialog that you wish
    to appear modal.

    You must call ReturnFromModal() right after the process / modeless dialog returns. 

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:


Return Value:

    None.

--*/
{
    EnableModeless(FALSE);
    //
    // Some extra precautions are required to use MAPISendMail as it
    // tends to enable the parent window in between dialogs (after
    // the login dialog, but before the send note dialog).
    //
    m_pMainWnd->EnableWindow(FALSE);
    m_pMainWnd->SetCapture();
    ::SetFocus(NULL);
    m_pMainWnd->m_nFlags |= WF_STAYDISABLED;
}   // CClientConsoleApp::PrepareForModal

VOID
CClientConsoleApp::ReturnFromModal ()
/*++

Routine name : CClientConsoleApp::ReturnFromModal

Routine description:

	Reverts back from the PrepareForModal function.

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:


Return Value:

    None.

--*/
{
    //
    // After returning from the process / modeless dialog, the window must
    // be re-enabled and focus returned to the frame to undo the workaround
    // done before at PrepareForModal().
    //
    ::ReleaseCapture();
    m_pMainWnd->m_nFlags &= ~WF_STAYDISABLED;

    m_pMainWnd->EnableWindow(TRUE);
    ::SetActiveWindow(NULL);
    m_pMainWnd->SetActiveWindow();
    m_pMainWnd->SetFocus();
    ::EnableWindow(m_pMainWnd->m_hWnd, TRUE);
    EnableModeless(TRUE);
    //
    // Return the Main Frame to the foreground
    //
    ::SetWindowPos(m_pMainWnd->m_hWnd, 
                   HWND_TOPMOST, 
                   0, 
                   0, 
                   0, 
                   0, 
                   SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);

    ::SetWindowPos(m_pMainWnd->m_hWnd, 
                   HWND_NOTOPMOST, 
                   0, 
                   0, 
                   0, 
                   0, 
                   SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);
}   // CClientConsoleApp::ReturnFromModal


DWORD 
CClientConsoleApp::SendMail(
    CString& cstrFile
)
/*++

Routine name : CClientConsoleApp::SendMail

Routine description:

    create a new mail message with attached file

Author:

    Alexander Malysh (AlexMay), Mar, 2000

Arguments:

    cstrFile                      [in]     - file name for attach

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER (TEXT("CClientConsoleApp::SendMail"), dwRes);

    ASSERTION(m_hInstMail);

    CWaitCursor wait;

    MAPISENDMAIL    *pfnMAPISendMail;
    pfnMAPISendMail = (MAPISENDMAIL *)GetProcAddress(m_hInstMail, "MAPISendMail");
    if (!pfnMAPISendMail)
    {
        AlignedAfxMessageBox(AFX_IDP_INVALID_MAPI_DLL);
        dwRes = GetLastError ();
        return dwRes;
    }
    //
    // Prepare the file description (for the attachment)
    //
    MapiFileDesc fileDesc = {0};
    fileDesc.nPosition = (ULONG)-1;

    char szFileName[MAX_PATH+1];
#ifdef _UNICODE
    _wcstombsz(szFileName, cstrFile, MAX_PATH);
#else
    strncpy(szFileName, cstrFile, MAX_PATH);
#endif
    fileDesc.lpszPathName = szFileName;
    //
    // Prepare the message (empty with 1 attachment)
    //
    MapiMessage message = {0};
    message.nFileCount = 1;
    message.lpFiles = &fileDesc;

    PrepareForModal();
    //
    // Try to send the message
    //
    dwRes = pfnMAPISendMail(   0, 
                               (ULONG_PTR)m_pMainWnd->m_hWnd,
                               &message, 
                               MAPI_LOGON_UI | MAPI_DIALOG,
                               0
                           );
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("MAPISendMail"), dwRes);
        if ( dwRes != SUCCESS_SUCCESS && 
             dwRes != MAPI_USER_ABORT &&  
             dwRes != MAPI_E_LOGIN_FAILURE)
        {
            AlignedAfxMessageBox(AFX_IDP_FAILED_MAPI_SEND);
        }
		dwRes = ERROR_SUCCESS;
    }
    ReturnFromModal();
    return dwRes;
} // CClientConsoleApp::SendMail

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

    CString m_cstrVersion;

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    DDX_Text(pDX, IDC_ABOUT_VERSION, m_cstrVersion);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CClientConsoleApp::OnAppAbout()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER (TEXT("CClientConsoleApp::OnAppAbout"));

    if(!m_pMainWnd)
    {
        ASSERTION_FAILURE;
        return;
    }

	if (IsWinXPOS())
	{
		HICON hIcon = LoadIcon(IDR_MAINFRAME);
		if(!hIcon)
		{
			dwRes = GetLastError();
			CALL_FAIL (GENERAL_ERR, TEXT("LoadIcon"), dwRes);
			PopupError(dwRes);
			return;
		}

		if(!::ShellAbout(m_pMainWnd->m_hWnd, m_pszAppName, TEXT(""), hIcon))
		{
			dwRes = ERROR_CAN_NOT_COMPLETE;
			CALL_FAIL (GENERAL_ERR, TEXT("ShellAbout"), dwRes);
			PopupError(dwRes);
			return;
		}
		return;
	}
	CAboutDlg aboutDlg;
	//
	// get version
	//
	TCHAR tszVersionNum[100] = {0};
	TCHAR tszBuildNum[100] = {0};

	_sntprintf(tszVersionNum, ARR_SIZE(tszVersionNum) - 1, TEXT("%d.%d"), VERMAJOR, VERMINOR);

#ifdef DEBUG
	_sntprintf(tszBuildNum, ARR_SIZE(tszBuildNum) - 1, TEXT("%dchk"), BUILD);
#else
	_sntprintf(tszBuildNum, ARR_SIZE(tszBuildNum) - 1, TEXT("%d"), BUILD);
#endif

	try
	{
		AfxFormatString2(aboutDlg.m_cstrVersion, 
						 IDS_VERSION_FORMAT, 
						 tszVersionNum, 
						 tszBuildNum);
	}
	catch(...)
	{
		dwRes = ERROR_NOT_ENOUGH_MEMORY;
		CALL_FAIL (MEM_ERR, TEXT("AfxFormatString2"), dwRes);
		PopupError(dwRes);
		return;
	}

	aboutDlg.DoModal();
}

BOOL 
CClientConsoleApp::FirstInstance ()
/*++

Routine name : CClientConsoleApp::FirstInstance

Routine description:

	Checks if this is the first instance of the client console.
    If not, activates the other instance (first found) and optionally posts messages
    to it with the parsed command line parameters.

Author:

	Eran Yariv (EranY),	May, 2001

Arguments:


Return Value:

    TRUE if this is the first instance of the client console, FALSE otherwise.

--*/
{
    DBG_ENTER (TEXT("CClientConsoleApp::FirstInstance"));
    CWnd *pWndPrev;     // Previous Client console mainframe window
    CWnd *pWndChild;    // Previous Client console top-most window
    DWORDLONG dwlStartupMsg;

    //
    // Determine if another window with your class name exists...
    //
    pWndPrev = CWnd::FindWindow(m_PrivateClassName, NULL);
    if (pWndPrev && pWndPrev->m_hWnd)
    {
        //
        // If so, does it have any popups?
        //
        pWndChild = pWndPrev->GetLastActivePopup();
        //
        // If iconic, restore the main window
        //
        if (pWndPrev->IsIconic())
        {
            pWndPrev->ShowWindow(SW_RESTORE);
        }
        //
        // Bring the main window or its popup to the foreground
        //
        pWndChild->SetForegroundWindow();
        if (m_cmdLineInfo.IsOpenFolder())
        {
            //
            // The user specified a specific startup folder.
            // Post a private message to the previous instance, telling it to switch to the requested folder.
            //
            pWndPrev->PostMessage (WM_CONSOLE_SET_ACTIVE_FOLDER, WPARAM(m_cmdLineInfo.GetFolderType()), 0);
        }
        dwlStartupMsg = m_cmdLineInfo.GetMessageIdToSelect();
        if (dwlStartupMsg)
        {
            //
            // The user specified a specific startup message to select.
            // Post a private message to the previous instance, telling it to select to the requested message.
            //
            ULARGE_INTEGER uli;
            uli.QuadPart = dwlStartupMsg;
            pWndPrev->PostMessage (WM_CONSOLE_SELECT_ITEM, WPARAM(uli.LowPart), LPARAM(uli.HighPart));
        }
        //
        // And we're done activating the previous instance
        //
        return FALSE;
    }
    //
    // First instance. Proceed as normal.
    //
    return TRUE;
}   // CClientConsoleApp::FirstInstance

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\clientconsoledoc.h ===
// ClientConsoleDoc.h : interface of the CClientConsoleDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CLIENTCONSOLEDOC_H__6E33CFA1_C99A_4691_9F91_00451692D3DB__INCLUDED_)
#define AFX_CLIENTCONSOLEDOC_H__6E33CFA1_C99A_4691_9F91_00451692D3DB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

typedef list<CServerNode *> SERVERS_LIST, *PSERVERS_LIST;

class CClientConsoleDoc : public CDocument
{
protected: // create from serialization only
    CClientConsoleDoc();
    DECLARE_DYNCREATE(CClientConsoleDoc)

// Attributes
public:
    virtual ~CClientConsoleDoc();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClientConsoleDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    virtual void OnCloseDocument();
    //}}AFX_VIRTUAL

// Implementation
public:
    const SERVERS_LIST& GetServersList() const { return m_ServersList; }
    DWORD GetServerCount() { return m_ServersList.size(); }

    static const HANDLE GetShutdownEvent ()     { return m_hShutdownEvent; }
    static const BOOL   ShuttingDown ()         { return m_bShuttingDown;  }

    BOOL IsSendFaxEnable();
    BOOL CanReceiveNow();

    DWORD RefreshServersList ();

    BOOL IsFolderRefreshing(FolderType type);
    int GetFolderDataCount(FolderType type);
    void SetInvalidFolder(FolderType type);
    void ViewFolder(FolderType type);
    CString& GetSingleServerName() { return m_cstrSingleServer; }

	CServerNode* FindServerByName(LPCTSTR lpctstrServer);

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CClientConsoleDoc)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:

	void  SetAllServersInvalid();
	DWORD RemoveAllInvalidServers();
	DWORD RemoveServerNode(CServerNode* pServer);

    void ClearServersList ();
    DWORD Init ();
    DWORD AddServerNode (LPCTSTR lpctstrServer);

    BOOL  m_bWin9xPrinterFormat; // EnumPrinters() fills PRINTER_INFO_2 in Win9x style
                                 // pShareName and pServerName aren't valid  

    SERVERS_LIST    m_ServersList;          // List of servers
    static HANDLE   m_hShutdownEvent;       // Set when the app. shuts down.
    static BOOL     m_bShuttingDown;        // Are we shutting down?
    BOOL            m_bRefreshingServers;   // Are we refreshing the server's list?
    CString         m_cstrSingleServer;     // Name of single server. Empty if we're in normal mode.

};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLIENTCONSOLEDOC_H__6E33CFA1_C99A_4691_9F91_00451692D3DB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\cmdlineinfo.cpp ===
// CmdLineInfo.cpp: implementation of the CCmdLineInfo class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     81

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

void 
CCmdLineInfo::ParseParam( 
    LPCTSTR lpszParam, 
    BOOL bFlag, 
    BOOL bLast 
)
/*++

Routine name : CCmdLineInfo::ParseParam

Routine description:

	parse/interpret individual parameters from the command line

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:

	lpszParam                     [in]    - parameter or flag
	bFlag                         [in]    - Indicates whether lpszParam is a parameter or a flag
	bLast                         [in]    - Indicates if this is the last parameter or flag on the command line

Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCmdLineInfo::ParseParam"));

    if(bFlag)
    {
        //
        // lpszParam is a flag
        //
        if(_tcsicmp(lpszParam, CONSOLE_CMD_FLAG_STR_FOLDER) == 0)
        {
            //
            // User asked for startup folder.
            // Next param is expected to be folder name.
            //
            m_cmdLastFlag = CMD_FLAG_FOLDER;
        }
        else if(_tcsicmp(lpszParam, CONSOLE_CMD_FLAG_STR_MESSAGE_ID) == 0)
        {
            //
            // User asked for startup message.
            // Next param is expected to be message id.
            //
            m_cmdLastFlag = CMD_FLAG_MESSAGE_ID;
        }
        else if(_tcsicmp(lpszParam, CONSOLE_CMD_FLAG_STR_NEW) == 0)
        {
            //
            // User asked for new instance.
            // No further params required.
            //
            m_bForceNewInstace = TRUE;
            m_cmdLastFlag = CMD_FLAG_NONE;
        }
        else
        {
            //
            // No flag
            //
            m_cmdLastFlag = CMD_FLAG_NONE;
        }
    }
    else
    {
        //
        // lpszParam is a parameter.
        // Let's see what was the last flag specified.
        //
        switch(m_cmdLastFlag)
        {
            case CMD_FLAG_FOLDER:
                if(_tcsicmp(lpszParam, CONSOLE_CMD_PRM_STR_OUTBOX) == 0)
                {
                    m_FolderType = FOLDER_TYPE_OUTBOX;
                }
                else if(_tcsicmp(lpszParam, CONSOLE_CMD_PRM_STR_INCOMING) == 0)
                {
                    m_FolderType = FOLDER_TYPE_INCOMING;
                }
                else if(_tcsicmp(lpszParam, CONSOLE_CMD_PRM_STR_INBOX) == 0)
                {
                    m_FolderType = FOLDER_TYPE_INBOX;
                }
                else if(_tcsicmp(lpszParam, CONSOLE_CMD_PRM_STR_SENT_ITEMS) == 0)
                {
                    m_FolderType = FOLDER_TYPE_SENT_ITEMS;
                }

                m_cmdLastFlag = CMD_FLAG_NONE;
                break;

            case CMD_FLAG_MESSAGE_ID:
                //
                // Try to parse the message to select
                //
                if (1 != _stscanf (lpszParam, TEXT("%I64x"), &m_dwlMessageId))
                {
                        //
                        // Can't read 64-bits message id from string
                        //
                        CALL_FAIL (GENERAL_ERR, 
                                   TEXT("Can't read 64-bits message id from input string"), 
                                   ERROR_INVALID_PARAMETER);
                        m_dwlMessageId = 0;
                }
                m_cmdLastFlag = CMD_FLAG_NONE;
                break;

            case CMD_FLAG_NONE:
                try
                {
                    m_cstrServerName = lpszParam;
                }
                catch (...)
                {
                    CALL_FAIL (MEM_ERR, TEXT("CString::operator ="), ERROR_NOT_ENOUGH_MEMORY);
                    return;
                }
                break;

            default:
                break;
        }
    }
}   // CCmdLineInfo::ParseParam
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\clientconsoleview.h ===
// ClientConsoleView.h : interface of the CClientConsoleView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CLIENTCONSOLEVIEW_H__5AE93A9F_044B_4796_97C1_2371233702C8__INCLUDED_)
#define AFX_CLIENTCONSOLEVIEW_H__5AE93A9F_044B_4796_97C1_2371233702C8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CClientConsoleView : public CListView
{
public: // create from serialization only
    CClientConsoleView();
    DECLARE_DYNCREATE(CClientConsoleView)

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClientConsoleView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual void OnInitialUpdate(); // called first time after construct
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CClientConsoleView();
    CClientConsoleDoc* GetDocument();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CClientConsoleView)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in ClientConsoleView.cpp
inline CClientConsoleDoc* CClientConsoleView::GetDocument()
   { return (CClientConsoleDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLIENTCONSOLEVIEW_H__5AE93A9F_044B_4796_97C1_2371233702C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\clientconsoleview.cpp ===
// ClientConsoleView.cpp : implementation of the CClientConsoleView class
//

//
// This view is used when the following nodes are selected in the 
// left (tree) view:
//    - Root of tree
//    - A server (not a folder in the server)
//
#include "stdafx.h"
#define __FILE_ID__     3

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleView

IMPLEMENT_DYNCREATE(CClientConsoleView, CListView)

BEGIN_MESSAGE_MAP(CClientConsoleView, CListView)
    //{{AFX_MSG_MAP(CClientConsoleView)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleView construction/destruction

CClientConsoleView::CClientConsoleView()
{}

CClientConsoleView::~CClientConsoleView()
{}

BOOL CClientConsoleView::PreCreateWindow(CREATESTRUCT& cs)
{
    return CListView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleView drawing

void CClientConsoleView::OnDraw(CDC* pDC)
{
    CListView::OnDraw (pDC);
}

void CClientConsoleView::OnInitialUpdate()
{
    CListView::OnInitialUpdate();

    CListCtrl& refCtrl = GetListCtrl();
    refCtrl.SetExtendedStyle (LVS_EX_FULLROWSELECT |  // Entire row is selected
                              LVS_EX_INFOTIP);        // Allow tooltips
    ModifyStyle(LVS_TYPEMASK, LVS_REPORT);
}

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleView diagnostics

#ifdef _DEBUG
void CClientConsoleView::AssertValid() const
{
    CListView::AssertValid();
}

void CClientConsoleView::Dump(CDumpContext& dc) const
{
    CListView::Dump(dc);
}

CClientConsoleDoc* CClientConsoleView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CClientConsoleDoc)));
    return (CClientConsoleDoc*)m_pDocument;
}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\columnselectdlg.h ===
#if !defined(AFX_COLUMNSELECTDLG_H__12FC80A8_741C_4589_AC4B_01F72CBAECE9__INCLUDED_)
#define AFX_COLUMNSELECTDLG_H__12FC80A8_741C_4589_AC4B_01F72CBAECE9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ColumnSelectDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CColumnSelectDlg dialog


class CColumnSelectDlg : public CFaxClientDlg
{
// Construction
public:
	CColumnSelectDlg(const CString* pcstrTitles, int* pnOrderedItems, 
			DWORD dwListSize, DWORD& dwSelectedItems, CWnd* pParent = NULL);
	// 
	// set resource string resource IDs
	//
	void SetStrings
	(
		int nCaptionId,			// dialog caption resource ID
		int nAvailableId = -1,  // Available box title resource ID
		int nDisplayedId = -1   // Displayed box title resource ID
	)
	{
		m_nCaptionId = nCaptionId;
		m_nAvailableId = nAvailableId;
		m_nDisplayedId = nDisplayedId;	
	}

// Dialog Data
	//{{AFX_DATA(CColumnSelectDlg)
	enum { IDD = IDD_COLUMN_SELECT };
	CButton	m_butOk;
	CButton	m_groupAvailable;
	CButton	m_groupDisplayed;
	CButton	m_butAdd;
	CButton	m_butRemove;	
	CButton	m_butUp;
	CButton	m_butDown;
	CListBox	m_ListCtrlDisplayed;
	CListBox	m_ListCtrlAvailable;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CColumnSelectDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CColumnSelectDlg)
	virtual void OnOK();
	afx_msg void OnButDown();
	afx_msg void OnButUp();
	afx_msg void OnButRemove();
	afx_msg void OnButAdd();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelChangeListAvailable();
	afx_msg void OnSelChangeListDisplayed();
	afx_msg void OnDblclkListAvailable();
	afx_msg void OnDblclkListDisplayed();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	const CString* m_pcstrTitles;
	int* m_pnOrderedItems;
	const DWORD m_dwListSize;
	DWORD& m_rdwSelectedItems;

	int m_nCaptionId;
	int m_nAvailableId;
	int m_nDisplayedId;

private:
	BOOL InputValidate();
	void MoveSelectedItems(CListBox& listFrom, CListBox& listTo);
	void MoveItemVertical(int nStep);
	BOOL AddStrToList(CListBox& listBox, DWORD dwItemId);
	BOOL SetWndCaption(CWnd* pWnd, int nResId);
	void CalcButtonsState();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COLUMNSELECTDLG_H__12FC80A8_741C_4589_AC4B_01F72CBAECE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\coverpagesdlg.h ===
#if !defined(AFX_COVERPAGESDLG_H__621F98B6_B494_4FAB_AFDC_C38A144D4504__INCLUDED_)
#define AFX_COVERPAGESDLG_H__621F98B6_B494_4FAB_AFDC_C38A144D4504__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CoverPagesDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCoverPagesDlg dialog

#define WM_CP_EDITOR_CLOSED     WM_APP + 1

class CCoverPagesDlg : public CFaxClientDlg
{
// Construction
public:
	CCoverPagesDlg(CWnd* pParent = NULL);   // standard constructor
    ~CCoverPagesDlg();

    DWORD GetLastDlgError() { return m_dwLastError; }

// Dialog Data
	//{{AFX_DATA(CCoverPagesDlg)
	enum { IDD = IDD_COVER_PAGES };
	CButton	m_butDelete;
	CButton	m_butRename;
	CButton	m_butOpen;
	CListCtrl	m_cpList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCoverPagesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCoverPagesDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnCpNew();
	afx_msg void OnCpOpen();
	afx_msg void OnCpRename();
	afx_msg void OnCpDelete();
	afx_msg void OnCpAdd();
	afx_msg void OnItemchangedListCp(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndLabelEditListCp(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkListCp(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydownListCp(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LRESULT OnCpEditorClosed(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    DWORD RefreshFolder();
    void  CalcButtonsState(); 
    DWORD CopyPage(const CString& cstrPath, const CString& cstrName);
    DWORD StartEditor(LPCTSTR lpFile);

    static HWND   m_hDialog;
    static HANDLE m_hEditorThread;

    static DWORD WINAPI StartEditorThreadProc(LPVOID lpFile);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COVERPAGESDLG_H__621F98B6_B494_4FAB_AFDC_C38A144D4504__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\coverpagesdlg.cpp ===
// CoverPagesDlg.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     90

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCoverPagesDlg dialog

extern CClientConsoleApp theApp;

HWND   CCoverPagesDlg::m_hDialog = NULL;
HANDLE CCoverPagesDlg::m_hEditorThread = NULL;

struct TColimnInfo
{
    DWORD dwStrRes;    // column header string
    DWORD dwAlignment; // column alignment
};

static TColimnInfo s_colInfo[] = 
{
    IDS_COV_COLUMN_NAME,        LVCFMT_LEFT,
    IDS_COV_COLUMN_MODIFIED,    LVCFMT_LEFT,
    IDS_COV_COLUMN_SIZE,        LVCFMT_RIGHT
};


CCoverPagesDlg::CCoverPagesDlg(CWnd* pParent /*=NULL*/)
	: CFaxClientDlg(CCoverPagesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCoverPagesDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CCoverPagesDlg::~CCoverPagesDlg()
{
    m_hDialog = NULL;
}

void 
CCoverPagesDlg::DoDataExchange(CDataExchange* pDX)
{
	CFaxClientDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCoverPagesDlg)
	DDX_Control(pDX, IDC_CP_DELETE, m_butDelete);
	DDX_Control(pDX, IDC_CP_RENAME, m_butRename);
	DDX_Control(pDX, IDC_CP_OPEN,   m_butOpen);
	DDX_Control(pDX, IDC_LIST_CP,   m_cpList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCoverPagesDlg, CFaxClientDlg)
	//{{AFX_MSG_MAP(CCoverPagesDlg)
    ON_MESSAGE (WM_CP_EDITOR_CLOSED, OnCpEditorClosed)
	ON_BN_CLICKED(IDC_CP_NEW,    OnCpNew)
	ON_BN_CLICKED(IDC_CP_OPEN,   OnCpOpen)
	ON_BN_CLICKED(IDC_CP_RENAME, OnCpRename)
	ON_BN_CLICKED(IDC_CP_DELETE, OnCpDelete)
	ON_BN_CLICKED(IDC_CP_ADD,    OnCpAdd)
	ON_NOTIFY(LVN_ITEMCHANGED,   IDC_LIST_CP, OnItemchangedListCp)
	ON_NOTIFY(LVN_ENDLABELEDIT,  IDC_LIST_CP, OnEndLabelEditListCp)
	ON_NOTIFY(NM_DBLCLK,         IDC_LIST_CP, OnDblclkListCp)
	ON_NOTIFY(LVN_KEYDOWN,       IDC_LIST_CP, OnKeydownListCp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCoverPagesDlg message handlers

BOOL 
CCoverPagesDlg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CCoverPagesDlg::OnInitDialog"));

	CFaxClientDlg::OnInitDialog();

    m_hDialog = m_hWnd;

    TCHAR tszCovDir[MAX_PATH+1];
    if(!GetClientCpDir(tszCovDir, sizeof(tszCovDir) / sizeof(tszCovDir[0])))
	{
		CString cstrCoverPageDirSuffix;
		m_dwLastError = LoadResourceString (cstrCoverPageDirSuffix, IDS_PERSONAL_CP_DIR);
		if(ERROR_SUCCESS != m_dwLastError)
		{
			CALL_FAIL (RESOURCE_ERR, TEXT ("LoadResourceString"), m_dwLastError);
			EndDialog(IDABORT);
			return FALSE;
		}

		if(!SetClientCpDir((TCHAR*)(LPCTSTR)cstrCoverPageDirSuffix))
		{
			CALL_FAIL (GENERAL_ERR, TEXT ("SetClientCpDir"), 0);
			ASSERTION_FAILURE;
		}
    }

	CSize size;
    CDC* pHdrDc = m_cpList.GetHeaderCtrl()->GetDC();
    ASSERTION(pHdrDc);

    //
    // init CListCtrl
    //
    m_cpList.SetExtendedStyle (LVS_EX_FULLROWSELECT |    // Entire row is selected
                               LVS_EX_INFOTIP       |    // Allow tooltips
                               LVS_EX_ONECLICKACTIVATE); // Hover cursor effect

    m_cpList.SetImageList (&CFolderListView::m_sReportIcons, LVSIL_SMALL);

    int nRes;
    CString cstrHeader;
    DWORD nCols = sizeof(s_colInfo)/sizeof(s_colInfo[0]);

    //
    // init column
    //
    for(int i=0; i < nCols; ++i)
    {
        m_dwLastError = LoadResourceString (cstrHeader, s_colInfo[i].dwStrRes);
        if(ERROR_SUCCESS != m_dwLastError)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT ("LoadResourceString"), m_dwLastError);
            EndDialog(IDABORT);
            return FALSE;
        }

        size = pHdrDc->GetTextExtent(cstrHeader);
        nRes = m_cpList.InsertColumn(i, cstrHeader, s_colInfo[i].dwAlignment, size.cx * 2.5);
        if(nRes != i)
        {
            m_dwLastError = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::InsertColumn"), m_dwLastError);
            EndDialog(IDABORT);
            return FALSE;
        }
    }

    //
    // fill list control with cover pages
    //
    m_dwLastError = RefreshFolder();
    if(ERROR_SUCCESS != m_dwLastError)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshFolder"), m_dwLastError);
        EndDialog(IDABORT);
        return FALSE;
    }
	
	CalcButtonsState();

	return TRUE; 
}

LRESULT 
CCoverPagesDlg::OnCpEditorClosed(
    WPARAM wParam, 
    LPARAM lParam
)
{ 
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnCpEditorClosed"), dwRes);

    CloseHandle(m_hEditorThread);
    m_hEditorThread = NULL;

    CalcButtonsState();

    dwRes = RefreshFolder();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshFolder"), dwRes);
    }
	
    return 0;
}


DWORD 
CCoverPagesDlg::RefreshFolder()
/*++

Routine name : CCoverPagesDlg::RefreshFolder

Routine description:

	fill list control with cover pages

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::RefreshFolder"), dwRes);

    if(!m_cpList.DeleteAllItems())
    {
        dwRes = ERROR_CAN_NOT_COMPLETE;
        CALL_FAIL (WINDOW_ERR, TEXT ("CListView::DeleteAllItems"), dwRes);
        return dwRes;
    }

    //
    // get cover pages location
    //
    DWORD dwError;
    TCHAR tszCovDir[MAX_PATH+1];
    if(!GetClientCpDir(tszCovDir, sizeof(tszCovDir) / sizeof(tszCovDir[0])))
    {
        dwError = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetClientCpDir"), dwError);
        return dwRes;
    }

    DWORD  dwDirLen = _tcslen(tszCovDir);
    TCHAR* pPathEnd = _tcschr(tszCovDir, '\0');

    CString cstrPagesPath;
    try
    {
        cstrPagesPath.Format(TEXT("%s%s"), tszCovDir, FAX_COVER_PAGE_MASK);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
        return dwRes;
    }

    //
    // Find First File
    //
    WIN32_FIND_DATA findData;
    HANDLE hFile = FindFirstFile(cstrPagesPath, &findData);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        dwError = GetLastError();
        if(ERROR_FILE_NOT_FOUND != dwError)
        {
            dwRes = dwError;
            CALL_FAIL (FILE_ERR, TEXT("FindFirstFile"), dwRes);
        }
        return dwRes;
    }

    int nRes;
    BOOL bFindRes = TRUE;
    CString cstrText;
    ULARGE_INTEGER  ulSize;
    int iIndex; 
    while(bFindRes)
    {
        _tcsncpy(pPathEnd, findData.cFileName, MAX_PATH - dwDirLen);
        if(!IsValidCoverPage(tszCovDir))
        {
            goto next;
        }                
        //
        // file name
        //
        iIndex = m_cpList.InsertItem(m_cpList.GetItemCount(), findData.cFileName, LIST_IMAGE_COVERPAGE);
        if(iIndex < 0)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::InsertItem"), dwRes);
            goto exit;
        }
        //
        // last modified
        //
        {
            CFaxTime tmModified(findData.ftLastWriteTime);
            try
            {
                cstrText = tmModified.FormatByUserLocale(TRUE);
            }
            catch(...)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY; 
                CALL_FAIL (MEM_ERR, TEXT ("CString::operator="), dwRes);
                goto exit;
            }
        }
        nRes = m_cpList.SetItemText(iIndex, 1, cstrText);
        if(!nRes)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::SetItemText"), dwRes);
            goto exit;
        }
        //
        // file size
        //
        ulSize.LowPart  = findData.nFileSizeLow;
        ulSize.HighPart = findData.nFileSizeHigh;
        dwRes = FaxSizeFormat(ulSize.QuadPart, cstrText);
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("FaxSizeFormat"), dwRes);
            goto exit;
        }

        nRes = m_cpList.SetItemText(iIndex, 2, cstrText);
        if(!nRes)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::SetItemText"), dwRes);
            goto exit;
        }
        //
        // Find Next File
        //
next:
        bFindRes = FindNextFile(hFile, &findData);
        if(!bFindRes)
        {
            dwError = GetLastError();
            if(ERROR_NO_MORE_FILES != dwError)
            {
                dwRes = dwError;
                CALL_FAIL (FILE_ERR, TEXT("FindNextFile"), dwRes);
            }
            break;
        }
    }

exit:
    if(INVALID_HANDLE_VALUE != hFile)
    {
        if(!FindClose(hFile))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("FindClose"), GetLastError());
        }
    }

    CalcButtonsState();

    return dwRes;
}

void 
CCoverPagesDlg::OnItemchangedListCp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    CalcButtonsState();
    
	*pResult = 0;
}


void 
CCoverPagesDlg::OnDblclkListCp(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnCpOpen();

	*pResult = 0;
}

void 
CCoverPagesDlg::OnKeydownListCp(NMHDR* pNMHDR, LRESULT* pResult) 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnKeydownListCp"));

    LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;

    switch(pLVKeyDow->wVKey)
    {
    case VK_F5:
        dwRes = RefreshFolder();
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT ("RefreshFolder"), dwRes);
        }
        break;

    case VK_DELETE:
        OnCpDelete();
        break;

    case VK_RETURN:
        OnCpOpen();
        break;
    }
    
	*pResult = 0;
}

void 
CCoverPagesDlg::OnCpNew() 
/*++

Routine name : CCoverPagesDlg::OnCpNew

Routine description:

	create new cover page

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnCpNew"));

    dwRes = StartEditor(NULL);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("StartEditor"), dwRes);
        PopupError(dwRes);
    }

    dwRes = RefreshFolder();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshFolder"), dwRes);
        PopupError(dwRes);
    }
}

void 
CCoverPagesDlg::OnCpOpen() 
/*++

Routine name : CCoverPagesDlg::OnCpOpen

Routine description:

	open selected cover page in editor

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnCpOpen"));

    DWORD dwSelected = m_cpList.GetSelectedCount();
    if(1 != dwSelected)
    {
        return;
    }

    int nIndex = m_cpList.GetNextItem (-1, LVNI_SELECTED);
    ASSERTION (0 <= nIndex);

    TCHAR  tszFileName[MAX_PATH+5];
    TCHAR* tszPtr = tszFileName;

    //
    // add quotation to file name
    //
    _tcscpy(tszPtr, TEXT("\""));
    tszPtr = _tcsinc(tszPtr);

    m_cpList.GetItemText(nIndex, 0, tszPtr, MAX_PATH); 

    _tcscat(tszPtr, TEXT("\""));

    dwRes = StartEditor(tszFileName);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("StartEditor"), dwRes);
        PopupError(dwRes);
    }

    dwRes = RefreshFolder();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshFolder"), dwRes);
        PopupError(dwRes);
    }
}

void 
CCoverPagesDlg::OnCpRename() 
/*++

Routine name : CCoverPagesDlg::OnCpRename

Routine description:

	start renaming a file name

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnCpRename"));

    int nIndex = m_cpList.GetNextItem (-1, LVNI_SELECTED);
    if(nIndex < 0)
    {
        return;
    }

    m_cpList.SetFocus();
    m_cpList.EditLabel(nIndex);
}

void 
CCoverPagesDlg::OnEndLabelEditListCp(NMHDR* pNMHDR, LRESULT* pResult) 
/*++

Routine name : CCoverPagesDlg::OnCpRename

Routine description:

	end of file renaming

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnEndLabelEditListCp"));

    *pResult = 0;

    LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;

    int nIndex = pDispInfo->item.iItem;

    TCHAR tszOldName[MAX_PATH+1];
    m_cpList.GetItemText(nIndex, 0, tszOldName, MAX_PATH); 
    
    if(NULL == pDispInfo->item.pszText || 
       _tcscmp(tszOldName, pDispInfo->item.pszText) == 0)
    {
        return;
    }

    //
    // get old and new file names
    //
    TCHAR tszCovDir[MAX_PATH+1];
    if(!GetClientCpDir(tszCovDir, sizeof(tszCovDir) / sizeof(tszCovDir[0])))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetClientCpDir"), dwRes);
        PopupError(dwRes);
        return;
    }

    CString cstrOldFullName;
    CString cstrNewFullName;
    try
    {
        cstrOldFullName.Format(TEXT("%s\\%s"), tszCovDir, tszOldName);
        cstrNewFullName.Format(TEXT("%s\\%s"), tszCovDir, pDispInfo->item.pszText);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
        PopupError(dwRes);
        return;
    }

    //
    // rename the file
    //
    if(!MoveFile(cstrOldFullName, cstrNewFullName))
    {
        dwRes = GetLastError();
        CALL_FAIL (FILE_ERR, TEXT("MoveFile"), dwRes);
        PopupError(dwRes);
        return;
    }

    *pResult = TRUE;
}

void 
CCoverPagesDlg::OnCpDelete() 
/*++

Routine name : CCoverPagesDlg::OnCpDelete

Routine description:

	delete selected cover page

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnCpDelete"));
	
    DWORD dwSelected = m_cpList.GetSelectedCount();
    if(1 != dwSelected)
    {
        return;
    }

    if(theApp.GetProfileInt(CLIENT_CONFIRM_SEC, CLIENT_CONFIRM_ITEM_DEL, 1))
    {     
        //
        // we should ask to confirm 
        //
        CString cstrMsg;
        dwRes = LoadResourceString(cstrMsg, IDS_SURE_DELETE_ONE);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
            PopupError(dwRes);
            return;
        }

        //
        // are you sure ?
        //
        if(AlignedAfxMessageBox(cstrMsg, MB_YESNO | MB_ICONQUESTION) != IDYES)
        {
            return;
        }
    }


    int nIndex = m_cpList.GetNextItem (-1, LVNI_SELECTED);
    ASSERTION (0 <= nIndex);

    //
    // get file name
    //
    TCHAR tszFileName[MAX_PATH+1];
    m_cpList.GetItemText(nIndex, 0, tszFileName, MAX_PATH); 

    TCHAR tszCovDir[MAX_PATH+1];
    if(!GetClientCpDir(tszCovDir, sizeof(tszCovDir) / sizeof(tszCovDir[0])))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetClientCpDir"), dwRes);
        PopupError(dwRes);
        return;
    }

    CString cstrFullFileName;
    try
    {
        cstrFullFileName.Format(TEXT("%s\\%s"), tszCovDir, tszFileName);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
        PopupError (dwRes);
        return;
    }

    //
    // delete the file
    //
    if(!DeleteFile(cstrFullFileName))
    {
        dwRes = GetLastError();
        CALL_FAIL (FILE_ERR, TEXT("DeleteFile"), dwRes);
        PopupError(dwRes);
        return;
    }

    if(!m_cpList.DeleteItem(nIndex))
    {
        PopupError (ERROR_CAN_NOT_COMPLETE);
        return;
    }
}

void 
CCoverPagesDlg::OnCpAdd() 
/*++

Routine name : CCoverPagesView::OnCpAdd

Routine description:

	open file dialog for choosing file

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnCpAdd"));

    TCHAR szFile[MAX_PATH] = {0};
    TCHAR szFilter[MAX_PATH] = {0};
    TCHAR szInitialDir[MAX_PATH * 2] = {0};
    OPENFILENAME ofn = {0};

    CString cstrFilterFormat;
    dwRes = LoadResourceString(cstrFilterFormat, IDS_CP_ADD_FILTER_FORMAT);
    if (ERROR_SUCCESS != dwRes)
    {
        ASSERTION_FAILURE;
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
        return;
    }

    _stprintf(szFilter, cstrFilterFormat, FAX_COVER_PAGE_MASK, 0, FAX_COVER_PAGE_MASK, 0);

    CString cstrTitle;
    dwRes = LoadResourceString(cstrTitle, IDS_COPY_CP_TITLE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
    }
    else
    {
        //
        // Set open file dialog title
        //
        ofn.lpstrTitle = cstrTitle;
    }

    //
    // Attempt to read path of server (e.g. common) CP folder as initial path
    //
    if (GetServerCpDir (NULL, szInitialDir, ARR_SIZE(szInitialDir)))
    {
        ofn.lpstrInitialDir = szInitialDir;
    }
        
    ofn.lStructSize = GetOpenFileNameStructSize();
    ofn.hwndOwner   = m_hWnd;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile   = szFile;
    ofn.nMaxFile    = ARR_SIZE(szFile);
    ofn.lpstrDefExt = FAX_COVER_PAGE_EXT_LETTERS;
    ofn.Flags       = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST;

    if(!GetOpenFileName(&ofn))
    {
        return;
    }

    dwRes = CopyPage(szFile, &(szFile[ofn.nFileOffset]) );
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CopyPage"), dwRes);
    }    
}


void 
CCoverPagesDlg::CalcButtonsState()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::CalcButtonsState"), dwRes);

    DWORD dwControls[] = 
    {
        IDC_LIST_CP,
        IDC_CP_NEW,
        IDC_CP_OPEN,
        IDC_CP_ADD,
        IDC_CP_RENAME,
        IDC_CP_DELETE,
        IDCANCEL
    };

    CWnd* pWnd = NULL;
    DWORD dwControlNum = sizeof(dwControls)/sizeof(dwControls[0]);

    //
    // if the Cover Page Editor is open disable all controls
    //
    for(DWORD dw=0; dw < dwControlNum; ++dw)
    {
        pWnd = GetDlgItem(dwControls[dw]);
        if(NULL == pWnd)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CWnd::GetDlgItem"), ERROR_INVALID_HANDLE);
            ASSERTION_FAILURE;
            continue;
        }
        pWnd->EnableWindow(!m_hEditorThread);
    }

    if(m_hEditorThread)
    {
        return;
    }

    DWORD dwSelCount = m_cpList.GetSelectedCount();

    m_butOpen.EnableWindow(1 == dwSelCount);
    m_butRename.EnableWindow(1 == dwSelCount);
    m_butDelete.EnableWindow(0 < dwSelCount);
}

DWORD 
CCoverPagesDlg::CopyPage(
    const CString& cstrPath, 
    const CString& cstrName
)
/*++

Routine name : CCoverPagesDlg::CopyPage

Routine description:

	copy file to the personal folder

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:

	cstrPath                      [in]     - full path
	cstrName                      [in]     - file name

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::CopyPage"), dwRes);

    LVFINDINFO findInfo = {0};
    findInfo.flags = LVFI_STRING;
    findInfo.psz = cstrName;

    CString cstrMsg;
    int nIndex = m_cpList.FindItem(&findInfo);
    if(nIndex >= 0)
    {
        //
        // file with this name already exists
        //
        try
        {
            AfxFormatString1(cstrMsg, IDS_COVER_PAGE_EXISTS, cstrName);
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("AfxFormatString1"), dwRes);
            return dwRes;
        }

        //
        // ask for overwrite
        //
        if(IDYES != AlignedAfxMessageBox(cstrMsg, MB_YESNO | MB_ICONQUESTION))
        {
            return dwRes;
        }
    }


    //
    // prepare a string with new file location
    //
    TCHAR tszCovDir[MAX_PATH+1];
    if(!GetClientCpDir(tszCovDir, sizeof(tszCovDir) / sizeof(tszCovDir[0])))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetClientCpDir"), dwRes);
        return dwRes;
    }

    CString cstrNewFileName;
    try
    {
        cstrNewFileName.Format(TEXT("%s\\%s"), tszCovDir, cstrName);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
        return dwRes;
    }

    //
    // copy file
    //
    BOOL bFailIfExists = FALSE;
    if(!CopyFile(cstrPath, cstrNewFileName, bFailIfExists))
    {
        dwRes = GetLastError();
        CALL_FAIL (FILE_ERR, TEXT("CopyFile"), dwRes);
        return dwRes;
    }

    dwRes = RefreshFolder();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshFolder"), dwRes);
        return dwRes;
    }

    return dwRes;
}

DWORD 
CCoverPagesDlg::StartEditor(
    LPCTSTR lpFile
)
/*++

Routine name : CCoverPagesDlg::StartEditor

Routine description:

    start cover pages editor

Author:

    Alexander Malysh (AlexMay), Feb, 2000

Arguments:

    lpFile                        [in]     - file name

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::StartEditor"), dwRes);

    TCHAR* tszParam = NULL;

    if(lpFile)
    {
        tszParam = StringDup(lpFile);
        if(!tszParam)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("StringDup"), dwRes);
            return dwRes;
        }
    }

    DWORD dwThreadId;
    m_hEditorThread = CreateThread(
                                   NULL,                 // SD
                                   0,                    // initial stack size
                                   StartEditorThreadProc,// thread function
                                   (LPVOID)tszParam,     // thread argument
                                   0,                    // creation option
                                   &dwThreadId           // thread identifier
                                  );
    if(!m_hEditorThread)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("CreateThread"), dwRes);        
        if(tszParam)
        {
            MemFree(tszParam);
        }
        return dwRes;
    }

    CalcButtonsState();

    return dwRes;
} // CCoverPagesDlg::StartEditor


DWORD 
WINAPI 
CCoverPagesDlg::StartEditorThreadProc(
    LPVOID lpFile
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::StartEditorThreadProc"), dwRes);

    TCHAR tszCovDir[MAX_PATH+1] = {0};
  	SHELLEXECUTEINFO executeInfo = {0};

    //
    // get cover pages editor location
    //
    CString cstrCovEditor;
    dwRes = GetAppLoadPath(cstrCovEditor);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("GetAppLoadPath"), dwRes);
        goto exit;
    }

    try
    {
        cstrCovEditor += FAX_COVER_IMAGE_NAME;
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::operator+"), dwRes);
        goto exit;
    }

    //
    // get cover pages directory
    //
    if(!GetClientCpDir(tszCovDir, sizeof(tszCovDir) / sizeof(tszCovDir[0])))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetClientCpDir"), dwRes);
        goto exit;
    }
    
	//
	// prepare SHELLEXECUTEINFO struct for ShellExecuteEx function
	//
	executeInfo.cbSize = sizeof(executeInfo);
	executeInfo.fMask  = SEE_MASK_NOCLOSEPROCESS;
	executeInfo.lpVerb = TEXT("open");
	executeInfo.lpFile = cstrCovEditor;
    executeInfo.lpParameters = (TCHAR*)lpFile;
    executeInfo.lpDirectory  = tszCovDir;
	executeInfo.nShow  = SW_RESTORE;

	//
	// Execute an aplication
	//
	if(!ShellExecuteEx(&executeInfo))
	{
		dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("ShellExecuteEx"), dwRes);
		goto exit;
	}

    DWORD dwWaitRes;    
    dwWaitRes = WaitForSingleObject(executeInfo.hProcess, INFINITE);

    switch(dwWaitRes)
    {
    case WAIT_OBJECT_0:
        //
        // cover pages editor is dead
        //
        break;

    default:
        dwRes = dwWaitRes;
        ASSERTION_FAILURE
        break;
    }

    if(!CloseHandle(executeInfo.hProcess))
    {
		dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("CloseHandle"), dwRes);
    }

exit:
    if(lpFile)
    {
        MemFree(lpFile);
    }

    ASSERTION(CCoverPagesDlg::m_hDialog);
    ::SendMessage(CCoverPagesDlg::m_hDialog, WM_CP_EDITOR_CLOSED, 0, NULL);

    return dwRes;
} // CCoverPagesDlg::StartEditorThreadProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\cmdlineinfo.h ===
// CmdLineInfo.h: interface for the CCmdLineInfo class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CMDLINEINFO_H__505B2DF0_17E3_4E13_8BDE_34D3FF703482__INCLUDED_)
#define AFX_CMDLINEINFO_H__505B2DF0_17E3_4E13_8BDE_34D3FF703482__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CCmdLineInfo : public CCommandLineInfo  
{
public:

    enum CmdLineFlags
    {
        CMD_FLAG_FOLDER,        // Folder specified
        CMD_FLAG_MESSAGE_ID,    // Message ID specified
        CMD_FLAG_NONE           // No flag specified    
    };

    CCmdLineInfo():
        m_cmdLastFlag(CMD_FLAG_NONE),
        m_FolderType(FOLDER_TYPE_INBOX),     // Default folder on startup is 'Inbox'
        m_dwlMessageId(0),                   // Do not select any message on startup,
        m_bForceNewInstace (FALSE)           // By default, previous instances are used
        {}

    virtual ~CCmdLineInfo() {}

    void ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast );

    DWORDLONG GetMessageIdToSelect () const { return m_dwlMessageId; }

    BOOL IsOpenFolder() { return m_FolderType < FOLDER_TYPE_MAX; }
    FolderType GetFolderType() 
        { ASSERT(IsOpenFolder()); return m_FolderType; }

    BOOL IsSingleServer() {return !m_cstrServerName.IsEmpty(); }
    CString& GetSingleServerName()
        { ASSERT(IsSingleServer()); return m_cstrServerName; }

    BOOL ForceNewInstance ()    { return m_bForceNewInstace; }

private:

    CmdLineFlags    m_cmdLastFlag;
    FolderType      m_FolderType;       // Folder to open on startup    
    DWORDLONG       m_dwlMessageId;     // Message id to select on startup
    BOOL            m_bForceNewInstace; // Do we force a new instance (/new) ?

    CString m_cstrServerName;

};

#endif // !defined(AFX_CMDLINEINFO_H__505B2DF0_17E3_4E13_8BDE_34D3FF703482__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\columnselectdlg.cpp ===
// ColumnSelectDlg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     35

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CColumnSelectDlg dialog


CColumnSelectDlg::CColumnSelectDlg
(
    const CString* pcstrTitles, 
    int* pnOrderedItems, 
    DWORD dwListSize,
    DWORD& dwSelectedItems,
    CWnd* pParent /*=NULL*/
):
/*++

Routine name : CColumnSelectDlg::CColumnSelectDlg

Routine description:

    Select dialog constructor

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    pcstrTitles                   [in]     - titles array
    pnOrderedItems                [in/out] - array of ordered indexes
    dwListSize                    [in]     - size of these arrays
    dwSelectedItems               [in/out] - number of selected items
    pParent                       [in]     - parent window

Return Value:

    None.

--*/
    CFaxClientDlg(CColumnSelectDlg::IDD, pParent),
    m_pcstrTitles(pcstrTitles), 
    m_pnOrderedItems(pnOrderedItems),
    m_dwListSize(dwListSize),
    m_rdwSelectedItems(dwSelectedItems),
    m_nCaptionId(-1),
    m_nAvailableId(-1),
    m_nDisplayedId(-1)
{
    DBG_ENTER(TEXT("CColumnSelectDlg::CColumnSelectDlg"));

    ASSERTION(NULL != m_pcstrTitles);
    ASSERTION(NULL != m_pnOrderedItems);
    ASSERTION(0 < m_dwListSize);
    ASSERTION(m_rdwSelectedItems <= m_dwListSize);
    
    //{{AFX_DATA_INIT(CColumnSelectDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}   // CColumnSelectDlg::CColumnSelectDlg

void 
CColumnSelectDlg::DoDataExchange(CDataExchange* pDX)
{
    CFaxClientDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CColumnSelectDlg)
    DDX_Control(pDX, IDOK, m_butOk);
    DDX_Control(pDX, IDC_STATIC_DISPLAYED, m_groupDisplayed);
    DDX_Control(pDX, IDC_STATIC_AVAILABLE, m_groupAvailable);
    DDX_Control(pDX, IDC_BUT_ADD, m_butAdd);
    DDX_Control(pDX, IDC_BUT_REMOVE, m_butRemove);
    DDX_Control(pDX, IDC_BUT_UP, m_butUp);
    DDX_Control(pDX, IDC_BUT_DOWN, m_butDown);
    DDX_Control(pDX, IDC_LIST_DISPLAYED, m_ListCtrlDisplayed);
    DDX_Control(pDX, IDC_LIST_AVAILABLE, m_ListCtrlAvailable);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CColumnSelectDlg, CFaxClientDlg)
    //{{AFX_MSG_MAP(CColumnSelectDlg)
    ON_BN_CLICKED(IDC_BUT_DOWN, OnButDown)
    ON_BN_CLICKED(IDC_BUT_UP, OnButUp)
    ON_BN_CLICKED(IDC_BUT_REMOVE, OnButRemove)
    ON_BN_CLICKED(IDC_BUT_ADD, OnButAdd)
    ON_LBN_SELCHANGE(IDC_LIST_AVAILABLE, OnSelChangeListAvailable)
    ON_LBN_SELCHANGE(IDC_LIST_DISPLAYED, OnSelChangeListDisplayed)
    ON_LBN_DBLCLK(IDC_LIST_AVAILABLE, OnDblclkListAvailable)
    ON_LBN_DBLCLK(IDC_LIST_DISPLAYED, OnDblclkListDisplayed)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CColumnSelectDlg message handlers


BOOL 
CColumnSelectDlg::OnInitDialog() 
/*++

Routine name : CColumnSelectDlg::OnInitDialog

Routine description:

    Init Dialog message handler

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    TRUE if successful initialization, FALSE otherwise.

--*/
{
    BOOL bRes=TRUE;
    DBG_ENTER(TEXT("CColumnSelectDlg::OnInitDialog"), bRes);

    CFaxClientDlg::OnInitDialog();

    if(!InputValidate())
    {
        bRes = FALSE;
        CALL_FAIL (GENERAL_ERR, TEXT("InputValidate"), bRes);
        goto exit;
    }

    DWORD dwColumnId, i;    
    CListBox* pListBox;

    for (i=0; i < m_dwListSize; ++i)
    {
        dwColumnId = m_pnOrderedItems[i];

        pListBox = (i < m_rdwSelectedItems) ? &m_ListCtrlDisplayed : &m_ListCtrlAvailable;

        if(!AddStrToList(*pListBox, dwColumnId))
        {
            bRes = FALSE;
            CALL_FAIL (GENERAL_ERR, TEXT("AddStrToList"), bRes);
            goto exit;
        }
    }

    SetWndCaption(this, m_nCaptionId);
    SetWndCaption(&m_groupAvailable, m_nAvailableId);
    SetWndCaption(&m_groupDisplayed, m_nDisplayedId);

    CalcButtonsState();
    
exit:

    if(!bRes)
    {
        EndDialog(IDABORT);
    }

    return bRes; 
}   // CColumnSelectDlg::OnInitDialog

void 
CColumnSelectDlg::OnOK() 
/*++

Routine name : CColumnSelectDlg::OnOK

Routine description:

    OK button message handler
    save slected item IDs to m_pnOrderedItems array

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnOK"));

    DWORD dwDisplayCount = m_ListCtrlDisplayed.GetCount();
    if(LB_ERR == dwDisplayCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetCount"), 0);
        EndDialog(IDABORT);
        return;
    }
    ASSERTION(dwDisplayCount <= m_dwListSize);

    //
    // compare slected item IDs to m_pnOrderedItems array
    //
    DWORD dwId;
    BOOL bModified = FALSE;
    for (DWORD i=0; i < dwDisplayCount; ++i)
    {
        dwId = m_ListCtrlDisplayed.GetItemData(i);
        if(LB_ERR == dwId)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetItemData"), 0);
            EndDialog(IDABORT);
            return;
        }

        if(m_pnOrderedItems[i] != (int)dwId)
        {
            bModified = TRUE;
            m_pnOrderedItems[i] = dwId;
        }
    }

    //
    // check m_pnOrderedItems[dwCount] element
    //
    if(dwDisplayCount != m_rdwSelectedItems)
    {
        bModified = TRUE;
        m_rdwSelectedItems = dwDisplayCount;
    }

    if(!bModified)
    {
        //
        // OK pressed, but nothing changed
        //
        EndDialog(IDCANCEL);
        return;
    }


    DWORD dwAvailCount = m_ListCtrlAvailable.GetCount();
    if(LB_ERR == dwAvailCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetCount"), 0);
        EndDialog(IDABORT);
        return;
    }

    //
    // save slected item IDs to m_pnOrderedItems array
    //
    for (i=0; i < dwAvailCount; ++i)
    {
        dwId = m_ListCtrlAvailable.GetItemData(i);
        if(LB_ERR == dwId)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetItemData"), 0);
            EndDialog(IDABORT);
            return;
        }

        ASSERTION(dwId < m_dwListSize);
        ASSERTION(dwDisplayCount + i < m_dwListSize);

        m_pnOrderedItems[dwDisplayCount + i] = dwId;
    }
    
    EndDialog(IDOK);
}   // CColumnSelectDlg::OnOK


void 
CColumnSelectDlg::OnButDown() 
/*++

Routine name : CColumnSelectDlg::OnButDown

Routine description:

    Move Down button message handler
    move down selected item of m_ListCtrlDisplayed

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnButDown"));

    MoveItemVertical(1);
}

void 
CColumnSelectDlg::OnButUp() 
/*++

Routine name : CColumnSelectDlg::OnButUp

Routine description:

    Move Up button message handler
    move up selected item of m_ListCtrlDisplayed

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnButUp"));

    MoveItemVertical(-1);
}

void 
CColumnSelectDlg::OnButAdd() 
/*++

Routine name : CColumnSelectDlg::OnButAdd

Routine description:

    Add button message handler
    move selected items from Available to Displayed list box

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnButAdd"));

    MoveSelectedItems(m_ListCtrlAvailable, m_ListCtrlDisplayed);
}


void 
CColumnSelectDlg::OnButRemove() 
/*++

Routine name : CColumnSelectDlg::OnButRemove

Routine description:

    Remove button message handler
    move selected item from Displayed to Available list box

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnButRemove"));

    MoveSelectedItems(m_ListCtrlDisplayed, m_ListCtrlAvailable);
}

void 
CColumnSelectDlg::OnSelChangeListAvailable() 
/*++

Routine name : CColumnSelectDlg::OnSelChangeListAvailable

Routine description:

    Selection Change of Available List message handler
    
Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnSelChangeListAvailable"));

    CalcButtonsState();
}

void 
CColumnSelectDlg::OnSelChangeListDisplayed() 
/*++

Routine name : CColumnSelectDlg::OnSelChangeListDisplayed

Routine description:

    Selection Change of Displayed List message handler
    
Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnSelChangeListDisplayed"));

    CalcButtonsState();
}

void 
CColumnSelectDlg::OnDblclkListAvailable() 
/*++

Routine name : CColumnSelectDlg::OnDblclkListAvailable

Routine description:

    Double click in Available List message handler
    add item if selected

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnDblclkListAvailable"));
    
    int nSelCount = m_ListCtrlAvailable.GetSelCount();
    if(LB_ERR == nSelCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelCount"), 0);
        EndDialog(IDABORT);
        return;
    }

    if(0 < nSelCount)
    {
        MoveSelectedItems(m_ListCtrlAvailable, m_ListCtrlDisplayed);
    }   
}

void 
CColumnSelectDlg::OnDblclkListDisplayed() 
/*++

Routine name : CColumnSelectDlg::OnDblclkListDisplayed

Routine description:

    Double click in Displayed List message handler
    remove item if selected

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnDblclkListDisplayed"));
    
    int nSelCount = m_ListCtrlDisplayed.GetSelCount();
    if(LB_ERR == nSelCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelCount"), 0);
        EndDialog(IDABORT);
        return;
    }

    if(0 < nSelCount)
    {
        MoveSelectedItems(m_ListCtrlDisplayed, m_ListCtrlAvailable);
    }   
}


/////////////////////////////////////////////////////////////////////////////
// CColumnSelectDlg private functions

// 
// add item to list box
//
BOOL 
CColumnSelectDlg::AddStrToList(
    CListBox& listBox, 
    DWORD dwItemId      
) 
/*++

Routine name : CColumnSelectDlg::AddStrToList

Routine description:

    Adds item to listBox

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    listBox                       [in]     - CListBox
    dwItemId                      [in]     - index of item in m_pcstrTitles array

Return Value:

    TRUE if success, FALSE otherwise.

--*/
{
    BOOL bRes=TRUE;
    DBG_ENTER(TEXT("CColumnSelectDlg::AddStrToList"), bRes);

    ASSERTION(dwItemId < m_dwListSize);

    DWORD dwIndex = listBox.AddString(m_pcstrTitles[dwItemId]);
    if(LB_ERR == dwIndex)
    {
        bRes = FALSE;
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::AddString"), bRes);
        EndDialog(IDABORT);
        return bRes;
    }
    if(LB_ERRSPACE == dwIndex)
    {
        bRes = FALSE;
        CALL_FAIL (MEM_ERR, TEXT ("CListBox::AddString"), bRes);
        EndDialog(IDABORT);
        return bRes;
    }

    int nRes = listBox.SetItemData(dwIndex, dwItemId);
    if(LB_ERR == nRes)
    {
        bRes = FALSE;
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::SetItemData"), bRes);
        EndDialog(IDABORT);
        return bRes;
    }

    return bRes;
}

void 
CColumnSelectDlg::MoveItemVertical(
    int nStep
)
/*++

Routine name : CColumnSelectDlg::MoveItemVertical

Routine description:

    Moves selected item in Displayes ListBox up or down

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    nStep                         [in]     - offset from current position

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::MoveItemVertical"));

    //
    // get Displayed list count
    //
    int nCount = m_ListCtrlDisplayed.GetCount();
    if(LB_ERR == nCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetCount"), 0);
        EndDialog(IDABORT);
        return;
    }

    ASSERTION(1 < nCount);

    //
    // get current selection count of Displayed list
    //
    int nSelCount = m_ListCtrlDisplayed.GetSelCount();
    if(LB_ERR == nSelCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelCount"), 0);
        EndDialog(IDABORT);
        return;
    }
    ASSERTION(1 == nSelCount);

    //
    // get selected item of Displayed list
    //
    int nIndex, nRes;
    nRes = m_ListCtrlDisplayed.GetSelItems(1, &nIndex) ;
    if(LB_ERR == nRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelItems"), 0);
        EndDialog(IDABORT);
        return;
    }
    int nNewIndex = nIndex + nStep;
    ASSERTION(0 <= nNewIndex && nCount > nNewIndex);

    //
    // get item data
    //
    DWORD dwId = m_ListCtrlDisplayed.GetItemData(nIndex);
    if(dwId == LB_ERR)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetItemData"), 0);
        EndDialog(IDABORT);
        return;
    }
    ASSERTION(dwId < m_dwListSize);

    //
    // delete selected item
    //
    nRes = m_ListCtrlDisplayed.DeleteString(nIndex);
    if(LB_ERR == nRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::DeleteString"), 0);
        EndDialog(IDABORT);
        return;
    }   

    //
    // insert item into new location
    //
    nRes = m_ListCtrlDisplayed.InsertString(nNewIndex, m_pcstrTitles[dwId]);
    if(LB_ERR == nRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::InsertString"), 0);
        EndDialog(IDABORT);
        return;
    }
    if(LB_ERRSPACE == nRes)
    {
        CALL_FAIL (MEM_ERR, TEXT("CListBox::InsertString"), 0);
        EndDialog(IDABORT);
        return;
    }

    nRes = m_ListCtrlDisplayed.SetItemData(nNewIndex, dwId );
    if(LB_ERR == nRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::SetItemData"), 0);
        EndDialog(IDABORT);
        return;
    }

    //
    // set selection    
    //
    nRes = m_ListCtrlDisplayed.SetSel(nNewIndex);
    if(LB_ERR == nRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::SetSel"), 0);
        EndDialog(IDABORT);
        return;
    }

    CalcButtonsState();
}

void CColumnSelectDlg::MoveSelectedItems(
    CListBox& listFrom, 
    CListBox& listTo
)
/*++

Routine name : CColumnSelectDlg::MoveSelectedItems

Routine description:

    moves selected items from one CListBox to another

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    listFrom                      [in/out] - source CListBox
    listTo                        [in/out] - destination CListBox

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::MoveSelectedItems"));

    //
    // get current selection count
    //
    int nSelCount = listFrom.GetSelCount();
    if(LB_ERR == nSelCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelCount"), 0);
        EndDialog(IDABORT);
        return;
    }

    ASSERTION(0 < nSelCount);
    
    DWORD dwId;
    int nRes, nIndex;
    for(int i=0; i < nSelCount; ++i)
    {
        //
        // get one selected item
        //
        nRes = listFrom.GetSelItems(1, &nIndex) ;
        if(LB_ERR == nRes)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelItems"), 0);
            EndDialog(IDABORT);
            return;
        }

        //
        // get item data
        //
        dwId = listFrom.GetItemData(nIndex);
        if(LB_ERR == dwId)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetItemData"), 0);
            EndDialog(IDABORT);
            return;
        }

        //
        // delete selected item
        //
        nRes = listFrom.DeleteString(nIndex);
        if(LB_ERR == nRes)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListBox::DeleteString"), 0);
            EndDialog(IDABORT);
            return;
        }   

        //
        // add item to another list
        //
        if(!AddStrToList(listTo, dwId))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("AddStrToList"), 0);
            EndDialog(IDABORT);
            return;
        }
    }

    CalcButtonsState();
}


void 
CColumnSelectDlg::CalcButtonsState()
{
    DBG_ENTER(TEXT("CColumnSelectDlg::CalcButtonsState"));
    
    //
    // get current selection of Available list
    // calculate Add button state
    //
    int nSelCount = m_ListCtrlAvailable.GetSelCount();
    if(LB_ERR == nSelCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelCount"), 0);
        EndDialog(IDABORT);
        return;
    }
    m_butAdd.EnableWindow(nSelCount > 0);

    //
    // get Displayed list count
    // calculate OK button state
    //
    int nCount = m_ListCtrlDisplayed.GetCount();
    if(LB_ERR == nCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetCount"), 0);
        EndDialog(IDABORT);
        return;
    }
    m_butOk.EnableWindow(nCount > 0);

    //
    // get current selection count of Displayed list
    // calculate Remove button state
    //
    nSelCount = m_ListCtrlDisplayed.GetSelCount();
    if(LB_ERR == nSelCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelCount"), 0);
        EndDialog(IDABORT);
        return;
    }
    m_butRemove.EnableWindow(nSelCount > 0);

    //
    // get selected item of Displayed list
    // calculate Up and Down buttons state
    //
    int nIndex, nRes;
    if(1 == nSelCount && 1 < nCount)
    {
        nRes = m_ListCtrlDisplayed.GetSelItems(1, &nIndex) ;
        if(LB_ERR == nRes)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelItems"), 0);
            EndDialog(IDABORT);
            return;
        }
        m_butUp.EnableWindow(nIndex > 0);
        m_butDown.EnableWindow(nIndex < nCount-1);
    }
    else
    {
        m_butUp.EnableWindow(FALSE);
        m_butDown.EnableWindow(FALSE);
    }
}


BOOL
CColumnSelectDlg::SetWndCaption (
    CWnd* pWnd,
    int   nResId
)
/*++

Routine name : CColumnSelectDlg::SetWndCaption

Routine description:

    Change window caption

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    pWnd                          [in/out] - CWnd pointer
    nResId                        [in]     - string resource ID

Return Value:

    TRUE if success, FALSE otherwise.

--*/
{
    BOOL bRes=TRUE;
    DBG_ENTER(TEXT("CColumnSelectDlg::SetWndCaption"), bRes);

    if(0 > nResId)
    {
        return bRes;
    }

    ASSERTION(NULL != pWnd);

    CString cstrText;

    //
    // load resource string
    //
    DWORD dwRes = LoadResourceString (cstrText, nResId);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
        EndDialog(IDABORT);
    }
    //
    // set window caption
    //
    pWnd->SetWindowText(cstrText);

    return bRes;
} 

BOOL 
CColumnSelectDlg::InputValidate()
/*++

Routine name : CColumnSelectDlg::InputValidate

Routine description:

    checks consistency of order array

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    TRUE if input is valid, FALSE otherwise.

--*/
{
    BOOL bRes=TRUE;
    DBG_ENTER(TEXT("CColumnSelectDlg::InputValidate"), bRes);

    if(m_rdwSelectedItems > m_dwListSize)
    {
        bRes = FALSE;
        return bRes;
    }

    //
    // init temporary array
    //
    int* pnOrderCheck;
    try
    {
        pnOrderCheck = new int[m_dwListSize];
    }
    catch (...)
    {
        bRes = FALSE;
        CALL_FAIL (MEM_ERR, TEXT ("pnOrderCheck = new int[m_dwListSize]"), bRes);
        return bRes;
    }
    
    for(DWORD dw=0; dw < m_dwListSize; ++dw)
    {
        pnOrderCheck[dw] = -1;
    }

    //
    // sign indexes
    //
    int nIndex;
    for(dw=0; dw < m_dwListSize; ++dw)
    {
        nIndex = m_pnOrderedItems[dw];
        ASSERTION(nIndex >= 0 && nIndex < m_dwListSize);

        pnOrderCheck[nIndex] = dw;
    }

    for(dw=0; dw < m_dwListSize; ++dw)
    {
        if(pnOrderCheck[dw] < 0)
        {
            bRes = FALSE;
            break;
        }
    }

    delete[] pnOrderCheck;

    return bRes;

} // CColumnSelectDlg::InputValidate
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\faxclientdlg.cpp ===
// FaxClientDlg.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     72


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFaxClientDlg dialog


CFaxClientDlg::CFaxClientDlg(DWORD dwDlgId, CWnd* pParent /*=NULL*/)
    : CDialog(dwDlgId, pParent),
    m_dwLastError(ERROR_SUCCESS)
{
    //{{AFX_DATA_INIT(CFaxClientDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CFaxClientDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFaxClientDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFaxClientDlg, CDialog)
    //{{AFX_MSG_MAP(CFaxClientDlg)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFaxClientDlg message handlers

LONG
CFaxClientDlg::OnHelp(
    WPARAM wParam,
    LPARAM lParam
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFaxClientDlg::OnHelp"));

    dwRes = WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("WinHelpContextPopup"),dwRes);
    }

    return TRUE;
}

void
CFaxClientDlg::OnContextMenu(
    CWnd* pWnd,
    CPoint point
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFaxClientDlg::OnContextMenu"));

    dwRes = WinHelpContextPopup(pWnd->GetWindowContextHelpId(), m_hWnd);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("WinHelpContextPopup"),dwRes);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\errordlg.h ===
#if !defined(AFX_ERRORDLG_H__E6A84A73_2471_4E02_848B_2263C157998A__INCLUDED_)
#define AFX_ERRORDLG_H__E6A84A73_2471_4E02_848B_2263C157998A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ErrorDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CErrorDlg dialog

class CErrorDlg : public CDialog
{
// Construction
public:
    CErrorDlg(
        DWORD   dwWin32ErrCode,
        DWORD   dwFileId,
        int     iLineNumber
        );

// Dialog Data
    //{{AFX_DATA(CErrorDlg)
    enum { IDD = IDD_ERROR };
    CStatic m_staticSeperator;
    BOOL    m_bDetails;
    CString m_cstrDetails;
    CString m_cstrErrorText;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CErrorDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CErrorDlg)
    afx_msg void OnDetails();
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:

    void FillErrorText ();

    CRect           m_rcBig;
    CRect           m_rcSmall;

    DWORD           m_dwWin32ErrCode;
    int             m_iLineNumber;
    DWORD           m_dwFileId;
};

#define PopupError(err)     {   CMainFrame *pFrm = GetFrm();                    \
                                if (pFrm)                                       \
                                    pFrm->PostMessage (WM_POPUP_ERROR,          \
                                           WPARAM(err),                         \
                                           MAKELPARAM(__LINE__, __FILE_ID__)); };


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ERRORDLG_H__E6A84A73_2471_4E02_848B_2263C157998A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\faxclientpg.cpp ===
// FaxClientPg.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     74

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CFaxClientPg property page

IMPLEMENT_DYNCREATE(CFaxClientPg, CPropertyPage)

CFaxClientPg::CFaxClientPg(
    UINT nIDTemplate,
    UINT nIDCaption
)   :CPropertyPage(nIDTemplate, nIDCaption)
{
    //
    // hide the Help button
    //
    m_psp.dwFlags &= ~PSP_HASHELP;
}

CFaxClientPg::~CFaxClientPg()
{
}

void CFaxClientPg::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFaxClientPg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFaxClientPg, CPropertyPage)
    //{{AFX_MSG_MAP(CFaxClientPg)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFaxClientPg message handlers

LONG
CFaxClientPg::OnHelp(
    WPARAM wParam,
    LPARAM lParam
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFaxClientPg::OnHelp"));

    dwRes = WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("WinHelpContextPopup"),dwRes);
    }

    return TRUE;
}

void
CFaxClientPg::OnContextMenu(
    CWnd* pWnd,
    CPoint point
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFaxClientPg::OnContextMenu"));

    dwRes = WinHelpContextPopup(pWnd->GetWindowContextHelpId(), m_hWnd);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("WinHelpContextPopup"),dwRes);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\errordlg.cpp ===
// ErrorDlg.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     8

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CErrorDlg dialog

CErrorDlg::CErrorDlg(
    DWORD   dwWin32ErrCode,
    DWORD   dwFileId,
    int     iLineNumber
)
    : CDialog(CErrorDlg::IDD, NULL),
      m_iLineNumber (iLineNumber),
      m_dwFileId (dwFileId),
      m_dwWin32ErrCode (dwWin32ErrCode)
{
    //{{AFX_DATA_INIT(CErrorDlg)
    m_bDetails = FALSE;
    m_cstrDetails = _T("");
    m_cstrErrorText = _T("");
    //}}AFX_DATA_INIT
}


void CErrorDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CErrorDlg)
    DDX_Control(pDX, IDC_SEPERATOR, m_staticSeperator);
    DDX_Check(pDX, IDC_DETAILS, m_bDetails);
    DDX_Text(pDX, IDC_DETAILS_DATA, m_cstrDetails);
    DDX_Text(pDX, IDC_ERROR_TEXT, m_cstrErrorText);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CErrorDlg, CDialog)
    //{{AFX_MSG_MAP(CErrorDlg)
    ON_BN_CLICKED(IDC_DETAILS, OnDetails)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CErrorDlg message handlers

BOOL CErrorDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();

    GetWindowRect (&m_rcBig);
    CRect rcSeperator;

    GetDlgItem(IDC_SEPERATOR)->GetWindowRect (&rcSeperator);
    m_rcSmall = m_rcBig;
    m_rcSmall.bottom = rcSeperator.top;
    //
    //  Shrink down to small size (initially)
    //
    OnDetails ();
    //
    // Fill in the error data
    //
    FillErrorText ();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void
CErrorDlg::FillErrorText ()
/*++

Routine name : CErrorDlg::FillErrorText

Routine description:

    Fills the text controls with a description of the error

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CErrorDlg::FillErrorText"));

    ASSERTION (m_dwWin32ErrCode);

    DWORD dwRes;
    CString cstrError;

    int iErrorId   = IDS_ERR_CANT_COMPLETE_OPERATION;
    int iDetailsId = 0;
    switch (m_dwWin32ErrCode)
    {
        case RPC_S_INVALID_BINDING:
        case EPT_S_CANT_PERFORM_OP:
        case RPC_S_ADDRESS_ERROR:
        case RPC_S_CALL_CANCELLED:
        case RPC_S_CALL_FAILED:
        case RPC_S_CALL_FAILED_DNE:
        case RPC_S_COMM_FAILURE:
        case RPC_S_NO_BINDINGS:
        case RPC_S_SERVER_TOO_BUSY:
        case RPC_S_SERVER_UNAVAILABLE:
            iErrorId = IDS_ERR_CONNECTION_FAILED;
            break;
        case ERROR_NOT_ENOUGH_MEMORY:
            iErrorId = IDS_ERR_NO_MEMORY;           
            break;
        case ERROR_ACCESS_DENIED:
            iErrorId = IDS_ERR_ACCESS_DENIED;    
            break;
        case FAX_ERR_SRV_OUTOFMEMORY:
            iDetailsId = IDS_ERR_SRV_OUTOFMEMORY;   
            break;
        case FAX_ERR_FILE_ACCESS_DENIED:
            iDetailsId = IDS_ERR_FILE_ACCESS_DENIED;
            break;
        case FAX_ERR_MESSAGE_NOT_FOUND:
            iDetailsId = IDS_ERR_MESSAGE_NOT_FOUND;
            break;
    }

    if(iDetailsId)
    {
        dwRes = LoadResourceString (cstrError, iDetailsId);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (MEM_ERR, TEXT("LoadResourceString"), dwRes);
        }
    }
    else
    {
        dwRes = Win32Error2String (m_dwWin32ErrCode, cstrError);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("Win32Error2String"), dwRes);
        }
    }

    try
    {
        m_cstrDetails.Format (TEXT("%s(%ld, %02ld%08ld)"), 
                              cstrError, 
                              m_dwWin32ErrCode,
                              m_dwFileId,
                              m_iLineNumber);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
    }

    dwRes = LoadResourceString (m_cstrErrorText, iErrorId);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (MEM_ERR, TEXT("LoadResourceString"), dwRes);
    }
    if (!UpdateData (FALSE))
    {
        CALL_FAIL (GENERAL_ERR, TEXT("UpdateData"), ERROR_GEN_FAILURE);
    }
}   // CErrorDlg::FillErrorText


void CErrorDlg::OnDetails() 
{   // The "Details" button was just pressed
    if (!UpdateData())
    {
        return;
    }
    CRect &rc = m_bDetails ? m_rcBig : m_rcSmall;
    SetWindowPos (NULL, rc.left, rc.top, rc.Width(), rc.Height(), SWP_NOOWNERZORDER);
}

void CErrorDlg::OnOK() 
{
    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\faxclientpg.h ===
#if !defined(AFX_FAXCLIENTPG_H__C9851773_AF2E_4C0B_B2F2_30E2E8FACF93__INCLUDED_)
#define AFX_FAXCLIENTPG_H__C9851773_AF2E_4C0B_B2F2_30E2E8FACF93__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FaxClientPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFaxClientPg dialog

class CFaxClientPg : public CPropertyPage
{
    DECLARE_DYNCREATE(CFaxClientPg)

// Construction
public:
    CFaxClientPg(UINT nIDTemplate, UINT nIDCaption=0);
    ~CFaxClientPg();


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CFaxClientPg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    CFaxClientPg() {}

    // Generated message map functions
    //{{AFX_MSG(CFaxClientPg)
    afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FAXCLIENTPG_H__C9851773_AF2E_4C0B_B2F2_30E2E8FACF93__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\faxclientdlg.h ===
#if !defined(AFX_FAXCLIENTDLG_H__9AF54B29_2711_4752_8832_27D9F6F616FC__INCLUDED_)
#define AFX_FAXCLIENTDLG_H__9AF54B29_2711_4752_8832_27D9F6F616FC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FaxClientDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFaxClientDlg dialog

class CFaxClientDlg : public CDialog
{
// Construction
public:
    CFaxClientDlg(DWORD dwDlgId, CWnd* pParent = NULL);   // standard constructor

    DWORD GetLastDlgError() { return m_dwLastError; }

// Dialog Data
    //{{AFX_DATA(CFaxClientDlg)
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFaxClientDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    DWORD m_dwLastError;

    // Generated message map functions
    //{{AFX_MSG(CFaxClientDlg)
    afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FAXCLIENTDLG_H__9AF54B29_2711_4752_8832_27D9F6F616FC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\faxtime.cpp ===
// FaxTime.cpp: implementation of the CFaxTime class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     9

CString 
CFaxDuration::FormatByUserLocale () const
/*++

Routine name : CFaxDuration::FormatByUserLocale

Routine description:

    Formats the duration according to the locale of the current user

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    String of result duration

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFaxDuration::FormatByUserLocale"));

    TCHAR szTimeSep[20];    
    //
    // Make sure the duration is less than 24Hrs
    //
    if (GetDays ())
    {
        ASSERTION_FAILURE;
        AfxThrowUserException ();
    }
    //
    // Get the string (MSDN says its up to 4 characters) seperating time units
    //
    if (!GetLocaleInfo (LOCALE_USER_DEFAULT,
                        LOCALE_STIME,
                        szTimeSep,
                        sizeof (szTimeSep) / sizeof (szTimeSep[0])))
    {
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("GetLocaleInfo"), dwRes);
        PopupError (dwRes);
        AfxThrowResourceException ();
    }
    //                       
    // Create a string specifying the duration
    //
    CString cstrResult;
    cstrResult.Format (TEXT("%d%s%02d%s%02d"), 
                       GetHours (),
                       szTimeSep,
                       GetMinutes (),
                       szTimeSep,
                       GetSeconds ());
    return cstrResult;
}   // CFaxDuration::FormatByUserLocale


CString 
CFaxTime::FormatByUserLocale (BOOL bLocal) const
/*++

Routine name : CFaxTime::FormatByUserLocale

Routine description:

    Formats the date and time according to the locale of the current user

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

  bLocal   [in] - if TRUE no need to convert from UTC to a local time

Return Value:

    String of result date and time

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFaxTime::FormatByUserLocale"));

    CString cstrRes;
    TCHAR szTimeBuf[40];
    TCHAR szDateBuf[120];

    SYSTEMTIME sysTime;
	FILETIME fileSysTime, fileLocalTime;

    if(!GetAsSystemTime (sysTime))
	{
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("CTime::GetAsSystemTime"), dwRes);
        PopupError (dwRes);
        AfxThrowResourceException ();
	}

    if(!bLocal)
    {
        //
	    // convert the time from UTC to a local time
	    //
	    if(!SystemTimeToFileTime(&sysTime, &fileSysTime))
	    {
            dwRes = GetLastError ();
            CALL_FAIL (RESOURCE_ERR, TEXT("SystemTimeToFileTime"), dwRes);
            PopupError (dwRes);
            AfxThrowResourceException ();
	    }

	    if(!FileTimeToLocalFileTime(&fileSysTime, &fileLocalTime))
	    {
            dwRes = GetLastError ();
            CALL_FAIL (RESOURCE_ERR, TEXT("FileTimeToLocalFileTime"), dwRes);
            PopupError (dwRes);
            AfxThrowResourceException ();
	    }

	    if(!FileTimeToSystemTime(&fileLocalTime, &sysTime))
	    {
            dwRes = GetLastError ();
            CALL_FAIL (RESOURCE_ERR, TEXT("FileTimeToSystemTime"), dwRes);
            PopupError (dwRes);
            AfxThrowResourceException ();
	    }
    }

    //
    // Create a string specifying the date
    //
    if (!GetY2KCompliantDate(LOCALE_USER_DEFAULT,                   // Get user's locale
                        DATE_SHORTDATE,                             // Short date format
                        &sysTime,                                   // Source date/time
                        szDateBuf,                                  // Output buffer
                        sizeof(szDateBuf) / sizeof(szDateBuf[0])    // Output buffer size
                       ))
    {
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("GetY2KCompliantDate()"), dwRes);
        PopupError (dwRes);
        AfxThrowResourceException ();
    }
    //
    // Create a string specifying the time
    //
    if (!FaxTimeFormat (LOCALE_USER_DEFAULT,                        // Get user's locale
                        0,                                          // No special format
                        &sysTime,                                   // Source date/time
                        NULL,                                       // Use format from locale
                        szTimeBuf,                                  // Output buffer
                        sizeof(szTimeBuf) / sizeof(szTimeBuf[0])    // Output buffer size
                       ))
    {
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("FaxTimeFormat"), dwRes);
        PopupError (dwRes);
        AfxThrowResourceException ();
    }
    //
    // Append time after date with a seperating space character
    //

    cstrRes.Format (TEXT("%s %s"), szDateBuf, szTimeBuf);

    return cstrRes;
}   // CFaxTime::FormatByUserLocale
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\faxmsg.h ===
// FaxMsg.h: interface for the CFaxMsg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FAXMSG_H__3B753848_4860_4DC5_AC1E_F3514CE4E839__INCLUDED_)
#define AFX_FAXMSG_H__3B753848_4860_4DC5_AC1E_F3514CE4E839__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//
// Enumeration of all job types:
//
typedef enum
{
    JOB_STAT_PENDING,
    JOB_STAT_INPROGRESS,
    JOB_STAT_DELETING,
    JOB_STAT_PAUSED,
    JOB_STAT_RETRYING,
    JOB_STAT_RETRIES_EXCEEDED,
    JOB_STAT_COMPLETED,
    JOB_STAT_CANCELED,
    JOB_STAT_CANCELING,
    JOB_STAT_ROUTING,
    JOB_STAT_ROUTING_RETRY,
    JOB_STAT_ROUTING_INPROGRESS,
    JOB_STAT_ROUTING_FAILED,
    NUM_JOB_STATUS
} JobStatusType;

class CFaxMsg : public CObject  
{
public:

    CFaxMsg() : 
        m_pServer(NULL),
        m_bValid (FALSE), 
        m_dwValidityMask(0),
        m_dwPossibleOperations(0)
        {}
    virtual ~CFaxMsg() {}


    CServerNode* GetServer() const
        { ASSERT (m_bValid);  return m_pServer; }

    //
    // Operation query:
    //
    DWORD GetPossibleOperations () const
        { ASSERT (m_bValid); return m_dwPossibleOperations; }

    const DWORD GetValidityMask() const
        { ASSERT (m_bValid); return m_dwValidityMask; }

    //
    // Item retrival:
    //
    const DWORDLONG GetId () const              
        { ASSERT (m_bValid); return m_dwlMessageId; }

    const DWORDLONG GetBroadcastId () const              
        { ASSERT (m_bValid); return m_dwlBroadcastId; }
    
    const CString &GetServerName () const 
        { ASSERT (m_bValid); return m_cstrServerName; }

    const DWORD GetExtendedStatus () const   
        { ASSERT (m_bValid); return m_dwExtendedStatus; }

    const CString &GetCSID () const            
        { ASSERT (m_bValid); return m_cstrCsid; }

    const CString &GetTSID () const            
        { ASSERT (m_bValid); return m_cstrTsid; }

    const DWORD GetSize () const            
        { ASSERT (m_bValid); return m_dwSize; }

    const CString &GetDevice () const          
        { ASSERT (m_bValid); return m_cstrDeviceName; }

    const DWORD GetRetries () const         
        { ASSERT (m_bValid); return m_dwRetries; }

    const CString &GetCallerId () const        
        { ASSERT (m_bValid); return m_cstrCallerID; }

    const CString &GetRoutingInfo () const     
        { ASSERT (m_bValid); return m_cstrRoutingInfo; }

    const CString &GetDocName () const         
        { ASSERT (m_bValid); return m_cstrDocumentName; }

    const CString &GetSubject () const         
        { ASSERT (m_bValid); return m_cstrSubject; }

    const CString &GetRecipientName () const   
        { ASSERT (m_bValid); return m_cstrRecipientName; }

    const CString &GetRecipientNumber () const 
        { ASSERT (m_bValid); return m_cstrRecipientNumber; }

    const CString &GetUser () const 
        { ASSERT (m_bValid); return m_cstrSenderUserName; }

    const CString &GetBilling () const 
        { ASSERT (m_bValid); return m_cstrBillingCode; }

    const DWORD GetType () const
        { ASSERT (m_bValid); return m_dwJobType; }

    const CFaxTime &GetOrigTime () const        
        { ASSERT (m_bValid); return m_tmOriginalScheduleTime;}

    const CFaxTime &GetSubmissionTime () const      
        { ASSERT (m_bValid); return m_tmSubmissionTime; }

    const CFaxTime &GetTransmissionStartTime () const
        { ASSERT (m_bValid); return m_tmTransmissionStartTime; }

    const CFaxTime &GetTransmissionEndTime () const
        { ASSERT(m_bValid); return m_tmTransmissionEndTime;}

    const DWORD GetNumPages () const        
        { ASSERT (m_bValid); return m_dwPageCount; }

    const FAX_ENUM_PRIORITY_TYPE GetPriority () const        
        { ASSERT (m_bValid); return m_Priority; }

    virtual DWORD GetTiff (CString &cstrTiffLocation) const=0;
    virtual DWORD Delete ()=0;

    //
    // Message specific
    //
    virtual const CString &GetSenderName () const
        { ASSERT(FALSE); return *((CString*)NULL);}

    virtual const CString &GetSenderNumber () const
        { ASSERT(FALSE); return *((CString*)NULL);}

    virtual const CFaxDuration &GetTransmissionDuration () const
        { ASSERT(FALSE); return *((CFaxDuration*)NULL);}


    //
    // Job specific
    //
    virtual DWORD Pause  ()
        { ASSERT(FALSE); return 0;}

    virtual DWORD Resume ()
        { ASSERT(FALSE); return 0;}

    virtual DWORD Restart()
        { ASSERT(FALSE); return 0;}

    virtual const JobStatusType GetStatus() const
        { ASSERT(FALSE); return JOB_STAT_COMPLETED;}

    virtual const CString &GetExtendedStatusString() const
        { ASSERT(FALSE); return *((CString*)NULL);}

    virtual const DWORD GetCurrentPage () const
        { ASSERT(FALSE); return 0;}

    virtual const CFaxTime &GetScheduleTime () const
        { ASSERT(FALSE); return *((CFaxTime*)NULL);}

protected:

    CServerNode* m_pServer;

    BOOL       m_bValid;

    DWORDLONG  m_dwlMessageId;
    DWORDLONG  m_dwlBroadcastId;

    DWORD      m_dwPossibleOperations;
    DWORD      m_dwValidityMask;
    DWORD      m_dwJobOnlyValidityMask; // Validity mask (not status)
    DWORD      m_dwJobID;
    DWORD      m_dwJobType;
    DWORD      m_dwQueueStatus;
    DWORD      m_dwExtendedStatus;
    DWORD      m_dwSize;
    DWORD      m_dwPageCount;
    DWORD      m_dwDeviceID;
    DWORD      m_dwRetries;

    CString    m_cstrRecipientNumber;
    CString    m_cstrRecipientName;
    CString    m_cstrSenderUserName;
    CString    m_cstrBillingCode;
    CString    m_cstrDocumentName;
    CString    m_cstrSubject;
    CString    m_cstrTsid;
    CString    m_cstrCsid;
    CString    m_cstrDeviceName;
    CString    m_cstrCallerID;
    CString    m_cstrRoutingInfo;
    CString    m_cstrServerName;

    CFaxTime   m_tmOriginalScheduleTime;
    CFaxTime   m_tmSubmissionTime;
    CFaxTime   m_tmTransmissionStartTime; 
    CFaxTime   m_tmTransmissionEndTime; 

    FAX_ENUM_PRIORITY_TYPE  m_Priority;
};

#endif // !defined(AFX_FAXMSG_H__3B753848_4860_4DC5_AC1E_F3514CE4E839__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\folder.cpp ===
// Folder.cpp: implementation of the CFolder class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     21

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CFolder, CTreeNode)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

void
CFolder::PreDestruct ()
{
    DBG_ENTER(TEXT("CFolder::PreDestruct"), TEXT("Type=%d"), m_Type);
    //
    // Stop the build thread - and wait for its death
    //
    DWORD dwRes = StopBuildThread ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolder::StopBuildThread"), dwRes);
    }
    //
    // Clear the map of items
    //
    dwRes = InvalidateContents(FALSE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolder::InvalidateContents"), dwRes);
    }
}   // CFolder::PreDestruct

CFolder::~CFolder()
{
    DBG_ENTER(TEXT("CFolder::~CFolder"), TEXT("Type=%d"), m_Type);
    //
    // Destroy data critical section
    //
    if (m_bCsDataInitialized)
    {
        DeleteCriticalSection (&m_CsData);
    }
}   // CFolder::~CFolder


CFaxMsg*
CFolder::FindMessage (
    DWORDLONG dwlMsgId
)
{
    DBG_ENTER(TEXT("CFolder::FindMessage"));

    MSGS_MAP::iterator it = m_Msgs.find (dwlMsgId);
    if (m_Msgs.end() == it)
    {
        //
        // Not found
        //
        return NULL;
    }
    else
    {
        return (*it).second;
    }
}   // CFolder::FindMessage

void CFolder::AssertValid() const
{
    CTreeNode::AssertValid();
}

void
CFolder::SetServer ( 
    CServerNode *pServer
)
{
    DBG_ENTER(TEXT("CFolder::SetServer"));
    ASSERTION (NULL != pServer);
    m_pServer = pServer;

    VERBOSE (DBG_MSG,
             TEXT ("Folder on server %s, Type=%d"), 
             m_pServer->Machine(),
             m_Type);
}

DWORD
CFolder::Init ()
/*++

Routine name : CFolder::Init

Routine description:

    Init a folder

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolder::Init"), dwRes);

    //
    // Init the build thread critical section
    //
    try
    {
        InitializeCriticalSection (&m_CsData);
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("InitializeCriticalSection"), dwRes);
        return dwRes;
    }
    m_bCsDataInitialized = TRUE;

    return dwRes;
}   // CFolder::Init


void 
CFolder::AttachView()
{
	DBG_ENTER(TEXT("CFolder::AttachView"));

    m_pAssignedView = NULL;

    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        //  Shutdown in progress
        //
        return;
    }

	//
    // Attach the right view to the folder
	//
    switch (m_Type)
    {
        case FOLDER_TYPE_INBOX:
            m_pAssignedView = pFrm->GetInboxView ();
            break;

        case FOLDER_TYPE_INCOMING:
            m_pAssignedView = pFrm->GetIncomingView ();
            break;

        case FOLDER_TYPE_OUTBOX:
            m_pAssignedView = pFrm->GetOutboxView ();
            break;

        case FOLDER_TYPE_SENT_ITEMS:
            m_pAssignedView = pFrm->GetSentItemsView ();
            break;


        default:
            ASSERTION_FAILURE;
    }
	ASSERTION(m_pAssignedView);

} //CFolder::AttachView


void
CFolder::SetVisible()
/*++

Routine name : CFolder::SetVisible

Routine description:

    Sets the visiblity of a folder

Author:

    Eran Yariv (EranY), Jan, 2000

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolder::SetVisible"), 
              TEXT("Server = %s, Type=%d"), 
              m_pServer ? m_pServer->Machine() : TEXT("None"),
              m_Type); 


    //
    // This folder's tree node was just selected
    //
    m_bVisible = TRUE;

    if (!m_bValidList && !m_bRefreshing)
    {
        //
        // The items list is invalid and there's not thread currently creating it.
        //
        // This is the 1st time this node is being selected for display
        // (since its creation) - build the list of jobs / messages now
        // 
        // NOTICE: RebuildContents() calls StopBuildThread() which waits for
        //         the previous thread to die WHILE DEQUEUEING WINDOWS MESSAGES.
        //         This may causes a seconds call to this function BEFORE 
        //         RebuildContents() returned.
        // 
        DWORD dwRes = RebuildContents ();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT ("CFolder::RebuildContents"), dwRes);
        }
    }

}   // CFolder::SetVisible



DWORD   
CFolder::InvalidateContents (
    BOOL bClearView                             
)
/*++

Routine name : CFolder::InvalidateContents

Routine description:

    Clears the contents of a folder (and the view if attached)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bClearView   [in] - Should we clear attached view ?


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolder::InvalidateContents"), dwRes, TEXT("Type=%d"), m_Type);

    CFaxMsg* pMsg;

    EnterData ();
    for (MSGS_MAP::iterator it = m_Msgs.begin(); it != m_Msgs.end(); ++it)
    {
        pMsg = (*it).second;

        if(bClearView && m_pAssignedView)
        {
           m_pAssignedView->OnUpdate (NULL, UPDATE_HINT_REMOVE_ITEM, pMsg);
        }

        SAFE_DELETE (pMsg);
    }
    m_Msgs.clear();
    LeaveData ();

    //
    // Mark list as invalid
    //
    m_bValidList = FALSE;
    return dwRes;
}   // CFolder::InvalidateContents

DWORD            
CFolder::RebuildContents ()
/*++

Routine name : CFolder::RebuildContents

Routine description:

    Rebuilds the contents of a folder (by creating a worker thread)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolder::RebuildContents"), dwRes, TEXT("Type=%d"), m_Type);

    ASSERTION(!m_bRefreshing);

    m_bRefreshing = TRUE;

    //
    // Stop the current (if any) build thread and make sure it's dead
    //
    m_bRefreshFailed = FALSE;
    DWORD dwThreadId;

    dwRes = StopBuildThread ();
    EnterCriticalSection (&m_CsData);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("CFolder::StopBuildThread"), dwRes);
        m_bRefreshing = FALSE;
        goto exit;
    }
    //
    // Lock the folder, so that notifications will not add jobs / messages
    // to the map and list view.
    //
    m_bLocked = TRUE;
    //
    // Clear our list and our view (list control)
    //
    dwRes = InvalidateContents(FALSE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("CFolder::InvalidateContents"), dwRes);
        m_bLocked = FALSE;
        m_bRefreshing = FALSE;
        goto exit;
    }
    //
    // Start the thread that will fill the data (in the background)
    //
    m_bStopRefresh = FALSE;
    m_hBuildThread = CreateThread (  
                        NULL,           // No security
                        0,              // Default stack size
                        BuildThreadProc,// Thread procedure
                        (LPVOID)this,   // Parameter
                        0,              // Normal creation
                        &dwThreadId     // We must have a thread id for win9x
                     );
    if (NULL == m_hBuildThread)
    {
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("CreateThread"), dwRes);
        PopupError (dwRes);
        m_bLocked = FALSE;
        m_bRefreshing = FALSE;
    }
exit:
    LeaveCriticalSection (&m_CsData);
    return dwRes;
}   // CFolder::RebuildContents


DWORD            
CFolder::StopBuildThread (BOOL bWaitForDeath)
/*++

Routine name : CFolder::StopBuildThread

Routine description:

    Stops the contents-building worker thread.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bWaitForDeath   [in] - Should we wait until the therad actually dies?

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolder::StopBuildThread"), dwRes, TEXT("Type=%d"), m_Type);

    m_bStopRefresh = TRUE;
    if (!bWaitForDeath)
    {
        return dwRes;
    }
    if (NULL == m_hBuildThread)
    {
        //
        // Background build thread is already dead
        //
        return dwRes;
    }
    dwRes = WaitForThreadDeathOrShutdown (m_hBuildThread);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("WaitForThreadDeathOrShutdown"), dwRes);
    }
    CloseHandle (m_hBuildThread);
    m_hBuildThread = NULL;
    return dwRes;
}   // CFolder::StopBuildThread

        

DWORD 
WINAPI 
CFolder::BuildThreadProc (
    LPVOID lpParameter
)
/*++

Routine name : CFolder::BuildThreadProc

Routine description:

    Static thread entry point.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    lpParameter   [in] - Pointer to the CFolder instance that created the thread.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolder::BuildThreadProc"), dwRes);

    CFolder *pFolder = (CFolder *)lpParameter;
    ASSERT (pFolder);

    const CServerNode* pServer = pFolder->GetServer();
    if(NULL != pServer)
    {
        VERBOSE (DBG_MSG,
                TEXT ("Folder on server %s"), 
                pServer->Machine());
    }
    //
    // Call the refresh function for the right folder
    //
    dwRes = pFolder->Refresh ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolder::Refresh"), dwRes);

        //
        // Check if the view still alive
        //
        pFolder->AttachView();
        if(pFolder->m_pAssignedView)
        {        
            //
            // Invalidate contents
            //
            pFolder->m_pAssignedView->SendMessage (
                           WM_FOLDER_INVALIDATE,
                           WPARAM (0), 
                           LPARAM (pFolder));
        }
        pFolder->m_bRefreshFailed = TRUE;
    }
    else
    {
        //
        // Refresh thread succeeded, there's a point in updating the view
        //
        pFolder->m_bValidList = TRUE;

        //
        // Check if the view still alive
        //
        pFolder->AttachView();
        if (pFolder->m_pAssignedView)
        {
            //
            // Folder has a view attached
            //
            pFolder->m_pAssignedView->SendMessage (
                           WM_FOLDER_REFRESH_ENDED,
                           WPARAM (dwRes), 
                           LPARAM (pFolder));
        }
    }
    pFolder->EnterData ();
    //
    // Unlock the folder - notifications can now be processed
    //
    pFolder->m_bLocked = FALSE;
    pFolder->LeaveData ();
    pFolder->m_bRefreshing = FALSE;
        
    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        //  Shutdown in progress
        //
    }
    else
    {
        pFrm->RefreshStatusBar ();
    }

    //
    // That's it, return the result
    //
    return dwRes;
}   // CFolder::BuildThreadProc


int 
CFolder::GetActivityStringResource() const
/*++

Routine name : CFolder::GetActivityStringResource

Routine description:

	Returns the resource id of a string identifying the activity of the folder

Author:

	Eran Yariv (EranY),	Jan, 2000

Arguments:


Return Value:

    Activity string resource id

--*/
{
    if (m_bRefreshFailed)
    {
        //
        // Last refresh failed
        //
        return IDS_FOLDER_REFRESH_FAILED;
    }
    if (m_pAssignedView && m_pAssignedView->Sorting())
    {
        //
        // Folder has a view and the view is currently sorting    
        //
        return IDS_FOLDER_SORTING;
    }
    if (IsRefreshing())
    {
        //
        // Folder is busy building up its data
        //
        return IDS_FOLDER_REFRESHING;
    }
    //
    // Folder is doing nothing
    //
    return IDS_FOLDER_IDLE;
}   // CFolder::GetActivityStringResource

DWORD  
CFolder::OnJobRemoved (
    DWORDLONG dwlMsgId,
    CFaxMsg*  pMsg /* = NULL */
)
/*++

Routine name : CFolder::OnJobRemoved

Routine description:

	Handles notification of a message removed from the archive

Author:

	Eran Yariv (EranY),	Feb, 2000

Arguments:

	dwlMsgId   [in]     - Message unique id
    pMsg       [in]     - Optional pointer to message to remove (for optimization)

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolder::OnJobRemoved"), 
              dwRes, 
              TEXT("MsgId=0x%016I64x, Type=%d"), 
              dwlMsgId,
              Type());

    EnterData ();
    
    if (!pMsg)
    {
        //
        // No message pointer was supplied - search for it
        //
        pMsg = FindMessage (dwlMsgId);
    }
    if (!pMsg)
    {
        //
        // This message is already not in the archive
        //
        VERBOSE (DBG_MSG, TEXT("Message is already gone"));
        goto exit;
    }

    if (m_pAssignedView)
    {
        //
        // If this folder is alive - tell our view to remove the message
        //
       m_pAssignedView->OnUpdate (NULL, UPDATE_HINT_REMOVE_ITEM, pMsg);
    }

    //
    // Remove the message from the map
    //
    try
    {
        m_Msgs.erase (dwlMsgId);
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("map::erase"), dwRes);
        delete pMsg;
        goto exit;
    }
    //
    // Delete message 
    //
    delete pMsg;

    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    LeaveData ();
    return dwRes;

}   // CFolder::OnJobRemoved
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\folderdialog.cpp ===
// FolderDialog.cpp: implementation of the CFolderDialog class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     70

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CClientConsoleApp theApp;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

DWORD 
CFolderDialog::Init(
    LPCTSTR tszInitialDir, // = NULL
    UINT nTitleResId       // = 0
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderDialog::Init"), dwRes);

    //
    // copy an initial folder name
    //
    m_tszInitialDir[ARR_SIZE(m_tszInitialDir) - 1] = 0;
    if(tszInitialDir && _tcslen(tszInitialDir) > 0)
    {
        _tcsncpy(m_tszInitialDir, tszInitialDir, ARR_SIZE(m_tszInitialDir)-1);        
    }

    //
    // load a title resource string
    //
    if(0 != nTitleResId)
    {
        dwRes = LoadResourceString (m_cstrTitle, nTitleResId);
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT ("LoadResourceString"), dwRes);
            return dwRes;
        }
    }

    return dwRes;

} // CFolderDialog::Init

int 
CALLBACK
CFolderDialog::BrowseCallbackProc(
    HWND hwnd,
    UINT uMsg,
    LPARAM lp, 
    LPARAM pData
) 
{
    DBG_ENTER(TEXT("CFolderDialog::BrowseCallbackProc"));

    CFolderDialog* pFolderDlg = (CFolderDialog*)pData;
    ASSERTION(pFolderDlg);

    switch (uMsg)
    {
        case BFFM_SELCHANGED:
        {
            BOOL bFolderIsOK = FALSE;
            TCHAR szPath [MAX_PATH + 1];

            if (SHGetPathFromIDList ((LPITEMIDLIST) lp, szPath)) 
            {
                DWORD dwFileAttr = GetFileAttributes(szPath);
                if (-1 != dwFileAttr && (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY))
                {
                    //
                    // The directory exists - enable the 'Ok' button
                    //
                    bFolderIsOK = TRUE;
                }
            }
            //
            // Enable / disable the 'ok' button
            //
            SendMessage(hwnd, BFFM_ENABLEOK , 0, (LPARAM)bFolderIsOK);
            break;
        }

        case BFFM_INITIALIZED:
            if(_tcslen(pFolderDlg->m_tszInitialDir) > 0) 
            {
                //
                // WParam is TRUE since you are passing a path.
                // It would be FALSE if you were passing a pidl.
                //
                SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)pFolderDlg->m_tszInitialDir);
            }
            break;

        case BFFM_VALIDATEFAILED:
            //
            // The folder name is invalid.
            // Do not close the dialog.
            //
            MessageBeep(MB_OK);
            return 1;
    }
    return 0;
} // CFolderDialog::BrowseCallbackProc


UINT 
CFolderDialog::DoModal(
    DWORD dwFlags /* =0 */)
{
    DBG_ENTER(TEXT("CFolderDialog::DoModal"));

    BROWSEINFO browseInfo = {0};
    browseInfo.hwndOwner  = theApp.m_pMainWnd->m_hWnd;
    browseInfo.pidlRoot   = NULL;
    browseInfo.pszDisplayName = 0;
    browseInfo.lpszTitle  = (m_cstrTitle.GetLength() != 0) ? (LPCTSTR)m_cstrTitle : NULL;
    browseInfo.ulFlags    = dwFlags | BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS | BIF_USENEWUI | BIF_VALIDATE;
    browseInfo.lpfn       = BrowseCallbackProc;
    browseInfo.lParam     = (LPARAM)this;

    //
    // Need OLE for a new style of the BrowseForFolder dialog
    //
    OleInitialize(NULL);
    LPITEMIDLIST pItemIdList = ::SHBrowseForFolder(&browseInfo);

    if(NULL == pItemIdList)
    {
        //
        // Cancel
        //
        OleUninitialize();
        return IDCANCEL;
    }

    OleUninitialize();
    //
    // get path from pItemIdList
    //
    if(!SHGetPathFromIDList(pItemIdList, (TCHAR*)&m_tszSelectedDir))
    {
        m_dwLastError = ERROR_CAN_NOT_COMPLETE;
        CALL_FAIL (GENERAL_ERR, TEXT("SHGetPathFromIDList"), m_dwLastError);
        return IDABORT;
    }
     //
    // free pItemIdList
    //
    LPMALLOC pMalloc;
    HRESULT hRes = SHGetMalloc(&pMalloc);
    if(E_FAIL == hRes)
    {
        m_dwLastError = ERROR_CAN_NOT_COMPLETE;
        CALL_FAIL (GENERAL_ERR, TEXT("SHGetMalloc"), m_dwLastError);
        return IDABORT;
    }

    pMalloc->Free(pItemIdList);
    pMalloc->Release();

    return IDOK;

} // CFolderDialog::DoModal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\faxtime.h ===
// FaxTime.h: interface for the CFaxTime class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FAXTIME_H__00A7FD8D_0FBC_4CA3_8187_836431261D07__INCLUDED_)
#define AFX_FAXTIME_H__00A7FD8D_0FBC_4CA3_8187_836431261D07__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CFaxDuration : public CTimeSpan
{
public:
    CFaxDuration () : CTimeSpan () {}
    CFaxDuration (time_t time) : CTimeSpan (time) {}

    virtual ~CFaxDuration () {}

    CString FormatByUserLocale () const;
    int Compare(const CFaxDuration & other) const
        { return (other == *this) ? 0 : ((*this < other) ? -1 : 1); }

    void Zero()
        { *this = CFaxDuration (0); }

};

class CFaxTime : public CTime  
{
public:
    CFaxTime() : CTime () {}
    CFaxTime( const CFaxTime& timeSrc ) : CTime (timeSrc) {}
    CFaxTime( time_t time ) : CTime (time) {}
    CFaxTime( int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec, int nDST = -1 ) :
        CTime (nYear, nMonth, nDay, nHour, nMin, nSec, nDST)
        {}
    CFaxTime( WORD wDosDate, WORD wDosTime, int nDST = -1 ) : CTime (wDosDate, wDosTime, nDST)
        {}
    CFaxTime( const SYSTEMTIME& sysTime, int nDST = -1 ) : CTime (sysTime, nDST) {}
    CFaxTime( const FILETIME& fileTime, int nDST = -1 ) : CTime (fileTime, nDST) {}

    virtual ~CFaxTime() {}

    CString FormatByUserLocale (BOOL bLocal = FALSE) const;

    const CFaxTime &operator = (const SYSTEMTIME &SysTime)
        { *this = CFaxTime (SysTime); return *this; }

    CFaxDuration operator -( CFaxTime rhs ) const
        { return CFaxDuration(GetTime() - rhs.GetTime ()); }

    int Compare(const CFaxTime & other) const
        { return (other == *this) ? 0 : ((*this < other) ? -1 : 1); }

    void Zero()
        { *this = CFaxTime (0); }
};

#endif // !defined(AFX_FAXTIME_H__00A7FD8D_0FBC_4CA3_8187_836431261D07__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\folderdialog.h ===
// FolderDialog.h: interface for the CFolderDialog class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FOLDERDIALOG_H__7C3137EF_7248_477F_ABEA_85F33AB2E0EF__INCLUDED_)
#define AFX_FOLDERDIALOG_H__7C3137EF_7248_477F_ABEA_85F33AB2E0EF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CFolderDialog  
{
public:
	CFolderDialog() : 
		m_dwLastError(ERROR_SUCCESS)
		{
            m_tszInitialDir[0] = TEXT('\0');
            m_tszSelectedDir[0] = TEXT('\0');
		}

	virtual ~CFolderDialog() {}

	DWORD Init(LPCTSTR tszInitialDir=NULL, UINT nTitleResId=0);
	UINT DoModal(DWORD dwFlags = 0);

	TCHAR* GetSelectedFolder() {return m_tszSelectedDir; } 
	DWORD  GetLastError() { return m_dwLastError; }

private:
	TCHAR   m_tszInitialDir[MAX_PATH+1];
	TCHAR   m_tszSelectedDir[MAX_PATH+1];
	CString m_cstrTitle;
	DWORD   m_dwLastError;

	static int CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lp, LPARAM pData);
};

#endif // !defined(AFX_FOLDERDIALOG_H__7C3137EF_7248_477F_ABEA_85F33AB2E0EF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\folder.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Folder.h

Abstract:

    Interface for the CFolder class.
    This abstract class is the base class for all 4 types of folders.

    It manages it's own view internally.

Author:

    Eran Yariv (EranY)  Dec, 1999

Revision History:

--*/

#if !defined(AFX_FOLDER_H__80DEDFB5_FF48_41BC_95DC_04A4060CF5FD__INCLUDED_)
#define AFX_FOLDER_H__80DEDFB5_FF48_41BC_95DC_04A4060CF5FD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

typedef map<DWORDLONG, CFaxMsg*> MSGS_MAP;

class CFolder : public CTreeNode  
{
public:
    CFolder(FolderType type) :
        CTreeNode (type),
        m_pAssignedView(NULL),
        m_bVisible(FALSE),
        m_pServer (NULL),
        m_bValidList (FALSE),
        m_hBuildThread (NULL),
        m_bCsDataInitialized (FALSE),
        m_bRefreshFailed (FALSE),
        m_bRefreshing(FALSE),
        m_bLocked (FALSE)
    {
        DBG_ENTER (TEXT("CFolder::CFolder"));
    }

    virtual ~CFolder();

    DECLARE_DYNAMIC(CFolder)

    virtual DWORD Init ();

	void AttachView();
    CFolderListView* GetView() const  { return m_pAssignedView; }

    void SetVisible ();
    void SetInvalid() { m_bValidList = FALSE; }
    BOOL IsValid() { return m_bValidList; }

    void  SetServer (CServerNode *pServer) ;
    const CServerNode* GetServer () const   { return m_pServer; }

    virtual void AssertValid( ) const;

    DWORD   InvalidateContents (BOOL bClearView);
    DWORD   RebuildContents ();

    MSGS_MAP &GetData ()     { return m_Msgs; }

    DWORD GetDataCount ()
        { 
            EnterData();
            int iSize = m_Msgs.size();
            LeaveData();
            return iSize;
        }

    CFaxMsg* FindMessage (DWORDLONG dwlMsgId);

    void    EnterData()
        { 
            if(!m_bCsDataInitialized)
            {
                ASSERT (FALSE); 
                return;
            }
            EnterCriticalSection (&m_CsData); 
        }

    void    LeaveData()
        { 
            if(!m_bCsDataInitialized)
            {
                ASSERT (FALSE); 
                return;
            }
            LeaveCriticalSection (&m_CsData); 
        }

    BOOL IsRefreshing () const  { return m_bRefreshing; }

    DWORD OnJobRemoved (DWORDLONG dwlMsgId, CFaxMsg* pMsg = NULL);
    virtual DWORD OnJobAdded (DWORDLONG dwlMsgId) = 0;
    virtual DWORD OnJobUpdated (DWORDLONG dwlMsgId, PFAX_JOB_STATUS pNewStatus) = 0;

    int GetActivityStringResource() const;

    BOOL Locked()       { return m_bLocked; }

    DWORD  StopBuildThread (BOOL bWaitForDeath = TRUE);

protected:

    MSGS_MAP  m_Msgs;     // Map of message id to CFaxMsg pointer.
 
    CFolderListView* m_pAssignedView; // Points to the view assigned to this node.
    BOOL             m_bVisible;      // Is this node currently visible?

    CServerNode     *m_pServer;         // Points to the server's node
    BOOL             m_bStopRefresh;    // Should we abort the refresh operation?
    BOOL             m_bValidList;      // Is the list of jobs / message valid?

    virtual DWORD Refresh () = 0;

    void PreDestruct ();    // Call on sons dtor

private:

    HANDLE           m_hBuildThread;    // Handle of background contents building thread
    BOOL             m_bCsDataInitialized; // Did we init the m_CsData member?
    CRITICAL_SECTION m_CsData;          // Critical section to protect the data

    static DWORD WINAPI BuildThreadProc (LPVOID lpParameter);

    BOOL  m_bRefreshFailed;  // Was the refresh a failure?
    BOOL  m_bRefreshing;    
    BOOL  m_bLocked;         // If TRUE, do not process server notifications
};

#endif // !defined(AFX_FOLDER_H__80DEDFB5_FF48_41BC_95DC_04A4060CF5FD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\folderlistview.cpp ===
// FolderListView.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     22

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include <dlgprnt2.cpp>

extern CClientConsoleApp theApp;

//
// Static members:
//
CFolderListView * CFolderListView::m_psCurrentViewBeingSorted = NULL;
CImageList CFolderListView::m_sImgListDocIcon;
CImageList CFolderListView::m_sReportIcons; 

/////////////////////////////////////////////////////////////////////////////
// CFolderListView

IMPLEMENT_DYNCREATE(CFolderListView, CListView)


BEGIN_MESSAGE_MAP(CFolderListView, CListView)
    //{{AFX_MSG_MAP(CFolderListView)
    ON_NOTIFY_REFLECT(LVN_COLUMNCLICK,   OnColumnClick)
    ON_WM_SETCURSOR()
    ON_MESSAGE (WM_FOLDER_REFRESH_ENDED, OnFolderRefreshEnded)
    ON_MESSAGE (WM_FOLDER_ADD_CHUNK,     OnFolderAddChunk)
    ON_MESSAGE (WM_FOLDER_INVALIDATE,    OnFolderInvalidate)
    ON_NOTIFY_REFLECT(NM_RCLICK,         OnItemRightClick)
    ON_WM_CONTEXTMENU()
    ON_NOTIFY_REFLECT(LVN_ITEMCHANGED,   OnItemChanged)
    ON_WM_SETCURSOR()
    ON_WM_CHAR()
    //}}AFX_MSG_MAP
    ON_UPDATE_COMMAND_UI(ID_SELECT_ALL,             OnUpdateSelectAll)    
    ON_UPDATE_COMMAND_UI(ID_SELECT_NONE,            OnUpdateSelectNone)    
    ON_UPDATE_COMMAND_UI(ID_SELECT_INVERT,          OnUpdateSelectInvert)  
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_VIEW,       OnUpdateFolderItemView)
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_PRINT,      OnUpdateFolderItemPrint)
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_COPY,       OnUpdateFolderItemCopy)      
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_MAIL_TO,    OnUpdateFolderItemSendMail)   
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_PROPERTIES, OnUpdateFolderItemProperties)
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_DELETE,     OnUpdateFolderItemDelete)    
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_PAUSE,      OnUpdateFolderItemPause)     
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_RESUME,     OnUpdateFolderItemResume)    
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_RESTART,    OnUpdateFolderItemRestart)   
    ON_COMMAND(ID_SELECT_ALL,             OnSelectAll)
    ON_COMMAND(ID_SELECT_NONE,            OnSelectNone)
    ON_COMMAND(ID_SELECT_INVERT,          OnSelectInvert)
    ON_COMMAND(ID_FOLDER_ITEM_VIEW,       OnFolderItemView)
    ON_COMMAND(ID_FOLDER_ITEM_PRINT,      OnFolderItemPrint)
    ON_COMMAND(ID_FOLDER_ITEM_COPY,       OnFolderItemCopy)
    ON_COMMAND(ID_FOLDER_ITEM_MAIL_TO,    OnFolderItemMail)
    ON_COMMAND(ID_FOLDER_ITEM_PRINT,      OnFolderItemPrint)
    ON_COMMAND(ID_FOLDER_ITEM_PROPERTIES, OnFolderItemProperties)
    ON_COMMAND(ID_FOLDER_ITEM_DELETE,     OnFolderItemDelete)
    ON_COMMAND(ID_FOLDER_ITEM_PAUSE,      OnFolderItemPause)
    ON_COMMAND(ID_FOLDER_ITEM_RESUME,     OnFolderItemResume)
    ON_COMMAND(ID_FOLDER_ITEM_RESTART,    OnFolderItemRestart)
    ON_NOTIFY_REFLECT(NM_DBLCLK,          OnDblClk)
END_MESSAGE_MAP()

BOOL CFolderListView::PreCreateWindow(CREATESTRUCT& cs)
{
    return CListView::PreCreateWindow(cs);
}

BOOL 
CFolderListView::OnSetCursor(
    CWnd* pWnd, 
    UINT nHitTest, 
    UINT message
)
{
    if (m_bInMultiItemsOperation || m_bSorting)
    {
        ::SetCursor(AfxGetApp()->LoadStandardCursor(IDC_WAIT));
        return TRUE;
    }

    CClientConsoleDoc* pDoc = GetDocument();
    if (pDoc && pDoc->IsFolderRefreshing(m_Type))
    {
        ::SetCursor(AfxGetApp()->LoadStandardCursor(IDC_APPSTARTING));
        return TRUE;
    }
    else        
    {
        return CView::OnSetCursor(pWnd, nHitTest, message);
    }       
}   // CFolderListView::OnSetCursor


BOOL 
CFolderListView::IsSelected (
    int iItem
)
/*++

Routine name : CFolderListView::IsSelected

Routine description:

    Checks if an item is selected in the list

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    iItem                         [in]     - Item index

Return Value:

    TRUE if item is selected in the list, FALSE otherwise.

--*/
{
    BOOL bRes = FALSE;
    DBG_ENTER(TEXT("CFolderListView::IsSelected"), bRes);

    CListCtrl &refCtrl = GetListCtrl();
    ASSERTION (refCtrl.GetItemCount() > iItem);

    DWORD dwState = refCtrl.GetItemState (iItem , LVIS_SELECTED);
    if (LVIS_SELECTED & dwState)
    {
        bRes = TRUE;
    }
    return bRes;
}

void 
CFolderListView::Select (
    int iItem, 
    BOOL bSelect
)
/*++

Routine name : CFolderListView::Select

Routine description:

    Selects / unselects an item in the list

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    iItem                         [in]     - Item index
    bSelect                       [in]     - TRUE if select, FALSE unselect

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::Select"), TEXT("%d"), bSelect);

    CListCtrl &refCtrl = GetListCtrl();
    ASSERTION (refCtrl.GetItemCount() > iItem);

    refCtrl.SetItemState (iItem, 
                          bSelect ? (LVIS_SELECTED | LVIS_FOCUSED) : 0,
                          LVIS_SELECTED | LVIS_FOCUSED);
}

void 
CFolderListView::OnSelectAll ()
/*++

Routine name : CFolderListView::OnSelectAll

Routine description:

    Select all list items

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnSelectAll"),
              TEXT("Type=%d"),
              m_Type);
    LV_ITEM lvItem;

    CListCtrl &refCtrl = GetListCtrl();
    ASSERTION (refCtrl.GetItemCount() > refCtrl.GetSelectedCount());

    lvItem.mask     = LVIF_STATE;
    lvItem.iItem    = -1;   // Specifies "All items"
    lvItem.iSubItem = 0;
    lvItem.state    = LVIS_SELECTED;
    lvItem.stateMask= LVIS_SELECTED;

    m_bInMultiItemsOperation = TRUE;

    refCtrl.SetItemState(-1, &lvItem);

    m_bInMultiItemsOperation = FALSE;
    RecalcPossibleOperations(); 

}   // CFolderListView::OnSelectAll

void 
CFolderListView::OnSelectNone ()
/*++

Routine name : CFolderListView::OnSelectNone

Routine description:

    Unselect all list items

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnSelectNone"),
              TEXT("Type=%d"),
              m_Type);

    LV_ITEM lvItem;

    CListCtrl &refCtrl = GetListCtrl();
    lvItem.mask     = LVIF_STATE;
    lvItem.iItem    = -1;   // Specifies "All items"
    lvItem.iSubItem = 0;
    lvItem.state    = 0;
    lvItem.stateMask= LVIS_SELECTED;

    m_bInMultiItemsOperation = TRUE;

    refCtrl.SetItemState(-1, &lvItem);

    m_bInMultiItemsOperation = FALSE;
    RecalcPossibleOperations(); 

}   // CFolderListView::OnSelectNone

void 
CFolderListView::OnSelectInvert ()
/*++

Routine name : CFolderListView::OnSelectInvert

Routine description:

    Invert list items selection

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnSelectInvert"),
              TEXT("Type=%d"),
              m_Type);

    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwItemsCount = refCtrl.GetItemCount();

    m_bInMultiItemsOperation = TRUE;

    for (DWORD dw = 0; dw < dwItemsCount; dw++)
    {
        Select (dw, !IsSelected (dw));
    }

    m_bInMultiItemsOperation = FALSE;
    RecalcPossibleOperations(); 

}   // CFolderListView::OnSelectInvert


void CFolderListView::OnDraw(CDC* pDC)
{
    CListView::OnDraw (pDC);
}

void CFolderListView::OnInitialUpdate()
{
    //
    // Refresh the image list (only if they are empty)
    //
    RefreshImageLists(FALSE);
    CListView::OnInitialUpdate();
}

/////////////////////////////////////////////////////////////////////////////
// CFolderListView diagnostics

#ifdef _DEBUG
void CFolderListView::AssertValid() const
{
    CListView::AssertValid();
}

void CFolderListView::Dump(CDumpContext& dc) const
{
    CListView::Dump(dc);
}

CClientConsoleDoc* CFolderListView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CClientConsoleDoc)));
    return (CClientConsoleDoc*)m_pDocument;
}

#endif //_DEBUG



/////////////////////////////////////////////////////////////////////////////
// CFolderListView message handlers

DWORD 
CFolderListView::InitColumns (
    int   *pColumnsUsed,
    DWORD dwDefaultColNum
)
/*++

Routine name : CFolderListView::InitColumns

Routine description:

    Inits the columns of the view.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pColumnsUsed    [in] - Pointer to the list of ids to place in the columns.
                          Must be a statically allocated list.
    dwDefaultColNum [in] - default column number

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::InitColumns"), dwRes);

    if (m_bColumnsInitialized)
    {
        return dwRes;
    }

    m_dwDefaultColNum = dwDefaultColNum;

    //
    // Count the number of columns provided
    //
    CountColumns (pColumnsUsed);

    int nItemIndex, nRes;
    CString cstrColumnText;
    DWORD dwCount = GetLogicalColumnsCount();   
    for (DWORD dw = 0; dw < dwCount; ++dw)
    {        
        nItemIndex = ItemIndexFromLogicalColumnIndex(dw);

        if(IsItemIcon(nItemIndex))
        {
            //
            // Init icon column - insert an empty string
            //
            nRes = GetListCtrl().InsertColumn (dw, TEXT(""), LVCFMT_LEFT);
            if (nRes < 0)
            {
                dwRes = ERROR_GEN_FAILURE;
                CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::InsertColumn"), dwRes);
                return dwRes;
            }
            //
            // Set the header control's bitmap
            //
            CHeaderCtrl *pHeader = GetListCtrl().GetHeaderCtrl();
            HDITEM hdItem;
            hdItem.mask = HDI_IMAGE | HDI_FORMAT;
            hdItem.fmt = HDF_LEFT | HDF_IMAGE;
            hdItem.iImage = 0;  // Use first (and only) image from image list
            if (!pHeader->SetItem (dw, &hdItem))
            {
                dwRes = ERROR_GEN_FAILURE;
                CALL_FAIL (WINDOW_ERR, TEXT("CHeaderCtrl::SetItem"), dwRes);
                return dwRes;
            }
        }
        else
        {
            //
            // init string column
            //
            dwRes = GetColumnHeaderString (cstrColumnText, nItemIndex);
            if (ERROR_SUCCESS != dwRes)
            { return dwRes; }
            nRes = GetListCtrl().InsertColumn (dw, 
                                               cstrColumnText,
                                               GetColumnHeaderAlignment (nItemIndex));
        }

        if (nRes < 0)
        {
            dwRes = ERROR_GEN_FAILURE;
            CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::InsertColumn"), dwRes);
            return dwRes;
        }
    }        

    m_bColumnsInitialized = TRUE;
    return dwRes;

}   // CFolderListView::InitColumns

void
CFolderListView::AutoFitColumns ()
/*++

Routine name : CFolderListView::AutoFitColumns

Routine description:

    Sets the column width to fit the contents of the column and the header

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::AutoFitColumns"));

    CHeaderCtrl *pHeader = GetListCtrl().GetHeaderCtrl ();
    ASSERTION (pHeader);
    DWORD dwCount = pHeader->GetItemCount();
    for (DWORD dwCol = 0; dwCol <= dwCount; dwCol++) 
    {
        GetListCtrl().SetColumnWidth (dwCol, LVSCW_AUTOSIZE);
        int wc1 = GetListCtrl().GetColumnWidth (dwCol);
        GetListCtrl().SetColumnWidth (dwCol, LVSCW_AUTOSIZE_USEHEADER);
        int wc2 = GetListCtrl().GetColumnWidth (dwCol);
        int wc = max(20,max(wc1,wc2));
        GetListCtrl().SetColumnWidth (dwCol, wc);
    }
}   // CFolderListView::AutoFitColumns

DWORD 
CFolderListView::UpdateLineTextAndIcon (
    DWORD dwLineIndex,
    CViewRow &row    
)
/*++

Routine name : CFolderListView::UpdateLineTextAndIcon

Routine description:

    Updates the icon and text in each column of a line item in the list

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    dwLineIndex        [in]     - Line index
    row                [in]     - Display information

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::UpdateLineTextAndIcon"), dwRes);

    //
    // Start by setting the icon
    //
    LVITEM lvItem = {0};
    lvItem.mask = LVIF_IMAGE;
    lvItem.iItem = dwLineIndex;
    lvItem.iSubItem = 0;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.pszText = NULL;
    lvItem.cchTextMax = 0;
    lvItem.lParam = NULL;
    lvItem.iImage = row.GetIcon();
    lvItem.iIndent = 0;
    CListCtrl &refCtrl = GetListCtrl();
    if (!refCtrl.SetItem (&lvItem))
    {
        dwRes = ERROR_GEN_FAILURE;
        CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::SetItem"), dwRes);
        return dwRes;
    }
    //
    // Set columns text
    //
    DWORD dwItemIndex;
    DWORD dwCount = GetLogicalColumnsCount();
    for (DWORD dwCol = 0; dwCol < dwCount; ++dwCol)
    {
        dwItemIndex = ItemIndexFromLogicalColumnIndex (dwCol);
        if(IsItemIcon(dwItemIndex))
        { 
            continue; 
        }
        //
        // Get text from column 
        //
        const CString &cstrColumn = row.GetItemString (dwItemIndex);

        //
        // Set the text in the control
        //
        if (!refCtrl.SetItemText (dwLineIndex, dwCol, cstrColumn))
        {
            dwRes = ERROR_GEN_FAILURE;
            CALL_FAIL (WINDOW_ERR, TEXT("ListCtrl::SetItemText"), dwRes);
            return dwRes;
        }
    }
    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;   
}   // CFolderListView::UpdateLineTextAndIcon

DWORD 
CFolderListView::AddItem (
    DWORD dwLineIndex,
    CViewRow &row,
    LPARAM lparamItemData,
    PINT pintItemIndex
)
/*++

Routine name : CFolderListView::AddItem

Routine description:

    Adds an item to the list

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwLineIndex     [in]  - Index of addition
    row             [in]  - Row of item view information
    lparamItemData  [in]  - Item associated data
    pintItemIndex   [out] - Item index in the list

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::AddItem"), dwRes, TEXT("%ld"), dwLineIndex);
    //
    // Insert the item: only state, indention and lParam are set.
    //
    LVITEM lvItem = {0};
    lvItem.mask = LVIF_PARAM | LVIF_STATE | LVIF_INDENT;
    lvItem.iItem = dwLineIndex;
    lvItem.iSubItem = 0;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.pszText = NULL;
    lvItem.cchTextMax = 0;
    lvItem.lParam = lparamItemData;
    lvItem.iImage = 0;
    lvItem.iIndent = 0;

    *pintItemIndex = ListView_InsertItem (GetListCtrl().m_hWnd, &lvItem);
    if (-1 == *pintItemIndex)
    {
        dwRes = ERROR_GEN_FAILURE;
        CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::InsertItem"), dwRes);
        return dwRes;
    }
    dwRes = UpdateLineTextAndIcon (*pintItemIndex, row);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("UpdateLineTextAndIcon"), dwRes);
        return dwRes;
    }
    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CFolderListView::AddItem


LRESULT 
CFolderListView::OnFolderAddChunk(
    WPARAM wParam,  // Error code
    LPARAM lParam   // MSGS_MAP pointer 
)
/*++

Routine name : CFolderListView::OnFolderAddChunk

Routine description:

    Called when a background folder thread brings a chunk of messages

Arguments:

    wParam         [in] - Thread error code
    lParam         [in] - Pointer to MSGS_MAP.

Return Value:

    Standard result code

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderAddChunk"));
    DWORD dwRes = (DWORD) wParam;    
    CObject* pObj = (CObject*)lParam;

    if (ERROR_SUCCESS == dwRes)
    {
        OnUpdate (NULL, UPDATE_HINT_ADD_CHUNK, pObj); 
    }
    else
    {
        PopupError (dwRes);
    }
    return 0;
}

LRESULT 
CFolderListView::OnFolderRefreshEnded (
    WPARAM wParam,  // Error code
    LPARAM lParam   // CFolder pointer 
)
/*++

Routine name : CFolderListView::OnFolderRefreshEnded

Routine description:

    Called when a background folder thread finishes its work.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    wParam         [in] - Thread error code
    lParam         [in] - Pointer to CFolder that started the thread.

Return Value:

    Standard result code

--*/
{ 
    DBG_ENTER(TEXT("CFolderListView::OnFolderRefreshEnded"));
    DWORD dwRes = (DWORD) wParam;
    CFolder *pFolder = (CFolder *) lParam;

    if (ERROR_SUCCESS == dwRes)
    {
        CListCtrl &refCtrl = GetListCtrl();
        m_HeaderCtrl.SetListControl (refCtrl.m_hWnd);

        DoSort();

        if(refCtrl.GetItemCount() > 0)
        {
            int iIndex = refCtrl.GetNextItem (-1, LVNI_SELECTED);
            if (-1 == iIndex)
            {
                //
                // If there is no selection, set focus on the first item.
                //
                refCtrl.SetItemState (0, LVIS_FOCUSED, LVIS_FOCUSED);
            }
            else
            {
                //
                // After sort, ensure the first selected item is visible
                //
                refCtrl.EnsureVisible (iIndex, FALSE);
            }
        }
    }
    else
    {
        PopupError (dwRes);
    }
    return 0;
}   // CFolderListView::OnFolderRefreshEnded
 


LRESULT 
CFolderListView::OnFolderInvalidate (
    WPARAM wParam,  // not in use
    LPARAM lParam   // CFolder pointer 
)
/*++

Routine name : CFolderListView::OnFolderRefreshEnded

Routine description:

    Called by a background folder thread in order to remove the all its fax messages.

Arguments:

    wParam         [in] - Not in use
    lParam         [in] - Pointer to CFolder that started the thread.

Return Value:

    Standard result code

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderInvalidate"));

    CFolder *pFolder = (CFolder *) lParam;
    if(!pFolder)
    {
        ASSERTION_FAILURE;
        return 0;
    }

    int iIndex; // View item index
    CListCtrl &refCtrl = GetListCtrl();

    LVFINDINFO lvfi = {0};
    lvfi.flags = LVFI_PARAM;

    CFaxMsg* pMsg;
    MSGS_MAP &msgMap = pFolder->GetData ();

    pFolder->EnterData ();
    //
    // Go through the folder's message map
    //
    for (MSGS_MAP::iterator it = msgMap.begin(); it != msgMap.end(); ++it)
    {
        pMsg = (*it).second;

        //
        // Delete the fax message from the view
        //
        lvfi.lParam = (LPARAM)pMsg;
        iIndex = refCtrl.FindItem (&lvfi);
        if(-1 != iIndex)
        {
            refCtrl.DeleteItem (iIndex);
        }

        //
        // Delete a fax message object
        //
        SAFE_DELETE (pMsg);
    }
    msgMap.clear();
    pFolder->LeaveData ();

    RecalcPossibleOperations ();

    return 0;
} // CFolderListView::OnFolderInvalidate


/***********************************
*                                  *
*      Columns sort support        *
*                                  *
***********************************/

int 
CFolderListView::CompareListItems (
    CFaxMsg* pFaxMsg1, 
    CFaxMsg* pFaxMsg2
)
/*++

Routine name : CFolderListView::CompareListItems

Routine description:

    Compares two items in the list (callback)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pFaxMsg1                       [in]     - Item 1
    pFaxMsg2                       [in]     - Item 2

Return Value:

    -1 if item1 is smaler than item2
    0 if identical
    +1 if item1 is bigger than item2

--*/
{
    DBG_ENTER(TEXT("CFolderListView::CompareListItems"));

    //
    // Make sure the we're sorting a valid column here
    //
    ASSERTION (m_nSortedCol >= 0);
    ASSERTION (m_nSortedCol <= GetLogicalColumnsCount());

    //
    // Get item index to sort by
    //
    DWORD dwItemIndex = ItemIndexFromLogicalColumnIndex (m_nSortedCol);

    //
    // Get comparison result
    //
    int iRes = m_bSortAscending ? CompareItems (pFaxMsg1, pFaxMsg2, dwItemIndex) :
                                  CompareItems (pFaxMsg2, pFaxMsg1, dwItemIndex);

    return iRes;
}

void CFolderListView::OnColumnClick(
    NMHDR* pNMHDR, 
    LRESULT* pResult
) 
/*++

Routine name : CFolderListView::OnColumnClick

Routine description:

    Handle mouse click on list header column (sort)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pNMHDR                        [in]     - Header column information
    pResult                       [out]    - Result

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnColumnClick"),
              TEXT("Type=%d"),
              m_Type);

    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    DWORD dwItemIndex = ItemIndexFromLogicalColumnIndex (pNMListView->iSubItem);
    if(IsItemIcon(dwItemIndex))
    { 
        //
        // no sort by icon
        //
        return;
    }

    if( pNMListView->iSubItem == m_nSortedCol )
    {
        m_bSortAscending = !m_bSortAscending;
    }
    else
    {
        m_bSortAscending = TRUE;
    }
    m_nSortedCol = pNMListView->iSubItem;
    DoSort();
    *pResult = 0;
}   // CFolderListView::OnColumnClick

    
int 
CALLBACK 
CFolderListView::ListViewItemsCompareProc (
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort
)
{
    DBG_ENTER(TEXT("CFolderListView::ListViewItemsCompareProc"));
    ASSERTION(m_psCurrentViewBeingSorted);
    ASSERTION(lParam1);
    ASSERTION(lParam2);

    CFaxMsg* pFaxMsg1 = (CFaxMsg*)lParam1;
    CFaxMsg* pFaxMsg2 = (CFaxMsg*)lParam2;

    DWORDLONG dwlId;
    try
    {
        dwlId = pFaxMsg1->GetId();
        dwlId = pFaxMsg2->GetId();
    }
    catch(...)
    {
        //
        // The list control has invalid item
        //
        VERBOSE (DBG_MSG, TEXT("List control has invalid item"));
        ASSERTION(FALSE);
        return 0;
    }

    return m_psCurrentViewBeingSorted->CompareListItems (pFaxMsg1, pFaxMsg2);
}


DWORD 
CFolderListView::RefreshImageLists (
    BOOL bForce
)
/*++

Routine name : CFolderListView::RefreshImageLists

Routine description:

    Loads the static list of images (icons) for the list control

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bForce - [in] If TRUE, any existing image list is destroyed and replaced with new ones.
                  If FALSE, existing image lists remain unchanged.    

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::RefreshImageLists"), dwRes);

    CListCtrl& refCtrl = GetListCtrl();

    if (bForce || (NULL == m_sReportIcons.m_hImageList))
    {
        //
        // Load image list of list view icons - 256 colors, pixel at 0,0 is mapped to background color during load
        //
        if(m_sReportIcons.m_hImageList)
        {
            ImageList_Destroy(m_sReportIcons.Detach());
        }
        HIMAGELIST himl = ImageList_LoadImage(
                                   AfxGetResourceHandle(), 
                                   MAKEINTRESOURCE(IDB_LIST_IMAGES), 
                                   16, 
                                   0,
                                   RGB(0, 255, 0), 
                                   IMAGE_BITMAP, 
                                   LR_LOADTRANSPARENT | LR_CREATEDIBSECTION);
        if (NULL == himl)
        {
            dwRes = GetLastError();
            CALL_FAIL (RESOURCE_ERR, TEXT("ImageList_LoadImage"), dwRes);
            PopupError (dwRes);
            return dwRes;
        }
        m_sReportIcons.Attach (himl);
    }  
    if (bForce || (NULL == m_sImgListDocIcon.m_hImageList))
    {
        //
        // Load the image list for the icons column and the up/down sort images - 16 colors.
        //
        if(m_sImgListDocIcon.m_hImageList)
        {
            ImageList_Destroy(m_sImgListDocIcon.Detach());
        }
        dwRes = LoadDIBImageList (m_sImgListDocIcon,
                                  IDB_DOC_ICON,
                                  16,
                                  RGB (214, 214, 214));
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadDIBImageList"), dwRes);
            PopupError (dwRes);
            return dwRes;
        }
    }
    refCtrl.SetExtendedStyle (LVS_EX_FULLROWSELECT |    // Entire row is selected
                              LVS_EX_INFOTIP);

    refCtrl.SetImageList (&m_sReportIcons, LVSIL_SMALL);
    //
    // Attach our custom header-control to the window of the list's header.
    //
    m_HeaderCtrl.SubclassWindow(refCtrl.GetHeaderCtrl()->m_hWnd);
    m_HeaderCtrl.SetImageList (&m_sImgListDocIcon);
    m_HeaderCtrl.SetListControl (refCtrl.m_hWnd);
    COLORREF crBkColor = ::GetSysColor(COLOR_WINDOW);
    refCtrl.SetBkColor(crBkColor);
    return dwRes;
}   // CFolderListView::RefreshImageLists



void 
CFolderListView::OnItemRightClick(
    NMHDR* pNMHDR, 
    LRESULT* pResult
) 
/*++

Routine name : CFolderListView::OnItemRightClick

Routine description:

    Handle mouse right-click on list items (popup context sensitive menu)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pNMHDR                        [in]     - Item information
    pResult                       [out]    - Result

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnItemRightClick"),
              TEXT("Type=%d"),
              m_Type);
    //
    // Send WM_CONTEXTMENU to self
    //
    SendMessage(WM_CONTEXTMENU, (WPARAM) m_hWnd, GetMessagePos());
    //
    // Mark message as handled and suppress default handling
    //
    *pResult = 1;
}   // CFolderListView::OnItemRightClick

DWORD 
CFolderListView::GetServerPossibleOperations (
    CFaxMsg* pMsg
)
/*++

Routine name : CFolderListView::GetServerPossibleOperations

Routine description:

    Retrieves operations possible on items according to server's security configuration.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:


Return Value:

    Possible operations (JOB_OP*)

--*/
{
    DWORD dwRes = FAX_JOB_OP_ALL;
    DBG_ENTER(TEXT("CFolderListView::GetServerPossibleOperations"), dwRes);
    ASSERTION(pMsg);

    CServerNode* pServer = pMsg->GetServer();
    ASSERTION (pServer);

    switch (m_Type)
    {
        case FOLDER_TYPE_INBOX:
            if (!pServer->CanManageInbox())
            {
                //
                // User cannot perform operations on the inbox
                //
                dwRes &= ~FAX_JOB_OP_DELETE;
            }
            break;

        case FOLDER_TYPE_INCOMING:
            if (!pServer->CanManageAllJobs ())
            {
                //
                // User cannot perform operations on the incoming queue folder
                //
                dwRes &= ~(FAX_JOB_OP_DELETE | FAX_JOB_OP_PAUSE | 
                           FAX_JOB_OP_RESUME | FAX_JOB_OP_RESTART);
            }
            break;

        case FOLDER_TYPE_OUTBOX:
        case FOLDER_TYPE_SENT_ITEMS:
            //
            // User can do anything here
            //
            break;

        default:
            ASSERTION_FAILURE;
            dwRes = 0;
    }
    return dwRes;
}   // CFolderListView::GetServerPossibleOperations



void CFolderListView::OnItemChanged(
    NMHDR* pNMHDR, 
    LRESULT* pResult
) 
/*++

Routine name : CFolderListView::OnItemChanged

Routine description:

    Handle selection changes of on list items

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pNMHDR                        [in]     - Item information
    pResult                       [out]    - Result

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnItemChanged"),
              TEXT("Type=%d"),
              m_Type);

    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    *pResult = 0;

    if(m_bInMultiItemsOperation)
    {
        return;
    }

    //
    // Find out if a new item is selected or unselected.
    //
    if (pNMListView->iItem < 0)
    {
        //
        // No item reported
        //
        return;
    }
    if (!(LVIF_STATE & (pNMListView->uChanged)))
    {
        //
        // This is not a selection change report
        //
        return;
    }
    if ( ((pNMListView->uNewState) & LVIS_SELECTED) && 
        !((pNMListView->uOldState) & LVIS_SELECTED))
    {
        //
        // Item changed from not-selected to selected.
        // Change the possible operations the user can perform on selected items.
        //
        OnItemSelected((CFaxMsg*)pNMListView->lParam);

        //
        // If the folder is still refreshing and a command line argument asks for a specific 
        // message to be selected in this folder, then we mark that message in m_dwlMsgToSelect.
        // Since the user just performed a manual selection of items, we no longer have to select anything for him.
        //
        m_dwlMsgToSelect = 0;
    }
    else if (!((pNMListView->uNewState) & LVIS_SELECTED) && 
              ((pNMListView->uOldState) & LVIS_SELECTED))
    {
        //
        // Item changed from selected to not-selected
        // Recalculate the possible operations the user can do on selected item.
        OnItemUnSelected((CFaxMsg*)pNMListView->lParam);

        //
        // If the folder is still refreshing and a command line argument asks for a specific 
        // message to be selected in this folder, then we mark that message in m_dwlMsgToSelect.
        // Since the user just performed a manual selection of items, we no longer have to select anything for him.
        //
        m_dwlMsgToSelect = 0;
    }
}   // CFolderListView::OnItemChanged

void
CFolderListView::RecalcPossibleOperations ()
/*++

Routine name : CFolderListView::RecalcPossibleOperations

Routine description:

    Recalculates the possible operation on the set of currently selected items.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::RecalcPossibleOperations"));
    CListCtrl &refCtrl = GetListCtrl();
    int iInd = -1;
    DWORD dwSelectedCount = refCtrl.GetSelectedCount ();
    
    m_dwPossibleOperationsOnSelectedItems = 0;
    ZeroMemory((PVOID)m_nImpossibleOperationsCounts, sizeof(m_nImpossibleOperationsCounts));

    CFaxMsg* pFaxMsg = NULL;
    for (DWORD dwItems = 0; dwItems < dwSelectedCount; dwItems++)
    {
        iInd = refCtrl.GetNextItem (iInd, LVNI_SELECTED);
        if(iInd < 0)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::GetNextItem"), 0);
            break;
        }
        LPARAM lparam = (LPARAM) refCtrl.GetItemData (iInd);

        OnItemSelected((CFaxMsg*)lparam);
    }

}   // CFolderListView::RecalcPossibleOperations

void 
CFolderListView::OnItemSelected(CFaxMsg* pFaxMsg)
/*++

Routine name : CFolderListView::OnItemSelected

Routine description:

    Recalculates the possible operation due to item selection

Arguments:

    pFaxMsg     [in] selected fax message

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnItemSelected"));
    //
    // Item changed from not-selected to selected.
    // Change the possible operations the user can perform on selected items.
    //
    if(0 == m_dwPossibleOperationsOnSelectedItems)
    {
        m_dwPossibleOperationsOnSelectedItems = 0xFFFF;
    }

    DWORD dwItemOperations = GetServerPossibleOperations(pFaxMsg) & 
                             pFaxMsg->GetPossibleOperations();

    if (GetListCtrl().GetSelectedCount() > 1)
    {
        //
        // If more than one item is selected, disable view and properties.
        //
        dwItemOperations &= ~(FAX_JOB_OP_VIEW | FAX_JOB_OP_PROPERTIES);
    }            

    m_dwPossibleOperationsOnSelectedItems &= dwItemOperations;

    //
    // Update impossible operations counts
    //
    DWORD dw;
    for(dw=0; dw < ARR_SIZE(m_nImpossibleOperationsCounts); ++dw)
    {
        if((dwItemOperations & 1) == 0)
        {
            //
            // The operation is disabled.
            //
            m_nImpossibleOperationsCounts[dw]++;
        }
        dwItemOperations = dwItemOperations >> 1;
    }

} // CFolderListView::OnItemSelected

void 
CFolderListView::OnItemUnSelected(CFaxMsg* pFaxMsg)
/*++

Routine name : CFolderListView::OnItemUnSelected

Routine description:

    Recalculates the possible operation due to item unselect

Arguments:

    pFaxMsg     [in] unselected fax message

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnItemUnSelected"));
    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelectedCount = refCtrl.GetSelectedCount ();

    if(dwSelectedCount <= 1)
    {
        m_dwPossibleOperationsOnSelectedItems = 0;
        ZeroMemory((PVOID)m_nImpossibleOperationsCounts, sizeof(m_nImpossibleOperationsCounts));  

        if(1 == dwSelectedCount)
        {
            int iInd = refCtrl.GetNextItem (-1, LVNI_SELECTED);

            OnItemSelected((CFaxMsg*)refCtrl.GetItemData (iInd));
        }
        return;
    }

    DWORD dwItemOperations = GetServerPossibleOperations(pFaxMsg) & 
                             pFaxMsg->GetPossibleOperations();
    DWORD dw;
    for(dw=0; dw < ARR_SIZE(m_nImpossibleOperationsCounts); ++dw)
    {
        if((dwItemOperations & 1) == 0)
        {
            //
            // The operation is disabled for unselected item.
            //
            m_nImpossibleOperationsCounts[dw]--;
            ASSERTION(m_nImpossibleOperationsCounts[dw] >= 0);
            if(m_nImpossibleOperationsCounts[dw] == 0)
            {
                //
                // Enable this operation
                //
                m_dwPossibleOperationsOnSelectedItems |= (1 << dw);
            }
        }
        dwItemOperations = dwItemOperations >> 1;
    }

} // CFolderListView::OnItemUnSelected


void 
CFolderListView::OnFolderItemView ()
/*++

Routine name : CFolderListView::OnFolderItemView

Routine description:

    Handles message view commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemView"),
              TEXT("Type=%d"),
              m_Type);

    if(!(m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_VIEW))
    {
        //
        // there is no TIF associated application
        //
        return;
    }

    CString cstrTiff;
    DWORD dwRes = FetchTiff (cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::FetchTiff"), dwRes);
        PopupError (dwRes);
        return;
    }
    
    //
    // Open the TIFF with associated application.
    // All preview files are automatically removed once the application is shut down.
    //
    dwRes = ViewFile(cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("ViewFile"), dwRes);

        if(ERROR_NO_ASSOCIATION == dwRes)
        {
            AlignedAfxMessageBox(IDS_NO_OPEN_ASSOCIATION, MB_ICONSTOP);
        }
        else
        {
            PopupError (dwRes);
        }
    } 
    else
    {
        if(FOLDER_TYPE_INBOX == m_Type)
        {
            theApp.InboxViewed();
        }
    }
}   // CFolderListView::OnFolderItemView


void 
CFolderListView::OnFolderItemPrint ()
/*++

Routine name : CFolderListView::OnFolderItemPrint

Routine description:

    Handles message print commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemPrint"),
              TEXT("Type=%d"),
              m_Type);

    HDC hPrinter;
    if (IsWinXPOS())
    {   
        //
        // Use new look of printer selection dialog
        //
        C_PrintDialogEx prnDlg(FALSE, 
                               PD_ALLPAGES                  | 
                               PD_USEDEVMODECOPIES          |
                               PD_NOPAGENUMS                |
                               PD_NOSELECTION               |
                               PD_RETURNDC);         
        if(IDOK != prnDlg.DoModal())
        {
            CALL_FAIL (GENERAL_ERR, TEXT("C_PrintDialogEx::DoModal"), CommDlgExtendedError());
            return;
        }
        hPrinter = prnDlg.GetPrinterDC();
        if(!hPrinter)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (GENERAL_ERR, TEXT("C_PrintDialogEx::GetPrinterDC"), dwRes);
            return;
        }
    }
    else
    {
        //
        // Use legacy printer selection dialog
        //
        CPrintDialog prnDlg(FALSE);         
        if(IDOK != prnDlg.DoModal())
        {
            return;
        }
        hPrinter = prnDlg.GetPrinterDC();
        if(!hPrinter)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (GENERAL_ERR, TEXT("CPrintDialog::GetPrinterDC"), dwRes);
            return;
        }
    }

    CString cstrTiff;
    dwRes = FetchTiff (cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::FetchTiff"), dwRes);
        PopupError (dwRes);
        return;
    }

    if(!TiffPrintDC(cstrTiff, hPrinter))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("TiffPrintDC"), dwRes);
        goto exit;
    }

exit:
    if(hPrinter)
    {
        CDC::FromHandle(hPrinter)->DeleteDC();
    }

    if (!DeleteFile (cstrTiff))
    {
        dwRes = GetLastError ();
        CALL_FAIL (FILE_ERR, TEXT("DeleteFile"), dwRes);
    }
}   // CFolderListView::OnFolderItemPrint

void 
CFolderListView::OnFolderItemCopy ()
/*++

Routine name : CFolderListView::OnFolderItemCopy

Routine description:

    Handles message copy commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemCopy"),
              TEXT("Type=%d"),
              m_Type);

    CString cstrTiff;
    DWORD dwRes = FetchTiff (cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::FetchTiff"), dwRes);
        PopupError (dwRes);
        return;
    }

    CString cstrFileName;
    CString cstrFilterFormat;

    TCHAR szFile[MAX_PATH] = {0};
    TCHAR szFilter[MAX_PATH] = {0};
    OPENFILENAME ofn = {0};
    
    //
    // get tif file name
    //
    int nFileNamePos = cstrTiff.ReverseFind(TEXT('\\'));
    ASSERTION(nFileNamePos > 0);
    nFileNamePos++;

    try
    {
        cstrFileName = cstrTiff.Right(cstrTiff.GetLength() - nFileNamePos);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::operator="), dwRes);
        PopupError (dwRes);
        goto del_file;
    }

    _tcscpy(szFile, cstrFileName);

    dwRes = LoadResourceString(cstrFilterFormat, IDS_SAVE_AS_FILTER_FORMAT);
    if (ERROR_SUCCESS != dwRes)
    {
        ASSERTION_FAILURE;
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
        goto del_file;
    }

    _stprintf(szFilter, cstrFilterFormat, FAX_TIF_FILE_MASK, 0, FAX_TIF_FILE_MASK, 0);

    ofn.lStructSize = GetOpenFileNameStructSize();
    ofn.hwndOwner   = m_hWnd;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile   = szFile;
    ofn.nMaxFile    = ARR_SIZE(szFile);
    ofn.lpstrDefExt = FAX_TIF_FILE_EXT;
    ofn.Flags       = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_ENABLEHOOK;
    ofn.lpfnHook    = OFNHookProc;

    if(!GetSaveFileName(&ofn))
    {
        goto del_file;
    }

    {
        //
        // SHFILEOPSTRUCT::pFrom should ends with double NULL
        //
        TCHAR tszSrcFile[MAX_PATH+1] = {0};
        _tcsncpy(tszSrcFile, cstrTiff, MAX_PATH);

        //
        // move the file
        //
        SHFILEOPSTRUCT shFileOpStruct = {0};

        shFileOpStruct.wFunc  = FO_MOVE;
        shFileOpStruct.fFlags = FOF_SILENT; // Don't display file move progress dialog
        shFileOpStruct.pFrom  = tszSrcFile;
        shFileOpStruct.pTo    = szFile;

        if(!SHFileOperation(&shFileOpStruct))
        {
            //
            // success
            //
            return;
        }
        else
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (GENERAL_ERR, TEXT("SHFileOperation"), dwRes);
            goto del_file;
        }
    }

del_file:
    if (!DeleteFile (cstrTiff))
    {
        dwRes = GetLastError ();
        CALL_FAIL (FILE_ERR, TEXT("DeleteFile"), dwRes);
    }

}   // CFolderListView::OnFolderItemCopy


void 
CFolderListView::OnUpdateFolderItemSendMail(
    CCmdUI* pCmdUI
)
{ 
    pCmdUI->Enable( (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_VIEW)       &&
                    (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_PROPERTIES) &&
                    theApp.IsMapiEnable());
}

void 
CFolderListView::OnUpdateFolderItemView(
    CCmdUI* pCmdUI
)
{
    OnUpdateFolderItemPrint(pCmdUI);
}

void 
CFolderListView::OnUpdateFolderItemPrint(
    CCmdUI* pCmdUI
)
{
    pCmdUI->Enable( (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_VIEW) &&
                    (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_PROPERTIES));
}

void 
CFolderListView::OnUpdateFolderItemCopy(
    CCmdUI* pCmdUI
)
{
    pCmdUI->Enable( (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_VIEW) &&
                    (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_PROPERTIES));
}


void 
CFolderListView::OnFolderItemMail ()
/*++

Routine name : CFolderListView::OnFolderItemMail

Routine description:

    Handles message mail commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemMail"),
              TEXT("Type=%d"),
              m_Type);

    CString cstrTiff;
    DWORD dwRes = FetchTiff (cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::FetchTiff"), dwRes);
        PopupError (dwRes);
        return;
    }

    //
    // create a new mail message with tif file attached
    //
    dwRes = theApp.SendMail(cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CClientConsoleApp::SendMail"), dwRes);
        PopupError (dwRes);
    }

    if (!DeleteFile (cstrTiff))
    {
        dwRes = GetLastError ();
        CALL_FAIL (FILE_ERR, TEXT("DeleteFile"), dwRes);
    }
}   // CFolderListView::OnFolderItemMail


void 
CFolderListView::OnFolderItemProperties ()
/*++

Routine name : CFolderListView::OnFolderItemProperties

Routine description:

    Handles message properties commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemProperties"),
              TEXT("Type=%d"),
              m_Type);

    //
    // Make sure there's exaclty one elemented selected
    //
    CListCtrl &refCtrl = GetListCtrl();
    ASSERTION (1 == refCtrl.GetSelectedCount());
    int iInd = refCtrl.GetNextItem (-1, LVNI_SELECTED);
    ASSERTION (0 <= iInd);
    CFaxMsg* pMsg = (CFaxMsg*)(refCtrl.GetItemData (iInd));
    ASSERTION (pMsg);

    CServerNode* pServer = pMsg->GetServer();
    ASSERTION (pServer);

    CItemPropSheet propSheet(IDS_PROPERTIES_SHEET_CAPTION);
    DWORD dwRes = propSheet.Init(pServer->GetFolder(m_Type), pMsg);
    
    if(ERROR_SUCCESS != dwRes)
    {
        PopupError (dwRes);
        return;
    }

    dwRes = propSheet.DoModal();
    if(IDABORT == dwRes)
    {
        PopupError (propSheet.GetLastError());
    }

}   // CFolderListView::OnFolderItemProperties


DWORD
CFolderListView::OpenSelectColumnsDlg() 
/*++

Routine name : CFolderListView::OpenSelectColumnsDlg

Routine description:

    opens column select dialog and reorders the columns

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    Error code

--*/
{   
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::OpenSelectColumnsDlg"),
              TEXT("Type=%d"),
              m_Type);

    ASSERTION(NULL != m_pnColumnsOrder);
    ASSERTION(NULL != m_pViewColumnInfo);

    DWORD dwCount = GetLogicalColumnsCount();

    //
    // init header string array
    //
    CString* pcstrHeaders;
    try
    {
        pcstrHeaders = new CString[dwCount];
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("new CString[dwCount]"), dwRes);
        return dwRes;
    }

    int nItemIndex;
    for (DWORD dw = 0; dw < dwCount; ++dw)
    {        
        nItemIndex = ItemIndexFromLogicalColumnIndex(dw);
        dwRes = GetColumnHeaderString (pcstrHeaders[dw], nItemIndex);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("GetColumnHeaderString"), dwRes);
            delete[] pcstrHeaders;
            return dwRes;
        }
    }

    //
    // save width
    //
    int nIndex;
    for (dw = 0; dw < m_dwDisplayedColumns; ++dw) 
    {
        nIndex = m_pnColumnsOrder[dw];
        ASSERTION(nIndex >= 0 && nIndex < dwCount);

        m_pViewColumnInfo[nIndex].nWidth = GetListCtrl().GetColumnWidth(nIndex);
    }

    //
    // start column select dialog
    //
    CColumnSelectDlg dlg(pcstrHeaders, m_pnColumnsOrder, dwCount, m_dwDisplayedColumns);
    if(IDOK == dlg.DoModal())
    {
        for (dw = 0; dw < dwCount; ++dw) 
        {
            nIndex = m_pnColumnsOrder[dw];
            ASSERTION(nIndex >= 0 && nIndex < dwCount);

            m_pViewColumnInfo[nIndex].dwOrder = dw;
            m_pViewColumnInfo[nIndex].bShow = (dw < m_dwDisplayedColumns);
        }

        //
        // if sorted column is hidden then no sort
        //
        if(m_nSortedCol >= 0)
        {
            ASSERTION(m_nSortedCol < dwCount);
            if(!m_pViewColumnInfo[m_nSortedCol].bShow)
            {
                m_nSortedCol = -1;
            }
        }
      
        ColumnsToLayout();
    }

    delete[] pcstrHeaders;

    return dwRes;

} // CFolderListView::OpenSelectColumnsDlg


DWORD 
CFolderListView::ColumnsToLayout()
/*++

Routine name : CFolderListView::ColumnsToLayout

Routine description:

    reorders columns according to saved layout

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::ColumnsToLayout"), dwRes);

    ASSERTION(NULL != m_pnColumnsOrder);
    ASSERTION(NULL != m_pViewColumnInfo);

    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwCount = GetLogicalColumnsCount();   
    
    CSize size;
    CDC* pHdrDc = refCtrl.GetHeaderCtrl()->GetDC();

    //
    // set column order
    //
    if(!refCtrl.SetColumnOrderArray(dwCount, m_pnColumnsOrder))
    {
        dwRes = ERROR_GEN_FAILURE;
        CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::SetColumnOrderArray"), dwRes);
        return dwRes;
    }

    //
    // set column width
    //
    DWORD dwItemIndex;
    CString cstrColumnText;
    for (DWORD dwCol = 0; dwCol < dwCount; ++dwCol) 
    {
        if(m_pViewColumnInfo[dwCol].bShow)
        {
            if(m_pViewColumnInfo[dwCol].nWidth < 0)
            {
                dwItemIndex = ItemIndexFromLogicalColumnIndex(dwCol);
                dwRes = GetColumnHeaderString (cstrColumnText, dwItemIndex);
                if(ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("GetColumnHeaderString"), dwRes);
                    return dwRes;
                }

                size = pHdrDc->GetTextExtent(cstrColumnText);
                refCtrl.SetColumnWidth (dwCol, size.cx * 1.5);
            }
            else
            {
                refCtrl.SetColumnWidth (dwCol, m_pViewColumnInfo[dwCol].nWidth);
            }
        }
        else
        {
            refCtrl.SetColumnWidth (dwCol, 0);
        }
    }

    Invalidate();

    return dwRes;

} // CFolderListView::ColumnsToLayout


DWORD
CFolderListView::ReadLayout(
    LPCTSTR lpszViewName
)
/*++

Routine name : CFolderListView::ReadLayout

Routine description:

    reads column layout from registry

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    lpszSection                   [in]    - registry section

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::ReadLayout"), 
              dwRes,
              TEXT("Type=%d"),
              m_Type);

    ASSERTION(NULL == m_pnColumnsOrder);
    ASSERTION(NULL == m_pViewColumnInfo);

    //
    // columns order array allocation
    //
    DWORD dwCount = GetLogicalColumnsCount();   
    try
    {
        m_pnColumnsOrder = new int[dwCount];
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("m_pdwColumnsOrder = new int[dwCount]"), dwRes);
        return dwRes;
    }
    
    for(DWORD dw=0; dw < dwCount; ++dw)
    {
        m_pnColumnsOrder[dw] = -1;
    }
    //
    // columns info array allocation
    //
    try
    {
        m_pViewColumnInfo = new TViewColumnInfo[dwCount];
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("new CString[dwCount]"), dwRes);
        return dwRes;
    }

    //
    // reads columns layout from registry
    //
    CString cstrSection;
    m_dwDisplayedColumns = 0;
    for(dw=0; dw < dwCount; ++dw)
    {
        try
        {
            cstrSection.Format(TEXT("%s\\%s\\%02d"), lpszViewName, CLIENT_VIEW_COLUMNS, dw);
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
            return dwRes;
        }

        m_pViewColumnInfo[dw].bShow = theApp.GetProfileInt(cstrSection, 
                                                           CLIENT_VIEW_COL_SHOW, 
                                                           (dw < m_dwDefaultColNum) ? 1 : 0);
        if(m_pViewColumnInfo[dw].bShow)
        {
            ++m_dwDisplayedColumns;
        }

        m_pViewColumnInfo[dw].nWidth = theApp.GetProfileInt(cstrSection, 
                                                            CLIENT_VIEW_COL_WIDTH, -1);
        m_pViewColumnInfo[dw].dwOrder = theApp.GetProfileInt(cstrSection, 
                                                            CLIENT_VIEW_COL_ORDER, dw);
        if(m_pViewColumnInfo[dw].dwOrder < dwCount)
        {
            m_pnColumnsOrder[m_pViewColumnInfo[dw].dwOrder] = dw;
        }
        else
        {
            ASSERTION_FAILURE;
        }
    }

    //
    // check column order consistence
    //
    for(dw=0; dw < dwCount; ++dw)
    {
        ASSERTION(m_pnColumnsOrder[dw] >= 0);
    }
    //
    // read sort parameters
    //
    m_bSortAscending = theApp.GetProfileInt(lpszViewName, CLIENT_VIEW_SORT_ASCENDING, 1);
    m_nSortedCol = theApp.GetProfileInt(lpszViewName, CLIENT_VIEW_SORT_COLUMN, 1);
    if(m_nSortedCol >= dwCount)
    {
        m_nSortedCol = 0;
    }

    return dwRes;

} // CFolderListView::ReadLayout


DWORD
CFolderListView::SaveLayout(
    LPCTSTR lpszViewName
)
/*++

Routine name : CFolderListView::SaveLayout

Routine description:

    saves column layout to registry

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    lpszSection                   [in]    - registry section

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::SaveLayout"), 
              dwRes,
              TEXT("Type=%d"),
              m_Type);
    
    if(!m_bColumnsInitialized)
    {
        return dwRes;
    }

    ASSERTION(m_pViewColumnInfo != NULL);

    //
    // save column layout to registry
    //
    BOOL bRes;
    DWORD dwWidth;
    CString cstrSection;
    DWORD dwCount = GetLogicalColumnsCount();   
    
    for(DWORD dw=0; dw < dwCount; ++dw)
    {
        try
        {
            cstrSection.Format(TEXT("%s\\%s\\%02d"), lpszViewName, CLIENT_VIEW_COLUMNS, dw);
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
            return dwRes;
        }

        bRes = theApp.WriteProfileInt(cstrSection, CLIENT_VIEW_COL_SHOW, 
                                                m_pViewColumnInfo[dw].bShow);
        bRes = theApp.WriteProfileInt(cstrSection, CLIENT_VIEW_COL_ORDER, 
                                                m_pViewColumnInfo[dw].dwOrder);
        dwWidth = m_pViewColumnInfo[dw].bShow ? GetListCtrl().GetColumnWidth(dw) : -1;
        bRes = theApp.WriteProfileInt(cstrSection, CLIENT_VIEW_COL_WIDTH, dwWidth);
    }

    //
    // save sort parameters
    //
    bRes = theApp.WriteProfileInt(lpszViewName, CLIENT_VIEW_SORT_ASCENDING, m_bSortAscending);
    bRes = theApp.WriteProfileInt(lpszViewName, CLIENT_VIEW_SORT_COLUMN, m_nSortedCol);    

    return dwRes;

} // CFolderListView::SaveLayout


BOOL 
CFolderListView::OnNotify( 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT* pResult
)
/*++

Routine name : CFolderListView::OnNotify

Routine description:

    disables resizing of hidden columns

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    wParam                        [in]    - Identifies the control that sends the message
    lParam                        [in]    - NMHEADER*
    pResult                       [out]   - result

Return Value:

    TRUE if message processed, FALSE otherwise.

--*/
{   
    int i=0;
    switch (((NMHEADER*)lParam)->hdr.code)
    {
        case HDN_BEGINTRACKA:
        case HDN_BEGINTRACKW:       
        case HDN_DIVIDERDBLCLICKA:
        case HDN_DIVIDERDBLCLICKW:
            DBG_ENTER(TEXT("CFolderListView::OnNotify"));

            //
            // get column index
            //
            DWORD dwIndex = ((NMHEADER*)lParam)->iItem;
            ASSERTION(NULL != m_pViewColumnInfo);
            ASSERTION(dwIndex < GetLogicalColumnsCount());

            //
            // ignore if hidden column 
            //
            if(!m_pViewColumnInfo[dwIndex].bShow )
            {
                *pResult = TRUE;
                return TRUE;
            }
    }

    return CListView::OnNotify(wParam, lParam, pResult );

} // CFolderListView::OnNotify


void 
CFolderListView::DoSort()
{
    if (m_bSorting || m_nSortedCol < 0)
    {
        //
        // Already sorting or no sorting column
        //
        return;
    }

    CWaitCursor waitCursor;

    m_bSorting = TRUE;

    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        //  Shutdown in progress
        //
    }
    else
    {
        pFrm->RefreshStatusBar ();
    }

    m_psCurrentViewBeingSorted = this;
    GetListCtrl().SortItems (ListViewItemsCompareProc, 0);                
    m_HeaderCtrl.SetSortImage( m_nSortedCol, m_bSortAscending );
    m_bSorting = FALSE;
}

DWORD 
CFolderListView::RemoveItem (
    LPARAM lparam,
    int    iIndex /* = -1 */
)
/*++

Routine name : CFolderListView::RemoveItem

Routine description:

    Removes an item from the list by its message / job pointer

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    lparam    [in]     - Message / Job pointer
    iIndex    [in]     - Optional item index in the control (for optimization)

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::RemoveItem"), 
              dwRes,
              TEXT("Type=%d"),
              m_Type);

    CListCtrl &refCtrl = GetListCtrl();
    if (-1 == iIndex)
    {
        //
        // Item index no supplied - search for it
        //
        LVFINDINFO lvfi;
        lvfi.flags = LVFI_PARAM;
        lvfi.lParam = lparam;
        iIndex = refCtrl.FindItem (&lvfi);
    }
    if (-1 == iIndex)
    {
        //
        // item already removed
        //
        CALL_FAIL (RESOURCE_ERR, TEXT("CListCtrl::FindItem"), dwRes);
        return dwRes;
    }
    BOOL bItemSelected = IsSelected (iIndex);
    //
    // Now erase the item
    //
    if (!refCtrl.DeleteItem (iIndex))
    {
        //
        // Failed to delete the item
        //
        dwRes = ERROR_GEN_FAILURE;
        CALL_FAIL (RESOURCE_ERR, TEXT("CListCtrl::DeleteItem"), dwRes);
        return dwRes;
    }

    if (bItemSelected)
    {
        //
        // If the item that we just removed was selected, we have to re-compute
        // the possible operations on the rest of the selected items.
        //
        if (!m_bInMultiItemsOperation)
        {
            //
            // Only recalc if we operate on few items.
            //
            RecalcPossibleOperations ();
        }
    }
    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CFolderListView::RemoveItem

DWORD 
CFolderListView::FindInsertionIndex (
    LPARAM lparamItemData,
    DWORD &dwResultIndex
)
/*++

Routine name : CFolderListView::FindInsertionIndex

Routine description:

    Finds an insertion index for a new item to the list, according to sort settings.

    This function must be called when the data critical section is held.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    lparamItemData  [in]     - Pointer to item
    dwResultIndex   [out]    - Insertion index

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::FindInsertionIndex"), 
              dwRes,
              TEXT("Type=%d"),
              m_Type);

    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwNumItems = refCtrl.GetItemCount ();
    if (!dwNumItems  || (-1 == m_nSortedCol))
    {
        //
        // List is not sorted or is empty, always add at the end
        //
        VERBOSE (DBG_MSG, TEXT("Insertion point at index %ld"), dwResultIndex);
        dwResultIndex = dwNumItems;
        return dwRes;
    }
    //
    // Get item index to sort by
    //
    DWORD dwItemIndex = ItemIndexFromLogicalColumnIndex (m_nSortedCol);

    //
    // Check if item can be placed in beginning of list (no search required)
    //
    LPARAM lparamTop = refCtrl.GetItemData (0); // Pointer to item in top index
    LPARAM lparamBottom = refCtrl.GetItemData (dwNumItems - 1); // Pointer to item in bottom index
    ASSERTION (lparamTop && lparamBottom);
    //
    // Get comparison result against top index
    //
    int iRes = CompareItems ((CFaxMsg*)lparamItemData, (CFaxMsg*)lparamTop, dwItemIndex);
    ASSERTION ((-1 <= iRes) && (+1 >= iRes));
    if (!m_bSortAscending)
    {
        iRes *= -1;
    }
    switch (iRes)
    {
        case -1:    // Item is smaller than top
        case  0:    // Item is identical to top
            //
            // Insert new item before top index
            //
            dwResultIndex = 0;
            VERBOSE (DBG_MSG, TEXT("Insertion point at index %ld"), dwResultIndex);
            return dwRes;

        default:    // Item is bigger than top
            //
            // Do nothing
            //
            break;
    }
    //
    // Check if item can be placed in bottom of list (no search required)
    //

    //
    // Get comparison result against bottom index
    //
    iRes = CompareItems ((CFaxMsg*)lparamItemData, (CFaxMsg*)lparamBottom, dwItemIndex);
    ASSERTION ((-1 <= iRes) && (+1 >= iRes));
    if (!m_bSortAscending)
    {
        iRes *= -1;
    }
    switch (iRes)
    {
        case +1:    // Item is bigger than bottom
        case  0:    // Item is identical to bottom
            //
            // Insert new item at the bottom index
            //
            dwResultIndex = dwNumItems;
            VERBOSE (DBG_MSG, TEXT("Insertion point at index %ld"), dwResultIndex);
            return dwRes;

        default:    // Item is smaller than bottom
            //
            // Do nothing
            //
            break;
    }
    //
    // Search for insertion point
    //
    dwRes = BooleanSearchInsertionPoint (0, 
                                         dwNumItems - 1, 
                                         lparamItemData, 
                                         dwItemIndex, 
                                         dwResultIndex);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("BooleanSearchInsertionPoint"), dwRes);
        return dwRes;
    }
    return dwRes;
}   // CFolderListView::FindInsertionIndex 

DWORD
CFolderListView::BooleanSearchInsertionPoint (
    DWORD dwTopIndex,
    DWORD dwBottomIndex,
    LPARAM lparamItemData,
    DWORD dwItemIndex,
    DWORD &dwResultIndex
)
/*++

Routine name : CFolderListView::BooleanSearchInsertionPoint

Routine description:

    Recursively searches an insertion point for a list item.
    Performs a boolean search.

    This function must be called when the data critical section is held.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    dwTopIndex      [in]     - Top list index
    dwBottomIndex   [in]     - Bottom list index
    lparamItemData  [in]     - Pointer to item
    dwItemIndex     [in]     - Logical column item to compare by
    dwResultIndex   [out]    - Insertion index

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::BooleanSearchInsertionPoint"), dwRes);

    ASSERTION (dwTopIndex <= dwBottomIndex);

    if ((dwTopIndex == dwBottomIndex) || (dwTopIndex + 1 == dwBottomIndex))
    {
        dwResultIndex = dwBottomIndex;
        VERBOSE (DBG_MSG, TEXT("Insertion point at index %ld"), dwResultIndex);
        return dwRes;
    }
    DWORD dwMiddleIndex = dwTopIndex + (dwBottomIndex - dwTopIndex) / 2;
    ASSERTION ((dwMiddleIndex != dwBottomIndex) && (dwMiddleIndex != dwTopIndex));

    CListCtrl &refCtrl = GetListCtrl();

    LPARAM lparamMiddle = refCtrl.GetItemData (dwMiddleIndex); // Pointer to item in middle index
    ASSERTION (lparamMiddle);
    //
    // Get comparison result against middle index
    //
    int iRes = CompareItems ((CFaxMsg*)lparamItemData, (CFaxMsg*)lparamMiddle, dwItemIndex);
    ASSERTION ((-1 <= iRes) && (+1 >= iRes));
    if (!m_bSortAscending)
    {
        iRes *= -1;
    }
    switch (iRes)
    {
        case -1:    // Item is smaller than middle
        case  0:    // Item is identical to middle
            //
            // Search between top and middle
            //
            dwRes = BooleanSearchInsertionPoint (dwTopIndex, 
                                                 dwMiddleIndex, 
                                                 lparamItemData, 
                                                 dwItemIndex, 
                                                 dwResultIndex);
            break;

        default:    // Item is bigger than middle
            //
            // Search between middle and bottom
            //
            dwRes = BooleanSearchInsertionPoint (dwMiddleIndex, 
                                                 dwBottomIndex, 
                                                 lparamItemData, 
                                                 dwItemIndex, 
                                                 dwResultIndex);
            break;
    }
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("BooleanSearchInsertionPoint"), dwRes);
    }
    return dwRes;
}   // CFolderListView::BooleanSearchInsertionPoint

DWORD 
CFolderListView::AddSortedItem (
    CViewRow &row, 
    LPARAM lparamItemData
)
/*++

Routine name : CFolderListView::AddSortedItem

Routine description:

    Adds an item to the list, preserving list sort order.

    This function must be called when the data critical section is held.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    row             [in] - Row of item view information
    lparamItemData  [in] - Item associated data

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::AddSortedItem"), 
              dwRes,
              TEXT("Type=%d"),
              m_Type);

    DWORD dwResultIndex;
    //
    // Find insertion index according to sort order
    //
    dwRes = FindInsertionIndex (lparamItemData, dwResultIndex);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("FindInsertionIndex"), dwRes);
        return dwRes;
    }
    //
    // Add new item in insertion index
    //
    int iItemIndex;
    dwRes = AddItem (dwResultIndex, row, lparamItemData, &iItemIndex);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("AddItem"), dwRes);
        return dwRes;
    }

    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CFolderListView::AddSortedItem

DWORD 
CFolderListView::UpdateSortedItem (
    CViewRow &row, 
    LPARAM lparamItemData
)
/*++

Routine name : CFolderListView::UpdateSortedItem

Routine description:

    Updates an item in the list, preserving list sort order.

    This function must be called when the data critical section is held.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    row             [in] - Row of item view information
    lparamItemData  [in] - Item associated data

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::UpdateSortedItem"), 
              dwRes,
              TEXT("Type=%d"),
              m_Type);

    //
    // Find the item in the list
    //
    CListCtrl &refCtrl = GetListCtrl();
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = lparamItemData;
    int iCurIndex = refCtrl.FindItem (&lvfi);
    if (-1 == iCurIndex)
    {
        dwRes = ERROR_NOT_FOUND;
        CALL_FAIL (RESOURCE_ERR, TEXT("CListCtrl::FindItem"), dwRes);
        return dwRes;
    }
#ifdef _DEBUG
    LPARAM lparamCurrentItem = refCtrl.GetItemData (iCurIndex);
    ASSERTION (lparamCurrentItem == lparamItemData);
#endif

    BOOL bJustUpdate = TRUE;   // If TRUE, we don't move the item in the list
    if (0 <= m_nSortedCol)
    {
        //
        // List is sorted.
        // See if the displayed text is different than the updated text
        //
        CString cstrDisplayedCell;
        try
        {
            cstrDisplayedCell = refCtrl.GetItemText (iCurIndex, m_nSortedCol);
        }
        catch (...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT ("CString::operator ="), dwRes);
            return dwRes;
        }
        //
        // Get item index to sort by
        //
        DWORD dwItemIndex = ItemIndexFromLogicalColumnIndex (m_nSortedCol);
        const CString &cstrUpdatedString =  row.GetItemString(dwItemIndex);
        if (cstrUpdatedString.Compare (cstrDisplayedCell))
        {
            //
            // Text in the sorted column is about to change.
            // Sorry, but we must:
            //    1. Remove old item from list
            //    2. Insert new item (sorted)
            //
            bJustUpdate = FALSE;
        }
    }
    if (bJustUpdate)
    {
        //
        // All we need to do is update the text of the list item (all sub items) and its icon
        //
        dwRes = UpdateLineTextAndIcon (iCurIndex, row);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("UpdateLineTextAndIcon"), dwRes);
            return dwRes;
        }
    }
    else
    {
        //
        // Since the text in the sorted column is different than the new text,
        // we must remove the current item and insert a new (sorted) item.
        //
        BOOL bItemSelected = IsSelected (iCurIndex);
        refCtrl.SetRedraw (FALSE);
        if (!refCtrl.DeleteItem (iCurIndex))
        {
            //
            // Failed to delete the item
            //
            dwRes = ERROR_GEN_FAILURE;
            refCtrl.SetRedraw (TRUE);
            CALL_FAIL (RESOURCE_ERR, TEXT("CListCtrl::DeleteItem"), dwRes);
            return dwRes;
        }
        dwRes = AddSortedItem (row, lparamItemData);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("AddSortedItem"), dwRes);
            refCtrl.SetRedraw (TRUE);
            return dwRes;
        }
        if (bItemSelected)
        {
            //
            // Since the item we removed was selected, we must also selected the new item
            // we just added.
            // Recalculate the possible operations the user can do on selected item.
            //
            Select (iCurIndex, TRUE);
            RecalcPossibleOperations ();
        }
        refCtrl.SetRedraw (TRUE);
    }

    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CFolderListView::UpdateSortedItem


DWORD 
CFolderListView::ConfirmItemDelete(
    BOOL& bConfirm
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::ConfirmItemDelete"), dwRes);

    //
    // do we should ask to confirm ?
    //
    BOOL bAsk = theApp.GetProfileInt(CLIENT_CONFIRM_SEC, CLIENT_CONFIRM_ITEM_DEL, 1);
    if(!bAsk)
    {
        bConfirm = TRUE;
        return dwRes;
    }

    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();
    ASSERTION (dwSelected > 0);

    //
    // prepare message string
    //
    CString cstrMsg;
    if(1 == dwSelected)
    {
        dwRes = LoadResourceString(cstrMsg, IDS_SURE_DELETE_ONE);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
            return dwRes;
        }
    }
    else 
    {
        //
        // more then 1 selected
        //
        CString cstrCount;
        try
        {
            cstrCount.Format(TEXT("%d"), dwSelected);
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
            return dwRes;
        }

        try
        {
            AfxFormatString1(cstrMsg, IDS_SURE_DELETE_MANY, cstrCount);
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("AfxFormatString1"), dwRes);
            return dwRes;
        }
    }

    //
    // are you sure ?
    //
    DWORD dwAskRes = AlignedAfxMessageBox(cstrMsg, MB_YESNO | MB_ICONQUESTION); 
    bConfirm = (IDYES == dwAskRes);

    return dwRes;

} // CFolderListView::ConfirmItemDelete


void 
CFolderListView::OnDblClk(
    NMHDR* pNMHDR, 
    LRESULT* pResult
) 
{
    DWORD nItem = ((NM_LISTVIEW*)pNMHDR)->iItem;

    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();
    DWORD dwSelItem  = refCtrl.GetNextItem (-1, LVNI_SELECTED);
    
    if(1 == dwSelected && dwSelItem == nItem)
    {
        OnFolderItemView();
    }

    *pResult = 0;
}


DWORD 
CFolderListView::FetchTiff (
    CString &cstrTiff
)
/*++

Routine name : CFolderListView::FetchTiff

Routine description:

    Fetches the TIFF image of the selected list item

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    cstrTiff  [out]    - Name of local TIFF file

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::FetchTiff"), dwRes);
    //
    // Make sure there's exaclty one elemented selected
    //
    CListCtrl &refCtrl = GetListCtrl();
    if (1 != refCtrl.GetSelectedCount())
	{
		return ERROR_CANTOPEN;
	}
    int iInd = refCtrl.GetNextItem (-1, LVNI_SELECTED);
    if (0 > iInd)
	{
		return ERROR_CANTOPEN;
	}
    CFaxMsg *pMsg = (CFaxMsg *) refCtrl.GetItemData (iInd);
	if (pMsg == NULL)
	{
		return ERROR_CANTOPEN;
	}
    //
    // Ask message to fetch the TIFF
    //
    dwRes = pMsg->GetTiff (cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("CFaxMsg::GetTIFF"), dwRes);
    }
    return dwRes;

}   // CFolderListView::FetchTiff

void 
CFolderListView::OnFolderItemDelete ()
/*++

Routine name : CFolderListView::OnFolderItemDelete

Routine description:

    Handles message delete commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemDelete"),
              TEXT("Type=%d"),
              m_Type);

    //
    // are you sure ?
    //
    BOOL bConfirm;
    DWORD dwRes = ConfirmItemDelete(bConfirm);
    if (ERROR_SUCCESS != dwRes)
    {
        PopupError (dwRes);
        CALL_FAIL (GENERAL_ERR, TEXT("ConfirmItemDelete"), dwRes);
        return;
    }

    if(!bConfirm)
    {
        //
        // not sure.
        //
        return;
    }

    CWaitCursor waitCursor;
  
    CClientConsoleDoc* pDoc = GetDocument();
    ASSERTION (pDoc);

    CServerNode* pServer = NULL;
    CFolder*     pFolder = NULL;

    //
    // Iterate set of selected messages, deleting each message in the set
    //
    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();
    if(0 == dwSelected)
    {
        return;
    }

    if (dwSelected > 1)
    {
        //
        // Disable refresh while deleting
        //
        refCtrl.SetRedraw (FALSE);
        //
        // Prevent costy re-calc on every deletion
        //
        m_bInMultiItemsOperation = TRUE;

        JobOpProgressDlgStart(FAX_JOB_OP_DELETE, dwSelected);
    }
    int iInd;
    CFaxMsg* pMsg;
    DWORDLONG dwlMsgId;
    for (DWORD dwItem = 0; dwItem < dwSelected && !m_bJobOpCancel; ++dwItem)
    {
        iInd = refCtrl.GetNextItem (-1, LVNI_SELECTED);
        if(iInd < 0)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::GetNextItem"), 0);
            break;
        }
        
        pMsg = (CFaxMsg *) refCtrl.GetItemData (iInd);
        ASSERTION (pMsg);

        dwlMsgId = pMsg->GetId();
        //
        // Ask message to delete
        //
        dwRes = pMsg->Delete ();
        if (ERROR_SUCCESS != dwRes)
        {
            PopupError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("CArchiveMsg::Delete"), dwRes);
            //
            // We exit upon first error
            //
            goto exit;
        }
        //
        // delete a message from the data map and from the view
        //
        pServer = pMsg->GetServer();
        ASSERTION (pServer);

        pFolder = pServer->GetFolder(m_Type);
        ASSERTION (pFolder);

        dwRes = pFolder->OnJobRemoved(dwlMsgId, pMsg);
        if (ERROR_SUCCESS != dwRes)
        {
            PopupError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("CMessageFolder::OnJobRemoved"), dwRes);
            goto exit;
        }

        if(m_bInMultiItemsOperation)
        {
            JobOpProgressDlgInc();
        }
    }

exit:
    if (m_bInMultiItemsOperation)
    {
        JobOpProgressDlgStop();
        //
        // Re-enable redraw
        //
        refCtrl.SetRedraw (TRUE);
        //
        // Ask for visual refresh of view
        //
        refCtrl.Invalidate ();

        m_bInMultiItemsOperation = FALSE;
        RecalcPossibleOperations ();    
    }

    if(FOLDER_TYPE_INBOX == m_Type)
    {
        theApp.InboxViewed();
    }

}   // CFolderListView::OnFolderItemDelete

void 
CFolderListView::CountColumns (
    int *lpItems
)
/*++

Routine name : CFolderListView::CountColumns

Routine description:

    Sets the items to be seen in the view.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    lpItems         [in] - List of items. ends with MSG_VIEW_ITEM_END

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::CountColumns"));
    m_dwAvailableColumnsNum = 0;
    MsgViewItemType *pItems = (MsgViewItemType *)lpItems;
    m_pAvailableColumns = pItems;
    while (MSG_VIEW_ITEM_END != *pItems)
    {
        ASSERTION (*pItems < MSG_VIEW_ITEM_END);
        ++m_dwAvailableColumnsNum;
        ++pItems;
    }
    ASSERTION (m_dwAvailableColumnsNum);
}   // CFolderListView::CountColumns

int 
CFolderListView::CompareItems (
    CFaxMsg* pFaxMsg1, 
    CFaxMsg* pFaxMsg2,
    DWORD dwItemIndex
) const
/*++

Routine name : CFolderListView::CompareItems

Routine description:

    Compares two archive items

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pFaxMsg1        [in] - Pointer to 1st message
    pFaxMsg2        [in] - Pointer to 2nd message
    dwItemIndex     [in] - Item (in the message) to comapre by

Return Value:

    -1 if message1 < message2, 0 if identical, +1 if message1 > message2

--*/
{
    DBG_ENTER(TEXT("CFolderListView::CompareItems"));

    ASSERTION (dwItemIndex < MSG_VIEW_ITEM_END);
    static CViewRow rowView1;
    static CViewRow rowView2;
    DWORD dwRes = rowView1.AttachToMsg (pFaxMsg1, FALSE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::AttachToMsg"), dwRes);
        return 0;
    }
    dwRes = rowView2.AttachToMsg (pFaxMsg2, FALSE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::AttachToMsg"), dwRes);
        return 0;
    }

    return rowView1.CompareByItem (rowView2, dwItemIndex);
}

DWORD 
CFolderListView::AddMsgMapToView(
    MSGS_MAP* pMap
)
/*++

Routine name : CFolderListView::AddMsgMapToView

Routine description:

    Add messages from the map to the view

Arguments:

    pMap        [in] - masage map

Return Value:

    error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::AddMsgMapToView"));

    ASSERTION(pMap);
    
    CListCtrl &listCtrl = GetListCtrl();
    DWORD dwCount = listCtrl.GetItemCount();

    listCtrl.SetRedraw (FALSE);

    CFaxMsg* pMsg;
    CViewRow viewRow;
    int iIndexToSelect = -1;
    for (MSGS_MAP::iterator it = pMap->begin(); it != pMap->end(); ++it)
    {
        int iItemIndex;

        pMsg = (*it).second;
        dwRes = viewRow.AttachToMsg (pMsg);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::AttachToMsg"), dwRes);
            break;
        }
        dwRes = AddItem (dwCount++, viewRow, (LPARAM)pMsg, &iItemIndex);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::AddItem"), dwRes);
            break;
        }
        if ((-1 == iIndexToSelect)    &&            // No item selected yet and
            m_dwlMsgToSelect          &&            // We should keep our eyes open for an item to select and
            (pMsg->GetId () == m_dwlMsgToSelect))   // Match found !!
        {
            //
            // This is the startup selected item.
            // Save the item index
            //
            iIndexToSelect = iItemIndex;
        }    
    }
    if (-1 != iIndexToSelect)
    {
        //
        // We have the user-specified-item-to-select in the list now
        //
        SelectItemByIndex (iIndexToSelect);
    }
    listCtrl.SetRedraw ();
    return dwRes;
} // CFolderListView::AddMsgMapToView

void 
CFolderListView::OnUpdate (
    CView* pSender, 
    LPARAM lHint, 
    CObject* pHint 
)
/*++

Routine name : CFolderListView::OnUpdate

Routine description:

    Receives a notification that the view should update itself

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pSender         [in] - Unused
    lHint           [in] - Hint of update operation
    pHint           [in] - If lHint is UPDATE_HINT_CLEAR_VIEW or UPDATE_HINT_FILL_VIEW
                           then pHint is a pointer to the folder that requested an update.

                           If lHint is UPDATE_HINT_REMOVE_ITEM, UPDATE_HINT_ADD_ITEM, or 
                           UPDATE_HINT_UPDATE_ITEM,
                           then pHint is a pointer to the job to remove / add / update.

                           Otherwise, pHint is undefined.

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnUpdate"), 
              TEXT("Hint=%ld, Type=%d"), 
              lHint,
              m_Type);

    OnUpdateHintType hint = (OnUpdateHintType) lHint;

    DWORD dwRes;
    CListCtrl &listCtrl = GetListCtrl();
    switch (hint)
    {
        case UPDATE_HINT_CREATION:
            //
            // Do nothing
            //
            break;

        case UPDATE_HINT_CLEAR_VIEW:
            //
            // Clear the entire list control now
            //
            if (!listCtrl.DeleteAllItems ())
            {
                CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::DeleteAllItems"), ERROR_GEN_FAILURE);
            }
            ClearPossibleOperations ();
            break;

        case UPDATE_HINT_ADD_CHUNK:
            {
                ASSERTION (pHint);
                MSGS_MAP* pMap = (MSGS_MAP*) pHint;

                dwRes = AddMsgMapToView(pMap);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::AddMsgMapToView"), dwRes);
                }
            }
            break;

        case UPDATE_HINT_FILL_VIEW:
            //
            // Fill the list control with my parents data
            //
            {
                ASSERTION (pHint);
                CFolder *pFolder = (CFolder *) pHint;

                pFolder->EnterData ();
                MSGS_MAP &ParentMap = pFolder->GetData ();

                dwRes = AddMsgMapToView(&ParentMap);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::AddMsgMapToView"), dwRes);
                }

                pFolder->LeaveData ();
            }
            break;

        case UPDATE_HINT_REMOVE_ITEM:
            //
            // The data critical section must be held.
            //
            {
                CFaxMsg* pMsg = (CFaxMsg*)pHint;
                ASSERTION(pMsg);

                dwRes = RemoveItem ((LPARAM)pMsg);
                if (ERROR_SUCCESS != dwRes)
                {
                    //
                    // Failed to remove item from list
                    //
                    CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::RemoveItem"), dwRes);
                    ASSERTION_FAILURE;
                }
            }
            break;

        case UPDATE_HINT_ADD_ITEM:
            //
            // The data critical section must be held.
            //
            {
                CFaxMsg* pMsg = (CFaxMsg*)pHint;
                ASSERTION(pMsg);

                CViewRow viewRow;
                dwRes = viewRow.AttachToMsg (pMsg);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::AttachToMsg"), dwRes);
                    return;
                }
                dwRes = AddSortedItem (viewRow, (LPARAM)pMsg);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::AddSortedItem"), dwRes);
                    return;
                }
            }
            break;

        case UPDATE_HINT_UPDATE_ITEM:
            //
            // The data critical section must be held.
            //
            {
                CFaxMsg* pMsg = (CFaxMsg*)pHint;
                ASSERTION(pMsg);

                CViewRow viewRow;
                dwRes = viewRow.AttachToMsg (pMsg);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::AttachToMsg"), dwRes);
                    return;
                }
                dwRes = UpdateSortedItem (viewRow, (LPARAM)pMsg);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::UpdateSortedItem"), dwRes);
                    return;
                }
            }
            break;

        default:
            //
            // Unsupported hint
            //
            ASSERTION_FAILURE;
    }

    if(!m_bInMultiItemsOperation)
    {
        RecalcPossibleOperations ();
    }

    CMainFrame *pFrm = GetFrm();
    if (pFrm)
    {
        pFrm->RefreshStatusBar();
    }

}   // CFolderListView::OnUpdate

int 
CFolderListView::GetPopupMenuResource () const
{
    DBG_ENTER(TEXT("CFolderListView::GetPopupMenuResource"));

    int nMenuRes=0;

    switch(m_Type)
    {
    case FOLDER_TYPE_INCOMING:
        nMenuRes = IDM_INCOMING;
        break;
    case FOLDER_TYPE_INBOX:
        nMenuRes = IDM_INBOX;
        break;
    case FOLDER_TYPE_SENT_ITEMS:
        nMenuRes = IDM_SENTITEMS;
        break;
    case FOLDER_TYPE_OUTBOX:
        nMenuRes = IDM_OUTBOX;
        break;
    default:
        ASSERTION_FAILURE
        break;
    }

    return nMenuRes;
}

void 
CFolderListView::OnFolderItemPause ()
/*++

Routine name : CFolderListView::OnFolderItemPause

Routine description:

    Handles job pause commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemPause"),
              TEXT("Type=%d"),
              m_Type);

    CWaitCursor waitCursor;

    //
    // Iterate set of selected jobs, pausing each job in the set
    //
    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();
    ASSERTION (dwSelected);

    int iInd = -1;

    if(dwSelected > 1)
    {
        m_bInMultiItemsOperation = TRUE;
        JobOpProgressDlgStart(FAX_JOB_OP_PAUSE, dwSelected);
    }

    for (DWORD dwItem = 0; dwItem < dwSelected && !m_bJobOpCancel; ++dwItem)
    {
        iInd = refCtrl.GetNextItem (iInd, LVNI_SELECTED);
        if(iInd < 0)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::GetNextItem"), 0);
            break;
        }
        CFaxMsg* pJob = (CFaxMsg*) refCtrl.GetItemData (iInd);
        ASSERT_KINDOF(CJob, pJob);
        //
        // Ask job to pause
        //
        DWORD dwRes = pJob->Pause ();
        if (ERROR_SUCCESS != dwRes)
        {
            PopupError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("CJob::Pause"), dwRes);
            //
            // We exit upon first error
            //
            goto exit;
        }

        //
        // update the view
        //
        OnUpdate (NULL, UPDATE_HINT_UPDATE_ITEM, pJob);    

        if(m_bInMultiItemsOperation)
        {
            JobOpProgressDlgInc();
        }
    }

exit:
    if(m_bInMultiItemsOperation)
    {
        m_bInMultiItemsOperation = FALSE;
        JobOpProgressDlgStop();
        RecalcPossibleOperations(); 
    }
}   // CFolderListView::OnFolderItemPause

void CFolderListView::OnFolderItemResume ()
/*++

Routine name : CFolderListView::OnFolderItemResume

Routine description:

    Handles job resume commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemResume"),
              TEXT("Type=%d"),
              m_Type);

    CWaitCursor waitCursor;

    //
    // Iterate set of selected jobs, resuming each job in the set
    //
    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();
    ASSERTION (dwSelected);

    if(dwSelected > 1)
    {
        m_bInMultiItemsOperation = TRUE;
        JobOpProgressDlgStart(FAX_JOB_OP_RESUME, dwSelected);
    }

    int iInd = -1;
    for (DWORD dwItem = 0; dwItem < dwSelected && !m_bJobOpCancel; ++dwItem)
    {
        iInd = refCtrl.GetNextItem (iInd, LVNI_SELECTED);
        if(iInd < 0)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::GetNextItem"), 0);
            break;
        }
        CFaxMsg* pJob = (CFaxMsg*) refCtrl.GetItemData (iInd);
        ASSERT_KINDOF(CJob, pJob);
        //
        // Ask job to resume
        //
        DWORD dwRes = pJob->Resume ();
        if (ERROR_SUCCESS != dwRes)
        {
            PopupError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("CJob::Resume"), dwRes);
            //
            // We exit upon first error
            //
            goto exit;
        }

        //
        // update the view
        //
        OnUpdate (NULL, UPDATE_HINT_UPDATE_ITEM, pJob);    

        if(m_bInMultiItemsOperation)
        {
            JobOpProgressDlgInc();
        }
    }

exit:
    if(m_bInMultiItemsOperation)
    {
        m_bInMultiItemsOperation = FALSE;
        JobOpProgressDlgStop();
        RecalcPossibleOperations(); 
    }

}   // CFolderListView::OnFolderItemResume

void 
CFolderListView::OnFolderItemRestart ()
/*++

Routine name : CFolderListView::OnFolderItemRestart

Routine description:

    Handles job restart commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemRestart"),
              TEXT("Type=%d"),
              m_Type);

    CWaitCursor waitCursor;

    //
    // Iterate set of selected jobs, restarting each job in the set
    //
    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();
    ASSERTION (dwSelected);

    if(dwSelected > 1)
    {
        m_bInMultiItemsOperation = TRUE;
        JobOpProgressDlgStart(FAX_JOB_OP_RESTART, dwSelected);
    }

    int iInd = -1;
    for (DWORD dwItem = 0; dwItem < dwSelected && !m_bJobOpCancel; ++dwItem)
    {
        iInd = refCtrl.GetNextItem (iInd, LVNI_SELECTED);
        if(iInd < 0)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::GetNextItem"), 0);
            break;
        }
        CFaxMsg* pJob = (CFaxMsg*) refCtrl.GetItemData (iInd);
        ASSERT_KINDOF(CJob, pJob);
        //
        // Ask job to restart
        //
        DWORD dwRes = pJob->Restart ();
        if (ERROR_SUCCESS != dwRes)
        {
            PopupError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("CJob::Restart"), dwRes);
            //
            // We exit upon first error
            //
            goto exit;
        }

        //
        // update the view
        //
        OnUpdate (NULL, UPDATE_HINT_UPDATE_ITEM, pJob);    

        if(m_bInMultiItemsOperation)
        {
            JobOpProgressDlgInc();
        }
    }

exit:
    if(m_bInMultiItemsOperation)
    {
        m_bInMultiItemsOperation = FALSE;
        JobOpProgressDlgStop();
        RecalcPossibleOperations(); 
    }

}   // CFolderListView::OnFolderItemRestart


void 
CFolderListView::OnChar( 
    UINT nChar, 
    UINT nRepCnt, 
    UINT nFlags 
)
/*++

Routine name : CFolderListView::OnChar

Routine description:

    The framework calls this member function when a keystroke translates 
    to a nonsystem character

Arguments:

  nChar     [in] - Contains the character code value of the key.
  nRepCnt   [in] - Contains the repeat count
  nFlags    [in] - Contains the scan code

Return Value:

    None.

--*/
{
    if(VK_TAB == nChar)
    {
        CMainFrame *pFrm = GetFrm();
        if (!pFrm)
        {
            //
            //  Shutdown in progress
            //
            return;
        }

        CLeftView* pLeftView = pFrm->GetLeftView();
        if(pLeftView)
        {
            pLeftView->SetFocus();
        }
    }
    else
    {
        CListView::OnChar(nChar, nRepCnt, nFlags);
    }
}

afx_msg void 
CFolderListView::OnContextMenu(
    CWnd *pWnd, 
    CPoint pos
)
{
    DBG_ENTER(TEXT("CFolderListView::OnContextMenu"),
              TEXT("Type=%d"),
              m_Type);

    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();

    if (!dwSelected)
    {
        //
        // If no item is selected, this is equivalent to right-clicking an empty area in the list view
        // which does nothing.
        //
        return;
    }

    if (pos.x == -1 && pos.y == -1)
    {
        //
        // Keyboard (VK_APP or Shift + F10)
        //
        //
        // Pop the context menu near the mouse cursor
        //
        pos = (CPoint) GetMessagePos();
    }

    int iMenuResource = GetPopupMenuResource ();
    if(0 == iMenuResource)
    {
        ASSERTION_FAILURE;
        return;
    }

    ScreenToClient(&pos);

    CMenu mnuContainer;
    if (!mnuContainer.LoadMenu (iMenuResource))
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("CMenu::LoadMenu"), ERROR_GEN_FAILURE);
        return;
    }
    CMenu *pmnuPopup = mnuContainer.GetSubMenu (0);
    ASSERTION (pmnuPopup);

    ClientToScreen(&pos);
    if (!pmnuPopup->TrackPopupMenu (TPM_LEFTALIGN, 
                                    pos.x, 
                                    pos.y, 
                                    theApp.m_pMainWnd))
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("CMenu::TrackPopupMenu"), ERROR_GEN_FAILURE);
    }
}   // CFolderListView::OnContextMenu

void 
CFolderListView::SelectItemById (
    DWORDLONG dwlMsgId
)
/*++

Routine name : CFolderListView::SelectItemById

Routine description:

	Selects an item in the list control, by its message id

Author:

	Eran Yariv (EranY),	May, 2001

Arguments:

	dwlMsgId       [in]     - Message id

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::SelectItemById"),
              TEXT("Message id=%0xI64d"),
              dwlMsgId);

    ASSERTION (dwlMsgId);

    int iMsgIndex = FindItemIndexFromID (dwlMsgId);
    if (-1 == iMsgIndex)
    {
        //
        // Message could not be found in the list.
        // This usually happens when we handle a WM_CONSOLE_SELECT_ITEM message sent to the main frame
        // but the folder is in the middle of refresh and the requested message might not be there yet.
        //
        // By setting m_dwlMsgToSelect = dwlMsgId we signal the OnFolderRefreshEnded() funtion to call us again
        // once refresh has ended.
        //
        VERBOSE (DBG_MSG, TEXT("Item not found - doing nothing"));
        m_dwlMsgToSelect = dwlMsgId;
        return;
    }
    SelectItemByIndex (iMsgIndex);
}   // CFolderListView::SelectItemById

void 
CFolderListView::SelectItemByIndex (
    int iMsgIndex
)
/*++

Routine name : CFolderListView::SelectItemByIndex

Routine description:

	Selects an item in the list control, by its list item index

Author:

	Eran Yariv (EranY),	May, 2001

Arguments:

	dwlMsgId       [in]     - List item index

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::SelectItemByIndex"),
              TEXT("Index = %ld"),
              iMsgIndex);


    CListCtrl &refCtrl = GetListCtrl();
    ASSERTION (iMsgIndex >= 0 && iMsgIndex < refCtrl.GetItemCount());

    OnSelectNone();
    refCtrl.SetItemState (iMsgIndex, 
                          LVIS_SELECTED | LVIS_FOCUSED,
                          LVIS_SELECTED | LVIS_FOCUSED);
    refCtrl.EnsureVisible (iMsgIndex, FALSE);
    refCtrl.SetFocus();
    //
    // Make sure this item won't be selected again
    //
    m_dwlMsgToSelect = 0;
}   // CFolderListView::SelectItemByIndex

int  
CFolderListView::FindItemIndexFromID (
    DWORDLONG dwlMsgId
)
/*++

Routine name : CFolderListView::FindItemIndexFromID

Routine description:

	Finds the list view item index of a message by a message id

Author:

	Eran Yariv (EranY),	May, 2001

Arguments:

	dwlMsgId     [in]     - Message id

Return Value:

    Item index. -1 if not found

--*/
{
    DBG_ENTER(TEXT("CFolderListView::FindItemIndexFromID"),
              TEXT("Message id=%0xI64d"),
              dwlMsgId);

    CListCtrl &refCtrl = GetListCtrl();
    int iItemCount = refCtrl.GetItemCount();
    //
    // We must traverse the entire list and look for the message that matches the id.
    //
    for (int iIndex = 0; iIndex < iItemCount; iIndex++)
    {
        CFaxMsg *pMsg = (CFaxMsg*)refCtrl.GetItemData (iIndex);
        if (dwlMsgId == pMsg->GetId())
        {
            //
            // Found it
            //
            return iIndex;
        }
    }
    return -1;
}   // CFolderListView::FindItemIndexFromID


INT_PTR 
CALLBACK 
CFolderListView::JobOpProgressDlgProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
)
/*++

Routine description:

    Job operation progress dialog

Arguments:

  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter

Return Value:

    return TRUE if it processed the message

--*/

{
    static CFolderListView* pFolderView = NULL;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            pFolderView = (CFolderListView*)lParam;
            return FALSE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    pFolderView->m_bJobOpCancel = TRUE;
                    ::EnableWindow(::GetDlgItem(hwndDlg, IDCANCEL), FALSE);
                    return TRUE;
            }                
            break;
    }
    return FALSE;

} // CFolderListView::JobOpProgressDlgProc


BOOL
CFolderListView::JobOpProgressDlgStart(
    FAX_ENUM_JOB_OP opJob,
    DWORD           dwItems
)
/*++

Routine name : CFolderListView::JobOpProgressDlgStart

Routine description:

	Open and initialize multi job operation dialog

Arguments:

	opJob       [in]- operation type FAX_ENUM_JOB_OP enum
    dwItems     [in]- number of iterations

Return Value:

    TRUE if success
    FALSE otherwise

--*/
{
    DBG_ENTER(TEXT("CFolderListView::JobOpProgressDlgStart"));

    HWND hProgressDlg = CreateDialogParam(GetResourceHandle(),               // handle to module
                                          MAKEINTRESOURCE(IDD_FAX_PROGRESS), // dialog box template name
                                          theApp.m_pMainWnd->m_hWnd,         // handle to owner window
                                          JobOpProgressDlgProc,              // dialog box procedure
                                          (LPARAM)this);                     // initialization value
    if(!hProgressDlg)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CreateDialog"), GetLastError());
        return FALSE;
    }

    //
    // Set title string
    //
    DWORD dwTitleID=0;
    TCHAR szTitle[MAX_PATH]={0};
    switch(opJob)
    {
        case FAX_JOB_OP_PAUSE:
            dwTitleID = IDS_PROGRESS_PAUSE;
            break;
        case FAX_JOB_OP_RESUME:
            dwTitleID = IDS_PROGRESS_RESUME;
            break;
        case FAX_JOB_OP_RESTART:
            dwTitleID = IDS_PROGRESS_RESTART;
            break;
        case FAX_JOB_OP_DELETE:
            dwTitleID = IDS_PROGRESS_DELETE;
            break;
        default:
            ASSERTION_FAILURE;
            break;
    }
    if(LoadString(GetResourceHandle(), dwTitleID, szTitle, ARR_SIZE(szTitle)))
    {
        ::SetDlgItemText(hProgressDlg, IDC_PROGRESS_TITLE, szTitle);
    }
    else
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadString"), GetLastError());
    }

    //
    // Init progress bar
    //
    m_dwJobOpPos = 0;
    m_dwJobOpItems = dwItems;
    ::SendDlgItemMessage(hProgressDlg, IDC_PROGRESS_BAR, PBM_SETRANGE32, 0, dwItems);
    ::SendDlgItemMessage(hProgressDlg, IDC_PROGRESS_BAR, PBM_SETSTEP, 1, 0);  

    theApp.m_pMainWnd->EnableWindow(FALSE);

    m_hJobOpProgressDlg = hProgressDlg;

    return TRUE;

} // CFolderListView::JobOpProgressDlgStart

void 
CFolderListView::JobOpProgressDlgInc()
/*++

Routine name : CFolderListView::JobOpProgressDlgInc

Routine description:

	Multi job operation progress dialog increment

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::JobOpProgressDlgInc"));

    if(!m_hJobOpProgressDlg)
    {
        return;
    }

    ++m_dwJobOpPos;
    //
    // Increment progress bar
    //
    ::SendDlgItemMessage(m_hJobOpProgressDlg, IDC_PROGRESS_BAR, PBM_STEPIT, 0, 0);

    //
    // Compose and set progress string
    //
    TCHAR szFormat[MAX_PATH] = {0};
    TCHAR szText[MAX_PATH] = {0};
    DWORD dwParam[2];    

    dwParam[0] = m_dwJobOpPos;
    dwParam[1] = m_dwJobOpItems;

    if(LoadString(GetResourceHandle(), 
                   IDS_PROGRESS_NUMBER,
                   szFormat, 
                   ARR_SIZE(szFormat)))
    {
        if(FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        (LPCVOID)szFormat,
                        0,
                        0,
                        szText,
                        ARR_SIZE(szText),
                        (va_list*)dwParam))
        {
            ::SetDlgItemText(m_hJobOpProgressDlg, IDC_PROGRESS_NUMBER, szText);
        }
        else
        {            
            CALL_FAIL (GENERAL_ERR, TEXT ("FormatMessage"), GetLastError());
        }
    }
    else
    {
        CALL_FAIL (RESOURCE_ERR, TEXT ("LoadString(IDS_PROGRESS_NUMBER)"), GetLastError());
    }

    //
    // MFC message pump
    // Taken from MSDN Q99999
    // INFO: Background Processing in an MFC Application
    //
    MSG msg;
    while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        if (!theApp.PreTranslateMessage(&msg))
        {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
        }
      
        theApp.OnIdle(0);   // updates user interface
        theApp.OnIdle(1);   // frees temporary objects
    }

} // CFolderListView::JobOpProgressDlgInc

void 
CFolderListView::JobOpProgressDlgStop()
/*++

Routine name : CFolderListView::JobOpProgressDlgStop

Routine description:

	Close multi job operation progress dialog

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::JobOpProgressDlgStop"));

    if(!m_hJobOpProgressDlg)
    {
        return;
    }

    ::DestroyWindow(m_hJobOpProgressDlg);
    m_hJobOpProgressDlg = NULL;
    m_bJobOpCancel = FALSE;
    m_dwJobOpItems = 0;
    m_dwJobOpPos = 0;

    theApp.ReturnFromModal();

} // CFolderListView::JobOpProgressDlgStop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\folderlistview.h ===
#if !defined(AFX_FOLDERLISTVIEW_H__D4D73C95_2B20_4A68_8B87_9DA4512F77C9__INCLUDED_)
#define AFX_FOLDERLISTVIEW_H__D4D73C95_2B20_4A68_8B87_9DA4512F77C9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FolderListView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFolderListView view

typedef enum
{
    UPDATE_HINT_CREATION,       // Sent by the framework upon creation
    UPDATE_HINT_CLEAR_VIEW,     // Clear entire list in view
    UPDATE_HINT_FILL_VIEW,      // Repopulate entire list in view
    UPDATE_HINT_REMOVE_ITEM,    // Remove a single item from the view.
                                // The item to remove is pointed by pHint
    UPDATE_HINT_ADD_ITEM,       // Add a single item from the view.
                                // The item to add is pointed by pHint
    UPDATE_HINT_UPDATE_ITEM,    // Update text for a single item from the view.
                                // The item to update is pointed by pHint
    UPDATE_HINT_ADD_CHUNK       // Add a chunk of messages to the view
} OnUpdateHintType;


struct TViewColumnInfo
{
	BOOL  bShow;	// FALSE if column hidden
	int   nWidth;	// column width
	DWORD dwOrder;	// column number in list control
};

//
// The WM_FOLDER_REFRESH_ENDED is sent by the thread in CFolder when it
// finishes to rebuild the list of items in the folder and wishes to 
// update the dislpay.
//
// lParam = Pointer to the CFolder that sent the message.
// wParam = Last Win32 error code returnd by the enumeration thread.
//
#define WM_FOLDER_REFRESH_ENDED         WM_APP + 1
#define WM_FOLDER_ADD_CHUNK             WM_APP + 2
#define WM_FOLDER_INVALIDATE            WM_APP + 3


extern CClientConsoleApp theApp;

class CFolderListView : public CListView
{
public:
    CFolderListView () : 
        m_bSorting(FALSE),
        m_dwPossibleOperationsOnSelectedItems (0),
        m_bColumnsInitialized (FALSE),
        m_nSortedCol (-1),   // Start unsorted
		m_dwDisplayedColumns(0),
		m_pViewColumnInfo(NULL),
		m_pnColumnsOrder(NULL),
        m_Type((FolderType)-1),
        m_bInMultiItemsOperation(FALSE),
        m_dwDefaultColNum(8),
        m_dwlMsgToSelect (theApp.GetMessageIdToSelect()),
        m_hJobOpProgressDlg(NULL),
        m_bJobOpCancel(FALSE),
        m_dwJobOpItems(0),
        m_dwJobOpPos(0)
    {
        ZeroMemory((PVOID)m_nImpossibleOperationsCounts, sizeof(m_nImpossibleOperationsCounts));
    }

    void SetType(FolderType type) { m_Type = type; }
    FolderType GetType() { return m_Type; }

    void SelectItemById (DWORDLONG dwlMsgId);
    void SelectItemByIndex (int iMsgIndex);

    int  FindItemIndexFromID (DWORDLONG dwlMsgId);

    CClientConsoleDoc* GetDocument();

    DECLARE_DYNCREATE(CFolderListView)

    BOOL Sorting() const  { return m_bSorting; }

    DWORD RefreshImageLists (BOOL bForce);

    DWORD InitColumns (int *pColumnsUsed, DWORD dwDefaultColNum); 
    void  AutoFitColumns ();

	void DoSort();

	DWORD ReadLayout(LPCTSTR lpszViewName);
	DWORD SaveLayout(LPCTSTR lpszViewName);
	DWORD ColumnsToLayout();

	DWORD OpenSelectColumnsDlg();

    BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);

    void OnUpdate (CView* pSender, LPARAM lHint, CObject* pHint );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClientConsoleView)
	public:
	void OnDraw(CDC* pDC);  // overridden to draw this view
	BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	void OnInitialUpdate(); // called first time after construct
	BOOL OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult );
	//}}AFX_VIRTUAL

// Implementation

protected:
	virtual ~CFolderListView() 
	{
		SAFE_DELETE_ARRAY(m_pViewColumnInfo);
		SAFE_DELETE_ARRAY(m_pnColumnsOrder);
	}

#ifdef _DEBUG
    void AssertValid() const;
    void Dump(CDumpContext& dc) const;
#endif

    DWORD RemoveItem (LPARAM lparam, int iItem = -1);
    DWORD AddItem (DWORD dwLineIndex, CViewRow &row, LPARAM lparamItemData, PINT);
    DWORD UpdateLineTextAndIcon (DWORD dwLineIndex, CViewRow &row);
    DWORD AddSortedItem (CViewRow &row, LPARAM lparamItemData);
    DWORD UpdateSortedItem (CViewRow &row, LPARAM lparamItemData);

    // Generated message map functions
protected:
    //{{AFX_MSG(CFolderListView)
    afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemRightClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnContextMenu(CWnd *pWnd, CPoint pos);
    afx_msg void OnUpdateSelectAll (CCmdUI* pCmdUI)
        { 
            CListCtrl &refCtrl = GetListCtrl();
            pCmdUI->Enable (refCtrl.GetSelectedCount () < refCtrl.GetItemCount()); 
        }

    afx_msg void OnUpdateSelectNone (CCmdUI* pCmdUI)
        { pCmdUI->Enable (GetListCtrl().GetSelectedCount () > 0); }

    afx_msg void OnUpdateSelectInvert (CCmdUI* pCmdUI)
        { pCmdUI->Enable (GetListCtrl().GetItemCount() > 0); }

    afx_msg void OnSelectAll ();
    afx_msg void OnSelectNone ();
    afx_msg void OnSelectInvert ();

    afx_msg void OnFolderItemView ();
    afx_msg void OnFolderItemPrint ();
    afx_msg void OnFolderItemCopy ();
    afx_msg void OnFolderItemMail ();
    afx_msg void OnFolderItemProperties ();

    afx_msg void OnFolderItemPause ();
    afx_msg void OnFolderItemResume ();
    afx_msg void OnFolderItemRestart ();

	afx_msg void OnFolderItemDelete();
  	afx_msg void OnDblClk(NMHDR* pNMHDR, LRESULT* pResult);

    afx_msg void OnUpdateFolderItemView (CCmdUI* pCmdUI);
	afx_msg void OnUpdateFolderItemSendMail(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFolderItemPrint(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFolderItemCopy(CCmdUI* pCmdUI);

    afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnUpdateFolderItemProperties (CCmdUI* pCmdUI)
        { pCmdUI->Enable (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_PROPERTIES); }

    afx_msg void OnUpdateFolderItemDelete (CCmdUI* pCmdUI)
        { pCmdUI->Enable (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_DELETE); }

    afx_msg void OnUpdateFolderItemPause (CCmdUI* pCmdUI)
        { pCmdUI->Enable (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_PAUSE); }

    afx_msg void OnUpdateFolderItemResume (CCmdUI* pCmdUI)
        { pCmdUI->Enable (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_RESUME); }

    afx_msg void OnUpdateFolderItemRestart (CCmdUI* pCmdUI)
        { pCmdUI->Enable (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_RESTART); }

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    //
    // Calculate possible operations
    //

    DWORD  m_dwPossibleOperationsOnSelectedItems;   // Operation available on 
                                                    // the set of selected items

    int    m_nImpossibleOperationsCounts[FAX_JOB_OP_NUMBER]; // Each array enrty corresponds to single possible operation
                                                              // Array enrty contains a number of selected items
                                                              // are NOT supporting specific operation
    void RecalcPossibleOperations ();
    void OnItemSelected(CFaxMsg* pFaxMsg);
    void OnItemUnSelected(CFaxMsg* pFaxMsg);

    DWORD GetServerPossibleOperations (CFaxMsg* pMsg);// Get operations possible on items according 
                                                      // to server's security configuration.

protected:

    FolderType m_Type;          // Type of this folder

    MsgViewItemType* m_pAvailableColumns;    // List of columns to use 
    DWORD  m_dwAvailableColumnsNum;  // Size of the m_pAvailableColumns list

    
    //
    // The following functions should be overriden by derived classes
    //
    DWORD ItemIndexFromLogicalColumnIndex(DWORD dwColIndex) const
        {
            ASSERT (dwColIndex < GetLogicalColumnsCount ());
            return m_pAvailableColumns[dwColIndex];
        }

    DWORD GetColumnHeaderString (CString &cstrRes, DWORD dwItemIndex) const
        {
            ASSERT (dwItemIndex < MSG_VIEW_ITEM_END);
            return CViewRow::GetItemTitle (dwItemIndex, cstrRes);
        }

    int GetColumnHeaderAlignment (DWORD dwItemIndex) const
        {
            ASSERT (dwItemIndex < MSG_VIEW_ITEM_END);
            return CViewRow::GetItemAlignment (dwItemIndex);
        }

    DWORD GetLogicalColumnsCount () const
        { 
            ASSERT (m_dwAvailableColumnsNum); 
            return m_dwAvailableColumnsNum; 
        }

    BOOL  IsItemIcon(DWORD dwItemIndex) const
        {
            ASSERT (dwItemIndex < MSG_VIEW_ITEM_END);
            return CViewRow::IsItemIcon (dwItemIndex);
        }

    int GetPopupMenuResource () const;

    void  CountColumns (int *pColumnsUsed);
    DWORD FetchTiff (CString &cstrTiff);

    int GetEmptyAreaPopupMenuRes() { return 0; }

    DWORD ConfirmItemDelete(BOOL& bConfirm);

    afx_msg LRESULT OnFolderRefreshEnded (WPARAM, LPARAM);
    afx_msg LRESULT OnFolderAddChunk (WPARAM, LPARAM);
    afx_msg LRESULT OnFolderInvalidate (WPARAM, LPARAM);

    void ClearPossibleOperations ()
        { m_dwPossibleOperationsOnSelectedItems = 0; }


    //
    // Multi job operetions progress indication
    //
    HWND  m_hJobOpProgressDlg; // job operations progress dialog handle
    BOOL  m_bJobOpCancel;      // job operations were canceled
    DWORD m_dwJobOpItems;      // number of iterations
    DWORD m_dwJobOpPos;        // current iteration number

    BOOL JobOpProgressDlgStart(FAX_ENUM_JOB_OP opJob, DWORD dwItems);
    void JobOpProgressDlgInc();
    void JobOpProgressDlgStop();

    static INT_PTR CALLBACK JobOpProgressDlgProc(HWND, UINT, WPARAM, LPARAM);

private:

    BOOL            m_bSorting;             // Are we sorting now?

    BOOL            m_bColumnsInitialized;  // Did we init the columns?
    CSortHeader     m_HeaderCtrl;           // Our custom header control
    int             m_nSortedCol;           // Column to sort by
    BOOL            m_bSortAscending;       // Sort order

    static CFolderListView    *m_psCurrentViewBeingSorted;  // Pointer to view that gets sorted.
	DWORD			m_dwDisplayedColumns;

	TViewColumnInfo*	m_pViewColumnInfo;
	int*				m_pnColumnsOrder;

    static int CALLBACK ListViewItemsCompareProc (
        LPARAM lParam1, 
        LPARAM lParam2, 
        LPARAM lParamSort);

    int CompareListItems (CFaxMsg* pFaxMsg1, CFaxMsg* pFaxMsg2);
    int CompareItems (CFaxMsg* pFaxMsg1, CFaxMsg* pFaxMsg2, DWORD dwItemIndex) const;

    DWORD FindInsertionIndex (LPARAM lparamItemData, DWORD &dwResultIndex);
    DWORD BooleanSearchInsertionPoint (
        DWORD dwTopIndex,
        DWORD dwBottomIndex,
        LPARAM lparamItemData,
        DWORD dwItemIndex,
        DWORD &dwResultIndex
    );

    //
    // List items selection
    //
    BOOL IsSelected (int iItem);
    void Select     (int iItem, BOOL bSelect);

    DWORD AddMsgMapToView(MSGS_MAP* pMap);

    BOOL  m_bInMultiItemsOperation;                   // Are we performing a long operation on many items?

    DWORD m_dwDefaultColNum;                          // Default column number

    DWORDLONG m_dwlMsgToSelect;                       // Message id to select when the folder refresh has ended

public:
    static CImageList m_sReportIcons;   // The list of images that act as icons
                                        // in the right pane (report views).
                                        // This image list is shared among all views.

    static CImageList m_sImgListDocIcon;  // Image list (with only one image) for the icon in the header control (icon column)
};

#ifndef _DEBUG  // debug version in ClientConsoleView.cpp
inline CClientConsoleDoc* CFolderListView::GetDocument()
   { return (CClientConsoleDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FOLDERLISTVIEW_H__D4D73C95_2B20_4A68_8B87_9DA4512F77C9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\inboxdetailspg.cpp ===
// InboxDetailsPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     50

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_CSID,                     IDC_CSID_VALUE,
    MSG_VIEW_ITEM_TSID,                     IDC_TSID_VALUE,
    MSG_VIEW_ITEM_DEVICE,                   IDC_DEVICE_VALUE,
    MSG_VIEW_ITEM_ID,                       IDC_JOB_ID_VALUE,
    MSG_VIEW_ITEM_CALLER_ID,                IDC_CALLER_ID_VALUE,
    MSG_VIEW_ITEM_ROUTING_INFO,             IDC_ROUTING_INFO_VALUE,
	MSG_VIEW_ITEM_SERVER,					IDC_SERVER_VALUE
};

/////////////////////////////////////////////////////////////////////////////
// CInboxDetailsPg property page

IMPLEMENT_DYNCREATE(CInboxDetailsPg, CMsgPropertyPg)

CInboxDetailsPg::CInboxDetailsPg(
    CFaxMsg* pMsg     // pointer to CArchiveMsg
): 
    CMsgPropertyPg(CInboxDetailsPg::IDD, pMsg)
{
}

CInboxDetailsPg::~CInboxDetailsPg()
{
}

void CInboxDetailsPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInboxDetailsPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInboxDetailsPg, CMsgPropertyPg)
	//{{AFX_MESSAGE_MAP(CInboxDetailsPg)
	//}}AFX_MESSAGE_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInboxDetailsPg message handlers

BOOL 
CInboxDetailsPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CInboxDetailsPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\import.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// W2K TIF files import support
//

#include "stdafx.h"
#include <tiff.h>
#include <Sddl.h>
#include <shlobjp.h> // LinkWindow control

#define __FILE_ID__     75

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef UNICODE

#define WM_IMPORT_PROGRESS_INC     WM_APP + 3 // Increment Import progress bar
#define WM_IMPORT_SET_FILE_COUNT   WM_APP + 4 // Set the file number to import

extern CClientConsoleApp theApp;

//
// Structure passed to the ImportArchiveFolder thread
//
struct ImportFolderParam
{
    LPCWSTR cszImportFolder; // Import folder name
    BOOL    bSentItems;      // TRUE if the folder contains outbound faxes
    HWND    hImportDlg;      // Handle to the Import progress dialog
    BOOL    bCancel;         // TRUE if the Cancel button has been pressed
};


DWORD 
ImportArchiveFile(
    LPCWSTR    pszFile, 
    LPWSTR     pszArchiveFolder, 
    BOOL       bSentItems,
    WCHAR*     pszUserSid,
    DWORDLONG* pdwlUniqueId
)
/*++

Routine name : ImportArchiveFile

Routine description:

    Imports pszFile file to the pszArchiveFolder folder.
    The pszFile should be generated by W2K MS Fax

Arguments:

    pszFile            - [in]  Imported file name
    pszArchiveFolder   - [in]  MS Fax archive folder name
    bSentItems         - [in]  TRUE if the file from the sent archive, FALSE if it from receive one
    pszUserSid         - [in]  The user string SID, can be NULL if(bSentItems == FALSE)
    pdwlUniqueId       - [out] Unique id for the file

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("ImportArchive"), dwRes);

    WCHAR* pszFileExt = FAX_TIF_FILE_EXT;
    WCHAR  szArchFile[MAX_PATH] = {0};

    MS_TAG_INFO  msTags = {0};

    //
    // Generate unique file name in the archive folder
    // 
    *pdwlUniqueId = GenerateUniqueFileName(pszArchiveFolder, 
                                           pszFileExt, 
                                           szArchFile, 
                                           ARR_SIZE(szArchFile));
    if(*pdwlUniqueId == 0)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT ("GenerateUniqueFileName"), dwRes);
        goto exit;
    }

    if(bSentItems)
    {
        //
        // Add user user SID to the file name for the outbound archive
        //
        // Delete generated file without the user SID in the name
        //
        if(!DeleteFile(szArchFile))
        {
            CALL_FAIL (GENERAL_ERR, TEXT ("DeleteFile"), GetLastError());
        }

        //
        // Add the user SID to the file name
        //
        if (_sntprintf(szArchFile,
                       ARR_SIZE(szArchFile) -1,
                       TEXT("%s\\%s$%I64X%s"),
                       pszArchiveFolder,
                       pszUserSid,
                       *pdwlUniqueId,
                       FAX_TIF_FILE_DOT_EXT) < 0)
        {
            dwRes = ERROR_BUFFER_OVERFLOW;
            CALL_FAIL (GENERAL_ERR, TEXT ("Insufficient szArchFile buffer"), dwRes);
            goto exit;
        }
    }

    if(!CopyFile(pszFile, szArchFile, FALSE))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT ("CopyFile"), dwRes);
        goto exit;
    }

    //
    // Read W2K MS TIF tags from the file
    //
    dwRes = GetW2kMsTiffTags(szArchFile, &msTags, bSentItems);
    if(ERROR_SUCCESS == dwRes)
    {
        //
        // Add new (XP) MS TIF tags to the file
        //
        if(!TiffAddMsTags(szArchFile, &msTags, bSentItems))
        {
            dwRes = GetLastError();
            CALL_FAIL (GENERAL_ERR, TEXT ("TiffAddMsTags"), dwRes);

            if(!DeleteFile(szArchFile))
            {
                CALL_FAIL (GENERAL_ERR, TEXT ("DeleteFile"), GetLastError());
            }
            goto exit;
        }
    }
    else if(ERROR_XP_TIF_FILE_FORMAT == dwRes)
    {
        //
        // The TIF file already has new (XP) TIF tags
        //
        dwRes = ERROR_SUCCESS;
    }
    else
    {
        //
        // The tiff file was not created by MS fax
        //
        if(!DeleteFile(szArchFile))
        {
            CALL_FAIL (GENERAL_ERR, TEXT ("DeleteFile"), GetLastError());
        }
    }

exit:    

    FreeMsTagInfo(&msTags);

    return dwRes;

} // ImportArchiveFile


DWORD 
WINAPI 
ImportArchiveFolder(
    LPVOID lpParameter   // thread data
)
/*++

Routine name : ImportArchiveFolder

Routine description:

    Imports fax (tif) files from the cstrImportFolder folder to the MS Fax archive.
    Returns ERROR_FILE_NOT_FOUND if the folder does not contain TIF files

Arguments:

    lpParameter   - [in] pointer to ImportFolderParam structure

Return Value:

    Standard Win32 error code

--*/
{
    ImportFolderParam* pParam = (ImportFolderParam*)lpParameter;

    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwError;
    int   nRes;
    WCHAR szFindMask[MAX_PATH] = {0};
    WCHAR szImportFile[MAX_PATH] = {0};
    WIN32_FIND_DATA findData = {0};
    HANDLE hFile = INVALID_HANDLE_VALUE;

    HANDLE hFax = NULL;
    PFAX_ARCHIVE_CONFIG pArchiveCfg = NULL;

    PSID   pUserSid   = NULL;
    WCHAR* pszUserSid = NULL;

    DWORDLONG dwlUniqueId;
    DWORD     dwFileCount = 0;
    DWORD     dwNotifyMsgID = 0; // Windows message id used for notification

    HMODULE hAdvapi32 = NULL;
    BOOL (*pfConvertSidToStringSid)(PSID, LPTSTR*) = NULL; // pointer to ConvertSidToStringSid()

    DBG_ENTER(TEXT("ImportFolderThread"), dwRes);

    if(!IsWinXPOS())
    {
        //
        // The Import functionality supported on XP OS only
        //
        ASSERTION_FAILURE;
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    //
    // ConvertSidToStringSid() Requires Windows 2000 or later, so we connect to it dynamically
    //
    hAdvapi32 = LoadLibrary(TEXT("advapi32.dll"));
    if(!hAdvapi32)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT ("LoadLibrary(advapi32.dll)"), dwRes);
        goto exit;
    }
    
    (FARPROC&)pfConvertSidToStringSid = GetProcAddress(hAdvapi32, "ConvertSidToStringSidW");
    if(!pfConvertSidToStringSid)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT ("GetProcAddress(ConvertSidToStringSid)"), dwRes);
        goto exit;
    }
    
    //
    // Compose find mask: path\*.tif
    //
    _snwprintf(szFindMask, MAX_PATH-1, TEXT("%s\\%s"), pParam->cszImportFolder, FAX_TIF_FILE_MASK);

    //
    // Count TIF files in the pParam->cszImportFolder folder
    //
    // Find the first tif file in the cstrImportFolder
    //
    hFile = FindFirstFile(szFindMask, &findData);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT ("FindFirstFile"), dwRes);
        goto exit;
    }

    dwFileCount = 1;
    for(;;)
    {
        //
        // Find Next File
        //
        if(!FindNextFile(hFile, &findData))
        {
            dwError = GetLastError();
            if(ERROR_NO_MORE_FILES != dwError)
            {
                dwRes = dwError;
                CALL_FAIL (GENERAL_ERR, TEXT ("FindNextFile"), dwRes);
            }
            break;
        }
        dwFileCount += 1;
    }

    if(INVALID_HANDLE_VALUE != hFile)
    {
        FindClose(hFile);
    }

    if(pParam->hImportDlg)
    {
        //
        // Set progress bar range
        //
        SendMessage(pParam->hImportDlg, WM_IMPORT_SET_FILE_COUNT, dwFileCount, 0);
    }


    //
    // Find the first tif file in the cstrImportFolder
    //
    hFile = FindFirstFile(szFindMask, &findData);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT ("FindFirstFile"), dwRes);
        goto exit;
    }

    //
    // Get fax server archive configuration
    //
    if(!FaxConnectFaxServer(NULL, &hFax))
    {
        dwRes = GetLastError();
        CALL_FAIL (RPC_ERR, TEXT ("FaxConnectFaxServer"), dwRes);
        goto exit;
    }

    //
    // Get pointer to the Client Console archive folder
    //
    if(theApp.m_pMainWnd)
    {   
        CClientConsoleDoc* pDoc = NULL;
        pDoc = (CClientConsoleDoc*)((CFrameWnd*)theApp.m_pMainWnd)->GetActiveDocument();
        if(pDoc)
        {
            //
            // find local fax server
            //
            CServerNode* pServer = NULL;
            pServer = pDoc->FindServerByName(NULL);
            if(pServer)
            {
                //
                // Get archive folder
                //
                CFolder* pFolder = NULL;
                pFolder = pServer->GetFolder(pParam->bSentItems ? FOLDER_TYPE_SENT_ITEMS : FOLDER_TYPE_INBOX);
                if(pFolder && pFolder->IsValid())
                {
                    dwNotifyMsgID = pServer->GetNotifyMsgID();
                }
            }
        }
    }

    //
    // Access check
    //
    DWORD dwAccessRights;
    if (!FaxAccessCheckEx(hFax, 
                          pParam->bSentItems ? FAX_ACCESS_MANAGE_OUT_ARCHIVE : FAX_ACCESS_MANAGE_IN_ARCHIVE, 
                          &dwAccessRights))
    {
        dwRes = GetLastError();
        CALL_FAIL (RPC_ERR, TEXT ("FaxAccessCheckEx"), dwRes);

        AlignedAfxMessageBox(IDS_IMPORT_NO_ACCESS, MB_OK | MB_ICONSTOP | MB_APPLMODAL);

        goto exit;
    }

    if(!FaxGetArchiveConfiguration(hFax, 
                                   pParam->bSentItems ? FAX_MESSAGE_FOLDER_SENTITEMS : FAX_MESSAGE_FOLDER_INBOX,
                                   &pArchiveCfg))
    {
        dwRes = GetLastError();
        CALL_FAIL (RPC_ERR, TEXT ("FaxGetArchiveConfiguration"), dwRes);
        goto exit;
    }
	
	BOOL bSameDir = FALSE;
	if ((dwRes = CheckToSeeIfSameDir((LPTSTR)pArchiveCfg->lpcstrFolder,(LPTSTR)pParam->cszImportFolder,&bSameDir)) != ERROR_SUCCESS)
	{
		CALL_FAIL (RPC_ERR, TEXT ("CheckToSeeIfSameDir"), dwRes);
		goto exit;
	}

	if (bSameDir)
	{
		AlignedAfxMessageBox(pParam->bSentItems ? IDS_IMPORT_SAME_DIR_SENT : IDS_IMPORT_SAME_DIR_INBOX 
			, MB_OK | MB_ICONSTOP | MB_APPLMODAL);
		goto exit;
	}

    if(pParam->bSentItems)
    {
        //
        // Get the user string SID for the outbound archive
        //
        pUserSid = GetCurrentThreadSID();
        if (!pUserSid)
        {
            dwRes = GetLastError ();
            CALL_FAIL (GENERAL_ERR, TEXT ("GetCurrentThreadSID"), dwRes);
            goto exit;
        }

        if (!pfConvertSidToStringSid(pUserSid, &pszUserSid))
        {
            dwRes = GetLastError ();
            CALL_FAIL (GENERAL_ERR, TEXT ("ConvertSidToStringSid"), dwRes);
            goto exit;
        }
    }

    while(!pParam->bCancel)
    {
        //
        // Compose full path 
        //
        _snwprintf(szImportFile, MAX_PATH-1, TEXT("%s\\%s\0"), pParam->cszImportFolder, findData.cFileName);

        nRes = IDOK;
        do
        {
            //
            // Import the file
            //
            dwError = ImportArchiveFile(szImportFile, 
                                        pArchiveCfg->lpcstrFolder, 
                                        pParam->bSentItems, 
                                        pszUserSid, 
                                        &dwlUniqueId);
            if(ERROR_SUCCESS != dwError)
            {
                CALL_FAIL (GENERAL_ERR, TEXT ("ImportArchiveFile"), dwRes);

                //
                // Popup "Cancel, Try Again, Continue" dialog
                //
                DWORD dwResId = IDS_IMPORT_ERROR; 
                WCHAR szFormat[MAX_PATH] = {0};
                WCHAR szMsg[MAX_PATH] = {0};

                if(ERROR_BAD_FORMAT == dwError)
                {
                    dwResId = IDS_IMPORT_BAD_FORMAT;
                }
                else if(ERROR_XP_TIF_WITH_WRONG_ARCHIVE_TYPE == dwError)
                {
                    dwResId = pParam->bSentItems ? IDS_IMPORT_FILE_NOT_SEND_TYPE : IDS_IMPORT_FILE_NOT_RECEIVE_TYPE;
                }

                if(LoadString(GetResourceHandle(), 
                              dwResId,
                              szFormat, 
                              ARR_SIZE(szFormat)))
                {
                    _snwprintf(szMsg, MAX_PATH-1, szFormat, findData.cFileName);

                    nRes = AlignedAfxMessageBox(szMsg, MB_CANCELTRYCONTINUE | MB_ICONSTOP | MB_APPLMODAL);  

                    if(IDCANCEL == nRes)
                    {
                        pParam->bCancel = TRUE;
                    }
                }
                else
                {
                    CALL_FAIL (GENERAL_ERR, TEXT ("LoadString(IDS_IMPORT_ERROR)"), GetLastError());
                }
            }
        }
        while(nRes == IDTRYAGAIN);

        if(dwNotifyMsgID)
        {
            //
            // Add the message to the archive folder
            // We simulate the server notification handled by the application main thread
            // The notification handler should free the event data
            //
            FAX_EVENT_EX* pEvent = (FAX_EVENT_EX*)MemAlloc(sizeof(FAX_EVENT_EX));
            if(!pEvent)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                CALL_FAIL (GENERAL_ERR, TEXT ("MemAlloc"), dwRes);
                goto exit;
            }
            ZeroMemory(pEvent, sizeof(FAX_EVENT_EX));

            pEvent->dwSizeOfStruct = sizeof(FAX_EVENT_EX);
            pEvent->EventType = pParam->bSentItems ? FAX_EVENT_TYPE_OUT_ARCHIVE : FAX_EVENT_TYPE_IN_ARCHIVE;
            pEvent->EventInfo.JobInfo.Type = FAX_JOB_EVENT_TYPE_ADDED;
            pEvent->EventInfo.JobInfo.dwlMessageId = dwlUniqueId;

            theApp.m_pMainWnd->SendMessage(dwNotifyMsgID, 0, (LPARAM)pEvent);
        }

        if(pParam->hImportDlg)
        {
            //
            // Increment progress bar
            //
            SendMessage(pParam->hImportDlg, WM_IMPORT_PROGRESS_INC, 0, 0);
        }

        //
        // Find Next File
        //
        if(!FindNextFile(hFile, &findData))
        {
            dwError = GetLastError();
            if(ERROR_NO_MORE_FILES != dwError)
            {
                dwRes = dwError;
                CALL_FAIL (GENERAL_ERR, TEXT ("FindNextFile"), dwRes);
            }
            break;
        }
    } // while

    //
    // Notify the fax service
    //
    if(!FaxRefreshArchive(hFax, 
                          pParam->bSentItems ? FAX_MESSAGE_FOLDER_SENTITEMS : FAX_MESSAGE_FOLDER_INBOX))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT ("FaxArchiveMessageAdded"), dwRes);
    }


exit:

    if(pParam->hImportDlg)
    {
        //
        // Close the Progress dialog
        //
        SendMessage(pParam->hImportDlg, WM_CLOSE, 0, 0);
    }

    if(0 == dwFileCount)
    {
        //
        // The folder does not contain faxes
        //
        AlignedAfxMessageBox(IDS_IMPORT_EMPTY_FOLDER, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
    }

    if(INVALID_HANDLE_VALUE != hFile)
    {
        FindClose(hFile);
    }

    if(pArchiveCfg)
    {
        FaxFreeBuffer(pArchiveCfg);
    }

    if(hFax)
    {
        FaxClose(hFax);
    }

    if(pUserSid)
    {
        MemFree(pUserSid);
    }

    if(pszUserSid)
    {
        LocalFree(pszUserSid);
    }

    if(hAdvapi32)
    {
        FreeLibrary(hAdvapi32);
    }

    return dwRes;

} // ImportArchiveFolder


INT_PTR 
CALLBACK 
ImportDlgProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
)
/*++

Routine description:

    Import fax dialog procedure

Arguments:

  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter

Return Value:

    return TRUE if it processed the message

--*/

{
    static ImportFolderParam* pIpmParam = NULL;
    static DWORD dwFileCount;   // The number of the files to import
    static DWORD dwCurrentFile; // The number of the currently imported file

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            {
                HANDLE hImportThread = NULL;
                pIpmParam = (ImportFolderParam*)lParam;
                TCHAR szFolder[MAX_PATH] = {0};

                DBG_ENTER(TEXT("ImportDlgProc(WM_INITDIALOG)"));


                dwFileCount = 0;
                dwCurrentFile = 0;

                //
                // Set import folder name
                //
                if(LoadString(GetResourceHandle(), 
                              pIpmParam->bSentItems ? IDS_IMPORT_TO_SENT_ITEMS : IDS_IMPORT_TO_INBOX,
                              szFolder, 
                              ARR_SIZE(szFolder)))
                {
                    SetDlgItemText(hwndDlg, IDC_PROGRESS_TITLE, szFolder);
                }
                else
                {
                    CALL_FAIL (GENERAL_ERR, TEXT ("LoadString() for IDC_PROGRESS_TITLE"), GetLastError());
                }

                pIpmParam->hImportDlg   = hwndDlg;

                hImportThread = CreateThread(NULL,                // SD
                                             0,                   // initial stack size
                                             ImportArchiveFolder, // thread function
                                             (LPVOID)pIpmParam,   // thread argument
                                             0,                   // creation option
                                             NULL);               // thread identifier
                if(!hImportThread)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT ("CreateThread"), GetLastError());
                }
                else
                {
                    CloseHandle(hImportThread);
                }
                return TRUE;
            }

        case WM_IMPORT_PROGRESS_INC:
            {
                //
                // Increment progress bar
                //
                SendDlgItemMessage(hwndDlg, IDC_PROGRESS_BAR, PBM_STEPIT, 0, 0);

                //
                // Compose and set currently imported fax number
                //
                ++dwCurrentFile;

                TCHAR szFormat[MAX_PATH] = {0};
                TCHAR szText[MAX_PATH] = {0};
                DWORD dwParam[2];

                DBG_ENTER(TEXT("ImportDlgProc(WM_IMPORT_PROGRESS_INC)"));


                dwParam[0] = dwCurrentFile;
                dwParam[1] = dwFileCount;

                if(!LoadString(GetResourceHandle(), 
                               IDS_PROGRESS_NUMBER,
                               szFormat, 
                               ARR_SIZE(szFormat)))
                {
                    CALL_FAIL (GENERAL_ERR, TEXT ("LoadString(IDS_PROGRESS_NUMBER)"), GetLastError());
                    return TRUE;
                }

                if(FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                (LPCVOID)szFormat,
                                0,
                                0,
                                szText,
                                ARR_SIZE(szText),
                                (va_list*)dwParam))
                {
                    SetDlgItemText(hwndDlg, IDC_PROGRESS_NUMBER, szText);
                }

                return TRUE;
            }
        case WM_IMPORT_SET_FILE_COUNT:
            //
            // Set the pange and step of the proggress bar
            //
            dwFileCount = wParam;
            dwCurrentFile = 1;

            SendDlgItemMessage(hwndDlg, IDC_PROGRESS_BAR, PBM_SETRANGE32, 0, dwFileCount);
            SendDlgItemMessage(hwndDlg, IDC_PROGRESS_BAR, PBM_SETSTEP, 1, 0);
            return TRUE;

        case WM_CLOSE:

            EndDialog(hwndDlg, IDCANCEL);

            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDCANCEL:
                        
                    //
                    // Mark cancel, don't close the dialog
                    //
                    pIpmParam->bCancel = TRUE;
                    EnableWindow(GetDlgItem(hwndDlg, IDCANCEL), FALSE);

                    return TRUE;
            } 

            break;


    } // switch ( uMsg )

    return FALSE;

} // ImportDlgProc


DWORD 
ImportArchiveFolderUI(
    LPCWSTR cstrImportFolder, 
    BOOL    bSentItems,
    HWND    hWnd
)
/*++

Routine name : ImportArchiveFolderUI

Routine description:

    Opens the Import Progress dialog

Arguments:

    cstrImportFolder   - [in]  Import folder name
    bSentItems         - [in]  TRUE if the folder is the sent archive, FALSE if it is receive one
    hWnd               - [in]  Parent window

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;

    ImportFolderParam impParam = {0};
    impParam.cszImportFolder   = cstrImportFolder;
    impParam.bSentItems        = bSentItems;

    DBG_ENTER(TEXT("ImportArchiveFolderUI"), dwRes);

    DialogBoxParam(GetResourceHandle(),               // handle to module
                   MAKEINTRESOURCE(IDD_FAX_PROGRESS), // dialog box template
                   hWnd,                              // handle to owner window
                   ImportDlgProc,                     // dialog box procedure
                   (LPARAM)&impParam);                // initialization value

    return dwRes;

} // ImportArchiveFolderUI


BOOL
IsFaxArchive(
    WCHAR* szFolder
)
/*++

Routine name : IsFaxArchive

Routine description:

    Determine if the folder contains at least one TIF file

Arguments:

    szFolder   - [in]  folder name

Return Value:

    TRUE if if the folder contains at least one TIF file
    FALSE otherwise

--*/
{
    WCHAR szFindMask[MAX_PATH] = {0};
    WIN32_FIND_DATA findData = {0};
    HANDLE hFile = INVALID_HANDLE_VALUE;

    DBG_ENTER(TEXT("IsFaxArchive"));

    //
    // Compose find mask: path\*.tif
    //
    _snwprintf(szFindMask, MAX_PATH-1, TEXT("%s\\%s"), szFolder, FAX_TIF_FILE_MASK);

    //
    // Find the first tif file in the cstrImportFolder
    //
    hFile = FindFirstFile(szFindMask, &findData);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("FindFirstFile"), GetLastError());
        return FALSE;
    }

    FindClose(hFile);
    return TRUE;
}

INT_PTR 
CALLBACK 
ImportInfoDlgProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
)
/*++

Routine description:

    Import information fax dialog procedure

Arguments:

  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter

Return Value:

    return TRUE if it processed the message

--*/

{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            //
            // Set focus on the OK button
            //
            SetFocus(GetDlgItem(hwndDlg, IDOK));
            return FALSE;

        case WM_NOTIFY :
            {
                LPNMHDR lpnm = (LPNMHDR) lParam;
                if(((NM_CLICK == lpnm->code) || (NM_RETURN == lpnm->code)) && 
                   lpnm->idFrom == IDC_IMPORT_HELP_LINK)
                {
                    //
                    // Display import help
                    //
                    HtmlHelpTopic(hwndDlg, FAX_HELP_IMPORT);
                    return TRUE;
                }
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hwndDlg, IDOK);
                    return TRUE;
            }                
            break;
    }
    return FALSE;
} // ImportInfoDlgProc

DWORD 
DetectImportFiles()
/*++

Routine name : DetectImportFiles

Routine description:

    Determine if the system has W2K fax archives.
    If yes warning dialog will be displayed for the first time.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    HKEY  hRegKey;
    DWORD dwImportWrn = 0; // 1 if the import warning has been displayed

    WCHAR* pszInbox = NULL;
    WCHAR* pszSentItems = NULL;
    DWORD  dwSize = 0;
    BOOL   bHaveFax = FALSE; // TRUE if the archives contain at least one TIF file

    DBG_ENTER(TEXT("DetectImportFiles"), dwRes);

    if(!IsWinXPOS())
    {
        return dwRes;
    }

    //
    // Check if the Import warning has been displayed
    //
    if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_SETUP, TRUE, KEY_ALL_ACCESS)))
    {
        dwImportWrn = GetRegistryDword(hRegKey, REGVAL_IMPORT_INFO);

        if(!dwImportWrn)
        {
            SetRegistryDword(hRegKey, REGVAL_IMPORT_INFO, TRUE);
        }
            
        RegCloseKey(hRegKey);
    }
    else
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("OpenRegistryKey"), GetLastError());
    }

    if(dwImportWrn)
    {
        //
        // Import warning has been displayed
        //
        return dwRes;
    }

    //
    // Read W2K archives location
    //
    if (!(hRegKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, TRUE, KEY_QUERY_VALUE)))
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("OpenRegistryKey"), GetLastError());
        return dwRes;
    }

    pszInbox = GetRegistryStringMultiSz(hRegKey, REGVAL_W2K_INBOX, NULL, &dwSize);
    pszSentItems = GetRegistryString(hRegKey, REGVAL_W2K_SENT_ITEMS, NULL);
        
    RegCloseKey(hRegKey);

    //
    // Determine if the archives have at least one TIF file
    //
    bHaveFax = IsFaxArchive(pszSentItems);

    WCHAR* pszFolder = pszInbox;
    while(!bHaveFax && pszFolder && *pszFolder)
    {
        //
        // Walk though the multiline pszInbox string
        //
        bHaveFax = IsFaxArchive(pszFolder);

        pszFolder = _wcsninc(pszFolder, wcslen(pszFolder)+1);
    }

    MemFree(pszInbox);
    MemFree(pszSentItems);

    if(bHaveFax)
    {
        if(!LinkWindow_RegisterClass())
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (GENERAL_ERR, TEXT ("LinkWindow_RegisterClass"), dwRes);
            return dwRes;
        }

        DialogBoxParam(GetResourceHandle(),               // handle to module
                       MAKEINTRESOURCE(IDD_IMPORT_INFO),  // dialog box template
                       theApp.m_pMainWnd->m_hWnd,         // handle to owner window
                       ImportInfoDlgProc,                 // dialog box procedure
                       NULL);                             // initialization value

        LinkWindow_UnregisterClass(theApp.m_hInstance);
    }

    return dwRes;
}

#endif //UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\inboxdetailspg.h ===
#if !defined(AFX_INBOXDETAILSPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_)
#define AFX_INBOXDETAILSPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// InboxDetailsPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CInboxDetailsPg dialog

class CInboxDetailsPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(CInboxDetailsPg)

// Construction
public:
	CInboxDetailsPg(CFaxMsg* pMsg);
	~CInboxDetailsPg();

// Dialog Data
	//{{AFX_DATA(CInboxDetailsPg)
	enum { IDD = IDD_INBOX_DETAILS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CInboxDetailsPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    CInboxDetailsPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(CInboxDetailsPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INBOXDETAILSPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\inboxgeneralpg.cpp ===
// InboxGeneralPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     40

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_STATUS,                   IDC_STATUS_VALUE,
    MSG_VIEW_ITEM_NUM_PAGES,                IDC_PAGES_VALUE,
    MSG_VIEW_ITEM_SIZE,                     IDC_SIZE_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_START_TIME,  IDC_START_TIME_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_END_TIME,    IDC_END_TIME_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_DURATION,    IDC_DURATION_VALUE
};

/////////////////////////////////////////////////////////////////////////////
// CInboxGeneralPg property page

IMPLEMENT_DYNCREATE(CInboxGeneralPg, CMsgPropertyPg)

CInboxGeneralPg::CInboxGeneralPg(
    CFaxMsg* pMsg     // pointer to CArchiveMsg
): 
    CMsgPropertyPg(CInboxGeneralPg::IDD, pMsg)
{
}

CInboxGeneralPg::~CInboxGeneralPg()
{
}

void CInboxGeneralPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInboxGeneralPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInboxGeneralPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(CInboxGeneralPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInboxGeneralPg message handlers

BOOL 
CInboxGeneralPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CInboxGeneralPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\incomingdetailspg.cpp ===
// IncomingDetailsPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     51

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_CALLER_ID,               IDC_CALLER_ID_VALUE,
    MSG_VIEW_ITEM_ROUTING_INFO,            IDC_ROUTING_INFO_VALUE,
    MSG_VIEW_ITEM_RETRIES,                 IDC_RETRIES_VALUE,
    MSG_VIEW_ITEM_CSID,                    IDC_CSID_VALUE,
    MSG_VIEW_ITEM_TSID,                    IDC_TSID_VALUE,
    MSG_VIEW_ITEM_DEVICE,                  IDC_DEVICE_VALUE,
    MSG_VIEW_ITEM_ID,                      IDC_JOB_ID_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_END_TIME,   IDC_END_TIME_VALUE,
    MSG_VIEW_ITEM_SEND_TIME,               IDC_TRANSMISSION_TIME_VALUE,
	MSG_VIEW_ITEM_SERVER,				   IDC_SERVER_VALUE
};

/////////////////////////////////////////////////////////////////////////////
// CIncomingDetailsPg property page

IMPLEMENT_DYNCREATE(CIncomingDetailsPg, CMsgPropertyPg)

CIncomingDetailsPg::CIncomingDetailsPg(
    CFaxMsg* pMsg     // pointer to CJob
) : 
    CMsgPropertyPg(CIncomingDetailsPg::IDD, pMsg)
{
}

CIncomingDetailsPg::~CIncomingDetailsPg()
{
}

void CIncomingDetailsPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIncomingDetailsPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CIncomingDetailsPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(CIncomingDetailsPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIncomingDetailsPg message handlers

BOOL 
CIncomingDetailsPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CIncomingDetailsPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\inboxgeneralpg.h ===
#if !defined(AFX_INBOXGENERALPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_)
#define AFX_INBOXGENERALPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// InboxGeneralPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CInboxGeneralPg dialog

class CInboxGeneralPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(CInboxGeneralPg)

// Construction
public:
	CInboxGeneralPg(CFaxMsg* pMsg);
	~CInboxGeneralPg();

// Dialog Data
	//{{AFX_DATA(CInboxGeneralPg)
	enum { IDD = IDD_INBOX_GENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CInboxGeneralPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    CInboxGeneralPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(CInboxGeneralPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INBOXGENERALPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\incominggeneralpg.cpp ===
// IncomingGeneralPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     41

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_NUM_PAGES,               IDC_PAGES_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_START_TIME, IDC_START_TIME_VALUE,
    MSG_VIEW_ITEM_SIZE,                    IDC_SIZE_VALUE,
    MSG_VIEW_ITEM_STATUS,                  IDC_STATUS_VALUE,
    MSG_VIEW_ITEM_EXTENDED_STATUS,         IDC_EXTENDED_STATUS_VALUE,
    MSG_VIEW_ITEM_CURRENT_PAGE,            IDC_CURRENT_PAGE_VALUE
};

/////////////////////////////////////////////////////////////////////////////
// CIncomingGeneralPg property page

IMPLEMENT_DYNCREATE(CIncomingGeneralPg, CMsgPropertyPg)

CIncomingGeneralPg::CIncomingGeneralPg(
    CFaxMsg* pMsg     // pointer to CJob
) : 
    CMsgPropertyPg(CIncomingGeneralPg::IDD, pMsg)
{
}

CIncomingGeneralPg::~CIncomingGeneralPg()
{
}

void CIncomingGeneralPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIncomingGeneralPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CIncomingGeneralPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(CIncomingGeneralPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIncomingGeneralPg message handlers

BOOL 
CIncomingGeneralPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CIncomingGeneralPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\incomingdetailspg.h ===
#if !defined(AFX_INCOMINGDETAILSPG_H__FC84E35A_631F_4AA1_985D_327E0A14B36E__INCLUDED_)
#define AFX_INCOMINGDETAILSPG_H__FC84E35A_631F_4AA1_985D_327E0A14B36E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// IncomingDetailsPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CIncomingDetailsPg dialog

class CIncomingDetailsPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(CIncomingDetailsPg)

// Construction
public:
	CIncomingDetailsPg(CFaxMsg* pMsg);
	~CIncomingDetailsPg();

// Dialog Data
	//{{AFX_DATA(CIncomingDetailsPg)
	enum { IDD = IDD_INCOMING_DETAILS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIncomingDetailsPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    CIncomingDetailsPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(CIncomingDetailsPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INCOMINGDETAILSPG_H__FC84E35A_631F_4AA1_985D_327E0A14B36E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\incominggeneralpg.h ===
#if !defined(AFX_INCOMINGGENERALPG_H__FC84E35A_631F_4AA1_985D_327E0A14B36E__INCLUDED_)
#define AFX_INCOMINGGENERALPG_H__FC84E35A_631F_4AA1_985D_327E0A14B36E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// IncomingGeneralPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CIncomingGeneralPg dialog

class CIncomingGeneralPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(CIncomingGeneralPg)

// Construction
public:
	CIncomingGeneralPg(CFaxMsg* pMsg);
	~CIncomingGeneralPg();

// Dialog Data
	//{{AFX_DATA(CIncomingGeneralPg)
	enum { IDD = IDD_INCOMING_GENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIncomingGeneralPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    CIncomingGeneralPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(CIncomingGeneralPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INCOMINGGENERALPG_H__FC84E35A_631F_4AA1_985D_327E0A14B36E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\itempropsheet.h ===
#if !defined(AFX_ITEMPROPSHEET_H__CCF76858_9A54_4AB7_8DBF_BD9815F06F53__INCLUDED_)
#define AFX_ITEMPROPSHEET_H__CCF76858_9A54_4AB7_8DBF_BD9815F06F53__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ItemPropSheet.h : header file
//

struct TMsgPageInfo
{
    MsgViewItemType itemType;       // job type
    DWORD           dwValueResId;   // item value control id
};

#define WM_SET_SHEET_FOCUS WM_APP+4


/////////////////////////////////////////////////////////////////////////////
// CItemPropSheet

class CItemPropSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CItemPropSheet)

// Construction
public:
	CItemPropSheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

    DWORD Init(CFolder* pFolder, CFaxMsg* pMsg);

    DWORD GetLastError() { return m_dwLastError; }
    void  SetLastError(DWORD dwError) { m_dwLastError = dwError; }

// Attributes
private:

    #define PROP_SHEET_PAGES_NUM  4

    CPropertyPage* m_pPages[PROP_SHEET_PAGES_NUM];

    DWORD m_dwLastError;

    CFaxMsg* m_pMsg;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CItemPropSheet)
	public:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CItemPropSheet();

	// Generated message map functions

protected:
	//{{AFX_MSG(CItemPropSheet)
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
    afx_msg LONG OnSetSheetFocus(UINT wParam, LONG lParam);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg LONG OnHelp(UINT wParam, LONG lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ITEMPROPSHEET_H__CCF76858_9A54_4AB7_8DBF_BD9815F06F53__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\job.h ===
// Job.h: interface for the CJob class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_JOB_H__0021D6D0_519B_42BA_85C7_8C9E600E408A__INCLUDED_)
#define AFX_JOB_H__0021D6D0_519B_42BA_85C7_8C9E600E408A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//
// Possible operations on a job / message
//
enum
{
    FAX_JOB_OP_PROPERTIES = 0x0080,
    FAX_JOB_OP_ALL        = FAX_JOB_OP_VIEW        | FAX_JOB_OP_PAUSE          | 
                            FAX_JOB_OP_RESUME      | FAX_JOB_OP_RESTART        | 
                            FAX_JOB_OP_DELETE      | FAX_JOB_OP_RECIPIENT_INFO | 
                            FAX_JOB_OP_SENDER_INFO | FAX_JOB_OP_PROPERTIES,
    FAX_JOB_OP_NUMBER     = 8  // The number of possible operations
};


class CJob : public CFaxMsg
{
public:

    DECLARE_DYNCREATE(CJob)

    //
    // Init / shutdown:
    //
    CJob () {}
    virtual ~CJob() {}


    DWORD Init (PFAX_JOB_ENTRY_EX pJob, CServerNode* pServer);
    DWORD UpdateStatus (PFAX_JOB_STATUS pStatus);
    BOOL  IsNewStatus (PFAX_JOB_STATUS pStatus);

    DWORD Copy(const CJob& other);

    //
    // Operations:
    //
    DWORD GetTiff (CString &cstrTiffLocation) const;
    DWORD Pause ()
        { return DoJobOperation (FAX_JOB_OP_PAUSE); }

    DWORD Resume ()
        { return DoJobOperation (FAX_JOB_OP_RESUME); }

    DWORD Restart ()
        { return DoJobOperation (FAX_JOB_OP_RESTART); }

    DWORD Delete ()
        { return DoJobOperation (FAX_JOB_OP_DELETE); }
    //
    // Item retrival:
    //
        
    const JobStatusType GetStatus () const;

    const CString &GetExtendedStatusString () const  
        { ASSERT (m_bValid); return m_cstrExtendedStatus; }

    const DWORD GetCurrentPage () const
        { ASSERT (m_bValid); return m_dwCurrentPage; }

    const CFaxTime &GetScheduleTime () const    
        { ASSERT (m_bValid); return m_tmScheduleTime; }


private:

    DWORD DoJobOperation (DWORD dwJobOp);

    DWORD     m_dwCurrentPage; 

    CString   m_cstrExtendedStatus; 

    CFaxTime  m_tmScheduleTime; 
};


#endif // !defined(AFX_JOB_H__0021D6D0_519B_42BA_85C7_8C9E600E408A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\leftview.cpp ===
// LeftView.cpp : implementation of the CLeftView class
//

#include "stdafx.h"
#define __FILE_ID__     4

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CClientConsoleApp theApp;

CImageList  CLeftView::m_ImageList;

/////////////////////////////////////////////////////////////////////////////
// CLeftView

IMPLEMENT_DYNCREATE(CLeftView, CTreeView)

BEGIN_MESSAGE_MAP(CLeftView, CTreeView)
    //{{AFX_MSG_MAP(CLeftView)
    ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnTreeSelChanged)
    ON_NOTIFY_REFLECT(NM_RCLICK, OnRightClick)
    ON_WM_CHAR( )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLeftView construction/destruction

CLeftView::CLeftView() :
    m_treeitemRoot (NULL),
    m_pCurrentView(NULL),
    m_iLastActivityStringId(0)
{}

CLeftView::~CLeftView()
{}

BOOL CLeftView::PreCreateWindow(CREATESTRUCT& cs)
{
    return CTreeView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CLeftView drawing

void CLeftView::OnDraw(CDC* pDC)
{
    CClientConsoleDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
}


DWORD 
CLeftView::RefreshImageList ()
{
    HIMAGELIST himl = NULL;
    DWORD dwRes = ERROR_SUCCESS;

    DBG_ENTER(TEXT("CLeftView::RefreshImageList"), dwRes);
    //
    // Build and load the image list
    //
    himl = m_ImageList.Detach();
    if (himl)
    {
        ImageList_Destroy(himl);
    }
    himl = ImageList_LoadImage(AfxGetResourceHandle(), 
                               MAKEINTRESOURCE(IDB_TREE_IMAGES), 
                               16, 
                               0,
                               RGB(0, 255, 0), 
                               IMAGE_BITMAP, 
                               LR_LOADTRANSPARENT | LR_CREATEDIBSECTION);
    if (NULL == himl)
    {
        dwRes = GetLastError();
        CALL_FAIL (RESOURCE_ERR, TEXT("ImageList_LoadImage"), dwRes);
    }
    else
    {
        m_ImageList.Attach (himl);
    }
    GetTreeCtrl().SetImageList (&m_ImageList, TVSIL_NORMAL);
    return dwRes;
}   // CLeftView::RefreshImageList

void CLeftView::OnInitialUpdate()
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CLeftView::OnInitialUpdate"));

    CTreeView::OnInitialUpdate();
 
    CClientConsoleDoc* pDoc = GetDocument();
    if(!pDoc)
    {
        ASSERTION(pDoc);
        PopupError (ERROR_GEN_FAILURE);
        return;
    }
    
    //
    // Set the style of the tree 
    //
    CTreeCtrl &Tree = GetTreeCtrl();
    LONG lWnd = GetWindowLong (Tree.m_hWnd, GWL_STYLE);
    if (!lWnd)
    {
        dwRes = GetLastError ();
        CALL_FAIL (WINDOW_ERR, TEXT("GetWindowLong"), dwRes);
        PopupError (dwRes);
        return;
    }
    lWnd |= (TVS_HASLINES           |   // Lines between node
             TVS_HASBUTTONS         |   // Tree has +/- (expand/collapse) buttons
             TVS_INFOTIP            |   // Allow tooltip messages
             TVS_LINESATROOT        |   // Root object has lines
             TVS_SHOWSELALWAYS          // Always show selected node
            );
    if (!SetWindowLong (Tree.m_hWnd, GWL_STYLE, lWnd))
    {
        dwRes = GetLastError ();
        CALL_FAIL (WINDOW_ERR, TEXT("SetWindowLong"), dwRes);
        PopupError (dwRes);
        return;
    }
    RefreshImageList();
    //
    // Create the 4 views of the 4 different folder types.
    //
    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        //  Shutdown in progress
        //
        return;
    }

    dwRes = pFrm->CreateFolderViews (GetDocument());
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CMainFrame::CreateFolderViews"), dwRes);
        PopupError (dwRes);
        return;
    }

    //
    // Build root node
    //
    CString cstrNodeName;
    dwRes = LoadResourceString (cstrNodeName, IDS_TREE_ROOT_NAME);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("LoadResourceString"), dwRes);
        PopupError (dwRes);
        return;
    }

    CString& cstrSingleServer =  pDoc->GetSingleServerName();
    if(!cstrSingleServer.IsEmpty())
    {
        CString cstrRoot;
        try
        {
            cstrRoot.Format(TEXT("%s (%s)"), cstrNodeName, cstrSingleServer);
            cstrNodeName = cstrRoot;
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("CString operation"), dwRes);
            PopupError (dwRes);
            return;
        }
    }

    m_treeitemRoot = Tree.InsertItem (cstrNodeName);
    if (NULL == m_treeitemRoot)
    {
        dwRes = ERROR_GEN_FAILURE;
        CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::InsertItem"), dwRes);
        PopupError (dwRes);
        return;
    }
    Tree.SetItemImage (m_treeitemRoot, TREE_IMAGE_ROOT, TREE_IMAGE_ROOT);
    //
    // Set the item data of the root to NULL.
    //
    Tree.SetItemData  (m_treeitemRoot, 0);


    HTREEITEM hItemIncoming;
    HTREEITEM hItemInbox;
    HTREEITEM hItemOutbox;
    HTREEITEM hItemSentItems;

    //
    // Add Incoming
    //
    dwRes = SyncFolderNode (m_treeitemRoot,                  // Parent node
                            TRUE,                            // Visible?
                            IDS_TREE_NODE_INCOMING,          // node string
                            TVI_LAST,                        // Insert after (= TVI_FIRST)
                            TREE_IMAGE_INCOMING,             // Normal icon
                            TREE_IMAGE_INCOMING,             // Selected icon
                            (LPARAM)pFrm->GetIncomingView(), // Node's data
                            hItemIncoming);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("SyncFolderNode"), dwRes);
        PopupError (dwRes);
        return;
    }

    //
    // Add Inbox
    //
    dwRes = SyncFolderNode (m_treeitemRoot,                // Parent node
                            TRUE,                          // Visible?
                            IDS_TREE_NODE_INBOX,           // node string
                            TVI_LAST,                      // Insert after (= TVI_FIRST)
                            TREE_IMAGE_INBOX,              // Normal icon
                            TREE_IMAGE_INBOX,              // Selected icon
                            (LPARAM)pFrm->GetInboxView(),  // Node's data
                            hItemInbox);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("SyncFolderNode"), dwRes);
        PopupError (dwRes);
        return;
    }

    //
    // Add Outbox
    //
    dwRes = SyncFolderNode (m_treeitemRoot,                 // Parent node
                            TRUE,                           // Visible?
                            IDS_TREE_NODE_OUTBOX,           // node string
                            TVI_LAST,                       // Insert after (= TVI_FIRST)
                            TREE_IMAGE_OUTBOX,              // Normal icon
                            TREE_IMAGE_OUTBOX,              // Selected icon
                            (LPARAM)pFrm->GetOutboxView(),  // Node's data
                            hItemOutbox);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("SyncFolderNode"), dwRes);
        PopupError (dwRes);
        return;
    }

    //
    // Add SentItems
    //
    dwRes = SyncFolderNode (m_treeitemRoot,                 // Parent node
                            TRUE,                           // Visible?
                            IDS_TREE_NODE_SENT_ITEMS,       // node string
                            TVI_LAST,                       // Insert after (= TVI_FIRST)
                            TREE_IMAGE_INBOX,               // Normal icon
                            TREE_IMAGE_INBOX,               // Selected icon
                            (LPARAM)pFrm->GetSentItemsView(),// Node's data
                            hItemSentItems);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("SyncFolderNode"), dwRes);
        PopupError (dwRes);
        return;
    }
    //
    // Expand the root to expose all the servers
    //
    Tree.Expand (m_treeitemRoot, TVE_EXPAND);    


    dwRes = pDoc->RefreshServersList();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CClientConsoleDoc::RefreshServersList"), dwRes);
        PopupError (dwRes);
        return;
    }


    if(theApp.IsCmdLineOpenFolder())
    {
        //
        // select folder according to command line
        //
        SelectFolder (theApp.GetCmdLineFolderType());
    }

#ifdef UNICODE
    DetectImportFiles();
#endif // UNICODE
}   // CLeftView::OnInitialUpdate


VOID
CLeftView::SelectFolder (
    FolderType type
)
{
    DBG_ENTER(TEXT("CLeftView::SelectFolder"), TEXT("type=%ld"), type);
    CFolderListView *pView = NULL;
    INT iNodeStringResource;
    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        //  Shutdown in progress
        //
        return;
    }
    switch(type)
    {
        case FOLDER_TYPE_INCOMING:
            iNodeStringResource = IDS_TREE_NODE_INCOMING;
            pView = pFrm->GetIncomingView();
            break;
        case FOLDER_TYPE_INBOX:
            iNodeStringResource = IDS_TREE_NODE_INBOX;
            pView = pFrm->GetInboxView();
            break;
        case FOLDER_TYPE_OUTBOX:
            iNodeStringResource = IDS_TREE_NODE_OUTBOX;
            pView = pFrm->GetOutboxView();
            break;
        case FOLDER_TYPE_SENT_ITEMS:
            iNodeStringResource = IDS_TREE_NODE_SENT_ITEMS;
            pView = pFrm->GetSentItemsView();
            break;
        default:
            ASSERTION_FAILURE
            return;
    }

    HTREEITEM hItem;
    CString cstrNodeName;
    //
    // Retrieve node's title string
    //
    if (ERROR_SUCCESS != LoadResourceString (cstrNodeName, iNodeStringResource))
    {
        return;
    }

    hItem = FindNode (GetTreeCtrl().GetRootItem(), cstrNodeName);
    if (!hItem)
    {
        ASSERTION_FAILURE
        return;
    }
    if(!GetTreeCtrl().Select(hItem, TVGN_CARET))
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::Select"), ERROR_CAN_NOT_COMPLETE);
    }

    //
    // Force data change while handling this message, otherwise the current view is not changed until the 
    // notification message reaches the left view.
    //
    ASSERTION (pView);
    NM_TREEVIEW nmtv = {0};
    LRESULT     lr;
    nmtv.itemNew.lParam = (LPARAM)pView;
    OnTreeSelChanged ((NMHDR*)&nmtv, &lr);
}   // CLeftView::SelectFolder

/////////////////////////////////////////////////////////////////////////////
// CLeftView diagnostics

#ifdef _DEBUG
void CLeftView::AssertValid() const
{
    CTreeView::AssertValid();
}

void CLeftView::Dump(CDumpContext& dc) const
{
    CTreeView::Dump(dc);
}

CClientConsoleDoc* CLeftView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CClientConsoleDoc)));
    return (CClientConsoleDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CLeftView message handlers

HTREEITEM
CLeftView::FindNode (
    HTREEITEM hRoot,
    CString &cstrNodeString
)
/*++

Routine name : CLeftView::FindNode

Routine description:

    Finds a node in the tree that has a specific string

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    hRoot            [in] - Root of search: all direct sons (only) of root will be searched
    cstrNodeString   [in] - String to look for

Return Value:

    Handle to found tree item, NULL if not found

--*/
{
    CTreeCtrl &refTree = GetTreeCtrl();
    for (HTREEITEM hChildItem = refTree.GetChildItem (hRoot); 
         hChildItem != NULL;
         hChildItem = refTree.GetNextSiblingItem (hChildItem))
    {
        if (cstrNodeString == refTree.GetItemText (hChildItem))
        {
            //
            // Match found
            //
            return hChildItem;
        }
    }
    return NULL;
}   // CLeftView::FindNode

DWORD 
CLeftView::SyncFolderNode (
    HTREEITEM       hParent,
    BOOL            bVisible,
    int             iNodeStringResource,
    HTREEITEM       hInsertAfter,
    TreeIconType    iconNormal,
    TreeIconType    iconSelected,
    LPARAM          lparamNodeData,
    HTREEITEM      &hNode
)
/*++

Routine name : CLeftView::SyncFolderNode

Routine description:

    Synchronizes a tree folder

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    hParent               [in]     - Parent node
    bVisible              [in]     - Should the node be visible?
    iNodeStringResource   [in]     - Resource of node's title string
    hInsertAfter          [in]     - Sibling to insert after (must exist)
    iconNormal            [in]     - Icon of normal image
    iconSelected          [in]     - Icon of selected image
    lparamNodeData        [in]     - Node assigned data
    hNode                 [out]    - Node tree item (changed only if node had to be created).
                                     Set to NULL if node was removed.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::SyncFolderNode"), dwRes);

    CString cstrNodeName;
    //
    // Retrieve node's title string
    //
    dwRes = LoadResourceString (cstrNodeName, iNodeStringResource);
    if (ERROR_SUCCESS != dwRes)
    {
        return dwRes;
    }
    CTreeCtrl &refTree = GetTreeCtrl();
    hNode = FindNode (hParent, cstrNodeName);
    if (!bVisible)
    {
        //
        // The node should not be visible at all
        //
        if (hNode)
        {
            if (refTree.GetSelectedItem () == hNode)
            {
                //
                // If the node is currently selected, select its parent
                //
                refTree.SelectItem (hParent);
            }
            //
            // Remove node
            //
            if (!refTree.DeleteItem (hNode))
            {
                dwRes = ERROR_GEN_FAILURE;
                CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::DeleteItem"), dwRes);
                return dwRes;
            }
        }
        hNode = NULL;
    }
    else
    {
        //
        // The node should be visible
        //
        if (!hNode)
        {
            //
            // Node does not exist, create it
            //
            TVINSERTSTRUCT tvis;
            tvis.hParent = hParent;
            tvis.hInsertAfter = hInsertAfter;
            tvis.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
            tvis.item.pszText = const_cast<LPTSTR> ((LPCTSTR) cstrNodeName);
            tvis.item.iImage = iconNormal;
            tvis.item.iSelectedImage = iconSelected;
            tvis.item.state = 0;
            tvis.item.stateMask = 0;
            tvis.item.lParam = lparamNodeData;
            hNode = refTree.InsertItem (&tvis);
            if (NULL == hNode)
            {
                dwRes = ERROR_GEN_FAILURE;
                CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::InsertItem"), dwRes);
                return dwRes;
            }
        }
        else
        {
            //
            // Node already exists, just update its image and assigned data
            //
            TVITEM tvi;
  
            tvi.hItem  = hNode;
            tvi.mask   = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
            tvi.iImage = iconNormal;
            tvi.iSelectedImage = iconSelected;
            tvi.lParam = lparamNodeData;
            if (!refTree.SetItem (&tvi))
            {
                dwRes = ERROR_GEN_FAILURE;
                CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::SetItem"), dwRes);
                return dwRes;
            }
        }
    }
    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CLeftView::SyncFolderNode


void 
CLeftView::OnTreeSelChanged(
    NMHDR* pNMHDR, 
    LRESULT* pResult
) 
/*++

Routine name : CLeftView::OnTreeSelChanged

Routine description:

    Called by the framework when a node is selected in the tree

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pNMHDR          [in ] - Pointer to structure describing old and new node
    pResult         [out] - Result

Return Value:

    None.

--*/
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    DBG_ENTER(TEXT("CLeftView::OnTreeSelChanged"));
    
    *pResult = 0;

    //
    // Retrieve item data of new node and cast to CObject
    //
    CFolderListView*  pFolderView = (CFolderListView*) pNMTreeView->itemNew.lParam;


    if (GetCurrentView() == pFolderView)
    {
        //
        // Hey, that folder is ALREADY the current one.
        // No change required.
        //
        VERBOSE (DBG_MSG, TEXT("Requested folder is already the current one. No change performed."));
        return;
    }

    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        //  Shutdown in progress
        //
        return;
    }

    pFrm->SwitchRightPaneView (pFolderView);
    m_pCurrentView = pFolderView;

    if(NULL == pFolderView)
    {
        SetFocus();
        return;
    }
    
    FolderType type = m_pCurrentView->GetType();

    GetDocument()->ViewFolder(type);
    
    SetFocus();

    if(FOLDER_TYPE_OUTBOX == type)
    {
        theApp.OutboxViewed();
    }

}   // CLeftView::OnTreeSelChanged


BOOL 
CLeftView::CanRefreshFolder()   
/*++

Routine name : CLeftView::CanRefreshFolder

Routine description:

    does the user can referesh curent folder

Author:

    Alexander Malysh (AlexMay), May, 2000

Arguments:


Return Value:

    TRUE if yes, FALSE otherwise.

--*/
{ 
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::CanRefreshFolder"));

    BOOL  bRefreshing;
    DWORD dwOffLineCount;

    GetServerState(bRefreshing, dwOffLineCount);

    return !bRefreshing;
}


DWORD
CLeftView::RefreshCurrentFolder ()
/*++

Routine name : CLeftView::RefreshCurrentFolder

Routine description:

    Causes a refresh of the currently displayed folder (right pane)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::RefreshCurrentFolder"), dwRes);

    CClientConsoleDoc* pDoc = GetDocument();
    if(!pDoc)
    {
        ASSERTION(pDoc);
        return dwRes;
    }

    if(!m_pCurrentView)
    {
        //
        // root is selected
        //
        // clear all the folders
        //
        CMainFrame *pFrm = GetFrm();
        if (!pFrm)
        {
            //
            //  Shutdown in progress
            //
            return dwRes;
        }

        pFrm->GetIncomingView()->OnUpdate(NULL, UPDATE_HINT_CLEAR_VIEW, NULL);
        pFrm->GetInboxView()->OnUpdate(NULL, UPDATE_HINT_CLEAR_VIEW, NULL);
        pFrm->GetSentItemsView()->OnUpdate(NULL, UPDATE_HINT_CLEAR_VIEW, NULL);
        pFrm->GetOutboxView()->OnUpdate(NULL, UPDATE_HINT_CLEAR_VIEW, NULL);

        pDoc->SetInvalidFolder(FOLDER_TYPE_INBOX);
        pDoc->SetInvalidFolder(FOLDER_TYPE_OUTBOX);
        pDoc->SetInvalidFolder(FOLDER_TYPE_SENT_ITEMS);
        pDoc->SetInvalidFolder(FOLDER_TYPE_INCOMING);

        //
        // refresh server status
        //
        CServerNode* pServerNode;
        const SERVERS_LIST& srvList = pDoc->GetServersList();
        for (SERVERS_LIST::iterator it = srvList.begin(); it != srvList.end(); ++it)
        {
            pServerNode = *it;
            pServerNode->RefreshState();
        }

        return dwRes;
    }

    FolderType type = m_pCurrentView->GetType();

    //
    // clear view
    // 
    m_pCurrentView->OnUpdate(NULL, UPDATE_HINT_CLEAR_VIEW, NULL);

    //
    // Invalidate Folder
    //
    pDoc->SetInvalidFolder(type);

    //
    // refresh folder
    //
    pDoc->ViewFolder(type);

    return dwRes;
}   // CLeftView::RefreshCurrentFolder

DWORD
CLeftView::OpenSelectColumnsDlg()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::OpenSelectColumnsDlg"), dwRes);
    ASSERTION(m_pCurrentView);

    dwRes = m_pCurrentView->OpenSelectColumnsDlg();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::OpenSelectColumnsDlg"), dwRes);
    }

    return dwRes;
}

void 
CLeftView::GetServerState(
    BOOL&  bRefreshing, 
    DWORD& dwOffLineCount
)
/*++

Routine name : CLeftView::GetServerState

Routine description:

    calculate servers status

Author:

    Alexander Malysh (AlexMay), May, 2000

Arguments:

    bRefreshing                   [out]    - is one of servers or folder refreshing
    dwOffLineCount                [out]    - a number of offline servers

Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;

    bRefreshing    = FALSE;
    dwOffLineCount = 0;

    const SERVERS_LIST& srvList = GetDocument()->GetServersList();

    FolderType type;
    CServerNode* pServerNode;
    for (SERVERS_LIST::iterator it = srvList.begin(); it != srvList.end(); ++it)
    {
        pServerNode = *it;

        if(m_pCurrentView)
        {
            //
            // is refreshing ?
            //
            type = m_pCurrentView->GetType();
            if(pServerNode->GetFolder(type)->IsRefreshing())
            {
                bRefreshing = TRUE;
            }
        }
        else
        {
            //
            // root selected
            //
            if(pServerNode->GetFolder(FOLDER_TYPE_INBOX)->IsRefreshing()      ||
               pServerNode->GetFolder(FOLDER_TYPE_OUTBOX)->IsRefreshing()     ||
               pServerNode->GetFolder(FOLDER_TYPE_SENT_ITEMS)->IsRefreshing() ||
               pServerNode->GetFolder(FOLDER_TYPE_INCOMING)->IsRefreshing())
            {
                bRefreshing = TRUE;
            }
        }

        if(pServerNode->IsRefreshing())
        {
            bRefreshing = TRUE;
        }
        else if(!pServerNode->IsOnline())
        {
            ++dwOffLineCount;
        }
    }
}

BOOL 
CLeftView::GetActivity(
    CString &cstr,
    HICON& hIcon
)
/*++

Routine name : CLeftView::GetActivity

Routine description:

    calculate status bar activity string and icon

Author:

    Alexander Malysh (AlexMay), Apr, 2000

Arguments:

    cstr                          [out]    - activity string
    hIcon                         [out]    - icon

Return Value:

    TRUE if any activity, FALSE otherwise.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    BOOL  bRes        = TRUE;
    DWORD dwOffLine   = 0;
    BOOL  bRefreshing = FALSE;
    int   nIconRes     = 0;
    int   nStringRes   = 0;
    DWORD dwServerCount = GetDocument()->GetServerCount();

    GetServerState(bRefreshing, dwOffLine);

    if(0 == dwServerCount)
    {
        //
        // no fax printer install
        //
        nIconRes   = IDI_SRV_WRN;
        nStringRes = IDS_NO_SRV_INSTALL;
    }
    else if(bRefreshing)
    {
        nIconRes   = IDI_SRV_WAIT;
        nStringRes = IDS_FOLDER_REFRESHING;
    }
    else if(dwOffLine)
    {
        nIconRes = IDI_SRV_WRN;

        if(dwServerCount == dwOffLine)
        {
            nStringRes = IDS_SRV_OFFLINE;
        }
        else
        {
            nStringRes = IDS_SRV_PART_OFFLINE;
        }
    }
    else
    {
        //
        // online
        //
        nIconRes   = IDI_SRV_OK;
        nStringRes = IDS_SRV_ONLINE;
    }

    if (m_iLastActivityStringId != nStringRes)
    {
        if (m_pCurrentView)
        {
            //
            // Force a recalc of the mouse cursor
            //
            m_pCurrentView->PostMessage (WM_SETCURSOR, 0, 0);
        }
        m_iLastActivityStringId = nStringRes;
    }

    if(0 != nStringRes)
    {
        //
        // load string
        //
        dwRes = LoadResourceString (cstr, nStringRes);
        if (ERROR_SUCCESS != dwRes)
        {
            bRes = FALSE;
        }
    }

    //
    // load icon
    //
    if(0 != nIconRes)
    {
        hIcon = (HICON)LoadImage(GetResourceHandle(), 
                                 MAKEINTRESOURCE(nIconRes), 
                                 IMAGE_ICON, 
                                 16, 
                                 16, 
                                 LR_SHARED);
        if(NULL == hIcon)
        {
            DBG_ENTER(TEXT("CLeftView::GetActivity"));
            dwRes = GetLastError();
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadImage"), dwRes);
            bRes = FALSE;
        }
    }
    return bRes;
}   // CLeftView::GetActivityString





void 
CLeftView::OnRightClick(
    NMHDR* pNMHDR, 
    LRESULT* pResult
) 
/*++

Routine name : CLeftView::OnRightClick

Routine description:

    mouse right click handler

Author:

    Alexander Malysh (AlexMay), Feb, 2000

Arguments:

    pNMHDR                        [in]     - message info
    pResult                       [out]    - result

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CLeftView::OnRightClick"));

    *pResult = 0;

    //
    // get cursor position
    //
    CPoint ptScreen(GetMessagePos());

    CPoint ptClient(ptScreen);
    ScreenToClient(&ptClient);

    UINT nFlags;
    CTreeCtrl &refTree = GetTreeCtrl();
    HTREEITEM hItem = refTree.HitTest(ptClient, &nFlags);

    if(0 == hItem)
    {
        return;
    }

    //
    // select the item
    //
    BOOL bRes = refTree.Select(hItem, TVGN_CARET);
    if(!bRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::Select"), ERROR_GEN_FAILURE);
        return;
    }

    //
    // TODO
    //
    return;

    int nMenuResource = 0;

    if (NULL == m_pCurrentView)
    {
        nMenuResource = IDM_TREE_ROOT_OPTIONS;
    }
    else
    {
        switch(m_pCurrentView->GetType())
        {
        case FOLDER_TYPE_OUTBOX:
            nMenuResource = IDM_OUTBOX_FOLDER;
            break;
        case FOLDER_TYPE_INCOMING:
        case FOLDER_TYPE_INBOX:
        case FOLDER_TYPE_SENT_ITEMS:
            break;
        default:
            ASSERTION_FAILURE
            break;
        }
    }
        
    if(0 == nMenuResource)
    {
        return;
    }

    //
    // popup menu
    //
    CMenu mnuContainer;
    if (!mnuContainer.LoadMenu (nMenuResource))
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("CMenu::LoadMenu"), ERROR_GEN_FAILURE);
        return;
    }

    CMenu* pmnuPopup = mnuContainer.GetSubMenu (0);
    ASSERTION (pmnuPopup);
    if (!pmnuPopup->TrackPopupMenu (TPM_LEFTALIGN, 
                                    ptScreen.x, 
                                    ptScreen.y, 
                                    AfxGetMainWnd ()))
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("CMenu::TrackPopupMenu"), ERROR_GEN_FAILURE);
    }   
} // CLeftView::OnRightClick



DWORD 
CLeftView::RemoveTreeItem(
    HTREEITEM hItem
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::RemoveTreeItem"), dwRes);

    ASSERTION(hItem);

    CTreeCtrl &refTree = GetTreeCtrl();
    
    if(!refTree.DeleteItem(hItem))
    {
        dwRes = ERROR_CAN_NOT_COMPLETE;
        CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::DeleteItem"), dwRes);
        return dwRes;
    }

    return dwRes;
}


DWORD 
CLeftView::SelectRoot()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::SelectRoot"), dwRes);

    CTreeCtrl &refTree = GetTreeCtrl();

    if(!refTree.Select(m_treeitemRoot, TVGN_CARET))
    {
        dwRes = ERROR_CAN_NOT_COMPLETE;
        CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::Select"), dwRes);
        return dwRes;
    }

    return dwRes;
}


DWORD 
CLeftView::OpenHelpTopic()
/*++

Routine name : CLeftView::OpenHelpTopic

Routine description:

    open appropriate help topic according to current selection

Author:

    Alexander Malysh (AlexMay), Mar, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::OpenHelpTopic"), dwRes);

    TCHAR* tszHelpTopic = FAX_HELP_WELCOME;

    if(NULL != m_pCurrentView)
    {
        switch(m_pCurrentView->GetType())
        {
        case FOLDER_TYPE_INCOMING:
            tszHelpTopic = FAX_HELP_INCOMING;
            break;
        case FOLDER_TYPE_INBOX:
            tszHelpTopic = FAX_HELP_INBOX;
            break;
        case FOLDER_TYPE_OUTBOX:
            tszHelpTopic = FAX_HELP_OUTBOX;
            break;
        case FOLDER_TYPE_SENT_ITEMS:
            tszHelpTopic = FAX_HELP_SENTITEMS;
            break;
        default:
            ASSERTION_FAILURE
            break;
        }
    }

    dwRes = ::HtmlHelpTopic(m_hWnd, tszHelpTopic);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("HtmlHelpTopic"),dwRes);
    }

    return dwRes;

} // CLeftView::OpenHelpTopic

int 
CLeftView::GetDataCount()
{
    int nCount = -1;
    if(NULL != m_pCurrentView)
    {
        FolderType type = m_pCurrentView->GetType();

        nCount = GetDocument()->GetFolderDataCount(type);
    }

    return nCount;
}

void 
CLeftView::OnChar( 
    UINT nChar, 
    UINT nRepCnt, 
    UINT nFlags 
)
/*++

Routine name : CFolderListView::OnChar

Routine description:

    The framework calls this member function when a keystroke translates 
    to a nonsystem character

Arguments:

  nChar     [in] - Contains the character code value of the key.
  nRepCnt   [in] - Contains the repeat count
  nFlags    [in] - Contains the scan code

Return Value:

    None.

--*/
{
    if(VK_TAB == nChar)
    {
        if(m_pCurrentView)
        {
            m_pCurrentView->SetFocus();
        }
    }
    else
    {
        CTreeView::OnChar(nChar, nRepCnt, nFlags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\leftview.h ===
// LeftView.h : interface of the CLeftView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_LEFTVIEW_H__8D2F8964_7AE2_4CB2_9FFB_03CF78C2C869__INCLUDED_)
#define AFX_LEFTVIEW_H__8D2F8964_7AE2_4CB2_9FFB_03CF78C2C869__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//
// List of icon indices, used in the tree control
//
typedef enum
{
    TREE_IMAGE_ROOT,                // Client console tree root
    TREE_IMAGE_SERVER_ONLINE,       // Online server
    TREE_IMAGE_SERVER_OFFLINE,      // Offline server
    TREE_IMAGE_INCOMING,            // Incoming folder
    TREE_IMAGE_INBOX,               // Inbox folder
    TREE_IMAGE_OUTBOX_PAUSED,       // The server's outgoing queue is paused 
    TREE_IMAGE_OUTBOX_BLOCKED,      // The server's outgoing queue is blocked
    TREE_IMAGE_OUTBOX,              // Outbox folder
    TREE_IMAGE_SERVER_REFRESHING,   // Refreshing server (connecting...)
    TREE_IMAGE_MAX
} TreeIconType; 

class CLeftView : public CTreeView
{
protected: // create from serialization only
    CLeftView();
    DECLARE_DYNCREATE(CLeftView)

// Attributes
public:
    virtual  ~CLeftView();

    CClientConsoleDoc* GetDocument();

    CFolderListView* GetCurrentView() { return m_pCurrentView; }

    BOOL   CanRefreshFolder();
    DWORD  RefreshCurrentFolder();

    DWORD OpenSelectColumnsDlg();
    BOOL  CanOpenSelectColumnsDlg() { return m_pCurrentView ? TRUE : FALSE; }

    int GetDataCount();

    BOOL GetActivity(CString& cstr, HICON& hIcon);

    BOOL  IsRemoteServerSelected();
    DWORD RemoveTreeItem(HTREEITEM hItem);

    DWORD SelectRoot();

    DWORD OpenHelpTopic();

    VOID  SelectFolder (FolderType);

    DWORD RefreshImageList ();

    static CImageList  m_ImageList;       // Image list of tree icons

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLeftView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual void OnInitialUpdate(); // called first time after construct
    //}}AFX_VIRTUAL

// Generated message map functions
protected:
    //{{AFX_MSG(CLeftView)
    afx_msg void OnTreeSelChanged(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnRightClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:

    void GetServerState(BOOL& bRefreshing, DWORD& dwOffLineCount);

    DWORD 
    SyncFolderNode (
        HTREEITEM       hParent,
        BOOL            bVisible,
        int             iNodeStringResource,
        HTREEITEM       hInsertAfter,
        TreeIconType    iconNormal,
        TreeIconType    iconSelected,
        LPARAM          lparamNodeData,
        HTREEITEM      &hNode
    );

    HTREEITEM FindNode (HTREEITEM hRoot, CString &cstrNodeString);

    HTREEITEM   m_treeitemRoot;    // Root fo tree

    CFolderListView*  m_pCurrentView;

    int         m_iLastActivityStringId;
};

#ifndef _DEBUG  // debug version in LeftView.cpp
inline CClientConsoleDoc* CLeftView::GetDocument()
   { return (CClientConsoleDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LEFTVIEW_H__8D2F8964_7AE2_4CB2_9FFB_03CF78C2C869__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\itempropsheet.cpp ===
// ItemPropSheet.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     42

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CItemPropSheet

IMPLEMENT_DYNAMIC(CItemPropSheet, CPropertySheet)


CItemPropSheet::CItemPropSheet(
    UINT nIDCaption,    // sheet caption id
    CWnd* pParentWnd,   // parent window
    UINT iSelectPage    // initialy selected page
):
    CPropertySheet(nIDCaption, pParentWnd, iSelectPage),
    m_dwLastError(ERROR_SUCCESS),
    m_pMsg(NULL)
{
    //
    // no Help button
    //
    m_psh.dwFlags &= ~PSH_HASHELP;
    //
    // no Apply button
    //
    m_psh.dwFlags |= PSH_NOAPPLYNOW;
}


DWORD
CItemPropSheet::Init(
    CFolder* pFolder,   // folder
    CFaxMsg* pMsg       // pointer to CJob or CArchiveMsg
)
{
    m_dwLastError = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CItemPropSheet::Init"), m_dwLastError);

    ASSERTION(pFolder);
    ASSERTION(pMsg);

    //
    // init page array
    //
    for(DWORD dw=0; dw < PROP_SHEET_PAGES_NUM; ++dw)
    {
        m_pPages[dw] = NULL;
    }


    //
    // create pages according to FolderType
    //
    FolderType type =  pFolder->Type();
    BOOL bCreatePersonalInfo = TRUE;

    if(pMsg->IsKindOf(RUNTIME_CLASS(CArchiveMsg)))
    {
        try
        {
            m_pMsg = new CArchiveMsg;
        }
        catch(...)
        {
            m_dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT ("new CArchiveMsg"), m_dwLastError);
            goto exit;
        }

        m_dwLastError = ((CArchiveMsg*)m_pMsg)->Copy(*((CArchiveMsg*)pMsg));
        if(ERROR_SUCCESS != m_dwLastError)
        {
            return m_dwLastError;
        }
    }
    else if(pMsg->IsKindOf(RUNTIME_CLASS(CJob)))
    {
        try
        {
            m_pMsg = new CJob;
        }
        catch(...)
        {
            m_dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT ("new CJob"), m_dwLastError);
            goto exit;
        }

        m_dwLastError = ((CJob*)m_pMsg)->Copy(*((CJob*)pMsg));
        if(ERROR_SUCCESS != m_dwLastError)
        {
            return m_dwLastError;
        }
    }
    else
    {
        ASSERTION_FAILURE
    }

    try
    {
        switch(type)
        {
        case FOLDER_TYPE_INCOMING:
            bCreatePersonalInfo = FALSE;

            m_pPages[0] = new CIncomingGeneralPg(m_pMsg);
            m_pPages[1] = new CIncomingDetailsPg(m_pMsg);

            break;
        case FOLDER_TYPE_INBOX:
            bCreatePersonalInfo = FALSE;

            m_pPages[0] = new CInboxGeneralPg(m_pMsg);
            m_pPages[1] = new CInboxDetailsPg(m_pMsg);

            break;
        case FOLDER_TYPE_OUTBOX:
        
            m_pPages[0] = new COutboxGeneralPg(m_pMsg);
            m_pPages[1] = new COutboxDetailsPg(m_pMsg);

            break;
        case FOLDER_TYPE_SENT_ITEMS:
    
            m_pPages[0] = new CSentItemsGeneralPg(m_pMsg);
            m_pPages[1] = new CSentItemsDetailsPg(m_pMsg);

            break;
        default:
            ASSERTION_FAILURE;
            break;
        };

        if(bCreatePersonalInfo)
        {
            //
            // create sender info page
            //
            m_pPages[2] = new CPersonalInfoPg(IDS_SENDER_INFO_CAPTION, 
                                              PERSON_SENDER, 
                                              m_pMsg,
                                              pFolder);

            m_dwLastError = ((CPersonalInfoPg*)m_pPages[2])->Init();
            if(ERROR_SUCCESS != m_dwLastError)
            {
                CALL_FAIL (GENERAL_ERR, TEXT ("CPersonalInfoPg::Init"), m_dwLastError);
            }
        }
    }
    catch(...)
    {
        m_dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("new CPropertyPage"), m_dwLastError);
        goto exit;
    }

    //
    // add pages to sheet
    //
    for(dw=0; dw < PROP_SHEET_PAGES_NUM; ++dw)
    {
        if(NULL != m_pPages[dw])
        {
            AddPage(m_pPages[dw]);
        }
    }

exit:
    if(ERROR_SUCCESS != m_dwLastError)
    {
        for(DWORD dw=0; dw < PROP_SHEET_PAGES_NUM; ++dw)
        {
            SAFE_DELETE(m_pPages[dw]);
        }
    }

    return m_dwLastError;
}

CItemPropSheet::~CItemPropSheet()
{
    for(DWORD dw=0; dw < PROP_SHEET_PAGES_NUM; ++dw)
    {
        SAFE_DELETE(m_pPages[dw]);
    }

    SAFE_DELETE(m_pMsg);
}


BEGIN_MESSAGE_MAP(CItemPropSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CItemPropSheet)
	ON_WM_ACTIVATE()
    ON_MESSAGE(WM_SET_SHEET_FOCUS, OnSetSheetFocus)
	ON_WM_CREATE()
    ON_MESSAGE(WM_HELP, OnHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CItemPropSheet message handlers

void 
CItemPropSheet::OnActivate(
    UINT nState, 
    CWnd* pWndOther,
    BOOL bMinimized
) 
{
    DBG_ENTER(TEXT("CItemPropSheet::OnActivate"));

    CPropertySheet::OnActivate(nState, pWndOther, bMinimized);
	
    //
    // hide OK button
    //
    CWnd *pWnd = GetDlgItem( IDOK );
    ASSERTION(NULL != pWnd);
	pWnd->ShowWindow( FALSE );	

    //
    // rename Cancel button
    //
    CString cstrText;
    DWORD dwRes = LoadResourceString (cstrText, IDS_BUTTON_CLOSE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
        return;
    }

    pWnd = GetDlgItem( IDCANCEL );
    ASSERT(NULL != pWnd);
	pWnd->SetWindowText(cstrText);	
}

LONG 
CItemPropSheet::OnSetSheetFocus(
    UINT wParam, 
    LONG lParam
)
{
    //
    // set focus on Close button
    //
    CWnd *pWnd = GetDlgItem( IDCANCEL );
    ASSERT(NULL != pWnd);
    pWnd->SetFocus();
    return 0;
} 

int 
CItemPropSheet::OnCreate(
    LPCREATESTRUCT lpCreateStruct
) 
{
	if (CPropertySheet::OnCreate(lpCreateStruct) == -1)
		return -1;
	
    ModifyStyleEx(0, WS_EX_CONTEXTHELP);
	
	return 0;
}

LONG 
CItemPropSheet::OnHelp(
    UINT wParam, 
    LONG lParam
)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"

#define __FILE_ID__     5

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CClientConsoleApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_CLOSE()
    ON_WM_SETTINGCHANGE()
    ON_WM_SYSCOLORCHANGE()
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,             OnHelpContents)
    ON_MESSAGE(WM_HELP,                    OnHelp)                   // F1
    ON_COMMAND(ID_VIEW_REFRESH_FOLDER,     OnRefreshFolder)
    ON_COMMAND(ID_SEND_NEW_FAX,            OnSendNewFax)
    ON_COMMAND(ID_RECEIVE_NEW_FAX,         OnReceiveNewFax)
    ON_COMMAND(ID_TOOLS_USER_INFO,         OnViewOptions)
    ON_COMMAND(ID_TOOLS_CONFIG_WIZARD,     OnToolsConfigWizard)
    ON_COMMAND(ID_TOOLS_ADMIN_CONSOLE,     OnToolsAdminConsole)    
    ON_COMMAND(ID_TOOLS_MONITOR,           OnToolsMonitor)    
    ON_COMMAND(ID_VIEW_COVER_PAGES,        OnToolsCoverPages)    
    ON_COMMAND(ID_VIEW_SERVER_STATUS,      OnToolsServerStatus)    
    ON_COMMAND(ID_TOOLS_FAX_PRINTER_PROPS, OnToolsFaxPrinterProps)    
    ON_COMMAND(ID_VIEW_SELECT_COLUMNS,     OnSelectColumns)
    ON_COMMAND(ID_IMPORT_INBOX,            OnImportInbox)
    ON_COMMAND(ID_IMPORT_SENT,             OnImportSentItems)
    ON_UPDATE_COMMAND_UI_RANGE(ID_TOOLS_CONFIG_WIZARD, ID_TOOLS_MONITOR, OnUpdateWindowsXPTools)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SELECT_COLUMNS,          OnUpdateSelectColumns)        
    ON_UPDATE_COMMAND_UI(ID_VIEW_SERVER_STATUS,           OnUpdateServerStatus)       
    ON_UPDATE_COMMAND_UI(ID_VIEW_REFRESH_FOLDER,          OnUpdateRefreshFolder)
    ON_UPDATE_COMMAND_UI(ID_INDICATOR_FOLDER_ITEMS_COUNT, OnUpdateFolderItemsCount)
    ON_UPDATE_COMMAND_UI(ID_INDICATOR_ACTIVITY,           OnUpdateActivity)    
    ON_UPDATE_COMMAND_UI(ID_SEND_NEW_FAX,                 OnUpdateSendNewFax)
    ON_UPDATE_COMMAND_UI(ID_RECEIVE_NEW_FAX,              OnUpdateReceiveNewFax)
    ON_UPDATE_COMMAND_UI(ID_IMPORT_SENT,                  OnUpdateImportSent)
    ON_UPDATE_COMMAND_UI(ID_HELP_FINDER,                  OnUpdateHelpContents)    
    ON_MESSAGE(WM_POPUP_ERROR,                            OnPopupError)
    ON_MESSAGE(WM_CONSOLE_SET_ACTIVE_FOLDER,              OnSetActiveFolder)
    ON_MESSAGE(WM_CONSOLE_SELECT_ITEM,                    OnSelectItem)
    ON_MESSAGE(WM_QUERYENDSESSION, OnQueryEndSession)
    ON_NOTIFY(NM_DBLCLK, AFX_IDW_STATUS_BAR, OnStatusBarDblClk )
END_MESSAGE_MAP()


//
// List of indices of items used in the Incoming folder
//
#define INCOMING_DEF_COL_NUM   8

static MsgViewItemType IncomingColumnsUsed[] = 
                {
                    MSG_VIEW_ITEM_ICON,                    // default 0 
                    MSG_VIEW_ITEM_TRANSMISSION_START_TIME, // default 1 
                    MSG_VIEW_ITEM_TSID,                    // default 2
                    MSG_VIEW_ITEM_CALLER_ID,               // default 3 
                    MSG_VIEW_ITEM_STATUS,                  // default 4 
                    MSG_VIEW_ITEM_EXTENDED_STATUS,         // default 5 
                    MSG_VIEW_ITEM_CURRENT_PAGE,            // default 6 
                    MSG_VIEW_ITEM_SIZE,                    // default 7 
                    MSG_VIEW_ITEM_SERVER,          
                    MSG_VIEW_ITEM_CSID,            
                    MSG_VIEW_ITEM_DEVICE,          
                    MSG_VIEW_ITEM_ROUTING_INFO,    
                    MSG_VIEW_ITEM_SEND_TIME,   // schedule time
                    MSG_VIEW_ITEM_TRANSMISSION_END_TIME,
                    MSG_VIEW_ITEM_ID,              
                    MSG_VIEW_ITEM_NUM_PAGES, 
                    MSG_VIEW_ITEM_RETRIES,         
                    MSG_VIEW_ITEM_END              // End of list
                };


//
// List of indices of items used in the Inbox folder
//
#define INBOX_DEF_COL_NUM   8

static MsgViewItemType InboxColumnsUsed[] = 
                {
                    MSG_VIEW_ITEM_ICON,                    // default 0 
                    MSG_VIEW_ITEM_TRANSMISSION_START_TIME, // default 1 
                    MSG_VIEW_ITEM_TSID,                    // default 2 
                    MSG_VIEW_ITEM_CALLER_ID,               // default 3 
                    MSG_VIEW_ITEM_NUM_PAGES,               // default 4 
                    MSG_VIEW_ITEM_STATUS,                  // default 5 
                    MSG_VIEW_ITEM_SIZE,                    // default 6 
                    MSG_VIEW_ITEM_CSID,                    // default 7
                    MSG_VIEW_ITEM_SERVER,                
                    MSG_VIEW_ITEM_TRANSMISSION_END_TIME, 
                    MSG_VIEW_ITEM_TRANSMISSION_DURATION, 
                    MSG_VIEW_ITEM_DEVICE,                
                    MSG_VIEW_ITEM_ROUTING_INFO,          
                    MSG_VIEW_ITEM_ID,                    
                    MSG_VIEW_ITEM_END              // End of list
                };

//
// List of indices of items used in the sent items folder
//
#define SENT_ITEMS_DEF_COL_NUM   8

static MsgViewItemType SentItemsColumnsUsed[] = 
                {
                    MSG_VIEW_ITEM_ICON,                   // default 0
                    MSG_VIEW_ITEM_TRANSMISSION_START_TIME,// default 1
                    MSG_VIEW_ITEM_RECIPIENT_NAME,         // default 2
                    MSG_VIEW_ITEM_RECIPIENT_NUMBER,       // default 3
                    MSG_VIEW_ITEM_SUBJECT,                // default 4
                    MSG_VIEW_ITEM_DOC_NAME,               // default 5
                    MSG_VIEW_ITEM_NUM_PAGES,              // default 6
                    MSG_VIEW_ITEM_SIZE,                   // default 7
                    MSG_VIEW_ITEM_SERVER,
                    MSG_VIEW_ITEM_USER,
                    MSG_VIEW_ITEM_PRIORITY,
                    MSG_VIEW_ITEM_CSID,
                    MSG_VIEW_ITEM_TSID,
                    MSG_VIEW_ITEM_ORIG_TIME,
                    MSG_VIEW_ITEM_RETRIES,
                    MSG_VIEW_ITEM_ID,
                    MSG_VIEW_ITEM_BROADCAST_ID,
                    MSG_VIEW_ITEM_SUBMIT_TIME,
                    MSG_VIEW_ITEM_TRANSMISSION_DURATION,
                    MSG_VIEW_ITEM_TRANSMISSION_END_TIME,
                    MSG_VIEW_ITEM_BILLING,
                    MSG_VIEW_ITEM_SENDER_NAME,
                    MSG_VIEW_ITEM_SENDER_NUMBER,
                    MSG_VIEW_ITEM_END    // End of list
                };

//
// List of indices of items used in the Outbox folder
//

#define OUTBOX_DEF_COL_NUM   9

static MsgViewItemType OutboxColumnsUsed[] = 
                {
                    MSG_VIEW_ITEM_ICON,             // default 0
                    MSG_VIEW_ITEM_SUBMIT_TIME,      // default 1
                    MSG_VIEW_ITEM_RECIPIENT_NAME,   // default 2
                    MSG_VIEW_ITEM_RECIPIENT_NUMBER, // default 3
                    MSG_VIEW_ITEM_SUBJECT,          // default 4
                    MSG_VIEW_ITEM_DOC_NAME,         // default 5
                    MSG_VIEW_ITEM_STATUS,           // default 6
                    MSG_VIEW_ITEM_EXTENDED_STATUS,  // default 7                    
                    MSG_VIEW_ITEM_CURRENT_PAGE,     // default 8                    
                    MSG_VIEW_ITEM_SEND_TIME,        
                    MSG_VIEW_ITEM_SERVER,    
                    MSG_VIEW_ITEM_NUM_PAGES,       
                    MSG_VIEW_ITEM_USER,        
                    MSG_VIEW_ITEM_PRIORITY,    
                    MSG_VIEW_ITEM_CSID,        
                    MSG_VIEW_ITEM_TSID,        
                    MSG_VIEW_ITEM_ORIG_TIME,   
                    MSG_VIEW_ITEM_SIZE,        
                    MSG_VIEW_ITEM_DEVICE,        
                    MSG_VIEW_ITEM_RETRIES,     
                    MSG_VIEW_ITEM_ID,      
                    MSG_VIEW_ITEM_BROADCAST_ID,
                    MSG_VIEW_ITEM_BILLING,         
                    MSG_VIEW_ITEM_END    // End of list
                };

//
// Status bar indicators
//
static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator (menu item)
    ID_INDICATOR_FOLDER_ITEMS_COUNT,  // status line indicator (num of folder items)
    ID_INDICATOR_ACTIVITY,            // status line indicator (Activity)
};


/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame() :
    m_pInitialRightPaneView (NULL),
    m_pLeftView (NULL),
    m_pIncomingView(NULL),
    m_pInboxView(NULL),
    m_pSentItemsView(NULL),
    m_pOutboxView(NULL)
{}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    int iRes = 0;
    DWORD dwRes;
    DBG_ENTER(TEXT("CMainFrame::OnCreate"), (HRESULT &)iRes);

    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
    {
        iRes = -1;
        CALL_FAIL (STARTUP_ERR, TEXT("CFrameWnd::OnCreate"), iRes);
        return iRes;
    }

    FrameToSavedLayout();

    //
    // Create the toolbar
    //  
    if (!m_wndToolBar.CreateEx(this) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        iRes = -1;
        CALL_FAIL (STARTUP_ERR, 
                   TEXT("CToolBar::CreateEx or CToolBar::LoadToolBar"), 
                   iRes);
        return iRes;
    }
    //
    // Create the rebar and place the toolbar + dialogbar in it.
    //
    if (!m_wndReBar.Create(this) ||
        !m_wndReBar.AddBar(&m_wndToolBar))
    {
        iRes = -1;
        CALL_FAIL (STARTUP_ERR, 
                   TEXT("CReBar::Create or CReBar::AddBar"), 
                   iRes);
        return iRes;
    }
    //
    // Create the status bar
    //
    if (!m_wndStatusBar.CreateEx (this, SBARS_SIZEGRIP | SBT_TOOLTIPS) ||
        !m_wndStatusBar.SetIndicators (indicators, sizeof(indicators)/sizeof(UINT)))
    {
        iRes = -1;
        CALL_FAIL (STARTUP_ERR, 
                   TEXT("CStatusBar::CreateEx or CStatusBar::SetIndicators"), 
                   iRes);
        return iRes;
    }

    //
    // set pane width
    //
    m_wndStatusBar.SetPaneInfo(STATUS_PANE_ITEM_COUNT, 
                               ID_INDICATOR_FOLDER_ITEMS_COUNT, 
                               SBPS_NORMAL, 
                               80);
    m_wndStatusBar.SetPaneInfo(STATUS_PANE_ACTIVITY, 
                               ID_INDICATOR_ACTIVITY,           
                               SBPS_STRETCH, 
                               200);

    // TODO: Remove this if you don't want tool tips
    m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() | CBRS_TOOLTIPS | CBRS_FLYBY);
    //
    // Load strings used for display throughout the application - priority & job status
    //
    dwRes = CViewRow::InitStrings ();
    if (ERROR_SUCCESS != dwRes)
    {
        iRes = -1;
        CALL_FAIL (RESOURCE_ERR, TEXT("CJob::InitStrings"), dwRes);
        return iRes;
    }
    return iRes;
}

BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT /*lpcs*/,
    CCreateContext* pContext)
{
    BOOL bRes = TRUE;
    DBG_ENTER(TEXT("CMainFrame::OnCreateClient"), bRes);
    //
    // Create splitter window
    //
    if (!m_wndSplitter.CreateStatic(this, 1, 2))
    {
        bRes = FALSE;
        CALL_FAIL (STARTUP_ERR, TEXT("CSplitterWnd::CreateStatic"), bRes);
        return bRes;
    }
    CRect r;
    GetWindowRect(r);

    int iLeftWidth = int(r.Width()*0.32),
        iRightWidth = int(r.Width()*0.68);

    if (!m_wndSplitter.CreateView(0, 
                                  0, 
                                  RUNTIME_CLASS(CLeftView), 
                                  CSize(iLeftWidth, r.Height()), 
                                  pContext
                                 ) ||
        !m_wndSplitter.CreateView(0, 
                                  1, 
                                  RUNTIME_CLASS(CClientConsoleView), 
                                  CSize(iRightWidth, r.Height()), 
                                  pContext
                                 )
       )
    {
        m_wndSplitter.DestroyWindow();
        bRes = FALSE;
        CALL_FAIL (STARTUP_ERR, TEXT("CSplitterWnd::CreateView"), bRes);
        return bRes;
    }
    m_pInitialRightPaneView = GetRightPane ();
    m_pLeftView = (CLeftView *)(m_wndSplitter.GetPane(0,0));

    SplitterToSavedLayout();

    return bRes;
}   // CMainFrame::OnCreateClient

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    BOOL bRes = TRUE;
    DBG_ENTER(TEXT("CMainFrame::PreCreateWindow"), bRes);
    
    //
    // The following line removes the document name from the application's title.
    //
    cs.style &= ~FWS_ADDTOTITLE;
    //
    // Use the unique class name so that FindWindow can later locate it.
    //
    cs.lpszClass = theApp.GetClassName();

    if( !CFrameWnd::PreCreateWindow(cs) )
    {
        bRes = FALSE;
        CALL_FAIL (STARTUP_ERR, TEXT("CFrameWnd::PreCreateWindow"), bRes);
        return bRes;
    }
    return bRes;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

CListView* CMainFrame::GetRightPane()
{
    CWnd* pWnd = m_wndSplitter.GetPane(0, 1);
    return (CListView *)pWnd;
}

void 
CMainFrame::SwitchRightPaneView(
    CListView *pNewView
)
/*++

Routine name : CMainFrame::SwitchRightPaneView

Routine description:

    Switches the view displayed in the right pane to a new view

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pNewView            [in] - View to display in the right pane

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CMainFrame::SwitchRightPaneView"));
    ASSERT_VALID (&m_wndSplitter);
    if (!pNewView)
    {
        //
        // Switch back to our initial right pane view
        //
        pNewView = m_pInitialRightPaneView;
    }
    ASSERTION (pNewView);
    ASSERT_KINDOF (CListView, pNewView);
    //
    // Get window at current pane
    //
    CWnd *pPaneWnd = m_wndSplitter.GetPane (0,1);
    ASSERT_VALID (pPaneWnd);
    CListView *pCurrentView = static_cast<CListView*> (pPaneWnd);        
    //
    // Exchange view window ID's so RecalcLayout() works.
    //
    UINT uCurrentViewId = ::GetWindowLong(pCurrentView->m_hWnd, GWL_ID);
    UINT uNewViewId =     ::GetWindowLong(pNewView->m_hWnd,     GWL_ID);
    if (uCurrentViewId == uNewViewId)
    {
        //
        // Same view - do nothing
        //
        return;
    }
    ::SetWindowLong(pCurrentView->m_hWnd, GWL_ID, uNewViewId);
    ::SetWindowLong(pNewView->m_hWnd,     GWL_ID, uCurrentViewId);
    //
    // Hide current view and show the new view
    //
    pCurrentView->ShowWindow(SW_HIDE);
    pNewView->ShowWindow(SW_SHOW);
    SetActiveView(pNewView);
    //
    // Cause redraw in new view
    //
    pNewView->Invalidate();
    //
    // Recalc frame layout
    //
    m_wndSplitter.RecalcLayout ();
}   // CMainFrame::SwitchRightPaneView

void CMainFrame::OnRefreshFolder()
/*++

Routine name : CMainFrame::OnRefreshFolder

Routine description:

    Called by the framework to refresh the current folder (F5)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnRefreshFolder"));
    DWORD dwRes = GetLeftView()->RefreshCurrentFolder ();
}

void 
CMainFrame::OnSelectColumns()
{
    DBG_ENTER(TEXT("CMainFrame::OnSelectColumns"));

    DWORD dwRes = m_pLeftView->OpenSelectColumnsDlg();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CLeftView::OpenSelectColumnsDlg"), dwRes);
        PopupError(dwRes);
    }
}

void 
CMainFrame::OnUpdateSelectColumns(
    CCmdUI* pCmdUI
)
{
    DBG_ENTER(TEXT("CMainFrame::OnUpdateSelectColumns"));

    pCmdUI->Enable(m_pLeftView->CanOpenSelectColumnsDlg());
}

void 
CMainFrame::OnUpdateFolderItemsCount(
    CCmdUI* pCmdUI
) 
/*++

Routine name : CMainFrame::OnUpdateFolderItemsCount

Routine description:

    status bar indication of folder items count

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    pCmdUI                        [in/out] 

Return Value:

    None.

--*/
{
    CString cstrText;
    if(NULL != m_pLeftView)
    {
        int nItemCount = m_pLeftView->GetDataCount();
        //
        // if nItemCount < 0 this information is not relevant
        //
        if(nItemCount >= 0)
        {
            CString cstrFormat;
            DWORD dwRes = LoadResourceString (cstrFormat, 
                            (1 == nItemCount) ? IDS_STATUS_BAR_ITEM : IDS_STATUS_BAR_ITEMS);
            if (ERROR_SUCCESS != dwRes)
            {
                goto exit;
            }
            
            try
            {
                cstrText.Format(cstrFormat, nItemCount);
            }
            catch(...)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
        }
    }

exit:
    pCmdUI->SetText (cstrText);
}

void 
CMainFrame::OnStatusBarDblClk( 
    NMHDR* pNotifyStruct, 
    LRESULT* result 
)
{
    POINT pt;
    GetCursorPos(&pt);

    CRect rc;
    m_wndStatusBar.GetItemRect(STATUS_PANE_ACTIVITY, &rc);
    m_wndStatusBar.ClientToScreen(&rc);

    if(rc.PtInRect(pt))
    {
        OnToolsServerStatus();
    }
}

void 
CMainFrame::OnUpdateActivity(
    CCmdUI* pCmdUI
)
{
    CString cstrText;
    HICON hIcon = NULL;

    if (!m_pLeftView)
    {
        //
        // No left view yet
        //
        return;
    }

    if (!m_pLeftView->GetActivity(cstrText, hIcon))
    {
        //
        // Activity string is to be ignored
        //
        cstrText.Empty ();
    }

    CStatusBarCtrl& barCtrl = m_wndStatusBar.GetStatusBarCtrl();
    barCtrl.SetIcon(STATUS_PANE_ACTIVITY, hIcon);
    pCmdUI->SetText (cstrText);
}

void 
CMainFrame::OnUpdateRefreshFolder(
    CCmdUI* pCmdUI
) 
/*++

Routine name : CMainFrame::OnUpdateRefreshFolder

Routine description:

    Called by the framework to know if the current folder can be refreshed (F5)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pCmdUI          [in] - Answer buffer

Return Value:

    None.

--*/
{
    pCmdUI->Enable(GetLeftView()->CanRefreshFolder());
}


LRESULT 
CMainFrame::OnPopupError (
    WPARAM wParam, 
    LPARAM lParam)
/*++

Routine name : CMainFrame::OnPopupError

Routine description:

    Handles the WM_POPUP_ERROR messages

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    wParam   [in]     - Error code
    lParam   [in]     - Hiword contains the __FILE_ID__ and 
                        Loword contains the line number

Return Value:

    Standard result code

--*/
{
    DWORD dwErrCode = (DWORD) wParam;
    WORD  wFileId   = HIWORD(DWORD(lParam));
    WORD  wLineNumber = LOWORD(DWORD(lParam));

    CErrorDlg ErrDlg(dwErrCode, wFileId, wLineNumber);
    return ErrDlg.DoModal (); 
}   // CMainFrame::OnPopupError


LRESULT 
CMainFrame::OnSelectItem (
    WPARAM wParam, 
    LPARAM lParam)
/*++

Routine name : CMainFrame::OnSelectItem

Routine description:

    Handles the WM_CONSOLE_SELECT_ITEM messages

Author:

    Eran Yariv (EranY), May, 2001

Arguments:

    wParam   [in]     - Low 32-bits of message id
    lParam   [in]     - High 32-bits of message id

Return Value:

    Standard result code

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnSelectItem"), TEXT("wParam=%ld, lParam=%ld"), wParam, lParam);


    ULARGE_INTEGER uli;
    uli.LowPart = wParam;
    uli.HighPart = lParam;

    if (!m_pLeftView)
    {
        return FALSE;
    }

    CFolderListView* pCurView = m_pLeftView->GetCurrentView();
    if (!pCurView)
    {
        return FALSE;
    }
    pCurView->SelectItemById(uli.QuadPart);
    return TRUE;
}   // CMainFrame::OnSelectItem


LRESULT 
CMainFrame::OnSetActiveFolder (
    WPARAM wParam, 
    LPARAM lParam)
/*++

Routine name : CMainFrame::OnSetActiveFolder

Routine description:

    Handles the WM_CONSOLE_SET_ACTIVE_FOLDER messages

Author:

    Eran Yariv (EranY), May, 2001

Arguments:

    wParam   [in]     - FolderType value
    lParam   [in]     - Unused

Return Value:

    Standard result code

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnSetActiveFolder"), TEXT("wParam=%ld, lParam=%ld"), wParam, lParam);

    if (wParam > FOLDER_TYPE_INCOMING)
    {
        VERBOSE (GENERAL_ERR, TEXT("wParam is out of range - message ignored"));
        return FALSE;
    }
    
    if (!m_pLeftView)
    {
        return FALSE;
    }
    m_pLeftView->SelectFolder (FolderType(wParam));
    return TRUE;
}   // CMainFrame::OnSetActiveFolder

DWORD   
CMainFrame::CreateFolderViews (
    CDocument *pDoc
)
/*++

Routine name : CMainFrame::CreateFolderViews

Routine description:

    Creates the 4 global views used for folders display

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pDoc            [in] - Pointer to document to attach to the new views

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::CreateFolderViews"), dwRes);

    DWORD dwChildID = AFX_IDW_PANE_FIRST + 10;

    ASSERTION (!m_pIncomingView && !m_pInboxView && !m_pSentItemsView && !m_pOutboxView);

    //
    // Create incoming view
    //
    dwRes = CreateDynamicView (dwChildID++,
                               CLIENT_INCOMING_VIEW,
                               RUNTIME_CLASS(CFolderListView), 
                               pDoc,
                               (PINT)IncomingColumnsUsed,
                               INCOMING_DEF_COL_NUM,
                               (CFolderListView **)&m_pIncomingView,
                               FOLDER_TYPE_INCOMING);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CMainFrame::CreateDynamicView (Incoming)"), dwRes);
        return dwRes;
    }

    //
    // Create inbox view
    //
    dwRes = CreateDynamicView (dwChildID++,
                               CLIENT_INBOX_VIEW,
                               RUNTIME_CLASS(CFolderListView), 
                               pDoc,
                               (PINT)InboxColumnsUsed,
                               INBOX_DEF_COL_NUM,
                               (CFolderListView **)&m_pInboxView,
                               FOLDER_TYPE_INBOX);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CMainFrame::CreateDynamicView (Inbox)"), dwRes);
        return dwRes;
    }

    //
    // Create SentItems view
    //
    dwRes = CreateDynamicView (dwChildID++,
                               CLIENT_SENT_ITEMS_VIEW,
                               RUNTIME_CLASS(CFolderListView),
                               pDoc,
                               (PINT)SentItemsColumnsUsed,
                               SENT_ITEMS_DEF_COL_NUM,
                               (CFolderListView **)&m_pSentItemsView,
                               FOLDER_TYPE_SENT_ITEMS);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CMainFrame::CreateDynamicView (SentItems)"), dwRes);
        return dwRes;
    }

    //
    // Create Outbox view
    //
    dwRes = CreateDynamicView (dwChildID++,
                               CLIENT_OUTBOX_VIEW,
                               RUNTIME_CLASS(CFolderListView),
                               pDoc,
                               (PINT)OutboxColumnsUsed,
                               OUTBOX_DEF_COL_NUM,
                               (CFolderListView **)&m_pOutboxView,
                               FOLDER_TYPE_OUTBOX);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CMainFrame::CreateDynamicView (Outbox)"), dwRes);
        return dwRes;
    }

    return dwRes;
}   // CMainFrame::CreateFolderViews

DWORD   
CMainFrame::CreateDynamicView (
    DWORD             dwChildId, 
    LPCTSTR           lpctstrName, 
    CRuntimeClass*    pViewClass,
    CDocument*        pDoc,
    int*              pColumnsUsed,
    DWORD             dwDefaultColNum,
    CFolderListView** ppNewView,
    FolderType        type
)
/*++

Routine name : CMainFrame::CreateDynamicView

Routine description:

    Creates a new view dynamically

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwChildId       [in ] - New child id (within the splitter) of the view
    lpctstrName     [in ] - Name of the view
    pViewClass      [in ] - Class of the view
    pDoc            [in ] - Pointer to document to attach to the new view
    pColumnsUsed    [in ] - List of columns to use in the view
    dwDefaultColNum [in ] - default column number
    ppNewView       [out] - Pointer to newly created view

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::CreateDynamicView"), dwRes);

    ASSERTION (pDoc);

    CCreateContext contextT;
    contextT.m_pNewViewClass = pViewClass;
    contextT.m_pCurrentDoc = pDoc;
    contextT.m_pNewDocTemplate = pDoc->GetDocTemplate();
    contextT.m_pLastView = NULL;
    contextT.m_pCurrentFrame = NULL;
    try
    {
        *ppNewView = (CFolderListView*)(pViewClass->CreateObject());
        if (NULL == *ppNewView)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT ("CRuntimeClass::CreateObject"), dwRes);
            return dwRes;
        }
    }
    catch (CException *pException)
    {
        TCHAR wszCause[1024];

        pException->GetErrorMessage (wszCause, 1024);
        pException->Delete ();
        VERBOSE (EXCEPTION_ERR,
                 TEXT("CreateObject caused exception : %s"), 
                 wszCause);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        return dwRes;
    }

    (*ppNewView)->SetType(type);

    ASSERT((*ppNewView)->m_hWnd == NULL);       // Not yet created

    DWORD dwStyle = WS_CHILD            |       // Child window (of splitter)
                    WS_BORDER           |       // Has borders
                    LVS_REPORT          |       // Report style
                    LVS_SHAREIMAGELISTS |       // All views use one global image list
                    LVS_SHOWSELALWAYS;          // Always show selected items

    //
    // Create the view 
    //
    CRect rect;
    if (!(*ppNewView)->Create(NULL, 
                              lpctstrName, 
                              dwStyle,
                              rect, 
                              &m_wndSplitter, 
                              dwChildId, 
                              &contextT))
    {
        dwRes = ERROR_GEN_FAILURE;
        CALL_FAIL (WINDOW_ERR, TEXT("CFolderListView::Create"), dwRes);
        //
        // pWnd will be cleaned up by PostNcDestroy
        //
        return dwRes;
    }

    //
    // Init the columns
    //
    dwRes = (*ppNewView)->InitColumns (pColumnsUsed, dwDefaultColNum);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::InitColumns"), dwRes);
    }

    dwRes = (*ppNewView)->ReadLayout(lpctstrName);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::ReadLayout"), dwRes);
    }

    (*ppNewView)->ColumnsToLayout();


    return dwRes;
}   // CMainFrame::CreateDynamicView

void 
CMainFrame::SaveLayout()
/*++

Routine name : CMainFrame::SaveLayout

Routine description:

    saves windows layout to the registry

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CMainFrame::SaveLayout"));

    DWORD dwRes = ERROR_SUCCESS;

    //
    // save folders layout
    //
    dwRes = m_pIncomingView->SaveLayout(CLIENT_INCOMING_VIEW);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::SaveLayout"), dwRes);
    }
    dwRes = m_pInboxView->SaveLayout(CLIENT_INBOX_VIEW);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::SaveLayout"), dwRes);
    }

    dwRes = m_pSentItemsView->SaveLayout(CLIENT_SENT_ITEMS_VIEW);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::SaveLayout"), dwRes);
    }

    dwRes = m_pOutboxView->SaveLayout(CLIENT_OUTBOX_VIEW);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::SaveLayout"), dwRes);
    }
    
    //
    // save main frame layout
    //
    WINDOWPLACEMENT wndpl;
    if(!GetWindowPlacement(&wndpl))
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CMainFrame::GetWindowPlacement"), 0);
    }
    else
    {
        BOOL bRes = TRUE;
        bRes &= theApp.WriteProfileInt(CLIENT_MAIN_FRAME, 
                                       CLIENT_MAXIMIZED, 
                                       (SW_SHOWMAXIMIZED == wndpl.showCmd));
        bRes &= theApp.WriteProfileInt(CLIENT_MAIN_FRAME, 
                                       CLIENT_NORMAL_POS_TOP, 
                                       wndpl.rcNormalPosition.top);
        bRes &= theApp.WriteProfileInt(CLIENT_MAIN_FRAME, 
                                       CLIENT_NORMAL_POS_RIGHT, 
                                       wndpl.rcNormalPosition.right);
        bRes &= theApp.WriteProfileInt(CLIENT_MAIN_FRAME, 
                                       CLIENT_NORMAL_POS_BOTTOM, 
                                       wndpl.rcNormalPosition.bottom);
        bRes &= theApp.WriteProfileInt(CLIENT_MAIN_FRAME, 
                                       CLIENT_NORMAL_POS_LEFT, 
                                       wndpl.rcNormalPosition.left);        

        int cxCur, cxMin;
        m_wndSplitter.GetColumnInfo(0, cxCur, cxMin);
        bRes &= theApp.WriteProfileInt(CLIENT_MAIN_FRAME, CLIENT_SPLITTER_POS, cxCur);
        if (!bRes)
        {
            VERBOSE (DBG_MSG, TEXT("Could not save one or more window positions"));
        }
    }
}

LRESULT 
CMainFrame::OnQueryEndSession(
    WPARAM, 
    LPARAM
)
/*++

Routine name : CMainFrame::OnQueryEndSession

Routine description:

    The system shutdown message handler
    Saves windows layout to the registry

Return Value:

    TRUE If the application can terminate conveniently
    FALSE otherwise

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnQueryEndSession"));

    SaveLayout();

    return TRUE;
}

void 
CMainFrame::OnClose() 
/*++

Routine name : CMainFrame::OnClose

Routine description:

    saves windows layout to the registry

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnClose"));

    SaveLayout();

    CFrameWnd::OnClose();
}

void 
CMainFrame::FrameToSavedLayout()
/*++

Routine name : CMainFrame::FrameToSavedLayout

Routine description:

    reads main frame size and position from registry and resize the window

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CMainFrame::FrameToSavedLayout"));

    WINDOWPLACEMENT wndpl;
    if(!GetWindowPlacement(&wndpl))
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CMainFrame::GetWindowPlacement"), 0);
        return;
    }

    wndpl.rcNormalPosition.top = theApp.GetProfileInt(CLIENT_MAIN_FRAME, 
                                                    CLIENT_NORMAL_POS_TOP, -1);
    wndpl.rcNormalPosition.right = theApp.GetProfileInt(CLIENT_MAIN_FRAME, 
                                                    CLIENT_NORMAL_POS_RIGHT, -1);
    wndpl.rcNormalPosition.bottom = theApp.GetProfileInt(CLIENT_MAIN_FRAME, 
                                                    CLIENT_NORMAL_POS_BOTTOM, -1);
    wndpl.rcNormalPosition.left = theApp.GetProfileInt(CLIENT_MAIN_FRAME, 
                                                        CLIENT_NORMAL_POS_LEFT, -1);

    if(wndpl.rcNormalPosition.top    < 0 || wndpl.rcNormalPosition.right < 0 ||
       wndpl.rcNormalPosition.bottom < 0 ||  wndpl.rcNormalPosition.left < 0)
    {
        VERBOSE (DBG_MSG, TEXT("Could not load one or more window positions"));
        return;
    }

    if(!SetWindowPlacement(&wndpl))
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CMainFrame::SetWindowPlacement"), 0);
    }
}

void 
CMainFrame::SplitterToSavedLayout()
{
    DBG_ENTER(TEXT("CMainFrame::SplitterToSavedLayout"));
    //
    // set splitter position according to saved value
    //
    int xPos = theApp.GetProfileInt(CLIENT_MAIN_FRAME, CLIENT_SPLITTER_POS, -1);
    if(xPos < 0)
    {
        VERBOSE (DBG_MSG, TEXT("Could not load splitter position"));
        return;
    }
    
    m_wndSplitter.SetColumnInfo(0, xPos, 10);
}


void 
CMainFrame::ActivateFrame(
    int nCmdShow
) 
{
    //
    // maximize according to saved value
    //
    BOOL bMaximized = theApp.GetProfileInt(CLIENT_MAIN_FRAME, CLIENT_MAXIMIZED, 0);
    if (bMaximized)
    {
        nCmdShow = SW_SHOWMAXIMIZED;
    }
    CFrameWnd::ActivateFrame(nCmdShow);
}

//
// MAX_NUM_SERVERS is defined to limit the range of messages we consider 
// as server notification. 
// 
#define MAX_NUM_SERVERS             256

LRESULT 
CMainFrame::WindowProc( 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam 
)
/*++

Routine name : CMainFrame::WindowProc

Routine description:

    Handle windows messages before MFC dispatches them.
    Here we handle notification messages from the servers.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    message           [in]     - Specifies the Windows message to be processed
    wParam            [in]     - 
    lParam            [in]     - 

Return Value:

    TRUE if mesage was handled by the function, FALSE otherwise.

--*/
{
    BOOL bRes = FALSE;  
    BOOL bBadMsg = FALSE;
    if ((WM_SERVER_NOTIFY_BASE > message) ||
        (WM_SERVER_NOTIFY_BASE + MAX_NUM_SERVERS < message))
    {
        //
        // This is not a server notification message
        //
        return CFrameWnd::WindowProc(message, wParam, lParam);
    }
    //
    // From now on, we're dealing with a server notification
    //
    DBG_ENTER(TEXT("CMainFrame::WindowProc"), 
              bRes, 
              TEXT("Msg=0x%08x, lParam=0x%08x, wParam=0x%08x"),
              message,
              lParam,
              wParam);

    //
    // This message should not be processed any more
    //
    bRes = TRUE;
    //
    // Try looking up the server node for which this message is intended
    //
    CServerNode *pServer = CServerNode::LookupServerFromMessageId (message);
    FAX_EVENT_EX *pEvent = (FAX_EVENT_EX *)(lParam);
    ASSERTION (pEvent);
    ASSERTION (sizeof (FAX_EVENT_EX) == pEvent->dwSizeOfStruct);
    if (pServer)
    {
        //
        // Tell the server a notification has arrived for it
        //
        VERBOSE (DBG_MSG, TEXT("Message was coming from %s"), pServer->Machine());
        try
        {
            //
            // Protect against bogus messages
            //
            DWORD dwRes = pServer->OnNotificationMessage (pEvent);
            if (ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::OnNotificationMessage"), dwRes);
            }
        }            
        catch (...)
        {
            bBadMsg = TRUE;
        }
    }
    else
    {
        VERBOSE (DBG_MSG, TEXT("Got server notification - No server found as sink"));
    }
    //
    // Processed or not - delete the message
    //
    if (!bBadMsg)
    {
        try
        {
            //
            // Protect against bogus messages
            // ... and ...
            // Plant a special value here to catch reuse of the same pointer
            //
            pEvent->dwSizeOfStruct = 0xbabe;
            FaxFreeBuffer (pEvent);
        }        
        catch (...)
        {
            bBadMsg = TRUE;
        }
    }        
    if (bBadMsg)
    {
        VERBOSE (GENERAL_ERR, TEXT("Exception while processing windows message as notification"));
        ASSERTION_FAILURE;
    }    
    return bRes;
} // CMainFrame::WindowProc

void 
CMainFrame::OnToolsAdminConsole()
{
    DBG_ENTER(TEXT("CMainFrame::OnToolsAdminConsole"));
	InvokeServiceManager(m_hWnd, GetResourceHandle(), IDS_ADMIN_CONSOLE_TITLE);
}

void 
CMainFrame::OnToolsConfigWizard()
/*++

Routine name : CMainFrame::OnToolsConfigWizard

Routine description:

    Fax Configuration Wizard invocation

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnToolsConfigWizard"));

    //
    // explicit launch
    //
    theApp.LaunchConfigWizard(TRUE);
}

void 
CMainFrame::OnToolsMonitor()
/*++

Routine name : CMainFrame::OnToolsMonitor

Routine description:

    Open Fax Monitor dialog

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnToolsMonitor"));

    HWND hWndFaxMon = ::FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hWndFaxMon) 
    {
        ::PostMessage(hWndFaxMon, WM_FAXSTAT_OPEN_MONITOR, 0, 0);
    }
}

void 
CMainFrame::OnToolsFaxPrinterProps()
/*++

Routine name : CMainFrame::OnToolsFaxPrinterProps

Routine description:

    Open Fax Printer Properties dialog

Return Value:

  none

--*/ 
{
    DBG_ENTER(TEXT("CMainFrame::OnToolsMonitor"));
    //
    // Open fax printer properties
    //
    FaxPrinterProperty(0);
}

void 
CMainFrame::OnUpdateWindowsXPTools(
    CCmdUI* pCmdUI
)
/*++

Routine name : CMainFrame::OnToolsConfigWizard

Routine description:

    Delete Fax Configuration Wizard and Admin Console 
    menu items for non Windows XP plarform

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnUpdateConfigWizard"));
    
    if(pCmdUI->m_pMenu)
    {
        if(!IsWinXPOS())
        {
            pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_CONFIG_WIZARD,     MF_BYCOMMAND);
            pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_ADMIN_CONSOLE,     MF_BYCOMMAND);
            pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_MONITOR,           MF_BYCOMMAND);
            pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_FAX_PRINTER_PROPS, MF_BYCOMMAND);
        }
        else
        {
            //
            // Windows XP OS - check SKU
            //
            if (IsDesktopSKU() || !IsFaxComponentInstalled(FAX_COMPONENT_ADMIN))
            {
                pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_ADMIN_CONSOLE, MF_BYCOMMAND);
            }

            if(!IsFaxComponentInstalled(FAX_COMPONENT_CONFIG_WZRD))
            {
                pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_CONFIG_WIZARD, MF_BYCOMMAND);
            } 

            if(!IsFaxComponentInstalled(FAX_COMPONENT_MONITOR))
            {
                pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_MONITOR, MF_BYCOMMAND);
            }

            //
            // Local fax printer properties
            //
            CClientConsoleDoc* pDoc = (CClientConsoleDoc*)GetActiveDocument();
            if(NULL == pDoc)
            {
                ASSERTION_FAILURE;
                return;
            }
            //
            // Find local fax server
            // if it is not installed disable the menu item
            //
            if(!pDoc->FindServerByName(NULL) || !IsFaxComponentInstalled(FAX_COMPONENT_DRIVER_UI))
            {
                pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_FAX_PRINTER_PROPS, MF_BYCOMMAND);
            }            
        }

        if(pCmdUI->m_pMenu->GetMenuItemCount() == 4)
        {
            //
            // delete the menu separator
            //
            pCmdUI->m_pMenu->DeleteMenu(3, MF_BYPOSITION);
        }
    }
}

void 
CMainFrame::OnUpdateSendNewFax(
    CCmdUI* pCmdUI
)
{ 
    BOOL bEnable = FALSE;

    CClientConsoleDoc* pDoc = (CClientConsoleDoc*)GetActiveDocument();
    if(NULL != pDoc)
    {
        bEnable = pDoc->IsSendFaxEnable();
    }

    pCmdUI->Enable(bEnable); 
}


void 
CMainFrame::OnUpdateReceiveNewFax(
    CCmdUI* pCmdUI
)
{ 
    BOOL bEnable = FALSE;

    if (IsWinXPOS ())
    {   
        //
        // Receive now works only in Windows XP
        //
        CClientConsoleDoc* pDoc = (CClientConsoleDoc*)GetActiveDocument();
        if(NULL != pDoc)
        {
            bEnable = pDoc->CanReceiveNow();
        }
    }
    pCmdUI->Enable(bEnable); 
}

void 
CMainFrame::OnReceiveNewFax()
/*++

Routine name : CMainFrame::OnReceiveNewFax

Routine description:

    Starts receiving now

Author:

    Eran Yariv (EranY). Mar, 2001

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnReceiveNewFax"));

    HWND hWndFaxMon = ::FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hWndFaxMon) 
    {
        ::PostMessage(hWndFaxMon, WM_FAXSTAT_RECEIVE_NOW, 0, 0);
    }
}   // CMainFrame::OnReceiveNewFax
    

void 
CMainFrame::OnSendNewFax()
/*++

Routine name : CMainFrame::OnSendNewFax

Routine description:

    start send fax wizard

Author:

    Alexander Malysh (AlexMay), Feb, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::OnSendNewFax"));
    
    //
    // get send fax wizard location
    //
    CString cstrFaxSend;
    dwRes = GetAppLoadPath(cstrFaxSend);
    if(ERROR_SUCCESS != dwRes)
    {
        PopupError(dwRes);
        CALL_FAIL (GENERAL_ERR, TEXT("GetAppLoadPath"), dwRes);
        return;
    }

    try
    {
        cstrFaxSend += FAX_SEND_IMAGE_NAME;
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        PopupError(dwRes);
        CALL_FAIL (MEM_ERR, TEXT("CString::operator+"), dwRes);
        return ;
    }

    //
    // start send fax wizard
    //
    HINSTANCE hWizard = ShellExecute(NULL, 
                                     TEXT("open"), 
                                     cstrFaxSend, 
                                     NULL, 
                                     NULL, 
                                     SW_RESTORE 
                                    );    
    if((DWORD_PTR)hWizard <= 32)
    {
        //
        // error
        //
        dwRes = PtrToUlong(hWizard);
        PopupError(dwRes);
        CALL_FAIL (GENERAL_ERR, TEXT("ShellExecute"), dwRes);
        return;
    }

} // CMainFrame::OnSendNewFax

void 
CMainFrame::OnViewOptions()
{
    DBG_ENTER(TEXT("CMainFrame::OnViewOptions"));

    CUserInfoDlg userInfo;
    if(userInfo.DoModal() == IDABORT)
    {
        DWORD dwRes = userInfo.GetLastDlgError();
        CALL_FAIL (GENERAL_ERR, TEXT("CUserInfoDlg::DoModal"), dwRes);
        PopupError(dwRes);
    }
}

void
CMainFrame::OnToolsCoverPages()
{
    DBG_ENTER(TEXT("CMainFrame::OnToolsCoverPages"));

    CCoverPagesDlg cpDlg;
    if(cpDlg.DoModal() == IDABORT)
    {
        DWORD dwRes = cpDlg.GetLastDlgError();
        CALL_FAIL (GENERAL_ERR, TEXT("CCoverPagesDlg::DoModal"), dwRes);
        PopupError(dwRes);
    }
}

void 
CMainFrame::OnSettingChange(
    UINT uFlags, 
    LPCTSTR lpszSection
) 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::OnSettingChange"));

    CFrameWnd::OnSettingChange(uFlags, lpszSection);

    if(lpszSection && !_tcscmp(lpszSection, TEXT("devices")))
    {
        //
        // some change in the system devices
        //
        CClientConsoleDoc* pDoc = (CClientConsoleDoc*)GetActiveDocument();
        if(NULL != pDoc)
        {
            dwRes = pDoc->RefreshServersList();
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CClientConsoleDoc::RefreshServersList"), dwRes);
            }
        }
    }
} // CMainFrame::OnSettingChange


LONG 
CMainFrame::OnHelp(
    UINT wParam, 
    LONG lParam
)
/*++

Routine name : CMainFrame::OnHelp

Routine description:

    F1 key handler

Author:

    Alexander Malysh (AlexMay), Mar, 2000

Arguments:

    wParam                        [in]     - 
    lParam                        [in]     - LPHELPINFO

Return Value:

    LONG

--*/
{  
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::OnHelp"));

    if(!IsFaxComponentInstalled(FAX_COMPONENT_HELP_CLIENT_CHM))
    {
        //
        // The help file is not installed
        //
        return TRUE;
    }

    if(NULL != m_pLeftView)
    {
        dwRes = m_pLeftView->OpenHelpTopic();
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CLeftView::OpenHelpTopic"),dwRes);
        }
    }
    else
    {
        OnHelpContents();
    }

    return TRUE;
}

void 
CMainFrame::OnUpdateHelpContents(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(IsFaxComponentInstalled(FAX_COMPONENT_HELP_CLIENT_CHM));
}

void 
CMainFrame::OnHelpContents()
/*++

Routine name : CMainFrame::OnHelpContents

Routine description:

    Help Contents menu item handler

Author:

    Alexander Malysh (AlexMay), Mar, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::OnHelpContents"));

    dwRes = ::HtmlHelpTopic(m_hWnd, FAX_HELP_WELCOME);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("HtmlHelpTopic"),dwRes);
    }
}

void 
CMainFrame::OnUpdateServerStatus(
    CCmdUI* pCmdUI
)
{
    BOOL bEnable = FALSE;

    CClientConsoleDoc* pDoc = (CClientConsoleDoc*)GetActiveDocument();
    if(NULL != pDoc)
    {
        bEnable = pDoc->GetServerCount() > 0;
    }

    pCmdUI->Enable(bEnable);
}

void 
CMainFrame::OnToolsServerStatus()
{
    DBG_ENTER(TEXT("CMainFrame::OnToolsServerStatus"));

    CClientConsoleDoc* pDoc = (CClientConsoleDoc*)GetActiveDocument();
    if(pDoc->GetServerCount() == 0)
    {
        //
        // no fax printer install
        //
        return;
    }

    CServerStatusDlg srvStatus(pDoc);
    if(srvStatus.DoModal() == IDABORT)
    {
        DWORD dwRes = srvStatus.GetLastDlgError();
        CALL_FAIL (GENERAL_ERR, TEXT("CServerStatusDlg::DoModal"), dwRes);
        PopupError(dwRes);
    }
}
void 
CMainFrame::OnImportSentItems()
{
    ImportArchive(TRUE);
}

void 
CMainFrame::OnImportInbox()
{
    ImportArchive(FALSE);
}


void 
CMainFrame::ImportArchive(
    BOOL bSentArch
)
/*++

Routine name : CMainFrame::ImportArchive

Routine description:

    Import W2K MS faxes into the fax archive

Arguments:

    bSentArch - [in] TRUE for Sent Items, FALSE for Inbox

Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::ImportArchive"));

#ifdef UNICODE

    HKEY   hRegKey;
    DWORD  dwSize;
    DWORD  dwFlags = 0;
    WCHAR* pszFolder = NULL;

    CFolderDialog dlgFolder;

    //
    // Read initial import folder
    //
    if ((hRegKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, TRUE, KEY_QUERY_VALUE)))
    {
        if(bSentArch)
        {
            pszFolder = GetRegistryString(hRegKey, REGVAL_W2K_SENT_ITEMS, NULL);
        }
        else
        {
            pszFolder = GetRegistryStringMultiSz(hRegKey, REGVAL_W2K_INBOX, NULL, &dwSize);
        }

        RegCloseKey(hRegKey);
    }
    else
    {
        CALL_FAIL(GENERAL_ERR, TEXT("OpenRegistryKey"), GetLastError());
    }
    dwRes = dlgFolder.Init(pszFolder, bSentArch ? IDS_IMPORT_TITLE_SENTITEMS : IDS_IMPORT_TITLE_INBOX);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("CMainFrame::ImportArchive"), dwRes);
        goto exit;
    }

    //
    // Display Browse for folder dialog
    //
    if (IsWinXPOS())
    {
        //
        // The new BIF_NONEWFOLDERBUTTON is only defined for WinXP and above
        //
        dwFlags = BIF_NONEWFOLDERBUTTON;
    }

    if(IDOK != dlgFolder.DoModal(dwFlags))
    {
        goto exit;
    }

    //
    // Import the selected folder
    //
    dwRes = ImportArchiveFolderUI(dlgFolder.GetSelectedFolder(), bSentArch, m_hWnd);   
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("ImportArchiveFolderUI"), dwRes);
    }

exit:

    MemFree(pszFolder);

#endif // UNICODE

}

void 
CMainFrame::OnUpdateImportSent(CCmdUI* pCmdUI)
{
    if(pCmdUI->m_pMenu)
    {
        if(!IsWinXPOS())
        {

            //
            // Delete the Import menu item and separator for non Windows XP OS
            //
            pCmdUI->m_pMenu->DeleteMenu(15, MF_BYPOSITION);
            pCmdUI->m_pMenu->DeleteMenu(14, MF_BYPOSITION);
        }
    }
}

afx_msg void 
CMainFrame::OnSysColorChange()
{
    //
    // Refresh the image lists we use - force it to refresh
    // Since the image list are static FolderListView members (shared between all instances),
    // we just pick any instance and call it's refresh function with bForce=TRUE.
    //
    if (m_pIncomingView)
    {
        m_pIncomingView->RefreshImageLists(TRUE);
        m_pIncomingView->Invalidate ();
    }
    if (m_pInboxView)
    {
        m_pInboxView->RefreshImageLists(FALSE);
        m_pInboxView->Invalidate ();
    }
    if (m_pSentItemsView)
    {
        m_pSentItemsView->RefreshImageLists(FALSE);
        m_pSentItemsView->Invalidate ();
    }
    if (m_pOutboxView)
    {
        m_pOutboxView->RefreshImageLists(FALSE);
        m_pOutboxView->Invalidate ();
    }
    if (m_pLeftView)
    {
        m_pLeftView->RefreshImageList ();
        m_pLeftView->Invalidate();
    }
    if (m_pInitialRightPaneView)
    {
        m_pInitialRightPaneView->GetListCtrl().SetBkColor(::GetSysColor(COLOR_WINDOW));
    }
}   // CMainFrame::OnSysColorChange
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\job.cpp ===
// Job.cpp: implementation of the CJob class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     17

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CJob, CObject)

DWORD
CJob::Init (
    PFAX_JOB_ENTRY_EX pJob,
    CServerNode* pServer
)
/*++

Routine name : CJob::Init

Routine description:

    Constructs a new job from a FAX_JOB_ENTRY_EX structure

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pJob            [in] - Pointer to FAX_JOB_ENTRY_EX structure
    pServer         [in] - pointer to CServerNode object

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CJob::Init"), dwRes);

    ASSERTION (pServer);
    m_pServer = pServer;

    ASSERTION (!m_bValid);

    m_dwJobOnlyValidityMask = pJob->dwValidityMask;

    try
    {
        //
        // Message id
        //
        ASSERTION (m_dwJobOnlyValidityMask & FAX_JOB_FIELD_MESSAGE_ID );
        m_dwlMessageId = pJob->dwlMessageId;

        //
        // Broadcast id
        //
        m_dwlBroadcastId = (m_dwJobOnlyValidityMask & FAX_JOB_FIELD_BROADCAST_ID) ?
                            pJob->dwlBroadcastId : 0;

        //
        // Recipient info
        //
        m_cstrRecipientNumber = pJob->lpctstrRecipientNumber ?
                                pJob->lpctstrRecipientNumber : TEXT("");
        m_cstrRecipientName   = pJob->lpctstrRecipientName ?
                                pJob->lpctstrRecipientName : TEXT("");
        //
        // Sender info
        //
        m_cstrSenderUserName = pJob->lpctstrSenderUserName ?
                               pJob->lpctstrSenderUserName : TEXT("");
        m_cstrBillingCode    = pJob->lpctstrBillingCode ?
                               pJob->lpctstrBillingCode : TEXT("");
        //
        // Document info
        //
        m_cstrDocumentName = pJob->lpctstrDocumentName ?
                             pJob->lpctstrDocumentName : TEXT("");
        m_cstrSubject      = pJob->lpctstrSubject ?
                             pJob->lpctstrSubject : TEXT("");

        //
        // Server name
        //
        m_cstrServerName = m_pServer->Machine();

        //
        // Original scheduled time
        //
        if (m_dwJobOnlyValidityMask & FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME)
        {
            m_tmOriginalScheduleTime = pJob->tmOriginalScheduleTime;
        }
        else
        {
            m_tmOriginalScheduleTime.Zero ();
        }
        //
        // Submission time
        //
        if (m_dwJobOnlyValidityMask & FAX_JOB_FIELD_SUBMISSION_TIME)
        {
            m_tmSubmissionTime = pJob->tmSubmissionTime;
        }
        else
        {
            m_tmSubmissionTime.Zero ();
        }
        //
        // Priority
        //
        if (m_dwJobOnlyValidityMask & FAX_JOB_FIELD_PRIORITY)
        {
            m_Priority = pJob->Priority;
            ASSERTION (m_Priority <= FAX_PRIORITY_TYPE_HIGH);
        }
        else
        {
            m_Priority = (FAX_ENUM_PRIORITY_TYPE)-1;
        }
    }
    catch (CException *pException)
    {
        TCHAR wszCause[1024];

        pException->GetErrorMessage (wszCause, 1024);
        pException->Delete ();
        VERBOSE (EXCEPTION_ERR,
                 TEXT("CJob::Init caused exception : %s"),
                 wszCause);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        return dwRes;
    }

    m_bValid = TRUE;

    m_dwPossibleOperations = 0;
    if (m_dwJobOnlyValidityMask & FAX_JOB_FIELD_STATUS_SUB_STRUCT)
    {
        //
        // Now update the status
        //
        dwRes = UpdateStatus (pJob->pStatus);
    }
    else
    {
        //
        // No status
        //
        VERBOSE (DBG_MSG, TEXT("Job id 0x%016I64x has no status"), m_dwlMessageId);
        m_dwValidityMask = m_dwJobOnlyValidityMask;
        ASSERTION_FAILURE;
    }
    return dwRes;
}   // CJob::Init

BOOL  
CJob::IsNewStatus (
    PFAX_JOB_STATUS pStatus
)
/*++

Routine name : CJob::IsNewStatus

Routine description:

    Check if the new status deffer from the current one

Arguments:

    pStatus    [in] - Pointer to a new status structure

Return Value:

    TRUE if the new status deffer from the current one
    FALSE otherwize

--*/
{
    DBG_ENTER(TEXT("CJob::IsNewStatus"));

    ASSERTION (pStatus);

    if(m_dwValidityMask          != (m_dwJobOnlyValidityMask | (pStatus->dwValidityMask)) ||
       m_dwJobID                 != pStatus->dwJobID                                      ||
       m_dwJobType               != pStatus->dwJobType                                    ||       
       m_dwQueueStatus           != pStatus->dwQueueStatus                                ||
       m_dwExtendedStatus        != pStatus->dwExtendedStatus                             ||
       m_dwSize                  != pStatus->dwSize                                       ||
       m_dwPageCount             != pStatus->dwPageCount                                  ||
       m_dwCurrentPage           != pStatus->dwCurrentPage                                ||
       m_tmScheduleTime          != pStatus->tmScheduleTime                               ||
       m_tmTransmissionStartTime != pStatus->tmTransmissionStartTime                      ||
       m_tmTransmissionEndTime   != pStatus->tmTransmissionEndTime                        ||
       m_dwDeviceID              != pStatus->dwDeviceID                                   ||
       m_dwRetries               != pStatus->dwRetries                                    ||
       m_dwPossibleOperations    != (pStatus->dwAvailableJobOperations | FAX_JOB_OP_PROPERTIES))
    {
        return TRUE;
    }

    if((pStatus->lpctstrExtendedStatus && m_cstrExtendedStatus.Compare(pStatus->lpctstrExtendedStatus)) ||
       (pStatus->lpctstrTsid           && m_cstrTsid.Compare(pStatus->lpctstrTsid))                     ||
       (pStatus->lpctstrCsid           && m_cstrCsid.Compare(pStatus->lpctstrCsid))                     ||
       (pStatus->lpctstrDeviceName     && m_cstrDeviceName.Compare(pStatus->lpctstrDeviceName))         ||
       (pStatus->lpctstrCallerID       && m_cstrCallerID.Compare(pStatus->lpctstrCallerID))             ||
       (pStatus->lpctstrRoutingInfo    && m_cstrRoutingInfo.Compare(pStatus->lpctstrRoutingInfo)))
    {
        return TRUE;
    }

    return FALSE;
} // CJob::IsNewStatus

DWORD
CJob::UpdateStatus (
    PFAX_JOB_STATUS pStatus
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CJob::UpdateStatus"), dwRes);

    ASSERTION (m_bValid);
    ASSERTION (pStatus);

    m_dwValidityMask = m_dwJobOnlyValidityMask | (pStatus->dwValidityMask);

    try
    {
        //
        // Job id
        //
        ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_JOB_ID);
        m_dwJobID = pStatus->dwJobID;
        //
        // Job type
        //
        ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_TYPE);
        m_dwJobType = pStatus->dwJobType;
        //
        // Queue status
        //
        ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_QUEUE_STATUS);
        m_dwQueueStatus = pStatus->dwQueueStatus;
        //
        // Extended status
        //
        m_dwExtendedStatus = pStatus->dwExtendedStatus;
        m_cstrExtendedStatus = pStatus->lpctstrExtendedStatus;
        //
        // Size
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_SIZE)
        {
            m_dwSize = pStatus->dwSize;
        }
        else
        {
            m_dwSize = 0;
        }
        //
        // Page count
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_PAGE_COUNT)
        {
            m_dwPageCount = pStatus->dwPageCount;
        }
        else
        {
            m_dwPageCount = 0;
        }
        //
        // Current page
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_CURRENT_PAGE)
        {
            m_dwCurrentPage = pStatus->dwCurrentPage;
        }
        else
        {
            m_dwCurrentPage = 0;
        }
        //
        // TCID and CSID
        //
        m_cstrTsid = pStatus->lpctstrTsid;
        m_cstrCsid = pStatus->lpctstrCsid;
        //
        // Scheduled time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_SCHEDULE_TIME)
        {
            m_tmScheduleTime = pStatus->tmScheduleTime;
        }
        else
        {
            m_tmScheduleTime.Zero ();
        }
        //
        // Start time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME)
        {
            m_tmTransmissionStartTime = pStatus->tmTransmissionStartTime;
        }
        else
        {
            m_tmTransmissionStartTime.Zero ();
        }

        //
        // End time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME)
        {
            m_tmTransmissionEndTime = pStatus->tmTransmissionEndTime;
        }
        else
        {
            m_tmTransmissionEndTime.Zero ();
        }

        //
        // Device
        //
        m_dwDeviceID = pStatus->dwDeviceID;
        m_cstrDeviceName = pStatus->lpctstrDeviceName;
        //
        // Retries
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_RETRIES)
        {
            m_dwRetries = pStatus->dwRetries;
        }
        else
        {
            m_dwRetries = 0;
        }
        //
        // Caller id and routing info
        //
        m_cstrCallerID = pStatus->lpctstrCallerID;
        m_cstrRoutingInfo = pStatus->lpctstrRoutingInfo;

        //
        // possible job operations
        //
        m_dwPossibleOperations = pStatus->dwAvailableJobOperations | FAX_JOB_OP_PROPERTIES;
    }
    catch (CException *pException)
    {
        TCHAR wszCause[1024];

        pException->GetErrorMessage (wszCause, 1024);
        pException->Delete ();
        VERBOSE (EXCEPTION_ERR,
                 TEXT("CJob::UpdateStatus caused exception : %s"),
                 wszCause);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        m_bValid = FALSE;
        return dwRes;
    }

    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CJob::UpdateStatus

const JobStatusType
CJob::GetStatus () const
/*++

Routine name : CJob::GetStatus

Routine description:

    Finds the current job status

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Job status

--*/
{
    DBG_ENTER(TEXT("CJob::GetStatus"));

    ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_STATUS_SUB_STRUCT);
    ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_QUEUE_STATUS);

    DWORD dwQueueStatus = m_dwQueueStatus;
    //
    // Start by checking status modifiers:
    //
    if (dwQueueStatus & JS_PAUSED)
    {
        return JOB_STAT_PAUSED;
    }
    //
    // We igonre the JS_NOLINE modifier.
    // Remove the modifiers now.
    //
    dwQueueStatus &= ~(JS_PAUSED | JS_NOLINE);
    //
    // Check other status values
    //
    switch (dwQueueStatus)
    {
        case JS_PENDING:
            return JOB_STAT_PENDING;
        case JS_INPROGRESS:
        case JS_FAILED:      // The job is about to be deleted in a sec. Do not update status.
            return JOB_STAT_INPROGRESS;
        case JS_DELETING:
            return JOB_STAT_DELETING;
        case JS_RETRYING:
            return JOB_STAT_RETRYING;
        case JS_RETRIES_EXCEEDED:
            return JOB_STAT_RETRIES_EXCEEDED;
        case JS_COMPLETED:
            return JOB_STAT_COMPLETED;
        case JS_CANCELED:
            return JOB_STAT_CANCELED;
        case JS_CANCELING:
            return JOB_STAT_CANCELING;
        case JS_ROUTING:
            return JOB_STAT_ROUTING;
        default:
            ASSERTION_FAILURE;
            return (JobStatusType)-1;
    }
}   // CJob::StatusValue


DWORD
CJob::GetTiff (
    CString &cstrTiffLocation
) const
/*++

Routine name : CJob::GetTiff

Routine description:

    Retrieves the job's TIFF file from the server

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    cstrTiffLocation              [out]    - Name of TIFF file

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CJob::GetTiff"), dwRes);

    dwRes = CopyTiffFromServer (m_pServer,
                                m_dwlMessageId,
                                FAX_MESSAGE_FOLDER_QUEUE,
                                cstrTiffLocation);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CopyTiffFromServer"), dwRes);
    }
    return dwRes;
}   // CJob::GetTiff

DWORD
CJob::DoJobOperation (
    DWORD dwJobOp
)
/*++

Routine name : CJob::DoJobOperation

Routine description:

    Performs an operation on the job

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwJobOp   [in]     - Operation.
                         Supported operations are:
                         FAX_JOB_OP_PAUSE, FAX_JOB_OP_RESUME,
                         FAX_JOB_OP_RESTART, and FAX_JOB_OP_DELETE.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CJob::DoJobOperation"), dwRes);
    DWORD dwJobCommand;
    switch (dwJobOp)
    {
        case FAX_JOB_OP_PAUSE:
            dwJobCommand = JC_PAUSE;
            break;

        case FAX_JOB_OP_RESUME:
            dwJobCommand = JC_RESUME;
            break;

        case FAX_JOB_OP_RESTART:
            dwJobCommand = JC_RESTART;
            break;

        case FAX_JOB_OP_DELETE:
            dwJobCommand = JC_DELETE;
            break;

        default:
            ASSERTION_FAILURE;
            dwRes = ERROR_CAN_NOT_COMPLETE;
            return dwRes;
    }
    if (!(dwJobOp & GetPossibleOperations()))
    {
        VERBOSE (DBG_MSG, TEXT("Job can no longer do operation"));
        dwRes = ERROR_CAN_NOT_COMPLETE;
        return dwRes;
    }
    HANDLE hFax;
    dwRes = m_pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::GetConnectionHandle"), dwRes);
        return dwRes;
    }

    FAX_JOB_ENTRY fje = {0};
    fje.SizeOfStruct = sizeof(FAX_JOB_ENTRY);

    START_RPC_TIME(TEXT("FaxSetJob"));
    if (!FaxSetJob (hFax,
                    m_dwJobID,
                    dwJobCommand,
                    &fje))
    {
        dwRes = GetLastError ();
        END_RPC_TIME(TEXT("FaxSetJob"));
        m_pServer->SetLastRPCError (dwRes);
        CALL_FAIL (RPC_ERR, TEXT("FaxSetJob"), dwRes);
        return dwRes;
    }
    END_RPC_TIME(TEXT("FaxSetJob"));

    //
    // Update job status and possible operations
    //
    switch (dwJobOp)
    {
        case FAX_JOB_OP_PAUSE:
            m_dwQueueStatus |= JS_PAUSED;
            m_dwPossibleOperations &= ~FAX_JOB_OP_PAUSE;
            m_dwPossibleOperations |= FAX_JOB_OP_RESUME;
            break;

        case FAX_JOB_OP_RESUME:
            m_dwQueueStatus &= ~JS_PAUSED;
            m_dwPossibleOperations &= ~FAX_JOB_OP_RESUME;
            m_dwPossibleOperations |= FAX_JOB_OP_PAUSE;
            break;

        case FAX_JOB_OP_RESTART:
            m_dwQueueStatus = JS_PENDING;
            m_dwPossibleOperations &= ~FAX_JOB_OP_RESTART;
            m_dwPossibleOperations |= FAX_JOB_OP_PAUSE;
            break;

        case FAX_JOB_OP_DELETE:
            m_dwPossibleOperations &= ~FAX_JOB_OP_DELETE;
            break;

        default:
            break;
    }

    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CJob::DoJobOperation


DWORD
CJob::Copy(
    const CJob& other
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CJob::Copy"), dwRes);

    try
    {
        m_dwlMessageId = other.m_dwlMessageId;
        m_dwlBroadcastId = other.m_dwlBroadcastId;
        m_dwValidityMask = other.m_dwValidityMask;
        m_dwJobOnlyValidityMask = other.m_dwJobOnlyValidityMask;
        m_dwJobID = other.m_dwJobID;
        m_dwJobType = other.m_dwJobType;
        m_dwQueueStatus = other.m_dwQueueStatus;
        m_dwExtendedStatus = other.m_dwExtendedStatus;
        m_dwSize = other.m_dwSize;
        m_dwPageCount = other.m_dwPageCount;
        m_dwCurrentPage = other.m_dwCurrentPage;
        m_dwDeviceID = other.m_dwDeviceID;
        m_dwRetries = other.m_dwRetries;
        m_cstrRecipientNumber = other.m_cstrRecipientNumber;
        m_cstrRecipientName = other.m_cstrRecipientName;
        m_cstrSenderUserName = other.m_cstrSenderUserName;
        m_cstrBillingCode = other.m_cstrBillingCode;
        m_cstrDocumentName = other.m_cstrDocumentName;
        m_cstrSubject = other.m_cstrSubject;
        m_cstrExtendedStatus = other.m_cstrExtendedStatus;
        m_cstrTsid = other.m_cstrTsid;
        m_cstrCsid = other.m_cstrCsid;
        m_cstrDeviceName = other.m_cstrDeviceName;
        m_cstrCallerID = other.m_cstrCallerID;
        m_cstrRoutingInfo = other.m_cstrRoutingInfo;
        m_tmOriginalScheduleTime = other.m_tmOriginalScheduleTime;
        m_tmSubmissionTime = other.m_tmSubmissionTime;
        m_tmScheduleTime = other.m_tmScheduleTime;
        m_tmTransmissionStartTime = other.m_tmTransmissionStartTime;
        m_tmTransmissionEndTime = other.m_tmTransmissionEndTime;
        m_Priority = other.m_Priority;
        m_dwPossibleOperations = other.m_dwPossibleOperations;
        m_cstrServerName = other.m_cstrServerName;

        m_bValid = other.m_bValid;
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwRes;

} // CJob::Copy
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__989CC918_D8CD_4A1E_811B_1AEE446A303D__INCLUDED_)
#define AFX_MAINFRM_H__989CC918_D8CD_4A1E_811B_1AEE446A303D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//
// WM_POPUP_ERROR is a message sent to the framework whenever an error
// popup should be displayed. 
// This way, even background threads can popup errors.
//
// WPARAM: Win32 error code
// LPARAM: HiWord = file id, LowWord = line number
// 
#define WM_POPUP_ERROR                      WM_APP + 3

// WM_CONSOLE_SET_ACTIVE_FOLDER is a message sent to the framework whenever 
// a new instance wishes to activate a previous instance and set the active folder.
//
// WPARAM: FolderType value
// LPARAM: unused.
// 
#define WM_CONSOLE_SET_ACTIVE_FOLDER        WM_APP + 4

// WM_CONSOLE_SELECT_ITEM is a message sent to the framework whenever 
// a new instance wishes to activate a previous instance and select a specific item in the startup folder
//
// WPARAM: Low 32-bits of message id
// LPARAM: High 32-bits of message id
// 
#define WM_CONSOLE_SELECT_ITEM              WM_APP + 5

//
// HTML Help topics
//
#define FAX_HELP_WELCOME            TEXT("::/FaxC_C_welcome.htm")
#define FAX_HELP_OUTBOX             TEXT("::/FaxC_C_FaxManageOutCont.htm")
#define FAX_HELP_INBOX              TEXT("::/FaxC_C_FaxArchCont.htm")
#define FAX_HELP_SENTITEMS          TEXT("::/FaxC_C_FaxArchCont.htm")
#define FAX_HELP_INCOMING           TEXT("::/FaxC_C_FaxManageCont.htm")
#define FAX_HELP_IMPORT             TEXT("::/FaxC_H_Import.htm")

#define STATUS_PANE_ITEM_COUNT      1
#define STATUS_PANE_ACTIVITY        2

class CCoverPagesView;

class CMainFrame : public CFrameWnd
{
    
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
protected:
    CSplitterWnd m_wndSplitter;

public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    public:
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void ActivateFrame(int nCmdShow = -1);
    //}}AFX_VIRTUAL

// Implementation
public:
    void SwitchRightPaneView (CListView *pNewView);
    virtual ~CMainFrame();
    CListView* GetRightPane();
    CView *GetActivePane()   { return (CView *) (m_wndSplitter.GetActivePane()); }
    CLeftView *GetLeftView() { return m_pLeftView; }

    CFolderListView    *GetIncomingView()  { return m_pIncomingView;   }
    CFolderListView    *GetInboxView()     { return m_pInboxView;      }
    CFolderListView    *GetSentItemsView() { return m_pSentItemsView;  }
    CFolderListView    *GetOutboxView()    { return m_pOutboxView;     }

    DWORD CreateFolderViews (CDocument *pDoc);

    void RefreshStatusBar ()
    {
        m_wndStatusBar.PostMessage (WM_IDLEUPDATECMDUI);
        m_wndStatusBar.UpdateWindow ();
    }

    LRESULT WindowProc( UINT message, WPARAM wParam, LPARAM lParam );

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;
    CToolBar    m_wndToolBar;
    CReBar      m_wndReBar;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg LRESULT OnPopupError (WPARAM, LPARAM);
    afx_msg LRESULT OnSetActiveFolder (WPARAM, LPARAM);
    afx_msg LRESULT OnSelectItem (WPARAM, LPARAM);
    afx_msg void OnClose();
    afx_msg void OnSysColorChange();
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg LONG OnHelp(UINT wParam, LONG lParam);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:

    afx_msg void OnHelpContents();
    afx_msg void OnRefreshFolder ();
    afx_msg void OnSendNewFax();
    afx_msg void OnReceiveNewFax();
    afx_msg void OnViewOptions();
    afx_msg void OnToolsCoverPages();
    afx_msg void OnToolsServerStatus();
    afx_msg void OnSelectColumns();
    afx_msg void OnToolsConfigWizard();
    afx_msg void OnToolsAdminConsole();
    afx_msg void OnToolsMonitor();
    afx_msg void OnImportSentItems();
    afx_msg void OnImportInbox();
    afx_msg void OnToolsFaxPrinterProps();
    afx_msg void OnUpdateWindowsXPTools(CCmdUI* pCmdUI);
    afx_msg void OnUpdateSelectColumns(CCmdUI* pCmdUI);
    afx_msg void OnUpdateServerStatus(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRefreshFolder(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFolderItemsCount(CCmdUI* pCmdUI);
    afx_msg void OnUpdateActivity(CCmdUI* pCmdUI);
    afx_msg void OnUpdateSendNewFax(CCmdUI* pCmdUI);
    afx_msg void OnUpdateReceiveNewFax(CCmdUI* pCmdUI);
    afx_msg void OnUpdateImportSent(CCmdUI* pCmdUI);
    afx_msg void OnUpdateHelpContents(CCmdUI* pCmdUI);
    afx_msg void OnStatusBarDblClk(NMHDR* pNotifyStruct, LRESULT* result);
    afx_msg LRESULT OnQueryEndSession(WPARAM, LPARAM);

    DWORD   CreateDynamicView (DWORD dwChildId, 
                               LPCTSTR lpctstrName, 
                               CRuntimeClass* pViewClass,
                               CDocument *pDoc,
                               int *pColumnsUsed,
                               DWORD dwDefaultColNum,
                               CFolderListView **ppNewView,
                               FolderType type);

    void SaveLayout();
    void FrameToSavedLayout();
    void SplitterToSavedLayout();

    void ImportArchive(BOOL bSentArch);

    CListView *m_pInitialRightPaneView; // Points to the initial right pane view 
                                        // created during the frame creation.
                                        // This view is used when the tree root is
                                        // selected or when a server node is selected 
                                        // in the tree.

    CLeftView *m_pLeftView;             // Pointer to the left view.
                                        // We must have this here (instead of using GetPane)
                                        // for threads to call the left pane.

    CFolderListView*    m_pIncomingView;   // Pointer to the global view 
                                           // of the incoming folder
    CFolderListView*    m_pInboxView;      // Pointer to the global view 
                                           // of the inbox folder
    CFolderListView*    m_pSentItemsView;  // Pointer to the global view 
                                           // of the sent items folder
    CFolderListView*    m_pOutboxView;     // Pointer to the global view 
                                           // of the outbox folder
};

inline CMainFrame *GetFrm ()       { return (CMainFrame *)AfxGetMainWnd(); }

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__989CC918_D8CD_4A1E_811B_1AEE446A303D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\message.cpp ===
// Message.cpp: implementation of the CArchiveMsg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     13

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CArchiveMsg, CObject)

DWORD 
CArchiveMsg::Init (
    PFAX_MESSAGE pMsg,
    CServerNode* pServer
)
/*++

Routine name : CArchiveMsg::Init

Routine description:

    Constructs a new message from a FAX_MESSAGE structure

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pMsg            [in] - Pointer to FAX_MESSAGE structure
    pServer         [in] - pointer to CServerNode object

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CArchiveMsg::Init"), dwRes);

    ASSERTION(pServer);

    m_pServer = pServer;

    m_bValid = FALSE;
    try
    {
        m_dwValidityMask = pMsg->dwValidityMask;
        //
        // Message id
        //        
        ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_MESSAGE_ID);
        m_dwlMessageId = pMsg->dwlMessageId;

        //
        // Broadcast id
        //
        m_dwlBroadcastId = (m_dwValidityMask & FAX_JOB_FIELD_BROADCAST_ID) ? 
                            pMsg->dwlBroadcastId : 0;

        //
        // Job type
        //
        ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_TYPE);
        m_dwJobType = pMsg->dwJobType;
        //
        // Extended status
        //
        m_dwExtendedStatus = (m_dwValidityMask & FAX_JOB_FIELD_STATUS_EX) ?
                                                 pMsg->dwExtendedStatus : 0;
        //
        // Job size
        //
        m_dwSize = (m_dwValidityMask & FAX_JOB_FIELD_SIZE) ? pMsg->dwSize : 0;

        //
        // Page count
        //
        m_dwPageCount = (m_dwValidityMask & FAX_JOB_FIELD_PAGE_COUNT) ? pMsg->dwPageCount : 0;

        //
        // Original scheduled time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME)
        {
            m_tmOriginalScheduleTime = pMsg->tmOriginalScheduleTime;
        }
        else
        {
            m_tmOriginalScheduleTime.Zero ();
        }
        //
        // Submission time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_SUBMISSION_TIME)
        {
            m_tmSubmissionTime = pMsg->tmOriginalScheduleTime;
        }
        else
        {
            m_tmSubmissionTime.Zero ();
        }
        //
        // Transmission start time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME)
        {
            m_tmTransmissionStartTime = pMsg->tmTransmissionStartTime;
        }
        else
        {
            m_tmTransmissionStartTime.Zero ();
        }
        //
        // Transmission end time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME)
        {
            m_tmTransmissionEndTime = pMsg->tmTransmissionEndTime;
        }
        else
        {
            m_tmTransmissionEndTime.Zero ();
        }
        //
        // Transmission duration
        //
        if ((m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME) &&
            (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME))
        {
            m_tmTransmissionDuration = m_tmTransmissionEndTime - m_tmTransmissionStartTime;
        }
        else
        {
            m_tmTransmissionDuration.Zero ();
        }
        //
        // Priority
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_PRIORITY)
        {
            m_Priority = pMsg->Priority;
            ASSERTION (m_Priority <= FAX_PRIORITY_TYPE_HIGH);
        }
        else
        {
            m_Priority = (FAX_ENUM_PRIORITY_TYPE)-1;
        }
        //
        // Retries
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_RETRIES)
        {
            m_dwRetries = pMsg->dwRetries;
        }
        else
        {
            m_dwRetries = 0;
        }
        //
        // Recipient info
        //
        m_cstrRecipientNumber = pMsg->lpctstrRecipientNumber ?
                                pMsg->lpctstrRecipientNumber : TEXT("");
        m_cstrRecipientName   = pMsg->lpctstrRecipientName ?
                                pMsg->lpctstrRecipientName : TEXT("");
        //
        // Sender info
        //
        m_cstrSenderNumber = pMsg->lpctstrSenderNumber ?
                             pMsg->lpctstrSenderNumber : TEXT("");
        m_cstrSenderName   = pMsg->lpctstrSenderName ?
                           pMsg->lpctstrSenderName : TEXT("");
        //
        // TSID / CSID
        //
        m_cstrTsid = pMsg->lpctstrTsid ?
                     pMsg->lpctstrTsid : TEXT("");
        m_cstrCsid = pMsg->lpctstrCsid ?
                     pMsg->lpctstrCsid : TEXT("");
        //
        // User
        //
        m_cstrSenderUserName = pMsg->lpctstrSenderUserName ?
                               pMsg->lpctstrSenderUserName : TEXT("");
        //
        // Billing
        //
        m_cstrBillingCode = pMsg->lpctstrBillingCode ?
                            pMsg->lpctstrBillingCode : TEXT("");
        //
        // Device
        //
        m_cstrDeviceName = pMsg->lpctstrDeviceName ?
                           pMsg->lpctstrDeviceName : TEXT("");
        //
        // Document
        //
        m_cstrDocumentName = pMsg->lpctstrDocumentName ?
                             pMsg->lpctstrDocumentName : TEXT("");
        //
        // Subject
        //
        m_cstrSubject = pMsg->lpctstrSubject ?
                        pMsg->lpctstrSubject : TEXT("");
        //
        // Caller id
        //
        m_cstrCallerID = pMsg->lpctstrCallerID ?
                         pMsg->lpctstrCallerID : TEXT("");
        //
        // Routing info
        //
        m_cstrRoutingInfo = pMsg->lpctstrRoutingInfo ?
                            pMsg->lpctstrRoutingInfo : TEXT("");
        //
        // Server name
        //
        m_cstrServerName = m_pServer->Machine();

        m_dwPossibleOperations = FAX_JOB_OP_VIEW | FAX_JOB_OP_DELETE | FAX_JOB_OP_PROPERTIES;
    }
    catch (CException *pException)
    {
        TCHAR wszCause[1024];

        pException->GetErrorMessage (wszCause, 1024);
        pException->Delete ();
        VERBOSE (EXCEPTION_ERR,
                 TEXT("Init caused exception : %s"), 
                 wszCause);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        return dwRes;
    }

    ASSERTION (ERROR_SUCCESS == dwRes);
    m_bValid = TRUE;
    return dwRes;
}   // CArchiveMsg::Init


DWORD 
CArchiveMsg::GetTiff (
    CString &cstrTiffLocation
) const
/*++

Routine name : CArchiveMsg::GetTiff

Routine description:

    Retrieves the message's TIFF from the server

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    cstrTiffLocation    [out]    - Name of TIFF file

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CArchiveMsg::GetTiff"), dwRes);

    dwRes = CopyTiffFromServer (m_pServer,
                                m_dwlMessageId,
                                (JT_SEND == m_dwJobType) ? 
                                    FAX_MESSAGE_FOLDER_SENTITEMS : 
                                    FAX_MESSAGE_FOLDER_INBOX,
                                cstrTiffLocation);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CopyTiffFromServer"), dwRes);
    }
    return dwRes;
}

DWORD 
CArchiveMsg::Delete ()
/*++

Routine name : CArchiveMsg::Delete

Routine description:

    Deletes the message

Author:

    Eran Yariv (EranY), Jan, 2000

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CArchiveMsg::Delete"), dwRes);

    if (!(GetPossibleOperations() & FAX_JOB_OP_DELETE))
    {
        VERBOSE (DBG_MSG, TEXT("Message can no longer be deleted"));
        dwRes = ERROR_CAN_NOT_COMPLETE;
        return dwRes;
    }
    HANDLE hFax;
    dwRes = m_pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::GetConnectionHandle"), dwRes);
        return dwRes;
    }
    START_RPC_TIME(TEXT("FaxRemoveMessage")); 
    if (!FaxRemoveMessage (hFax,
                           m_dwlMessageId,
                           (JT_SEND == m_dwJobType) ? 
                               FAX_MESSAGE_FOLDER_SENTITEMS : 
                               FAX_MESSAGE_FOLDER_INBOX))
    {
        dwRes = GetLastError ();
        END_RPC_TIME(TEXT("FaxRemoveMessage")); 
        m_pServer->SetLastRPCError (dwRes);
        CALL_FAIL (RPC_ERR, TEXT("FaxRemoveMessage"), dwRes);
        return dwRes;
    }
    END_RPC_TIME(TEXT("FaxRemoveMessage")); 

    ASSERTION (ERROR_SUCCESS == dwRes);    
    return dwRes;
}   // CArchiveMsg::Delete


DWORD
CArchiveMsg::Copy(
    const CArchiveMsg& other
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CArchiveMsg::Copy"), dwRes);

    try
    {
        m_dwValidityMask = other.m_dwValidityMask;
        m_dwJobType = other.m_dwJobType;
        m_dwExtendedStatus = other.m_dwExtendedStatus;
        m_dwlMessageId = other.m_dwlMessageId;
        m_dwlBroadcastId = other.m_dwlBroadcastId;
        m_dwSize = other.m_dwSize;
        m_dwPageCount = other.m_dwPageCount;
        m_tmOriginalScheduleTime = other.m_tmOriginalScheduleTime;
        m_tmSubmissionTime = other.m_tmSubmissionTime;
        m_tmTransmissionStartTime = other.m_tmTransmissionStartTime;
        m_tmTransmissionEndTime = other.m_tmTransmissionEndTime;
        m_tmTransmissionDuration = other.m_tmTransmissionDuration;
        m_Priority = other.m_Priority;
        m_dwRetries = other.m_dwRetries;
        m_cstrRecipientNumber = other.m_cstrRecipientNumber;
        m_cstrRecipientName = other.m_cstrRecipientName;
        m_cstrSenderNumber = other.m_cstrSenderNumber;
        m_cstrSenderName = other.m_cstrSenderName;
        m_cstrTsid = other.m_cstrTsid;
        m_cstrCsid = other.m_cstrCsid;
        m_cstrSenderUserName = other.m_cstrSenderUserName;
        m_cstrBillingCode = other.m_cstrBillingCode;
        m_cstrDeviceName = other.m_cstrDeviceName;
        m_cstrDocumentName = other.m_cstrDocumentName;
        m_cstrSubject = other.m_cstrSubject;
        m_cstrCallerID = other.m_cstrCallerID;
        m_cstrRoutingInfo = other.m_cstrRoutingInfo;
        m_cstrServerName = other.m_cstrServerName;
            
        m_bValid = other.m_bValid;
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwRes;

} // CArchiveMsg::Copy
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\message.h ===
// Message.h: interface for the CArchiveMsg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MESSAGE_H__C1376D20_394B_4B2F_BF50_0585A2A85AE2__INCLUDED_)
#define AFX_MESSAGE_H__C1376D20_394B_4B2F_BF50_0585A2A85AE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NUMERIC_CMP
    #define NUMERIC_CMP(a,b)   (((a) == (b)) ? 0 : (((a) < (b)) ? -1 : 1))
#endif

class CArchiveMsg : public CFaxMsg
{
public:

    DECLARE_DYNCREATE(CArchiveMsg)

    CArchiveMsg () {}
    virtual ~CArchiveMsg() {}

    DWORD Init (PFAX_MESSAGE pMsg, CServerNode* pServer);

    DWORD Copy(const CArchiveMsg& other);

    //
    // Operations:
    //
    DWORD GetTiff (CString &cstrTiffLocation) const;
    DWORD Delete ();

    //
    // Item retrival:
    //
    const CString &GetSenderName () const           
        { ASSERT (m_bValid); return m_cstrSenderName; }

    const CString &GetSenderNumber () const         
        { ASSERT (m_bValid); return m_cstrSenderNumber; }

    const CFaxDuration &GetTransmissionDuration () const 
        { ASSERT (m_bValid); return m_tmTransmissionDuration; }

private:

    CString       m_cstrSenderNumber; 
    CString       m_cstrSenderName; 

    CFaxDuration  m_tmTransmissionDuration; 
};

#endif // !defined(AFX_MESSAGE_H__C1376D20_394B_4B2F_BF50_0585A2A85AE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\msgpropertypg.h ===
#if !defined(AFX_MESSAGEPROPERTYPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_)
#define AFX_MESSAGEPROPERTYPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MsgPropertyPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMessagePropertyPg dialog

class CMsgPropertyPg : public CFaxClientPg
{
	DECLARE_DYNCREATE(CMsgPropertyPg)

// Construction
public:
	CMsgPropertyPg(DWORD dwResId, CFaxMsg* pMsg);
	~CMsgPropertyPg();

// Dialog Data
	//{{AFX_DATA(CMsgPropertyPg)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMessagePropertyPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
    CMsgPropertyPg() {}

    void Refresh(TMsgPageInfo* pPageInfo, DWORD dwSize);

    CFaxMsg* m_pMsg;

    // Generated message map functions
	//{{AFX_MSG(CMsgPropertyPg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MESSAGEPROPERTYPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\outboxdetailspg.cpp ===
// OutboxDetailsPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     53

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_USER,             IDC_USER_VALUE,
    MSG_VIEW_ITEM_PRIORITY,         IDC_PRIORITY_VALUE,
    MSG_VIEW_ITEM_CSID,             IDC_CSID_VALUE,
    MSG_VIEW_ITEM_TSID,             IDC_TSID_VALUE,
    MSG_VIEW_ITEM_DEVICE,           IDC_DEVICE_VALUE,
    MSG_VIEW_ITEM_RETRIES,          IDC_RETRIES_VALUE,
    MSG_VIEW_ITEM_ID,               IDC_JOB_ID_VALUE,
    MSG_VIEW_ITEM_BROADCAST_ID,     IDC_BROADCAST_ID_VALUE,
    MSG_VIEW_ITEM_SUBMIT_TIME,      IDC_SUBMISSION_TIME_VALUE,
    MSG_VIEW_ITEM_BILLING,          IDC_BILLING_CODE_VALUE,
	MSG_VIEW_ITEM_SERVER,			IDC_SERVER_VALUE
};


/////////////////////////////////////////////////////////////////////////////
// COutboxDetailsPg property page

IMPLEMENT_DYNCREATE(COutboxDetailsPg, CMsgPropertyPg)


COutboxDetailsPg::COutboxDetailsPg(
    CFaxMsg* pMsg     // pointer to CJob
) : 
    CMsgPropertyPg(COutboxDetailsPg::IDD, pMsg)
{
}

COutboxDetailsPg::~COutboxDetailsPg()
{
}

void COutboxDetailsPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COutboxDetailsPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COutboxDetailsPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(COutboxDetailsPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COutboxDetailsPg message handlers

BOOL 
COutboxDetailsPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("COutboxDetailsPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\messagefolder.h ===
// MessageFolder.h: interface for the CMessageFolder class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MESSAGEFOLDER_H__5236D732_0E9D_4B89_A1CB_2185C21746FD__INCLUDED_)
#define AFX_MESSAGEFOLDER_H__5236D732_0E9D_4B89_A1CB_2185C21746FD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMessageFolder : public CFolder  
{
public:
    CMessageFolder(
        FolderType type, 
        FAX_ENUM_MESSAGE_FOLDER Folder
    ) : 
        CFolder(type),
        m_Folder (Folder)
    {}

    virtual ~CMessageFolder() { PreDestruct(); }

    DWORD Refresh ();

    static void ReadConfiguration ();

    DWORD OnJobAdded (DWORDLONG dwlMsgId);
    DWORD OnJobUpdated (DWORDLONG dwlMsgId, PFAX_JOB_STATUS pNewStatus)
        { ASSERT (FALSE); return ERROR_CALL_NOT_IMPLEMENTED; }

private:

    FAX_ENUM_MESSAGE_FOLDER m_Folder;   // Inbox / Sent items
    static DWORD            m_sdwNumMessagesPerRPCCall; // Number of messages to 
                                                        // retrieve per RPC call.
};

#endif // !defined(AFX_MESSAGEFOLDER_H__5236D732_0E9D_4B89_A1CB_2185C21746FD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\messagefolder.cpp ===
// MessageFolder.cpp: implementation of the CMessageFolder class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     14

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

#define DEFAULT_NUM_MSGS_PER_CALL       100


DWORD  CMessageFolder::m_sdwNumMessagesPerRPCCall = 0;

void 
CMessageFolder::ReadConfiguration ()
/*++

Routine name : CMessageFolder::ReadConfiguration

Routine description:

    Reads the Messages-Per-RPC-Call parameters from the registry

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    m_sdwNumMessagesPerRPCCall = 
        AfxGetApp ()->GetProfileInt (CLIENT_ARCHIVE_KEY, 
                                     CLIENT_ARCHIVE_MSGS_PER_CALL, 
                                     DEFAULT_NUM_MSGS_PER_CALL);
}

DWORD
CMessageFolder::Refresh ()
/*++

Routine name : CMessageFolder::Refresh

Routine description:

    Rebuilds the map of the message using the client API.
    This function is always called in the context of a worker thread.

    This function must be called when the data critical section is held.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMessageFolder::Refresh"), dwRes, TEXT("Type=%d"), Type());
    //
    // Enumerate archived messages from the server
    //
    ASSERTION (m_pServer);
    HANDLE              hFax;
    HANDLE              hEnum;
    DWORD               dwIndex;
    DWORD               dwNumMsgs = 0;
    PFAX_MESSAGE        pMsgs = NULL;
    MSGS_MAP            mapChunk;


    ASSERTION (m_sdwNumMessagesPerRPCCall);
    dwRes = m_pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("CFolder::GetConnectionHandle"), dwRes);
        return dwRes;
    }
    if (m_bStopRefresh)
    {
        //
        // Quit immediately
        //
        return dwRes;
    }
    START_RPC_TIME(TEXT("FaxStartMessagesEnum")); 
    if (!FaxStartMessagesEnum (hFax, m_Folder, &hEnum))
    {
        dwRes = GetLastError ();
        END_RPC_TIME(TEXT("FaxStartMessagesEnum"));
        if (ERROR_NO_MORE_ITEMS == dwRes)
        {
            //
            // This is not a real error - the folder is simply empty
            //
            VERBOSE (DBG_MSG, TEXT("Folder is empty"));
            dwRes = ERROR_SUCCESS;
            return dwRes;
        }
        m_pServer->SetLastRPCError (dwRes);
        CALL_FAIL (RPC_ERR, TEXT("FaxStartMessagesEnum"), dwRes);
        return dwRes;
    }
    END_RPC_TIME(TEXT("FaxStartMessagesEnum"));
    if (m_bStopRefresh)
    {
        //
        // Quit immediately
        //
        goto exit;
    }
    //
    // Make sure our list is empty
    //
    ASSERTION (!m_Msgs.size()); 
    //
    // Get the messages in bunches
    //
    while (ERROR_SUCCESS == dwRes)
    {
        DWORD dwReturnedMsgs;
        START_RPC_TIME(TEXT("FaxEnumMessages")); 
        if (!FaxEnumMessages (hEnum, m_sdwNumMessagesPerRPCCall, &pMsgs, &dwReturnedMsgs))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxEnumMessages"));
            if (ERROR_NO_MORE_ITEMS != dwRes)
            {   
                //
                // Really an error
                //
                m_pServer->SetLastRPCError (dwRes);
                CALL_FAIL (RPC_ERR, TEXT("FaxEnumMessages"), dwRes);
                goto exit;
            }
            else
            {
                //
                // Not an error - just a "end of data" sign
                //
                break;
            }
        }
        END_RPC_TIME(TEXT("FaxEnumMessages"));
        if (m_bStopRefresh)
        {
            //
            // Quit immediately
            //
            goto exit;
        }
        //
        // Success in enumeration
        //
        mapChunk.clear();
        for (dwIndex = 0; dwIndex < dwReturnedMsgs; dwIndex++)
        {
            CArchiveMsg *pMsg = NULL;
            //
            // Create a new message 
            //
            try
            {
                pMsg = new CArchiveMsg;
            }
            catch (...)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                CALL_FAIL (MEM_ERR, TEXT("new CArchiveMsg"), dwRes);
                goto exit;
            }
            //
            // Init the message 
            //
            dwRes = pMsg->Init (&pMsgs[dwIndex], m_pServer);
            if (ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (MEM_ERR, TEXT("CArchiveMsg::Init"), dwRes);
                SAFE_DELETE (pMsg);
                goto exit;
            }
            //
            // Enter the message into the map
            //
            EnterData();
            try
            {
                m_Msgs[pMsgs[dwIndex].dwlMessageId] = pMsg;
                mapChunk[pMsgs[dwIndex].dwlMessageId] = pMsg;
            }
            catch (...)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                CALL_FAIL (MEM_ERR, TEXT("map::operator[]"), dwRes);
                SAFE_DELETE (pMsg);
                LeaveData ();
                goto exit;
            }
            LeaveData ();

            if (m_bStopRefresh)
            {
                //
                // Quit immediately
                //
                goto exit;
            }
        }
        //
        // Free current chunk of messages
        //
        FaxFreeBuffer ((LPVOID)pMsgs);
        pMsgs = NULL;

        AttachView();
        if (m_pAssignedView)
        {
            //
            // Folder has a view attached
            //
            m_pAssignedView->SendMessage (
                           WM_FOLDER_ADD_CHUNK,
                           WPARAM (dwRes), 
                           LPARAM (&mapChunk));
        }
        else
        {
            //
            //  Shutdown in progress
            //
            goto exit;
        }
    }
    if (ERROR_NO_MORE_ITEMS == dwRes)
    {
        //
        // Not a real error
        //
        dwRes = ERROR_SUCCESS;
    }
    ASSERTION (ERROR_SUCCESS == dwRes);

exit:

    //
    // Close enumeration handle
    //
    ASSERTION (hEnum);
    {
        START_RPC_TIME(TEXT("FaxEndMessagesEnum")); 
        if (!FaxEndMessagesEnum (hEnum))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxEndMessagesEnum"));
            m_pServer->SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxEndMessagesEnum"), dwRes);
        }
        else
        {
            END_RPC_TIME(TEXT("FaxEndMessagesEnum"));
        }
    }
    //
    // Free left overs (if exist)
    //
    FaxFreeBuffer ((LPVOID)pMsgs);
    return dwRes;
}   // CMessageFolder::Refresh



DWORD 
CMessageFolder::OnJobAdded (
    DWORDLONG dwlMsgId
)
/*++

Routine name : CMessageFolder::OnJobAdded

Routine description:

	Handles notification of a message added to the archive

Author:

	Eran Yariv (EranY),	Feb, 2000

Arguments:

	dwlMsgId   [in]     - New message unique id

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMessageFolder::OnJobAdded"), 
              dwRes, 
              TEXT("MsgId=0x%016I64x, Type=%d"), 
              dwlMsgId,
              Type());

    HANDLE              hFax;
    PFAX_MESSAGE        pFaxMsg = NULL;
    CArchiveMsg           *pMsg = NULL;

    EnterData ();
    pMsg = (CArchiveMsg*)FindMessage (dwlMsgId);
    if (pMsg)
    {
        //
        // This message is already in the archive
        //
        VERBOSE (DBG_MSG, TEXT("Message is already known and visible"));
        goto exit;
    }
    //
    // Get information about this message
    //
    dwRes = m_pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("CFolder::GetConnectionHandle"), dwRes);
        goto exit;
    }
    {
        START_RPC_TIME(TEXT("FaxGetMessage")); 
        if (!FaxGetMessage (hFax, dwlMsgId, m_Folder, &pFaxMsg))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxGetMessage"));
            m_pServer->SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxGetMessage"), dwRes);
            goto exit;
        }
        END_RPC_TIME(TEXT("FaxGetMessage"));
    }
    //
    // Enter a new message to the map
    //
    try
    {
        pMsg = new CArchiveMsg;
        ASSERTION (pMsg);
        m_Msgs[pFaxMsg->dwlMessageId] = pMsg;
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        SAFE_DELETE (pMsg);
        goto exit;
    }
    //
    // Init the message 
    //
    dwRes = pMsg->Init (pFaxMsg, m_pServer);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (MEM_ERR, TEXT("CArchiveMsg::Init"), dwRes);
        //
        // Remove message from map and delete it
        //
        if (pMsg)
        {
            try
            {
                m_Msgs.erase (pFaxMsg->dwlMessageId);
            }
            catch (...)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                CALL_FAIL (MEM_ERR, TEXT("map::erase"), dwRes);
            }
            SAFE_DELETE (pMsg);
        }
        goto exit;
    }
    if (m_pAssignedView)
    {
        //
        // If this folder is alive - tell our view to add the message
        //
        m_pAssignedView->OnUpdate (NULL, UPDATE_HINT_ADD_ITEM, pMsg);
    }
    
    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    if(pFaxMsg)
    {
        FaxFreeBuffer(pFaxMsg);
    }
    LeaveData ();
    return dwRes;
}   // CMessageFolder::OnJobAdded
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\msgpropertypg.cpp ===
// MessagePropertyPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     58

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CMessagePropertyPg property page

IMPLEMENT_DYNCREATE(CMsgPropertyPg, CFaxClientPg)

CMsgPropertyPg::CMsgPropertyPg(
    DWORD dwResId,      // dialog resource id
    CFaxMsg* pMsg       // pointer to CArchiveMsg/CJob
): 
    CFaxClientPg(dwResId),
    m_pMsg(pMsg)
{
}

CMsgPropertyPg::~CMsgPropertyPg()
{
}

void CMsgPropertyPg::DoDataExchange(CDataExchange* pDX)
{
	CFaxClientPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMessagePropertyPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMsgPropertyPg, CFaxClientPg)
	//{{AFX_MSG_MAP(CMessagePropertyPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMessagePropertyPg message handlers

void
CMsgPropertyPg::Refresh(
    TMsgPageInfo* pPageInfo,    // page info array
    DWORD dwSize                    // size of the array
) 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMessagePropertyPg::Refresh"));

    CFaxClientPg::OnInitDialog();

    CItemPropSheet* pParent = (CItemPropSheet*)GetParent();

    //
    // create CArchiveMsg adapter
    //
    CViewRow messView;
    dwRes = messView.AttachToMsg(m_pMsg);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::AttachToMsg"), dwRes);
        pParent->SetLastError(ERROR_INVALID_DATA);
        pParent->EndDialog(IDABORT);
        return;
    }

    
    CWnd *pWnd;

    for(DWORD dw=0; dw < dwSize; ++dw)
    {
        //
        // set item value
        //
        pWnd = GetDlgItem(pPageInfo[dw].dwValueResId);
        if(NULL == pWnd)
        {
            dwRes = ERROR_INVALID_HANDLE;
            CALL_FAIL (WINDOW_ERR, TEXT("CWnd::GetDlgItem"), dwRes);
            break;
        }
        pWnd->SetWindowText(messView.GetItemString(pPageInfo[dw].itemType));
        //
        // Place the caret back at the beginning of the text
        //
        pWnd->SendMessage (EM_SETSEL, 0, 0);
    }
    
    if (ERROR_SUCCESS != dwRes)
    {
        pParent->SetLastError(ERROR_INVALID_DATA);
        pParent->EndDialog(IDABORT);
    }
}

BOOL 
CMsgPropertyPg::OnSetActive()
{
  BOOL bRes = CFaxClientPg::OnSetActive();

  GetParent()->PostMessage(WM_SET_SHEET_FOCUS, 0, 0L);

  return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\outboxgeneralpg.cpp ===
// OutboxGeneralPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     43

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_DOC_NAME,         IDC_DOC_NAME_VALUE,
    MSG_VIEW_ITEM_SUBJECT,          IDC_SUBJECT_VALUE,
    MSG_VIEW_ITEM_RECIPIENT_NAME,   IDC_RECIPIENT_NAME_VALUE,
    MSG_VIEW_ITEM_RECIPIENT_NUMBER, IDC_RECIPIENT_NUMBER_VALUE,
    MSG_VIEW_ITEM_STATUS,           IDC_STATUS_VALUE,
    MSG_VIEW_ITEM_EXTENDED_STATUS,  IDC_EXTENDED_STATUS_VALUE,
    MSG_VIEW_ITEM_NUM_PAGES,        IDC_PAGES_VALUE,
    MSG_VIEW_ITEM_CURRENT_PAGE,     IDC_CURRENT_PAGE_VALUE,
    MSG_VIEW_ITEM_SIZE,             IDC_SIZE_VALUE,
    MSG_VIEW_ITEM_SEND_TIME,        IDC_TRANSMISSION_TIME_VALUE
};


/////////////////////////////////////////////////////////////////////////////
// COutboxGeneralPg property page

IMPLEMENT_DYNCREATE(COutboxGeneralPg, CMsgPropertyPg)


COutboxGeneralPg::COutboxGeneralPg(
    CFaxMsg* pMsg     // pointer to CJob
) : 
    CMsgPropertyPg(COutboxGeneralPg::IDD, pMsg)
{
}

COutboxGeneralPg::~COutboxGeneralPg()
{
}

void COutboxGeneralPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COutboxGeneralPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COutboxGeneralPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(COutboxGeneralPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COutboxGeneralPg message handlers

BOOL 
COutboxGeneralPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("COutboxGeneralPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\outboxdetailspg.h ===
#if !defined(AFX_OUTBOXDETAILSPG_H__A2BCE6CD_3ABB_456A_B9B0_198AA6E5CFFD__INCLUDED_)
#define AFX_OUTBOXDETAILSPG_H__A2BCE6CD_3ABB_456A_B9B0_198AA6E5CFFD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OutboxDetailsPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COutboxDetailsPg dialog

class COutboxDetailsPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(COutboxDetailsPg)

// Construction
public:
	COutboxDetailsPg(CFaxMsg* pMsg);
	~COutboxDetailsPg();

// Dialog Data
	//{{AFX_DATA(COutboxDetailsPg)
	enum { IDD = IDD_OUTBOX_DETAILS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(COutboxDetailsPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    COutboxDetailsPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(COutboxDetailsPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OUTBOXDETAILSPG_H__A2BCE6CD_3ABB_456A_B9B0_198AA6E5CFFD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\outboxgeneralpg.h ===
#if !defined(AFX_OUTBOXGENERALPG_H__A2BCE6CD_3ABB_456A_B9B0_198AA6E5CFFD__INCLUDED_)
#define AFX_OUTBOXGENERALPG_H__A2BCE6CD_3ABB_456A_B9B0_198AA6E5CFFD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OutboxGeneralPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COutboxGeneralPg dialog

class COutboxGeneralPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(COutboxGeneralPg)

// Construction
public:
	COutboxGeneralPg(CFaxMsg* pMsg);
	~COutboxGeneralPg();

// Dialog Data
	//{{AFX_DATA(COutboxGeneralPg)
	enum { IDD = IDD_OUTBOX_GENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(COutboxGeneralPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    COutboxGeneralPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(COutboxGeneralPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OUTBOXGENERALPG_H__A2BCE6CD_3ABB_456A_B9B0_198AA6E5CFFD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\personalinfopg.cpp ===
// PersonalInfoPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     44

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// this array maps dialog control IDs to
// number of string in FAX_PERSONAL_PROFILE structure
//
static TPersonalPageInfo s_PageInfo[] = 
{ 
    IDC_NAME_VALUE,             PERSONAL_PROFILE_NAME,
    IDC_FAX_NUMBER_VALUE,       PERSONAL_PROFILE_FAX_NUMBER,
    IDC_COMPANY_VALUE,          PERSONAL_PROFILE_COMPANY,
    IDC_TITLE_VALUE,            PERSONAL_PROFILE_TITLE,
    IDC_DEPARTMENT_VALUE,       PERSONAL_PROFILE_DEPARTMENT,
    IDC_OFFICE_VALUE,           PERSONAL_PROFILE_OFFICE_LOCATION,
    IDC_HOME_PHONE_VALUE,       PERSONAL_PROFILE_HOME_PHONE,
    IDC_BUSINESS_PHONE_VALUE,   PERSONAL_PROFILE_OFFICE_PHONE,
    IDC_EMAIL_VALUE,            PERSONAL_PROFILE_EMAIL,
    IDC_BILLING_CODE_VALUE,     PERSONAL_PROFILE_BILLING_CODE,
    IDC_ADDRESS_VALUE,          PERSONAL_PROFILE_STREET_ADDRESS
};

/////////////////////////////////////////////////////////////////////////////
// CPersonalInfoPg property page

IMPLEMENT_DYNCREATE(CPersonalInfoPg, CFaxClientPg)


CPersonalInfoPg::CPersonalInfoPg(
    DWORD dwCaptionId,              // page caption id
    EnumPersinalInfo ePersonalInfo, // type of Persinal Info (SENDER or RECIPIENT)
    CFaxMsg* pMsg,                  // pointer to CJob or CArchiveMsg
    CFolder* pFolder                // folder
) : 
    CFaxClientPg(CPersonalInfoPg::IDD, dwCaptionId),
    m_ePersonalInfo(ePersonalInfo),
    m_pPersonalProfile(NULL),
    m_pMsg(pMsg),
    m_pFolder(pFolder)
{
    DBG_ENTER(TEXT("CPersonalInfoPg::CPersonalInfoPg"));

    ASSERTION(NULL != pFolder);
    ASSERTION(PERSON_SENDER == ePersonalInfo || PERSON_RECIPIENT == ePersonalInfo);
}

CPersonalInfoPg::~CPersonalInfoPg()
{
    if(m_pPersonalProfile)
    {
        FaxFreeBuffer(m_pPersonalProfile);
    }
}

void CPersonalInfoPg::DoDataExchange(CDataExchange* pDX)
{
	CFaxClientPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPersonalInfoPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPersonalInfoPg, CFaxClientPg)
	//{{AFX_MSG_MAP(CPersonalInfoPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPersonalInfoPg message handlers

DWORD 
CPersonalInfoPg::Init()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CPersonalInfoPg::Init"));


    ASSERTION(m_pFolder);

    //
    // get server handle
    //
    CServerNode *pServer = const_cast<CServerNode *>(m_pFolder->GetServer());       
    HANDLE hFax;
    dwRes = pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::GetConnectionHandle"), dwRes);
        return dwRes;        
    }

    //
    // get folder type and message id
    //
    DWORDLONG  dwlMessageId;
    FAX_ENUM_MESSAGE_FOLDER  eFolder;    
    FolderType type = m_pFolder->Type();

    dwlMessageId = m_pMsg->GetId();

    switch(type)
    {
    case FOLDER_TYPE_INCOMING:
    case FOLDER_TYPE_OUTBOX:
        eFolder = FAX_MESSAGE_FOLDER_QUEUE;
        break;
    case FOLDER_TYPE_INBOX:
        eFolder = FAX_MESSAGE_FOLDER_INBOX;
        break;
    case FOLDER_TYPE_SENT_ITEMS:
        eFolder = FAX_MESSAGE_FOLDER_SENTITEMS;
        break;
    default:
        ASSERTION_FAILURE
        return ERROR_CAN_NOT_COMPLETE;
    };

    //
    // get personal info
    //
    if(PERSON_RECIPIENT == m_ePersonalInfo)
    {
        //
        // get recipient info
        //
        START_RPC_TIME(TEXT("FaxGetRecipientInfo")); 
        if (!FaxGetRecipientInfo(hFax, dwlMessageId, eFolder, &m_pPersonalProfile))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxGetRecipientInfo")); 
            pServer->SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxGetRecipientInfo"), dwRes);
            m_pPersonalProfile = NULL;
            return dwRes;
        }
        END_RPC_TIME(TEXT("FaxGetRecipientInfo")); 
    }
    else // if(PERSON_SENDER == m_ePersonalInfo)
    {
        //
        // get sender info
        //
        START_RPC_TIME(TEXT("FaxGetSenderInfo")); 
        if (!FaxGetSenderInfo(hFax, dwlMessageId, eFolder, &m_pPersonalProfile))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxGetSenderInfo")); 
            pServer->SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxGetSenderInfo"), dwRes);
            m_pPersonalProfile = NULL;
            return dwRes;
        }
        END_RPC_TIME(TEXT("FaxGetSenderInfo")); 
    }


    return dwRes;
}

BOOL 
CPersonalInfoPg::OnInitDialog() 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CPersonalInfoPg::OnInitDialog"));

    CFaxClientPg::OnInitDialog();

    if(!m_pPersonalProfile)
    {
        return TRUE;
    }

    CItemPropSheet* pParent = (CItemPropSheet*)GetParent();


    //
    // array of strings from FAX_PERSONAL_PROFILE
    //
    TCHAR** ptchValues = ptchValues = &(m_pPersonalProfile->lptstrName);

    CWnd *pWnd;
    dwRes = ERROR_SUCCESS;
    DWORD dwSize = sizeof(s_PageInfo)/sizeof(s_PageInfo[0]);    
    for(DWORD dw=0; dw < dwSize; ++dw)
    {
        //
        // set item value
        //
        pWnd = GetDlgItem(s_PageInfo[dw].dwValueResId);
        if(NULL == pWnd)
        {
            dwRes = ERROR_INVALID_HANDLE;
            CALL_FAIL (WINDOW_ERR, TEXT("CWnd::GetDlgItem"), dwRes);
            break;
        }

        pWnd->SetWindowText(ptchValues[s_PageInfo[dw].eValStrNum]);
        //
        // Place the caret back at the beginning of the text
        //
        pWnd->SendMessage (EM_SETSEL, 0, 0);
    }

    if (ERROR_SUCCESS != dwRes)
    {
        pParent->SetLastError(ERROR_INVALID_DATA);
        pParent->EndDialog(IDABORT);
    }
	
	return TRUE;
}

BOOL 
CPersonalInfoPg::OnSetActive()
{
  BOOL bRes = CFaxClientPg::OnSetActive();

  GetParent()->PostMessage(WM_SET_SHEET_FOCUS, 0, 0L);

  return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\queuefolder.cpp ===
// QueueFolder.cpp: implementation of the CQueueFolder class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     19

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CQueueFolder, CFolder)




DWORD
CQueueFolder::Refresh ()
/*++

Routine name : CQueueFolder::Refresh

Routine description:

    Rebuilds the map of the jobs using the client API.
    This function is always called in the context of a worker thread.

    This function must be called when the data critical section is held.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CQueueFolder::Refresh"), dwRes, TEXT("Type=%d"), Type());

    //
    // Enumerate jobs from the server
    //
    ASSERTION (m_pServer);
    HANDLE            hFax;
    PFAX_JOB_ENTRY_EX pEntries;
    DWORD             dwNumJobs;
    DWORD             dw;

    dwRes = m_pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("CFolder::GetConnectionHandle"), dwRes);
        return dwRes;
    }
    if (m_bStopRefresh)
    {
        //
        // Quit immediately
        //
        return dwRes;
    }
    START_RPC_TIME(TEXT("FaxEnumJobsEx")); 
    if (!FaxEnumJobsEx (hFax, 
                        m_dwJobTypes,
                        &pEntries,
                        &dwNumJobs))
    {
        dwRes = GetLastError ();
        END_RPC_TIME(TEXT("FaxEnumJobsEx"));
        m_pServer->SetLastRPCError (dwRes);
        CALL_FAIL (RPC_ERR, TEXT("FaxEnumJobsEx"), dwRes);
        return dwRes;
    }
    END_RPC_TIME(TEXT("FaxEnumJobsEx"));
    if (m_bStopRefresh)
    {
        //
        // Quit immediately
        //
        goto exit;
    }
    //
    // Make sure our map is empty
    //
    ASSERTION (!m_Msgs.size()); 
    //
    // Fill the map and the list control
    //
    for (dw = 0; dw < dwNumJobs; dw++)
    {
        PFAX_JOB_ENTRY_EX pEntry = &pEntries[dw];
        
        if((pEntry->pStatus->dwQueueStatus & JS_COMPLETED) ||
           (pEntry->pStatus->dwQueueStatus & JS_CANCELED))
        {
            //
            // don't display completed or canceled jobs
            //
            continue;
        }

        CJob *pJob = NULL;
        try
        {
            pJob = new CJob;
        }
        catch (...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("new CJob"), dwRes);
            goto exit;
        }
        //
        // Init the message 
        //
        dwRes = pJob->Init (pEntry, m_pServer);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (MEM_ERR, TEXT("CJob::Init"), dwRes);
            SAFE_DELETE (pJob);
            goto exit;
        }
        //
        // Enter the message into the map
        //
        EnterData();
        try
        {
            m_Msgs[pEntry->dwlMessageId] = pJob;
        }
        catch (...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("map::operator[]"), dwRes);
            SAFE_DELETE (pJob);
            LeaveData ();
            goto exit;
        }
        LeaveData ();
        if (m_bStopRefresh)
        {
            //
            // Quit immediately
            //
            goto exit;
        }
    }

    AttachView();
    if (m_pAssignedView)
    {
        //
        // Folder has a view attached
        //
        m_pAssignedView->SendMessage (
                       WM_FOLDER_ADD_CHUNK,
                       WPARAM (dwRes), 
                       LPARAM (&m_Msgs));
    }
    else
    {
        //
        //  Shutdown in progress
        //
    }

    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    FaxFreeBuffer ((LPVOID)pEntries);
    return dwRes;
}   // CQueueFolder::Refresh


DWORD 
CQueueFolder::OnJobAdded (
    DWORDLONG dwlMsgId
)
/*++

Routine name : CQueueFolder::OnJobAdded

Routine description:

	Handles notification of a job added to the queue

Author:

	Eran Yariv (EranY),	Feb, 2000

Arguments:

	dwlMsgId   [in]     - New job unique id

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CQueueFolder::OnJobAdded"), 
              dwRes, 
              TEXT("MsgId=0x%016I64x, Type=%d"), 
              dwlMsgId,
              Type());

    HANDLE              hFax;
    PFAX_JOB_ENTRY_EX   pFaxJob = NULL;
    CJob               *pJob = NULL;

    EnterData ();
    pJob = (CJob*)FindMessage (dwlMsgId); 
    if (pJob)
    {
        //
        // This job is already in the queue
        //
        VERBOSE (DBG_MSG, TEXT("Job is already known and visible"));
        goto exit;
    }
    //
    // Get information about this job
    //
    dwRes = m_pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("CFolder::GetConnectionHandle"), dwRes);
        goto exit;
    }
    {
        START_RPC_TIME(TEXT("FaxGetJobEx")); 
        if (!FaxGetJobEx (hFax, dwlMsgId, &pFaxJob))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxGetJobEx"));
            m_pServer->SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxGetJobEx"), dwRes);
            goto exit;
        }
        END_RPC_TIME(TEXT("FaxGetJobEx"));
    }
    //
    // Enter a new job to the map
    //
    try
    {
        pJob = new CJob;
        ASSERTION (pJob);
        m_Msgs[pFaxJob->dwlMessageId] = pJob;
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        SAFE_DELETE (pJob);
        goto exit;
    }
    //
    // Init the message 
    //
    dwRes = pJob->Init (pFaxJob, m_pServer);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (MEM_ERR, TEXT("CJob::Init"), dwRes);
        if (pJob)
        {
            try
            {
                m_Msgs.erase (pFaxJob->dwlMessageId);
            }
            catch (...)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                CALL_FAIL (MEM_ERR, TEXT("map::erase"), dwRes);
            }
            SAFE_DELETE (pJob);
        }
        goto exit;
    }
    if (m_pAssignedView)
    {
        //
        // If this folder is alive - tell our view to add the job
        //
        m_pAssignedView->OnUpdate (NULL, UPDATE_HINT_ADD_ITEM, pJob);
    }
    
    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    if(pFaxJob)
    {
        FaxFreeBuffer(pFaxJob);
    }
    LeaveData ();
    return dwRes;
}   // CQueueFolder::OnJobAdded


DWORD 
CQueueFolder::OnJobUpdated (
    DWORDLONG dwlMsgId,
    PFAX_JOB_STATUS pNewStatus
)
/*++

Routine name : CQueueFolder::OnJobUpdated

Routine description:

	Handles notification of a job removed from the queue

Author:

	Eran Yariv (EranY),	Feb, 2000

Arguments:

	dwlMsgId   [in]     - Job unique id
    pNewStatus [in]     - New status of the job

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CQueueFolder::OnJobUpdated"),
              dwRes, 
              TEXT("MsgId=0x%016I64x, Type=%d"), 
              dwlMsgId,
              Type());

    CJob *pJob = NULL;

    EnterData ();
    pJob = (CJob*)FindMessage (dwlMsgId);
    if (!pJob)
    {
        //
        // This job is not in the queue - treat the notification as if the job was added
        //
        VERBOSE (DBG_MSG, TEXT("Job is not known - adding it"));
        LeaveData ();
        dwRes = OnJobAdded (dwlMsgId);
        return dwRes;
    }
    //
    // Update job's status
    //
    if(pJob->IsNewStatus(pNewStatus))
    {
        dwRes = pJob->UpdateStatus (pNewStatus);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CJob::UpdateStatus"), dwRes);
            goto exit;
        }
        if (m_pAssignedView)
        {
            //
            // If this folder is alive - tell our view to update the job
            //
            m_pAssignedView->OnUpdate (NULL, UPDATE_HINT_UPDATE_ITEM, pJob);
        }
    }

    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    LeaveData ();
    return dwRes;
}   // CQueueFolder::OnJobUpdated
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\queuefolder.h ===
// QueueFolder.h: interface for the CQueueFolder class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_QUEUEFOLDER_H__D91FC386_B879_4485_B32F_9A53F59554E3__INCLUDED_)
#define AFX_QUEUEFOLDER_H__D91FC386_B879_4485_B32F_9A53F59554E3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CQueueFolder : public CFolder  
{
public:
    CQueueFolder(
        FolderType type, 
        DWORD dwJobTypes
    ) : 
        CFolder(type),
        m_dwJobTypes(dwJobTypes) 
    {}

    virtual ~CQueueFolder() { PreDestruct(); }

    DECLARE_DYNAMIC(CQueueFolder)

    DWORD Refresh ();

    DWORD OnJobAdded (DWORDLONG dwlMsgId);
    DWORD OnJobUpdated (DWORDLONG dwlMsgId, PFAX_JOB_STATUS pNewStatus);

private:
    
    DWORD  m_dwJobTypes;   // Bit mask of JT_* values to retrieve
};

#endif // !defined(AFX_QUEUEFOLDER_H__D91FC386_B879_4485_B32F_9A53F59554E3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\personalinfopg.h ===
#if !defined(AFX_PERSONALINFOPG_H__C3EA2FB2_67AC_4552_AE70_7DE1E0544B60__INCLUDED_)
#define AFX_PERSONALINFOPG_H__C3EA2FB2_67AC_4552_AE70_7DE1E0544B60__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PersonalInfoPg.h : header file
//

//
// this is FAX_PERSONAL_PROFILE struct string data members enum
// it ALWAYS should be synced with FAX_PERSONAL_PROFILE
//
enum EnumPersonalProfile
{
    PERSONAL_PROFILE_NAME = 0,
    PERSONAL_PROFILE_FAX_NUMBER,
    PERSONAL_PROFILE_COMPANY,
    PERSONAL_PROFILE_STREET_ADDRESS,
    PERSONAL_PROFILE_CITY,
    PERSONAL_PROFILE_STATE,
    PERSONAL_PROFILE_ZIP,
    PERSONAL_PROFILE_COUNTRY,
    PERSONAL_PROFILE_TITLE,
    PERSONAL_PROFILE_DEPARTMENT,
    PERSONAL_PROFILE_OFFICE_LOCATION,
    PERSONAL_PROFILE_HOME_PHONE,
    PERSONAL_PROFILE_OFFICE_PHONE,
    PERSONAL_PROFILE_EMAIL,
    PERSONAL_PROFILE_BILLING_CODE,
    PERSONAL_PROFILE_STR_NUM
};

struct TPersonalPageInfo
{
    DWORD               dwValueResId; // item value control id
    EnumPersonalProfile eValStrNum;   // number of string in FAX_PERSONAL_PROFILE structure
};

enum EnumPersinalInfo {PERSON_SENDER, PERSON_RECIPIENT};

/////////////////////////////////////////////////////////////////////////////
// CPersonalInfoPg dialog

class CPersonalInfoPg : public CFaxClientPg
{
	DECLARE_DYNCREATE(CPersonalInfoPg)

// Construction
public:    
	CPersonalInfoPg(DWORD dwCaptionId, 
                    EnumPersinalInfo ePersonalInfo, 
                    CFaxMsg* pMsg,
                    CFolder* pFolder);
	~CPersonalInfoPg();

    DWORD Init();

// Dialog Data
	//{{AFX_DATA(CPersonalInfoPg)
	enum { IDD = IDD_PERSONAL_INFO };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPersonalInfoPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
private:
    CPersonalInfoPg() {}

    PFAX_PERSONAL_PROFILE m_pPersonalProfile;
    EnumPersinalInfo      m_ePersonalInfo;

    CFaxMsg* m_pMsg;
    CFolder* m_pFolder;

protected:
	// Generated message map functions
	//{{AFX_MSG(CPersonalInfoPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PERSONALINFOPG_H__C3EA2FB2_67AC_4552_AE70_7DE1E0544B60__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\sentitemsdetailspg.cpp ===
// SentItemsDetailsPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     55

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_USER,             IDC_USER_VALUE,
    MSG_VIEW_ITEM_PRIORITY,         IDC_PRIORITY_VALUE,
    MSG_VIEW_ITEM_CSID,             IDC_CSID_VALUE,
    MSG_VIEW_ITEM_TSID,             IDC_TSID_VALUE,
    MSG_VIEW_ITEM_ORIG_TIME,        IDC_SCHEDULED_TIME_VALUE,
    MSG_VIEW_ITEM_RETRIES,          IDC_RETRIES_VALUE,
    MSG_VIEW_ITEM_ID,               IDC_JOB_ID_VALUE,
    MSG_VIEW_ITEM_BROADCAST_ID,     IDC_BROADCAST_ID_VALUE,
    MSG_VIEW_ITEM_SUBMIT_TIME,      IDC_SUBMISSION_TIME_VALUE,
    MSG_VIEW_ITEM_BILLING,          IDC_BILLING_CODE_VALUE,
	MSG_VIEW_ITEM_SERVER,			IDC_SERVER_VALUE
};

/////////////////////////////////////////////////////////////////////////////
// CSentItemsDetailsPg property page

IMPLEMENT_DYNCREATE(CSentItemsDetailsPg, CMsgPropertyPg)


CSentItemsDetailsPg::CSentItemsDetailsPg(
    CFaxMsg* pMsg     // pointer to CArchiveMsg
) : 
    CMsgPropertyPg(CSentItemsDetailsPg::IDD, pMsg)
{
}

CSentItemsDetailsPg::~CSentItemsDetailsPg()
{
}

void CSentItemsDetailsPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSentItemsDetailsPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSentItemsDetailsPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(CSentItemsDetailsPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSentItemsDetailsPg message handlers

BOOL 
CSentItemsDetailsPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CSentItemsDetailsPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\sentitemsdetailspg.h ===
#if !defined(AFX_SENTITEMSDETAILSPG_H__E5645AEB_4289_4D6D_B000_60C3A52638F0__INCLUDED_)
#define AFX_SENTITEMSDETAILSPG_H__E5645AEB_4289_4D6D_B000_60C3A52638F0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SentItemsDetailsPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSentItemsDetailsPg dialog

class CSentItemsDetailsPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(CSentItemsDetailsPg)

// Construction
public:
	CSentItemsDetailsPg(CFaxMsg* pMsg);
	~CSentItemsDetailsPg();

// Dialog Data
	//{{AFX_DATA(CSentItemsDetailsPg)
	enum { IDD = IDD_SENT_ITEMS_DETAILS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSentItemsDetailsPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    CSentItemsDetailsPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(CSentItemsDetailsPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SENTITEMSDETAILSPG_H__E5645AEB_4289_4D6D_B000_60C3A52638F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\servernode.cpp ===
// ServerNode.cpp: implementation of the CServerNode class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     23

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CServerNode, CTreeNode)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CServerNode::CServerNode() :
    CTreeNode(FOLDER_TYPE_SERVER),
    m_bValid(TRUE),
    m_dwRights (0),
    m_dwQueueState (0),
    m_bSelfDestruct (FALSE),
    m_hConnection (NULL),
    m_hNotification (NULL),
    m_bCsBuildupValid (FALSE),
    m_bCsBuildupThreadValid(FALSE),
    m_hBuildupThread (NULL),
    m_bInBuildup (FALSE),
    m_dwLastRPCError (0),
    m_Inbox (FOLDER_TYPE_INBOX, FAX_MESSAGE_FOLDER_INBOX),
    m_SentItems (FOLDER_TYPE_SENT_ITEMS, FAX_MESSAGE_FOLDER_SENTITEMS),
    m_Outbox (FOLDER_TYPE_OUTBOX, JT_SEND),
    m_Incoming (FOLDER_TYPE_INCOMING, JT_RECEIVE | JT_ROUTING)
{}

CServerNode::~CServerNode()
{
    DBG_ENTER(TEXT("CServerNode::~CServerNode"), TEXT("%s"), m_cstrMachine);
    DWORD dwRes = StopBuildThread ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::StopBuildThread"), dwRes);
    }
    dwRes = Disconnect (TRUE);    // Shutdown aware
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::Disconnect"), dwRes);
    }
    if (m_bCsBuildupValid)
    {
        DeleteCriticalSection (&m_csBuildup);
    }
    if(m_bCsBuildupThreadValid)
    {
        DeleteCriticalSection (&m_csBuildupThread);
    }
}

void CServerNode::AssertValid() const
{
    CObject::AssertValid();
}

void CServerNode::Dump( CDumpContext &dc ) const
{
    CObject::Dump( dc );
    dc << TEXT(" Server = ") << m_cstrMachine;
}

//
// Static class members:
//
CServerNode::MESSAGES_MAP CServerNode::m_sMsgs;
DWORD        CServerNode::m_sdwMinFreeMsg = WM_SERVER_NOTIFY_BASE;
CRITICAL_SECTION CServerNode::m_sMsgsCs;
BOOL CServerNode::m_sbMsgsCsInitialized = FALSE;

DWORD 
CServerNode::InitMsgsMap ()
/*++

Routine name : CServerNode::InitMsgsMap

Routine description:

    Initializes the notification messages map

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::InitMsgsMap"), dwRes);

    ASSERTION (!m_sbMsgsCsInitialized);
    try
    {
        InitializeCriticalSection (&m_sMsgsCs);
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("InitializeCriticalSection"), dwRes);
        return dwRes;
    }
    m_sbMsgsCsInitialized = TRUE;
    return dwRes;
}   // CServerNode::InitMsgsMap

DWORD 
CServerNode::ShutdownMsgsMap ()
/*++

Routine name : CServerNode::ShutdownMsgsMap

Routine description:

    Shuts down the notification messages map

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::ShutdownMsgsMap"), dwRes);

    if (!m_sbMsgsCsInitialized)
    {
        return dwRes;
    }
    EnterCriticalSection (&m_sMsgsCs);
    m_sMsgs.clear ();
    LeaveCriticalSection (&m_sMsgsCs);
    m_sbMsgsCsInitialized = FALSE;
    DeleteCriticalSection (&m_sMsgsCs);
    return dwRes;
}   // CServerNode::ShutdownMsgsMap

CServerNode *
CServerNode::LookupServerFromMessageId (
    DWORD dwMsgId
)
/*++

Routine name : CServerNode::LookupServerFromMessageId

Routine description:

    Given a mesage id, looks up the server this message was sent to

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwMsgId                       [in]     - Message id

Return Value:

    Server node that should process the message or NULL if message id is not mapped

--*/
{
    DBG_ENTER(TEXT("CServerNode::LookupServerFromMessageId"), TEXT("%ld"), dwMsgId);
    CServerNode *pRes = NULL;
    if (!m_sbMsgsCsInitialized)
    {
        return pRes;
    }
    EnterCriticalSection (&m_sMsgsCs);
    MESSAGES_MAP::iterator it = m_sMsgs.find (dwMsgId);
    if (m_sMsgs.end() == it)
    {
        //
        // Item not found there
        //
        VERBOSE (DBG_MSG, 
                 TEXT("Notification message %ld has no associated server"),
                 dwMsgId);
    }
    else
    {
        pRes = (*it).second;
    }
    LeaveCriticalSection (&m_sMsgsCs);
    return pRes;
}   // CServerNode::LookupServerFromMessageId


DWORD 
CServerNode::AllocateNewMessageId (
    CServerNode *pServer, 
    DWORD &dwMsgId
)
/*++

Routine name : CServerNode::AllocateNewMessageId

Routine description:

    Allocates a new message id for server's notification

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pServer                       [in]     - Pointer to server
    dwMsgId                       [out]    - New message id

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::AllocateNewMessageId"), dwRes, TEXT("%s"), pServer->Machine());

    if (!m_sbMsgsCsInitialized)
    {
        //
        // Map no longer exists
        //
        dwRes = ERROR_SHUTDOWN_IN_PROGRESS;
        return dwRes;
    }

    EnterCriticalSection (&m_sMsgsCs);
    for (DWORD dw = m_sdwMinFreeMsg; ; dw++)
    {
        CServerNode *pSrv = LookupServerFromMessageId (dw);
        if (!pSrv)
        {
            //
            // Free spot found
            //
            dwMsgId = dw;
            try
            {
                m_sMsgs[dwMsgId] = pServer;
            }
            catch (...)
            {
                //
                // Not enough memory
                //
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                CALL_FAIL (MEM_ERR, TEXT("map::operator []"), dwRes);
                goto exit;
            }
            //
            // Success
            //
            VERBOSE (DBG_MSG, 
                     TEXT("Server %s registered for notification on message 0x%08x"),
                     pServer->Machine(),
                     dwMsgId);
            goto exit;
        }
    }

exit:
    LeaveCriticalSection (&m_sMsgsCs);
    return dwRes;                
}   // CServerNode::AllocateNewMessageId

DWORD 
CServerNode::FreeMessageId (
    DWORD dwMsgId
)
/*++

Routine name : CServerNode::FreeMessageId

Routine description:

    Frees a message id back to the map

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwMsgId           [in]     - Message id to free

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::FreeMessageId"), dwRes);

    if (!m_sbMsgsCsInitialized)
    {
        //
        // Map no longer exists
        //
        dwRes = ERROR_SHUTDOWN_IN_PROGRESS;
        return dwRes;
    }
    EnterCriticalSection (&m_sMsgsCs);
    try
    {
        m_sMsgs.erase (dwMsgId);
    }
    catch (...)
    {
        //
        // Not enough memory
        //
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("map::erase"), dwRes);
        goto exit;
    }
    //
    // Success
    //
    VERBOSE (DBG_MSG, 
             TEXT("Server unregistered for notification on message 0x%08x"),
             dwMsgId);

    if (dwMsgId < m_sdwMinFreeMsg)
    {
        //
        // Free spot was created lower than before.
        //
        m_sdwMinFreeMsg = dwMsgId;
    }
exit:
    LeaveCriticalSection (&m_sMsgsCs);
    return dwRes;
}   // CServerNode::FreeMessageId


DWORD 
CServerNode::Connect()
/*++

Routine name : CServerNode::Connect

Routine description:

    Connects to the fax server

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::Connect"), dwRes, TEXT("%s"), m_cstrMachine);

    ASSERTION (!m_hConnection);
    START_RPC_TIME(TEXT("FaxConnectFaxServer"));    
    if (!FaxConnectFaxServer ((LPCTSTR)m_cstrMachine, &m_hConnection))
    {
        dwRes = GetLastError ();
        SetLastRPCError (dwRes, FALSE); // Don't disconnect on error
        CALL_FAIL (RPC_ERR, TEXT("FaxConnectFaxServer"), dwRes);
        m_hConnection = NULL;
    }
    END_RPC_TIME(TEXT("FaxConnectFaxServer"));    
    return dwRes;
}   // CServerNode::Connect

DWORD 
CServerNode::Disconnect(
    BOOL bShutdownAware,
    BOOL bWaitForBuildThread
)
/*++

Routine name : CServerNode::Disconnect

Routine description:

    Disconnects from the server and closes the notification handle.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bShutdownAware    [in]     - If TRUE, disables disconnection 
                                 while application is shutting down
    bWaitForBuildThread [in]   - If TRUE, wait for build threads stop
Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::Disconnect"), dwRes, TEXT("%s"), m_cstrMachine);

    if(bWaitForBuildThread)
    {
        //
        // just turn on m_bStopBuildup flag
        //
        StopBuildThread (FALSE);
        m_Inbox.StopBuildThread(FALSE);
        m_SentItems.StopBuildThread(FALSE);
        m_Outbox.StopBuildThread(FALSE);
        m_Incoming.StopBuildThread(FALSE);

        //
        // wait for the all threads finish
        //
        dwRes = StopBuildThread();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::StopBuildThread"), dwRes);
        }

        dwRes = m_Inbox.StopBuildThread();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("m_Inbox.StopBuildThread"), dwRes);
        }

        dwRes = m_SentItems.StopBuildThread();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("m_SentItems.StopBuildThread"), dwRes);
        }

        dwRes = m_Outbox.StopBuildThread();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("m_Outbox.StopBuildThread"), dwRes);
        }

        dwRes = m_Incoming.StopBuildThread();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("m_Incoming.StopBuildThread"), dwRes);
        }
    }

    if (!m_hConnection)
    {
        //
        // Already disconnected
        //
        return dwRes;
    }
    if (bShutdownAware && CClientConsoleDoc::ShuttingDown())
    {
        VERBOSE (DBG_MSG,
                 TEXT("Left open connection (and notification) to %s because we're shutting down."),
                 m_cstrMachine);
        return dwRes;
    }

    if (m_hNotification)
    {
        //
        // Unregister server notifications
        //
        START_RPC_TIME(TEXT("FaxUnregisterForServerEvents"));    
        if (!FaxUnregisterForServerEvents (m_hNotification))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxUnregisterForServerEvents")); 
            SetLastRPCError (dwRes, FALSE); // Don't disconnect on error
            CALL_FAIL (RPC_ERR, TEXT("FaxUnregisterForServerEvents"), dwRes);
            //
            // Carry on with disconnection
            //
        }
        END_RPC_TIME(TEXT("FaxUnregisterForServerEvents")); 
        //
        // Free the message id back to the map
        //
        dwRes = FreeMessageId (m_dwMsgId);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("FreeMessageId"), dwRes);
            //
            // Carry on with disconnection
            //
        }
    }
    //
    // Close connection
    //
    START_RPC_TIME(TEXT("FaxClose"));    
    if (!FaxClose (m_hConnection))
    {
        dwRes = GetLastError ();
        END_RPC_TIME(TEXT("FaxClose")); 
        SetLastRPCError (dwRes, FALSE); // Don't disconnect on error
        CALL_FAIL (RPC_ERR, TEXT("FaxClose"), dwRes);
        m_hConnection = NULL;
        return dwRes;
    }
    END_RPC_TIME(TEXT("FaxClose")); 
    m_hConnection = NULL;
    m_hNotification = NULL;

    return dwRes;
}   // CServerNode::Disconnect

DWORD 
CServerNode::GetConnectionHandle (
    HANDLE &hFax
)
/*++

Routine name : CServerNode::GetConnectionHandle

Routine description:

    Retrieves connection handle (re-connects if neeed)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    hFax                          [out]    - Connection handle

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::GetConnectionHandle"), dwRes);


    //
    // Protect the m_hBuildupThread from CloseHandle() more then once
    //
    EnterCriticalSection (&m_csBuildupThread);

    if (m_hConnection)
    {
        //
        // We already have a live connection
        //
        hFax = m_hConnection;
        goto exit;
    }

    //
    // Refresh server state with first connection.
    // RefreshState() creates a background thread that will call Connect()
    //
    dwRes = RefreshState();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshState"), dwRes);
        goto exit;
    }
    if(NULL != m_hBuildupThread)
    {
        //
        // Wait for that background thread to end
        //
        dwRes = WaitForThreadDeathOrShutdown (m_hBuildupThread);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("WaitForThreadDeathOrShutdown"), dwRes);
        }
        CloseHandle (m_hBuildupThread);
        m_hBuildupThread = NULL;
    }
    hFax = m_hConnection;

    if(!hFax)
    {
        dwRes = ERROR_INVALID_HANDLE;
    }

exit:
    LeaveCriticalSection (&m_csBuildupThread);

    return dwRes;
}   // CServerNode::GetConnectionHandle 

DWORD 
CServerNode::Init (
    LPCTSTR tstrMachine
)
/*++

Routine name : CServerNode::Init

Routine description:

    Inits server node information

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    tstrMachine                   [in]     - Server machine name

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::Init"), dwRes);

    ASSERTION (!m_bCsBuildupValid);
    ASSERTION (!m_hConnection);
    //
    // Create buildup thread critical section
    //
    try
    {
        InitializeCriticalSection (&m_csBuildup);
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("InitializeCriticalSection(&m_csBuildup)"), dwRes);
        return dwRes;
    }
    m_bCsBuildupValid = TRUE;

    try
    {
        InitializeCriticalSection (&m_csBuildupThread);
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("InitializeCriticalSection(&m_csBuildupThread)"), dwRes);
        return dwRes;
    }
    m_bCsBuildupThreadValid = TRUE;

    //
    // Save our connection + server names
    //
    try
    {
        m_cstrMachine = tstrMachine;
        //
        // Remove leading backslashes from machine's name
        //
        m_cstrMachine.Remove (TEXT('\\'));
    }
    catch (CException *pException)
    {
        TCHAR wszCause[1024];

        pException->GetErrorMessage (wszCause, 1024);
        pException->Delete ();
        VERBOSE (EXCEPTION_ERR,
                 TEXT("CString::operator = caused exception : %s"), 
                 wszCause);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        return dwRes;
    }
    dwRes = CreateFolders ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CreateFolders"), dwRes);
    }
    return dwRes;
}   // CServerNode::Init

DWORD
CServerNode::SetNewQueueState (
    DWORD dwNewState
)
/*++

Routine name : CServerNode::SetNewQueueState

Routine description:

    Sets the news state of the queue

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwNewState                    [in]     - New queue state

Return Value:

    Standard Win32 error code

--*/
{
    HANDLE hFax;
    DWORD dwRes;
    DBG_ENTER(TEXT("CServerNode::SetNewQueueState"), dwRes);

    dwRes = GetConnectionHandle(hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        return dwRes;
    }
    START_RPC_TIME(TEXT("FaxSetQueue"));    
    if (!FaxSetQueue (hFax, dwNewState))
    {
        dwRes = GetLastError ();
        END_RPC_TIME(TEXT("FaxSetQueue")); 
        SetLastRPCError (dwRes);
        CALL_FAIL (RPC_ERR, TEXT("FaxSetQueue"), dwRes);
        return dwRes;
    }
    END_RPC_TIME(TEXT("FaxSetQueue")); 
    return dwRes;
}   // CServerNode::SetNewQueueState

DWORD 
CServerNode::BlockIncoming (
    BOOL bBlock
)
/*++

Routine name : CServerNode::BlockIncoming

Routine description:

    Blocks / unblocks the incoming queue

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bBlock                        [in]     - TRUE if block

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CServerNode::BlockIncoming"), dwRes);

    DWORD dwNewState = bBlock ? (m_dwQueueState | FAX_INCOMING_BLOCKED) : 
                                (m_dwQueueState & ~FAX_INCOMING_BLOCKED);
    dwRes = SetNewQueueState (dwNewState);
    if (ERROR_SUCCESS == dwRes)
    {
        m_dwQueueState = dwNewState;
    }
    return dwRes;
}   // CServerNode::BlockIncoming

DWORD 
CServerNode::BlockOutbox (
    BOOL bBlock
)
/*++

Routine name : CServerNode::BlockOutbox

Routine description:

    Blocks / unblocks the outgoing queue

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bBlock                        [in]     - TRUE if block

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CServerNode::BlockOutbox"), dwRes);

    DWORD dwNewState = bBlock ? (m_dwQueueState | FAX_OUTBOX_BLOCKED) : 
                                (m_dwQueueState & ~FAX_OUTBOX_BLOCKED);
    dwRes = SetNewQueueState (dwNewState);
    if (ERROR_SUCCESS == dwRes)
    {
        m_dwQueueState = dwNewState;
    }
    return dwRes;
}   // CServerNode::BlockOutbox

DWORD 
CServerNode::PauseOutbox (
    BOOL bPause
)
/*++

Routine name : CServerNode::PauseOutbox

Routine description:

    Pauses / resumes the outgoing queue

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bPause                        [in]     - TRUE if pause

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CServerNode::PauseOutbox"), dwRes);

    DWORD dwNewState = bPause ? (m_dwQueueState | FAX_OUTBOX_PAUSED) : 
                                (m_dwQueueState & ~FAX_OUTBOX_PAUSED);
    dwRes = SetNewQueueState (dwNewState);
    if (ERROR_SUCCESS == dwRes)
    {
        m_dwQueueState = dwNewState;
    }
    return dwRes;
}   // CServerNode::PauseOutbox

    
DWORD 
CServerNode::CreateFolders ()
/*++

Routine name : CServerNode::CreateFolders

Routine description:

    Creates the 4 folders of the server

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::CreateFolders"), dwRes);

    //
    // Create inbox folder
    //
    m_Inbox.SetServer(this);

    dwRes = m_Inbox.Init ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CMessageFolder::Init"), dwRes);
        goto error;
    }
    //
    // Create outbox folder
    //
    m_Outbox.SetServer(this);

    dwRes = m_Outbox.Init ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CQueueFolder::Init"), dwRes);
        goto error;
    }
    //
    // Create sentitems folder
    //
    m_SentItems.SetServer(this);

    dwRes = m_SentItems.Init ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CMessageFolder::Init"), dwRes);
        goto error;
    }
    //
    // Create incoming folder
    //
    m_Incoming.SetServer(this);

    dwRes = m_Incoming.Init ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CQueueFolder::Init"), dwRes);
        goto error;
    }

    ASSERTION (ERROR_SUCCESS == dwRes);

error:
    return dwRes;            
}   // CServerNode::CreateFolders


DWORD 
CServerNode::InvalidateSubFolders (
    BOOL bClearView
)
/*++

Routine name : CServerNode::InvalidateSubFolders

Routine description:

    Invalidates the contents of all 4 sub folders

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bClearView     [in] Should we clear attached view ?

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::InvalidateSubFolders"), dwRes);

    dwRes = m_Inbox.InvalidateContents (bClearView);   
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("m_Inbox.InvalidateContents"), dwRes);
        return dwRes;
    }
    dwRes = m_Outbox.InvalidateContents (bClearView);   
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("m_Outbox.InvalidateContents"), dwRes);
        return dwRes;
    }
    dwRes = m_SentItems.InvalidateContents (bClearView);   
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("m_SentItems.InvalidateContents"), dwRes);
        return dwRes;
    }
    dwRes = m_Incoming.InvalidateContents (bClearView);   
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("m_Incoming.InvalidateContents"), dwRes);
        return dwRes;
    }
    return dwRes;
}   // CServerNode::InvalidateSubFolders

    

//
// Buildup thread functions:
//

DWORD
CServerNode::ClearContents ()
/*++

Routine name : CServerNode::ClearContents

Routine description:

    Clears the server's contents

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CServerNode::ClearContents"), dwRes);

    dwRes = Disconnect ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("Disconnect"), dwRes);
        return dwRes;
    }
    dwRes = InvalidateSubFolders(FALSE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("InvalidateSubFolders"), dwRes);
        return dwRes;
    }
    return dwRes;
}   // CServerNode::ClearContents

DWORD 
CServerNode::RefreshState()
/*++

Routine name : CServerNode::RefreshState

Routine description:

    Refreshes the server's state

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CServerNode::RefreshState"), dwRes, TEXT("%s"), m_cstrMachine);

    DWORD dwThreadId;
    //
    // Stop the current (if any) buildup thread and make sure it's dead
    //
    dwRes = StopBuildThread ();
    EnterCriticalSection (&m_csBuildup);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("CServerNode::StopBuildThread"), dwRes);
        goto exit;
    }
    //
    // Tell our view to refresh our image
    //
    m_bInBuildup = TRUE;
    //
    // Start the thread that will fill the data (in the background)
    //
    m_bStopBuildup = FALSE;
    m_hBuildupThread = CreateThread (  
                        NULL,               // No security
                        0,                  // Default stack size
                        BuildupThreadProc,  // Thread procedure
                        (LPVOID)this,       // Parameter
                        0,                  // Normal creation
                        &dwThreadId         // We must have a thread id for win9x
                     );
    if (NULL == m_hBuildupThread)
    {
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("CreateThread"), dwRes);
        goto exit;
    }
    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&m_csBuildup);
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Build up failed
        //
        m_bInBuildup = FALSE;
    }
    return dwRes;
}   // CServerNode::RefreshState

DWORD
CServerNode::Buildup ()
/*++

Routine name : CServerNode::Buildup

Routine description:

    Server refresh worker thread function.
    Works in a background thread and performs the following:
       1. FaxConnectFaxServer (if not already connected)
       2. FaxGetQueueStates
       3. FaxAccessCheckEx (MAXIMUM_ALLOWED)
       4. FaxRegisterForServerEvents

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::Buildup"), dwRes, TEXT("%s"), m_cstrMachine);

    HANDLE hFax;
    HWND hwnd;
    CMainFrame *pMainFrm = NULL;
    DWORD dwEventTypes = FAX_EVENT_TYPE_OUT_QUEUE |     // Outbox events
                         FAX_EVENT_TYPE_QUEUE_STATE |   // Paused / blocked queue events
                         FAX_EVENT_TYPE_OUT_ARCHIVE |   // SentItems events
                         FAX_EVENT_TYPE_FXSSVC_ENDED;   // Server shutdown events

    //
    // get connection
    //
    if (m_hConnection)
    {
        hFax = m_hConnection;
    }
    else
    {
        dwRes = Connect ();
        if (ERROR_SUCCESS != dwRes)
        {
            goto exit;
        }
        ASSERTION (m_hConnection);
        hFax = m_hConnection;
    }
    
    if (m_bStopBuildup)
    {
        //
        // Thread should stop abruptly
        //
        dwRes = ERROR_CANCELLED;
        goto exit;
    }
    {
        START_RPC_TIME(TEXT("FaxGetQueueStates"));    
        if (!FaxGetQueueStates (hFax, &m_dwQueueState))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxGetQueueStates"));    
            SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxGetQueueStates"), dwRes);
            goto exit;
        }
        END_RPC_TIME(TEXT("FaxGetQueueStates"));    
    }
    if (m_bStopBuildup)
    {
        //
        // Thread should stop abruptly
        //
        dwRes = ERROR_CANCELLED;
        goto exit;
    }

    {
        //
        // retrieve the access rights of the caller
        //
        START_RPC_TIME(TEXT("FaxAccessCheckEx"));    
        if (!FaxAccessCheckEx (hFax, MAXIMUM_ALLOWED, &m_dwRights))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxAccessCheckEx"));    
            SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxAccessCheckEx"), dwRes);
            goto exit;
        }
        END_RPC_TIME(TEXT("FaxAccessCheckEx"));    
    }
    if (m_bStopBuildup)
    {
        //
        // Thread should stop abruptly
        //
        dwRes = ERROR_CANCELLED;
        goto exit;
    }

    //
    // Register for notifications - start by allocating a message id
    //
    if(m_hNotification)
    {
        //
        // already registered
        //
        goto exit;
    }

    dwRes = AllocateNewMessageId (this, m_dwMsgId);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("AllocateNewMessageId"), dwRes);
        goto exit;
    }

    //
    // Ask the server for a notification handle
    //  
    pMainFrm = GetFrm();
    if (NULL == pMainFrm)
    {
        //
        // No main frame - probably we're shutting down
        //
        goto exit;
    }
    hwnd = pMainFrm->m_hWnd;

    if (CanSeeAllJobs())
    {
        dwEventTypes |= FAX_EVENT_TYPE_IN_QUEUE;    // Incoming folder events
    }
    if (CanSeeInbox())
    {
        dwEventTypes |= FAX_EVENT_TYPE_IN_ARCHIVE;  // Inbox folder events
    }
       
    {
        START_RPC_TIME(TEXT("FaxRegisterForServerEvents"));    
        if (!FaxRegisterForServerEvents (   
                    hFax,
                    dwEventTypes,   // Types of events to receive
                    NULL,           // Not using completion ports
                    0,              // Not using completion ports
                    hwnd,           // Handle of window to receive notification messages
                    m_dwMsgId,      // Message id
                    &m_hNotification// Notification handle
           ))
        {
            dwRes = GetLastError ();
            SetLastRPCError (dwRes, FALSE);    // Do not auto-disconnect
            CALL_FAIL (RPC_ERR, TEXT("FaxRegisterForServerEvents"), dwRes);
            m_hNotification = NULL;
            goto exit;
        }
        END_RPC_TIME(TEXT("FaxRegisterForServerEvents"));    
    }
    ASSERTION (ERROR_SUCCESS == dwRes);

exit:

    m_bInBuildup = FALSE;

    if (!m_bStopBuildup)
    {
        if (ERROR_SUCCESS != dwRes)
        {
            //
            // Some error occured during refresh
            //
            Disconnect (FALSE, FALSE);
        }
    }

    //
    // Check if the frame still alive
    //
    pMainFrm = GetFrm();
    if (pMainFrm)
    {
        pMainFrm->RefreshStatusBar ();
    }

    return dwRes;
}   // CServerNode::Buildup


DWORD 
WINAPI 
CServerNode::BuildupThreadProc (
    LPVOID lpParameter
)
/*++

Routine name : CServerNode::BuildupThreadProc

Routine description:

    Server refresh thread entry point.
    This is a static function which accepts a pointer to the actual CServerNode instance
    and calls the Buildup function on the real instance.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    lpParameter   [in]     - Pointer to server node that created the thread

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::BuildupThreadProc"), dwRes);

    CServerNode *pServer = (CServerNode *)lpParameter;
    ASSERTION (pServer);
    ASSERT_KINDOF (CServerNode, pServer);

    dwRes = pServer->Buildup ();
    if (pServer->m_bSelfDestruct)
    {
        //
        // Object was waiting for thread to stop before it could destruct itself
        //
        delete pServer;
    }
    return dwRes;
}   // CServerNode::BuildupThreadProc


DWORD            
CServerNode::StopBuildThread (
    BOOL bWaitForDeath
)
/*++

Routine name : CServerNode::StopBuildThread

Routine description:

    Stops the server's buildup thread

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bWaitForDeath      [in]     - If TRUE, waits until the thread is dead

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::StopBuildThread"), dwRes);

    m_bStopBuildup = TRUE;
    if (!bWaitForDeath)
    {
        return dwRes;
    }

    //
    // Protect the m_hBuildupThread from CloseHandle() more then once
    //
    if(!m_bCsBuildupThreadValid)
    {
        return dwRes;
    }
    EnterCriticalSection (&m_csBuildupThread);

    if(NULL == m_hBuildupThread)
    {
        goto exit;
    }
    //
    // Wait for build thread to die
    //
    dwRes = WaitForThreadDeathOrShutdown (m_hBuildupThread);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("WaitForThreadDeathOrShutdown"), dwRes);
    }
    CloseHandle (m_hBuildupThread);
    m_hBuildupThread = NULL;

exit:
    LeaveCriticalSection (&m_csBuildupThread);

    return dwRes;
}   // CServerNode::StopBuildThread

BOOL  
CServerNode::FatalRPCError (
    DWORD dwErr
)
/*++

Routine name : CServerNode::FatalRPCError

Routine description:

    Checks if an error code means a fatal RPC connection state

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    dwErr         [in]     - Error code to check

Return Value:

    TRUE if error code means a fatal RPC connection state, FALSE otherwise.

--*/
{
    BOOL bRes = FALSE;
    DBG_ENTER(TEXT("CServerNode::FatalRPCError"), bRes);

    switch (bRes)
    {
        case RPC_S_INVALID_BINDING:
        case EPT_S_CANT_PERFORM_OP:
        case RPC_S_ADDRESS_ERROR:
        case RPC_S_COMM_FAILURE:
        case RPC_S_NO_BINDINGS:
        case RPC_S_SERVER_UNAVAILABLE:
            //
            // Something really bad happened to our RPC connection
            //
            bRes = TRUE;
            break;
    }
    return bRes;
}   // CServerNode::FatalRPCError


void 
CServerNode::SetLastRPCError (
    DWORD dwErr, 
    BOOL DisconnectOnFailure
)
/*++

Routine name : CServerNode::SetLastRPCError

Routine description:

    Sets the last RPC error encountered on this server

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwErr               [in]     - Error code
    DisconnectOnFailure [in]     - If TRUE, disconnects from the server upon error

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CServerNode::SetLastRPCError"), TEXT("%ld"), dwErr);

    m_dwLastRPCError = dwErr;
    if (DisconnectOnFailure && FatalRPCError(dwErr))
    {
        //
        // We have a real failure here - disconnect now.
        //
        DWORD dwRes = Disconnect ();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RPC_ERR, TEXT("CServerNode::Disconnect"), dwRes);
        }
    }
}   // CServerNode::SetLastRPCError

void
CServerNode::Destroy ()
/*++

Routine name : CServerNode::Destroy

Routine description:

    Destroys the server's node.
    Since the dtor is private, this is the only way to destroy the server node.
    
    If the server is not busy refreshing itself, it deletes itself.
    Otherwise, it signals a suicide request and the thread destorys the node.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    if (m_bSelfDestruct)
    {
        //
        // Already being destroyed
        //
        return;
    }
    EnterCriticalSection (&m_csBuildup);
    m_bSelfDestruct = TRUE;
    if (m_hBuildupThread)
    {
        //
        // Thread is running, just mark request for self-destruction
        //
        LeaveCriticalSection (&m_csBuildup);
    }
    else
    {
        //
        // Suicide
        //
        LeaveCriticalSection (&m_csBuildup);

        try
        {
            delete this;
        }
        catch (...)
        {
            DBG_ENTER(TEXT("CServerNode::Destroy"));
            CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::Destructor exception"), 0);
            ASSERTION_FAILURE;
        }
    }
}   // CServerNode::Destroy 

DWORD
CServerNode::GetActivity(
    CString& cstrText, 
    TreeIconType& iconIndex
) const
/*++

Routine name : CServerNode::GetActivityStringResource

Routine description:

    Returns the resource id of a string identifying the activity of the server

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    cstrText       [out] - activity string
    iconIndex      [out] - icon index

Return Value:

    Activity string resource id

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::GetActivity"), dwRes);

    DWORD dwStrRes = 0;
    if (IsRefreshing())
    {
        iconIndex = TREE_IMAGE_SERVER_REFRESHING;
        dwStrRes = IDS_SERVER_REFRESHING;
    }
    else if (IsOnline ())
    {
        if (IsOutboxBlocked())
        {
            //
            // Server's Outgoing queue is blocked
            //
            iconIndex = TREE_IMAGE_OUTBOX_BLOCKED;
            dwStrRes = IDS_SERVER_OUTBOX_BLOCKED;
        }
        else if (IsOutboxPaused())
        {
            //
            // Server's Outgoing queue is paused
            //
            iconIndex = TREE_IMAGE_OUTBOX_PAUSED;
            dwStrRes = IDS_SERVER_OUTBOX_PAUSED;
        }
        else
        {
            //
            // Server's Outgoing queue is fully functional
            //
            iconIndex = TREE_IMAGE_SERVER_ONLINE;
            dwStrRes = IDS_SERVER_ONLINE;
        }
    }
    else
    {
        iconIndex = TREE_IMAGE_SERVER_OFFLINE;

        //
        // Server is offline
        //
        if (RPC_S_SERVER_UNAVAILABLE == m_dwLastRPCError)
        {
            //
            // The RPC server is unavailable.
            //
            dwStrRes = IDS_SERVER_OFFLINE;
        }
        else
        {
            //
            // General network / RPC error
            //
            dwStrRes = IDS_SERVER_NET_ERROR;
        }
    }

    dwRes = LoadResourceString(cstrText, dwStrRes);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("LoadResourceString"), dwRes);
        return dwRes;
    }                    

    return dwRes;

}   // CServerNode::GetActivityStringResource



DWORD  
CServerNode::OnNotificationMessage (
    PFAX_EVENT_EX pEvent
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::OnNotificationMessage"), dwRes);

    ASSERTION (pEvent);

    switch (pEvent->EventType)
    {
        case FAX_EVENT_TYPE_IN_QUEUE:
            //
            // Something happened in the incoming folder
            //
            if (m_Incoming.Locked() || !m_Incoming.IsValid())
            {
                //
                // Folder is locked or invalid - do not process notifications
                //
                dwRes = ERROR_LOCK_VIOLATION;
                VERBOSE (DBG_MSG, 
                         TEXT("Incoming folder is locked or invalid - notification is NOT processed"));
                return dwRes;
            }

            switch (pEvent->EventInfo.JobInfo.Type)
            {
                case FAX_JOB_EVENT_TYPE_ADDED:
                    //
                    // A job was added
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_QUEUE / FAX_JOB_EVENT_TYPE_ADDED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_Incoming.OnJobAdded (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                case FAX_JOB_EVENT_TYPE_REMOVED:
                    //
                    // A job was removed
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_QUEUE / FAX_JOB_EVENT_TYPE_REMOVED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_Incoming.OnJobRemoved (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                case FAX_JOB_EVENT_TYPE_STATUS:
                    //
                    // A job has changed its status
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_QUEUE / FAX_JOB_EVENT_TYPE_STATUS")
                             TEXT(" / 0x%016I64x (status = 0x%08x)"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId,
                             pEvent->EventInfo.JobInfo.pJobData->dwQueueStatus);

                    if((pEvent->EventInfo.JobInfo.pJobData->dwQueueStatus & JS_COMPLETED) ||
                       (pEvent->EventInfo.JobInfo.pJobData->dwQueueStatus & JS_CANCELED))
                    {
                        //
                        // don't display completed or canceled jobs
                        //
                        dwRes = m_Incoming.OnJobRemoved (pEvent->EventInfo.JobInfo.dwlMessageId);
                    }
                    else
                    {
                        dwRes = m_Incoming.OnJobUpdated (pEvent->EventInfo.JobInfo.dwlMessageId,
                                                         pEvent->EventInfo.JobInfo.pJobData); 
                    }

                    break;

                default:
                    dwRes = ERROR_GEN_FAILURE;
                    VERBOSE (DBG_MSG, 
                             TEXT("Got unknown server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_QUEUE / %d / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.Type,
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;
            }
            break;

        case FAX_EVENT_TYPE_OUT_QUEUE:
            //
            // Something happened in the outbox folder
            //
            if (m_Outbox.Locked() || !m_Outbox.IsValid())
            {
                //
                // Folder is locked or invalid - do not process notifications
                //
                dwRes = ERROR_LOCK_VIOLATION;
                VERBOSE (DBG_MSG, 
                         TEXT("Outbox folder is locked or invalid - notification is NOT processed"));
                return dwRes;
            }
            switch (pEvent->EventInfo.JobInfo.Type)
            {
                case FAX_JOB_EVENT_TYPE_ADDED:
                    //
                    // A job was added
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_QUEUE / FAX_JOB_EVENT_TYPE_ADDED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_Outbox.OnJobAdded (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                case FAX_JOB_EVENT_TYPE_REMOVED:
                    //
                    // A job was removed
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_QUEUE / FAX_JOB_EVENT_TYPE_REMOVED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_Outbox.OnJobRemoved (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                case FAX_JOB_EVENT_TYPE_STATUS:
                    //
                    // A job has changed its status
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_QUEUE / FAX_JOB_EVENT_TYPE_STATUS")
                             TEXT(" / 0x%016I64x (status = 0x%08x)"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId,
                             pEvent->EventInfo.JobInfo.pJobData->dwQueueStatus);

                    if((pEvent->EventInfo.JobInfo.pJobData->dwQueueStatus & JS_COMPLETED) ||
                       (pEvent->EventInfo.JobInfo.pJobData->dwQueueStatus & JS_CANCELED))
                    {
                        //
                        // don't display completed or canceled jobs
                        //
                        dwRes = m_Outbox.OnJobRemoved (pEvent->EventInfo.JobInfo.dwlMessageId);
                    }
                    else
                    {
                        dwRes = m_Outbox.OnJobUpdated (pEvent->EventInfo.JobInfo.dwlMessageId,
                                                       pEvent->EventInfo.JobInfo.pJobData); 
                    }

                    break;

                default:
                    dwRes = ERROR_GEN_FAILURE;
                    VERBOSE (DBG_MSG, 
                             TEXT("Got unknown server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_QUEUE / %d / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.Type,
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;
            }
            break;

        case FAX_EVENT_TYPE_QUEUE_STATE:
            //
            // Queue states have changed.
            // Update internal data with new queue states.
            //
            VERBOSE (DBG_MSG, 
                     TEXT("Got server notification from %s - FAX_EVENT_TYPE_QUEUE_STATE / %d"),
                     m_cstrMachine, 
                     pEvent->EventInfo.dwQueueStates);
            //
            // Assert valid values only
            //            
            ASSERTION (0 == (pEvent->EventInfo.dwQueueStates & ~(FAX_INCOMING_BLOCKED |
                                                                 FAX_OUTBOX_BLOCKED   |
                                                                 FAX_OUTBOX_PAUSED)));
            m_dwQueueState = pEvent->EventInfo.dwQueueStates;
            break;

        case FAX_EVENT_TYPE_IN_ARCHIVE:
            //
            // Something happened in the Inbox folder
            //
            if (m_Inbox.Locked() || !m_Inbox.IsValid())
            {
                //
                // Folder is locked or invalid - do not process notifications
                //
                dwRes = ERROR_LOCK_VIOLATION;
                VERBOSE (DBG_MSG, 
                         TEXT("Inbox folder is locked or invalid - notification is NOT processed"));
                return dwRes;
            }
            switch (pEvent->EventInfo.JobInfo.Type)
            {
                case FAX_JOB_EVENT_TYPE_ADDED:
                    //
                    // A message was added
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_ARCHIVE / FAX_JOB_EVENT_TYPE_ADDED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_Inbox.OnJobAdded (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                case FAX_JOB_EVENT_TYPE_REMOVED:
                    //
                    // A message was removed
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_ARCHIVE / FAX_JOB_EVENT_TYPE_REMOVED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_Inbox.OnJobRemoved (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                default:
                    dwRes = ERROR_GEN_FAILURE;
                    VERBOSE (DBG_MSG, 
                             TEXT("Got unknown server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_ARCHIVE / %d / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.Type,
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;
            }
            break;

        case FAX_EVENT_TYPE_OUT_ARCHIVE:
            //
            // Something happened in the SentItems folder
            //
            if (m_SentItems.Locked() || !m_SentItems.IsValid())
            {
                //
                // Folder is locked or invalid - do not process notifications
                //
                dwRes = ERROR_LOCK_VIOLATION;
                VERBOSE (DBG_MSG, 
                         TEXT("SentItems folder is locked or invalid - notification is NOT processed"));
                return dwRes;
            }
            switch (pEvent->EventInfo.JobInfo.Type)
            {
                case FAX_JOB_EVENT_TYPE_ADDED:
                    //
                    // A message was added
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_ARCHIVE / FAX_JOB_EVENT_TYPE_ADDED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_SentItems.OnJobAdded (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                case FAX_JOB_EVENT_TYPE_REMOVED:
                    //
                    // A message was removed
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_ARCHIVE / FAX_JOB_EVENT_TYPE_REMOVED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_SentItems.OnJobRemoved (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                default:
                    dwRes = ERROR_GEN_FAILURE;
                    VERBOSE (DBG_MSG, 
                             TEXT("Got unknown server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_ARCHIVE / %d / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.Type,
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;
            }
            break;

        case FAX_EVENT_TYPE_FXSSVC_ENDED:
            //
            // Fax service is shutting down
            //
            VERBOSE (DBG_MSG, 
                     TEXT("Got server notification from %s - FAX_EVENT_TYPE_FXSSVC_ENDED"),
                     m_cstrMachine);
            dwRes = Disconnect ();
            if (ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("Disconnect"), dwRes);
            }
            dwRes = InvalidateSubFolders (TRUE);
            if (ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("InvalidateSubFolders"), dwRes);
            }
            break;

        default:
            dwRes = ERROR_GEN_FAILURE;
            VERBOSE (DBG_MSG, 
                     TEXT("Got unknown server notification from %s - %d"),
                     m_cstrMachine,
                     pEvent->EventType);
            break;
    }
    return dwRes;
}   // CServerNode::OnNotificationMessage 


CFolder* 
CServerNode::GetFolder(FolderType type)
{
    CFolder* pFolder=NULL;

    switch(type)
    {
    case FOLDER_TYPE_INBOX:
        pFolder = &m_Inbox;
        break;
    case FOLDER_TYPE_OUTBOX:
        pFolder = &m_Outbox;
        break;
    case FOLDER_TYPE_SENT_ITEMS:
        pFolder = &m_SentItems;
        break;
    case FOLDER_TYPE_INCOMING:
        pFolder = &m_Incoming;
        break;
    default:
        {
            DBG_ENTER(TEXT("CServerNode::GetFolder"));
            ASSERTION_FAILURE
        }
        break;
    }

    return pFolder;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\sentitemsgeneralpg.cpp ===
// SentItemsGeneralPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     45

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_DOC_NAME,         IDC_DOC_NAME_VALUE,
    MSG_VIEW_ITEM_SUBJECT,          IDC_SUBJECT_VALUE,
    MSG_VIEW_ITEM_RECIPIENT_NAME,   IDC_RECIPIENT_NAME_VALUE,
    MSG_VIEW_ITEM_RECIPIENT_NUMBER, IDC_RECIPIENT_NUMBER_VALUE,
    MSG_VIEW_ITEM_NUM_PAGES,        IDC_PAGES_VALUE,
    MSG_VIEW_ITEM_SIZE,             IDC_SIZE_VALUE,
    MSG_VIEW_ITEM_SENDER_NAME,      IDC_SENDER_NAME_VALUE,
    MSG_VIEW_ITEM_SENDER_NUMBER,    IDC_SENDER_NUMBER_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_START_TIME, IDC_START_TIME_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_END_TIME,   IDC_END_TIME_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_DURATION,   IDC_DURATION_VALUE
};

/////////////////////////////////////////////////////////////////////////////
// CSentItemsGeneralPg property page

IMPLEMENT_DYNCREATE(CSentItemsGeneralPg, CMsgPropertyPg)


CSentItemsGeneralPg::CSentItemsGeneralPg(
    CFaxMsg* pMsg     // pointer to CArchiveMsg
) : 
    CMsgPropertyPg(CSentItemsGeneralPg::IDD, pMsg)
{
}

CSentItemsGeneralPg::~CSentItemsGeneralPg()
{
}

void CSentItemsGeneralPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSentItemsGeneralPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSentItemsGeneralPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(CSentItemsGeneralPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSentItemsGeneralPg message handlers

BOOL 
CSentItemsGeneralPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CSentItemsGeneralPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\serverstatusdlg.h ===
#if !defined(AFX_SERVERSTATUS_H__13E9E42D_A0CA_4111_9DB7_A9FBD889A168__INCLUDED_)
#define AFX_SERVERSTATUS_H__13E9E42D_A0CA_4111_9DB7_A9FBD889A168__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ServerStatus.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CServerStatusDlg dialog

class CServerStatusDlg : public CFaxClientDlg
{
// Construction
public:
	CServerStatusDlg(CClientConsoleDoc* pDoc, CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CServerStatusDlg)
	enum { IDD = IDD_SERVER_STATUS };
	CListCtrl	m_listServer;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerStatusDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    CClientConsoleDoc* m_pDoc;

    DWORD RefreshServerList();

	// Generated message map functions
	//{{AFX_MSG(CServerStatusDlg)
	virtual BOOL OnInitDialog();
    afx_msg void OnKeydownListCp(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SERVERSTATUS_H__13E9E42D_A0CA_4111_9DB7_A9FBD889A168__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\sentitemsgeneralpg.h ===
#if !defined(AFX_SENTITEMSGENERALPG_H__E5645AEB_4289_4D6D_B000_60C3A52638F0__INCLUDED_)
#define AFX_SENTITEMSGENERALPG_H__E5645AEB_4289_4D6D_B000_60C3A52638F0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SentItemsGeneralPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSentItemsGeneralPg dialog

class CSentItemsGeneralPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(CSentItemsGeneralPg)

// Construction
public:
	CSentItemsGeneralPg(CFaxMsg* pMsg);
	~CSentItemsGeneralPg();

// Dialog Data
	//{{AFX_DATA(CSentItemsGeneralPg)
	enum { IDD = IDD_SENT_ITEMS_GENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSentItemsGeneralPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    CSentItemsGeneralPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(CSentItemsGeneralPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SENTITEMSGENERALPG_H__E5645AEB_4289_4D6D_B000_60C3A52638F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\serverstatusdlg.cpp ===
// ServerStatus.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     82

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

struct TSrvStatusColInfo
{
    DWORD dwStrRes; // column header string
    DWORD dwWidth;  // column width
};

static TSrvStatusColInfo s_colInfo[] = 
{
    IDS_SRV_COL_SERVER,        133,
    IDS_SRV_COL_STATUS,        120
};

/////////////////////////////////////////////////////////////////////////////
// CServerStatusDlg dialog


CServerStatusDlg::CServerStatusDlg(CClientConsoleDoc* pDoc, CWnd* pParent /*=NULL*/)
	: CFaxClientDlg(CServerStatusDlg::IDD, pParent),
    m_pDoc(pDoc)
{
    ASSERT(m_pDoc);
}


void CServerStatusDlg::DoDataExchange(CDataExchange* pDX)
{
	CFaxClientDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerStatusDlg)
	DDX_Control(pDX, IDC_LIST_SERVER, m_listServer);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerStatusDlg, CFaxClientDlg)
	//{{AFX_MSG_MAP(CServerStatusDlg)
	ON_NOTIFY(LVN_KEYDOWN, IDC_LIST_SERVER, OnKeydownListCp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerStatusDlg message handlers

BOOL 
CServerStatusDlg::OnInitDialog() 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerStatusDlg::OnInitDialog"));

    CFaxClientDlg::OnInitDialog();
	
    //
    // init CListCtrl
    //
    m_listServer.SetExtendedStyle (LVS_EX_FULLROWSELECT |    // Entire row is selected
                                   LVS_EX_INFOTIP       |    // Allow tooltips
                                   LVS_EX_ONECLICKACTIVATE); // Hover cursor effect

    m_listServer.SetImageList (&CLeftView::m_ImageList, LVSIL_SMALL);

    int nRes;
    CString cstrHeader;
    DWORD nCols = sizeof(s_colInfo)/sizeof(s_colInfo[0]);

    //
    // init column
    //
    for(int i=0; i < nCols; ++i)
    {
        //
        // load title string
        //
        m_dwLastError = LoadResourceString (cstrHeader, s_colInfo[i].dwStrRes);
        if(ERROR_SUCCESS != m_dwLastError)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT ("LoadResourceString"), m_dwLastError);
            EndDialog(IDABORT);
            return FALSE;
        }

        //
        // insert column
        //
        nRes = m_listServer.InsertColumn(i, cstrHeader, LVCFMT_LEFT, s_colInfo[i].dwWidth);
        if(nRes != i)
        {
            m_dwLastError = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::InsertColumn"), m_dwLastError);
            EndDialog(IDABORT);
            return FALSE;
        }
    }

    //
    // fill list control with servers
    //
    m_dwLastError = RefreshServerList();
    if(ERROR_SUCCESS != m_dwLastError)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshServerList"), m_dwLastError);
        EndDialog(IDABORT);
        return FALSE;
    }

	
	return TRUE;
}

DWORD 
CServerStatusDlg::RefreshServerList()
/*++

Routine name : CServerStatusDlg::RefreshServerList

Routine description:

	fill in list control with servers statuses

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::RefreshServerList"), dwRes);

    if(!m_listServer.DeleteAllItems())
    {
        dwRes = ERROR_CAN_NOT_COMPLETE;
        CALL_FAIL (WINDOW_ERR, TEXT ("CListView::DeleteAllItems"), dwRes);
        return dwRes;
    }

    const SERVERS_LIST& srvList = m_pDoc->GetServersList();

    int nItem, nRes;
    CString cstrName;
    CString cstrStatus;
    TreeIconType iconIndex;
    CServerNode* pServerNode;
    for (SERVERS_LIST::iterator it = srvList.begin(); it != srvList.end(); ++it)
    {
        //
        // get server name
        //
        pServerNode = *it;
        try
        {
            cstrName = pServerNode->Machine();
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("CString::operator="), dwRes);
            return dwRes;
        }

        if(cstrName.GetLength() == 0)
        {
            dwRes = LoadResourceString(cstrName, IDS_LOCAL_SERVER);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("LoadResourceString"), dwRes);
                return dwRes;
            }                    
        }

        //
        // get server status
        //
        dwRes = pServerNode->GetActivity(cstrStatus, iconIndex);
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::GetActivity"), dwRes);
            return dwRes;
        }                    

        nItem = m_listServer.GetItemCount();

        //
        // insert server row
        //
        nItem = m_listServer.InsertItem(nItem, cstrName, iconIndex);
        if(nItem < 0)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::InsertItem"), dwRes);
            return dwRes;
        }

        //
        // display server status
        //
        nRes = m_listServer.SetItemText(nItem, 1, cstrStatus);
        if(!nRes)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::SetItemText"), dwRes);
            return dwRes;
        }
    }

    return dwRes;

} // CServerStatusDlg::RefreshServerList

void 
CServerStatusDlg::OnKeydownListCp(NMHDR* pNMHDR, LRESULT* pResult) 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnKeydownListCp"));

    LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;

    if(VK_F5 == pLVKeyDow->wVKey)
    {
        //
        // F5 was pressed
        //
        dwRes = RefreshServerList();
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT ("RefreshServerList"), dwRes);
        }
    }
    
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\sortheader.cpp ===
// SortHeader.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     6

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define SORT_UP_ARROW_ICON_ID     1
#define SORT_DOWN_ARROW_ICON_ID   2

/////////////////////////////////////////////////////////////////////////////
// CSortHeader

CSortHeader::CSortHeader() :
    m_nSortColumn (-1), // Not sorted,
    m_hwndList (NULL)   // No attached list view control
{}

CSortHeader::~CSortHeader()
{
    Detach ();
}


BEGIN_MESSAGE_MAP(CSortHeader, CHeaderCtrl)
    //{{AFX_MSG_MAP(CSortHeader)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSortHeader message handlers

int 
CSortHeader::SetSortImage(
    int nCol, 
    BOOL bAscending
)
/*++

Routine name : CSortHeader::SetSortImage

Routine description:

    Sets the current sort column & sort order

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    nCol            [in ] - Sort column index
    bAscending      [in ] - Sort order

Return Value:

    Previous sort column

--*/
{
    DBG_ENTER(TEXT("CSortHeader::SetSortImage"),
              TEXT("Col=%d, bAscending = %d"),
              nCol,
              bAscending);

    int nPrevCol = m_nSortColumn;

    m_nSortColumn = nCol;
    if (nPrevCol == nCol && m_bSortAscending == bAscending)
    {
        //
        // Sort column didn't change and sort order didn't change - return now
        //
        return nPrevCol;
    }
    m_bSortAscending = bAscending;

    if (!IsWinXPOS())
    {
        HD_ITEM hditem;
        //
        // Change the entire header control to owner-drawn
        //
        hditem.mask = HDI_FORMAT;
        GetItem( nCol, &hditem );
        hditem.fmt |= HDF_OWNERDRAW;
        SetItem( nCol, &hditem );
        //
        // Invalidate header control so that it gets redrawn
        //
        Invalidate();
    }
    else
    {
        //
        // No need for owner-drawn header control in Windows XP.
        // We can use bitmaps along with text.
        //
        ASSERTION (m_hwndList);
        LV_COLUMN lvc;
        if (-1 != nPrevCol)
        {
            //
            // Remove the sort arrow from the previously sorted column
            //
            lvc.mask = LVCF_FMT;
            ListView_GetColumn (m_hwndList, nPrevCol, &lvc);
            lvc.fmt &= ~(LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT);
            ListView_SetColumn(m_hwndList, nPrevCol, &lvc);
        } 
        if (-1 != nCol)
        {
            //
            // Add sort arrow to the currently sorted column
            //
            lvc.mask = LVCF_FMT;
            ListView_GetColumn (m_hwndList, nCol, &lvc);
            lvc.fmt |= (LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT);
            lvc.mask = LVCF_IMAGE | LVCF_FMT;
            lvc.iImage = m_bSortAscending ? SORT_UP_ARROW_ICON_ID : SORT_DOWN_ARROW_ICON_ID;
            ListView_SetColumn(m_hwndList, nCol, &lvc);
        }
    }
    return nPrevCol;
}

void CSortHeader::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
    CDC dc;

    dc.Attach( lpDrawItemStruct->hDC );
    //
    // Get the column rect
    //
    CRect rcLabel( lpDrawItemStruct->rcItem );
    //
    // Save DC
    //
    int nSavedDC = dc.SaveDC();
    //
    // Set clipping region to limit drawing within column
    //
    CRgn rgn;
    rgn.CreateRectRgnIndirect( &rcLabel );
    dc.SelectObject( &rgn );
    rgn.DeleteObject();
    //
    // Draw the background
    //
    dc.FillRect(rcLabel, &CBrush(::GetSysColor(COLOR_3DFACE)));
    //
    // Labels are offset by a certain amount  
    // This offset is related to the width of a space character
    //
    int offset = dc.GetTextExtent(_T(" "), 1 ).cx*2;
    //
    // Get the column text and format
    //
    TCHAR buf[256];
    HD_ITEM hditem;

    hditem.mask = HDI_TEXT | HDI_FORMAT;
    hditem.pszText = buf;
    hditem.cchTextMax = 255;

    GetItem( lpDrawItemStruct->itemID, &hditem );
    //
    // Determine format for drawing column label
    UINT uFormat = DT_SINGLELINE | DT_NOPREFIX | DT_NOCLIP | DT_VCENTER | DT_END_ELLIPSIS;
    if( hditem.fmt & HDF_CENTER)
    {
        uFormat |= DT_CENTER;
    }
    else if( hditem.fmt & HDF_RIGHT)
    {
        uFormat |= DT_RIGHT;
    }
    else
    {
        uFormat |= DT_LEFT;
    }
    //
    // Adjust the rect if the mouse button is pressed on it
    //
    if( lpDrawItemStruct->itemState == ODS_SELECTED )
    {
        rcLabel.left++;
        rcLabel.top += 2;
        rcLabel.right++;
    }
    //
    // Adjust the rect further if Sort arrow is to be displayed
    //
    if( lpDrawItemStruct->itemID == (UINT)m_nSortColumn )
    {
        rcLabel.right -= 3 * offset;
    }

    rcLabel.left += offset;
    rcLabel.right -= offset;
    //
    // Draw column label
    //
    if( rcLabel.left < rcLabel.right )
    {
        dc.DrawText(buf,-1,rcLabel, uFormat);
    }
    //
    // Draw the Sort arrow
    //
    if( lpDrawItemStruct->itemID == (UINT)m_nSortColumn )
    {
        CRect rcIcon( lpDrawItemStruct->rcItem );
        //
        // Set up pens to use for drawing the triangle
        //
        CPen penLight(PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT));
        CPen penShadow(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
        CPen *pOldPen = dc.SelectObject( &penLight );
        offset = (rcIcon.bottom - rcIcon.top) / 4;
        if (m_bSortAscending) 
        {
            //
            // Draw triangle pointing upwards
            //
            dc.MoveTo( rcIcon.right - 2*offset, offset);
            dc.LineTo( rcIcon.right - offset, rcIcon.bottom - offset-1 );
            dc.LineTo( rcIcon.right - 3*offset-2, rcIcon.bottom - offset-1 );
            dc.MoveTo( rcIcon.right - 3*offset-1, rcIcon.bottom - offset-1 );
            dc.SelectObject( &penShadow );
            dc.LineTo( rcIcon.right - 2*offset, offset-1);      
        }       
        else 
        {
            //
            // Draw triangle pointing downwards
            //
            dc.MoveTo( rcIcon.right - offset-1, offset);
            dc.LineTo( rcIcon.right - 2*offset-1, rcIcon.bottom - offset );
            dc.MoveTo( rcIcon.right - 2*offset-2, rcIcon.bottom - offset );
            dc.SelectObject( &penShadow );
            dc.LineTo( rcIcon.right - 3*offset-1, offset );
            dc.LineTo( rcIcon.right - offset-1, offset);        
        }       
        //
        // Restore the pen
        //
        dc.SelectObject( pOldPen );
    }
    //
    // Restore dc
    //
    dc.RestoreDC( nSavedDC );
    //
    // Detach the dc before returning
    //
    dc.Detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\servernode.h ===
// ServerNode.h: interface for the CServerNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SERVERNODE_H__1B5E5554_A8BB_4682_B1A8_56453753643D__INCLUDED_)
#define AFX_SERVERNODE_H__1B5E5554_A8BB_4682_B1A8_56453753643D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//
// WM_SERVER_NOTIFY_BASE is the base (minimal) message id used for notifications
// that arrive from the server(s). Each server is assigned a differnet message id
// which is equal of bigger than this value.
//
#define WM_SERVER_NOTIFY_BASE       WM_APP + 10

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

class CServerNode : public CTreeNode
{
public:
    CServerNode ();

    DECLARE_DYNAMIC(CServerNode)

    DWORD Init (LPCTSTR tstrMachine);
    const CString & Machine () const    { return m_cstrMachine; }

    DWORD RefreshState ();

    void AttachFoldersToViews()
        {
            m_Inbox.AttachView();
            m_SentItems.AttachView();
            m_Outbox.AttachView();
            m_Incoming.AttachView();
        }

    BOOL  IsIncomingBlocked () const    { return (m_dwQueueState & FAX_INCOMING_BLOCKED) ? TRUE : FALSE; }
    BOOL  IsOutboxBlocked () const      { return (m_dwQueueState & FAX_OUTBOX_BLOCKED) ? TRUE : FALSE; }
    BOOL  IsOutboxPaused () const       { return (m_dwQueueState & FAX_OUTBOX_PAUSED) ? TRUE : FALSE; }

    BOOL  IsOnline () const          { return m_hConnection ? TRUE : FALSE; }
    BOOL  IsRefreshing() const       { return m_bInBuildup; }
    DWORD GetActivity(CString& cstrText, TreeIconType& iconIndex) const;


    DWORD BlockIncoming (BOOL bBlock);
    DWORD BlockOutbox (BOOL bBlock);
    DWORD PauseOutbox (BOOL bPause);

    BOOL  CanSeeInbox ()     const { return IsRightHeld(FAX_ACCESS_QUERY_IN_ARCHIVE);   }
    BOOL  CanManageInbox()   const { return IsRightHeld(FAX_ACCESS_MANAGE_IN_ARCHIVE);  }
    BOOL  CanSeeAllJobs ()   const { return IsRightHeld(FAX_ACCESS_QUERY_JOBS);         }
    BOOL  CanManageAllJobs() const { return IsRightHeld(FAX_ACCESS_MANAGE_JOBS);        }
	BOOL  CanManageConfig()  const { return IsRightHeld(FAX_ACCESS_MANAGE_CONFIG);      } 
	BOOL  CanSendFax()       const { return (IsRightHeld(FAX_ACCESS_SUBMIT)			||
											 IsRightHeld(FAX_ACCESS_SUBMIT_NORMAL)	||
											 IsRightHeld(FAX_ACCESS_SUBMIT_HIGH))		&& 
                                            !IsOutboxBlocked();                         } 
    BOOL  CanReceiveNow()    const { return IsRightHeld(FAX_ACCESS_QUERY_IN_ARCHIVE) &&     // FaxAnswerCall requires FAX_ACCESS_QUERY_IN_ARCHIVE
                                            m_cstrMachine.IsEmpty();                    }   // FaxAnswerCall only works on local server

    CFolder* GetFolder(FolderType type);

    const CMessageFolder   &GetInbox () const     { return m_Inbox;     }
    const CMessageFolder   &GetSentItems () const { return m_SentItems; }
    const CQueueFolder     &GetOutbox () const    { return m_Outbox;    }
    const CQueueFolder     &GetIncoming () const  { return m_Incoming;  }

    virtual void AssertValid( ) const;
    virtual void Dump( CDumpContext &dc ) const;

    DWORD GetConnectionHandle (HANDLE &hFax);

    DWORD InvalidateSubFolders(BOOL bClearView);

    void SetLastRPCError (DWORD dwErr, BOOL DisconnectOnFailure = TRUE);
    DWORD GetLastRPCError ()            { return m_dwLastRPCError; }

    DWORD Disconnect (BOOL bShutdownAware = FALSE, BOOL bWaitForBuildThread = TRUE);
    void Destroy ();

    static CServerNode *LookupServerFromMessageId (DWORD dwMsgId);

    static DWORD InitMsgsMap ();
    static DWORD ShutdownMsgsMap ();

    DWORD  OnNotificationMessage (PFAX_EVENT_EX pEvent);

	BOOL IsValid() { return m_bValid; }
	void SetValid(BOOL bValid) { m_bValid = bValid; }

    DWORD GetNotifyMsgID() { return m_dwMsgId; }

private:

    virtual ~CServerNode();

    BOOL IsRightHeld (DWORD dwRight) const
    {
        return ((m_dwRights & dwRight) == dwRight) ? TRUE : FALSE;
    }

    DWORD Connect ();

	BOOL  m_bValid;
    DWORD SetNewQueueState (DWORD dwNewState);
    DWORD ClearContents ();

    DWORD CreateFolders ();
    BOOL  FatalRPCError (DWORD dwErr);

    DWORD       m_dwRights;     // Current relevant access rights
    DWORD       m_dwQueueState; // Current queue state
    HANDLE      m_hConnection;  // Handle to RPC connection
    CString     m_cstrMachine;  // Server's machine name

    CMessageFolder      m_Inbox;       // Inbox folder
    CMessageFolder      m_SentItems;   // SentItems folder
    CQueueFolder        m_Outbox;      // Outbox folder
    CQueueFolder        m_Incoming;    // Incoming folder

    DWORD               m_dwLastRPCError;   // Error code of last RPC call

    //
    // Buildup thread members and functions:
    //
    CRITICAL_SECTION    m_csBuildup;            // Protects buildup phase
    BOOL                m_bCsBuildupValid;      // Is the critical section valid?
    HANDLE              m_hBuildupThread;       // Handle of background contents building thread
    BOOL                m_bStopBuildup;         // Should we abort the buildup operation?
    BOOL                m_bInBuildup;           // Are we doing a buildup now?

    CRITICAL_SECTION    m_csBuildupThread;      // Protects access to the m_hBuildupThread
    BOOL                m_bCsBuildupThreadValid;// Is the critical section valid?

    DWORD               StopBuildThread (BOOL bWaitForDeath = TRUE);
    DWORD               Buildup ();

    BOOL                m_bSelfDestruct;        // Should we destroy ourselves ASAP?

    static DWORD WINAPI BuildupThreadProc (LPVOID lpParameter);

    //
    // Notifications handling:
    //
    HANDLE              m_hNotification;    // Notification registration handle
    DWORD               m_dwMsgId;          // Windows message id used for notification

        //
        // Map between Windows message and server pointer from 
        // which the notification message was sent.
        //
    typedef map <DWORD, CServerNode *> MESSAGES_MAP;    
    static CRITICAL_SECTION m_sMsgsCs;   // Protects access to the map
    static BOOL             m_sbMsgsCsInitialized;  // Was m_sMsgsCs initialized;
    static MESSAGES_MAP     m_sMsgs;
    static DWORD            m_sdwMinFreeMsg; // The smallest available message id
    static DWORD AllocateNewMessageId (CServerNode *pServer, DWORD &dwMsdgId);
    static DWORD FreeMessageId (DWORD dwMsgId);
    
};

#endif // !defined(AFX_SERVERNODE_H__1B5E5554_A8BB_4682_B1A8_56453753643D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ClientConsole.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\sortheader.h ===
#if !defined(AFX_SORTHEADER_H__A5F69D17_1989_4206_8A14_7AC8C91AB797__INCLUDED_)
#define AFX_SORTHEADER_H__A5F69D17_1989_4206_8A14_7AC8C91AB797__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SortHeader.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSortHeader window

class CSortHeader : public CHeaderCtrl
{
// Construction
public:
    CSortHeader();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSortHeader)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CSortHeader();
    int SetSortImage (int nCol, BOOL bAscending);
    void    SetListControl (HWND hwnd)  { m_hwndList = hwnd; }


    // Generated message map functions
protected:
    //{{AFX_MSG(CSortHeader)
    //}}AFX_MSG

    void    DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

    int     m_nSortColumn;
    BOOL    m_bSortAscending;
    HWND    m_hwndList;

    DECLARE_MESSAGE_MAP()

private:

};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SORTHEADER_H__A5F69D17_1989_4206_8A14_7AC8C91AB797__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\treenode.cpp ===
// TreeNode.cpp: implementation of the CTreeNode class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     61

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CTreeNode, CObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTreeNode::CTreeNode(FolderType type):
    m_Type(type)          // node type
{
    DBG_ENTER(TEXT("CTreeNode::CTreeNode"));
 
    ASSERTION ((type >= 0) && (type < FOLDER_TYPE_MAX));
}

CTreeNode::~CTreeNode()
{
}

void CTreeNode::AssertValid() const
{
    CObject::AssertValid();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Eran Yariv (EranY)

!ENDIF

!include ..\..\faxsrc.inc

TARGETPATH=obj
TARGETTYPE=PROGRAM

UMTYPE=windows
C_DEFINES=$(C_DEFINES) /D_NT_SUR_ /DNO_STRICT /DWIN4 /DNT4 /DNT_BUILD /D_WIN32_IE=0x0400

NOMFCPDB=1
USE_NATIVE_EH=1
USE_STL=1
USE_LATEST_MFC=1


PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj
PRECOMPILED_CXX=1

INCLUDES=               \
    ..;                 \
    $(INCLUDES); 

!ifndef NOUNICODE
TARGETLIBS = $(FAXLIB)\*\$(WINFAX).lib \
             $(FAXLIB)\*\$(FAXTIFF).lib  
!else
TARGETLIBS = $(FAXLIB95)\*\$(WINFAX).lib \
             $(FAXLIB95)\*\$(FAXTIFF).lib  
!endif

TARGETLIBS= $(TARGETLIBS) \
    $(SDK_LIB_PATH)\comdlg32.lib    \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SDK_LIB_PATH)\shell32.lib     \
    $(SDK_LIB_PATH)\uuid.lib        \
    $(SDK_LIB_PATH)\winspool.lib    \
    $(SDK_LIB_PATH)\comctl32.lib    \
    $(SDK_LIB_PATH)\htmlhelp.lib    \
    $(FAXROOT)\util\debugex\$(DEBUG_TYPE)\$(O)\debugex.lib

SOURCES=\
    ..\ClientConsole.cpp        \
    ..\ClientConsoleDoc.cpp     \
    ..\ClientConsoleView.cpp    \
    ..\Folder.cpp               \
    ..\FolderListView.cpp       \
    ..\Job.cpp                  \
    ..\LeftView.cpp             \
    ..\MainFrm.cpp              \
    ..\Message.cpp              \
    ..\MessageFolder.cpp        \
    ..\QueueFolder.cpp          \
    ..\ServerNode.cpp           \
    ..\SortHeader.cpp           \
    ..\Utils.cpp                \
    ..\ErrorDlg.cpp             \
    ..\FaxTime.cpp              \
    ..\ViewRow.cpp              \
    ..\ColumnSelectDlg.cpp      \
    ..\Version.rc               \
    ..\ItemPropSheet.cpp        \
    ..\InboxGeneralPg.cpp       \
    ..\IncomingGeneralPg.cpp    \
    ..\OutboxGeneralPg.cpp      \
    ..\SentItemsGeneralPg.cpp   \
    ..\PersonalInfoPg.cpp       \
    ..\InboxDetailsPg.cpp       \
    ..\IncomingDetailsPg.cpp    \
    ..\OutboxDetailsPg.cpp      \
    ..\SentItemsDetailsPg.cpp   \
    ..\MsgPropertyPg.cpp        \
    ..\TreeNode.cpp             \
    ..\UserInfoDlg.cpp          \
    ..\FolderDialog.cpp         \
    ..\FaxClientPg.cpp          \
    ..\CoverPagesDlg.cpp        \
    ..\FaxClientDlg.cpp         \
    ..\CmdLineInfo.cpp          \
    ..\ServerStatusDlg.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__5C2C92BD_853F_48F7_8067_255E5DA21502__INCLUDED_)
#define AFX_STDAFX_H__5C2C92BD_853F_48F7_8067_255E5DA21502__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#pragma warning (disable : 4786)    // identifier was truncated to 255 characters in the debug information

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <objbase.h>
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>       // MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#include <afxodlgs.h>       // MFC support for Windows Common Dialogs    
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <afxpriv.h>

#include <mapi.h>

//
// Windows headers:
//
#include <WinSpool.h>
#include <shlwapi.h>
//
// Fax server includes:
//
#include <FaxReg.h>     // Fax registry settings
//
// STL includes:
//
#include <list>
#include <map>
#include <set>
using namespace std;

#include <DebugEx.h>

#include <htmlhelp.h>
#include <faxutil.h>
#include <faxres.h>
#include <cvernum.h>
#include "..\tiff\inc\tifflib.h"

//
// Pre-declarations (to prevent include loops):
//
class CClientConsoleDoc;
class CServerNode;
class CFolder;
class CLeftView;
class CFolderListView;
//
// Local includes:
//

#include "resources\resource.h"
#include "TreeNode.h"
#include "CmdLineInfo.h"
#include "MainFrm.h"
#include "FaxTime.h"
#include "FaxMsg.h"
#include "Utils.h"
#include "FaxClientPg.h"
#include "FaxClientDlg.h"
#include "ErrorDlg.h"
#include "ClientConsole.h"
#include "Job.h"
#include "Message.h"
#include "ViewRow.h"
#include "SortHeader.h"
#include "Folder.h"
#include "FolderListView.h"
#include "QueueFolder.h"
#include "MessageFolder.h"
#include "LeftView.h"
#include "ServerNode.h"
#include "ClientConsoleDoc.h"
#include "ClientConsoleView.h"
#include "ColumnSelectDlg.h"
#include "ItemPropSheet.h"
#include "MsgPropertyPg.h"
#include "InboxGeneralPg.h"
#include "IncomingGeneralPg.h"
#include "OutboxGeneralPg.h"
#include "SentItemsGeneralPg.h"
#include "PersonalInfoPg.h"
#include "InboxDetailsPg.h"
#include "IncomingDetailsPg.h"
#include "OutboxDetailsPg.h"
#include "SentItemsDetailsPg.h"
#include "UserInfoDlg.h"
#include "FolderDialog.h"
#include "CoverPagesDlg.h"
#include "ServerStatusDlg.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5C2C92BD_853F_48F7_8067_255E5DA21502__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\treenode.h ===
// TreeNode.h: interface for the CTreeNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TREENODE_H__3B753848_4860_4DC5_AC1E_F3514CE4E839__INCLUDED_)
#define AFX_TREENODE_H__3B753848_4860_4DC5_AC1E_F3514CE4E839__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

enum FolderType
{
    FOLDER_TYPE_INBOX,
    FOLDER_TYPE_OUTBOX,
    FOLDER_TYPE_SENT_ITEMS,
    FOLDER_TYPE_INCOMING,    
    FOLDER_TYPE_SERVER,      
    FOLDER_TYPE_COVER_PAGES, 
    FOLDER_TYPE_MAX
};

class CFolderListView;

class CTreeNode : public CObject  
{
public:
	CTreeNode(FolderType type);
	virtual ~CTreeNode();

    FolderType Type() const  { return m_Type; }

    virtual BOOL IsRefreshing() const = 0;

    virtual void AssertValid() const;

    DECLARE_DYNAMIC(CTreeNode)

protected:

    FolderType m_Type;          // Type of this folder
};

#endif // !defined(AFX_TREENODE_H__3B753848_4860_4DC5_AC1E_F3514CE4E839__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\userinfodlg.h ===
#if !defined(AFX_OPTIONSUSERINFOPG_H__BF10E6C1_FC10_422F_9F76_1D0BBD7C73CA__INCLUDED_)
#define AFX_OPTIONSUSERINFOPG_H__BF10E6C1_FC10_422F_9F76_1D0BBD7C73CA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OptionsUserInfoPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CUserInfoDlg dialog

class CUserInfoDlg : public CFaxClientDlg
{

// Construction
public:
	CUserInfoDlg();
	~CUserInfoDlg();

// Dialog Data
	//{{AFX_DATA(CUserInfoDlg)
	enum { IDD = IDD_OPTIONS_USER_INFO };
    CEdit	m_editAddress;
	CButton	m_butOk;
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

    #define ADDRESS_MAX_LEN  512

private:
    DWORD Save();

private:
    TCHAR** m_tchStrArray;
    FAX_PERSONAL_PROFILE m_PersonalProfile;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CUserInfoDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CUserInfoDlg)
    virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnModify();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OPTIONSUSERINFOPG_H__BF10E6C1_FC10_422F_9F76_1D0BBD7C73CA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\utils.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Utils.h

Abstract:

    Provides utility functions for the entire poject

Author:

    Eran Yariv (EranY)  Dec, 1999

Revision History:

--*/

#if !defined(AFX_UTILS_H__6E33CFA1_C99A_4691_9F91_00451692D3DB__INCLUDED_)
#define AFX_UTILS_H__6E33CFA1_C99A_4691_9F91_00451692D3DB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

DWORD
LoadResourceString (
    CString &cstr,
    int      ResId
);

#define SAFE_DELETE(x)       if (NULL != (x)) { delete   (x); (x) = NULL; }
#define SAFE_DELETE_ARRAY(x) if (NULL != (x)) { delete [](x); (x) = NULL; }

CString DWORDLONG2String (DWORDLONG dwlData);
CString DWORD2String     (DWORD dwData);
DWORD   Win32Error2String(DWORD dwWin32Err, CString& strError);
                  
DWORD LoadDIBImageList (CImageList &, 
                        int iResourceId, 
                        DWORD dwImageWidth,
                        COLORREF crMask);


DWORD WaitForThreadDeathOrShutdown (HANDLE hThread);

DWORD 
GetUniqueFileName (LPCTSTR lpctstrExt, CString &cstrResult);

DWORD CopyTiffFromServer (CServerNode *pServer,
                          DWORDLONG dwlMsgId, 
                          FAX_ENUM_MESSAGE_FOLDER Folder,
                          CString &cstrTiff);

DWORD GetDllVersion (LPCTSTR lpszDllName);

DWORD ReadRegistryString (LPCTSTR lpszSection, LPCTSTR lpszKey, CString& cstrValue);
DWORD WriteRegistryString(LPCTSTR lpszSection, LPCTSTR lpszKey, CString& cstrValue);

DWORD FaxSizeFormat(DWORDLONG dwlSize, CString& cstrValue);

DWORD GetAppLoadPath(CString& cstrLoadPath);

DWORD HtmlHelpTopic(HWND hWnd, TCHAR* tszHelpTopic);
                     
#define PACKVERSION(major,minor) MAKELONG(minor,major)

struct FaxTempFile
{
	//
	// hWaitHandles[0] handle of application that uses a temp file
	// hWaitHandles[1] handle of shutdown event
	//
    HANDLE hWaitHandles[2];
    TCHAR  tszFileName[MAX_PATH];
    TCHAR  tszOldDefaultPrinter[MAX_PATH];
};

DWORD WINAPI DeleteTmpFileThrdProc(LPVOID lpFileStruct);

DWORD GetPrintersInfo(PRINTER_INFO_2*& pPrinterInfo2, DWORD& dwNumPrinters);

UINT_PTR CALLBACK OFNHookProc(HWND, UINT, WPARAM, LPARAM);

int AlignedAfxMessageBox( LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0 );
int AlignedAfxMessageBox( UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT) -1 );

HINSTANCE GetResourceHandle();

//
// Import.cpp
//
#ifdef UNICODE

DWORD ImportArchiveFolderUI(LPCWSTR cstrImportFolder, BOOL bSentItems, HWND hWnd);
DWORD DetectImportFiles();

#endif // UNICODE

#endif // !defined(AFX_UTILS_H__6E33CFA1_C99A_4691_9F91_00451692D3DB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\viewrow.h ===
// ViewRow.h: interface for the CViewRow class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VIEWROW_H__6BEB111C_C0F4_46DD_A28A_0BFEE31CA6EF__INCLUDED_)
#define AFX_VIEWROW_H__6BEB111C_C0F4_46DD_A28A_0BFEE31CA6EF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//
// List of ids for images in the image list used for icons in the list view
//
typedef enum
{
    INVALID = -1,
    LIST_IMAGE_PARTIALLY_RECEIVED,
    LIST_IMAGE_NORMAL_MESSAGE,
    LIST_IMAGE_RECEIVING,
    LIST_IMAGE_ROUTING,
    LIST_IMAGE_ERROR,
    LIST_IMAGE_PAUSED,
    LIST_IMAGE_SENDING,
    LIST_IMAGE_SUCCESS,
    LIST_IMAGE_COVERPAGE
} IconType;


// 
// Items available for a view
//
typedef enum 
{
    //
    // common items
    //
	MSG_VIEW_ITEM_ICON,
    MSG_VIEW_ITEM_STATUS,
    MSG_VIEW_ITEM_SERVER,
    MSG_VIEW_ITEM_NUM_PAGES,
    MSG_VIEW_ITEM_CSID,
    MSG_VIEW_ITEM_TSID,    
    MSG_VIEW_ITEM_SIZE,
    MSG_VIEW_ITEM_DEVICE,
    MSG_VIEW_ITEM_RETRIES,
    MSG_VIEW_ITEM_ID,
    MSG_VIEW_ITEM_BROADCAST_ID,
    MSG_VIEW_ITEM_CALLER_ID,
    MSG_VIEW_ITEM_ROUTING_INFO,
    MSG_VIEW_ITEM_DOC_NAME,
    MSG_VIEW_ITEM_SUBJECT,
    MSG_VIEW_ITEM_RECIPIENT_NAME,
    MSG_VIEW_ITEM_RECIPIENT_NUMBER,
    MSG_VIEW_ITEM_USER,
    MSG_VIEW_ITEM_PRIORITY,
    MSG_VIEW_ITEM_ORIG_TIME,
    MSG_VIEW_ITEM_SUBMIT_TIME,
    MSG_VIEW_ITEM_BILLING,
    MSG_VIEW_ITEM_TRANSMISSION_START_TIME,
    //
    // job specific
    //
    MSG_VIEW_ITEM_SEND_TIME,
    MSG_VIEW_ITEM_EXTENDED_STATUS,
    MSG_VIEW_ITEM_CURRENT_PAGE,
    //
    // message specific
    //
    MSG_VIEW_ITEM_SENDER_NAME,
    MSG_VIEW_ITEM_SENDER_NUMBER,
    MSG_VIEW_ITEM_TRANSMISSION_END_TIME,
    MSG_VIEW_ITEM_TRANSMISSION_DURATION,
    //
    // End of list (unused)
    //
    MSG_VIEW_ITEM_END    
} MsgViewItemType;


class CViewRow  
{
public:
    CViewRow() : 
        m_pMsg(NULL),
        m_bAttached(FALSE),
        m_bStringsPreparedForDisplay(FALSE)
        {}
    virtual ~CViewRow() {}

    DWORD AttachToMsg(CFaxMsg *pMsg, BOOL PrepareStrings=TRUE);

    int CompareByItem (CViewRow &other, DWORD item);

    IconType GetIcon () const
        { ASSERT (m_bAttached); return m_Icon; }

    static  DWORD InitStrings ();

    static  DWORD GetItemTitle (DWORD, CString &);

    static int GetItemAlignment (DWORD item)
        { ASSERT (item >=0 && item < MSG_VIEW_ITEM_END); return m_Alignments[item]; }

    const CString &GetItemString (DWORD item) const
        { 
            ASSERT (m_bAttached && item >=0 && item < MSG_VIEW_ITEM_END); 
            ASSERT (MSG_VIEW_ITEM_ICON != item);
            ASSERT (m_bStringsPreparedForDisplay);
            return m_Strings[item]; 
        }

    static BOOL IsItemIcon (DWORD item)
        { return (MSG_VIEW_ITEM_ICON == item); }

protected:
    CFaxMsg* m_pMsg;

    BOOL       m_bAttached;     // Are we attached to the job / message?
    IconType   m_Icon;          // Icon id of job / message

    BOOL       m_bStringsPreparedForDisplay;      // Is m_Strings valid?

    CString    m_Strings[MSG_VIEW_ITEM_END]; // String representation of 
                                             // item's data
  
    static CString m_cstrPriorities[FAX_PRIORITY_TYPE_HIGH+1];
    static CString m_cstrQueueStatus[NUM_JOB_STATUS];
    static CString m_cstrQueueExtendedStatus[JS_EX_CALL_ABORTED - JS_EX_DISCONNECTED + 1];
    static CString m_cstrMessageStatus[2];

    static int m_Alignments[MSG_VIEW_ITEM_END];
    static int m_TitleResources[MSG_VIEW_ITEM_END];

    DWORD DetachFromMsg();

    IconType CalcIcon(CFaxMsg *pMsg);

private:
    IconType CalcJobIcon(CFaxMsg *pJob);
    IconType CalcMessageIcon(CFaxMsg *pMsg);

    DWORD InitStatusStr(CFaxMsg *pMsg);
    DWORD InitExtStatusStr(CFaxMsg *pMsg);

};

#endif // !defined(AFX_VIEWROW_H__6BEB111C_C0F4_46DD_A28A_0BFEE31CA6EF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\userinfodlg.cpp ===
// OptionsUserInfoPg.cpp : implementation file
//

#include "stdafx.h"


#define __FILE_ID__     71

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// this array maps dialog control IDs to
// number of string in FAX_PERSONAL_PROFILE structure
//
static TPersonalPageInfo s_PageInfo[] = 
{ 
    IDC_NAME_VALUE,             PERSONAL_PROFILE_NAME,                
    IDC_FAX_NUMBER_VALUE,       PERSONAL_PROFILE_FAX_NUMBER,          
    IDC_COMPANY_VALUE,          PERSONAL_PROFILE_COMPANY,             
    IDC_TITLE_VALUE,            PERSONAL_PROFILE_TITLE,               
    IDC_DEPARTMENT_VALUE,       PERSONAL_PROFILE_DEPARTMENT,          
    IDC_OFFICE_VALUE,           PERSONAL_PROFILE_OFFICE_LOCATION,     
    IDC_HOME_PHONE_VALUE,       PERSONAL_PROFILE_HOME_PHONE,          
    IDC_BUSINESS_PHONE_VALUE,   PERSONAL_PROFILE_OFFICE_PHONE,        
    IDC_EMAIL_VALUE,            PERSONAL_PROFILE_EMAIL,       
    IDC_BILLING_CODE_VALUE,     PERSONAL_PROFILE_BILLING_CODE,
    IDC_ADDRESS_VALUE,          PERSONAL_PROFILE_STREET_ADDRESS
};


/////////////////////////////////////////////////////////////////////////////
// CUserInfoDlg property page


CUserInfoDlg::CUserInfoDlg(): 
    CFaxClientDlg(CUserInfoDlg::IDD)
{
    memset((LPVOID)&m_PersonalProfile, 0, sizeof(m_PersonalProfile));   
    m_PersonalProfile.dwSizeOfStruct = sizeof(m_PersonalProfile);

    m_tchStrArray =  &(m_PersonalProfile.lptstrName);
}

CUserInfoDlg::~CUserInfoDlg()
{
    //
    // free memory
    //
    for(DWORD dw=0; dw < PERSONAL_PROFILE_STR_NUM; ++dw)
    {
        MemFree(m_tchStrArray[dw]);
    }
}

void CUserInfoDlg::DoDataExchange(CDataExchange* pDX)
{
    CFaxClientDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CUserInfoDlg)
    DDX_Control(pDX, IDC_ADDRESS_VALUE, m_editAddress);
    DDX_Control(pDX, IDOK, m_butOk);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CUserInfoDlg, CFaxClientDlg)
    //{{AFX_MSG_MAP(CUserInfoDlg)
    ON_EN_CHANGE(IDC_NAME_VALUE,           OnModify)
    ON_EN_CHANGE(IDC_NAME_VALUE,           OnModify)
    ON_EN_CHANGE(IDC_FAX_NUMBER_VALUE,     OnModify)
    ON_EN_CHANGE(IDC_COMPANY_VALUE,        OnModify)
    ON_EN_CHANGE(IDC_TITLE_VALUE,          OnModify)
    ON_EN_CHANGE(IDC_DEPARTMENT_VALUE,     OnModify)
    ON_EN_CHANGE(IDC_OFFICE_VALUE,         OnModify)
    ON_EN_CHANGE(IDC_HOME_PHONE_VALUE,     OnModify)
    ON_EN_CHANGE(IDC_BUSINESS_PHONE_VALUE, OnModify)
    ON_EN_CHANGE(IDC_EMAIL_VALUE,          OnModify)
    ON_EN_CHANGE(IDC_BILLING_CODE_VALUE,   OnModify)
    ON_EN_CHANGE(IDC_ADDRESS_VALUE,        OnModify)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUserInfoDlg message handlers

BOOL 
CUserInfoDlg::OnInitDialog() 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("COptionsSettingsPg::OnInitDialog"));

    CFaxClientDlg::OnInitDialog();

    //
    // get user info
    //
    FAX_PERSONAL_PROFILE personalProfile;
    memset((LPVOID)&personalProfile, 0, sizeof(personalProfile));   
    personalProfile.dwSizeOfStruct = sizeof(personalProfile);

    HRESULT hResult = FaxGetSenderInformation(&personalProfile);
    if(S_OK != hResult)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("FaxGetSenderInformation"), hResult);
        return TRUE;
    }

    //
    // A numeric edit control should be LTR
    //
    SetLTREditDirection(m_hWnd, IDC_FAX_NUMBER_VALUE);
    SetLTREditDirection(m_hWnd, IDC_EMAIL_VALUE);
    SetLTREditDirection(m_hWnd, IDC_HOME_PHONE_VALUE);
    SetLTREditDirection(m_hWnd, IDC_BUSINESS_PHONE_VALUE);

    //
    // copy strings into the private structure
    //
    DWORD dwLen;
    TCHAR** tchStrArray =  &(personalProfile.lptstrName);
    for(DWORD dw=0; dw < PERSONAL_PROFILE_STR_NUM; ++dw)
    {
        if(NULL == tchStrArray[dw])
        {
            continue;
        }

        dwLen = _tcslen(tchStrArray[dw]);
        if(0 == dwLen)
        {
            continue;
        }

        m_tchStrArray[dw] = (TCHAR*)MemAlloc(sizeof(TCHAR)*(dwLen+1));
        if(!m_tchStrArray[dw])
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("MemAlloc"), dwRes);
            PopupError(dwRes);
            break;
        }

        _tcscpy(m_tchStrArray[dw], tchStrArray[dw]);
    }

    FaxFreeSenderInformation(&personalProfile);

    //
    // display user info
    //
    CEdit* pEdit;
    DWORD dwSize = sizeof(s_PageInfo)/sizeof(s_PageInfo[0]);    
    for(dw=0; dw < dwSize; ++dw)
    {
        //
        // set item value
        //
        pEdit = (CEdit*)GetDlgItem(s_PageInfo[dw].dwValueResId);
        ASSERTION(NULL != pEdit);

        pEdit->SetWindowText(m_tchStrArray[s_PageInfo[dw].eValStrNum]);
        pEdit->SetLimitText(80);
        //
        // Place the caret back at the beginning of the text
        //
        pEdit->SendMessage (EM_SETSEL, 0, 0);
    }

    m_editAddress.SetLimitText(ADDRESS_MAX_LEN);

    m_butOk.EnableWindow(FALSE);    
    
    return TRUE;

} // CUserInfoDlg::OnInitDialog


void 
CUserInfoDlg::OnModify() 
{
    m_butOk.EnableWindow(TRUE); 
}

void 
CUserInfoDlg::OnOK()
{
    DBG_ENTER(TEXT("CUserInfoDlg::OnOK"));

    DWORD dwRes = Save();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("Save"),dwRes);
        PopupError(dwRes);
        return;
    }

    CFaxClientDlg::OnOK();
}

DWORD
CUserInfoDlg::Save() 
/*++

Routine name : CUserInfoDlg::Save

Routine description:

    save the settings into the registry

Author:

    Alexander Malysh (AlexMay), Feb, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CUserInfoDlg::Save"), dwRes);

    //
    // get user info from UI and save it into FAX_PERSONAL_PROFILE structure
    //
    CWnd *pWnd;
    DWORD dwLen;
    TCHAR tszText[512];
    DWORD dwSize = sizeof(s_PageInfo)/sizeof(s_PageInfo[0]);    
    for(DWORD dw=0; dw < dwSize; ++dw)
    {
        //
        // get item value
        //
        pWnd = GetDlgItem(s_PageInfo[dw].dwValueResId);
        ASSERTION(NULL != pWnd);

        pWnd->GetWindowText(tszText, sizeof(tszText)/sizeof(tszText[0]));

        if(m_tchStrArray[s_PageInfo[dw].eValStrNum])
        {
            if(_tcscmp(m_tchStrArray[s_PageInfo[dw].eValStrNum], tszText) == 0)
            {
                continue;
            }
        }

        MemFree(m_tchStrArray[s_PageInfo[dw].eValStrNum]);
        m_tchStrArray[s_PageInfo[dw].eValStrNum] = NULL;

        dwLen = _tcslen(tszText);
        if(0 == dwLen)
        {
            continue;
        }

        //
        // copy string into FAX_PERSONAL_PROFILE structure
        //
        m_tchStrArray[s_PageInfo[dw].eValStrNum] = (TCHAR*)MemAlloc(sizeof(TCHAR)*(dwLen+1));
        if(!m_tchStrArray[s_PageInfo[dw].eValStrNum])
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("MemAlloc"), dwRes);
            break;
        }

        _tcscpy(m_tchStrArray[s_PageInfo[dw].eValStrNum], tszText);
    }

    //
    // save user info into the registry
    //
    HRESULT hResult;
    if(ERROR_SUCCESS == dwRes)
    {
        hResult = FaxSetSenderInformation(&m_PersonalProfile);
        if(S_OK != hResult)
        {
            dwRes = hResult;
            CALL_FAIL (GENERAL_ERR, TEXT("FaxSetSenderInformation"), hResult);
        }
    }


    return dwRes;

} // CUserInfoDlg::Save
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\viewrow.cpp ===
// ViewRow.cpp: implementation of the CViewRow class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     31

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//
// The following four arrays of strings are filled during app. startup from 
// the string table resource by calling InitStrings
//
CString CViewRow::m_cstrPriorities[FAX_PRIORITY_TYPE_HIGH+1];
CString CViewRow::m_cstrQueueStatus[NUM_JOB_STATUS];
CString CViewRow::m_cstrQueueExtendedStatus[JS_EX_CALL_ABORTED - JS_EX_DISCONNECTED + 1];
CString CViewRow::m_cstrMessageStatus[2];

int CViewRow::m_Alignments[MSG_VIEW_ITEM_END] = 
{
	 LVCFMT_LEFT,           // MSG_VIEW_ITEM_ICON
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_STATUS
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_SERVER
     LVCFMT_RIGHT,          // MSG_VIEW_ITEM_NUM_PAGES
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_CSID
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_TSID
     LVCFMT_RIGHT,          // MSG_VIEW_ITEM_SIZE
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_DEVICE
     LVCFMT_RIGHT,          // MSG_VIEW_ITEM_RETRIES
     LVCFMT_RIGHT,          // MSG_VIEW_ITEM_ID
     LVCFMT_RIGHT,          // MSG_VIEW_ITEM_BROADCAST_ID
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_CALLER_ID
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_ROUTING_INFO
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_DOC_NAME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_SUBJECT
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_RECIPIENT_NAME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_RECIPIENT_NUMBER
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_USER
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_PRIORITY
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_ORIG_TIME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_SUBMIT_TIME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_BILLING
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_TRANSMISSION_START_TIME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_SEND_TIME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_EXTENDED_STATUS
     LVCFMT_RIGHT,          // MSG_VIEW_ITEM_CURRENT_PAGE
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_SENDER_NAME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_SENDER_NUMBER
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_TRANSMISSION_END_TIME
     LVCFMT_RIGHT           // MSG_VIEW_ITEM_TRANSMISSION_DURATION
}; 

int CViewRow::m_TitleResources[MSG_VIEW_ITEM_END] = 
{
    IDS_COLUMN_ICON,            // MSG_VIEW_ITEM_ICON,
    IDS_MSG_COLUMN_STATUS,      // MSG_VIEW_ITEM_STATUS,
    IDS_MSG_COLUMN_SERVER,      // MSG_VIEW_ITEM_SERVER,
    IDS_MSG_COLUMN_NUM_PAGES,   // MSG_VIEW_ITEM_NUM_PAGES,
    IDS_MSG_COLUMN_CSID,        // MSG_VIEW_ITEM_CSID,
    IDS_MSG_COLUMN_TSID,        // MSG_VIEW_ITEM_TSID,    
    IDS_MSG_COLUMN_SIZE,        // MSG_VIEW_ITEM_SIZE,
    IDS_MSG_COLUMN_DEVICE,      // MSG_VIEW_ITEM_DEVICE,
    IDS_MSG_COLUMN_RETRIES,     // MSG_VIEW_ITEM_RETRIES,
    IDS_MSG_COLUMN_JOB_ID,      // MSG_VIEW_ITEM_ID,
    IDS_MSG_COLUMN_BROADCAST_ID,// MSG_VIEW_ITEM_BROADCAST_ID
    IDS_MSG_COLUMN_CALLER_ID,   // MSG_VIEW_ITEM_CALLER_ID,
    IDS_MSG_COLUMN_ROUTING_INFO,// MSG_VIEW_ITEM_ROUTING_INFO,
    IDS_MSG_COLUMN_DOC_NAME,    // MSG_VIEW_ITEM_DOC_NAME,
    IDS_MSG_COLUMN_SUBJECT,     // MSG_VIEW_ITEM_SUBJECT,
    IDS_MSG_COLUMN_RECP_NAME,   // MSG_VIEW_ITEM_RECIPIENT_NAME,
    IDS_MSG_COLUMN_RECP_NUM,    // MSG_VIEW_ITEM_RECIPIENT_NUMBER,
    IDS_MSG_COLUMN_USER,        // MSG_VIEW_ITEM_USER,
    IDS_MSG_COLUMN_PRIORITY,    // MSG_VIEW_ITEM_PRIORITY,
    IDS_MSG_COLUMN_ORIG_TIME,   // MSG_VIEW_ITEM_ORIG_TIME,
    IDS_MSG_COLUMN_SUBMIT_TIME, // MSG_VIEW_ITEM_SUBMIT_TIME,
    IDS_MSG_COLUMN_BILLING,     // MSG_VIEW_ITEM_BILLING,
    IDS_MSG_COLUMN_TRANSMISSION_START_TIME, // MSG_VIEW_ITEM_TRANSMISSION_START_TIME,
    IDS_MSG_COLUMN_SEND_TIME,   // MSG_VIEW_ITEM_SEND_TIME,
    IDS_MSG_COLUMN_EX_STATUS,   // MSG_VIEW_ITEM_EXTENDED_STATUS,
    IDS_MSG_COLUMN_CURR_PAGE,   // MSG_VIEW_ITEM_CURRENT_PAGE,
    IDS_MSG_COLUMN_SENDER_NAME, // MSG_VIEW_ITEM_SENDER_NAME,
    IDS_MSG_COLUMN_SENDER_NUM,  // MSG_VIEW_ITEM_SENDER_NUMBER,
    IDS_MSG_COLUMN_TRANSMISSION_END_TIME, // MSG_VIEW_ITEM_TRANSMISSION_END_TIME,
    IDS_MSG_COLUMN_TRANSMISSION_DURATION  // MSG_VIEW_ITEM_TRANSMISSION_DURATION,
};


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

DWORD 
CViewRow::InitStrings ()
/*++

Routine name : CViewRow::InitStrings

Routine description:

    Loads the static strings used to display status etc.
    Static.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::InitStrings"), dwRes);
    //
    // Load strings used for diaply throughout the application - job status
    //
    int iStatusIds[] = 
    {
        IDS_PENDING,
        IDS_INPROGRESS,
        IDS_DELETING,
        IDS_PAUSED,
        IDS_RETRYING,
        IDS_RETRIES_EXCEEDED,
        IDS_COMPLETED,
        IDS_CANCELED,
        IDS_CANCELING,
        IDS_ROUTING,
        IDS_ROUTING_RETRY,
        IDS_ROUTING_INPROGRESS,
        IDS_ROUTING_FAILED
    };

    for (int i = JOB_STAT_PENDING; i < NUM_JOB_STATUS; i++)
    {
        dwRes = LoadResourceString (m_cstrQueueStatus[i], iStatusIds[i]);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
            return dwRes;
        }
    }
    //
    // Load strings used for diaply throughout the application - job extended status
    //
    int iExtStatusIds[] = 
    {
        IDS_DISCONNECTED,    
        IDS_INITIALIZING,    
        IDS_DIALING,         
        IDS_TRANSMITTING,    
        IDS_ANSWERED,        
        IDS_RECEIVING,       
        IDS_LINE_UNAVAILABLE,
        IDS_BUSY,            
        IDS_NO_ANSWER,       
        IDS_BAD_ADDRESS,     
        IDS_NO_DIAL_TONE,    
        IDS_FATAL_ERROR,     
        IDS_CALL_DELAYED,    
        IDS_CALL_BLACKLISTED,
        IDS_NOT_FAX_CALL,
		IDS_STATUS_PARTIALLY_RECEIVED,
        IDS_HANDLED,
		IDS_CALL_COMPLETED,
		IDS_CALL_ABORTED
    };           
    for (i = 0; i < sizeof(iExtStatusIds) / sizeof (iExtStatusIds[0]); i++)
    {
        dwRes = LoadResourceString (m_cstrQueueExtendedStatus[i], iExtStatusIds[i]);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
            return dwRes;
        }
    }
    int iPrioritiyIds[] = 
    {
        IDS_LOW_PRIORITY,
        IDS_NORMAL_PRIORITY,
        IDS_HIGH_PRIORITY
    };

    for (i = FAX_PRIORITY_TYPE_LOW; i <= FAX_PRIORITY_TYPE_HIGH; i++)
    {
        dwRes = LoadResourceString (m_cstrPriorities[i], iPrioritiyIds[i]);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
            return dwRes;
        }
    }
    dwRes = LoadResourceString (m_cstrMessageStatus[0], IDS_STATUS_SUCCESS);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
        return dwRes;
    }
    dwRes = LoadResourceString (m_cstrMessageStatus[1], IDS_STATUS_PARTIALLY_RECEIVED);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
        return dwRes;
    }
    return dwRes;
}   // CViewRow::InitStrings

DWORD    
CViewRow::GetItemTitle (
    DWORD item, 
    CString &cstrRes
) 
/*++

Routine name : CViewRow::GetItemTitle

Routine description:

    Retrieves the title string of an item in the view

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    item            [in ] - Item
    cstrRes         [out] - String buffer

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::GetItemTitle"), dwRes);

    ASSERTION (item < MSG_VIEW_ITEM_END);

    dwRes = LoadResourceString (cstrRes, m_TitleResources[item]);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("LoadResourceString"), dwRes);
    }
    return dwRes;

}   // CViewRow::GetItemTitle


DWORD 
CViewRow::DetachFromMsg()
/*++

Routine name : CViewRow::DetachFromMsg

Routine description:

	Ivalidate content, empty all strings

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::ResetDisplayStrings"), dwRes);

    m_bAttached = FALSE;
    m_bStringsPreparedForDisplay = FALSE;

    for(DWORD dw=0; dw < MSG_VIEW_ITEM_END; ++dw)
    {
        try
        {
            m_Strings[dw].Empty();
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (GENERAL_ERR, TEXT("CString::Empty"), dwRes);
            return dwRes;
        }
    }

    return dwRes;
}


DWORD CViewRow::AttachToMsg(
    CFaxMsg *pMsg,
    BOOL PrepareStrings
)
/*++

Routine name : CViewRow::AttachToMsg

Routine description:

    Attach the view row to an existing message.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pMsg            [in] - Message to attach to
    PrepareStrings  [in] - If TRUE, also create internal strings 
                           representation for list display.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::AttachToMsg"), dwRes);

    ASSERTION (pMsg);

    dwRes = DetachFromMsg();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("DetachFromMsg"), dwRes);
        return dwRes;
    }

    if (PrepareStrings)
    {
        DWORD dwValidityMask = pMsg->GetValidityMask ();
        try
        {
            //
            // Msg id
            //
            m_Strings[MSG_VIEW_ITEM_ID] = DWORDLONG2String (pMsg->GetId());

            //
            // Msg broadcast id
            //
            m_Strings[MSG_VIEW_ITEM_BROADCAST_ID] = (pMsg->GetBroadcastId() != 0) ? 
                                                    DWORDLONG2String (pMsg->GetBroadcastId()) : TEXT("");

            //
            // Msg size
            //
            if (dwValidityMask & FAX_JOB_FIELD_SIZE)
            {
                dwRes = FaxSizeFormat(pMsg->GetSize(), m_Strings[MSG_VIEW_ITEM_SIZE]);
                if(ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("FaxSizeFormat"), dwRes);
                    return dwRes;
                }
            }
            //
            // Page count
            //
            if (dwValidityMask & FAX_JOB_FIELD_PAGE_COUNT)
            {
                m_Strings[MSG_VIEW_ITEM_NUM_PAGES] = DWORD2String (pMsg->GetNumPages());
            }
            //
            // Original scheduled time
            //
            if (dwValidityMask & FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME)
            {
                m_Strings[MSG_VIEW_ITEM_ORIG_TIME] = 
                    pMsg->GetOrigTime().FormatByUserLocale ();
            }
            //
            // Submission time
            //
            if (dwValidityMask & FAX_JOB_FIELD_SUBMISSION_TIME)
            {
                m_Strings[MSG_VIEW_ITEM_SUBMIT_TIME] = 
                    pMsg->GetSubmissionTime().FormatByUserLocale ();
            }
            //
            // Transmission start time
            //
            if (dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME)
            {
                m_Strings[MSG_VIEW_ITEM_TRANSMISSION_START_TIME] = 
                    pMsg->GetTransmissionStartTime().FormatByUserLocale ();
            }

            //
            // Transmission end time
            //
            if (dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME)
            {
                m_Strings[MSG_VIEW_ITEM_TRANSMISSION_END_TIME] = 
                    pMsg->GetTransmissionEndTime().FormatByUserLocale ();
            }

            //
            // Priority
            //
            if (dwValidityMask & FAX_JOB_FIELD_PRIORITY)
            {
                m_Strings[MSG_VIEW_ITEM_PRIORITY] = m_cstrPriorities[pMsg->GetPriority()];
            }
            //
            // Retries
            //
            if (dwValidityMask & FAX_JOB_FIELD_RETRIES)
            {
                m_Strings[MSG_VIEW_ITEM_RETRIES] = DWORD2String (pMsg->GetRetries());
            }
            //
            // Recipient info
            //
            m_Strings[MSG_VIEW_ITEM_RECIPIENT_NUMBER] = pMsg->GetRecipientNumber();

#ifdef UNICODE
            if(theApp.IsRTLUI())
            {
                //
                // Phone number always should be LTR
                // Add LEFT-TO-RIGHT OVERRIDE  (LRO)
                //
                m_Strings[MSG_VIEW_ITEM_RECIPIENT_NUMBER].Insert(0, UNICODE_LRO);
            }
#endif
            m_Strings[MSG_VIEW_ITEM_RECIPIENT_NAME] = pMsg->GetRecipientName();
            //
            // TSID / CSID
            //
            m_Strings[MSG_VIEW_ITEM_TSID] = pMsg->GetTSID();
            m_Strings[MSG_VIEW_ITEM_CSID] = pMsg->GetCSID();
            //
            // User
            //
            m_Strings[MSG_VIEW_ITEM_USER] = pMsg->GetUser();
            //
            // Billing
            //
            m_Strings[MSG_VIEW_ITEM_BILLING] = pMsg->GetBilling();
            //
            // Device
            //
            m_Strings[MSG_VIEW_ITEM_DEVICE] = pMsg->GetDevice();
            //
            // Document
            //
            m_Strings[MSG_VIEW_ITEM_DOC_NAME] = pMsg->GetDocName();
            //
            // Subject
            //
            m_Strings[MSG_VIEW_ITEM_SUBJECT] = pMsg->GetSubject();
            //
            // Caller id
            //
            m_Strings[MSG_VIEW_ITEM_CALLER_ID] = pMsg->GetCallerId();
            //
            // Routing info
            //
            m_Strings[MSG_VIEW_ITEM_ROUTING_INFO] = pMsg->GetRoutingInfo();

            //
            // Server name
            //
            m_Strings[MSG_VIEW_ITEM_SERVER] = pMsg->GetServerName();
            if(m_Strings[MSG_VIEW_ITEM_SERVER].GetLength() == 0)
            {
                dwRes = LoadResourceString(m_Strings[MSG_VIEW_ITEM_SERVER], 
                                           IDS_LOCAL_SERVER);
                if(ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("LoadResourceString"), dwRes);
                    return dwRes;
                }                    
            }

            //
            // Icon
            //
            m_Icon = CalcIcon (pMsg);

            dwRes = InitStatusStr(pMsg);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::InitStatusStr"), dwRes);
                return dwRes;
            }                    

            dwRes = InitExtStatusStr(pMsg);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::InitExtStatusStr"), dwRes);
                return dwRes;
            }                    

            if(pMsg->IsKindOf(RUNTIME_CLASS(CArchiveMsg)))
            {                
                //
                // Sender info
                //
                m_Strings[MSG_VIEW_ITEM_SENDER_NUMBER] = pMsg->GetSenderNumber();
#ifdef UNICODE
                if(theApp.IsRTLUI())
                {
                    //
                    // Phone number always should be LTR
                    // Add LEFT-TO-RIGHT OVERRIDE  (LRO)
                    //
                    m_Strings[MSG_VIEW_ITEM_SENDER_NUMBER].Insert(0, UNICODE_LRO);
                }
#endif
                
                m_Strings[MSG_VIEW_ITEM_SENDER_NAME] = pMsg->GetSenderName();

                //
                // Transmission duration
                //
                if ((dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME) &&
                    (dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME))
                {
                    m_Strings[MSG_VIEW_ITEM_TRANSMISSION_DURATION] = 
                        pMsg->GetTransmissionDuration().FormatByUserLocale ();
                }
            }
            else if(pMsg->IsKindOf(RUNTIME_CLASS(CJob)))
            {
                //
                // Current page
                //
                if (dwValidityMask & FAX_JOB_FIELD_CURRENT_PAGE)
                {
                    m_Strings[MSG_VIEW_ITEM_CURRENT_PAGE] = 
                                            DWORD2String (pMsg->GetCurrentPage());
                }

                //
                // Send time
                //
                if (dwValidityMask & FAX_JOB_FIELD_SCHEDULE_TIME)
                {
                    m_Strings[MSG_VIEW_ITEM_SEND_TIME] = 
                            pMsg->GetScheduleTime().FormatByUserLocale ();
                }
            }
            else
            {
                ASSERTION_FAILURE
            }
        }

        catch (CException *pException)
        {
            TCHAR wszCause[1024];

            pException->GetErrorMessage (wszCause, 1024);
            pException->Delete ();
            VERBOSE (EXCEPTION_ERR,
                     TEXT("CJob::Init caused exception : %s"), 
                     wszCause);
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            return dwRes;
        }
        m_bStringsPreparedForDisplay = TRUE;
    }
    ASSERTION (ERROR_SUCCESS == dwRes);
    m_bAttached = TRUE;
    m_pMsg = pMsg;
    return dwRes;
}   // CViewRow::AttachToMessage

DWORD 
CViewRow::InitStatusStr(
    CFaxMsg *pMsg
)
/*++

Routine name : CViewRow::InitStatusStr

Routine description:

    Init m_Strings[MSG_VIEW_ITEM_STATUS] string with status

Arguments:

    pMsg           [in] - CFaxMsg

Return Value:

    error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::InitStatusStr"));

    ASSERTION(pMsg);

    try
    {
        DWORD dwValidityMask = pMsg->GetValidityMask ();

        if(pMsg->IsKindOf(RUNTIME_CLASS(CArchiveMsg)))
        {
            //
            // Status
            //
            switch (pMsg->GetType())
            {
                case JT_RECEIVE:
                    //
                    // Received message
                    //
                    if ((pMsg->GetExtendedStatus ()) == JS_EX_PARTIALLY_RECEIVED)
                    {
                        //
                        // Partially received fax
                        //
                        m_Strings[MSG_VIEW_ITEM_STATUS] = m_cstrMessageStatus[1];
                    }
                    else
                    {
                        //
                        // Fully received fax
                        //
                        m_Strings[MSG_VIEW_ITEM_STATUS] = m_cstrMessageStatus[0];
                    }
                    break;

                case JT_SEND:
                    //
                    // Sent message
                    //
                    m_Strings[MSG_VIEW_ITEM_STATUS] = m_cstrMessageStatus[0];
                    break;

                default:
                    ASSERTION_FAILURE;
                    m_Strings[MSG_VIEW_ITEM_STATUS].Empty ();
                    break;
            }                              
        }
        else if(pMsg->IsKindOf(RUNTIME_CLASS(CJob)))
        {
            //
            // Queue status
            //
            ASSERTION (dwValidityMask & FAX_JOB_FIELD_QUEUE_STATUS);
            JobStatusType stat = pMsg->GetStatus();
            BOOL bValidStatus = TRUE;
            ASSERTION ((stat >= JOB_STAT_PENDING) && (stat < NUM_JOB_STATUS));

            if(pMsg->GetType() == JT_ROUTING)
            {
            switch(stat)
                {
                    case JOB_STAT_INPROGRESS:
                        stat = JOB_STAT_ROUTING_INPROGRESS;
                        break;
                    case JOB_STAT_RETRYING:
                        stat = JOB_STAT_ROUTING_RETRY;
                        break;
                    case JOB_STAT_RETRIES_EXCEEDED:
                        stat = JOB_STAT_ROUTING_FAILED;
                        break;
                    default:
                        //
                        // Future / unknown job status
                        //
                        bValidStatus = FALSE;
                        break;
                };
            }
            if (bValidStatus)
            {
                m_Strings[MSG_VIEW_ITEM_STATUS] = m_cstrQueueStatus[stat];
            }
            else
            {
                //
                // Unknown (future) status - use empty etring
                //
                m_Strings[MSG_VIEW_ITEM_STATUS].Empty();
            }
                
        }
        else
        {
            ASSERTION_FAILURE;
        }
    }
    catch(CException *pException)
    {
        TCHAR szCause[MAX_PATH];

        if(pException->GetErrorMessage(szCause, ARR_SIZE(szCause)))
        {
            VERBOSE (EXCEPTION_ERR, TEXT("%s"), szCause);
        }
        pException->Delete();

        dwRes = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwRes;
}

DWORD 
CViewRow::InitExtStatusStr(
    CFaxMsg *pMsg
)
/*++

Routine name : CViewRow::InitExtStatusStr

Routine description:

    Init m_Strings[MSG_VIEW_ITEM_EXTENDED_STATUS] string with extended status

Arguments:

    pMsg           [in] - CFaxMsg

Return Value:

    error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::InitExtStatusStr"));

    ASSERTION(pMsg);

    try
    {
        if(pMsg->IsKindOf(RUNTIME_CLASS(CJob)))
        {
            //
            // Extended status            
			// Check for extended status string first
			//
			if (pMsg->GetExtendedStatusString().IsEmpty())
			{
				//
				// Empty extended status string, check for well known extended status
				//
				DWORD dwValidityMask = pMsg->GetValidityMask ();

				if ((dwValidityMask & FAX_JOB_FIELD_STATUS_EX))
				{
					//
					// Extended status code is reported
					//
					DWORD dwExtStatus = pMsg->GetExtendedStatus ();

					ASSERTION (dwExtStatus >= JS_EX_DISCONNECTED);
					if (dwExtStatus > FAX_API_VER_1_MAX_JS_EX)
					{
						//
						// Unknown (future) extended status - use blank string
						//
						m_Strings[MSG_VIEW_ITEM_EXTENDED_STATUS].Empty();
					}
					else
					{
						//
						// Predefined extended status
						//
						m_Strings[MSG_VIEW_ITEM_EXTENDED_STATUS] = 
									m_cstrQueueExtendedStatus[dwExtStatus - JS_EX_DISCONNECTED];
					}
				}				
			}
			else
			{				
				//
				// We have an extended status string, display it
				//
				m_Strings[MSG_VIEW_ITEM_EXTENDED_STATUS] = 
                            pMsg->GetExtendedStatusString();
			}
        }
    }
    catch(CException *pException)
    {
        TCHAR szCause[MAX_PATH];

        if(pException->GetErrorMessage(szCause, ARR_SIZE(szCause)))
        {
            VERBOSE (EXCEPTION_ERR, TEXT("%s"), szCause);
        }
        pException->Delete();

        dwRes = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwRes;
}


IconType 
CViewRow::CalcIcon(
    CFaxMsg *pMsg
)
{
    DBG_ENTER(TEXT("CViewRow::CalcIcon"));
    ASSERTION(pMsg);

    IconType icon = INVALID;

    if(pMsg->IsKindOf(RUNTIME_CLASS(CArchiveMsg)))
    {
        icon = CalcMessageIcon(pMsg);
    }
    else if(pMsg->IsKindOf(RUNTIME_CLASS(CJob)))
    {
        icon = CalcJobIcon(pMsg);
    }
    else
    {
        ASSERTION_FAILURE
    }
    return icon;
}

IconType 
CViewRow::CalcJobIcon(
    CFaxMsg *pJob
)
{
    DBG_ENTER(TEXT("CViewRow::CalcJobIcon"));
    ASSERTION(pJob);

    int iStatus = pJob->GetStatus();

    ASSERTION (pJob->GetValidityMask() & FAX_JOB_FIELD_STATUS_SUB_STRUCT);
    ASSERTION (pJob->GetValidityMask() && FAX_JOB_FIELD_TYPE);
    switch (pJob->GetType())
    {
        case JT_ROUTING:
            //
            // Routing job
            //
            switch (iStatus)
            {
                case JOB_STAT_PENDING:
                case JOB_STAT_DELETING:
                case JOB_STAT_RETRYING:
                case JOB_STAT_CANCELING:
                case JOB_STAT_INPROGRESS:
                    return LIST_IMAGE_ROUTING;
                    break;

                case JOB_STAT_RETRIES_EXCEEDED:
                    return LIST_IMAGE_ERROR;
                    break;

                default:
                    //
                    // We don't allow MSG_STAT_COMPLETED, MSG_STAT_PAUSED, 
                    // and MSG_STAT_CANCELED.
                    //
                    ASSERTION_FAILURE;
                    return INVALID;
            }
            break;

        case JT_RECEIVE:
            //
            // Receiving job
            //
            switch (iStatus)
            {
                case JOB_STAT_CANCELING:
                case JOB_STAT_INPROGRESS:
                case JOB_STAT_ROUTING:
                    return LIST_IMAGE_RECEIVING;
                    break;

                default:
                    //
                    // We don't allow MSG_STAT_COMPLETED, MSG_STAT_PAUSED, 
                    // MSG_STAT_PENDING, MSG_STAT_DELETING, 
                    // MSG_STAT_RETRYING
                    // MSG_STAT_RETRIES_EXCEEDED,
                    // and MSG_STAT_CANCELED.
                    //
                    ASSERTION_FAILURE;
                    return INVALID;
            }
            break;
        

        case JT_SEND:
            switch (iStatus)
            {
                case JOB_STAT_PENDING:
                case JOB_STAT_DELETING:
                case JOB_STAT_RETRYING:
                case JOB_STAT_CANCELING:
                case JOB_STAT_COMPLETED:
                case JOB_STAT_CANCELED:
                    return LIST_IMAGE_NORMAL_MESSAGE;
                    break;

                case JOB_STAT_RETRIES_EXCEEDED:
                    return LIST_IMAGE_ERROR;
                    break;

                case JOB_STAT_PAUSED:
                    return LIST_IMAGE_PAUSED;
                    break;

                case JOB_STAT_INPROGRESS:
                    return LIST_IMAGE_SENDING;
                    break;

                default:
                    //
                    // Unknown job status
                    //
                    ASSERTION_FAILURE;
                    return INVALID;
            }
            break;

        default:
            ASSERTION_FAILURE;
            return INVALID;
    }
}

IconType 
CViewRow::CalcMessageIcon(
    CFaxMsg *pMsg
)
{
    DBG_ENTER(TEXT("CViewRow::CalcMessageIcon"));
    ASSERTION(pMsg);

    switch (pMsg->GetType())
    {
        case JT_RECEIVE:
            //
            // Received message
            //
            if ((pMsg->GetExtendedStatus ()) == JS_EX_PARTIALLY_RECEIVED)
            {
                //
                // Partially received fax
                //
                return LIST_IMAGE_PARTIALLY_RECEIVED;
            }
            else
            {
                //
                // Fully received fax
                //
                return LIST_IMAGE_SUCCESS;
            }
            break;

        case JT_SEND:
            return LIST_IMAGE_SUCCESS;

        default:
            ASSERTION_FAILURE;
            return INVALID;
    }
}

int      
CViewRow::CompareByItem (
    CViewRow &other, 
    DWORD item
)
/*++

Routine name : CViewRow::CompareByItem

Routine description:

    Compares a list item against another one

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    other           [in] - Other list item
    item            [in] - Item to compare by

Return Value:

    -1 if smaler than other, 0 if identical, +1 if bigger than other

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::CompareByItem"));

    ASSERTION (item < MSG_VIEW_ITEM_END);
    ASSERTION (m_bAttached && other.m_bAttached);

    if(other.m_pMsg->IsKindOf(RUNTIME_CLASS(CJob))  !=
             m_pMsg->IsKindOf(RUNTIME_CLASS(CJob)))
    {
        ASSERTION_FAILURE;
        return 1;
    }

    switch (item)
    {
        case MSG_VIEW_ITEM_ICON:
        case MSG_VIEW_ITEM_STATUS:
            dwRes = InitStatusStr(m_pMsg);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::InitStatusStr"), dwRes);
                return 0;
            }                    

            dwRes = other.InitStatusStr(other.m_pMsg);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::InitStatusStr"), dwRes);
                return 0;
            }                    

            return m_Strings[MSG_VIEW_ITEM_STATUS].Compare(other.m_Strings[MSG_VIEW_ITEM_STATUS]);

        case MSG_VIEW_ITEM_EXTENDED_STATUS:
            dwRes = InitExtStatusStr(m_pMsg);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::InitStatusStr"), dwRes);
                return 0;
            }                    

            dwRes = other.InitExtStatusStr(other.m_pMsg);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::InitStatusStr"), dwRes);
                return 0;
            }                    

            return m_Strings[item].Compare(other.m_Strings[item]);

        case MSG_VIEW_ITEM_SERVER:
            return m_pMsg->GetServerName().Compare (other.m_pMsg->GetServerName());

        case MSG_VIEW_ITEM_CSID:
            return m_pMsg->GetCSID().Compare (other.m_pMsg->GetCSID());

        case MSG_VIEW_ITEM_TSID:
            return m_pMsg->GetTSID().Compare (other.m_pMsg->GetTSID());

        case MSG_VIEW_ITEM_DEVICE:
            return m_pMsg->GetDevice().Compare (other.m_pMsg->GetDevice());

        case MSG_VIEW_ITEM_CALLER_ID:
            return m_pMsg->GetCallerId().Compare (other.m_pMsg->GetCallerId());

        case MSG_VIEW_ITEM_ROUTING_INFO:
            return m_pMsg->GetRoutingInfo().Compare (other.m_pMsg->GetRoutingInfo());

        case MSG_VIEW_ITEM_DOC_NAME:
            return m_pMsg->GetDocName().Compare (other.m_pMsg->GetDocName());

        case MSG_VIEW_ITEM_SUBJECT:
            return m_pMsg->GetSubject().Compare (other.m_pMsg->GetSubject());

        case MSG_VIEW_ITEM_RECIPIENT_NAME:
            return m_pMsg->GetRecipientName().Compare (other.m_pMsg->GetRecipientName());

        case MSG_VIEW_ITEM_RECIPIENT_NUMBER:
            return m_pMsg->GetRecipientNumber().Compare (other.m_pMsg->GetRecipientNumber());

        case MSG_VIEW_ITEM_USER:
            return m_pMsg->GetUser().Compare (other.m_pMsg->GetUser());

        case MSG_VIEW_ITEM_PRIORITY:
            return NUMERIC_CMP(m_pMsg->GetPriority(), other.m_pMsg->GetPriority());

        case MSG_VIEW_ITEM_BILLING:
            return m_pMsg->GetBilling().Compare (other.m_pMsg->GetBilling());

        case MSG_VIEW_ITEM_NUM_PAGES:
            return NUMERIC_CMP(m_pMsg->GetNumPages(), other.m_pMsg->GetNumPages());

        case MSG_VIEW_ITEM_CURRENT_PAGE:
            return NUMERIC_CMP(m_pMsg->GetCurrentPage(), other.m_pMsg->GetCurrentPage());

        case MSG_VIEW_ITEM_TRANSMISSION_START_TIME:
            return m_pMsg->GetTransmissionStartTime().Compare (
                        other.m_pMsg->GetTransmissionStartTime());

        case MSG_VIEW_ITEM_SIZE:
            return NUMERIC_CMP(m_pMsg->GetSize(), other.m_pMsg->GetSize());

        case MSG_VIEW_ITEM_RETRIES:
            return NUMERIC_CMP(m_pMsg->GetRetries(), other.m_pMsg->GetRetries());

        case MSG_VIEW_ITEM_ID:
            return NUMERIC_CMP(m_pMsg->GetId(), other.m_pMsg->GetId());

        case MSG_VIEW_ITEM_BROADCAST_ID:
            return NUMERIC_CMP(m_pMsg->GetBroadcastId(), other.m_pMsg->GetBroadcastId());
            
        case MSG_VIEW_ITEM_ORIG_TIME:
            return m_pMsg->GetOrigTime().Compare (
                        other.m_pMsg->GetOrigTime());

        case MSG_VIEW_ITEM_SUBMIT_TIME:
            return m_pMsg->GetSubmissionTime().Compare (
                        other.m_pMsg->GetSubmissionTime());

        case MSG_VIEW_ITEM_SEND_TIME:
            return m_pMsg->GetScheduleTime().Compare (
                        other.m_pMsg->GetScheduleTime());

        case MSG_VIEW_ITEM_SENDER_NAME:
            return m_pMsg->GetSenderName().Compare (other.m_pMsg->GetSenderName());

        case MSG_VIEW_ITEM_SENDER_NUMBER:
            return m_pMsg->GetSenderNumber().Compare (other.m_pMsg->GetSenderNumber());

        case MSG_VIEW_ITEM_TRANSMISSION_END_TIME:
            return m_pMsg->GetTransmissionEndTime().Compare (
                        other.m_pMsg->GetTransmissionEndTime());

        case MSG_VIEW_ITEM_TRANSMISSION_DURATION:
            return m_pMsg->GetTransmissionDuration().Compare (
                        other.m_pMsg->GetTransmissionDuration());

        default:
            ASSERTION_FAILURE;
            return 0;
    }
    ASSERTION_FAILURE;
}   // CViewRow::CompareByItem
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\resources\resource.h ===
//
// Microsoft Developer Studio generated include file.
// Used by clientconsole.rc
//
#define IDD_ABOUTBOX                    100
#define ID_VIEW_ARRANGE                 127
#define IDR_MAINFRAME                   128
#define IDB_TREE_IMAGES                 130
#define IDB_LIST_IMAGES                 131
#define ID_VIEW_REFRESH_FOLDER          132
#define IDD_ERROR                       135
#define IDD_COLUMN_SELECT               136
#define IDR_ICON_ERROR                  137
#define IDC_STATIC_AVAILABLE            138
#define IDC_STATIC_DISPLAYED            139
#define IDC_BUT_ADD                     140
#define IDC_BUT_REMOVE                  141
#define IDC_BUT_UP                      142
#define IDC_BUT_DOWN                    143
#define IDC_LIST_DISPLAYED              144
#define IDC_LIST_AVAILABLE              145
#define ID_VIEW_SELECT_COLUMNS          146
#define ID_INDICATOR_FOLDER_ITEMS_COUNT 147
#define ID_INDICATOR_ACTIVITY           148
#define IDB_DOC_ICON                    149
#define IDD_OUTBOX_GENERAL              150
#define IDD_INCOMING_GENERAL            151
#define IDD_SENT_ITEMS_GENERAL          152
#define IDD_INBOX_GENERAL               153
#define IDD_PERSONAL_INFO               154
#define IDD_INBOX_DETAILS               155
#define IDD_INCOMING_DETAILS            156
#define IDD_OUTBOX_DETAILS              157
#define IDD_SENT_ITEMS_DETAILS          158
#define IDD_COPY_CP_FROM_SRV            159
#define ID_SEND_NEW_FAX                 160
#define ID_ADD_NEW_FAX_PRINTER          161
#define ID_REMOVE_FAX_PRINTER           162
#define ID_VIEW_OPTIONS                 163
#define IDD_OPTIONS_USER_INFO           165
#define IDI_USER_INFO                   167
#define IDI_OPTIONS                     168
#define IDD_ADDRESS                     169
#define IDD_COVER_PAGES                 170
#define IDI_SRV_WRN                     171
#define IDI_SRV_OK                      172
#define IDI_SRV_WAIT                    173
#define ID_RECEIVE_NEW_FAX              174
#define IDD_FAX_PROGRESS                175
#define IDI_ICON_INFO                   176
#define IDD_IMPORT_INFO                 177
#define IDC_ERROR_TEXT                  1001
#define IDC_SEPERATOR                   1003
#define IDC_DETAILS_DATA                1004
#define IDC_DETAILS                     1005
#define IDM_OUTBOX                      1006
#define IDM_INCOMING                    1007
#define IDM_INBOX                       1008
#define IDM_SENTITEMS                   1009
#define ID_FOLDER_ITEM_VIEW             1010
#define ID_FOLDER_ITEM_PRINT            1011
#define ID_FOLDER_ITEM_PAUSE            1012
#define ID_FOLDER_ITEM_RESUME           1013
#define ID_FOLDER_ITEM_RESTART          1014
#define ID_FOLDER_ITEM_PROPERTIES       1015
#define ID_FOLDER_ITEM_DELETE           1016
#define ID_FOLDER_ITEM_COPY             1017
#define ID_FOLDER_ITEM_MAIL_TO          1018
#define ID_SELECT_ALL                   1019
#define ID_SELECT_NONE                  1020
#define ID_SELECT_INVERT                1021
#define ID_FOLDER_ITEM_RENAME           1022
#define ID_REFRESH_SERVER_STATUS        1023
#define IDC_DOC_NAME_TITLE              1100
#define IDC_DOC_NAME_VALUE              1101
#define IDC_SUBJECT_TITLE               1102
#define IDC_SUBJECT_VALUE               1103
#define IDC_RECIPIENT_NAME_TITLE        1104
#define IDC_RECIPIENT_NAME_VALUE        1105
#define IDC_RECIPIENT_NUMBER_TITLE      1106
#define IDC_RECIPIENT_NUMBER_VALUE      1107
#define IDC_STATUS_TITLE                1108
#define IDC_STATUS_VALUE                1109
#define IDC_EXTENDED_STATUS_TITLE       1110
#define IDC_EXTENDED_STATUS_VALUE       1111
#define IDC_PAGES_TITLE                 1112
#define IDC_PAGES_VALUE                 1113
#define IDC_CURRENT_PAGE_TITLE          1114
#define IDC_CURRENT_PAGE_VALUE          1115
#define IDC_USER_TITLE                  1116
#define IDC_USER_VALUE                  1117
#define IDC_PRIORITY_TITLE              1118
#define IDC_PRIORITY_VALUE              1119
#define IDC_CSID_TITLE                  1120
#define IDC_CSID_VALUE                  1121
#define IDC_TSID_TITLE                  1122
#define IDC_TSID_VALUE                  1123
#define IDC_SCHEDULED_TIME_TITLE        1124
#define IDC_SCHEDULED_TIME_VALUE        1125
#define IDC_CALLER_ID_TITLE             1126
#define IDC_CALLER_ID_VALUE             1127
#define IDC_SIZE_TITLE                  1128
#define IDC_SIZE_VALUE                  1129
#define IDC_DEVICE_TITLE                1130
#define IDC_DEVICE_VALUE                1131
#define IDC_ROUTING_INFO_TITLE          1132
#define IDC_ROUTING_INFO_VALUE          1133
#define IDC_JOB_ID_TITLE                1134
#define IDC_JOB_ID_VALUE                1135
#define IDC_SUBMISSION_TIME_TITLE       1136
#define IDC_SUBMISSION_TIME_VALUE       1137
#define IDC_SENDER_NAME_TITLE           1138
#define IDC_TRANSMISSION_TIME_TITLE     1139
#define IDC_TRANSMISSION_TIME_VALUE     1140
#define IDC_SENDER_NAME_VALUE           1141
#define IDC_BILLING_CODE_TITLE          1142
#define IDC_BILLING_CODE_VALUE          1143
#define IDC_START_TIME_TITLE            1144
#define IDC_START_TIME_VALUE            1145
#define IDC_END_TIME_TITLE              1146
#define IDC_NAME_TITLE                  1147
#define IDC_END_TIME_VALUE              1148
#define IDC_NAME_VALUE                  1149
#define IDC_DURATION_TITLE              1150
#define IDC_FAX_NUMBER_TITLE            1151
#define IDC_DURATION_VALUE              1152
#define IDC_FAX_NUMBER_VALUE            1153
#define IDC_SENDER_NUMBER_TITLE         1154
#define IDC_COMPANY_TITLE               1155
#define IDC_SENDER_NUMBER_VALUE         1156
#define IDC_COMPANY_VALUE               1157
#define IDC_STREET_VALUE                1159
#define IDC_CITY_TITLE                  1160
#define IDC_CITY_VALUE                  1161
#define IDC_STATE_TITLE                 1162
#define IDC_STATE_VALUE                 1163
#define IDC_ZIP_CODE_TITLE              1164
#define IDC_ZIP_CODE_VALUE              1165
#define IDC_COUNTRY_TITLE               1166
#define IDC_COUNTRY_VALUE               1167
#define IDC_TITLE_TITLE                 1168
#define IDC_TITLE_VALUE                 1169
#define IDC_DEPARTMENT_TITLE            1170
#define IDC_DEPARTMENT_VALUE            1171
#define IDC_OFFICE_TITLE                1172
#define IDC_OFFICE_VALUE                1173
#define IDC_HOME_PHONE_TITLE            1174
#define IDC_HOME_PHONE_VALUE            1175
#define IDC_BUSINESS_PHONE_TITLE        1176
#define IDC_BUSINESS_PHONE_VALUE        1177
#define IDC_EMAIL_TITLE                 1180
#define IDC_EMAIL_VALUE                 1181
#define IDC_RETRIES_TITLE               1182
#define IDC_RETRIES_VALUE               1183
#define IDC_STATIC_DOC_INFO             1200
#define IDC_STATIC_STATUS               1201
#define IDC_STATIC_TRANS_INFO           1202
#define IDC_STATIC_PERSONAL             1203
#define IDC_STATIC_ADDRESS              1204
#define IDC_EDIT_TEST                   1205
#define ID_COV_PAGE_NEW                 1208
#define IDC_SELECT_CP_FOR_COPY          1211
#define IDC_LIST_CP                     1212
#define IDM_TREE_ROOT_OPTIONS           1213
#define IDC_COVER_PAGES_DIR             1215
#define IDC_BUT_CP_BROWSE               1216
#define IDC_CONFIRMATIONS               1217
#define IDC_CONFIRM_ITEM_DELETION       1218
#define IDC_CONFIRM_PRINTER_REMOVAL     1220
#define IDC_COVER_PAGES_LOCATION        1221
#define IDC_USER_INFO                   1222
#define IDC_STATIC_USER_INFO            1223
#define IDC_BUT_ADDRESS                 1225
#define IDC_ADDRESS_TITLE               1226
#define IDC_ADDRESS_VALUE               1227
#define IDM_OUTBOX_FOLDER               1228
#define IDM_INCOMING_FOLDER             1229
#define ID_QUEUE_BLOCK                  1230
#define ID_QUEUE_UNBLOCK                1231
#define ID_QUEUE_PAUSE                  1232
#define ID_QUEUE_RESUME                 1233
#define ID_QUEUE_DELETE_ALL_FAXES       1234
#define ID_VIEW_COVER_PAGES             1235
#define ID_TOOLS_USER_INFO              1236
#define IDC_CP_OPEN                     1238
#define IDC_CP_NEW                      1239
#define IDC_CP_RENAME                   1240
#define IDC_CP_DELETE                   1241
#define IDC_CP_ADD                      1244
#define IDD_SERVER_STATUS               1245
#define IDC_LIST_SERVER                 1246
#define ID_VIEW_SERVER_STATUS           1247
#define IDC_ABOUT_PRODUCT               1248
#define IDC_ABOUT_VERSION               1249
#define IDC_ABOUT_COPYRIGHT             1250
#define IDC_BROADCAST_ID_TITLE          1251
#define IDC_BROADCAST_ID_VALUE          1252
#define ID_TOOLS_CONFIG_WIZARD          1301
#define ID_TOOLS_ADMIN_CONSOLE          1302
#define ID_TOOLS_FAX_PRINTER_PROPS      1303
#define ID_TOOLS_MONITOR                1304
#define ID_IMPORT_INBOX                 1310
#define ID_IMPORT_SENT                  1311
#define IDC_PROGRESS_TITLE              1312
#define IDC_PROGRESS_BAR                1313
#define IDC_PROGRESS_NUMBER             1314
#define IDC_IMPORT_HELP_LINK            1315
#define IDC_SERVER_TITLE                1316
#define IDC_SERVER_VALUE                1317
#define IDB_ERROR_IMG                   32515
#define ID_DOCUMENT_RESUME              32771
#define IDS_TREE_NODE_INBOX             57605
#define IDS_TREE_NODE_SENT_ITEMS        57606
#define IDS_TREE_NODE_OUTBOX            57607
#define IDS_TREE_NODE_INCOMING          57608
#define IDS_TREE_ROOT_NAME              57638
#define IDS_STATUS_SUCCESS              57657
#define IDS_STATUS_PARTIALLY_RECEIVED   57658
#define IDS_LOW_PRIORITY                57661
#define IDS_NORMAL_PRIORITY             57662
#define IDS_HIGH_PRIORITY               57663
#define IDS_CANCELING                   57672
#define IDS_CANCELED                    57673
#define IDS_COMPLETED                   57674
#define IDS_RETRIES_EXCEEDED            57675
#define IDS_PENDING                     57676
#define IDS_RETRYING                    57677
#define IDS_PAUSED                      57679
#define IDS_DELETING                    57683
#define IDS_INPROGRESS                  57684
#define IDS_MSG_COLUMN_STATUS           57691
#define IDS_MSG_COLUMN_SERVER           57692
#define IDS_MSG_COLUMN_NUM_PAGES        57693
#define IDS_MSG_COLUMN_CSID             57694
#define IDS_MSG_COLUMN_TSID             57695
#define IDS_MSG_COLUMN_SIZE             57696
#define IDS_MSG_COLUMN_DEVICE           57697
#define IDS_MSG_COLUMN_RETRIES          57698
#define IDS_MSG_COLUMN_JOB_ID           57699
#define IDS_MSG_COLUMN_CALLER_ID        57700
#define IDS_MSG_COLUMN_ROUTING_INFO     57701
#define IDS_MSG_COLUMN_DOC_NAME         57702
#define IDS_MSG_COLUMN_SUBJECT          57703
#define IDS_MSG_COLUMN_RECP_NAME        57704
#define IDS_MSG_COLUMN_RECP_NUM         57705
#define IDS_MSG_COLUMN_USER             57706
#define IDS_MSG_COLUMN_PRIORITY         57707
#define IDS_MSG_COLUMN_ORIG_TIME        57708
#define IDS_MSG_COLUMN_SUBMIT_TIME      57709
#define IDS_MSG_COLUMN_BILLING          57710
#define IDS_MSG_COLUMN_TRANSMISSION_START_TIME 57711
#define IDS_MSG_COLUMN_SEND_TIME        57712
#define IDS_MSG_COLUMN_EX_STATUS        57713
#define IDS_MSG_COLUMN_CURR_PAGE        57714
#define IDS_MSG_COLUMN_SENDER_NAME      57715
#define IDS_MSG_COLUMN_SENDER_NUM       57716
#define IDS_MSG_COLUMN_TRANSMISSION_END_TIME 57717
#define IDS_MSG_COLUMN_TRANSMISSION_DURATION 57718
#define IDS_ERR_CONNECTION_FAILED       57730
#define IDS_ERR_NO_MEMORY               57731
#define IDS_ERR_ACCESS_DENIED           57732
#define IDS_ERR_OPERATION_FAILED        57733
#define IDS_ERR_CANT_COMPLETE_OPERATION 57734
#define IDS_MSG_COLUMN_BROADCAST_ID     57735
#define IDS_DISCONNECTED                58000
#define IDS_INITIALIZING                58001
#define IDS_DIALING                     58002
#define IDS_TRANSMITTING                58003
#define IDS_ANSWERED                    58004
#define IDS_RECEIVING                   58005
#define IDS_LINE_UNAVAILABLE            58006
#define IDS_BUSY                        58007
#define IDS_NO_ANSWER                   58008
#define IDS_BAD_ADDRESS                 58009
#define IDS_NO_DIAL_TONE                58010
#define IDS_FATAL_ERROR                 58011
#define IDS_CALL_DELAYED                58012
#define IDS_CALL_BLACKLISTED            58013
#define IDS_NOT_FAX_CALL                58014
#define IDS_HANDLED                     58015
#define IDS_CALL_COMPLETED              58016
#define IDS_CALL_ABORTED                58017
#define IDS_TREE_NODE_FORMAT_REMOTE     61204
#define IDS_TREE_NODE_FORMAT_LOCAL      61205
#define IDS_STATUS_BAR_ITEM             61206
#define IDS_STATUS_BAR_ITEMS            61207
#define IDS_COLUMN_ICON                 61208
#define IDS_FOLDER_IDLE                 61209
#define IDS_SERVER_REFRESHING           61210
#define IDS_SERVER_ONLINE               61211
#define IDS_SERVER_OFFLINE              61212
#define IDS_FOLDER_REFRESHING           61213
#define IDS_FOLDER_SORTING              61214
#define IDS_SERVER_NET_ERROR            61215
#define IDS_FOLDER_REFRESH_FAILED       61216
#define IDS_BUTTON_CLOSE                61222
#define IDS_SENDER_INFO_CAPTION         61224
#define IDS_RECIPIENT_INFO_CAPTION      61225
#define IDS_PROPERTIES_SHEET_CAPTION    61226
#define IDS_BAD_COMCTL32                61227
#define IDS_PERSONAL_COVER_PAGES        61228
#define IDS_COV_COLUMN_NAME             61229
#define IDS_COV_COLUMN_MODIFIED         61230
#define IDS_COV_COLUMN_SIZE             61231
#define IDS_COVER_PAGE                  61232
#define IDS_COVER_PAGE_EXISTS           61234
#define IDS_SURE_DELETE_ONE             61235
#define IDS_SURE_DELETE_MANY            61236
#define IDS_OPTIONS_CAPTION             61239
#define IDS_SELECT_CP_DIR               61240
#define IDS_LOCAL_SERVER                61243
#define IDS_SRV_COL_SERVER              61244
#define IDS_SRV_COL_STATUS              61245
#define IDS_SRV_PART_OFFLINE            61246
#define IDS_SRV_OFFLINE                 61247
#define IDS_SRV_ONLINE                  61248
#define IDS_NO_SRV_INSTALL              61249
#define IDS_VERSION_FORMAT              61250
#define IDS_PERSONAL_CP_DIR             61251
#define IDS_ROUTING                     61252
#define IDS_ROUTING_RETRY               61253
#define IDS_ROUTING_INPROGRESS          61254
#define IDS_ROUTING_FAILED              61255
#define IDS_NO_OPEN_ASSOCIATION         61256
#define IDS_NO_PRINT_ASSOCIATION        61257
#define IDS_PRINTER_NAME_FORMAT         61258
#define IDS_SAVE_AS_TOO_LONG            61259
#define IDS_ERR_SRV_OUTOFMEMORY         61260
#define IDS_ERR_FILE_ACCESS_DENIED      61261
#define IDS_ERR_MESSAGE_NOT_FOUND       61262
#define IDS_ERR_NO_HTML_HELP            61263
#define IDS_SERVER_OUTBOX_BLOCKED       61264
#define IDS_SERVER_OUTBOX_PAUSED        61265
#define IDS_IMPORT_TITLE_INBOX          61266
#define IDS_IMPORT_EMPTY_FOLDER         61267
#define IDS_IMPORT_TO_INBOX             61268
#define IDS_IMPORT_TO_SENT_ITEMS        61269
#define IDS_PROGRESS_NUMBER             61270
#define IDS_IMPORT_ERROR                61271
#define IDS_IMPORT_INFO                 61272
#define IDS_IMPORT_BAD_FORMAT           61273
#define IDS_COPY_CP_TITLE               61274
#define IDS_IMPORT_NO_ACCESS            61275
#define IDS_SAVE_AS_FILTER_FORMAT       61276
#define IDS_CP_ADD_FILTER_FORMAT        61277
#define IDS_IMPORT_TITLE_SENTITEMS      61278
#define IDS_IMPORT_FILE_NOT_SEND_TYPE    61279
#define IDS_IMPORT_FILE_NOT_RECEIVE_TYPE 61280
#define IDS_PROGRESS_DELETE             61281
#define IDS_PROGRESS_PAUSE              61282
#define IDS_PROGRESS_RESUME             61283
#define IDS_PROGRESS_RESTART            61284
#define IDS_IMPORT_SAME_DIR_SENT		61285
#define IDS_IMPORT_SAME_DIR_INBOX		61286
#define IDS_ADMIN_CONSOLE_TITLE			61287
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\clientconsole\utils.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Utils.cpp

Abstract:

    Provides utility functions for the entire poject

Author:

    Eran Yariv (EranY)  Dec, 1999

Revision History:

--*/

#include "stdafx.h"
#define __FILE_ID__     10


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CClientConsoleApp theApp;

DWORD
LoadResourceString (
    CString &cstr,
    int      ResId
)
/*++

Routine name : LoadResourceString

Routine description:

    Loads a string from the resource

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    cstr            [out] - String buffer
    ResId           [in ] - String resource id

Return Value:

    Standard win32 error code

--*/
{
    BOOL bRes;
    DWORD dwRes = ERROR_SUCCESS;

    try
    {
        bRes = cstr.LoadString (ResId);
    }
    catch (CMemoryException *pException)
    {
        DBG_ENTER(TEXT("LoadResourceString"), dwRes);
        TCHAR wszCause[1024];

        pException->GetErrorMessage (wszCause, 1024);
        pException->Delete ();
        VERBOSE (EXCEPTION_ERR,
                 TEXT("CString::LoadString caused exception : %s"), 
                 wszCause);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        PopupError (dwRes);
        return dwRes;
    }
    if (!bRes)
    {
        dwRes = ERROR_NOT_FOUND;
        PopupError (dwRes);
        return dwRes;
    }
    return dwRes;
}   // LoadResourceString

CString 
DWORDLONG2String (
    DWORDLONG dwlData
)
/*++

Routine name : DWORDLONG2String

Routine description:

    Converts a 64-bit unsigned number to string

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwlData         [in] - Number to convert

Return Value:

    Output string

--*/
{
    CString cstrResult;
    cstrResult.Format (TEXT("0x%016I64x"), dwlData);
    return cstrResult;
}   // DWORDLONG2String


CString 
DWORD2String (
    DWORD dwData
)
/*++

Routine name : DWORD2String

Routine description:

    Converts a 32-bit unsigned number to string

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwData          [in] - Number to convert

Return Value:

    Output string

--*/
{
    CString cstrResult;
    cstrResult.Format (TEXT("%ld"), dwData);
    return cstrResult;
}   // DWORD2String


DWORD 
Win32Error2String(
    DWORD    dwWin32Err, 
    CString& strError
)
/*++

Routine name : Win32Error2String

Routine description:

    Format a Win32 error code to a string

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwWin32Err      [in]  - Win32 error code
    strError        [out] - Result string

Return Value:

    error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("Win32Error2String"));

    LPTSTR  lpszError=NULL;
    //
    // Create descriptive error text
    //
    if (!FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM     |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        dwWin32Err,
                        0,
                        (TCHAR *)&lpszError,
                        0,
                        NULL))
    {
        //
        // Failure to format the message
        //
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("FormatMessage"), dwRes);
        return dwRes;
    }

    try
    {
        strError = lpszError;
    }
    catch (...)
    {
        LocalFree (lpszError);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LocalFree (lpszError);
    return dwRes;
}   // Win32Error2String



DWORD 
LoadDIBImageList (
    CImageList &iml, 
    int iResourceId, 
    DWORD dwImageWidth,
    COLORREF crMask
)
/*++

Routine name : LoadDIBImageList

Routine description:

    Loads an image list from the resource, retaining 24-bit colors

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    iml             [out] - Image list buffer
    iResourceId     [in ] - Image list bitmap resource id
    dwImageWidth    [in ] - Image width (pixels)
    crMask          [in ] - Color key (transparent mask)

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("LoadDIBImageList"), dwRes);

    HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(iResourceId), RT_BITMAP);
    if (hInst)
    {
        HIMAGELIST hIml = ImageList_LoadImage ( hInst,
                                                MAKEINTRESOURCE(iResourceId),
                                                dwImageWidth,
                                                0,
                                                crMask,
                                                IMAGE_BITMAP,
                                                LR_DEFAULTCOLOR);
        if (hIml)
        {
            if (!iml.Attach (hIml))
            {
                dwRes = ERROR_GEN_FAILURE;
                CALL_FAIL (WINDOW_ERR, TEXT("CImageList::Attach"), dwRes);
                DeleteObject (hIml);
            }
        }
        else
        {
            //
            //  ImageList_LoadImage() failed
            //
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, _T("ImageList_LoadImage"), dwRes);
        }
    }
    else
    {
        //
        //  AfxFindResourceHandle() failed
        //
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, _T("AfxFindResourceHandle"), dwRes);
    }
    return dwRes;
}   // LoadDIBImageList



#define BUILD_THREAD_DEATH_TIMEOUT INFINITE


DWORD 
WaitForThreadDeathOrShutdown (
    HANDLE hThread
)
/*++

Routine name : WaitForThreadDeathOrShutdown

Routine description:

    Waits for a thread to end.
    Also processes windows messages in the background.
    Stops waiting if the application is shutting down.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    hThread         [in] - Handle to thread

Return Value:

    Standard Win23 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("WaitForThreadDeathOrShutdown"), dwRes);

    for (;;)
    {
        //
        // We wait on the thread handle and the shutdown event (which ever comes first)
        //
        HANDLE hWaitHandles[2];
        hWaitHandles[0] = hThread;
        hWaitHandles[1] = CClientConsoleDoc::GetShutdownEvent ();
        if (NULL == hWaitHandles[1])
        {
            //
            // We're shutting down
            //
            return dwRes;
        }
        DWORD dwStart = GetTickCount ();
        VERBOSE (DBG_MSG,
                 TEXT("Entering WaitForMultipleObjects (timeout = %ld)"), 
                 BUILD_THREAD_DEATH_TIMEOUT);
        //
        // Wait now....
        //
        dwRes = MsgWaitForMultipleObjects(
                   sizeof (hWaitHandles) / sizeof(hWaitHandles[0]), // Num of wait objects
                   hWaitHandles,                                    // Array of wait objects
                   FALSE,                                           // Wait for either one
                   BUILD_THREAD_DEATH_TIMEOUT,                      // Timeout
                   QS_ALLINPUT);                                    // Accept messages

        DWORD dwRes2 = GetLastError();
        VERBOSE (DBG_MSG, 
                 TEXT("Leaving WaitForMultipleObjects after waiting for %ld millisecs"),
                 GetTickCount() - dwStart);
        switch (dwRes)
        {
            case WAIT_FAILED:
                dwRes = dwRes2;
                if (ERROR_INVALID_HANDLE == dwRes)
                {
                    //
                    // The thread is dead
                    //
                    VERBOSE (DBG_MSG, TEXT("Thread is dead (ERROR_INVALID_HANDLE)"));
                    dwRes = ERROR_SUCCESS;
                }
                goto exit;

            case WAIT_OBJECT_0:
                //
                // The thread is not running
                //
                VERBOSE (DBG_MSG, TEXT("Thread is dead (WAIT_OBJECT_0)"));
                dwRes = ERROR_SUCCESS;
                goto exit;

            case WAIT_OBJECT_0 + 1:
                //
                // Shutdown is now in progress
                //
                VERBOSE (DBG_MSG, TEXT("Shutdown in progress"));
                dwRes = ERROR_SUCCESS;
                goto exit;

            case WAIT_OBJECT_0 + 2:
                //
                // System message (WM_xxx) in our queue
                //
                MSG msg;
                
                if (TRUE == ::GetMessage (&msg, NULL, NULL, NULL))
                {
                    VERBOSE (DBG_MSG, 
                             TEXT("System message (0x%x)- deferring to AfxWndProc"),
                             msg.message);

                    CMainFrame *pFrm = GetFrm();
                    if (!pFrm)
                    {
                        //
                        //  Shutdown in progress
                        //
                        goto exit;
                    }

                    if (msg.message != WM_KICKIDLE && 
                        !pFrm->PreTranslateMessage(&msg))
                    {
                        ::TranslateMessage(&msg);
                        ::DispatchMessage(&msg);
                    }
                }
                else
                {
                    //
                    // Got WM_QUIT
                    //
                    AfxPostQuitMessage (0);
                    dwRes = ERROR_SUCCESS;
                    goto exit;
                }
                break;

            case WAIT_TIMEOUT:
                //
                // Thread won't die !!!
                //
                VERBOSE (DBG_MSG, 
                         TEXT("Wait timeout (%ld millisecs)"), 
                         BUILD_THREAD_DEATH_TIMEOUT);
                goto exit;

            default:
                //
                // What's this???
                //
                VERBOSE (DBG_MSG, 
                         TEXT("Unknown error (%ld)"), 
                         dwRes);
                ASSERTION_FAILURE;
                goto exit;
        }
    }
exit:
    return dwRes;
}   // WaitForThreadDeathOrShutdown

DWORD 
GetUniqueFileName (
    LPCTSTR lpctstrExt,
    CString &cstrResult
)
/*++

Routine name : GetUniqueFileName

Routine description:

    Generates a unique file name

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    lpctstrExt   [in]     - File extension
    cstrResult   [out]    - Result file name

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("GetUniqueFileName"), dwRes);

    TCHAR szDir[MAX_PATH];
    //
    // Get path to temp dir
    //
    if (!GetTempPath (MAX_PATH, szDir))
    {
        dwRes = GetLastError ();
        CALL_FAIL (FILE_ERR, TEXT("GetTempPath"), dwRes);
        return dwRes;
    }
    //
    // Try out indices - start with a random index and advance (cyclic) by 1.
    // We're calling rand() 3 times here because we want to get a larger
    // range than 0..RAND_MAX (=32768)
    //
    DWORD dwStartIndex = DWORD((DWORDLONG)(rand()) * 
                                (DWORDLONG)(rand()) * 
                                (DWORDLONG)(rand())
                              );
    for (DWORD dwIndex = dwStartIndex+1; dwIndex != dwStartIndex; dwIndex++)
    {
        try
        {
            cstrResult.Format (TEXT("%s%s%08x%08x.%s"),
                               szDir,
                               CONSOLE_PREVIEW_TIFF_PREFIX,
                               GetCurrentProcessId(),
                               dwIndex,
                               lpctstrExt);
        }
        catch (CMemoryException *pException)
        {
            TCHAR wszCause[1024];

            pException->GetErrorMessage (wszCause, 1024);
            pException->Delete ();
            VERBOSE (EXCEPTION_ERR,
                     TEXT("CString::Format caused exception : %s"), 
                     wszCause);
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            return dwRes;
        }
        HANDLE hFile = CreateFile(  cstrResult,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_NEW,
                                    FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_TEMPORARY,
                                    NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            dwRes = GetLastError ();
            if (ERROR_FILE_EXISTS == dwRes)
            {
                //
                // Try next index id
                //
                dwRes = ERROR_SUCCESS;
                continue;
            }
            CALL_FAIL (FILE_ERR, TEXT("CreateFile"), dwRes);
            return dwRes;
        }
        //
        // Success - close the file (leave it with size 0)
        //
        CloseHandle (hFile);
        return dwRes;
    }
    //
    // We just scanned 4GB file names and all were busy - impossible.
    //
    ASSERTION_FAILURE;
    dwRes = ERROR_GEN_FAILURE;
    return dwRes;
}   // GetUniqueFileName

DWORD 
CopyTiffFromServer (
    CServerNode *pServer,
    DWORDLONG dwlMsgId, 
    FAX_ENUM_MESSAGE_FOLDER Folder,
    CString &cstrTiff
)
/*++

Routine name : CopyTiffFromServer

Routine description:

    Copies a TIFF file from the server's archive / queue

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pServer       [in]     - Pointer to the server node
    dwlMsgId      [in]     - Id of job / message
    Folder        [in]     - Folder of message / job
    cstrTiff      [out]    - Name of TIFF file that arrived from the server

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CopyTiffFromServer"), dwRes);

    //
    // Create a temporary file name for the TIFF
    //
    dwRes = GetUniqueFileName (FAX_TIF_FILE_EXT, cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("GetUniqueFileName"), dwRes);
        return dwRes;
    }
    HANDLE hFax;
    dwRes = pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::GetConnectionHandle"), dwRes);
        goto exit;
    }
    {
        START_RPC_TIME(TEXT("FaxGetMessageTiff")); 
        if (!FaxGetMessageTiff (hFax,
                                dwlMsgId,
                                Folder,
                                cstrTiff))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxGetMessageTiff")); 
            pServer->SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxGetMessageTiff"), dwRes);
            goto exit;
        }
        END_RPC_TIME(TEXT("FaxGetMessageTiff")); 
    }

    ASSERTION (ERROR_SUCCESS == dwRes);    

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        DeleteFile (cstrTiff);
    }
    return dwRes;
}   // CopyTiffFromServer

DWORD 
GetDllVersion (
    LPCTSTR lpszDllName
)
/*++

Routine Description:
    Returns the version information for a DLL exporting "DllGetVersion".
    DllGetVersion is exported by the shell DLLs (specifically COMCTRL32.DLL).
      
Arguments:

    lpszDllName - The name of the DLL to get version information from.

Return Value:

    The version is retuned as DWORD where:
    HIWORD ( version DWORD  ) = Major Version
    LOWORD ( version DWORD  ) = Minor Version
    Use the macro PACKVERSION to comapre versions.
    If the DLL does not export "DllGetVersion" the function returns 0.
    
--*/
{
    DWORD dwVersion = 0;
    DBG_ENTER(TEXT("GetDllVersion"), dwVersion, TEXT("%s"), lpszDllName);

    HINSTANCE hinstDll;

    hinstDll = LoadLibrary(lpszDllName);
	
    if(hinstDll)
    {
        DLLGETVERSIONPROC pDllGetVersion;
        pDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hinstDll, "DllGetVersion");
        // Because some DLLs may not implement this function, you
        // must test for it explicitly. Depending on the particular 
        // DLL, the lack of a DllGetVersion function may
        // be a useful indicator of the version.
        if(pDllGetVersion)
        {
            DLLVERSIONINFO dvi;
            HRESULT hr;

            ZeroMemory(&dvi, sizeof(dvi));
            dvi.cbSize = sizeof(dvi);

            hr = (*pDllGetVersion)(&dvi);

            if(SUCCEEDED(hr))
            {
                dwVersion = PACKVERSION(dvi.dwMajorVersion, dvi.dwMinorVersion);
            }
        }
        FreeLibrary(hinstDll);
    }
    return dwVersion;
}   // GetDllVersion


DWORD 
ReadRegistryString(
    LPCTSTR lpszSection, // in
    LPCTSTR lpszKey,     // in
    CString& cstrValue   // out
)
/*++

Routine name : ReadRegistryString

Routine description:

	read string from registry

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:

	lpszSection                   [in]     - section
	lpszKey                       [in]     - key
	out                           [out]    - value

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("ReadRegistryString"), dwRes);

    HKEY hKey;
    dwRes = RegOpenKeyEx( HKEY_CURRENT_USER, lpszSection, 0, KEY_QUERY_VALUE, &hKey);
    if(ERROR_SUCCESS != dwRes)
    {
       CALL_FAIL (GENERAL_ERR, TEXT("RegOpenKeyEx"), dwRes);
       return dwRes;
    }

    DWORD dwType;
    TCHAR  tchData[1024];
    DWORD dwDataSize = sizeof(tchData);
    dwRes = RegQueryValueEx( hKey, lpszKey, 0, &dwType, (BYTE*)tchData, &dwDataSize);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("RegQueryValueEx"), dwRes);
        goto exit;
    }

    if(REG_SZ != dwType)
    {
        dwRes = ERROR_BADDB;
        goto exit;
    }

    try
    {
        cstrValue = tchData;
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::operator="), dwRes);
        goto exit;
    }

exit:
    dwRes = RegCloseKey( hKey );
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("RegCloseKey"), dwRes);
        return dwRes;
    }

    return dwRes;

} // ReadRegistryString

DWORD 
WriteRegistryString(
    LPCTSTR lpszSection, // in
    LPCTSTR lpszKey,     // in
    CString& cstrValue   // in
)
/*++

Routine name : WriteRegistryString

Routine description:

	write string to the regostry

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:

	lpszSection                   [in]     - section
	lpszKey                       [in]     - key
	out                           [in]     - value

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("WriteRegistryString"), dwRes);

    HKEY hKey;
    dwRes = RegOpenKeyEx( HKEY_CURRENT_USER, lpszSection, 0, KEY_SET_VALUE, &hKey);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("RegOpenKeyEx"), dwRes);
        return dwRes;
    }

    LPCTSTR lpData = (LPCTSTR)cstrValue;
    dwRes = RegSetValueEx( hKey, 
                           lpszKey, 
                           0, 
                           REG_SZ, 
                           (BYTE*)lpData, 
                           (1 + cstrValue.GetLength()) * sizeof (TCHAR));
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("RegSetValueEx"), dwRes);
        goto exit;
    }

exit:
    dwRes = RegCloseKey( hKey );
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("RegCloseKey"), dwRes);
        return dwRes;
    }

    return dwRes;

} // WriteRegistryString


DWORD 
FaxSizeFormat(
    DWORDLONG dwlSize, // in
    CString& cstrValue // out
)
/*++

Routine name : FaxSizeFormat

Routine description:

	format string of file size

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:

	wdlSize                       [in]     - size
	out                           [out]    - formatted string

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("FaxSizeFormat"), dwRes);

	if(dwlSize > 0 && dwlSize < 1024)
	{
		dwlSize = 1;
	}
	else
	{
		dwlSize = dwlSize / (DWORDLONG)1024;
	}

    try
    {
        cstrValue.Format (TEXT("%I64d"), dwlSize);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
        return dwRes;
    }

    //
    // format the number
    //
    int nFormatRes;
    TCHAR tszNumber[100];
    nFormatRes = GetNumberFormat(LOCALE_USER_DEFAULT,  // locale
                                 0,                    // options
                                 cstrValue,            // input number string
                                 NULL,                 // formatting information
                                 tszNumber,            // output buffer
                                 sizeof(tszNumber) / sizeof(tszNumber[0]) // size of output buffer
                                );
    if(0 == nFormatRes)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetNumberFormat"), dwRes);
        return dwRes;
    }

    //
    // get decimal separator
    //
    TCHAR tszDec[10];
    nFormatRes = GetLocaleInfo(LOCALE_USER_DEFAULT,      // locale identifier
                               LOCALE_SDECIMAL,          // information type
                               tszDec,                   // information buffer
                               sizeof(tszDec) / sizeof(tszDec[0]) // size of buffer
                              );
    if(0 == nFormatRes)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetLocaleInfo"), dwRes);
        return dwRes;
    }

    //
    // cut the string on the decimal separator
    //
    TCHAR* pSeparator = _tcsstr(tszNumber, tszDec);
    if(NULL != pSeparator)
    {
        *pSeparator = TEXT('\0');
    }

    try
    {
        TCHAR szFormat[64] = {0}; 
#ifdef UNICODE
        if(theApp.IsRTLUI())
        {
            //
            // Size field always should be LTR
            // Add LEFT-TO-RIGHT OVERRIDE  (LRO)
            //
            szFormat[0] = UNICODE_LRO;
        }
#endif
        _tcscat(szFormat, TEXT("%s KB"));

        cstrValue.Format (szFormat, tszNumber);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
        return dwRes;
    }
    
    return dwRes;

} // FaxSizeFormat


DWORD 
HtmlHelpTopic(
    HWND hWnd, 
    TCHAR* tszHelpTopic
)
/*++

Routine name : HtmlHelpTopic

Routine description:

	open HTML Help topic

Author:

	Alexander Malysh (AlexMay),	Mar, 2000

Arguments:

	hWnd                          [in]     - window handler
	tszHelpTopic                  [in]     - help topic

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("HtmlHelpTopic"), dwRes);

    if(!tszHelpTopic)
    {
        ASSERTION_FAILURE;
        return ERROR_INVALID_PARAMETER;
    }

    //
    // get help file name
    //
    TCHAR tszHelpFile[2 * MAX_PATH] = {0};

    _sntprintf(tszHelpFile, 
               ARR_SIZE(tszHelpFile) - 1, 
               TEXT("%s.%s%s"), 
               theApp.m_pszExeName,  // application name (FxsClnt)
               FAX_HTML_HELP_EXT,    // help file extension (CHM)
               tszHelpTopic);        // help topic

    SetLastError(0);
    HtmlHelp(NULL, tszHelpFile, HH_DISPLAY_TOPIC, NULL);

    dwRes = GetLastError();    
    if(ERROR_DLL_NOT_FOUND == dwRes || 
       ERROR_MOD_NOT_FOUND == dwRes ||
       ERROR_PROC_NOT_FOUND == dwRes) 
    {
        AlignedAfxMessageBox(IDS_ERR_NO_HTML_HELP);
    }

    return dwRes;
}


DWORD 
GetAppLoadPath(
    CString& cstrLoadPath
)
/*++

Routine name : GetAppLoadPath

Routine description:

	The directory from which the application loaded

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:

	cstrLoadPath                  [out]    - the directory

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("GetAppLoadPath"), dwRes);

    TCHAR tszFullPath[MAX_PATH+1]={0};
    DWORD dwGetRes = GetModuleFileName(NULL, tszFullPath, ARR_SIZE(tszFullPath)-1);
    if(0 == dwGetRes)
    {
        dwRes = GetLastError();
        CALL_FAIL (FILE_ERR, TEXT("GetModuleFileName"), dwRes);
        return dwRes;
    }

    //
    // cut file name
    //
    TCHAR* ptchFile = _tcsrchr(tszFullPath, TEXT('\\'));
    ASSERTION(ptchFile);

    ptchFile = _tcsinc(ptchFile);
    *ptchFile = TEXT('\0');

    try
    {
        cstrLoadPath = tszFullPath;
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::operator="), dwRes);
        return dwRes;
    }

    return dwRes;
} // GetAppLoadPath


DWORD
GetPrintersInfo(
    PRINTER_INFO_2*& pPrinterInfo2,
    DWORD& dwNumPrinters
)
/*++

Routine name : GetPrintersInfo

Routine description:

	enumerate printers and get printers info

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:

	pPrinterInfo2                 [out]    - printer info structure array
	dwNumPrinters                 [out]    - number of printers

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("GetPrintersInfo"), dwRes);

    //
    // First call, just collect required sizes
    //
    DWORD dwRequiredSize;
    if (!EnumPrinters ( PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                        NULL,   // Local server
                        2,      // Info level
                        NULL,   // Initial buffer
                        0,      // Initial buffer size
                        &dwRequiredSize,
                        &dwNumPrinters))
    {
        DWORD dwEnumRes = GetLastError ();
        if (ERROR_INSUFFICIENT_BUFFER != dwEnumRes)
        {
            dwRes = dwEnumRes;
            CALL_FAIL (RESOURCE_ERR, TEXT("EnumPrinters"), dwRes);
            return dwRes;
        }
    }
    //
    // Allocate buffer for printers list
    //
    try
    {
        pPrinterInfo2 = (PRINTER_INFO_2 *) new BYTE[dwRequiredSize];
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY; 
        CALL_FAIL (MEM_ERR, TEXT("new BYTE[dwRequiredSize]"), dwRes);
        return dwRes;
    }
    //
    // 2nd call, get the printers list
    //
    if (!EnumPrinters ( PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                        NULL,                       // Local server
                        2,                          // Info level
                        (LPBYTE)pPrinterInfo2,      // Buffer
                        dwRequiredSize,             // Buffer size
                        &dwRequiredSize,
                        &dwNumPrinters))
    {
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("EnumPrinters"), dwRes);
        SAFE_DELETE_ARRAY (pPrinterInfo2);
        return dwRes;
    }

    if (!dwNumPrinters) 
    {
        VERBOSE(DBG_MSG, TEXT("No printers in this machine"));
    }

    return dwRes;

} // GetPrintersInfo

UINT_PTR 
CALLBACK 
OFNHookProc(
  HWND hdlg,      // handle to child dialog box
  UINT uiMsg,     // message identifier
  WPARAM wParam,  // message parameter
  LPARAM lParam   // message parameter
)
/*++

Routine name : OFNHookProc

Routine description:

    Callback function that is used with the 
    Explorer-style Open and Save As dialog boxes.
    Refer MSDN for more info.

--*/
{
    UINT_PTR nRes = 0;

    if(WM_NOTIFY == uiMsg)
    {
        LPOFNOTIFY pOfNotify = (LPOFNOTIFY)lParam;
        if(CDN_FILEOK == pOfNotify->hdr.code)
        {
            if(_tcslen(pOfNotify->lpOFN->lpstrFile) > (MAX_PATH-10))
            {
                AlignedAfxMessageBox(IDS_SAVE_AS_TOO_LONG, MB_OK | MB_ICONEXCLAMATION);
                SetWindowLong(hdlg, DWLP_MSGRESULT, 1);
                nRes = 1;
            }
        }
    }
    return nRes;
}

int 
AlignedAfxMessageBox( 
    LPCTSTR lpszText, 
    UINT    nType, 
    UINT    nIDHelp
)
/*++

Routine name : AlignedAfxMessageBox

Routine description:

    Display message box with correct reading order

Arguments:

    AfxMessageBox() arguments

Return Value:

    MessageBox() result

--*/
{
    if(IsRTLUILanguage())
    {
        nType |= MB_RTLREADING | MB_RIGHT; 
    }

    return AfxMessageBox(lpszText, nType, nIDHelp);
}

int 
AlignedAfxMessageBox( 
    UINT nIDPrompt, 
    UINT nType, 
    UINT nIDHelp
)
/*++

Routine name : AlignedAfxMessageBox

Routine description:

    Display message box with correct reading order

Arguments:

    AfxMessageBox() arguments

Return Value:

    MessageBox() result

--*/
{
    if(IsRTLUILanguage())
    {
        nType |= MB_RTLREADING | MB_RIGHT;
    }

    return AfxMessageBox(nIDPrompt, nType, nIDHelp);
}

HINSTANCE 
GetResourceHandle()
{
    return GetResInst(FAX_CONSOLE_RESOURCE_DLL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxactivity.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxActivity.cpp

Abstract:

	Implementation of CFaxActivity Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxActivity.h"

//
//========================= QUEUED MESSAGES =============================
//
STDMETHODIMP 
CFaxActivity::get_QueuedMessages(
    long *plQueuedMessages
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivity::get_QueuedMessages"), hr);
    hr = GetNumberOfMessages(mtQUEUED, plQueuedMessages);
	return hr;
}

//
//========================= OUTGOING MESSAGES =============================
//
STDMETHODIMP 
CFaxActivity::get_OutgoingMessages(
    long *plOutgoingMessages
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivity::get_OutgoingMessages"), hr);
    hr = GetNumberOfMessages(mtOUTGOING, plOutgoingMessages);
	return hr;
}

//
//========================= ROUTING MESSAGES =============================
//
STDMETHODIMP 
CFaxActivity::get_RoutingMessages(
    long *plRoutingMessages
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivity::get_RoutingMessages"), hr);
    hr = GetNumberOfMessages(mtROUTING, plRoutingMessages);
	return hr;
}

//
//========================= INCOMING MESSAGES =============================
//
STDMETHODIMP 
CFaxActivity::get_IncomingMessages(
    long *plIncomingMessages
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivity::get_IncomingMessages"), hr);
    hr = GetNumberOfMessages(mtINCOMING, plIncomingMessages);
	return hr;
}

//
//=================== GET NUMBER OF MESSAGES ===================================
//
STDMETHODIMP
CFaxActivity::GetNumberOfMessages(
    MSG_TYPE msgType,
    long * plNumber
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivity::GetNumberOfMessages"), hr);

    //
    //  check that we have got good ptr
    //
    if (::IsBadWritePtr(plNumber, sizeof(long)))
    {
        hr = E_POINTER;
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(plNumber, sizeof(long))"), hr);
        AtlReportError(CLSID_FaxActivity, 
            IDS_ERROR_INVALID_ARGUMENT, 
            IID_IFaxActivity, 
            hr);
        return hr;
    }

    //
    //  Bring data from Server in the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    switch(msgType)
    {
    case mtINCOMING:
        *plNumber = m_ServerActivity.dwIncomingMessages;
        break;
    case mtROUTING:
        *plNumber = m_ServerActivity.dwRoutingMessages;
        break;
    case mtOUTGOING:
        *plNumber = m_ServerActivity.dwOutgoingMessages;
        break;
    case mtQUEUED:
        *plNumber = m_ServerActivity.dwQueuedMessages;
        break;
    default:
        //
        //  ASSERT(FALSE)
        //
        ATLASSERT(msgType == mtQUEUED);     
        break;
    }

    return hr;
}

//
//========================= REFRESH ============================================
//
STDMETHODIMP 
CFaxActivity::Refresh()
/*++

Routine name : CFaxActivity::Refresh

Routine description:

	Refresh the contents of the object : bring new data from the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivity::Refresh"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxActivity, 
            GetErrorMsgId(hr), 
            IID_IFaxActivity, 
            hr);
        return hr;
    }


    //
    //  Ask from Server new Activity data
    //
    if (!FaxGetServerActivity(hFaxHandle, &m_ServerActivity))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxActivity, 
            GetErrorMsgId(hr), 
            IID_IFaxActivity, 
            hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxGetServerActivity(hFaxHandle, &ServerActivity)"), hr);
        return hr;
    }

    m_bInited = true;
	return hr;
}

//
//======================= SUPPORT ERROR INFO ==================================
//
STDMETHODIMP 
CFaxActivity::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxActivity::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - reference to the ifc to check.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxActivity
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxactivity.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxActivity.h

Abstract:

	Declaration of the CFaxActivity Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXACTIVITY_H_
#define __FAXACTIVITY_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"


// 
//==================== ACTIVITY ==========================================
//
class ATL_NO_VTABLE CFaxActivity : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxActivity, &IID_IFaxActivity, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxActivity() : CFaxInitInner(_T("FAX ACTIVITY")),
        m_bInited(false)
	{
        m_ServerActivity.dwSizeOfStruct = sizeof(FAX_SERVER_ACTIVITY);
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXACTIVITY)
DECLARE_NOT_AGGREGATABLE(CFaxActivity)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxActivity)
	COM_INTERFACE_ENTRY(IFaxActivity)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	STDMETHOD(Refresh)();

	STDMETHOD(get_QueuedMessages)(/*[out, retval]*/ long *plQueuedMessages);
	STDMETHOD(get_RoutingMessages)(/*[out, retval]*/ long *plRoutingMessages);
	STDMETHOD(get_IncomingMessages)(/*[out, retval]*/ long *plIncomingMessages);
	STDMETHOD(get_OutgoingMessages)(/*[out, retval]*/ long *plOutgoingMessages);

private:
    typedef enum MSG_TYPE { mtINCOMING, mtROUTING, mtOUTGOING, mtQUEUED } MSG_TYPE;

    bool                    m_bInited;
    FAX_SERVER_ACTIVITY     m_ServerActivity;

    STDMETHOD(GetNumberOfMessages)(MSG_TYPE msgType, long *plNumber);
};

#endif //__FAXACTIVITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxactivitylogging.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxActivityLogging.h

Abstract:

	Declaration of the CFaxActivityLogging Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXACTIVITYLOGGING_H_
#define __FAXACTIVITYLOGGING_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//================ FAX ACTIVITY LOGGING =================================================
//
class ATL_NO_VTABLE CFaxActivityLogging : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxActivityLogging, &IID_IFaxActivityLogging, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxActivityLogging() : CFaxInitInner(_T("FAX ACTIVITY LOGGING")), m_bInited(false)
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXACTIVITYLOGGING)
DECLARE_NOT_AGGREGATABLE(CFaxActivityLogging)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxActivityLogging)
	COM_INTERFACE_ENTRY(IFaxActivityLogging)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_LogIncoming)(/*[out, retval]*/ VARIANT_BOOL *pbLogIncoming);
    STDMETHOD(put_LogIncoming)(/*[out, retval]*/ VARIANT_BOOL bLogIncoming);
    STDMETHOD(get_LogOutgoing)(/*[out, retval]*/ VARIANT_BOOL *pbLogOutgoing);
    STDMETHOD(put_LogOutgoing)(/*[out, retval]*/ VARIANT_BOOL bLogOutgoing);
    STDMETHOD(get_DatabasePath)(/*[out, retval]*/ BSTR *pbstrDatabasePath);
    STDMETHOD(put_DatabasePath)(/*[out, retval]*/ BSTR bstrDatabasePath);

    STDMETHOD(Refresh)();
    STDMETHOD(Save)();

private:
    VARIANT_BOOL    m_bLogIncoming;
    VARIANT_BOOL    m_bLogOutgoing;
    CComBSTR        m_bstrDatabasePath;
    bool            m_bInited;
};

#endif //__FAXACTIVITYLOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxactivitylogging.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxActivityLogging.cpp

Abstract:

	Implementation of Activity Logging Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxActivityLogging.h"

//
//==================== SAVE ========================================
//
STDMETHODIMP
CFaxActivityLogging::Save(
)
/*++

Routine name : CFaxActivityLogging::Save

Routine description:

	Save current Activity Logging Configuration to the Server.

Author:

	Iv Garber (IvG),	June, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxActivityLogging::Save"), hr);

    if (!m_bInited)
    {
        //
        //  nothing was done to the Configuration
        //
        return hr;
    }

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxActivityLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxActivityLogging, 
            hr);
        return hr;
    }

    //
    //  Create Activity Logging Configuration
    //

    FAX_ACTIVITY_LOGGING_CONFIG    alConfig;
    alConfig.dwSizeOfStruct = sizeof(FAX_ACTIVITY_LOGGING_CONFIG);
    alConfig.bLogIncoming = VARIANT_BOOL2bool(m_bLogIncoming);
    alConfig.bLogOutgoing = VARIANT_BOOL2bool(m_bLogOutgoing);
    alConfig.lptstrDBPath = m_bstrDatabasePath;

    //
    //  Ask the Server to set the Activity Configuration
    //
    if (!FaxSetActivityLoggingConfiguration(hFaxHandle, &alConfig))
    {
        //
        //  Failed to set the Configuration to the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxActivityLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxActivityLogging, 
            hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxSetActivityLoggingConfiguration()"), hr);
        return hr;
    }

    return hr;
}

//
//==================== REFRESH ========================================
//
STDMETHODIMP
CFaxActivityLogging::Refresh(
)
/*++

Routine name : CFaxActivityLogging::Refresh

Routine description:

	Bring new Activity Logging cofiguration from the Server.

Author:

	Iv Garber (IvG),	June, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxActivityLogging::Refresh"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxActivityLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxActivityLogging, 
            hr);
        return hr;
    }

    //
    //  Ask the Server for the Mail Configuration
    //
    CFaxPtr<FAX_ACTIVITY_LOGGING_CONFIG>    pConfig;
    if (!FaxGetActivityLoggingConfiguration(hFaxHandle, &pConfig))
    {
        //
        //  Failed to get the Configuration from the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxActivityLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxActivityLogging, 
            hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxGetActivityLoggingConfiguration()"), hr);
        return hr;
    }

    //  
    //  Check that pConfig is valid
    //
    if (!pConfig || pConfig->dwSizeOfStruct != sizeof(FAX_ACTIVITY_LOGGING_CONFIG))
    {
        hr = E_FAIL;
        AtlReportError(CLSID_FaxActivityLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxActivityLogging, 
            hr);
        CALL_FAIL(GENERAL_ERR, _T("(!pConfig || SizeOfStruct != sizeof(FAX_ACTIVITY_LOGGING_CONFIG))"), hr);
        return hr;
    }

    m_bLogIncoming = bool2VARIANT_BOOL(pConfig->bLogIncoming);
    m_bLogOutgoing = bool2VARIANT_BOOL(pConfig->bLogOutgoing);

    m_bstrDatabasePath = pConfig->lptstrDBPath;
    if ( (pConfig->lptstrDBPath) && !m_bstrDatabasePath )
    {
		//
		//	Failed to Copy
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxActivityLogging, 
            IDS_ERROR_OUTOFMEMORY, 
            IID_IFaxActivityLogging, 
            hr);
		CALL_FAIL(MEM_ERR, _T("::SysAllocString()"), hr);
		return hr;
    }

    m_bInited = true;
    return hr;
}

//
//============================= DATABASE PATH ====================================
//
STDMETHODIMP 
CFaxActivityLogging::put_DatabasePath(
	BSTR bstrDatabasePath
)
/*++

Routine name : CFaxActivityLogging::put_DatabasePath

Routine description:

	Set the Database Path

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	bstrDatabasePath              [in]    - the new value of Database Path

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxActivityLogging::put_DatabasePath"), hr, _T("%s"), bstrDatabasePath);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bstrDatabasePath = bstrDatabasePath;
	if (bstrDatabasePath && !m_bstrDatabasePath)
	{
		//	
		//	not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxActivityLogging, 
            IDS_ERROR_OUTOFMEMORY, 
            IID_IFaxActivityLogging, 
            hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
		return hr;
	}
    return hr;
}

STDMETHODIMP 
CFaxActivityLogging::get_DatabasePath(
	BSTR *pbstrDatabasePath
)
/*++

Routine name : CFaxActivityLogging::get_DatabasePath

Routine description:

	Return current Database Path

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	pbstrDatabasePath                    [out]    - the current Database Path

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxActivityLogging::get_DatabasePath"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetBstr(pbstrDatabasePath, m_bstrDatabasePath);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxActivityLogging, GetErrorMsgId(hr), IID_IFaxActivityLogging, hr);
        return hr;
    }

	return hr;
}

//
//===================== LOG OUTGOING ======================================
//
STDMETHODIMP
CFaxActivityLogging::get_LogOutgoing(
    VARIANT_BOOL *pbLogOutgoing
)
/*++

Routine name : CFaxActivityLogging::get_LogOutgoing

Routine description:

	Return Log Incoming value

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbLogOutgoing                 [out]    - the value of the Log Incoming to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivityLogging::get_LogOutgoing"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbLogOutgoing, m_bLogOutgoing);
    if (FAILED(hr))
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxActivityLogging, GetErrorMsgId(hr), IID_IFaxActivityLogging, hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP
CFaxActivityLogging::put_LogOutgoing(
    VARIANT_BOOL bLogOutgoing
)
/*++

Routine name : CFaxActivityLogging::put_LogOutgoing

Routine description:

	Set new Log Incoming value

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	bLogOutgoing                 [in]    - the value of the Log Incoming to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivityLogging::put_LogOutgoing"), hr, _T("Log Incoming : %d"), bLogOutgoing);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bLogOutgoing = bLogOutgoing;
    return hr;
}

//
//===================== LOG INCOMING ======================================
//
STDMETHODIMP
CFaxActivityLogging::get_LogIncoming(
    VARIANT_BOOL *pbLogIncoming
)
/*++

Routine name : CFaxActivityLogging::get_LogIncoming

Routine description:

	Return Log Incoming value

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbLogIncoming                 [out]    - the value of the Log Incoming to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivityLogging::get_LogIncoming"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbLogIncoming, m_bLogIncoming);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxActivityLogging, GetErrorMsgId(hr), IID_IFaxActivityLogging, hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP
CFaxActivityLogging::put_LogIncoming(
    VARIANT_BOOL bLogIncoming
)
/*++

Routine name : CFaxActivityLogging::put_LogIncoming

Routine description:

	Set new Log Incoming value

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	bLogIncoming                 [in]    - the value of the Log Incoming to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivityLogging::put_LogIncoming"), hr, _T("Log Incoming : %d"), bLogIncoming);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bLogIncoming = bLogIncoming;
    return hr;
}

//
//================ SUPPORT ERROR INFO ====================================
//
STDMETHODIMP 
CFaxActivityLogging::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxActivityLogging::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the IID

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxActivityLogging
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxcomex.cpp ===
// FaxComEx.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f FaxComExps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "FaxComEx.h"
#include "FaxComEx_i.c"

#include "FaxSender.h"
#include "FaxDevice.h"
#include "FaxServer.h"
#include "FaxDevices.h"
#include "FaxFolders.h"
#include "FaxActivity.h"
#include "FaxSecurity.h"
#include "FaxDocument.h"
#include "FaxRecipient.h"
#include "FaxDeviceIds.h"
#include "FaxRecipients.h"
#include "FaxIncomingJob.h"
#include "FaxOutgoingJob.h"
#include "FaxIncomingJobs.h"
#include "FaxOutgoingJobs.h"
#include "FaxEventLogging.h"
#include "FaxOutgoingQueue.h"
#include "FaxIncomingQueue.h"
#include "FaxInboundRouting.h"
#include "FaxLoggingOptions.h"
#include "FaxReceiptOptions.h"
#include "FaxDeviceProvider.h"
#include "FaxIncomingMessage.h"
#include "FaxIncomingArchive.h"
#include "FaxOutgoingArchive.h"
#include "FaxOutgoingMessage.h"
#include "FaxOutboundRouting.h"
#include "FaxDeviceProviders.h"
#include "FaxActivityLogging.h"
#include "FaxOutboundRoutingRule.h"
#include "FaxOutboundRoutingRules.h"
#include "FaxOutboundRoutingGroup.h"
#include "FaxInboundRoutingMethod.h"
#include "FaxInboundRoutingMethods.h"
#include "FaxOutboundRoutingGroups.h"
#include "FaxIncomingMessageIterator.h"
#include "FaxOutgoingMessageIterator.h"
#include "FaxInboundRoutingExtension.h"
#include "FaxInboundRoutingExtensions.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_FaxDocument, CFaxDocument)
OBJECT_ENTRY(CLSID_FaxServer, CFaxServer)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_FAXCOMEXLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxarchiveinner.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    faxarchiveinner.h

Abstract:

    Declaration and Implementation of Fax Archive Inner Template Class.

Author:

    Iv Garber (IvG) May, 2000

Revision History:

--*/

#ifndef __FAXARCHIVEINNER_H_
#define __FAXARCHIVEINNER_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"


//
//================ FAX ARCHIVE INNER =========================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
class CFaxArchiveInner : 
    public IDispatchImpl<T, piid, &LIBID_FAXCOMEXLib>, 
    public CFaxInitInner
{
public:
    CFaxArchiveInner() : CFaxInitInner(_T("FAX ARCHIVE INNER"))
    {
        m_bInitialized = FALSE;
    }

    virtual ~CFaxArchiveInner() 
    {};

    STDMETHOD(get_SizeLow)(/*[out, retval]*/ long *plSizeLow);  
    STDMETHOD(get_SizeHigh)(/*[out, retval]*/ long *plSizeHigh);
    STDMETHOD(get_UseArchive)(/*[out, retval]*/ VARIANT_BOOL *pbUseArchive);
    STDMETHOD(put_UseArchive)(/*[in]*/ VARIANT_BOOL bUseArchive);
    STDMETHOD(get_ArchiveFolder)(BSTR *pbstrArchiveFolder);
    STDMETHOD(put_ArchiveFolder)(BSTR bstrArchiveFolder);
    STDMETHOD(get_SizeQuotaWarning)(VARIANT_BOOL *pbSizeQuotaWarning);
    STDMETHOD(put_SizeQuotaWarning)(VARIANT_BOOL bSizeQuotaWarning);
    STDMETHOD(get_HighQuotaWaterMark)(long *plHighQuotaWaterMark);
    STDMETHOD(put_HighQuotaWaterMark)(long lHighQuotaWaterMark);
    STDMETHOD(get_LowQuotaWaterMark)(long *plLowQuotaWaterMark);
    STDMETHOD(put_LowQuotaWaterMark)(long lLowQuotaWaterMark);
    STDMETHOD(get_AgeLimit)(long *plAgeLimit);
    STDMETHOD(put_AgeLimit)(long lAgeLimit);
    STDMETHOD(Refresh)();
    STDMETHOD(Save)();
    STDMETHOD(GetMessage)(BSTR bstrMessageId, MsgIfc **ppFaxMessage);
    STDMETHOD(GetMessages)(long lPrefetchSize, IteratorIfc **ppFaxMessageIterator);

private:
    bool            m_bInitialized;

    VARIANT_BOOL    m_bUseArchive;
    CComBSTR        m_bstrArchiveFolder;
    VARIANT_BOOL    m_bSizeQuotaWarning;
    long            m_lHighQuotaWaterMark;
    long            m_lLowQuotaWaterMark;
    long            m_lAgeLimit;
    ULARGE_INTEGER  m_uliSize;
};

//
//========================= REFRESH ====================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::Refresh(
)
/*++

Routine name : CFaxArchiveInner::Refresh

Routine description:

    Retrieve Current Configuration of the Incoming / Outgoing Archive on Fax Server

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxArchiveInner::Refresh"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    CFaxPtr<FAX_ARCHIVE_CONFIG>     pFaxArchiveConfig;
    if ( 0 == ::FaxGetArchiveConfiguration(hFaxHandle, ArchiveType, &pFaxArchiveConfig))
    {
        //
        //  Failed to Get Archive Configuration
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::FaxGetArchiveConfiguration()"), hr);
        return hr;
    }

    if (!pFaxArchiveConfig || pFaxArchiveConfig->dwSizeOfStruct != sizeof(FAX_ARCHIVE_CONFIG))
    {
        //
        //  Failed to Get Archive Configuration
        //
        hr = E_FAIL;
        AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("Invalid pFaxArchiveConfig"), hr);
        return hr;
    }

    m_bUseArchive = bool2VARIANT_BOOL(pFaxArchiveConfig->bUseArchive);
    m_bSizeQuotaWarning = bool2VARIANT_BOOL(pFaxArchiveConfig->bSizeQuotaWarning);
    m_lHighQuotaWaterMark = pFaxArchiveConfig->dwSizeQuotaHighWatermark;
    m_lLowQuotaWaterMark = pFaxArchiveConfig->dwSizeQuotaLowWatermark;
    m_lAgeLimit = pFaxArchiveConfig->dwAgeLimit;
    m_uliSize.QuadPart = pFaxArchiveConfig->dwlArchiveSize;

    m_bstrArchiveFolder = pFaxArchiveConfig->lpcstrFolder;
    if (!m_bstrArchiveFolder && pFaxArchiveConfig->lpcstrFolder) 
    {
        hr = E_OUTOFMEMORY;
        AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR& operator=()"), hr);
        return hr;
    }

    m_bInitialized = TRUE;
    return hr;
}

//
//==================== USE ARCHIVE ====================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::get_UseArchive(
        VARIANT_BOOL *pbUseArchive
)
/*++

Routine name : CFaxArchiveInner::get_UseArchive

Routine description:

    Return Flag indicating whether or not to Archive the Fax Messages

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbUseArchive                  [out]    - Ptr to the Place to put Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxArchiveInner::get_UseArchive"), hr);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbUseArchive, m_bUseArchive);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
    return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>::
    put_UseArchive(
        VARIANT_BOOL bUseArchive
)
/*++

Routine name : CFaxArchiveInner::put_UseArchive

Routine description:

    Set new Use Archive Flag

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bUseArchive                   [in]    - the new Value for the Use Archive Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxArchiveInner::put_UseArchive"), hr, _T("%ld"), bUseArchive);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bUseArchive = bUseArchive;
    return hr;
}

//
//==================== ARCHIVE FOLDER ====================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::get_ArchiveFolder(
        BSTR *pbstrArchiveFolder
)
/*++

Routine name : CFaxArchiveInner::get_ArchiveFolder

Routine description:

    return Archive Folder on Server

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbstrArchiveFolder              [out]    - the Archive Folder

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT hr = S_OK;
    DBG_ENTER (TEXT("CFaxArchiveInner::get_ArchiveFolder"), hr);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetBstr(pbstrArchiveFolder, m_bstrArchiveFolder);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
    return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::put_ArchiveFolder (
        BSTR bstrArchiveFolder
)
/*++

Routine name : CFaxArchiveInner::put_ArchiveFolder

Routine description:

    Set Archive Folder

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bstrArchiveFolder              [in]    - new Archive Folder on Server 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxArchiveInner::put_ArchiveFolder"), hr, _T("%s"), bstrArchiveFolder);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bstrArchiveFolder = bstrArchiveFolder;
    if (bstrArchiveFolder && !m_bstrArchiveFolder)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(*pcid, 
            IDS_ERROR_OUTOFMEMORY, 
            *piid, 
            hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

//
//==================== SIZE QUOTA WARNING ================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::get_SizeQuotaWarning(
        VARIANT_BOOL *pbSizeQuotaWarning
)
/*++

Routine name : CFaxArchiveInner::get_SizeQuotaWarning

Routine description:

    Return Flag indicating whether or not to issue event log warning when
    watermarks are crossed

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbSizeQuotaWarning            [out]    - ptr to place where to put the Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxArchiveInner::get_SizeQuotaWarning"), hr);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbSizeQuotaWarning, m_bSizeQuotaWarning);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
    return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::put_SizeQuotaWarning(
        VARIANT_BOOL bSizeQuotaWarning
)
/*++

Routine name : CFaxArchiveInner::put_SizeQuotaWarning

Routine description:

    Set new SizeQuotaWarning Flag

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bSizeQuotaWarning              [in]    - the new Value for the SizeQuotaWarning Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxArchiveInner::put_SizeQuotaWarning"), hr, _T("%ld"), bSizeQuotaWarning);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bSizeQuotaWarning = bSizeQuotaWarning;
    return hr;
}

//
//================= QUOTA WATER MARKS ===============================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::get_HighQuotaWaterMark(
        long *plHighQuotaWaterMark
)
/*++

Routine name : CFaxArchiveInner::get_HighQuotaWaterMark

Routine description:

    Return HighQuotaWaterMark

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    plHighQuotaWaterMark        [out]    - HighQuotaWaterMark

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxArchiveInner::get_HighQuotaWaterMark"), hr);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plHighQuotaWaterMark , m_lHighQuotaWaterMark);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
    return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::put_HighQuotaWaterMark(
        long lHighQuotaWaterMark
)
/*++

Routine name : CFaxArchiveInner::put_HighQuotaWaterMark

Routine description:

    Set HighQuotaWaterMark

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    lHighQuotaWaterMark     [in]    - HighQuotaWaterMark to Set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxArchiveInner::put_HighQuotaWaterMark"), hr, _T("%ld"), lHighQuotaWaterMark);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_lHighQuotaWaterMark = lHighQuotaWaterMark;
    return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::get_LowQuotaWaterMark(
        long *plLowQuotaWaterMark
)
/*++

Routine name : CFaxArchiveInner::get_LowQuotaWaterMark

Routine description:

    Return LowQuotaWaterMark

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    plLowQuotaWaterMark         [out]    - LowQuotaWaterMark

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxArchiveInner::get_LowQuotaWaterMark"), hr);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plLowQuotaWaterMark , m_lLowQuotaWaterMark);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
    return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::put_LowQuotaWaterMark(
        long lLowQuotaWaterMark
)
/*++

Routine name : CFaxArchiveInner::put_LowQuotaWaterMark

Routine description:

    Set LowQuotaWaterMark

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    lLowQuotaWaterMark      [in]    - LowQuotaWaterMark to Set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxArchiveInner::put_LowQuotaWaterMark"), hr, _T("%ld"), lLowQuotaWaterMark);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_lLowQuotaWaterMark = lLowQuotaWaterMark;
    return hr;
}

//
//================= AGE LIMIT ===============================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::get_AgeLimit(
        long *plAgeLimit
)
/*++

Routine name : CFaxArchiveInner::get_AgeLimit

Routine description:

    Return how long in days Fax Message is stored at Fax Server

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    plAgeLimit              [out]    - AgeLimit

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxArchiveInner::get_AgeLimit"), hr);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plAgeLimit, m_lAgeLimit);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
    return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::put_AgeLimit(
        long lAgeLimit
)
/*++

Routine name : CFaxArchiveInner::put_AgeLimit

Routine description:

    Set AgeLimit

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    lAgeLimit       [in]    - AgeLimit to Set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxArchiveInner::put_AgeLimit"), hr, _T("%ld"), lAgeLimit);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_lAgeLimit = lAgeLimit;
    return hr;
}

//
//================= SIZE ==============================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::get_SizeLow(
        long *plSizeLow
)
/*++

Routine name : CFaxArchiveInner::get_SizeLow

Routine description:

    Return Size in Bytes of the Archive

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plSizeLow                   [out]    - Ptr to the place to put the Size in

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxArchiveInner::get_SizeLow"), hr);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plSizeLow, long(m_uliSize.LowPart));
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
    return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::get_SizeHigh(
        long *plSizeHigh
)
/*++

Routine name : CFaxArchiveInner::get_SizeHigh

Routine description:

    Return Size in Bytes of the Archive

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plSizeHigh                  [out]    - Ptr to the place to put the Size in

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxArchiveInner::get_SizeHigh"), hr);

    //  
    //  Initialize before first use
    //
    if (!m_bInitialized)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plSizeHigh, long(m_uliSize.HighPart));
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
    return hr;
}

//
//========================= SAVE ====================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::Save(
)
/*++

Routine name : CFaxArchiveInner::Save

Routine description:

    Save the Archive's Configuration

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT             hr = S_OK;
    HANDLE              hFaxHandle = NULL;
    FAX_ARCHIVE_CONFIG  FaxArchiveConfig;

    DBG_ENTER (_T("CFaxArchiveInner::Save"), hr);

    //
    //  Get Fax Server Handle
    //
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    if (hFaxHandle == NULL)
    {
        //
        //  Fax Server Is Not Connected 
        //
        hr = E_HANDLE;
        AtlReportError(*pcid, 
            IDS_ERROR_SERVER_NOT_CONNECTED, 
            *piid, 
            hr);
        CALL_FAIL(GENERAL_ERR, _T("hFaxHandle == NULL"), hr);
        return hr;
    }

    //
    //  FaxArchiveConfig.dwlArchiveSize is ignored for SetConfiguration()
    //
    FaxArchiveConfig.dwSizeOfStruct = sizeof(FAX_ARCHIVE_CONFIG);

    FaxArchiveConfig.bUseArchive = VARIANT_BOOL2bool(m_bUseArchive);
    FaxArchiveConfig.bSizeQuotaWarning = VARIANT_BOOL2bool(m_bSizeQuotaWarning);
    FaxArchiveConfig.dwSizeQuotaHighWatermark = m_lHighQuotaWaterMark;
    FaxArchiveConfig.dwSizeQuotaLowWatermark = m_lLowQuotaWaterMark;
    FaxArchiveConfig.dwAgeLimit = m_lAgeLimit;
    FaxArchiveConfig.lpcstrFolder = m_bstrArchiveFolder;

    if ( 0 == ::FaxSetArchiveConfiguration(hFaxHandle, ArchiveType, &FaxArchiveConfig))
    {
        //
        //  Failed to Set Archive Configuration
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::FaxSetArchiveConfiguration()"), hr);
        return hr;
    }
    return hr;
}

//
//=============== GET MESSAGE ========================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::GetMessage(
        BSTR bstrMessageId, 
        MsgIfc **ppFaxMessage
)
/*++

Routine name : CFaxArchiveInner::GetMessage

Routine description:

    Return Message by given Id

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    bstrMessageId               [in]    - Id of the Message to return
    ppFaxMessage                [out]    - Ptr to the place to put the Message

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT hr = S_OK;

    DBG_ENTER (TEXT("CFaxArchiveInner::GetMessage"), hr, _T("%s"), bstrMessageId);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(ppFaxMessage, sizeof(MsgIfc *)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr"), hr);
        return hr;
    }

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
    
    //
    //  convert Message Id that we've got to hexadecimal DWORDLONG
    //
    DWORDLONG   dwlMsgId;
    int iParsed = _stscanf (bstrMessageId, _T("%I64x"), &dwlMsgId); 
    if ( iParsed != 1)
    {
        //
        //  Failed to conver the number
        //
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("_stscanf()"), hr);
        AtlReportError(*pcid, IDS_ERROR_INVALIDMSGID, *piid, hr);
        return hr;
    }

    CFaxPtr<FAX_MESSAGE>    pFaxPtrMessage;
    if (!FaxGetMessage(hFaxHandle, dwlMsgId, ArchiveType, &pFaxPtrMessage))
    {
        //
        //  Failed to retrieve the Message
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxGetMessage()"), hr);
        return hr;
    }

    //
    //  Check that pFaxPtrMessage is valid
    //
    if (!pFaxPtrMessage || pFaxPtrMessage->dwSizeOfStruct != sizeof(FAX_MESSAGE))
    {
        //
        //  Failed to Get Message
        //
        hr = E_FAIL;
        AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("Invalid pFaxMessage"), hr);
        return hr;
    }

    //
    //  Create Message Object
    //
    CComPtr<MsgIfc>     pTmpMessage;
    hr = MsgType::Create(&pTmpMessage);
    if (FAILED(hr))
    {
        //
        //  Failed to create the Message object
        //
        AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("MsgType::Create()"), hr);
        return hr;
    }

    //
    //  Initialize the Message Object
    //
    hr = ((MsgType *)((MsgIfc *)pTmpMessage))->Init(pFaxPtrMessage, m_pIFaxServerInner);
    if (FAILED(hr))
    {
        //
        // Failed to Init the Message Object
        //
        AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("<casted>pTmpMessage->Init(pFaxMessage, m_pIFaxServerInner)"), hr);
        return hr;
    }

    //
    //  Return Message Object to the Caller
    //
    hr = pTmpMessage.CopyTo(ppFaxMessage);
    if (FAILED(hr))
    {
        //
        //  Failed to Copy Interface
        //
        AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("CComPtr::CopyTo"), hr);
        return hr;
    }

    return hr;
}

//
//========================= GET MESSAGES ==============================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
          class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
    ::GetMessages(
        long lPrefetchSize, 
        IteratorIfc **ppFaxMessageIterator
)
/*++

Routine name : CFaxArchiveInner::GetMessages

Routine description:

    Return Iterator on Archive's Messages.

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    lPrefetchSize               [in]    - Size of Prefetch Buffer for Messages.
    ppFaxMessageIterator        [out]    - Ptr to place to put Iterator Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxArchiveInner::GetMessages"), hr);

    CObjectHandler<IteratorType, IteratorIfc>   objectCreator;
    CComPtr<IteratorIfc>                        pObjectTmp;
    hr = objectCreator.GetObject(&pObjectTmp, m_pIFaxServerInner);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
    //
    // Set object prefetch size to default value
    //
    hr = pObjectTmp->put_PrefetchSize(lPrefetchSize);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
    //
    // Object is successfully created and set - copy it back to caller
    //
    hr = pObjectTmp.CopyTo(ppFaxMessageIterator);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("CComPtr::CopyTo"), hr);
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
    return hr;
}   // CFaxArchiveInner::GetMessages

#endif //__FAXARCHIVEINNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxcommon.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxCommon.cpp

Abstract:

	Implementation of common Interfaces and Functions.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "StdAfx.h"
#include "resource.h"
#include "FaxComEx.h"
#include "FaxCommon.h"
#include "faxutil.h"
#include "FaxServer.h"

//
//============= GET BSTR FROM DWORDLONG ==========================================
//
HRESULT
GetBstrFromDwordlong(
    /*[in]*/ DWORDLONG  dwlFrom,
    /*[out]*/ BSTR *pbstrTo
)
/*++

Routine name : GetBstrFromDwordlong

Routine description:

	Convert DWORDLONG into BSTR. Used in Message, and in Events in Server.

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	dwlFrom                       [in]    - DWORDLONG value to convert to BSTR
	pbstrTo                       [out]    - ptr to the BSTR to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("GetBstrFromDwordlong"), hr, _T("DWORDLONG=%ld"), dwlFrom);

    //
    //  Convert DWORDLONG into buffer of TCHARs
    //
    TCHAR   tcBuffer[25];
    ::_i64tot(dwlFrom, tcBuffer, 16);

    //
    //  Create BSTR from that buffer
    //
    BSTR    bstrTemp;
    bstrTemp = ::SysAllocString(tcBuffer);
    if (!bstrTemp)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("SysAllocString()"), hr);
        return hr;
    }

    //
    //  Return created BSTR
    //
    *pbstrTo = bstrTemp;
    return hr;
}

//
//===================== GET EXTENSION PROPERTY ===============================================
//
HRESULT
GetExtensionProperty(
    /*[in]*/ IFaxServerInner *pServer,
    /*[in]*/ long lDeviceId,
    /*[in]*/ BSTR bstrGUID, 
    /*[out, retval]*/ VARIANT *pvProperty
)
/*++

Routine name : GetExtensionProperty

Routine description:

	Retrieves the Extension Data by given GUID from the Server.
    Used by FaxServer and FaxDevice Classes.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

    pServer                   [in]    --  Ptr to the Fax Server Object
    lDeviceId                 [in]    --  Device Id with which the Extension Property is assosiated
    bstrGUID                  [in]    --  Extension's Data GUID
    pvProperty                [out]    --  Variant with the Blob to Return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("GetExtensionProperty"), hr, _T("GUID=%s"), bstrGUID);

    //
    //  Check the pointer we have got
    //
    if (!pvProperty) 
    {
        hr = E_POINTER;
        CALL_FAIL(GENERAL_ERR, _T("!pvProperty"), hr);
        return hr;
    }

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = pServer->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
		return hr;
	}

    //
    //  Ask Server to Get the Extension Property we want
    //
    CFaxPtrBase<void>   pData;
    DWORD               dwSize = 0;
    if (!FaxGetExtensionData(faxHandle, lDeviceId, bstrGUID, &pData, &dwSize))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxGetExtensionData(faxHandle, m_lID, bstrGUID, &pData, &dwSize)"), hr);
		return hr;
    }

    //
    //  Create SafeArray to Return to User
    //
    hr = Binary2VarByteSA(((BYTE *)(pData.p)), pvProperty, dwSize);

	SecureZeroMemory(pData, dwSize);
    return hr; 
};

//
//===================== SET EXTENSION PROPERTY ===============================================
//  TODO:   should work with empty vProperty
//
HRESULT
SetExtensionProperty(
    /*[in]*/ IFaxServerInner *pServer,
    /*[in]*/ long lDeviceId,
    /*[in]*/ BSTR bstrGUID, 
    /*[in]*/ VARIANT vProperty
)
/*++

Routine name : SetExtensionProperty

Routine description:

	Used by FaxDevice and FaxServer Classes, to Set the Extension Data by given GUID on the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

    pServer                   [in]    --  Ptr to the Fax Server Object
    lDeviceId                 [in]    --  Device Id with which the Extension Property is assosiated
    bstrGUID                  [in]    --  Extension's Data GUID
    vProperty                 [in]    --  Variant with the Blob to Set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("SetExtensionProperty"), hr, _T("GUID=%s"), bstrGUID);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = pServer->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
		return hr;
	}

    //
    //  check that Variant contains SafeArray
    //
    if (vProperty.vt != (VT_ARRAY | VT_UI1))
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("(vProperty.vt != VT_ARRAY | VT_BYTE)"), hr);
        return hr;
    }

    //
    //  Create Binary from the SafeArray we got
    //
    CFaxPtrLocal<void>  pData;
    hr = VarByteSA2Binary(vProperty, (BYTE **)&pData);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    //  Ask Server to Set the Extension Property we want
    //
    DWORD       dwLength = vProperty.parray->rgsabound[0].cElements;
    if (!FaxSetExtensionData(faxHandle, lDeviceId, bstrGUID, pData, dwLength))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxSetExtensionData(faxHandle, m_lID, bstrGUID, &pData, dwLength)"), hr);
    }

	SecureZeroMemory(pData, dwLength);
    return hr; 
};

//
//========================= GET LONG ========================================
//
HRESULT GetLong(
	long    *plTo, 
    long    lFrom
)
/*++

Routine name : GetLong

Routine description:

	Check that plTo is valid
    Copy the given lFrom into plTo

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plTo                [out]    - Ptr to put the value
    lFrom               [in]    -  value to put
    
Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("GetLong"), hr, _T("lFrom=%d"), lFrom);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(plTo, sizeof(long)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(plTo, sizeof(long))"), hr);
		return hr;
	}

	*plTo = lFrom;
	return hr;
}

//
//========================= GET VARIANT BOOL ========================================
//
HRESULT GetVariantBool(
	VARIANT_BOOL    *pbTo, 
    VARIANT_BOOL    bFrom
)
/*++

Routine name : GetVariantBool

Routine description:

	Check that pbTo is valid
    Copy the given bFrom into pbTo

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbTo                [out]    - Ptr to put the value
    bFrom               [in]    -  value to put
    
Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("GetVariantBool"), hr, _T("bFrom=%d"), bFrom);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pbTo, sizeof(VARIANT_BOOL)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pbTo, sizeof(VARIANT_BOOL))"), hr);
		return hr;
	}

	*pbTo = bFrom;
	return hr;
}

//
//========================= GET BSTR ========================================
//
HRESULT GetBstr(
	BSTR    *pbstrTo, 
    BSTR    bstrFrom
)
/*++

Routine name : GetBstr

Routine description:

	Check that pbstTo is valid
    SysAllocString for bstrFrom
    Copy the newly created string into pbstrTo

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrTo                [out]    - Ptr to put the value
    bstrFrom               [in]    -   Ptr to the string to return 
    
Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("GetBstr"), hr, _T("String=%s"), bstrFrom);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pbstrTo, sizeof(BSTR)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pbstrTo, sizeof(BSTR))"), hr);
		return hr;
	}

    //
    //  First copy the string locally
    //
	BSTR	bstrTemp;
    bstrTemp = ::SysAllocString(bstrFrom);
	if (!bstrTemp && bstrFrom)
	{
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("::SysAllocString(bstrFrom)"), hr);
		return hr;
	}

	*pbstrTo = bstrTemp;
	return hr;
}

//
//======= CONVERNT BYTE BLOB INTO VARIANT CONTAINING BYTE SAFE ARRAY  ============
//
HRESULT Binary2VarByteSA(
    BYTE *pbDataFrom, 
    VARIANT *pvarTo,
    DWORD   dwLength
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("Binary2VarByteSA"), hr, _T("Size=%d"), dwLength);

    //
    //  Allocate the safe array : vector of Unsigned Chars
    //
    SAFEARRAY *pSafeArray;
	pSafeArray = ::SafeArrayCreateVector(VT_UI1, 0, dwLength);
	if (pSafeArray == NULL)
	{
		//
		//	Not Enough Memory
		//
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("::SafeArrayCreateVector(VT_UI1, 0, dwLength)"), hr);
		return hr;
	}

    //
    //  get Access to the elements of the Safe Array
    //
	BYTE *pbElement;
	hr = ::SafeArrayAccessData(pSafeArray, (void **) &pbElement);
	if (FAILED(hr))
	{
		//
		//	Failed to access safearray
		//
        hr = E_FAIL;
		CALL_FAIL(GENERAL_ERR, _T("::SafeArrayAccessData(pSafeArray, &pbElement)"), hr);
        SafeArrayDestroy(pSafeArray);
		return hr;
	}

    //
    //  Fill the Safe Array with the bytes from pbDataFrom
    //
    memcpy(pbElement, pbDataFrom, dwLength);

	hr = ::SafeArrayUnaccessData(pSafeArray);
    if (FAILED(hr))
    {
	    CALL_FAIL(GENERAL_ERR, _T("::SafeArrayUnaccessData(pSafeArray)"), hr);
    }

    //
    //  Return the Safe Array inside the VARIANT we got
    //
    VariantInit(pvarTo);
    pvarTo->vt = VT_UI1 | VT_ARRAY;
    pvarTo->parray = pSafeArray;
    return hr;
}


//
//======= CONVERNT VARIANT CONTAINING BYTE SAFE ARRAY INTO POINTER TO BYTES BLOB =========
//
HRESULT 
VarByteSA2Binary(
    VARIANT varFrom, 
    BYTE **ppbData
)
{
    HRESULT hr = S_OK;
    DBG_ENTER(_T("VarByteSA2Binary"), hr);
    //
    // Check that Variant has right type
    //
    if ((varFrom.vt !=  VT_UI1) && (varFrom.vt != (VT_UI1 | VT_ARRAY)))
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("pVarFrom->vt not VT_UI1 or VT_UI1 | VT_ARRAY"), hr);
        return hr;
    }
    ULONG       ulNum = 0;
    SAFEARRAY   *pSafeArray = NULL;
    //
    // Is there is only one member ?
    //
    if (varFrom.vt == VT_UI1)
    {
        ulNum = 1;
    }
    else
    {
        //
        // Get safe array values
        //
        pSafeArray = varFrom.parray;

        if (!pSafeArray)
        {
            hr = E_INVALIDARG;
            CALL_FAIL(GENERAL_ERR, _T("!pSafeArray ( = varFrom.parray )"), hr);
            return hr;        
        }

        if (SafeArrayGetDim(pSafeArray) != 1)
        {
            hr = E_INVALIDARG;
            CALL_FAIL(GENERAL_ERR, _T("SafeArrayGetDim(pSafeArray) != 1"), hr);
            return hr;        
        }

        if (pSafeArray->rgsabound[0].lLbound != 0)
        {
            hr = E_INVALIDARG;
            CALL_FAIL(GENERAL_ERR, _T("pSafeArray->rgsabound[0].lLbound != 0"), hr);
            return hr;        
        }

        ulNum = pSafeArray->rgsabound[0].cElements;
    }

    //
    //  Allocate memory for the safearray
    //
    *ppbData = (BYTE *)MemAlloc(ulNum);
	if (!*ppbData)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("MemAlloc(sizeof(ulNum)"), hr);
		return hr;
	}
    ZeroMemory(*ppbData, ulNum);

    //
    //  Fill pbData with the values from the pSafeArray
    //
    if (!pSafeArray)
    {
        *ppbData[0] = varFrom.bVal;
    }
    else
    {
        //
        //  Get Access to the Safe Array
        //
        BYTE *pbElement;
	    hr = ::SafeArrayAccessData(pSafeArray, (void **) &pbElement);
	    if (FAILED(hr))
	    {
            hr = E_FAIL;
            MemFree (*ppbData);
		    CALL_FAIL(GENERAL_ERR, _T("::SafeArrayAccessData(pSafeArray, &pbElement)"), hr);
		    return hr;
	    }
        //
        //  Fill pbData with the values from the Safe Array 
        //
        memcpy(*ppbData, pbElement, ulNum);

        hr = ::SafeArrayUnaccessData(pSafeArray);
        if (FAILED(hr))
        {
	        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayUnaccessData(pSafeArray)"), hr);
        }

    }
    return hr;
}   // VarByteSA2Binary

//
//======================= INIT ============================================
//
STDMETHODIMP
CFaxInitInner::Init(
	/*[in]*/ IFaxServerInner* pServer
)
/*++

Routine name : CFaxInitInner::Init

Routine description:

	Store Ptr to the Fax Server. Used in most of the objects

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pServer                       [in]    - Ptr to the Fax Server

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxInitInner::Init"), hr);
	m_pIFaxServerInner = pServer;
	return hr;
}

//
//======================= GET FAX HANDLE ============================================
//
STDMETHODIMP
CFaxInitInner::GetFaxHandle(
	/*[in]*/ HANDLE* pFaxHandle
)
/*++

Routine name : CFaxInitInner::GetFaxHandle

Routine description:

	Ask m_pIServerInner for handle to the fax server and handle error

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pFaxHandle						[out]    - Ptr to the returned Fax Handle

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;

	DBG_ENTER (TEXT("CFaxInitInner::GetFaxHandle"), hr);

	//
	//	Get Fax Server Handle
	//
	hr = m_pIFaxServerInner->GetHandle(pFaxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (*pFaxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("hFaxHandle==NULL"), hr);
		return hr;
	}

	return hr;
}

//
//======================= GET ERROR MESSAGE ID ================================
//
LPCTSTR
GetErrorMsgId(
	HRESULT hRes
)
/*++

Routine name : GetErrorMsgId

Routine description:

	Return IDS of the Message according to the given result of the RPC call
		and not only RPC

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	hRes                         [in]    - the RPC call result

Return Value:

    UINT IDS of the Message to show to the User

--*/
{
	switch(hRes)
	{
        case E_POINTER:
	    case HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER):
		    return IDS_ERROR_INVALID_ARGUMENT;

        case E_OUTOFMEMORY:
	    case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
		    return IDS_ERROR_OUTOFMEMORY;

	    case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
		    return IDS_ERROR_ACCESSDENIED;

	    case E_HANDLE:
        case HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED):
            return IDS_ERROR_SERVER_NOT_CONNECTED;

        case HRESULT_FROM_WIN32(ERROR_UNSUPPORTED_TYPE):
            return IDS_ERROR_UNSUPPORTED_RECEIPT_TYPE;

	    case HRESULT_FROM_WIN32(RPC_S_INVALID_BINDING):
	    case HRESULT_FROM_WIN32(EPT_S_CANT_PERFORM_OP):
	    case HRESULT_FROM_WIN32(RPC_S_ADDRESS_ERROR):
	    case HRESULT_FROM_WIN32(RPC_S_CALL_CANCELLED):
	    case HRESULT_FROM_WIN32(RPC_S_CALL_FAILED):
	    case HRESULT_FROM_WIN32(RPC_S_CALL_FAILED_DNE):
	    case HRESULT_FROM_WIN32(RPC_S_COMM_FAILURE):
	    case HRESULT_FROM_WIN32(RPC_S_NO_BINDINGS):
	    case HRESULT_FROM_WIN32(RPC_S_SERVER_TOO_BUSY):
	    case HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE):
		    return IDS_ERROR_CONNECTION_FAILED;

        case HRESULT_FROM_WIN32(ERROR_WRITE_PROTECT):
            return IDS_ERROR_QUEUE_BLOCKED;

        case FAX_E_FILE_ACCESS_DENIED:
            return IDS_ERROR_FILE_ACCESS_DENIED;

        case FAX_E_SRV_OUTOFMEMORY:
            return IDS_ERROR_SRV_OUTOFMEMORY;

        case FAX_E_GROUP_NOT_FOUND:
            return IDS_ERROR_GROUP_NOT_FOUND;

        case FAX_E_BAD_GROUP_CONFIGURATION:
            return IDS_ERROR_BAD_GROUP_CONFIGURATION;

        case FAX_E_GROUP_IN_USE:
            return IDS_ERROR_GROUP_IN_USE;

        case FAX_E_RULE_NOT_FOUND:
            return IDS_ERROR_RULE_NOT_FOUND;

        case FAX_E_NOT_NTFS:
            return IDS_ERROR_NOT_NTFS;

        case FAX_E_DIRECTORY_IN_USE:
            return IDS_ERROR_DIRECTORY_IN_USE;

        case FAX_E_MESSAGE_NOT_FOUND:
            return IDS_ERROR_MESSAGE_NOT_FOUND;

        case FAX_E_DEVICE_NUM_LIMIT_EXCEEDED:
            return IDS_ERROR_DEVICE_NUM_LIMIT_EXCEEDED;

        case FAX_E_NOT_SUPPORTED_ON_THIS_SKU:
            return IDS_ERROR_NOT_SUPPORTED_ON_THIS_SKU;

        case FAX_E_VERSION_MISMATCH:
            return IDS_ERROR_VERSION_MISMATCH;

		case FAX_E_RECIPIENTS_LIMIT:
			return IDS_ERROR_RECIPIENTS_LIMIT;

	    default:
		    return IDS_ERROR_OPERATION_FAILED;
	}
}

//
//====================== SYSTEM TIME TO LOCAL DATE ============================================
//
HRESULT
SystemTime2LocalDate(
    SYSTEMTIME sysTimeFrom, 
    DATE *pdtTo
)
/*++

Routine name : SystemTime2LocalDate

Routine description:

    Convert the System Time stored in FAX_MESSAGE struct to the DATE understood by client

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    tmFrom          [in]    - the System time to convert
    pdtTo           [out]   - the Date to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("SystemTime2LocalDate"), hr);

    //
    //  convert System Time to File Time
    //
    FILETIME fileSysTime;
    if(!SystemTimeToFileTime(&sysTimeFrom, &fileSysTime))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL (GENERAL_ERR, _T("SystemTimeToFileTime"), hr);
        return hr;
    }

    //
    //  convert File Time to Local File Time
    //
    FILETIME fileLocalTime;
    if(!FileTimeToLocalFileTime(&fileSysTime, &fileLocalTime))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL (GENERAL_ERR, _T("FileTimeToLocalFileTime"), hr);
        return hr;
    }

    //
    //  convert Local File Time back to System Time
    //
    if(!FileTimeToSystemTime(&fileLocalTime, &sysTimeFrom))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL (GENERAL_ERR, _T("FileTimeToSystemTime"), hr);
        return hr;
    }

    //
    //  finally, convert now local System Time to Variant Time
    //
    if (!SystemTimeToVariantTime(&sysTimeFrom, pdtTo))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL (GENERAL_ERR, _T("SystemTimeToVariantTime"), hr);
        return hr;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxdevice.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDevice.h

Abstract:

	Declaration of the CFaxDevice class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXDEVICE_H_
#define __FAXDEVICE_H_

#include "resource.h"       // main symbols
#include "FaxLocalPtr.h"

//
//================= FAX DEVICE =================================================
//  Fax Device Object is created by Fax Devices Collection.
//  Fax Devices Collection makes AddRef() on each Device Object.
//  Each Device Object makes AddRef() on the Fax Server.
//  This is done because Fax Device Object needs the Handle to the Fax Server
//      to perform Refresh() etc.
//
class ATL_NO_VTABLE CFaxDevice : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxDevice, &IID_IFaxDevice, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxDevice() : CFaxInitInnerAddRef(_T("FAX DEVICE"))
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDEVICE)
DECLARE_NOT_AGGREGATABLE(CFaxDevice)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxDevice)
	COM_INTERFACE_ENTRY(IFaxDevice)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	STDMETHOD(Save)();
	STDMETHOD(Refresh)();
    STDMETHOD(AnswerCall)();

	STDMETHOD(put_CSID)(/*[in]*/ BSTR bstrCSID);
	STDMETHOD(put_TSID)(/*[in]*/ BSTR bstrTSID);
	STDMETHOD(get_Id)(/*[out, retval]*/ long *plId);
	STDMETHOD(get_CSID)(/*[out, retval]*/ BSTR *pbstrCSID);
	STDMETHOD(get_TSID)(/*[out, retval]*/ BSTR *pbstrTSID);
	STDMETHOD(put_Description)(/*[in]*/ BSTR bstrDescription);
	STDMETHOD(put_SendEnabled)(/*[in]*/ VARIANT_BOOL bSendEnabled);
	STDMETHOD(get_DeviceName)(/*[out, retval]*/ BSTR *pbstrDeviceName);
	STDMETHOD(put_RingsBeforeAnswer)(/*[in]*/ long lRingsBeforeAnswer);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pbstrDescription);
	STDMETHOD(get_ProviderUniqueName)(/*[out, retval]*/ BSTR *pbstrProviderUniqueName);
	STDMETHOD(get_SendingNow)(/*[out, retval]*/ VARIANT_BOOL *pbSendingNow);
	STDMETHOD(get_PoweredOff)(/*[out, retval]*/ VARIANT_BOOL *pbPoweredOff);
	STDMETHOD(get_RingingNow)(/*[out, retval]*/ VARIANT_BOOL *pbRingingNow);
	STDMETHOD(get_SendEnabled)(/*[out, retval]*/ VARIANT_BOOL *pbSendEnabled);
	STDMETHOD(get_ReceivingNow)(/*[out, retval]*/ VARIANT_BOOL *pbReceivingNow);
    STDMETHOD(put_ReceiveMode)(/*[in]*/ FAX_DEVICE_RECEIVE_MODE_ENUM ReceiveMode);
	STDMETHOD(get_RingsBeforeAnswer)(/*[out, retval]*/ long *plRingsBeforeAnswer);
    STDMETHOD(get_ReceiveMode)(/*[out, retval]*/ FAX_DEVICE_RECEIVE_MODE_ENUM *pReceiveMode);

	STDMETHOD(get_UsedRoutingMethods)(/*[out, retval]*/ VARIANT *pvUsedRoutingMethods);
	STDMETHOD(UseRoutingMethod)(/*[in]*/ BSTR bstrMethodGUID, /*[in]*/ VARIANT_BOOL bUse);

	STDMETHOD(SetExtensionProperty)(/*[in]*/ BSTR bstrGUID, /*[in]*/ VARIANT vProperty);
	STDMETHOD(GetExtensionProperty)(/*[in]*/ BSTR bstrGUID, /*[out, retval]*/ VARIANT *pvProperty);

//  Internal Use
    STDMETHOD(Init)(FAX_PORT_INFO_EX *pInfo, IFaxServerInner *pServer);

private:
    long    m_lID;
    long    m_lRings;

    BOOL    m_bSendEnabled;
    FAX_ENUM_DEVICE_RECEIVE_MODE    m_ReceiveMode;

    DWORD   m_dwStatus;

    CComBSTR    m_bstrTSID;
    CComBSTR    m_bstrCSID;
    CComBSTR    m_bstrDescr;
    CComBSTR    m_bstrDeviceName;
    CComBSTR    m_bstrProviderUniqueName;
};

#endif //__FAXDEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxdevice.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxDevice.cpp

Abstract:

    Implementation of CFaxDevice class.

Author:

    Iv Garber (IvG) Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxDevice.h"
#include "..\..\inc\FaxUIConstants.h"


//
//===================== ANSWER CALL ================================================
//
STDMETHODIMP
CFaxDevice::AnswerCall()
/*++

Routine name : CFaxDevice::AnswerCall

Routine description:

    Answer a Call when Manual Answer is set ON. The lCallId parameter is received from  OnNewCall notification.

Author:

    Iv Garber (IvG),    Dec, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::AnswerCall"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE faxHandle;
    hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

    if (faxHandle == NULL)
    {
        //
        //  Fax Server is not connected
        //
        hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }

    //
    //  Ask Server to Answer the Call
    //
    if (!FaxAnswerCall(faxHandle, m_lID))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxAnswerCall(faxHandle, lCallId, m_lID)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }

    return hr;
}


//
//===================== GET RINGING NOW ================================================
//
STDMETHODIMP
CFaxDevice::get_RingingNow(
    /*[out, retval]*/ VARIANT_BOOL *pbRingingNow
)
/*++

Routine name : CFaxDevice::get_RingingNow

Routine description:

    Return whether or not the Device was ringing at the moment the properties were taken.

Author:

    Iv Garber (IvG),    Dec, 2000

Arguments:

    pbRingingNow            [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_RingingNow"), hr);

    hr = GetVariantBool(pbRingingNow, bool2VARIANT_BOOL(m_dwStatus & FAX_DEVICE_STATUS_RINGING));
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }
    return hr;
};

//
//===================== GET RECEIVING NOW ================================================
//
STDMETHODIMP
CFaxDevice::get_ReceivingNow(
    /*[out, retval]*/ VARIANT_BOOL *pbReceivingNow
)
/*++

Routine name : CFaxDevice::get_ReceivingNow

Routine description:

    Return whether or not the Device was receiving when the properties were taken.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pbReceivingNow            [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_ReceivingNow"), hr);

    hr = GetVariantBool(pbReceivingNow, bool2VARIANT_BOOL(m_dwStatus & FAX_DEVICE_STATUS_RECEIVING));
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }
    return hr;
};

//
//===================== GET SENDING NOW ================================================
//
STDMETHODIMP
CFaxDevice::get_SendingNow(
    /*[out, retval]*/ VARIANT_BOOL *pbSendingNow
)
/*++

Routine name : CFaxDevice::get_SendingNow

Routine description:

    Return whether or not the Device was sending when the properties were taken.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pbSendingNow            [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_SendingNow"), hr);

    hr = GetVariantBool(pbSendingNow, bool2VARIANT_BOOL(m_dwStatus & FAX_DEVICE_STATUS_SENDING));
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }
    return hr;
};

//
//===================== SET EXTENSION PROPERTY ===============================================
//  TODO:   should work with empty vProperty
//
STDMETHODIMP
CFaxDevice::SetExtensionProperty(
    /*[in]*/ BSTR bstrGUID, 
    /*[in]*/ VARIANT vProperty
)
/*++

Routine name : CFaxDevice::SetExtensionProperty

Routine description:

    Set the Extension Data by given GUID on the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrGUID                  [in]    --  Extension's Data GUID
    vProperty                 [out]    --  Variant with the Blob to Set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::SetExtensionProperty()"), hr, _T("GUID=%s"), bstrGUID);

    hr = ::SetExtensionProperty(m_pIFaxServerInner, m_lID, bstrGUID, vProperty);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }

    return hr;
};

//
//===================== GET EXTENSION PROPERTY ===============================================
//
STDMETHODIMP
CFaxDevice::GetExtensionProperty(
    /*[in]*/ BSTR bstrGUID, 
    /*[out, retval]*/ VARIANT *pvProperty
)
/*++

Routine name : CFaxDevice::GetExtensionProperty

Routine description:

    Retrieves the Extension Data by given GUID from the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrGUID                  [in]    --  Extension's Data GUID
    pvProperty                [out]    --  Variant with the Blob to Return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::GetExtensionProperty()"), hr, _T("GUID=%s"), bstrGUID);

    hr = ::GetExtensionProperty(m_pIFaxServerInner, m_lID, bstrGUID, pvProperty);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }

    return hr;
};

//
//===================== USE ROUTING METHOD ===============================================
//
STDMETHODIMP
CFaxDevice::UseRoutingMethod(
    /*[in]*/ BSTR bstrMethodGUID, 
    /*[in]*/ VARIANT_BOOL bUse
)
/*++

Routine name : CFaxDevice::UseRoutingMethod

Routine description:

    Add/Remove Routing Method for the Device.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrMethodGUID          [in]    --  Method to Add/Remove
    bUse                    [in]    --  Add or Remove Operation Indicator


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::UseRoutingMethod()"), hr, _T("MethodGUID=%s, bUse=%d"), bstrMethodGUID, bUse);

    //
    //  Get Fax Server Handle
    //
    HANDLE faxHandle;
    hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

    if (faxHandle == NULL)
    {
        //
        //  Fax Server is not connected
        //
        hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }
    //
    //  Open Port for the Device
    //
    HANDLE  hPort;
    if (!FaxOpenPort(faxHandle, m_lID, PORT_OPEN_MODIFY, &hPort))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxOpenPort(faxHandle, m_lID, PORT_OPEN_QUERY, &hPort)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }
    ATLASSERT(hPort);
    //
    //  Ask Server to Add/Remove the Method for the Device
    //
    if (!FaxEnableRoutingMethod(hPort, bstrMethodGUID, VARIANT_BOOL2bool(bUse)))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxEnableRoutingMethod(faxHandle, bstrMethodGUID, VARIANT_BOOL2bool(bUse))"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        goto exit;
    }
exit:
    if (!FaxClose(hPort))
    {
        CALL_FAIL(GENERAL_ERR, _T("FaxClose(hPort)"), Fax_HRESULT_FROM_WIN32(GetLastError()));
    } 
    //
    //  no need to store change locally, because each time get_UsedRoutingMethods is used,
    //  it brings the updated data from the Server.
    //
    return hr; 
}   // CFaxDevice::UseRoutingMethod

//
//===================== SAVE ===============================================
//
STDMETHODIMP
CFaxDevice::Save()
/*++

Routine name : CFaxDevice::Save

Routine description:

    Save the data of the Device to the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::Save()"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE faxHandle;
    hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

    if (faxHandle == NULL)
    {
        //
        //  Fax Server is not connected
        //
        hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }

    //
    //  Create FAX_PORT_INFO struct and fill it with the values
    //
    FAX_PORT_INFO_EX        Data = {0};

    Data.ReceiveMode = m_ReceiveMode;
    Data.bSend = m_bSendEnabled;

    Data.dwRings = m_lRings;
    Data.dwSizeOfStruct = sizeof(FAX_PORT_INFO_EX);

    Data.lptstrCsid = m_bstrCSID;
    Data.lptstrDescription = m_bstrDescr;
    Data.lptstrTsid = m_bstrTSID;

    //
    //  Save the Data struct on Server
    //
    if (!FaxSetPortEx(faxHandle, m_lID, &Data))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxSetPortEx(faxHandle, m_lID, &Data)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }

    return hr; 
};

//
//===================== REFRESH ===============================================
//
STDMETHODIMP
CFaxDevice::Refresh()
/*++

Routine name : CFaxDevice::Refresh

Routine description:

    Bring from the Server data for the Device.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::Refresh()"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE faxHandle;
    hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

    if (faxHandle == NULL)
    {
        //
        //  Fax Server is not connected
        //
        hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }

    //
    //  Ask Server for Data about Device
    //
    CFaxPtr<FAX_PORT_INFO_EX>   pDevice;
    if (!FaxGetPortEx(faxHandle, m_lID, &pDevice))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetPortEx(faxHandle, m_lId, &pDevice)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }
    hr = Init(pDevice, NULL);
    return hr; 
};

//
//================== GET USED ROUTING METHODS ==================================
//
STDMETHODIMP
CFaxDevice::get_UsedRoutingMethods(
    /*[out, retval]*/ VARIANT *pvUsedRoutingMethods
)
/*++

Routine name : CFaxDevice::get_UsedRoutingMethods

Routine description:

    Return Variant containing the SafeArray of Used by the Device Routing Methods GUIDs.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pvUsedRoutingMethods          [out]    - the Variant containing the Result

Return Value:

    Standard HRESULT code

--*/

{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_UsedRoutingMethods"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE faxHandle;
    hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

    if (faxHandle == NULL)
    {
        //
        //  Fax Server is not connected
        //
        hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }

    //
    //  Open Port for the Device
    //
    HANDLE  portHandle;
    if (!FaxOpenPort(faxHandle, m_lID, PORT_OPEN_QUERY, &portHandle))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxOpenPort(faxHandle, m_lID, PORT_OPEN_QUERY, &portHandle)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }
    ATLASSERT(portHandle);

    //
    //  Bring from the Server all Device's Routing Methods
    //
    DWORD       dwNum = 0;
    CFaxPtr<FAX_ROUTING_METHOD>   pMethods;
    BOOL    bResult = FaxEnumRoutingMethods(portHandle, &pMethods, &dwNum);
    if (!bResult)
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxEnumRoutingMethods(portHandle, &pMethods, &dwNum)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        if (!FaxClose(portHandle))
        {
            CALL_FAIL(GENERAL_ERR, _T("FaxClose(portHandle)"), Fax_HRESULT_FROM_WIN32(GetLastError()));
        }        
        return hr;
    }

    if (!FaxClose(portHandle))
    {
        CALL_FAIL(GENERAL_ERR, _T("FaxClose(portHandle)"), Fax_HRESULT_FROM_WIN32(GetLastError()));
    }        

	//
	//	count the enabled routing methods 
	//
	DWORD	dwCount = 0;
    for ( DWORD i=0 ; i<dwNum ; i++ )
    {
        if (pMethods[i].Enabled)
        {
			dwCount++;
        }
    }

    //
    //  Create SafeArray for Enabled Routing Methods
    //
    SAFEARRAY *psaGUIDs;
    psaGUIDs = ::SafeArrayCreateVector(VT_BSTR, 0, dwCount);
    if (!psaGUIDs)
    {
        hr = E_FAIL;
        CALL_FAIL(GENERAL_ERR, _T("SafeArrayCreateVector(VT_BSTR, 0, dwCount)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }

    //
    //  Got Access to the SafeArray
    //
    BSTR    *pbstrElement;
    hr = ::SafeArrayAccessData(psaGUIDs, (void **) &pbstrElement);
    if (FAILED(hr))
    {
        hr = E_FAIL;
        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayAccessData(psaGUIDs, &pbstrElement)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        ::SafeArrayDestroy(psaGUIDs);
        return hr;
    }

    //
    //  Put Methods GUIDs into the SafeArray
    //
	DWORD	j=0;

    for ( i=0 ; i<dwNum ; i++ )
    {
		if (pMethods[i].Enabled)
		{
            pbstrElement[j] = ::SysAllocString(pMethods[i].Guid);
	        if (pMethods[i].Guid && !pbstrElement[j])
			{
				//
				//  Not Enough Memory
				//
				hr = E_OUTOFMEMORY;
				CALL_FAIL(MEM_ERR, _T("::SysAllocString(pMethods[i])"), hr);
				AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
				::SafeArrayUnaccessData(psaGUIDs);
				::SafeArrayDestroy(psaGUIDs);
				return hr;
			}

			j++;
		}
    }

    //
    //  Unaccess the SafeArray
    //
    hr = ::SafeArrayUnaccessData(psaGUIDs);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayUnaccessData(psaGUIDs)"), hr);
    }


    //
    //  Put the SafeArray we created into the given Variant
    //
    VariantInit(pvUsedRoutingMethods);
    pvUsedRoutingMethods->vt = VT_BSTR | VT_ARRAY;
    pvUsedRoutingMethods->parray = psaGUIDs;
    return hr;
};

//
//================= PUT DESCRIPTION ======================================
//
STDMETHODIMP 
CFaxDevice::put_Description(
    /*[in]*/ BSTR   bstrDescription
)
/*++

Routine name : CFaxDevice::put_Description

Routine description:

    Set Description

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrDescription                    [in]    - new Description

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDevice::put_Description"), hr, _T("Value=%s"), bstrDescription);

    m_bstrDescr = bstrDescription;
    if (!m_bstrDescr && bstrDescription)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_OUTOFMEMORY, IID_IFaxDevice, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

//
//================= PUT CSID ======================================
//
STDMETHODIMP 
CFaxDevice::put_CSID (
    /*[in]*/ BSTR   bstrCSID
)
/*++

Routine name : CFaxDevice::put_CSID

Routine description:

    Set CSID

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrCSID                    [in]    - new TSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDevice::put_CSID"), hr, _T("Value=%s"), bstrCSID);

    if (SysStringLen(bstrCSID) > FXS_TSID_CSID_MAX_LENGTH)
    {
        //
        //  Out of the Range
        //
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_OUTOFRANGE, IID_IFaxDevice, hr);
        CALL_FAIL(GENERAL_ERR, _T("TSID is too long"), hr);
        return hr;
    }
    
    m_bstrCSID = bstrCSID;
    if (!m_bstrCSID && bstrCSID)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_OUTOFMEMORY, IID_IFaxDevice, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

//
//================= PUT TSID ======================================
//
STDMETHODIMP 
CFaxDevice::put_TSID (
    /*[in]*/ BSTR   bstrTSID
)
/*++

Routine name : CFaxDevice::put_TSID

Routine description:

    Set TSID

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrTSID                    [in]    - new TSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDevice::put_TSID"), hr, _T("Value=%s"), bstrTSID);

    if (SysStringLen(bstrTSID) > FXS_TSID_CSID_MAX_LENGTH)
    {
        //
        //  Out of the Range
        //
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_OUTOFRANGE, IID_IFaxDevice, hr);
        CALL_FAIL(GENERAL_ERR, _T("TSID is too long"), hr);
        return hr;
    }

    m_bstrTSID = bstrTSID;
    if (!m_bstrTSID && bstrTSID)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_OUTOFMEMORY, IID_IFaxDevice, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

//
//=============== PUT RECEIVE MODE =====================================================
//
STDMETHODIMP
CFaxDevice::put_ReceiveMode(
    /*[in]*/ FAX_DEVICE_RECEIVE_MODE_ENUM ReceiveMode
)
/*++

Routine name : CFaxDevice::put_ReceiveMode

Routine description:

    Set New Value of Receive Mode Attribute for Device Object.

Author:

    Iv Garber (IvG),    Aug, 2000

Arguments:

    ReceiveMode             [in]    - the new value to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::put_ReceiveMode"), hr, _T("Value=%d"), ReceiveMode);

    //
    //  Set receive mode
    //
    if ((ReceiveMode > fdrmMANUAL_ANSWER) || (ReceiveMode < fdrmNO_ANSWER))
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDevice, hr);
        CALL_FAIL(GENERAL_ERR, _T("ReceiveMode > fdrmMANUAL_ANSWER"), hr);
        return hr;
    }
    if (fdrmMANUAL_ANSWER == ReceiveMode)
    {
        //
        //  Check to see if the device is virtual    
        //  Get Fax Server Handle
        //
        HANDLE faxHandle;
        hr = m_pIFaxServerInner->GetHandle(&faxHandle);
        ATLASSERT(SUCCEEDED(hr));

        if (faxHandle == NULL)
        {
            //
            //  Fax Server is not connected
            //
            hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
            CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
            AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
            return hr;
        }

        BOOL bVirtual;
        DWORD dwRes = IsDeviceVirtual (faxHandle, m_lID, &bVirtual);
        if (ERROR_SUCCESS != dwRes)
        {
            hr = Fax_HRESULT_FROM_WIN32(dwRes);
            CALL_FAIL(GENERAL_ERR, _T("IsDeviceVirtual"), hr);
            AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
            return hr;
        }
        if (bVirtual)
        {
            //
            // Virtual devices cannot be set to manual-answer mode
            //
            hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            CALL_FAIL(GENERAL_ERR, _T("IsDeviceVirtual"), hr);
            AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
            return hr;
        }
    }                
    m_ReceiveMode = FAX_ENUM_DEVICE_RECEIVE_MODE (ReceiveMode);
    return hr;
}

//
//=============== PUT SEND ENABLED ==================================================
//
STDMETHODIMP
CFaxDevice::put_SendEnabled(
    /*[in]*/ VARIANT_BOOL bSendEnabled
)
/*++

Routine name : CFaxDevice::put_SendEnabled

Routine description:

    Set New Value for Send Property for Device Object.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bSendEnabled                         [in]    - the new value to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::put_SendEnabled"), hr, _T("Value=%d"), bSendEnabled);

    m_bSendEnabled = VARIANT_BOOL2bool(bSendEnabled);
    return hr;
}

//
//=============== PUT RINGS BEFORE ANSWER ======================================
//
STDMETHODIMP
CFaxDevice::put_RingsBeforeAnswer(
    /*[in]*/ long lRings
)
/*++

Routine name : CFaxDevice::put_RingsBeforeAnswer

Routine description:

    Set New Value for the Rings Before Answer Property for Device Object

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    lRings                        [in]    - the new value to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::put_RingsBeforeAnswer)"), hr, _T("Value=%d"), lRings);

    if (lRings < FXS_RINGS_LOWER || lRings > FXS_RINGS_UPPER)
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDevice, hr);
        CALL_FAIL(GENERAL_ERR, _T("lRings<0"), hr);
        return hr;
    }
    m_lRings = lRings;
    return hr; 
};
    
//
//===================== GET CSID ================================================
//
STDMETHODIMP
CFaxDevice::get_CSID(
    /*[out, retval]*/ BSTR *pbstrCSID
)
/*++

Routine name : CFaxDevice::get_CSID

Routine description:

    Return the Device's CSID.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbstrCSID                   [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_CSID"), hr);

    hr = GetBstr(pbstrCSID, m_bstrCSID);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }
    return hr;
}

//
//===================== GET TSID ================================================
//
STDMETHODIMP
CFaxDevice::get_TSID(
    /*[out, retval]*/ BSTR *pbstrTSID
)
/*++

Routine name : CFaxDevice::get_TSID

Routine description:

    Return the Device's TSID.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbstrTSID                   [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_TSID"), hr);

    hr = GetBstr(pbstrTSID, m_bstrTSID);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
        return hr;
    }
    return hr;
}

//
//===================== GET RECEIVE MODE =============================================
//
STDMETHODIMP
CFaxDevice::get_ReceiveMode(
    /*[out, retval]*/ FAX_DEVICE_RECEIVE_MODE_ENUM *pReceiveMode
)
/*++

Routine name : CFaxDevice::get_ReceiveMode

Routine description:

    Return the Device's Receive Mode Attribute.

Author:

    Iv Garber (IvG),    Aug, 2000

Arguments:

    pReceiveMode                  [out]    - the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_ReceiveMode"), hr);

	if (::IsBadWritePtr(pReceiveMode, sizeof(FAX_DEVICE_RECEIVE_MODE_ENUM)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pReceiveMode, sizeof(FAX_DEVICE_RECEIVE_MODE_ENUM))"), hr);
		return hr;
	}

    *pReceiveMode = (FAX_DEVICE_RECEIVE_MODE_ENUM) m_ReceiveMode;
    return hr;
};

//
//===================== GET SEND ENABLED ============================================
//
STDMETHODIMP
CFaxDevice::get_SendEnabled(
    /*[out, retval]*/ VARIANT_BOOL *pbSendEnabled
)
/*++

Routine name : CFaxDevice::get_SendEnabled

Routine description:

    Return the Device's Send Attribute.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbSendEnabled                  [out]    - the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_SendEnabled"), hr);

    hr = GetVariantBool(pbSendEnabled, bool2VARIANT_BOOL(m_bSendEnabled));
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
    }
    return hr;
};

//
//===================== GET DESCRIPTION ================================================
//
STDMETHODIMP
CFaxDevice::get_Description(
    /*[out, retval]*/ BSTR *pbstrDescription
)
/*++

Routine name : CFaxDevice::get_Description

Routine description:

    Return the Device's Description.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbstrDescription                [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_Description"), hr);

    hr = GetBstr(pbstrDescription, m_bstrDescr);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
    }
    return hr;
}

//
//===================== GET POWERED OFF ================================================
//
STDMETHODIMP
CFaxDevice::get_PoweredOff(
    /*[out, retval]*/ VARIANT_BOOL *pbPoweredOff
)
/*++

Routine name : CFaxDevice::get_PoweredOff

Routine description:

    Return the Device's Powered Off Attribute.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbPoweredOff                [out]    - the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_PoweredOff"), hr);

    hr = GetVariantBool(pbPoweredOff, bool2VARIANT_BOOL(m_dwStatus & FAX_DEVICE_STATUS_POWERED_OFF));
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
    }
    return hr;
};

//
//===================== GET PROVIDER UNIQUE NAME ================================================
//
STDMETHODIMP
CFaxDevice::get_ProviderUniqueName(
    /*[out, retval]*/ BSTR *pbstrProviderUniqueName
)
/*++

Routine name : CFaxDevice::get_ProviderUniqueName

Routine description:

    Return the Device Provider's Unique Name.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbstrProviderUniqueName           [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_ProviderUniqueName"), hr);

    hr = GetBstr(pbstrProviderUniqueName, m_bstrProviderUniqueName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
    }
    return hr;
}

//
//===================== GET DEVICE NAME ================================================
//
STDMETHODIMP
CFaxDevice::get_DeviceName(
    /*[out, retval]*/ BSTR *pbstrDeviceName
)
/*++

Routine name : CFaxDevice::get_DeviceName

Routine description:

    Return the Device's Name.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbstrDeviceName                [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_DeviceName"), hr);

    hr = GetBstr(pbstrDeviceName, m_bstrDeviceName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
    }
    return hr;
}

//
//===================== GET RINGS BEFORE ANSWER ================================================
//
STDMETHODIMP
CFaxDevice::get_RingsBeforeAnswer(
    /*[out, retval]*/ long *plRingsBeforeAnswer
)
/*++

Routine name : CFaxDevice::get_RingsBeforeAnswer

Routine description:

    Return the Device's Number of Rings Before the Answer.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    plRingsBeforeAnswer         [out]    - the Number of Device Rings

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_RingsBeforeAnswer"), hr);

    hr = GetLong(plRingsBeforeAnswer, m_lRings);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
    }
    return hr;
};

//
//===================== GET ID ================================================
//
STDMETHODIMP
CFaxDevice::get_Id(
    /*[out, retval]*/ long *plId
)
/*++

Routine name : CFaxDevice::get_Id

Routine description:

    Return the Device Id.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    plId                          [out]    - the Device ID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_Id"), hr);

    hr = GetLong(plId, m_lID);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr);
    }
    return hr;
};

//
//========================= INIT ==============================================
//
STDMETHODIMP
CFaxDevice::Init(
    FAX_PORT_INFO_EX *pInfo,
    IFaxServerInner  *pServer
)
/*++

Routine name : CFaxDevice::Init

Routine description:

    Initialize the Object with the given data.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pInfo                         [in]    - Ptr to the Device's Data.
    pServer                       [in]    - Ptr to the Fax Server.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::Init"), hr);

    //
    //  Store different Device Fields
    //
    m_lID = pInfo->dwDeviceID;
    m_lRings = pInfo->dwRings;
    m_bSendEnabled = pInfo->bSend;
    m_ReceiveMode = pInfo->ReceiveMode;
    m_dwStatus = pInfo->dwStatus;

    m_bstrDescr = pInfo->lptstrDescription;
    m_bstrProviderUniqueName = pInfo->lpctstrProviderGUID;
    m_bstrDeviceName = pInfo->lpctstrDeviceName;
    m_bstrTSID = pInfo->lptstrTsid;
    m_bstrCSID = pInfo->lptstrCsid;
    if ( (pInfo->lptstrDescription && !m_bstrDescr) ||
         (pInfo->lpctstrProviderGUID && !m_bstrProviderUniqueName) ||
         (pInfo->lptstrTsid && !m_bstrTSID) ||
         (pInfo->lpctstrDeviceName && !m_bstrDeviceName) ||
         (pInfo->lptstrCsid && !m_bstrCSID) )
    {
        hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_OUTOFMEMORY, IID_IFaxDevice, hr);
        return hr;
    }

    if (pServer)
    {
        //
        //  Store Ptr to Fax Server Object
        //
        hr = CFaxInitInnerAddRef::Init(pServer);
    }

    return hr;
}

//
//========================= SUPPORT ERROR INFO ====================================
//
STDMETHODIMP 
CFaxDevice::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxDevice::InterfaceSupportsErrorInfo

Routine description:

    ATL's implementation of Support Error Info.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
    static const IID* arr[] = 
    {
        &IID_IFaxDevice
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxdeviceids.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDeviceIds.h

Abstract:

	Declaration of the CFaxDeviceIds class

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXDEVICEIDS_H_
#define __FAXDEVICEIDS_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include <vector>
#include "VCUE_Copy.h"

namespace DeviceIdsNamespace
{

	// Store the Device Ids in Vector
	typedef	std::vector<long>	ContainerType;

	// Typedef the copy classes using existing typedefs
    typedef VCUE::GenericCopy<VARIANT, long>    EnumCopyType;
    typedef VCUE::GenericCopy<long, long>       CollectionCopyType;

    typedef CComEnumOnSTL< IEnumVARIANT, &__uuidof(IEnumVARIANT), VARIANT, EnumCopyType, 
        ContainerType > EnumType;

    typedef ICollectionOnSTLImpl< IFaxDeviceIds, ContainerType, long, CollectionCopyType, 
        EnumType > CollectionType;
};

using namespace DeviceIdsNamespace;

//
//===================== FAX DEVICE IDS COLLECTION ======================================
//  FaxDeviceIDs Collection needs Ptr to the Fax Server, for Remove, Add and SetOrder
//  operations. So, it inherits from CFaxInitInnerAddRef class.
//
class ATL_NO_VTABLE CFaxDeviceIds : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<DeviceIdsNamespace::CollectionType, &IID_IFaxDeviceIds, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxDeviceIds() : CFaxInitInnerAddRef(_T("FAX DEVICE IDS"))
	{
	}
    ~CFaxDeviceIds()
    {
        //
        //  Clear the Collection
        //
        CCollectionKiller<DeviceIdsNamespace::ContainerType>  CKiller;
        CKiller.ClearCollection(&m_coll);    
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDEVICEIDS)
DECLARE_NOT_AGGREGATABLE(CFaxDeviceIds)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxDeviceIds)
	COM_INTERFACE_ENTRY(IFaxDeviceIds)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(Add)(/*[in]*/ long lDeviceId);
    STDMETHOD(Remove)(/*[in]*/ long lIndex);
    STDMETHOD(SetOrder)(/*[in]*/ long lDeviceId, /*[in]*/ long lNewOrder);

//  Internal Use
    STDMETHOD(Init)(/*[in]*/ DWORD *pDeviceIds, /*[in]*/ DWORD dwNum, /*[in]*/ BSTR bstrGroupName, 
        /*[in]*/ IFaxServerInner *pServer);

private:
    CComBSTR    m_bstrGroupName;

//  Private Functions
    STDMETHOD(UpdateGroup)();
};

#endif //__FAXDEVICEIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxdeviceids.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDeviceIds.cpp

Abstract:

	Implementation of CFaxDeviceIds class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxDeviceIds.h"
#include "faxutil.h"

//
//======================= UPDATE GROUP ======================================
//
STDMETHODIMP
CFaxDeviceIds::UpdateGroup()
/*++

Routine name : CFaxDeviceIds::UpdateGroup

Routine description:

	Update Group Info at Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceIds::UpdateGroup"));

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDeviceIds, GetErrorMsgId(hr), IID_IFaxDeviceIds, hr);
		return hr;
	}

    //
    //  Create Group Structure
    //
    FAX_OUTBOUND_ROUTING_GROUP      groupData;
    groupData.dwNumDevices = m_coll.size();
    groupData.dwSizeOfStruct = sizeof(FAX_OUTBOUND_ROUTING_GROUP);
    groupData.lpctstrGroupName = m_bstrGroupName;
    groupData.Status = FAX_GROUP_STATUS_ALL_DEV_VALID;

    groupData.lpdwDevices = (DWORD *)MemAlloc(sizeof(DWORD) * groupData.dwNumDevices);
    if (!groupData.lpdwDevices)
    {
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("MemAlloc(sizeof(DWORD) * groupData.dwNumDevices)"), hr);
        AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceIds, hr);
		return hr;
    }

    ContainerType::iterator DeviceIdIterator = m_coll.begin();
    DWORD   i = 0;
    while ( DeviceIdIterator != m_coll.end())
    {
        groupData.lpdwDevices[i] = *DeviceIdIterator;

        DeviceIdIterator++;
        i++;
    }

    //
    //  Call Server to Update Group's Info
    //
    if (!FaxSetOutboundGroup(faxHandle, &groupData))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxSetOutboundGroup(faxHandle, &groupData)"), hr);
        AtlReportError(CLSID_FaxDeviceIds, GetErrorMsgId(hr), IID_IFaxDeviceIds, hr);
		return hr;
    }

    return hr;
}

//
//==================================== INIT ======================================
//
STDMETHODIMP
CFaxDeviceIds::Init(
    /*[in]*/ DWORD *pDeviceIds, 
    /*[in]*/ DWORD dwNum, 
    /*[in]*/ BSTR bstrGroupName,
    /*[in]*/ IFaxServerInner *pServer
)
/*++

Routine name : CFaxDeviceIds::Init

Routine description:

	Initialize the DeviceIds Collection.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pDeviceIds                    [in]    - Ptr to the DeviceIds
	dwNum                         [in]    - Count of the Device Ids
	bstrGroupName                 [in]    - Name of the owner Group
	pServer                       [in]    - Ptr to the Server Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceIds::Init"), hr, _T("NumDevices=%d GroupName=%s"), dwNum, bstrGroupName);

    m_bstrGroupName = bstrGroupName;
    if (bstrGroupName && !m_bstrGroupName)
    {
        hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceIds, hr);
		return hr;
    }

    //
    //  Fill the Collection with Device Ids
    //
    for ( DWORD i=0 ; i<dwNum ; i++ )
    {
        try
        {
            m_coll.push_back(pDeviceIds[i]);
        }
        catch (exception &)
        {
		    hr = E_OUTOFMEMORY;
		    AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceIds, hr);
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pDeviceIds[i])"), hr);
		    return hr;
	    }
    }

    //
    //  Store and AddRef the Ptr to the Fax Server Object
    //
    hr = CFaxInitInnerAddRef::Init(pServer);
    return hr;
}

//
//==================================== ADD ======================================
//
STDMETHODIMP
CFaxDeviceIds::Add(
    /*[in]*/ long lDeviceId
)
/*++

Routine name : CFaxDeviceIds::Add

Routine description:

	Add new Device ID to the Collection

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lDeviceId                     [in]    - the Device Id to add

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceIds::Add"), hr, _T("DeviceId=%ld"), lDeviceId);

    //
    //  Check that we can Add Device Id
    //
    if (_tcsicmp(m_bstrGroupName, ROUTING_GROUP_ALL_DEVICES) == 0)
    {
        //
        //  This is the "All Devices" Group
        //
	    hr = E_INVALIDARG;
	    CALL_FAIL(GENERAL_ERR, _T("All Devices Group"), hr);
        AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_ALLDEVICESGROUP, IID_IFaxDeviceIds, hr);
        return hr;
    }

	//
	//	Put the Device Id in the collection
	//
	try 
	{
		m_coll.push_back(lDeviceId);
	}
	catch (exception &)
	{
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceIds, hr);
		CALL_FAIL(MEM_ERR, _T("m_coll.push_back(lDeviceId)"), hr);
		return hr;
	}

    //
    //  Update Group's Info at Server
    //
    hr = UpdateGroup();
    if (FAILED(hr))
    {
        //
        //  Failed to Add the Device Id --> remove it from the Collection as well
        //
	    try 
	    {
		    m_coll.pop_back();
	    }
	    catch (exception &)
	    {
		    //
            //  Only write to Debug
            //
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(lDeviceId)"), E_OUTOFMEMORY);
	    }

        return hr;
    }

    return hr;
}

//
//======================== REMOVE =================================================
//
STDMETHODIMP
CFaxDeviceIds::Remove(
    /*[in]*/ long lIndex
)
/*++

Routine name : CFaxDeviceIds::Remove

Routine description:

	Remove the given Item from the Collection

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lIndex                        [in]    - Index of the Item to remove

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceIds::Remove"), hr, _T("Index=%ld"), lIndex);

    //
    //  Check that we can Remove the Device from the Collection
    //
    if (_tcsicmp(m_bstrGroupName, ROUTING_GROUP_ALL_DEVICES) == 0)
    {
        //
        //  This is the "All Devices" Group
        //
	    hr = E_INVALIDARG;
	    CALL_FAIL(GENERAL_ERR, _T("All Devices Group"), hr);
        AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_ALLDEVICESGROUP, IID_IFaxDeviceIds, hr);
        return hr;
    }

    //
    //  Check that Index is Valid
    //
    if ((lIndex > m_coll.size()) || (lIndex < 1))
    {
	    hr = E_INVALIDARG;
	    CALL_FAIL(GENERAL_ERR, _T("(lIndex > m_coll.size() or lIndex < 1)"), hr);
        AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFRANGE, IID_IFaxDeviceIds, hr);
        return hr;
    }

	//
	//	Remove the Item from the Collection
	//
    long    lDeviceId;
	try 
	{
        ContainerType::iterator it;
        it = m_coll.begin() + lIndex - 1;
        lDeviceId = *it;
		m_coll.erase(it);
	}
	catch (exception &)
	{
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceIds, hr);
		CALL_FAIL(MEM_ERR, _T("m_coll.erase(it)"), hr);
		return hr;
	}

    //
    //  Update Group's Info at Server
    //
    hr = UpdateGroup();
    if (FAILED(hr))
    {
        //
        //  Failed to Remove the Device --> Add it back into the Collection
        //
	    try 
	    {
            ContainerType::iterator it;
            it = m_coll.begin() + lIndex - 1;
            m_coll.insert(it, lDeviceId);
	    }
	    catch (exception &)
	    {
            //
            //  Only Debug 
            //
		    CALL_FAIL(MEM_ERR, _T("m_coll.insert(it, lDeviceId)"), E_OUTOFMEMORY);
	    }

        return hr;
    }

    return hr;
}

//
//======================== SET ORDER =================================================
//
STDMETHODIMP
CFaxDeviceIds::SetOrder(
    /*[in]*/ long lDeviceId, 
    /*[in]*/ long lNewOrder
)
/*++

Routine name : CFaxDeviceIds::SetOrder

Routine description:

	Update Order for the Device Id

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lDeviceId                     [in]    - the Device Id
	lNewOrder                     [in]    - the new Order of the Device Id

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceIds::SetOrder"), hr, _T("Id=%ld Order=%ld"), lDeviceId, lNewOrder);

    //
    //  Before setting the Device's Order at Server, check that the Device is present in the Collection
    //
    ContainerType::iterator it;
    it = m_coll.begin();
    while (it != m_coll.end())
    {
        if ((*it) == lDeviceId)
        {
            break;
        }

        it++;
    }

    if (it == m_coll.end())
    {
        //
        //  Our Collection does not contain such Device Id
        //
        hr = E_INVALIDARG;
		CALL_FAIL(GENERAL_ERR, _T("(The Device Id does not found in the Collection !!)"), hr);
        AtlReportError(CLSID_FaxDeviceIds, GetErrorMsgId(hr), IID_IFaxDeviceIds, hr);
		return hr;
    }

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDeviceIds, GetErrorMsgId(hr), IID_IFaxDeviceIds, hr);
		return hr;
	}

    //  Call Server to Update the Device's Order
    //
    if (!FaxSetDeviceOrderInGroup(faxHandle, m_bstrGroupName, lDeviceId, lNewOrder))
    {
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("FaxSetDeviceOrderInGroup(faxHandle, m_bstrGroupName, lDeviceId, lNewOrder)"), hr);
        AtlReportError(CLSID_FaxDeviceIds, GetErrorMsgId(hr), IID_IFaxDeviceIds, hr);
		return hr;
    }

    //
    //  Remove the Device Id from its Place in the Collection and Put it in the Desired Place
    //
	try 
	{
        m_coll.erase(it);

        it = m_coll.begin() + lNewOrder - 1;
        m_coll.insert(it, lDeviceId);
	}
	catch (exception &)
	{
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceIds, hr);
		CALL_FAIL(MEM_ERR, _T("m_coll.erase(it)/insert(it, lDeviceId)"), hr);
		return hr;
	}

    return hr;
}

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxDeviceIds::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxDeviceIds::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of the ISupportErrorInfo Interface.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxDeviceIds
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxcommon.h ===
//	Fax Common Functions Definitions

#ifndef __FAXCOMMON_H_
#define __FAXCOMMON_H_

#include "FaxStrings.h"
#include <new>
//
// Class: CComContainedObject2
// Author: ronenbar
// Date: 20-Dec-2001
//
// This is modified version of ATL's CComContainedObject.
// It implements IUnknown so the life time of an object inherited from
// it is managed by the controlling uknown (AddRef and Release are delegated to
// the controlling unknown.
// However, unlike the original class this class DOES NOT DELEGATE QueryInterface
// to the controlling IUnknown.
// This is useful when implementing a contained object which is returned via a container
// object method and not via its QueryInterface. I.e. the contrainer is not an aggregator
// but just want the embedded object life time to be managed by the container.
//
//

template <class Base> //Base must be derived from CComObjectRoot
class CComContainedObject2 : public Base
{
public:
        typedef Base _BaseClass;
        CComContainedObject2(void* pv) {m_pOuterUnknown = (IUnknown*)pv;}
#ifdef _ATL_DEBUG_INTERFACES
        ~CComContainedObject2()
        {
                _Module.DeleteNonAddRefThunk(_GetRawUnknown());
                _Module.DeleteNonAddRefThunk(m_pOuterUnknown);
        }
#endif

        STDMETHOD_(ULONG, AddRef)() {return OuterAddRef();}
        STDMETHOD_(ULONG, Release)() {return OuterRelease();}
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {		
				HRESULT hr;
				//
				// Don't delegate QueryInterface to the control IUnknown
				//
                hr = _InternalQueryInterface(iid, ppvObject);
                return hr;
        }
        template <class Q>
        HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
        {
                return QueryInterface(__uuidof(Q), (void**)pp);
        }
        //GetControllingUnknown may be virtual if the Base class has declared
        //DECLARE_GET_CONTROLLING_UNKNOWN()
        IUnknown* GetControllingUnknown()
        {
#ifdef _ATL_DEBUG_INTERFACES
                IUnknown* p;
                _Module.AddNonAddRefThunk(m_pOuterUnknown, _T("CComContainedObject2"), &p);
                return p;
#else
                return m_pOuterUnknown;
#endif
        }
};

inline 
HRESULT Fax_HRESULT_FROM_WIN32 (DWORD dwWin32Err)
{
    if (dwWin32Err >= FAX_ERR_START && dwWin32Err <= FAX_ERR_END)
    {
        //
        // Fax specific error code - make a HRESULT using FACILITY_ITF
        //
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, dwWin32Err);
    }
    else
    {
        return HRESULT_FROM_WIN32(dwWin32Err);
    }
}   // Fax_HRESULT_FROM_WIN32

//
//================ PRIVATE INTERFACE FOR FAX SERVER ===========================
//
MIDL_INTERFACE("80459F70-BBC8-4d68-8EAB-75516195EB02")
IFaxServerInner : public IUnknown
{
	STDMETHOD(GetHandle)(/*[out, retval]*/ HANDLE* pFaxHandle) = 0;
};


//
//=========== TRANSLATION BETWEEN BOOL OF C++ AND BOOL OF VB ==============
//
#define bool2VARIANT_BOOL(b)   ((b) ? VARIANT_TRUE : VARIANT_FALSE)
#define VARIANT_BOOL2bool(b)   ((VARIANT_TRUE == (b)) ? true : false)


//
//================ INIT INNER private interface ===========================
//
MIDL_INTERFACE("D0C7F049-22C1-441c-A2F4-675CC53BDF81")
IFaxInitInner : public IUnknown
{
	STDMETHOD(Init)(/*[in]*/ IFaxServerInner* pServer) = 0;
	STDMETHOD(GetFaxHandle)(/*[out]*/ HANDLE *pFaxHandle) = 0;
};


//
//================== INIT INNER IMPLEMENTATION -- NO ADDREF ON SERVER ==================
//
#define     MAX_LENGTH      50

class CFaxInitInner : public IFaxInitInner
{
public:
    CFaxInitInner(TCHAR *tcObjectName) : m_pIFaxServerInner(NULL)
    {
        DBG_ENTER(_T("FAX INIT INNER::CREATE"), _T("ObjectName = %s"), tcObjectName);
        _tcsncpy(m_tstrObjectName, tcObjectName, MAX_LENGTH);    
    
    }

    ~CFaxInitInner()
    {
        DBG_ENTER(_T("FAX INIT INNER::DESTROY"), _T("ObjectName = %s"), m_tstrObjectName);
    }

	STDMETHOD(Init)(/*[in]*/ IFaxServerInner* pServer);
	STDMETHOD(GetFaxHandle)(/*[out]*/ HANDLE *pFaxHandle);

protected:
	IFaxServerInner*	m_pIFaxServerInner;
private:
    TCHAR    m_tstrObjectName[MAX_LENGTH];
};


//
//================== INIT INNER IMPLEMENTATION -- PLUS ADDREF ON SERVER ==================
//
class CFaxInitInnerAddRef : public CFaxInitInner
{
public:
    CFaxInitInnerAddRef(TCHAR *tcObjectName) : CFaxInitInner(tcObjectName)
    {}

    ~CFaxInitInnerAddRef()
    {
        if(m_pIFaxServerInner) 
        {
            m_pIFaxServerInner->Release();
        }
    }

    STDMETHOD(Init)(/*[in]*/ IFaxServerInner* pServer)
    {
        HRESULT     hr = S_OK;
        DBG_ENTER(_T("CFaxInitInnerAddRef::Init"));
        hr = CFaxInitInner::Init(pServer);
        if (SUCCEEDED(hr))
        {
            m_pIFaxServerInner->AddRef();
        }
        return hr;
    };
};


//
//================ COMMON FUNCTONS ============================================
//
LPCTSTR GetErrorMsgId(HRESULT hRes);
HRESULT SystemTime2LocalDate(SYSTEMTIME sysTimeFrom, DATE *pdtTo);
HRESULT VarByteSA2Binary(VARIANT varFrom, BYTE **ppbData);
HRESULT Binary2VarByteSA(BYTE *pbDataFrom, VARIANT *pvarTo, DWORD dwLength);
HRESULT GetBstr(BSTR *pbstrTo, BSTR bstrFrom);
HRESULT GetVariantBool(VARIANT_BOOL *pbTo, VARIANT_BOOL bFrom);
HRESULT GetLong(long *plTo, long lFrom);
HRESULT SetExtensionProperty(IFaxServerInner *pServer, long lDeviceId, BSTR bstrGUID, VARIANT vProperty);
HRESULT GetExtensionProperty(IFaxServerInner *pServer, long lDeviceId, BSTR bstrGUID, VARIANT *pvProperty);
HRESULT GetBstrFromDwordlong(/*[in]*/ DWORDLONG  dwlFrom, /*[out]*/ BSTR *pbstrTo);

//
//================== FAX SMART PTR -- BASE VERSION ==================================
//
template <typename T>
class CFaxPtrBase
{
private:
	virtual void Free()
	{
        DBG_ENTER(_T("CFaxPtrBase::Free()"), _T("PTR:%ld"), p);
		if (p)
		{
			FaxFreeBuffer(p);
            p = NULL;
		}
	}

public:
	CFaxPtrBase()
	{
		p = NULL;
	}

	virtual ~CFaxPtrBase()
	{
		Free();
	}

	T** operator&()
	{
		ATLASSERT(p==NULL);
		return &p;
	}

	bool operator!() const
	{
		return (p == NULL);
	}

	operator T*() const
	{
		return (T*)p;
	}

	T* operator=(T* lp)
	{
        DBG_ENTER(_T("CFaxPtrBase::operator=()"));
		Free();
		p = lp;
		return (T*)p;
	}

   	T* Detach()
	{
		T* pt = p;
		p = NULL;
		return pt;
	}

	T* p;
};

//
//================== FAX SMART PTR -- FULL VERSION ==================================
//
template <typename T>
class CFaxPtr : public CFaxPtrBase<T>
{
public:
	T* operator->() const
	{
		ATLASSERT(p!=NULL);
		return (T*)p;
	}
};

//
//======================== OBJECT HANDLER ======================================
//
template<typename ClassName, typename IfcType>
class CObjectHandler
{
public :
    //
    //=================== GET CONTAINED OBJECT =============================================
    //
    HRESULT GetContainedObject(IfcType **ppObject, 
        CComContainedObject2<ClassName> **ppInstanceVar, 
        IFaxServerInner *pServerInner)
    {
    	HRESULT				hr = S_OK;
    	DBG_ENTER (_T("CObjectHandler::GetContainedObject"), hr);

        //
        //  Check that we have got a good ptr
        //
        if (::IsBadWritePtr(ppObject, sizeof(IfcType *))) 
	    {
		    hr = E_POINTER;
		    CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		    return hr;
        }

        if (!*ppInstanceVar)
        {
            hr = CreateContainedObject(ppInstanceVar, pServerInner);
            if (FAILED(hr))
            {
                return hr;
            }
        }

	    hr = (*ppInstanceVar)->QueryInterface(ppObject);
        if (FAILED(hr))
        {
		    hr = E_FAIL;
		    CALL_FAIL(GENERAL_ERR, _T("(*ppInstanceVar)->QueryInterface(ppObject)"), hr);
		    return hr;
        }

	    return hr;
    }

    //
    //=================== CREATE CONTAINED OBJECT =============================================
    //
    HRESULT CreateContainedObject(CComContainedObject2<ClassName> **ppObject, IFaxServerInner *pServerInner)
    {
	    HRESULT				hr = S_OK;
	    DBG_ENTER (_T("CObjectHandler::CreateObject"), hr);

        //
        //  Create the Object 
        //
        *ppObject = new (std::nothrow) CComContainedObject2<ClassName>(pServerInner);
	    if (!*ppObject)
	    {
		    //
		    // Failed to create the ppObject
		    //
            hr = E_OUTOFMEMORY;
		    CALL_FAIL(MEM_ERR, _T("new CComContainedObject2<ClassName>(pServerInner)"), hr);
			return hr;
	    }

        //
        //  Init the Object
        //
	    hr = (*ppObject)->Init(pServerInner);
	    if (FAILED(hr))
	    {
		    //
		    // Failed to Init the Object
		    //
		    CALL_FAIL(GENERAL_ERR, _T("(*ppObject)->Init(pServerInner)"), hr);
		    return hr;
	    }

        return hr;
    };

    //
    //=================== GET OBJECT =============================================
    //
    HRESULT GetObject(IfcType **ppObject, IFaxServerInner *pServerInner)
    {
        HRESULT		hr = S_OK;
        DBG_ENTER (TEXT("CObjectHandler::GetObject"), hr);

        //
        //  Check that we have got a good ptr
        //
        if (::IsBadWritePtr(ppObject, sizeof(IfcType *))) 
	    {
		    hr = E_POINTER;
		    CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		    return hr;
        }

	    //
	    // Create new Object
	    //
	    CComPtr<IfcType>        pObjectTmp;
        hr = ClassName::Create(&pObjectTmp);
	    if (FAILED(hr))
	    {
		    CALL_FAIL(GENERAL_ERR, _T("ClassName::Create(&pObjectTmp)"), hr);
		    return hr;
	    }

	    //
	    //	Get IFaxInitInner Interface from the Object
	    //
	    CComQIPtr<IFaxInitInner> pObjectInit(pObjectTmp);
	    ATLASSERT(pObjectInit);

	    //
	    //	Initialize the Object
	    //
	    hr = pObjectInit->Init(pServerInner);
	    if (FAILED(hr))
	    {
		    CALL_FAIL(GENERAL_ERR, _T("pObjectInit->Init(pServerInner)"), hr);
		    return hr;
	    }

		//
		//	Return the Object
		//
	    hr = pObjectTmp.CopyTo(ppObject);
	    if (FAILED(hr))
	    {
		    CALL_FAIL(GENERAL_ERR, _T("CComPtr::CopyTo"), hr);
		    return hr;
	    }
    	return hr;
    };
};

//
//====================== COLLECTION KILLER =========================================
//
template <typename ContainerType>
class CCollectionKiller
{
public:
    STDMETHODIMP EmptyObjectCollection(ContainerType *pColl)
    {
        HRESULT     hr = S_OK;
        DBG_ENTER(_T("CCollectionKiller::EmptyObjectCollection"));

        //
        //  Release all objects
        //
        ContainerType::iterator it = pColl->begin();
        while ( it != pColl->end())
        {
            (*it++)->Release();
        }

        hr = ClearCollection(pColl);
        return hr;
    };

    STDMETHODIMP ClearCollection(ContainerType *pColl)
    {
        HRESULT     hr = S_OK;
        DBG_ENTER(_T("CCollectionKiller::ClearCollection"), hr);

	    //
	    //	Pop the Objects from the Collection
	    //
	    try 
	    {
		    pColl->clear();
	    }
	    catch (exception &)
	    {
            hr = E_OUTOFMEMORY;
		    CALL_FAIL(MEM_ERR, _T("pColl->clear()"), hr);
	    }
        return hr;
    };
};

#endif	//  __FAXCOMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxdeviceprovider.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDeviceProvider.cpp

Abstract:

	Implementation of CFaxDeviceProvider Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxDeviceProvider.h"

//
//========================= GET UNIQUE NAME ========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_UniqueName(
	BSTR *pbstrUniqueName
)
/*++

Routine name : CFaxDeviceProvider::get_UniqueName

Routine description:

	Return Name of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrUniqueName                [out]    - Ptr to put the UniqueName

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_UniqueName"), hr);
    hr = GetBstr(pbstrUniqueName, m_bstrUniqueName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
        return hr;
    }
    return hr;
}

//
//========================= GET IMAGE NAME ========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_ImageName(
	BSTR *pbstrImageName
)
/*++

Routine name : CFaxDeviceProvider::get_ImageName

Routine description:

	Return Image Name of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrImageName                [out]    - Ptr to put the ImageName

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_ImageName"), hr);
    hr = GetBstr(pbstrImageName, m_bstrImageName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
        return hr;
    }
    return hr;
}

//
//========================= GET FRIENDLY NAME ========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_FriendlyName(
	BSTR *pbstrFriendlyName
)
/*++

Routine name : CFaxDeviceProvider::get_FriendlyName

Routine description:

	Return Friendly Name of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrFriendlyName               [out]    - Ptr to put the FriendlyName

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_FriendlyName"), hr);
    hr = GetBstr(pbstrFriendlyName, m_bstrFriendlyName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
        return hr;
    }
    return hr;
}

//
//========================= GET TAPI PROVIDER NAME ========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_TapiProviderName(
	BSTR *pbstrTapiProviderName
)
/*++

Routine name : CFaxDeviceProvider::get_TapiProviderName

Routine description:

	Return Tapi Provider Name of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrTapiProviderName               [out]    - Ptr to put the TapiProviderName

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_TapiProviderName"), hr);
    hr = GetBstr(pbstrTapiProviderName, m_bstrTapiProviderName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
        return hr;
    }
    return hr;
}

//
//===================== GET STATUS =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_Status(
	FAX_PROVIDER_STATUS_ENUM *pStatus
)
/*++

Routine name : CFaxDeviceProvider::get_Status

Routine description:

	Return Status of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pStatus                [out]    - Ptr to put Status value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_Status"), hr);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pStatus, sizeof(FAX_PROVIDER_STATUS_ENUM)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pStatus, sizeof(FAX_PROVIDER_STATUS_ENUM))"), hr);
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
        return hr;
	}

	*pStatus = m_Status;
	return hr;
}

//
//===================== GET INIT ERROR CODE =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_InitErrorCode(
	long *plInitErrorCode
)
/*++

Routine name : CFaxDeviceProvider::get_InitErrorCode

Routine description:

	Return InitErrorCode of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plInitErrorCode                [out]    - Ptr to put InitErrorCode value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_InitErrorCode"), hr);

    hr = GetLong(plInitErrorCode, m_lLastError);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
        return hr;
    }
	return hr;
}

//
//===================== GET DEBUG =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_Debug(
	VARIANT_BOOL *pbDebug
)
/*++

Routine name : CFaxDeviceProvider::get_Debug

Routine description:

	Return if the Device Provider compiled in Debug version

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbDebug                 [out]    - Ptr to put Debug value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_Debug"), hr);

    hr = GetVariantBool(pbDebug, m_bDebug);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
        return hr;
    }
	return hr;
}

//
//===================== GET MAJOR BUILD =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_MajorBuild(
	long *plMajorBuild
)
/*++

Routine name : CFaxDeviceProvider::get_MajorBuild

Routine description:

	Return MajorBuild of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plMajorBuild                [out]    - Ptr to put MajorBuild value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_MajorBuild"), hr);

    hr = GetLong(plMajorBuild, m_lMajorBuild);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
        return hr;
    }
	return hr;
}

//
//===================== GET MINOR BUILD =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_MinorBuild(
	long *plMinorBuild
)
/*++

Routine name : CFaxDeviceProvider::get_MinorBuild

Routine description:

	Return MinorBuild of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plMinorBuild                [out]    - Ptr to put MinorBuild value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_MinorBuild"), hr);

    hr = GetLong(plMinorBuild, m_lMinorBuild);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
        return hr;
    }
	return hr;
}

//
//===================== GET MAJOR VERSION =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_MajorVersion(
	long *plMajorVersion
)
/*++

Routine name : CFaxDeviceProvider::get_MajorVersion

Routine description:

	Return MajorVersion of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plMajorVersion                [out]    - Ptr to put MajorVersion value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_MajorVersion"), hr);

    hr = GetLong(plMajorVersion, m_lMajorVersion);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
        return hr;
    }
	return hr;
}

//
//===================== GET MINOR VERSION =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_MinorVersion(
	long *plMinorVersion
)
/*++

Routine name : CFaxDeviceProvider::get_MinorVersion

Routine description:

	Return MinorVersion of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plMinorVersion                [out]    - Ptr to put MinorVersionvalue

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_MinorVersion"), hr);

    hr = GetLong(plMinorVersion, m_lMinorVersion);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
        return hr;
    }
	return hr;
}

//
//===================== GET DEVICE IDS =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_DeviceIds(
	/*[out, retval]*/ VARIANT *pvDeviceIds
)
/*++

Routine name : CFaxDeviceProvider::get_DeviceIds

Routine description:

	Return array of all device ids exposed by the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pvDeviceIds                 [out]    - Ptr to put Variant containing Safearray of IDs

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_DeviceIds"), hr);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(pvDeviceIds, sizeof(VARIANT)))
	{
		hr = E_POINTER;
		AtlReportError(
            CLSID_FaxDeviceProvider,
            GetErrorMsgId(hr), 
            IID_IFaxDeviceProvider, 
            hr);
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pvDeviceIds, sizeof(VARIANT))"), hr);
		return hr;
	}

    //
    //  Allocate the safe array : vector of long
    //
    SAFEARRAY   *psaResult;
    hr = SafeArrayCopy(m_psaDeviceIDs, &psaResult);
    if (FAILED(hr) || !psaResult)
    {
        if (!psaResult)
        {
            hr = E_OUTOFMEMORY;
        }
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
		CALL_FAIL(MEM_ERR, _T("SafeArrayCopy(m_psaDeviceIDs, &psaResult)"), hr);
		return hr;
	}

    //
    //  Return the Safe Array inside the VARIANT we got
    //
    VariantInit(pvDeviceIds);
    pvDeviceIds->vt = VT_I4 | VT_ARRAY;
    pvDeviceIds->parray = psaResult;
    return hr;
}

//
//==================== INIT ========================================
//
STDMETHODIMP
CFaxDeviceProvider::Init(
    FAX_DEVICE_PROVIDER_INFO *pInfo,
    FAX_PORT_INFO_EX *pDevices,
    DWORD dwNum
)
/*++

Routine name : CFaxDeviceProvider::Init

Routine description:

	Initialize the Device Provider Object with given Information.
    Allocates memory and stores given pInfo.
    Find in the pDevices its own Devices, create Variant of SafeArray containing them.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pInfo               [in]  -- the Info of the Device Provider Object
    pDevices            [in]  -- array of all available Devices
    dwNum               [in]  -- number of elements in pDevices array

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::Init"), hr);

    //
    //  Copy the FAX_DEVICE_PROVIDER_INFO
    //
    m_Status = FAX_PROVIDER_STATUS_ENUM(pInfo->Status);
    m_lLastError = pInfo->dwLastError;

    if (!(pInfo->Version.bValid))
    {
        m_lMajorBuild = 0;
        m_lMinorBuild = 0;
        m_lMajorVersion = 0;
        m_lMinorVersion = 0;
        m_bDebug = VARIANT_FALSE;
    }
    else
    {
        m_lMajorBuild = pInfo->Version.wMajorBuildNumber;
        m_lMinorBuild = pInfo->Version.wMinorBuildNumber;
        m_lMajorVersion = pInfo->Version.wMajorVersion;
        m_lMinorVersion = pInfo->Version.wMinorVersion;
        m_bDebug = bool2VARIANT_BOOL((pInfo->Version.dwFlags & FAX_VER_FLAG_CHECKED) ? true : false);
    }

    m_bstrUniqueName = pInfo->lpctstrGUID;
    m_bstrImageName = pInfo->lpctstrImageName;
    m_bstrFriendlyName = pInfo->lpctstrFriendlyName;
    m_bstrTapiProviderName = pInfo->lpctstrProviderName;
    if ( (pInfo->lpctstrGUID && !m_bstrUniqueName) ||
         (pInfo->lpctstrFriendlyName && !m_bstrFriendlyName) ||
         (pInfo->lpctstrImageName && !m_bstrImageName) ||
         (pInfo->lpctstrProviderName && !m_bstrTapiProviderName) )
    {
        hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
        return hr;
    }

    //
    //  count the devices of the Provider
    //
    DWORD   dwCount = 0;
    for (DWORD  i=0 ; i<dwNum ; i++ )
    {
        if ( _tcsicmp(pDevices[i].lpctstrProviderGUID, m_bstrUniqueName) == 0 )
        {
            dwCount++;
        }
    }

    //
    //  Allocate the safe array : vector of long
    //
	m_psaDeviceIDs = ::SafeArrayCreateVector(VT_I4, 0, dwCount);
	if (m_psaDeviceIDs == NULL)
	{
		//
		//	Not Enough Memory
		//
		hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
		CALL_FAIL(MEM_ERR, _T("::SafeArrayCreateVector(VT_I4, 0, dwCount)"), hr);
		return hr;
	}

    if ( dwCount>0 )
    {

        //
        //  get Access to the elements of the Safe Array
        //
	    DWORD   *pdwElement;
	    hr = ::SafeArrayAccessData(m_psaDeviceIDs, (void **) &pdwElement);
	    if (FAILED(hr))
	    {
		    //
		    //	Failed to access safearray
		    //
            hr = E_FAIL;
		    CALL_FAIL(GENERAL_ERR, _T("::SafeArrayAccessData(m_psaDeviceIDs, &pdwElement)"), hr);
            AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr);
		    return hr;
	    }

        //
        //  Fill the array with values
        //
        DWORD       idx = 0;
        for ( i=0 ; i<dwNum ; i++ )
        {
            if ( _tcsicmp(pDevices[i].lpctstrProviderGUID, m_bstrUniqueName) == 0 )
            {
                pdwElement[idx] = pDevices[i].dwDeviceID;
                idx++;
            }
        }

        //
        //  free the safearray from the access  
        //
	    hr = ::SafeArrayUnaccessData(m_psaDeviceIDs);
        if (FAILED(hr))
        {
	        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayUnaccessData(m_psaDeviceIDs)"), hr);
        }
    }

    return hr;
}

//
//==================== SUPPORT ERROR INFO =============================================
//
STDMETHODIMP 
CFaxDeviceProvider::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxDeviceProvider::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxDeviceProvider
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxdevices.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDevices.cpp

Abstract:

	Implementation of CFaxDevices class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxDevices.h"

//
//============================= GET ITEM =========================================
//
STDMETHODIMP
CFaxDevices::get_Item(
    /*[in]*/ VARIANT vIndex, 
    /*[out, retval]*/ IFaxDevice **ppDevice
)
/*++

Routine name : CFaxDevices::get_Item

Routine description:

	Return a Device from the Collection. 
    A Device is identified either by its Index in the Collection, or by its Name.

Author:

	Iv Garber (IvG),	May, 2001

Arguments:

	vIndex      [in]    - Variant containing Index or Name of the Device to return.
	ppDevice    [out]   - ptr to the Device to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevices::get_Item"), hr);

    //
    //  Check the Ptr we have got
    //
    if (::IsBadWritePtr(ppDevice, sizeof(IFaxDevice *)))
    {
        hr = E_POINTER;
        AtlReportError(CLSID_FaxDevices, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDevices, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppDevice)"), hr);
		return hr;
    }

    CComVariant var;

    if (vIndex.vt != VT_BSTR)
    {
        //
        //  vIndex is not BSTR ==> convert to VT_I4
        //
        hr = var.ChangeType(VT_I4, &vIndex);
        if (SUCCEEDED(hr))
        {
            VERBOSE(DBG_MSG, _T("Parameter is Number : %d"), var.lVal);
            //
            //  call default ATL's implementation
            //
            hr = ICollectionOnSTLImpl<IFaxDevices, ContainerType, 
                IFaxDevice*, CollectionCopyType, EnumType>::get_Item(var.lVal, ppDevice);
            return hr;
		}
    }

    //
    //  convert to BSTR
    //
    hr = var.ChangeType(VT_BSTR, &vIndex);
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxDevices, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDevices, hr);
        CALL_FAIL(GENERAL_ERR, _T("var.ChangeType(VT_BSTR, &vIndex)"), hr);
        return hr;
    }

    VERBOSE(DBG_MSG, _T("Parameter is String : %s"), var.bstrVal);

    ContainerType::iterator it = m_coll.begin();
    while (it != m_coll.end())
    {
        CComBSTR    bstrDeviceName;
        hr = (*it)->get_DeviceName(&bstrDeviceName);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_DeviceName(&bstrDeviceName)"), hr);
            AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr);
            return hr;
        }

        if (_tcsicmp(bstrDeviceName, var.bstrVal) == 0)
        {
            //
            //  found the desired Device 
            //
            (*it)->AddRef();
            *ppDevice = *it;
            return hr;
        }
        it++;
    }

    //
    //  Device does not exist
    //
	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Device Is Not Found"), hr);
	AtlReportError(CLSID_FaxDevices, IDS_ERROR_INVALIDDEVICE, IID_IFaxDevices, hr);
	return hr;
}

//
//==================== ITEM BY ID ================================================
//
STDMETHODIMP
CFaxDevices::get_ItemById(
    /*[in]*/ long lId, 
    /*[out, retval]*/ IFaxDevice **ppDevice
)
/*++

Routine name : CFaxDevices::get_ItemById

Routine description:

	Return Fax Device Object by given Device ID.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lId                           [in]    - the ID of the Device to Return
	ppFaxDevice                   [out]    - the Device To Return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevices::get_ItemById"), hr, _T("ID=%d"), lId);

    //
    //  Check the Ptr we have got
    //
    if (::IsBadWritePtr(ppDevice, sizeof(IFaxDevice *)))
    {
        hr = E_POINTER;
        AtlReportError(CLSID_FaxDevices, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDevices, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppDevice)"), hr);
		return hr;
    }

    //
    //  Find the Device In the Collection
    //
    long    lDeviceID;
    ContainerType::iterator it = m_coll.begin();
    while (it != m_coll.end())
    {
        hr = (*it)->get_Id(&lDeviceID);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_Id(&lDeviceID)"), hr);
            AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr);
            return hr;
        }

        if (lId == lDeviceID)
        {
            //
            //  found the desired Device 
            //
            (*it)->AddRef();
            *ppDevice = *it;
            return hr;
        }
        it++;
    }

    //
    //  Device does not exist
    //
	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Device Is Not Found"), hr);
	AtlReportError(CLSID_FaxDevices, IDS_ERROR_INVALIDDEVICEID, IID_IFaxDevices, hr);
    return hr;
}

//
//============================= INIT ============================================
//
STDMETHODIMP
CFaxDevices::Init(
    IFaxServerInner *pServerInner
)
/*++

Routine name : CFaxDevices::Init

Routine description:

	Initialize the Collection : get from RPC all Devices,
    Create all Objects and store them in the stl::vector.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pServerInner                    [in]    - Ptr to the Fax Server.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevices::Init"), hr);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = pServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr);
		return hr;
	}

    //
    //  Bring from the Server all Devices 
    //
    DWORD       dwNum = 0;
    CFaxPtr<FAX_PORT_INFO_EX>   pDevices;
    if (!FaxEnumPortsEx(faxHandle, &pDevices, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumPortsEx(faxHandle, &pDevices, &dwNum)"), hr);
        AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr);
		return hr;
    }
    //
    //  Fill the Collection with Objects
    //
    CComObject<CFaxDevice>  *pClass = NULL;
    CComPtr<IFaxDevice>     pObject = NULL;
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        //
        //  Create Device Object
        //
        hr = CComObject<CFaxDevice>::CreateInstance(&pClass);
        if (FAILED(hr) || (!pClass))
        {
            if (!pClass)
            {
                hr = E_OUTOFMEMORY;
    		    CALL_FAIL(MEM_ERR, _T("CComObject<CFaxDevice>::CreateInstance(&pClass)"), hr);
            }
            else
            {
    		    CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxDevice>::CreateInstance(&pClass)"), hr);
            }

            AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr);
		    return hr;
        }

        //
        //  Init the Device Object
        //
        hr = pClass->Init(&pDevices[i], 
                          pServerInner);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("pClass->Init(&pDevices[i], pServerInner)"), hr);
            AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr);
            delete pClass;
            return hr;
        }

        //
        //  Get Interface from the pClass.
        //  This will make AddRef() on the Interface. 
        //  This is the Collection's AddRef, which is freed at Collection's Dtor.
        //
        hr = pClass->QueryInterface(&pObject);
        if (FAILED(hr) || (!pObject))
        {
            if (!pObject)
            {
                hr = E_FAIL;
            }
            CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&pObject)"), hr);
            AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr);
            delete pClass;
            return hr;
        }

	    //
	    //	Put the Object in the collection
	    //
	    try 
	    {
		    m_coll.push_back(pObject);
	    }
	    catch (exception &)
	    {
		    hr = E_OUTOFMEMORY;
		    AtlReportError(CLSID_FaxDevices, IDS_ERROR_OUTOFMEMORY, IID_IFaxDevices, hr);
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pObject)"), hr);

            //
            //  no need to delete the pClass. pObject is CComPtr, it will be Released, and this 
            //  will delete the pClass object.
            //
		    return hr;
	    }

        //
        //  We want to save the current AddRef() to Collection
        //
        pObject.Detach();

    }

    return hr;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxDevices::Create (
	IFaxDevices **ppDevices
)
/*++

Routine name : CFaxDevices::Create

Routine description:

	Static function to create the Fax Devices Collection Object

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	ppDevices              [out]  -- the new Fax Devices Collection Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxDevices::Create"), hr);

    //
    //  Create Instance of the Collection
    //
	CComObject<CFaxDevices>		*pClass;
	hr = CComObject<CFaxDevices>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxDevices>::CreateInstance(&pClass)"), hr);
		return hr;
	}

    //
    //  Return the desired Interface Ptr
    //
	hr = pClass->QueryInterface(ppDevices);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(ppDevices)"), hr);
		return hr;
	}

	return hr;
}	//	CFaxDevices::Create()

//
//=================== SUPPORT ERROR INFO =================================================
//
STDMETHODIMP 
CFaxDevices::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxDevices::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Infterface to check

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxDevices
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxdeviceproviders.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDeviceProviders.cpp

Abstract:

	Implementation of CFaxDeviceProviders Class

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxDeviceProviders.h"

//
//==================== CREATE ========================================
//
HRESULT 
CFaxDeviceProviders::Create (
	IFaxDeviceProviders **ppDeviceProviders
)
/*++

Routine name : CFaxDeviceProviders::Create

Routine description:

	Static function to create the Fax Device Providers Collection Object

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	ppDeviceProviders           [out]  -- the new Fax Device Providers Collection Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProviders::Create"), hr);

    //
    //  Create Instance of the Collection
    //
	CComObject<CFaxDeviceProviders>		*pClass;
	hr = CComObject<CFaxDeviceProviders>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxDeviceProviders>::CreateInstance(&pClass)"), hr);
		return hr;
	}

    //
    //  Return the desired Interface Ptr
    //
	hr = pClass->QueryInterface(ppDeviceProviders);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(ppDeviceProviders)"), hr);
		return hr;
	}

	return hr;
}	//	CFaxDeviceProviders::Create()

//
//============================= INIT ============================================
//
STDMETHODIMP
CFaxDeviceProviders::Init(
    IFaxServerInner *pServerInner
)
/*++

Routine name : CFaxDeviceProviders::Init

Routine description:

	Initialize the Collection : 
    1)  get from RPC all Device Provider and all Devices Structures, 
    2)  create COM objects for each structure,
    3)  init all these objects with the Device Provider structure and Devices array,
    4)  AddRef() each object,
    5)  put the Ptrs to Objects into the STL::vector.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pServerInner                    [in]    - Ptr to the Fax Server.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceProviders::Init"), hr);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = pServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDeviceProviders, GetErrorMsgId(hr), IID_IFaxDeviceProviders, hr);
		return hr;
	}

    //
    //  Bring from the Server all Device Providers
    //
    DWORD       dwNum = 0;
    CFaxPtr<FAX_DEVICE_PROVIDER_INFO>   pDeviceProviders;
    if (!FaxEnumerateProviders(faxHandle, &pDeviceProviders, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumerateProviders(faxHandle, &pDeviceProviders, &dwNum"), hr);
        AtlReportError(CLSID_FaxDeviceProviders, GetErrorMsgId(hr), IID_IFaxDeviceProviders, hr);
		return hr;
    }


    //
    //  Bring all the Devices from the Server
    //
    CFaxPtr<FAX_PORT_INFO_EX>   pDevices;
    DWORD                       dwNumDevices = 0;
    if (!FaxEnumPortsEx(faxHandle, &pDevices, &dwNumDevices))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxDeviceProviders, GetErrorMsgId(hr), IID_IFaxDeviceProviders, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxEnumPortsEx(hFaxHandle, &pDevices, &dwNumDevices)"), hr);
        return hr;
    }

    //
    //  Fill the Collection with Objects
    //
    CComObject<CFaxDeviceProvider>  *pClass = NULL;
    CComPtr<IFaxDeviceProvider>     pObject = NULL;
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        //
        //  Create Device Provider Object
        //
        hr = CComObject<CFaxDeviceProvider>::CreateInstance(&pClass);
        if (FAILED(hr) || (!pClass))
        {
            if (!pClass)
            {
                hr = E_OUTOFMEMORY;
    		    CALL_FAIL(MEM_ERR, _T("CComObject<CFaxDeviceProvider>::CreateInstance(&pClass)"), hr);
            }
            else
            {
    		    CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxDeviceProvider>::CreateInstance(&pClass)"), hr);
            }

            AtlReportError(CLSID_FaxDeviceProviders, GetErrorMsgId(hr), IID_IFaxDeviceProviders, hr);
		    return hr;
        }

        //
        //  Init the Device Provider Object
        //
        hr = pClass->Init(&pDeviceProviders[i], pDevices, dwNumDevices);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("pClass->Init(&pDeviceProviders[i], pDevices)"), hr);
            AtlReportError(CLSID_FaxDeviceProviders, GetErrorMsgId(hr), IID_IFaxDeviceProviders, hr);
            delete pClass;
            return hr;
        }

        //
        //  Get Interface from the pClass.
        //  This will make AddRef() on the Interface. 
        //  This is the Collection's AddRef, which is freed at Collection's Dtor.
        //
        hr = pClass->QueryInterface(&pObject);
        if (FAILED(hr) || (!pObject))
        {
            if (!pObject)
            {
                hr = E_FAIL;
            }
            CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&pObject)"), hr);
            AtlReportError(CLSID_FaxDeviceProviders, GetErrorMsgId(hr), IID_IFaxDeviceProviders, hr);
            delete pClass;
            return hr;
        }

	    //
	    //	Put the Object in the collection
	    //
	    try 
	    {
		    m_coll.push_back(pObject);
	    }
	    catch (exception &)
	    {
		    hr = E_OUTOFMEMORY;
		    AtlReportError(CLSID_FaxDeviceProviders, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceProviders, hr);
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pObject)"), hr);

            //
            //  pObject will call Release(), which will delete the pClass
            //
		    return hr;
	    }

        //
        //  We want to save the current AddRef() to Collection
        //
        pObject.Detach();
    }

    return hr;
}

//
//============================= GET ITEM =========================================
//
STDMETHODIMP
CFaxDeviceProviders::get_Item(
    /*[in]*/ VARIANT vIndex, 
    /*[out, retval]*/ IFaxDeviceProvider **ppDeviceProvider
)
/*++

Routine name : CFaxDeviceProviders::get_Item

Routine description:

	Return an Item from the Collection.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	vIndex                        [in]    - Identifier of the Item to return.
	ppDeviceProvider              [out]    - the result value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceProviders::get_Item"), hr);

    //
    //  Check the Ptr we have got
    //
    if (::IsBadWritePtr(ppDeviceProvider, sizeof(IFaxDeviceProvider *)))
    {
        hr = E_POINTER;
        AtlReportError(CLSID_FaxDeviceProviders, 
            IDS_ERROR_INVALID_ARGUMENT, 
            IID_IFaxDeviceProviders, 
            hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppDeviceProvider)"), hr);
		return hr;
    }

    CComVariant var;

    if (vIndex.vt != VT_BSTR)
    {
        //
        //  vIndex is not BSTR ==> convert to VT_I4
        //
        hr = var.ChangeType(VT_I4, &vIndex);
        if (SUCCEEDED(hr))
        {
            VERBOSE(DBG_MSG, _T("Parameter is Number : %d"), var.lVal);
            //
            //  call default ATL's implementation
            //
            hr = ICollectionOnSTLImpl<IFaxDeviceProviders, ContainerType, 
                IFaxDeviceProvider*, CollectionCopyType, EnumType>::get_Item(var.lVal, ppDeviceProvider);
            return hr;
		}
    }

    //
    //  convert to BSTR
    //
    hr = var.ChangeType(VT_BSTR, &vIndex);
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxDeviceProviders, 
            IDS_ERROR_INVALID_ARGUMENT, 
            IID_IFaxDeviceProviders, 
            hr);
        CALL_FAIL(GENERAL_ERR, _T("var.ChangeType(VT_BSTR, &vIndex)"), hr);
        return hr;
    }

    VERBOSE(DBG_MSG, _T("Parameter is String : %s"), var.bstrVal);

    ContainerType::iterator it = m_coll.begin();
    while (it != m_coll.end())
    {
        CComBSTR    bstrUniqueName;
        hr = (*it)->get_UniqueName(&bstrUniqueName);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_UniqueName(&bstrUniqueName)"), hr);
            AtlReportError(CLSID_FaxDeviceProviders, 
                GetErrorMsgId(hr),
                IID_IFaxDeviceProviders, 
                hr);
            return hr;
        }

        if (_tcsicmp(bstrUniqueName, var.bstrVal) == 0)
        {
            //
            //  found the desired Device Provider
            //
            (*it)->AddRef();
            *ppDeviceProvider = *it;
            return hr;
        }
        it++;
    }

    //
    //  Device Provider does not exist
    //
	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Device Provider Is Not Found"), hr);
	AtlReportError(CLSID_FaxDeviceProviders, 
        IDS_ERROR_INVALIDDEVPROVGUID, 
        IID_IFaxDeviceProviders, 
        hr);
	return hr;
}

//
//================== SUPPORT ERROR INFO ========================================
//
STDMETHODIMP 
CFaxDeviceProviders::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxDeviceProviders::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxDeviceProviders
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxdeviceprovider.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDeviceProvider.h

Abstract:

	Declaration of the CFaxDeviceProvider Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXDEVICEPROVIDER_H_
#define __FAXDEVICEPROVIDER_H_

#include "resource.h"       // main symbols
#include "FaxLocalPtr.h"

//
//=================== FAX DEVICE PROVIDER ========================================
//
class ATL_NO_VTABLE CFaxDeviceProvider : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxDeviceProvider, &IID_IFaxDeviceProvider, &LIBID_FAXCOMEXLib>
{
public:
    CFaxDeviceProvider() : 
      m_psaDeviceIDs(NULL)
	{
        DBG_ENTER(_T("FAX DEVICE PROVIDER::CREATE"));
	}

    ~CFaxDeviceProvider()
    {
        HRESULT     hr = S_OK;
        DBG_ENTER(_T("FAX DEVICE PROVIDER::DESTROY"));
        if (m_psaDeviceIDs)
        {
            hr = SafeArrayDestroy(m_psaDeviceIDs);
            if (FAILED(hr))
            {
                CALL_FAIL(GENERAL_ERR, _T("SafeArrayDestroy(m_psaDeviceIDs)"), hr);
            }
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDEVICEPROVIDER)
DECLARE_NOT_AGGREGATABLE(CFaxDeviceProvider)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxDeviceProvider)
	COM_INTERFACE_ENTRY(IFaxDeviceProvider)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_Debug)(/*[out, retval]*/ VARIANT_BOOL *pbDebug);
    STDMETHOD(get_MajorBuild)(/*[out, retval]*/ long *plMajorBuild);
    STDMETHOD(get_MinorBuild)(/*[out, retval]*/ long *plMinorBuild);
    STDMETHOD(get_DeviceIds)(/*[out, retval]*/ VARIANT *pvDeviceIds);
    STDMETHOD(get_ImageName)(/*[out, retval]*/ BSTR *pbstrImageName);
    STDMETHOD(get_UniqueName)(/*[out, retval]*/ BSTR *pbstrUniqueName);
    STDMETHOD(get_MajorVersion)(/*[out, retval]*/ long *plMajorVersion);
    STDMETHOD(get_MinorVersion)(/*[out, retval]*/ long *plMinorVersion);
    STDMETHOD(get_InitErrorCode)(/*[out, retval]*/ long *plInitErrorCode);
    STDMETHOD(get_FriendlyName)(/*[out, retval]*/ BSTR *pbstrFriendlyName);
    STDMETHOD(get_Status)(/*[out, retval]*/ FAX_PROVIDER_STATUS_ENUM *pStatus);
    STDMETHOD(get_TapiProviderName)(/*[out, retval]*/ BSTR *pbstrTapiProviderName);

//	Internal Use
    STDMETHOD(Init)(FAX_DEVICE_PROVIDER_INFO *pInfo, FAX_PORT_INFO_EX *pDevices, DWORD dwNum);

private:
    long            m_lMajorBuild;
    long            m_lMinorBuild;
    long            m_lMajorVersion;
    long            m_lMinorVersion;
    long            m_lLastError;

    CComBSTR        m_bstrUniqueName;
    CComBSTR        m_bstrImageName;
    CComBSTR        m_bstrFriendlyName;
    CComBSTR        m_bstrTapiProviderName;

    SAFEARRAY       *m_psaDeviceIDs;

    VARIANT_BOOL    m_bDebug;

    FAX_PROVIDER_STATUS_ENUM        m_Status;
};

#endif //__FAXDEVICEPROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxdeviceproviders.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDeviceProviders.h

Abstract:

	Declaration of the CFaxDeviceProviders Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXDEVICEPROVIDERS_H_
#define __FAXDEVICEPROVIDERS_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include <vector>
#include "VCUE_Copy.h"
#include "FaxDeviceProvider.h"

namespace DeviceProvidersNamespace
{

    //
    //  Device Provider Objects are stored in Vector of STL.
    //  When initialized, they got ALL their data. 
    //  They never call Fax Server.
    //  They do not depend neither on Fax Server nor on Device Providers Collection
    //  after they are created and initialized.
    //  So, they implemented as usual COM Objects. 
    //  The Collection stores Ptrs to them, and makes ONE AddRef(). 
    //  Each time User asks for an Object from the Collection, an additional AddRef() happens. 
    //  When killed, Collection calls Release() on all its Device Provider Objects.
    //  Those that are not asked by User, dies. 
    //  Those, that have User's AddRef() - remains alive, untill User free its Reference on them.
    //  The Device Provider Object can continue to live after all objects are freed,
    //  including Fax Server and all its Descendants. 
    //  THIS IS BECAUSE Device Provider Object and their Collection is Snap-Shot 
    //  of the situation on the Server. They are not updatable, but a read-only objects.
    //  To get the updated data, User must ask new Collection from the Server.
    //
	typedef	std::vector<IFaxDeviceProvider*>        ContainerType;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT			    EnumExposedType;
	typedef	IEnumVARIANT        EnumIfc;

	//  Copy Classes
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<ContainerType::value_type>            CollectionCopyType;

    //  Enumeration Type, shortcut for next typedef
    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), EnumExposedType, EnumCopyType, ContainerType >    
        EnumType;

    //  Collection Type, real ancestor of the DeviceProvider Collection
    typedef ICollectionOnSTLImpl< IFaxDeviceProviders, ContainerType, ContainerType::value_type, 
        CollectionCopyType, EnumType >    CollectionType;
};

using namespace DeviceProvidersNamespace;

//
//==================== FAX DEVICE PROVIDERS ===========================================
//
class ATL_NO_VTABLE CFaxDeviceProviders : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<DeviceProvidersNamespace::CollectionType, &IID_IFaxDeviceProviders, 
                        &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxDeviceProviders() : CFaxInitInner(_T("FAX DEVICE PROVIDERS"))
    {}

    ~CFaxDeviceProviders()
    {
        CCollectionKiller<DeviceProvidersNamespace::ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDEVICEPROVIDERS)
DECLARE_NOT_AGGREGATABLE(CFaxDeviceProviders)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxDeviceProviders)
	COM_INTERFACE_ENTRY(IFaxDeviceProviders)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ IFaxDeviceProvider **ppDeviceProvider);

//  Internal Use
    STDMETHOD(Init)(IFaxServerInner *pServerInner);
    static HRESULT Create(IFaxDeviceProviders **ppDeviceProviders);
};

#endif //__FAXDEVICEPROVIDERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxeventlogging.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxEventLogging.cpp

Abstract:

	Implementation of Event Logging Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxEventLogging.h"

//
//================= PUT LEVEL =======================================
//
STDMETHODIMP
CFaxEventLogging::PutLevel(
    FAX_ENUM_LOG_CATEGORIES faxCategory,
    FAX_LOG_LEVEL_ENUM faxLevel
)
/*++

Routine name : CFaxEventLogging::PutLevel

Routine description:

	Set the Level of given Category.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	faxCategory                   [in]    - the Category for which level is desired.
	faxLevel                      [in]    - the result : level of the given category

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxEventLogging::PutLevel"), hr, _T("Category : %d"), faxCategory);

    //
    //  check the range
    //
    if (faxLevel > fllMAX || faxLevel < fllNONE)
    {
		//
		//	Out of range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxEventLogging,
            IDS_ERROR_OUTOFRANGE, 
            IID_IFaxEventLogging, 
            hr);
		CALL_FAIL(GENERAL_ERR, _T("Level is out of range"), hr);
		return hr;
    }

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    switch(faxCategory)
    {
    case FAXLOG_CATEGORY_INIT:
        m_InitLevel = faxLevel;
        break;
    case FAXLOG_CATEGORY_OUTBOUND:
        m_OutboundLevel = faxLevel;
        break;
    case FAXLOG_CATEGORY_INBOUND:
        m_InboundLevel = faxLevel;
        break;
    default:
        m_GeneralLevel = faxLevel;
        break;
    }

    return hr;
}

//
//================= GET LEVEL =======================================
//
STDMETHODIMP
CFaxEventLogging::GetLevel(
    FAX_ENUM_LOG_CATEGORIES faxCategory,
    FAX_LOG_LEVEL_ENUM     *pLevel
)
/*++

Routine name : CFaxEventLogging::GetLevel

Routine description:

	Return current Level of given Category.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	faxCategory                   [in]    - the Category for which level is desired.
	pLevel                        [out]    - the result : level of the given category

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxEventLogging::GetLevel"), hr, _T("Category : %d"), faxCategory);

    //
    //  Check that we have a good pointer 
    //
    if (::IsBadWritePtr(pLevel, sizeof(FAX_LOG_LEVEL_ENUM)))
    {
		//
		//	Got Bad Return Pointer
		//
		hr = E_POINTER;
		AtlReportError(CLSID_FaxEventLogging, 
            IDS_ERROR_INVALID_ARGUMENT, 
            IID_IFaxEventLogging, 
            hr);
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pLevel, sizeof(FAX_LOG_LEVEL_ENUM))"), hr);
		return hr;
	}

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    switch(faxCategory)
    {
    case FAXLOG_CATEGORY_INIT:
        *pLevel = m_InitLevel;
        break;
    case FAXLOG_CATEGORY_OUTBOUND:
        *pLevel = m_OutboundLevel;
        break;
    case FAXLOG_CATEGORY_INBOUND:
        *pLevel = m_InboundLevel;
        break;
    default:
        *pLevel = m_GeneralLevel;
        break;
    }

    return hr;
}

//
//====================== PUT INIT EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::put_InitEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM InitEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::put_InitEventsLogging"), hr, _T("Level=%d"), InitEventLevel);
    hr = PutLevel(FAXLOG_CATEGORY_INIT, InitEventLevel);
    return hr;
}
    
//
//====================== PUT INBOUND EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::put_InboundEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM InboundEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::put_InboundEventsLogging"), hr, _T("Level=%d"), InboundEventLevel);
    hr = PutLevel(FAXLOG_CATEGORY_INBOUND, InboundEventLevel);
    return hr;
}

//
//====================== PUT OUTBOUND EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::put_OutboundEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM OutboundEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::put_OutboundEventsLogging"), hr, _T("Level=%d"), OutboundEventLevel);
    hr = PutLevel(FAXLOG_CATEGORY_OUTBOUND, OutboundEventLevel);
    return hr;
}

//
//====================== PUT GENERAL EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::put_GeneralEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM GeneralEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::put_GeneralEventsLogging"), hr, _T("Level=%d"), GeneralEventLevel);
    hr = PutLevel(FAXLOG_CATEGORY_UNKNOWN, GeneralEventLevel);
    return hr;
}

//
//====================== GET_INIT EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::get_InitEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pInitEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::get_InitEventsLogging"), hr);
    hr = GetLevel(FAXLOG_CATEGORY_INIT, pInitEventLevel);
    return hr;
}
    
//
//====================== GET INBOUND EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::get_InboundEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pInboundEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::get_InboundEventsLogging"), hr);
    hr = GetLevel(FAXLOG_CATEGORY_INBOUND, pInboundEventLevel);
    return hr;
}

//
//====================== GET OUTBOUND EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::get_OutboundEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pOutboundEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::get_OutboundEventsLogging"), hr);
    hr = GetLevel(FAXLOG_CATEGORY_OUTBOUND, pOutboundEventLevel);
    return hr;
}

//
//====================== GET GENERAL EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::get_GeneralEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pGeneralEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::get_GeneralEventsLogging"), hr);
    hr = GetLevel(FAXLOG_CATEGORY_UNKNOWN, pGeneralEventLevel);
    return hr;
}

//
//================== SAVE ===============================================================
//
STDMETHODIMP 
CFaxEventLogging::Save()
/*++

Routine name : CFaxEventLogging::Save

Routine description:

	Save the Object's contents : bring its current logging categories settings to the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxEventLogging::Save"), hr);

    if (!m_bInited)
    {
        //
        //  No changes
        //
        return hr;
    }

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxEventLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxEventLogging, 
            hr);
        return hr;
    }

    DWORD   dwNum = 4;
    FAX_LOG_CATEGORY    faxCategories[4];

    faxCategories[0].Category = FAXLOG_CATEGORY_INIT;
    faxCategories[0].Name = m_bstrInitName;
    faxCategories[0].Level = FAX_ENUM_LOG_LEVELS(m_InitLevel);
    faxCategories[1].Category = FAXLOG_CATEGORY_INBOUND;
    faxCategories[1].Name = m_bstrInboundName;
    faxCategories[1].Level = FAX_ENUM_LOG_LEVELS(m_InboundLevel);
    faxCategories[2].Category = FAXLOG_CATEGORY_OUTBOUND;
    faxCategories[2].Name = m_bstrOutboundName;
    faxCategories[2].Level = FAX_ENUM_LOG_LEVELS(m_OutboundLevel);
    faxCategories[3].Category = FAXLOG_CATEGORY_UNKNOWN;
    faxCategories[3].Name = m_bstrGeneralName;
    faxCategories[3].Level = FAX_ENUM_LOG_LEVELS(m_GeneralLevel);

    //
    //  Store out setting at the Server 
    //
    if (!FaxSetLoggingCategories(hFaxHandle, faxCategories, dwNum))
    {
        //
        //  Failed to put the Logging Categories to the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxEventLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxEventLogging, 
            hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxSetLoggingCategories(hFaxHandle, faxCategories, dwNum)"), hr);
        return hr;
    }

    return hr;
}

//
//================== REFRESH ===========================================
//
STDMETHODIMP 
CFaxEventLogging::Refresh()
/*++

Routine name : CFaxEventLogging::Refresh

Routine description:

	Refresh the Object's contents : bring new logging categories settings from the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxEventLogging::Refresh"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxEventLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxEventLogging, 
            hr);
        return hr;
    }

    //
    //  Ask the Server for the Logging Settings
    //
    DWORD   dwNum;
    CFaxPtr<FAX_LOG_CATEGORY>   pLogCategory;
    if (!FaxGetLoggingCategories(hFaxHandle, &pLogCategory, &dwNum))
    {
        //
        //  Failed to get the Logging Categories from the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxEventLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxEventLogging, 
            hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxGetLoggingCategories(hFaxHandle, &pLogCategory, &dwNum)"), hr);
        return hr;
    }

    //
    //  must be 4 categories
    //
    ATLASSERT(dwNum == 4);

    for (DWORD i=0; i<dwNum; i++)
    {
        switch(pLogCategory[i].Category)
        {
        case FAXLOG_CATEGORY_INIT:
            m_bstrInitName = pLogCategory[i].Name;
            m_InitLevel = FAX_LOG_LEVEL_ENUM(pLogCategory[i].Level);
            break;
        case FAXLOG_CATEGORY_OUTBOUND:
            m_bstrOutboundName = pLogCategory[i].Name;
            m_OutboundLevel = FAX_LOG_LEVEL_ENUM(pLogCategory[i].Level);
            break;
        case FAXLOG_CATEGORY_INBOUND:
            m_bstrInboundName = pLogCategory[i].Name;
            m_InboundLevel = FAX_LOG_LEVEL_ENUM(pLogCategory[i].Level);
            break;
        case FAXLOG_CATEGORY_UNKNOWN:
            m_bstrGeneralName = pLogCategory[i].Name;
            m_GeneralLevel = FAX_LOG_LEVEL_ENUM(pLogCategory[i].Level);
            break;
        default:
            // 
            //  ASSERT(FALSE)
            //
            ATLASSERT(pLogCategory[i].Category == FAXLOG_CATEGORY_INIT);
            break;
        }
    }

    m_bInited = true;
    return hr;
}

//
//================== SUPPORT ERROR INFO =====================================
//
STDMETHODIMP 
CFaxEventLogging::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxEventLogging::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the IID

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxEventLogging
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxdevices.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDevices.h

Abstract:

	Declaration of the CFaxDevices class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXDEVICES_H_
#define __FAXDEVICES_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include <vector>
#include "VCUE_Copy.h"
#include "FaxDevice.h"

namespace DevicesNamespace
{

    //
    //  Device Objects are stored in Vector of STL.
    //  When initialized, they got ALL their data, and Fax Server Ptr.
    //  They do not depend on Devices Collection, only on Fax Server.
    //  So, they implemented as usual COM Objects. 
    //  They inherit from CFaxInitInnerAddRef class, which means they make AddRef() 
    //  on Fax Server ( at Init() ).
    //  By doing this, the objects prevent the death of the Fax Server prematurely.
    //  So, if the User frees all its references to the Fax Server, but holds its
    //  reference to the Device Object, the Device Object will continue to work,
    //  because Fax Server Object actually did not died.
    //  The Collection stores Ptrs to them, and makes ONE AddRef(). 
    //  Each time User asks for an Object from the Collection, an additional AddRef() happens. 
    //  When killed, Collection calls Release() on all its Device Provider Objects.
    //  Those that were not requested by the User, dies. 
    //  Those, that have User's AddRef() - remains alive, untill User free its Reference on them.
    //  Fax Server remains alive untill all the Device Collections and all Device Objects are killed.
    //  At their death, they Release() the Fax Server.
    //
	typedef	std::vector<IFaxDevice*>       ContainerType;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT			EnumExposedType;
	typedef	IEnumVARIANT    EnumIfc;

	//  Copy Classes
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<ContainerType::value_type>            CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), EnumExposedType, EnumCopyType, 
        ContainerType >    EnumType;

    typedef ICollectionOnSTLImpl< IFaxDevices, ContainerType, ContainerType::value_type, 
        CollectionCopyType, EnumType >    CollectionType;
};

using namespace DevicesNamespace;

//
//===================== FAX DEVICES =============================================
//
class ATL_NO_VTABLE CFaxDevices : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<DevicesNamespace::CollectionType, &IID_IFaxDevices, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner    //  for Debug + Creation thru CObjectHandler
{
public:
    CFaxDevices() : CFaxInitInner(_T("FAX DEVICES"))
	{
	}

    ~CFaxDevices()
    {
        CCollectionKiller<DevicesNamespace::ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDEVICES)
DECLARE_NOT_AGGREGATABLE(CFaxDevices)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxDevices)
	COM_INTERFACE_ENTRY(IFaxDevices)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ IFaxDevice **ppDevice);
    STDMETHOD(get_ItemById)(/*[in]*/ long lId, /*[out, retval]*/ IFaxDevice **ppFaxDevice);

//  Internal Use
    static HRESULT Create(IFaxDevices **ppDevices);
    STDMETHOD(Init)(IFaxServerInner *pServer);
};

#endif //__FAXDEVICES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxdocument.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxDocument.h

Abstract:

    Declaration of the CFaxDocument class.

Author:

    Iv Garber (IvG) Jun, 2000

Revision History:

--*/

#ifndef __FAXDOCUMENT_H_
#define __FAXDOCUMENT_H_

#include "resource.h"       // main symbols
#include "FaxRecipients.h"
#include "FaxServer.h"

//
//======================== FAX DOCUMENT ===========================================
//
class ATL_NO_VTABLE CFaxDocument : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxDocument, &CLSID_FaxDocument>,
    public ISupportErrorInfo,
    public IDispatchImpl<IFaxDocument, &IID_IFaxDocument, &LIBID_FAXCOMEXLib>
{
public:
    CFaxDocument():
        m_Sender (this)
    {
        DBG_ENTER(_T("FAX DOCUMENT -- CREATE"));
    };

    ~CFaxDocument()
    {
        DBG_ENTER(_T("FAX DOCUMENT -- DESTROY"));
    };

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDOCUMENT)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxDocument)
    COM_INTERFACE_ENTRY(IFaxDocument)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(Submit)(/*[in]*/ BSTR bstrFaxServerName, /*[out, retval]*/ VARIANT *pvFaxOutgoingJobIDs);
    STDMETHOD(ConnectedSubmit)(/*[in]*/ IFaxServer *pFaxServer, /*[out, retval]*/ VARIANT *pvFaxOutgoingJobIDs);

    STDMETHOD(put_Body)(/*[in]*/ BSTR bstrBody);
    STDMETHOD(get_Body)(/*[out, retval]*/ BSTR *pbstrBody);

    STDMETHOD(put_Note)(/*[in]*/ BSTR bstrNote);
    STDMETHOD(get_Note)(/*[out, retval]*/ BSTR *pbstrNote);

    STDMETHOD(put_Subject)(/*[in]*/ BSTR bstrSubject);
    STDMETHOD(get_Subject)(/*[out, retval]*/ BSTR *pbstrSubject);

    STDMETHOD(put_CallHandle)(/*[in]*/ long lCallHandle);
    STDMETHOD(get_CallHandle)(/*[out, retval]*/ long *plCallHandle);

    STDMETHOD(put_CoverPage)(/*[in]*/ BSTR bstrCoverPage);
    STDMETHOD(get_CoverPage)(/*[out, retval]*/ BSTR *pbstrCoverPage);

    STDMETHOD(put_ScheduleTime)(/*[in]*/ DATE dateScheduleTime);
    STDMETHOD(get_ScheduleTime)(/*[out, retval]*/ DATE *pdateScheduleTime);

    STDMETHOD(put_DocumentName)(/*[in]*/ BSTR bstrDocumentName);
    STDMETHOD(get_DocumentName)(/*[out, retval]*/ BSTR *pbstrDocumentName);

    STDMETHOD(put_ReceiptAddress)(/*[in]*/ BSTR bstrReceiptAddress);
    STDMETHOD(get_ReceiptAddress)(/*[out, retval]*/ BSTR *pbstrReceiptAddress);

    STDMETHOD(put_Priority)(/*[in]*/ FAX_PRIORITY_TYPE_ENUM Priority);
    STDMETHOD(get_Priority)(/*[out, retval]*/ FAX_PRIORITY_TYPE_ENUM *pPriority);

    STDMETHOD(put_AttachFaxToReceipt)(/*[in]*/ VARIANT_BOOL bAttachFax);
    STDMETHOD(get_AttachFaxToReceipt)(/*[out, retval]*/ VARIANT_BOOL *pbAttachFax);

    STDMETHOD(putref_TapiConnection)(/*[in]*/ IDispatch* pTapiConnection);
    STDMETHOD(get_TapiConnection)(/*[out, retval]*/ IDispatch **ppTapiConnection);

    STDMETHOD(put_ReceiptType)(/*[in]*/ FAX_RECEIPT_TYPE_ENUM ReceiptType);
    STDMETHOD(get_ReceiptType)(/*[out, retval]*/ FAX_RECEIPT_TYPE_ENUM *pReceiptType);

    STDMETHOD(put_GroupBroadcastReceipts)(/*[in]*/ VARIANT_BOOL bUseGrouping);
    STDMETHOD(get_GroupBroadcastReceipts)(/*[out, retval]*/ VARIANT_BOOL *pbUseGrouping);

    STDMETHOD(put_ScheduleType)(/*[in]*/ FAX_SCHEDULE_TYPE_ENUM ScheduleType);
    STDMETHOD(get_ScheduleType)(/*[out, retval]*/ FAX_SCHEDULE_TYPE_ENUM *pScheduleType);

    STDMETHOD(put_CoverPageType)(/*[in]*/ FAX_COVERPAGE_TYPE_ENUM CoverPageType);
    STDMETHOD(get_CoverPageType)(/*[out, retval]*/ FAX_COVERPAGE_TYPE_ENUM *pCoverPageType);

    STDMETHOD(get_Recipients)(/*[out, retval]*/ IFaxRecipients **ppFaxRecipients);
    STDMETHOD(get_Sender)(/*[out, retval]*/ IFaxSender **ppFaxSender);

    HRESULT FinalConstruct();

private:
    CComPtr<IFaxRecipients> m_Recipients;
    CComPtr<IDispatch>      m_TapiConnection;
    FAX_SCHEDULE_TYPE_ENUM  m_ScheduleType;
    FAX_RECEIPT_TYPE_ENUM   m_ReceiptType;
    FAX_PRIORITY_TYPE_ENUM  m_Priority;
    FAX_COVERPAGE_TYPE_ENUM m_CoverPageType;
    CComBSTR                m_bstrBody;
    CComBSTR                m_bstrCoverPage;
    CComBSTR                m_bstrSubject;
    CComBSTR                m_bstrNote;
    CComBSTR                m_bstrDocName;
    CComBSTR                m_bstrReceiptAddress;
    DATE                    m_ScheduleTime;
    long                    m_CallHandle;
    VARIANT_BOOL            m_bUseGrouping;
    VARIANT_BOOL            m_bAttachFax;

    CComContainedObject2<CFaxSender>  m_Sender;
};

#endif //__FAXDOCUMENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxdocument.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxDocument.cpp

Abstract:

    Implementation of CFaxDocument

Author:

    Iv Garber (IvG) Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxDocument.h"
#include "faxutil.h"


//
//==================== SUBMIT =======================================
//
STDMETHODIMP
CFaxDocument::Submit(
    /*[in]*/ BSTR bstrFaxServerName, 
    /*[out, retval]*/ VARIANT *pvFaxOutgoingJobIDs
)
/*++

Routine name : CFaxDocument::Submit

Routine description:

    Connect to the Fax Server whose name is given as a parameter to the function;
    Submit the Fax Document on this Fax Server;
    Disconnect from the Fax Server.

Author:

    Iv Garber (IvG),    Dec, 2000

Arguments:

    bstrFaxServerName             [in]    - Fax Server Name to connect and send the document through
    ppsfbstrFaxOutgoingJobIDs     [out, retval]    - Result : List of Created Jobs for the Document

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::Submit"), hr, _T("%s"), bstrFaxServerName);

    //
    //  Create Fax Server Object
    //
    CComObject<CFaxServer>  *pFaxServer = NULL;
    hr = CComObject<CFaxServer>::CreateInstance(&pFaxServer);
    if (FAILED(hr) || !pFaxServer)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("new CComObject<CFaxServer>"), hr);
        goto exit;
    }
    pFaxServer->AddRef();

    //
    //  Connect to Fax Server
    //
    hr = pFaxServer->Connect(bstrFaxServerName);
    if (FAILED(hr))
    {
        //
        //  Connect handles the error
        //
        CALL_FAIL(GENERAL_ERR, _T("faxServer.Connect()"), hr);
        goto exit;
    }

    //
    //  Submit Fax Document
    //
    hr = ConnectedSubmit(pFaxServer, pvFaxOutgoingJobIDs);
    if (FAILED(hr))
    {
        //
        //  Submit handles the error 
        //
        CALL_FAIL(GENERAL_ERR, _T("Submit(faxServer,...)"), hr);
        goto exit;
    }

    //
    //  Disconnect
    //
    hr = pFaxServer->Disconnect();
    if (FAILED(hr))
    {
        //
        //  Disconnect handles the error 
        //
        CALL_FAIL(GENERAL_ERR, _T("faxServer.Disconnect())"), hr);
    }

exit:
    if (pFaxServer)
    {
        pFaxServer->Release();
    }

    return hr;
}


//
//================= FINAL CONSTRUCT ===========================
//
HRESULT 
CFaxDocument::FinalConstruct()
/*++

Routine name : CFaxDocument::FinalConstruct

Routine description:

    Final Construct

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::FinalConstruct"), hr);

    //
    //  Initialize instance vars
    //
    m_CallHandle = 0;
    m_ScheduleTime = 0;
    m_Priority = fptNORMAL;
    m_ReceiptType = frtNONE;
    m_ScheduleType = fstNOW;
    m_CoverPageType = fcptNONE;
    m_bAttachFax = VARIANT_FALSE;
    m_bUseGrouping = VARIANT_FALSE;
    return hr;
}

//
//==================== CONNECTED SUBMIT =======================================
//
STDMETHODIMP
CFaxDocument::ConnectedSubmit(
    /*[in]*/ IFaxServer *pFaxServer, 
    /*[out, retval]*/ VARIANT *pvFaxOutgoingJobIDs
)
/*++

Routine name : CFaxDocument::ConnectedSubmit

Routine description:

    Submit the Fax Document on already connected Fax Server

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pFaxServer                    [in]    - Fax Server to Send the Document through
    ppsfbstrFaxOutgoingJobIDs     [out, retval]    - Result : List of Created Jobs for the Document

Return Value:

    Standard HRESULT code

--*/
{

    HRESULT     hr = S_OK;
    bool        bRes = TRUE;
    HANDLE      hFaxHandle = NULL;
    LPCTSTR     lpctstrFileName = NULL;
    DWORD       dwNumRecipients = 0;
    long        lNum = 0L;
    LONG_PTR    i = 0;
    DWORDLONG   dwlMessageId = 0;
    PDWORDLONG  lpdwlRecipientMsgIds = NULL;

    PFAX_PERSONAL_PROFILE       pRecipientsPersonalProfile = NULL;
    FAX_PERSONAL_PROFILE        SenderPersonalProfile;
    PFAX_COVERPAGE_INFO_EX      pCoverPageInfoEx = NULL;
    FAX_JOB_PARAM_EX            JobParamEx;

    SAFEARRAY                   *psa = NULL;

    DBG_ENTER (_T("CFaxDocument::ConnectedSubmit"), hr);

    if (!pFaxServer)
    {
        //
        //  Bad Return OR Interface Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("!pFaxServer"), hr);
        return hr;
    }

    if ( ::IsBadWritePtr(pvFaxOutgoingJobIDs, sizeof(VARIANT)) )
    {
        //
        //  Bad Return OR Interface Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pvFaxOutgoingJobIDs, sizeof(VARIANT))"), hr);
        return hr;
    }

    //
    //  Recipients Collection must exist and must contain at least one item
    //
    if (!m_Recipients)
    {
        hr = E_INVALIDARG;
        Error(IDS_ERROR_NO_RECIPIENTS, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("!m_Recipients"), hr);
        return hr;
    }

    //
    //  Get Fax Server Handle
    //
    CComQIPtr<IFaxServerInner>  pIFaxServerInner(pFaxServer);
    if (!pIFaxServerInner)
    {
        hr = E_FAIL;
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, 
            _T("CComQIPtr<IFaxServerInner>	pIFaxServerInner(pFaxServer)"), 
            hr);
        return hr;
    }

    hr = pIFaxServerInner->GetHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("pIFaxServerInner->GetHandle(&hFaxHandle)"), hr);
        return hr;
    }

    if (hFaxHandle == NULL)
    {
        //
        //  Fax Server is not connected
        //
        hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        Error(IDS_ERROR_SERVER_NOT_CONNECTED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("hFaxHandle==NULL"), hr);
        return hr;
    }

    //
    //  Get File Name of the Document
    //
    if (m_bstrBody && (m_bstrBody.Length() > 0))
    {
        lpctstrFileName = m_bstrBody;
    }
    else
    {
        //
        //  check that Cover Page exists
        //
        if (m_CoverPageType == fcptNONE)
        {
            //
            //  invalid arguments combination
            //
            hr = E_INVALIDARG;
            Error(IDS_ERROR_NOTHING_TO_SUBMIT, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("No Document Body and CoverPageType == fcptNONE"), hr);
            return hr;
        }
    }

    //
    //  Check consistency of Cover Page data
    //
    if ( (m_CoverPageType != fcptNONE) && (m_bstrCoverPage.Length() < 1))
    {
        //
        //  Cover Page File Name is missing
        //
        hr = E_INVALIDARG;
        Error(IDS_ERROR_NOCOVERPAGE, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("CoverPageType != fcptNONE but m_bstrCoverPage is empty."), hr);
        return hr;
    }

    //
    //  Prepare Cover Page data
    //
    if ((m_CoverPageType != fcptNONE) || (m_bstrSubject.Length() > 0))
    {
        pCoverPageInfoEx = PFAX_COVERPAGE_INFO_EX(MemAlloc(sizeof(FAX_COVERPAGE_INFO_EX)));
        if (!pCoverPageInfoEx)
        {
            //
            //  Not enough memory
            //
            hr = E_OUTOFMEMORY;
            Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
            CALL_FAIL(MEM_ERR, _T("MemAlloc(sizeof(FAX_COVERPAGE_INFO_EX)"), hr);
            return hr;
        }

        ZeroMemory(pCoverPageInfoEx, sizeof(FAX_COVERPAGE_INFO_EX));
        pCoverPageInfoEx ->dwSizeOfStruct = sizeof(FAX_COVERPAGE_INFO_EX);

        pCoverPageInfoEx ->lptstrSubject = m_bstrSubject;

        if (m_CoverPageType != fcptNONE)
        {
            pCoverPageInfoEx ->dwCoverPageFormat = FAX_COVERPAGE_FMT_COV;
            pCoverPageInfoEx ->lptstrCoverPageFileName = m_bstrCoverPage;
            pCoverPageInfoEx ->bServerBased = (m_CoverPageType == fcptSERVER);
            pCoverPageInfoEx ->lptstrNote = m_bstrNote;
        }
        else
        {
            //
            //  No Cover Page, only Subject
            //
            pCoverPageInfoEx ->dwCoverPageFormat = FAX_COVERPAGE_FMT_COV_SUBJECT_ONLY;
        }
    }

    //
    //  Call Sender Profile to Bring its Data
    //
    hr = m_Sender.GetSenderProfile(&SenderPersonalProfile);
    if (FAILED(hr))
    {
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("m_Sender.GetSenderProfile(&SenderPersonalProfile)"), hr);
        goto error;
    }

    //
    //  Get Number of Recipients
    //
    hr = m_Recipients->get_Count(&lNum);
    if (FAILED(hr))
    {
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("m_Recipients->get_Count()"), hr);
        goto error;
    }

    if (lNum <= 0)
    {
        hr = E_INVALIDARG;
        Error(IDS_ERROR_NO_RECIPIENTS, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("!m_Recipients"), hr);
        goto error;
    }

    //
    //  TapiConnection / CallHandle support
    //
    if (m_TapiConnection || (m_CallHandle != 0))
    {
        if (lNum > 1)
        {
            //
            //  ONLY ONE Recipient is allowed in this case
            //
            hr = E_INVALIDARG;
            Error(IDS_ERROR_ILLEGAL_RECIPIENTS, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("TapiConnection and/or CallHandle + more than ONE Recipients."), hr);
            goto error;
        }

        if (m_TapiConnection)
        {
            //
            //  Pass TapiConnection to the Fax Service
            //
            JobParamEx.dwReserved[0] = 0xFFFF1234;
            JobParamEx.dwReserved[1] = DWORD_PTR(m_TapiConnection.p);
        }
    }

    //
    //  Total number of Recipients
    //
    dwNumRecipients = lNum;

    //
    //  Get Array of Recipient Personal Profiles
    //
    pRecipientsPersonalProfile = PFAX_PERSONAL_PROFILE(MemAlloc(sizeof(FAX_PERSONAL_PROFILE) * lNum));
    if (!pRecipientsPersonalProfile)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("MemAlloc(sizeof(FAX_PERSONAL_PROFILE) * lNum)"), hr);
        goto error;
    }

    for ( i = 1 ; i <= lNum ; i++ )
    {
        //
        //  Get Next Recipient
        //
        CComPtr<IFaxRecipient>  pCurrRecipient = NULL;
        hr = m_Recipients->get_Item(i, &pCurrRecipient);
        if (FAILED(hr))
        {
            Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("m_Recipients->get_Item(i, &pCurrRecipient)"), hr);
            goto error;
        }

        //
        //  Get its Data
        //
        BSTR    bstrName = NULL;
        BSTR    bstrFaxNumber = NULL;

        hr = pCurrRecipient->get_Name(&bstrName);
        if (FAILED(hr))
        {
            Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("pCurrRecipient->get_Name(&bstrName)"), hr);
            goto error;
        }

        hr = pCurrRecipient->get_FaxNumber(&bstrFaxNumber);
        if (FAILED(hr))
        {
            Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("pCurrRecipient->get_FaxNumber(&bstrFaxNumber)"), hr);
            goto error;
        }

        //
        //  Store the data to pass at Fax Submit
        //
        FAX_PERSONAL_PROFILE    currProfile = {0};
        currProfile.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
        currProfile.lptstrFaxNumber = bstrFaxNumber;
        currProfile.lptstrName = bstrName;

        *(pRecipientsPersonalProfile + i - 1) = currProfile;
    }

    //
    //  Fill Job Params 
    //
    JobParamEx.dwSizeOfStruct = sizeof(FAX_JOB_PARAM_EX);
    JobParamEx.lptstrReceiptDeliveryAddress = m_bstrReceiptAddress;
    JobParamEx.Priority = FAX_ENUM_PRIORITY_TYPE(m_Priority);
    JobParamEx.lptstrDocumentName = m_bstrDocName;
    JobParamEx.dwScheduleAction = m_ScheduleType;
    JobParamEx.dwPageCount = 0;
    JobParamEx.hCall = m_CallHandle;    //  either Zero or Valid Value

    if ((m_bUseGrouping == VARIANT_TRUE) && (dwNumRecipients > 1))
    {
         JobParamEx.dwReceiptDeliveryType = m_ReceiptType | DRT_GRP_PARENT;
    }
    else
    {
         JobParamEx.dwReceiptDeliveryType = m_ReceiptType;
    }

    //
    //  Add AttachFaxToReceipt flag if applicable.
    //
    //  The conditions are :
    //      1.  m_bAttachFax is set to VARIANT_TRUE
    //      2.  ReceiptType is MAIL 
    //      3.  The next case is NOT the current one :
    //              m_bUseGrouping is set to VARIANT_TRUE
    //              no Body
    //              Number of Recipients is more than ONE
    //
    if ( (m_bAttachFax == VARIANT_TRUE) 
        &&
         (m_ReceiptType == frtMAIL) 
        &&
         ((m_bUseGrouping == VARIANT_FALSE) || (m_bstrBody) || (dwNumRecipients == 1))
       ) 
    {
        JobParamEx.dwReceiptDeliveryType |= DRT_ATTACH_FAX;
    }

    if (m_ScheduleType == fstSPECIFIC_TIME)
    {
        if (m_ScheduleTime == 0)
        {
            //
            //  Invalid Combination
            //
            hr = E_INVALIDARG;
            Error(IDS_ERROR_SCHEDULE_TYPE, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, 
                _T("m_ScheduleType==fstSPECIFIC_TIME but m_ScheduleTime==0"), 
                hr);
            goto error;
        }

        SYSTEMTIME  ScheduleTime;

        if (TRUE != VariantTimeToSystemTime(m_ScheduleTime, &ScheduleTime))
        {
            //
            //  VariantTimeToSystemTime failed
            //
            hr = E_INVALIDARG;
            Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("VariantTimeToSystemTime"), hr);
            goto error;
        }

        JobParamEx.tmSchedule = ScheduleTime;
    }

    lpdwlRecipientMsgIds = PDWORDLONG(MemAlloc(sizeof(DWORDLONG) * lNum));
    if (!lpdwlRecipientMsgIds)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("MemAlloc(sizeof(DWORDLONG) * lNum"), hr);
        goto error;
    }

    if ( FALSE == FaxSendDocumentEx(hFaxHandle, 
        lpctstrFileName, 
        pCoverPageInfoEx, 
        &SenderPersonalProfile,
        dwNumRecipients,
        pRecipientsPersonalProfile,
        &JobParamEx,
        &dwlMessageId,
        lpdwlRecipientMsgIds) )
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxSendDocumentEx()"), hr);
        goto error;
    }

    //
    //  Put Received Job Ids into SafeArray
    //
    psa = ::SafeArrayCreateVector(VT_BSTR, 0, lNum);
    if (!psa)
    {
        //
        //  Not Enough Memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("::SafeArrayCreate()"), hr);
        goto error;
    }

    BSTR *pbstr;
    hr = ::SafeArrayAccessData(psa, (void **) &pbstr);
    if (FAILED(hr))
    {
        //
        //  Failed to access safearray
        //
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayAccessData()"), hr);
        goto error;
    }

    TCHAR       tcBuffer[25];
    for ( i = 0 ; i < lNum ; i++ )
    {
        ::_i64tot(lpdwlRecipientMsgIds[i], tcBuffer, 16);
        pbstr[i] = ::SysAllocString(tcBuffer);
        if (pbstr[i] == NULL)
        {
            //
            //  Not Enough Memory
            //
            hr = E_OUTOFMEMORY;
            Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
            CALL_FAIL(MEM_ERR, _T("::SysAllocString()"), hr);
            goto error;
        }
    }

    hr = SafeArrayUnaccessData(psa);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayUnaccessData(psa)"), hr);
    }

    VariantInit(pvFaxOutgoingJobIDs);
    pvFaxOutgoingJobIDs->vt = VT_BSTR | VT_ARRAY;
    pvFaxOutgoingJobIDs->parray = psa;
    goto ok;

error:
    //
    //  Delete SafeArray only in the case on an Error
    //
    if (psa)
    {
        SafeArrayDestroy(psa);
    }

ok:
    if (pCoverPageInfoEx) 
    {
        MemFree(pCoverPageInfoEx);
    }

    if (pRecipientsPersonalProfile) 
    {
        for (i = 0 ; i < dwNumRecipients ; i++ )
        {
            //
            //  Free the Name and the Fax Number of each Recipient.
            //
            //  Notice these are BSTRs (although in the FAX_PERSONAL_PROFILE structure
            //  they are treated as LPCTSTRs) since we get them by calling 
            //  pCurrRecipient->get_Name() and pCurrRecipient->get_FaxNumber().
            //
            BSTR bstrName = (BSTR)(pRecipientsPersonalProfile[i].lptstrName);
            BSTR bstrFaxNumber = (BSTR)(pRecipientsPersonalProfile[i].lptstrFaxNumber);
            ::SysFreeString(bstrName);
            ::SysFreeString(bstrFaxNumber);
        }
        MemFree(pRecipientsPersonalProfile);
    }

    if (lpdwlRecipientMsgIds)
    {
        MemFree(lpdwlRecipientMsgIds);
    }

    return hr;
}

//
//==================== INTERFACE SUPPORT ERROR INFO =======================
//
STDMETHODIMP
CFaxDocument::InterfaceSupportsErrorInfo (
    REFIID riid
)
/*++

Routine name : CFaxRecipients::InterfaceSupportsErrorInfo

Routine description:

    ATL's implementation of Support Error Info

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    riid                          [in]    - Interface ID

Return Value:

    Standard HRESULT code

--*/
{
    static const IID* arr[] = 
    {
        &IID_IFaxDocument
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

//
//========================= GET OBJECTS ======================================
//
STDMETHODIMP 
CFaxDocument::get_Sender (
    IFaxSender **ppFaxSender
)
/*++

Routine name : CFaxDocument::get_Sender

Routine description:

    Return Default Sender Information

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    ppFaxSender            [out]    - current Sender object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::get_Sender"), hr);

    if (::IsBadWritePtr(ppFaxSender, sizeof(IFaxSender *)))
    {
        //
        //  Got a bad return pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    //
    //  Sender Profile is created at Final Construct
    //
    hr = m_Sender.QueryInterface(ppFaxSender);
    if (FAILED(hr))
    {
        //
        //  Failed to copy interface
        //
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("CCom<IFaxSender>::CopyTo()"), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::get_Recipients (
    IFaxRecipients **ppFaxRecipients
)
/*++

Routine name : CFaxDocument::get_Recipients

Routine description:

    Return Recipients Collection

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    ppFaxRecipients               [out]    - The Recipients Collection

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::get_Recipients"), hr);

    if (::IsBadWritePtr(ppFaxRecipients, sizeof(IFaxRecipients *)))
    {
        //
        //  Got a bad return pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    if (!(m_Recipients))
    {
        //
        // Create collection on demand only once.
        //
        hr = CFaxRecipients::Create(&m_Recipients);
        if (FAILED(hr))
        {
            //
            //  Failure to create recipients collection
            //
            Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("CFaxRecipients::Create"), hr);
            return hr;
        }
    }

    hr = m_Recipients.CopyTo(ppFaxRecipients);
    if (FAILED(hr))
    {
        //
        //  Failed to copy Interface
        //
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("CComBSTR::CopyTo"), hr);
        return hr;
    }

    return hr;
}

//
//========================= PUT BSTR ATTRIBUTES ========================
//
STDMETHODIMP 
CFaxDocument::put_Body (
    BSTR bstrBody
)
/*++

Routine name : CFaxDocument::put_Body

Routine description:

    Set Body of the Document. Receives full path to the file to send through fax server.

Author:

    Iv Garber (IvG),    May, 2001

Arguments:

    bstrBody                 [in]    - the Body of the Document.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_Body"), hr, _T("%s"), bstrBody);

    m_bstrBody = bstrBody;
    if (bstrBody && !m_bstrBody)
    {
        //
        //  not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::put_CoverPage (
    BSTR bstrCoverPage
)
/*++

Routine name : CFaxDocument::put_CoverPage

Routine description:

    Set Cover Page

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bstrCoverPage                 [in]    - new Cover Page value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_CoverPage"), hr, _T("%s"), bstrCoverPage);

    m_bstrCoverPage = bstrCoverPage;
    if (bstrCoverPage && !m_bstrCoverPage)
    {
        //
        //  not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::put_Subject ( 
    BSTR bstrSubject
)
/*++

Routine name : CFaxDocument::put_Subject

Routine description:

    Set Subject of the Fax Document

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bstrSubject                   [in]    - The new Subject value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_Subject"), hr, _T("%s"), bstrSubject);

    m_bstrSubject = bstrSubject;
    if (bstrSubject && !m_bstrSubject)
    {
        //
        //  not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::put_Note (
    BSTR bstrNote
)
/*++

Routine name : CFaxDocument::put_Note

Routine description:

    Set Note for the Document

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bstrNote                     [in]    - the new Note field

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_Note"), hr, _T("%s"), bstrNote);

    m_bstrNote = bstrNote;
    if (bstrNote && !m_bstrNote)
    {
        //
        //  not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::put_DocumentName (
    BSTR bstrDocumentName
)
/*++

Routine name : CFaxDocument::put_DocumentName

Routine description:

    Set the Name of the Document

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bstrDocumentName              [in]    - the new Name of the Document

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_DocumentName"), 
        hr, 
        _T("%s"),
        bstrDocumentName);

    m_bstrDocName = bstrDocumentName;
    if (bstrDocumentName && !m_bstrDocName)
    {
        //  
        //  not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::put_ReceiptAddress (
    BSTR bstrReceiptAddress
)
/*++

Routine name : CFaxDocument::put_ReceiptAddress

Routine description:

    Set Receipt Address

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bstrReceiptAddress            [in]    - the Receipt Address

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_ReceiptAddress"), 
        hr, 
        _T("%s"),
        bstrReceiptAddress);

    m_bstrReceiptAddress = bstrReceiptAddress;
    if (bstrReceiptAddress && !m_bstrReceiptAddress)
    {
        //  
        //  not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

//
//========================= GET BSTR ATTRIBUTES ========================
//
STDMETHODIMP 
CFaxDocument::get_Body (
    BSTR *pbstrBody
)
/*++

Routine name : CFaxDocument::get_Body

Routine description:

    Returns full path to the file containing the Body of the Document to send.

Author:

    Iv Garber (IvG),    May, 2001

Arguments:

    pbstrBody           [out]    - ptr to place to put the Body path 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_Body"), hr);

    hr = GetBstr(pbstrBody, m_bstrBody);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_CoverPage (
    BSTR *pbstrCoverPage
)
/*++

Routine name : CFaxDocument::get_CoverPage

Routine description:

    Return Cover Page Path

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbstrCoverPage                [out]    - ptr to place to put the Cover Page Path

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_CoverPage"), hr);

    hr = GetBstr(pbstrCoverPage, m_bstrCoverPage);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_Subject (
    BSTR *pbstrSubject
)
/*++

Routine name : CFaxDocument::get_Subject

Routine description:

    Return Subject

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbstrSubject                  [out]    - The Document's Subject

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_Subject"), hr);

    hr = GetBstr(pbstrSubject, m_bstrSubject);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_Note(
    BSTR *pbstrNote
)
/*++

Routine name : CFaxDocument::get_Note

Routine description:

    Return Note field of the Cover Page

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbstrNote                    [out]    - the Note

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxDocument::get_Note"), hr);

    hr = GetBstr(pbstrNote, m_bstrNote);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_DocumentName(
    BSTR *pbstrDocumentName
)
/*++

Routine name : CFaxDocument::get_DocumentName

Routine description:

    Return Document Name

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbstrDocumentName             [out]    - Name of the Document

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_Document Name"), hr);

    hr = GetBstr(pbstrDocumentName, m_bstrDocName);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_ReceiptAddress(
    BSTR *pbstrReceiptAddress
)
/*++

Routine name : CFaxDocument::get_ReceiptAddress

Routine description:

    Return Receipt Address

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbstrReceiptAddress           [out]    - Receipt Address

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_ReceiptAddress"), hr);

    hr = GetBstr(pbstrReceiptAddress, m_bstrReceiptAddress);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

//
//========================= GET & PUT OTHER ATTRIBUTES ========================
//
STDMETHODIMP 
CFaxDocument::get_ScheduleTime(
    DATE *pdateScheduleTime
)
/*++

Routine name : CFaxDocument::get_ScheduleTime

Routine description:

    Return Schedule Time

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pdateScheduleTime             [out]    - the Schedule Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxDocument::get_ScheduleTime"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateScheduleTime, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pdateScheduleTime = m_ScheduleTime;
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_ScheduleTime(
    DATE dateScheduleTime
)
/*++

Routine name : CFaxDocument::put_ScheduleTime

Routine description:

    Return Schedule Time

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    dateScheduleTime              [in]    - the new Schedule Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_ScheduleTime"),
        hr, 
        _T("%f"), 
        dateScheduleTime);

    m_ScheduleTime = dateScheduleTime;
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_CallHandle(
    long *plCallHandle
)
/*++

Routine name : CFaxDocument::get_CallHandle

Routine description:

    Return Call Handle

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    plCallHandle                  [out]    - Call Handle

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_CallHandle"), hr);

    hr = GetLong(plCallHandle, m_CallHandle);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_CallHandle(
    long lCallHandle
)
/*++

Routine name : CFaxDocument::put_CallHandle

Routine description:

    Set Call Handle

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    lCallHandle                   [in]    - Call Handle to Set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_CallHandle"), hr, _T("%ld"), lCallHandle);

    m_CallHandle = lCallHandle;
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_CoverPageType(
    FAX_COVERPAGE_TYPE_ENUM *pCoverPageType
)
/*++

Routine name : CFaxDocument::get_CoverPageType

Routine description:

    Returns Type of the Cover Page used : whether it is Local or Server Cover Page,
        or the Cover Page is not used.

Author:

    Iv Garber (IvG),    Nov, 2000

Arguments:

    pCoverPageType          [out]    - ptr to the place to put the Cover Page Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_CoverPageType"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pCoverPageType, sizeof(FAX_COVERPAGE_TYPE_ENUM)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pCoverPageType = m_CoverPageType;
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_CoverPageType(
    FAX_COVERPAGE_TYPE_ENUM CoverPageType
)
/*++

Routine name : CFaxDocument::put_CoverPageType

Routine description:

    Set Type of the Cover Page : either Local or Server or do not use Cover Page.

Author:

    Iv Garber (IvG),    Nov, 2000

Arguments:

    CoverPageType           [in]    - the new Value of the Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_CoverPageType"), hr, _T("%ld"), CoverPageType);

    if (CoverPageType < fcptNONE || CoverPageType > fcptSERVER)
    {
        //
        //  Cover Page Type is wrong
        //
        hr = E_INVALIDARG;
        Error(IDS_ERROR_OUTOFRANGE, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("Cover Page Type is out of range"), hr);
        return hr;
    }

    m_CoverPageType = FAX_COVERPAGE_TYPE_ENUM(CoverPageType);
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_ScheduleType(
    FAX_SCHEDULE_TYPE_ENUM *pScheduleType
)
/*++

Routine name : CFaxDocument::get_ScheduleType

Routine description:

    Return Schedule Type

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pScheduleType                 [out]    - ptr to put the Current Schedule Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_ScheduleType"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pScheduleType, sizeof(FAX_SCHEDULE_TYPE_ENUM)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pScheduleType = m_ScheduleType;
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_ScheduleType(
    FAX_SCHEDULE_TYPE_ENUM ScheduleType
)
/*++

Routine name : CFaxDocument::put_ScheduleType

Routine description:

    Set Schedule Type

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    ScheduleType                  [in]    - new Schedule Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_ScheduleType"), hr, _T("Type=%d"), ScheduleType);

    if (ScheduleType < fstNOW || ScheduleType > fstDISCOUNT_PERIOD)
    {
        //
        //  Schedule Type is wrong
        //
        hr = E_INVALIDARG;
        Error(IDS_ERROR_OUTOFRANGE, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("Schedule Type is out of range"), hr);
        return hr;
    }

    m_ScheduleType = FAX_SCHEDULE_TYPE_ENUM(ScheduleType);
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_ReceiptType(
    FAX_RECEIPT_TYPE_ENUM *pReceiptType
)
/*++

Routine name : CFaxDocument::get_ReceiptType

Routine description:

    Return Receipt Type

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pReceiptType                  [out]    - ptr to put the Current Receipt Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_ReceiptType"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pReceiptType, sizeof(FAX_SCHEDULE_TYPE_ENUM)))
    {
        //  
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pReceiptType = m_ReceiptType;
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_ReceiptType(
    FAX_RECEIPT_TYPE_ENUM ReceiptType
)
/*++

Routine name : CFaxDocument::put_ReceiptType

Routine description:

    Set Receipt Type

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    ReceiptType                   [in]    - new Receipt Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_ReceiptType"), hr, _T("%d"), ReceiptType);

    if ((ReceiptType != frtNONE) && (ReceiptType != frtMSGBOX) && (ReceiptType != frtMAIL))
    {
        //  
        //  Out of range
        //
        hr = E_INVALIDARG;
        Error(IDS_ERROR_OUTOFRANGE, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("Receipt Type is out of range. It may be one of the values allowed by the Server."), hr);
        return hr;
    }

    m_ReceiptType = FAX_RECEIPT_TYPE_ENUM(ReceiptType);
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_AttachFaxToReceipt(
    VARIANT_BOOL *pbAttachFax
)
/*++

Routine name : CFaxDocument::get_AttachFaxToReceipt

Routine description:

    Return Flag indicating whether or not Fax Service should Attach Fax To the Receipt

Author:

    Iv Garber (IvG),    Dec, 2000

Arguments:

    pbAttachFax         [out]    - the Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::get_AttachFaxToReceipt"), hr);

    hr = GetVariantBool(pbAttachFax, m_bAttachFax);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_AttachFaxToReceipt(
    VARIANT_BOOL bAttachFax
)
/*++

Routine name : CFaxDocument::put_AttachFaxToReceipt

Routine description:

    Set whether Fax Server should attach the fax to the receipt

Author:

    Iv Garber (IvG),    Dec, 2000

Arguments:

    bAttachFax              [in]    - the new value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_AttachFaxToReceipt"), hr, _T("%d"), bAttachFax);

    m_bAttachFax = bAttachFax;
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_GroupBroadcastReceipts(
    VARIANT_BOOL *pbUseGrouping
)
/*++

Routine name : CFaxDocument::get_GroupBroadcastReceipts

Routine description:

    Return Flag indicating whether or not Broadcast Receipts are Grouped

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbUseGrouping                  [out]    - the Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::get_GroupBroadcastReceipts"), hr);

    hr = GetVariantBool(pbUseGrouping, m_bUseGrouping);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_GroupBroadcastReceipts(
    VARIANT_BOOL bUseGrouping
)
/*++

Routine name : CFaxDocument::put_GroupBroadcastReceipts

Routine description:

    Set Group Broadcast Receipts Flag

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bUseGrouping                   [in]    - the new value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_GroupBroadcastReceipts"), hr, _T("%d"), bUseGrouping);

    m_bUseGrouping = bUseGrouping;
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_Priority(
    FAX_PRIORITY_TYPE_ENUM *pPriority
)
/*++

Routine name : CFaxDocument::get_Priority

Routine description:

    Return Current Priority of the Document

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pPriority                     [out]    - the Current Priority

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxDocument::get_Priority"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pPriority, sizeof(FAX_PRIORITY_TYPE_ENUM)))
    {
        //  
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pPriority = m_Priority;
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_Priority(
    FAX_PRIORITY_TYPE_ENUM Priority
)
/*++

Routine name : CFaxDocument::put_Priority

Routine description:

    Set new Priority for the Document

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    Priority                      [in]    - the new Priority

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_Priority"), hr, _T("%d"), Priority);

    if (Priority < fptLOW || Priority > fptHIGH)
    {
        //
        //  Out of the Range
        //
        hr = E_INVALIDARG;
        Error(IDS_ERROR_OUTOFRANGE, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("Priority is out of the Range"), hr);
        return hr;
    }

    m_Priority = FAX_PRIORITY_TYPE_ENUM(Priority);
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_TapiConnection(
    IDispatch **ppTapiConnection
)
/*++

Routine name : CFaxDocument::get_TapiConnection

Routine description:

    Return Tapi Connection

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    ppTapiConnection              [out]    - the Tapi Connection Interface

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_TapiConnection"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(ppTapiConnection, sizeof(IDispatch *)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("IsBadWritePtr()"), hr);
        return hr;
    }

    hr = m_TapiConnection.CopyTo(ppTapiConnection);
    if (FAILED(hr))
    {
        //  
        //  Failed to Copy Interface
        //
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("CComPtr<IDispatch>::CopyTo()"), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::putref_TapiConnection(
    IDispatch *pTapiConnection
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::putref_TapiConnection"), hr, _T("%ld"), pTapiConnection);

    if (!pTapiConnection) 
    {
        //  
        //  Got NULL interface
        //  
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("!pTapiConnection"), hr);
        return hr;
    }

    m_TapiConnection = pTapiConnection;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxeventlogging.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxEventLogging.h

Abstract:

	Declaration of the CFaxEventLogging Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXEVENTLOGGING_H_
#define __FAXEVENTLOGGING_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//========================= EVENT LOGGING ======================================
//
class ATL_NO_VTABLE CFaxEventLogging : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxEventLogging, &IID_IFaxEventLogging, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxEventLogging() : CFaxInitInner(_T("FAX EVENT LOGGING")),
        m_bInited(false),
        m_InitLevel(fllNONE),
        m_OutboundLevel(fllNONE),
        m_InboundLevel(fllNONE),
        m_GeneralLevel(fllNONE)
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXEVENTLOGGING)
DECLARE_NOT_AGGREGATABLE(CFaxEventLogging)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxEventLogging)
	COM_INTERFACE_ENTRY(IFaxEventLogging)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
    STDMETHOD(Save)();
    STDMETHOD(Refresh)();

	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(put_InitEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM InitEventLevel);
    STDMETHOD(get_InitEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pInitEventLevel);
    STDMETHOD(put_InboundEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM InboundEventLevel);
    STDMETHOD(put_GeneralEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM GeneralEventsLevel);
    STDMETHOD(get_InboundEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pInboundEventLevel);
    STDMETHOD(put_OutboundEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM OutboundEventsLevel);
    STDMETHOD(get_GeneralEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pGeneralEventsLevel);
    STDMETHOD(get_OutboundEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pOutboundEventsLevel);

private:
    bool                m_bInited;
    FAX_LOG_LEVEL_ENUM  m_InitLevel;
    FAX_LOG_LEVEL_ENUM  m_OutboundLevel;
    FAX_LOG_LEVEL_ENUM  m_InboundLevel;
    FAX_LOG_LEVEL_ENUM  m_GeneralLevel;
    CComBSTR            m_bstrInitName;
    CComBSTR            m_bstrOutboundName;
    CComBSTR            m_bstrInboundName;
    CComBSTR            m_bstrGeneralName;

    STDMETHOD(GetLevel)(FAX_ENUM_LOG_CATEGORIES faxCategory, FAX_LOG_LEVEL_ENUM *faxLevel);
    STDMETHOD(PutLevel)(FAX_ENUM_LOG_CATEGORIES faxCategory, FAX_LOG_LEVEL_ENUM faxLevel);
};

#endif //__FAXEVENTLOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxfolders.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxFolders.cpp

Abstract:

	Implementation of CFaxFolders

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxFolders.h"


//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxFolders::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxFolders::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Interface Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Reference of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxFolders,
		&IID_IFaxOutgoingQueue,     // Contained object
		&IID_IFaxIncomingQueue,     // Contained object
		&IID_IFaxOutgoingArchive,   // Contained object
		&IID_IFaxIncomingArchive    // Contained object
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}	//	CFaxFolders::InterfaceSupportErrorInfo

//
//==================== GET OUTGOING QUEUE ====================================
//
STDMETHODIMP 
CFaxFolders::get_OutgoingQueue(
	IFaxOutgoingQueue **ppOutgoingQueue
)
/*++

Routine name : CFaxFolders::get_OutgoingQueue

Routine description:

	Return OutgoingQueue 

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppOutgoingQueue                          [out]    - ptr to put the IOutgoingQueue Ifc

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxFolders::get_OutgoingQueue"), hr);

    CObjectHandler<CFaxOutgoingQueue, IFaxOutgoingQueue>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppOutgoingQueue, &m_pOutgoingQueue, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxFolders, 
			GetErrorMsgId(hr), 
			IID_IFaxFolders, 
			hr);
        return hr;
    }
    return hr;
}	//	CFaxFolders::get_OutgoingQueue()

//
//==================== GET INCOMING ARCHIVE ====================================
//
STDMETHODIMP 
CFaxFolders::get_IncomingArchive(
	IFaxIncomingArchive **ppIncomingArchive
)
/*++

Routine name : CFaxFolders::get_IncomingArchive

Routine description:

	Return Incoming Archive

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pIncomingArchive                          [out]    - The ptr to the place to put IncomingArchive

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxFolders::get_IncomingArchive"), hr);

    CObjectHandler<CFaxIncomingArchive, IFaxIncomingArchive>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppIncomingArchive, &m_pIncomingArchive, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxFolders, 
			GetErrorMsgId(hr), 
			IID_IFaxFolders, 
			hr);
        return hr;
    }
    return hr;
}	//	CFaxFolders::get_IncomingArchive()

//
//==================== GET INCOMING QUEUE ====================================
//
STDMETHODIMP 
CFaxFolders::get_IncomingQueue(
	IFaxIncomingQueue **ppIncomingQueue
)
/*++
Routine name : CFaxFolders::get_IncomingQueue

Routine description:

	Return Incoming Queue

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pIncomingQueue                         [out]    - The Incoming Queue

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxFolders::get_IncomingQueue"), hr);

	CObjectHandler<CFaxIncomingQueue, IFaxIncomingQueue>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppIncomingQueue, &m_pIncomingQueue, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxFolders, 
			GetErrorMsgId(hr), 
			IID_IFaxFolders, 
			hr);
        return hr;
    }
    return hr;
}	//	CFaxFolders::get_IncomingQueue()

//
//==================== GET OUTGOING ARCHIVE ====================================
//
STDMETHODIMP 
CFaxFolders::get_OutgoingArchive(
	IFaxOutgoingArchive **ppOutgoingArchive
)
/*++

Routine name : CFaxFolders::get_OutgoingArchive

Routine description:

	Return Outgoing Archive Object

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pOutgoingArchive                          [out]    - The ptr to put Outgoing Archive Object

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxFolders::get_OutgoingArchive"), hr);

	CObjectHandler<CFaxOutgoingArchive, IFaxOutgoingArchive>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppOutgoingArchive, &m_pOutgoingArchive, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxFolders, 
			GetErrorMsgId(hr), 
			IID_IFaxFolders, 
			hr);
        return hr;
    }
    return hr;
}	//	CFaxFolders::get_OutgoingArchive()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxfolders.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxFolders.h

Abstract:

	Declaration of the CFaxFolders Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXFOLDERS_H_
#define __FAXFOLDERS_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include "FaxOutgoingQueue.h"
#include "FaxIncomingArchive.h"
#include "FaxIncomingQueue.h"
#include "FaxOutgoingArchive.h"


//
//===================== FAX FOLDERS ========================================
//
class ATL_NO_VTABLE CFaxFolders : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxFolders, &IID_IFaxFolders, &LIBID_FAXCOMEXLib>,
	public CFaxInitInner
{
public:
    CFaxFolders() : CFaxInitInner(_T("FAX FOLDERS")),
        m_pOutgoingQueue(NULL),
        m_pIncomingQueue(NULL),
        m_pIncomingArchive(NULL),
        m_pOutgoingArchive(NULL)
	{}
    ~CFaxFolders()
    {
        //
        //  free all the allocated objects
        //
        if (m_pOutgoingQueue) 
        {
            delete m_pOutgoingQueue;
        }

        if (m_pIncomingQueue) 
        {
            delete m_pIncomingQueue;
        }

        if (m_pOutgoingArchive) 
        {
            delete m_pOutgoingArchive;
        }

        if (m_pIncomingArchive) 
        {
            delete m_pIncomingArchive;
        }
    }


DECLARE_REGISTRY_RESOURCEID(IDR_FAXFOLDERS)
DECLARE_NOT_AGGREGATABLE(CFaxFolders)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxFolders)
	COM_INTERFACE_ENTRY(IFaxFolders)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

// Interfaces 
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

STDMETHOD(get_OutgoingQueue)(/*[out, retval]*/ IFaxOutgoingQueue **pOutgoingQueue);
STDMETHOD(get_IncomingQueue)(/*[out, retval]*/ IFaxIncomingQueue **pIncomingQueue);
STDMETHOD(get_IncomingArchive)(/*[out, retval]*/ IFaxIncomingArchive **pIncomingArchive);
STDMETHOD(get_OutgoingArchive)(/*[out, retval]*/ IFaxOutgoingArchive **pOutgoingArchive);

private:
	CComContainedObject2<CFaxOutgoingQueue>      *m_pOutgoingQueue;
	CComContainedObject2<CFaxIncomingArchive>    *m_pIncomingArchive;
	CComContainedObject2<CFaxIncomingQueue>      *m_pIncomingQueue;
	CComContainedObject2<CFaxOutgoingArchive>    *m_pOutgoingArchive;
};

#endif //__FAXFOLDERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxinboundrouting.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRouting.cpp

Abstract:

	Implementation of CFaxInboundRouting Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxInboundRouting.h"

//
//================== GET METHODS COLLECTION OBJECT ==============================
//
STDMETHODIMP 
CFaxInboundRouting::GetMethods(
    IFaxInboundRoutingMethods **ppMethods
)
/*++

Routine name : CFaxInboundRouting::GetMethods

Routine description:

	Return Methods Collection Object

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	ppMethods            [out]    - Ptr to the Place for Methods Collection Object 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxInboundRouting::GetMethods"), hr);

    CObjectHandler<CFaxInboundRoutingMethods, IFaxInboundRoutingMethods>    ObjectCreator;
    hr = ObjectCreator.GetObject(ppMethods, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRouting, GetErrorMsgId(hr), IID_IFaxInboundRouting, hr);
        return hr;
    }
    return hr;
}

//
//================== GET EXTENSIONS COLLECTION OBJECT ==============================
//
STDMETHODIMP 
CFaxInboundRouting::GetExtensions(
    IFaxInboundRoutingExtensions **ppExtensions
)
/*++

Routine name : CFaxInboundRouting::GetExtensions

Routine description:

	Return Extensions Collection Object

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	ppExtensions            [out]    - Ptr to the Place for Extensions Collection Object 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxInboundRouting::GetExtensions"), hr);

    CObjectHandler<CFaxInboundRoutingExtensions, IFaxInboundRoutingExtensions>    ObjectCreator;
    hr = ObjectCreator.GetObject(ppExtensions, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRouting, GetErrorMsgId(hr), IID_IFaxInboundRouting, hr);
        return hr;
    }
    return hr;
}

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxInboundRouting::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxInboundRouting::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxInboundRouting
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxinboundrouting.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRouting.h

Abstract:

	Declaration of the CFaxInboundRouting Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXINBOUNDROUTING_H_
#define __FAXINBOUNDROUTING_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include "FaxInboundRoutingExtensions.h"
#include "FaxInboundRoutingMethods.h"

//
// ================ INBOUND ROUTING ==================================================
//  Both IRExtensions and IRMethods Collections are not cached.
//  Rather they are created each time the InboundRouting is asked for them.
//  To be sure that the Server Object is up during their lifetime, they do 
//      AddRef() on the Server Ojbect at their Init() function.
//
class ATL_NO_VTABLE CFaxInboundRouting : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxInboundRouting, &IID_IFaxInboundRouting, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxInboundRouting() : CFaxInitInner(_T("FAX INBOUND ROUTING"))
	{}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINBOUNDROUTING)
DECLARE_NOT_AGGREGATABLE(CFaxInboundRouting)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxInboundRouting)
	COM_INTERFACE_ENTRY(IFaxInboundRouting)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(GetExtensions)(/*[out, retval]*/ IFaxInboundRoutingExtensions **ppExtensions);
    STDMETHOD(GetMethods)(/*[out, retval]*/ IFaxInboundRoutingMethods **ppMethods);
};

#endif //__FAXINBOUNDROUTING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxinboundroutingextension.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingExtension.h

Abstract:

	Declaration of the CFaxInboundRoutingExtension class.

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#ifndef __FAXINBOUNDROUTINGEXTENSION_H_
#define __FAXINBOUNDROUTINGEXTENSION_H_

#include "resource.h"       // main symbols
#include "FaxLocalPtr.h"

//
//================== FAX INBOUND ROUTING EXTENSION ==========================================
//  This is a READ-ONLY object. At its Init it gots all its data. It never uses FaxServer.
//
class ATL_NO_VTABLE CFaxInboundRoutingExtension : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxInboundRoutingExtension, &IID_IFaxInboundRoutingExtension, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner    //  for Debug purposes only
{
public:
    CFaxInboundRoutingExtension() : CFaxInitInner(_T("FAX INBOUND ROUTING EXTENSION")),
        m_psaMethods(NULL)
	{}

    ~CFaxInboundRoutingExtension()
    {
        HRESULT     hr = S_OK;
        if (m_psaMethods)
        {
            hr = SafeArrayDestroy(m_psaMethods);
            if (FAILED(hr))
            {
                DBG_ENTER(_T("CFaxInboundRoutingExtension::Dtor"));
                CALL_FAIL(GENERAL_ERR, _T("SafeArrayDestroy(m_psaMethods)"), hr);
            }
        }
    }


DECLARE_REGISTRY_RESOURCEID(IDR_FAXINBOUNDROUTINGEXTENSION)
DECLARE_NOT_AGGREGATABLE(CFaxInboundRoutingExtension)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxInboundRoutingExtension)
	COM_INTERFACE_ENTRY(IFaxInboundRoutingExtension)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_Debug)(/*[out, retval]*/ VARIANT_BOOL *pbDebug);
    STDMETHOD(get_MajorBuild)(/*[out, retval]*/ long *plMajorBuild);
    STDMETHOD(get_MinorBuild)(/*[out, retval]*/ long *plMinorBuild);
    STDMETHOD(get_ImageName)(/*[out, retval]*/ BSTR *pbstrImageName);
    STDMETHOD(get_UniqueName)(/*[out, retval]*/ BSTR *pbstrUniqueName);
    STDMETHOD(get_MajorVersion)(/*[out, retval]*/ long *plMajorVersion);
    STDMETHOD(get_MinorVersion)(/*[out, retval]*/ long *plMinorVersion);
    STDMETHOD(get_InitErrorCode)(/*[out, retval]*/ long *plInitErrorCode);
    STDMETHOD(get_FriendlyName)(/*[out, retval]*/ BSTR *pbstrFriendlyName);
    STDMETHOD(get_Status)(/*[out, retval]*/ FAX_PROVIDER_STATUS_ENUM *pStatus);

    STDMETHOD(get_Methods)(/*[out, retval]*/ VARIANT *pvMethods);

//	Internal Use
    STDMETHOD(Init)(FAX_ROUTING_EXTENSION_INFO *pInfo, FAX_GLOBAL_ROUTING_INFO *pMethods, DWORD dwNum);
    
private:
    DWORD           m_dwLastError;
    DWORD           m_dwMajorBuild;
    DWORD           m_dwMinorBuild;
    DWORD           m_dwMajorVersion;
    DWORD           m_dwMinorVersion;

    CComBSTR        m_bstrFriendlyName;
    CComBSTR        m_bstrImageName;
    CComBSTR        m_bstrUniqueName;

    VARIANT_BOOL    m_bDebug;

    SAFEARRAY       *m_psaMethods;

    FAX_PROVIDER_STATUS_ENUM    m_Status;
};

#endif //__FAXINBOUNDROUTINGEXTENSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxinboundroutingextension.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingExtension.cpp

Abstract:

	Implementation of CFaxInboundRoutingExtension class.

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxInboundRoutingExtension.h"


//
//===================== GET METHODS =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_Methods(
	/*[out, retval]*/ VARIANT *pvMethods
)
/*++

Routine name : CFaxInboundRoutingExtension::get_Methods

Routine description:

	Return array of all Method GUIDS exposed by the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pvMethods           [out]    - Ptr to put Variant containing Safearray of Methods

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_Methods"), hr);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(pvMethods, sizeof(VARIANT)))
	{
		hr = E_POINTER;
		AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pvMethods, sizeof(VARIANT))"), hr);
		return hr;
	}

    //
    //  Allocate the safe array : vector of BSTR
    //
    SAFEARRAY   *psaResult;
    hr = SafeArrayCopy(m_psaMethods, &psaResult);
    if (FAILED(hr) || !psaResult)
    {
        if (!psaResult)
        {
            hr = E_OUTOFMEMORY;
        }
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
		CALL_FAIL(MEM_ERR, _T("SafeArrayCopy(m_psaMethods, &psaResult)"), hr);
		return hr;
	}

    //
    //  Return the Safe Array inside the VARIANT we got
    //
    VariantInit(pvMethods);
    pvMethods->vt = VT_BSTR | VT_ARRAY;
    pvMethods->parray = psaResult;
    return hr;
}

//
//===================== GET STATUS =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_Status(
	FAX_PROVIDER_STATUS_ENUM *pStatus
)
/*++

Routine name : CFaxInboundRoutingExtension::get_Status

Routine description:

	Return Status of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pStatus                [out]    - Ptr to put Status value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_Status"), hr);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pStatus, sizeof(FAX_PROVIDER_STATUS_ENUM)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pStatus, sizeof(FAX_PROVIDER_STATUS_ENUM))"), hr);
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
        return hr;
	}

	*pStatus = m_Status;
	return hr;
}

//
//========================= GET IMAGE NAME ========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_ImageName(
	BSTR *pbstrImageName
)
/*++

Routine name : CFaxInboundRoutingExtension::get_ImageName

Routine description:

	Return Image Name of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pbstrImageName                [out]    - Ptr to put the ImageName

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_ImageName"), hr);
    hr = GetBstr(pbstrImageName, m_bstrImageName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
        return hr;
    }
    return hr;
}

//
//========================= GET FRIENDLY NAME ========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_FriendlyName(
	BSTR *pbstrFriendlyName
)
/*++

Routine name : CFaxInboundRoutingExtension::get_FriendlyName

Routine description:

	Return Friendly Name of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pbstrFriendlyName               [out]    - Ptr to put the FriendlyName

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_FriendlyName"), hr);
    hr = GetBstr(pbstrFriendlyName, m_bstrFriendlyName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
        return hr;
    }
    return hr;
}

//
//========================= GET UNIQUE NAME ========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_UniqueName(
	BSTR *pbstrUniqueName
)
/*++

Routine name : CFaxInboundRoutingExtension::get_UniqueName

Routine description:

	Return Unique Name of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pbstrUniqueName               [out]    - Ptr to put the Unique Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_UniquName"), hr);
    hr = GetBstr(pbstrUniqueName, m_bstrUniqueName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
        return hr;
    }
    return hr;
}

//
//===================== GET DEBUG =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_Debug(
	VARIANT_BOOL *pbDebug
)
/*++

Routine name : CFaxInboundRoutingExtension::get_Debug

Routine description:

	Return if the IR Extension is compiled in Debug version

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pbDebug                 [out]    - Ptr to put Debug value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_Debug"), hr);

    hr = GetVariantBool(pbDebug, m_bDebug);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
        return hr;
    }
	return hr;
}

//
//===================== GET MAJOR BUILD =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_MajorBuild(
	long *plMajorBuild
)
/*++

Routine name : CFaxInboundRoutingExtension::get_MajorBuild

Routine description:

	Return MajorBuild of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	plMajorBuild                [out]    - Ptr to put MajorBuild value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_MajorBuild"), hr);

    hr = GetLong(plMajorBuild, m_dwMajorBuild);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
        return hr;
    }
	return hr;
}

//
//===================== GET MINOR BUILD =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_MinorBuild(
	long *plMinorBuild
)
/*++

Routine name : CFaxInboundRoutingExtension::get_MinorBuild

Routine description:

	Return MinorBuild of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	plMinorBuild                [out]    - Ptr to put MinorBuild value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_MinorBuild"), hr);

    hr = GetLong(plMinorBuild, m_dwMinorBuild);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
        return hr;
    }
	return hr;
}

//
//===================== GET MAJOR VERSION =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_MajorVersion(
	long *plMajorVersion
)
/*++

Routine name : CFaxInboundRoutingExtension::get_MajorVersion

Routine description:

	Return MajorVersion of the IR Extension

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plMajorVersion                [out]    - Ptr to put MajorVersion value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_MajorVersion"), hr);

    hr = GetLong(plMajorVersion, m_dwMajorVersion);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
        return hr;
    }
	return hr;
}

//
//===================== GET MINOR VERSION =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_MinorVersion(
	long *plMinorVersion
)
/*++

Routine name : CFaxInboundRoutingExtension::get_MinorVersion

Routine description:

	Return MinorVersion of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	plMinorVersion                [out]    - Ptr to put MinorVersionvalue

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_MinorVersion"), hr);

    hr = GetLong(plMinorVersion, m_dwMinorVersion);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
        return hr;
    }
	return hr;
}

//
//===================== GET INIT ERROR CODE =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_InitErrorCode(
	long *plInitErrorCode
)
/*++

Routine name : CFaxInboundRoutingExtension::get_InitErrorCode

Routine description:

	Return InitErrorCode of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	plInitErrorCode                [out]    - Ptr to put InitErrorCode value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_InitErrorCode"), hr);

    hr = GetLong(plInitErrorCode, m_dwLastError);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
        return hr;
    }
	return hr;
}

//
//==================== INIT ========================================
//
STDMETHODIMP
CFaxInboundRoutingExtension::Init(
    FAX_ROUTING_EXTENSION_INFO *pInfo,
    FAX_GLOBAL_ROUTING_INFO *pMethods,
    DWORD dwNum
)
/*++

Routine name : CFaxInboundRoutingExtesnion::Init

Routine description:

	Initialize the IR Extension Object with given Information.
    Allocates memory and stores given pInfo.
    Find in the pMethods its own Methods, create Variant of SafeArray containing them.

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pInfo               [in]  -- the Info of the IR Extension Object
    pMethods            [in]  -- array of all available Methods
    dwNum               [in]  -- number of elements in pMethods array

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::Init"), hr);

    //
    //  Copy the FAX_ROUTING_EXTENSION_INFO
    //
    m_dwLastError = pInfo->dwLastError;
    m_Status = FAX_PROVIDER_STATUS_ENUM(pInfo->Status);

    if (!(pInfo->Version.bValid))
    {
        m_dwMajorBuild = 0;
        m_dwMinorBuild = 0;
        m_dwMajorVersion = 0;
        m_dwMinorVersion = 0;
        m_bDebug = VARIANT_FALSE;
    }
    else
    {
        m_dwMajorBuild = pInfo->Version.wMajorBuildNumber;
        m_dwMinorBuild = pInfo->Version.wMinorBuildNumber;
        m_dwMajorVersion = pInfo->Version.wMajorVersion;
        m_dwMinorVersion = pInfo->Version.wMinorVersion;
        m_bDebug = bool2VARIANT_BOOL((pInfo->Version.dwFlags & FAX_VER_FLAG_CHECKED) ? true : false);
    }

    m_bstrImageName = pInfo->lpctstrImageName;
    m_bstrFriendlyName = pInfo->lpctstrFriendlyName;
    m_bstrUniqueName = pInfo->lpctstrExtensionName;
    if ( (pInfo->lpctstrImageName && !m_bstrImageName) ||
         (pInfo->lpctstrFriendlyName && !m_bstrFriendlyName) ||
         (pInfo->lpctstrExtensionName && !m_bstrUniqueName) )
    {
        hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
        return hr;
    }

    //
    //  count the Methods of the IR Extension
    //
    DWORD   dwCount = 0;
    for (DWORD  i=0 ; i<dwNum ; i++ )
    {
        //
        //  We may only compare Friendly Name and Image Name.
        //  This is potentially a problem. 
        //  Extensions should be distinguished by their Unique Name.
        //
        if ( (_tcscmp(pMethods[i].ExtensionFriendlyName, m_bstrFriendlyName) == 0) &&
             (_tcscmp(pMethods[i].ExtensionImageName, m_bstrImageName) == 0) )
        {
            dwCount++;
        }
    }

    //
    //  Allocate the safe array : vector of BSTR
    //
	m_psaMethods = ::SafeArrayCreateVector(VT_BSTR, 0, dwCount);
	if (!m_psaMethods)
	{
		//
		//	Not Enough Memory
		//
		hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
		CALL_FAIL(MEM_ERR, _T("::SafeArrayCreateVector(VT_BSTR, 0, dwCount)"), hr);
		return hr;
	}

    if ( dwCount>0 )
    {

        //
        //  get Access to the elements of the Safe Array
        //
	    BSTR *pbstrElement;
	    hr = ::SafeArrayAccessData(m_psaMethods, (void **) &pbstrElement);
	    if (FAILED(hr))
	    {
		    //
		    //	Failed to access safearray
		    //
            hr = E_FAIL;
		    CALL_FAIL(GENERAL_ERR, _T("::SafeArrayAccessData(m_psaMethods, &pbstrElement)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
		    return hr;
	    }

        //
        //  Fill the array with values
        //
        DWORD       idx = 0;
        for ( i=0 ; i<dwNum ; i++ )
        {
        //
        //  Like the previous comparison :
        //      We may only compare Friendly Name and Image Name.
        //      This is potentially a problem. 
        //      Extensions should be distinguished by their Unique Name.
        //
            if ( (_tcscmp(pMethods[i].ExtensionFriendlyName, m_bstrFriendlyName) == 0) &&
                 (_tcscmp(pMethods[i].ExtensionImageName, m_bstrImageName) == 0) )
            {
                //
                //  Allocate memory for the GUID and store ptr to it in the SafeArray
                //
                BSTR bstrTmp = NULL;
                bstrTmp = ::SysAllocString(pMethods[i].Guid);
                if (pMethods[i].Guid && !bstrTmp)
                {
		            //
		            //	Not Enough Memory
		            //
		            hr = E_OUTOFMEMORY;
                    AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr);
		            CALL_FAIL(MEM_ERR, _T("::SysAllocString(pMethods[i].Guid)"), hr);
                    SafeArrayUnaccessData(m_psaMethods);
                    SafeArrayDestroy(m_psaMethods);
                    m_psaMethods = NULL;
		            return hr;
                }

                pbstrElement[idx] = bstrTmp;
                idx++;
            }
        }
        ATLASSERT(idx == dwCount);

        //
        //  free the safearray from the access  
        //
	    hr = ::SafeArrayUnaccessData(m_psaMethods);
        if (FAILED(hr))
        {
	        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayUnaccessData(m_psaMethods)"), hr);
            return hr;
        }
    }

    return hr;
}

//
//==================== SUPPORT ERROR INFO =============================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxInboundRoutingExtension::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxInboundRoutingExtension
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxinboundroutingextensions.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingExtensions.cpp

Abstract:

	Implementation of CFaxInboundRoutingExtensions class.

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxInboundRoutingExtensions.h"
#include "FaxInboundRoutingExtension.h"

//
//==================== CREATE ========================================
//
HRESULT 
CFaxInboundRoutingExtensions::Create (
	IFaxInboundRoutingExtensions **ppIRExtensions
)
/*++

Routine name : CFaxInboundRoutingExtensions::Create

Routine description:

	Static function to create the Fax IR Extensions Collection Object

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	ppIRExtensions          [out]  -- the new Fax IR Extensions Collection Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtensions::Create"), hr);

    //
    //  Create Instance of the Collection
    //
	CComObject<CFaxInboundRoutingExtensions>		*pClass;
	hr = CComObject<CFaxInboundRoutingExtensions>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxInboundRoutingExtensions>::CreateInstance(&pClass)"), hr);
		return hr;
	}

    //
    //  Return the desired Interface Ptr
    //
	hr = pClass->QueryInterface(ppIRExtensions);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(ppIRExtensions)"), hr);
		return hr;
	}

	return hr;
}	//	CFaxInboundRoutingExtensions::Create()

//
//============================= INIT ============================================
//
STDMETHODIMP
CFaxInboundRoutingExtensions::Init(
    IFaxServerInner *pServerInner
)
/*++

Routine name : CFaxInboundRoutingExtensions::Init

Routine description:

	Initialize the Collection : 
    1)  get from RPC all IR Extensions and all Methods Structures, 
    2)  create COM objects for each structure,
    3)  init all these objects with the IR Extension structure and Methods array,
    4)  AddRef() each object,
    5)  put the Ptrs to Objects into the STL::vector.

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pServerInner                    [in]    - Ptr to the Fax Server.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingExtensions::Init"), hr);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = pServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr);
		return hr;
	}

    //
    //  Bring from the Server all IR Extensions
    //
    DWORD       dwNum = 0;
    CFaxPtr<FAX_ROUTING_EXTENSION_INFO>   pIRExtensions;
    if (!FaxEnumRoutingExtensions(faxHandle, &pIRExtensions, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumRoutingExtensions(faxHandle, &pIRExtensions, &dwNum"), hr);
        AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr);
		return hr;
    }

    //
    //  Bring all the Methods from the Server
    //
    DWORD       dwNumMethods = 0;
    CFaxPtr<FAX_GLOBAL_ROUTING_INFO>   pMethods;
    if (!FaxEnumGlobalRoutingInfo(faxHandle, &pMethods, &dwNumMethods))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxEnumGlobalRoutingInfo(hFaxHandle, &pMethods, &dwNumMethods)"), hr);
        return hr;
    }

    //
    //  Fill the Collection with Objects
    //
    CComObject<CFaxInboundRoutingExtension>  *pClass = NULL;
    CComPtr<IFaxInboundRoutingExtension>     pObject = NULL;
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        //
        //  Create IR Extensin Object
        //
        hr = CComObject<CFaxInboundRoutingExtension>::CreateInstance(&pClass);
        if (FAILED(hr) || (!pClass))
        {
            if (!pClass)
            {
                hr = E_OUTOFMEMORY;
    		    CALL_FAIL(MEM_ERR, _T("CComObject<CFaxInboundRoutingExtension>::CreateInstance(&pClass)"), hr);
            }
            else
            {
    		    CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxInboundRoutingExtension>::CreateInstance(&pClass)"), hr);
            }

            AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr);
		    return hr;
        }

        //
        //  Init the IR Extension Object
        //
        hr = pClass->Init(&pIRExtensions[i], pMethods, dwNumMethods);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("pClass->Init(&pIRExtensions[i], pMethods, dwNumMethods)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr);
            delete pClass;
            return hr;
        }

        //
        //  Get Interface from the pClass.
        //  This will make AddRef() on the Interface. 
        //  This is the Collection's AddRef, which is freed at Collection's Dtor.
        //
        hr = pClass->QueryInterface(&pObject);
        if (FAILED(hr) || (!pObject))
        {
            if (!pObject)
            {
                hr = E_FAIL;
            }
            CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&pObject)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr);
            delete pClass;
            return hr;
        }

	    //
	    //	Put the Object in the collection
	    //
	    try 
	    {
		    m_coll.push_back(pObject);
	    }
	    catch (exception &)
	    {
		    hr = E_OUTOFMEMORY;
		    AtlReportError(CLSID_FaxInboundRoutingExtensions, IDS_ERROR_OUTOFMEMORY, IID_IFaxInboundRoutingExtensions, hr);
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pObject)"), hr);

            //
            //  pObject will call Release(), which will delete the pClass
            //
		    return hr;
	    }

        //
        //  We want to save the current AddRef() to Collection
        //
        pObject.Detach();
    }

    return hr;
}

//
//============================= GET ITEM =========================================
//
STDMETHODIMP
CFaxInboundRoutingExtensions::get_Item(
    /*[in]*/ VARIANT vIndex, 
    /*[out, retval]*/ IFaxInboundRoutingExtension **ppIRExtension
)
/*++

Routine name : CFaxInboundRoutingExtensions::get_Item

Routine description:

	Return an Item from the Collection.

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	vIndex                          [in]    - Identifier of the Item to return.
	ppIRExtension                   [out]    - the result value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingExtensions::get_Item"), hr);

    //
    //  Check the Ptr we have got
    //
    if (::IsBadWritePtr(ppIRExtension, sizeof(IFaxInboundRoutingExtension *)))
    {
        hr = E_POINTER;
        AtlReportError(CLSID_FaxInboundRoutingExtensions, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxInboundRoutingExtensions, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppIRExtension)"), hr);
		return hr;
    }

    CComVariant var;

    if (vIndex.vt != VT_BSTR)
    {
        //
        //  vIndex is not BSTR ==> convert to VT_I4
        //
        hr = var.ChangeType(VT_I4, &vIndex);
        if (SUCCEEDED(hr))
        {
            VERBOSE(DBG_MSG, _T("Parameter is Number : %d"), var.lVal);
            //
            //  call default ATL's implementation
            //
            hr = ICollectionOnSTLImpl<IFaxInboundRoutingExtensions, ContainerType, 
                IFaxInboundRoutingExtension*, CollectionCopyType, EnumType>::get_Item(var.lVal, 
                ppIRExtension);
            return hr;
		}
    }

    //
    //  convert to BSTR
    //
    hr = var.ChangeType(VT_BSTR, &vIndex);
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxInboundRoutingExtensions, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxInboundRoutingExtensions, hr);
        CALL_FAIL(GENERAL_ERR, _T("var.ChangeType(VT_BSTR, &vIndex)"), hr);
        return hr;
    }

    VERBOSE(DBG_MSG, _T("Parameter is String : %s"), var.bstrVal);

    ContainerType::iterator it = m_coll.begin();
    while (it != m_coll.end())
    {
        CComBSTR    bstrName;
        hr = (*it)->get_UniqueName(&bstrName);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_UniqueName(&bstrName)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr);
            return hr;
        }

        if (_tcsicmp(bstrName, var.bstrVal) == 0)
        {
            //
            //  found the desired IR Extension
            //
            (*it)->AddRef();
            *ppIRExtension = *it;
            return hr;
        }
        it++;
    }

    //
    //  IR Extension does not exist
    //
	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Inbound Routing Extension Is Not Found"), hr);
	AtlReportError(CLSID_FaxInboundRoutingExtensions, IDS_ERROR_WRONGEXTENSIONNAME, IID_IFaxInboundRoutingExtensions, hr);
	return hr;
}

//
//================== SUPPORT ERROR INFO ========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtensions::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxInboundRoutingExtensions::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxInboundRoutingExtensions
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxinboundroutingextensions.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingExtensions.h

Abstract:

	Declaration of the CFaxInboundRoutingExtensions class

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#ifndef __FAXINBOUNDROUTINGEXTENSIONS_H_
#define __FAXINBOUNDROUTINGEXTENSIONS_H_

#include "resource.h"       // main symbols
#include <vector>
#include "VCUE_Copy.h"
#include "FaxCommon.h"

//#include "FaxDeviceProvider.h"

//
//  Very same as Device Providers Collection and Device Provider Objects
//
namespace IRExtensionsNamespace
{
    //
    //  Inbound Routing Extension Objects are stored in Vector of STL.
    //  When initialized, they got ALL their data. 
    //  They never call Fax Server.
    //  They do not depend neither on Fax Server nor on Extensions Collection
    //  after they are created and initialized.
    //  So, they implemented as usual COM Objects. 
    //  The Collection stores Ptrs to them, and makes ONE AddRef(). 
    //  Each time User asks for an Object from the Collection, an additional AddRef() happens. 
    //  When killed, Collection calls Release() on all contained in it Extension Objects.
    //  Those that are not asked by User, dies. 
    //  Those, that have User's AddRef() - remains alive, untill User free its Reference on them.
    //  The Extension Object can continue to live after all objects are freed,
    //  including Fax Server and all its Descendants. 
    //  THIS IS BECAUSE Extension Object and their Collection is Snap-Shot 
    //  of the situation on the Server. They are not updatable, but a read-only objects.
    //  To get the updated data, User must ask new Collection from the Server.
    //
	typedef	std::vector<IFaxInboundRoutingExtension*>        ContainerType;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT			    EnumExposedType;
	typedef	IEnumVARIANT        EnumIfc;

	//  Copy Classes
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<ContainerType::value_type>            CollectionCopyType;

    //  Enumeration Type, shortcut for next typedef
    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), EnumExposedType, EnumCopyType, ContainerType >    
        EnumType;

    //  Collection Type, real ancestor of the IR Extensions Collection
    typedef ICollectionOnSTLImpl< IFaxInboundRoutingExtensions, ContainerType, ContainerType::value_type, 
        CollectionCopyType, EnumType >    CollectionType;
};

using namespace IRExtensionsNamespace;

//
//===================== INBOUND ROUTING EXTENSIONS COLLECTION =================================
//
class ATL_NO_VTABLE CFaxInboundRoutingExtensions : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<IRExtensionsNamespace::CollectionType, &IID_IFaxInboundRoutingExtensions, 
		   &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
	CFaxInboundRoutingExtensions() : CFaxInitInner(_T("INBOUND ROUTING EXTENSIONS COLLECTION"))
	{}

    ~CFaxInboundRoutingExtensions()
    {
        CCollectionKiller<IRExtensionsNamespace::ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINBOUNDROUTINGEXTENSIONS)
DECLARE_NOT_AGGREGATABLE(CFaxInboundRoutingExtensions)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxInboundRoutingExtensions)
	COM_INTERFACE_ENTRY(IFaxInboundRoutingExtensions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, 
        /*[out, retval]*/ IFaxInboundRoutingExtension **ppExtension);

//  Internal Use
    STDMETHOD(Init)(IFaxServerInner *pServerInner);
    static HRESULT Create(IFaxInboundRoutingExtensions **ppIRExtensions);
};

#endif //__FAXINBOUNDROUTINGEXTENSIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxinboundroutingmethod.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingMethod.h

Abstract:

	Declaration of the CFaxInboundRoutingMethod Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXINBOUNDROUTINGMETHOD_H_
#define __FAXINBOUNDROUTINGMETHOD_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//==================== FAX INBOUND ROUTING METHOD =============================
//
class ATL_NO_VTABLE CFaxInboundRoutingMethod : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxInboundRoutingMethod, &IID_IFaxInboundRoutingMethod, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxInboundRoutingMethod() : CFaxInitInnerAddRef(_T("FAX INBOUND ROUTING METHOD"))
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINBOUNDROUTINGMETHOD)
DECLARE_NOT_AGGREGATABLE(CFaxInboundRoutingMethod)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxInboundRoutingMethod)
	COM_INTERFACE_ENTRY(IFaxInboundRoutingMethod)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);
    STDMETHOD(get_GUID)(/*[out, retval]*/ BSTR *pbstrGUID);
    STDMETHOD(get_FunctionName)(/*[out, retval]*/ BSTR *pbstrFunctionName);
    STDMETHOD(get_ExtensionFriendlyName)(/*[out, retval]*/ BSTR *pbstrExtensionFriendlyName);
    STDMETHOD(get_ExtensionImageName)(/*[out, retval]*/ BSTR *pbstrExtensionImageName);

    STDMETHOD(put_Priority)(/*[in]*/ long lPriority);
    STDMETHOD(get_Priority)(/*[out, retval]*/ long *plPriority);

    STDMETHOD(Save)();
    STDMETHOD(Refresh)();

//  Internal Use
    STDMETHOD(Init)(FAX_GLOBAL_ROUTING_INFO *pInfo, IFaxServerInner *pServer);

private:
    CComBSTR    m_bstrName;
    CComBSTR    m_bstrGUID;
    CComBSTR    m_bstrFunctionName;
    CComBSTR    m_bstrFriendlyName;
    CComBSTR    m_bstrImageName;
    long        m_lPriority;
};

#endif //__FAXINBOUNDROUTINGMETHOD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxinboundroutingmethod.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingMethod.cpp

Abstract:

	Implementation of CFaxInboundRoutingMethod Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxInboundRoutingMethod.h"

//
//==================== REFRESH ========================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::Refresh()
/*++

Routine name : CFaxInboundRoutingMethod::Refresh

Routine description:

    Bring from the Server new Method Data ( only Priority may change ).

Author:

	Iv Garber (IvG),	Jun, 2000

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingMethod::Refresh"), hr);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("(faxHandle == NULL)"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr);
		return hr;
	}

    //
    //  Bring from the Server all Inbound Routing Methods
    //
    DWORD       dwNum = 0;
    CFaxPtr<FAX_GLOBAL_ROUTING_INFO>    pMethods;
    if (!FaxEnumGlobalRoutingInfo(faxHandle, &pMethods, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumGlobalRoutingInfo(faxHandle, &pMethods, &dwNum)"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr);
		return hr;
    }

    //
    //  find our Method
    //
    for ( DWORD i=0 ; i<dwNum ; i++ )
    {
        if ( _tcsicmp(pMethods[i].Guid, m_bstrGUID) == 0 )
        {
            hr = Init(&pMethods[i], NULL);
            return hr;
        }
    }

    return hr;
}

//
//==================== INIT ========================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::Init(
    FAX_GLOBAL_ROUTING_INFO *pInfo,
    IFaxServerInner *pServer
)
/*++

Routine name : CFaxInboundRoutingMethod::Init

Routine description:

	Initialize the IR Method Object with given Information.
    Allocates memory and stores given pInfo.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pInfo               [in]  -- the Info of the IR Method Object
	pServer             [in]  -- Ptr to the Server

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingMethod::Init"), hr);

    //
    //  Copy the FAX_GLOBAL_ROUTING_INFO structure
    //
    m_lPriority = pInfo->Priority;

    m_bstrGUID = pInfo->Guid;
    m_bstrImageName = pInfo->ExtensionImageName;
    m_bstrFriendlyName = pInfo->ExtensionFriendlyName;
    m_bstrFunctionName = pInfo->FunctionName;
    m_bstrName = pInfo->FriendlyName;
    if ( (pInfo->Guid && !m_bstrGUID) ||
         (pInfo->FriendlyName && !m_bstrName) ||
         (pInfo->ExtensionImageName && !m_bstrImageName) ||
         (pInfo->ExtensionFriendlyName && !m_bstrFriendlyName) ||
         (pInfo->FunctionName && !m_bstrFunctionName) )
    {
        hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr);
        return hr;
    }

    if (pServer)
    {

        //
        //  Store Ptr to the Server
        //
        hr = CFaxInitInnerAddRef::Init(pServer);
    }
    return hr;
}

//
//===================== SAVE ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::Save()
/*++

Routine name : CFaxInboundRoutingMethod::Save

Routine description:

	Save the Method's Priority.

Author:

	Iv Garber (IvG),	Jun, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::Save"), hr);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("(faxHandle == NULL)"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr);
		return hr;
	}

    //
    //  Prepare Structure 
    //
    FAX_GLOBAL_ROUTING_INFO     Data;
    Data.Guid = m_bstrGUID;
    Data.Priority = m_lPriority;
    Data.SizeOfStruct = sizeof(FAX_GLOBAL_ROUTING_INFO);
    Data.ExtensionFriendlyName = NULL;
    Data.ExtensionImageName = NULL;
    Data.FriendlyName = NULL;
    Data.FunctionName = NULL;

    //
    //  Call Server to update its data about the Method
    //
    if (!FaxSetGlobalRoutingInfo(faxHandle, &Data))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxSetGlobalRoutingInfo(faxHandle, &Data)"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr);
		return hr;
    }

    return hr;
}

//
//===================== PUT PRIORITY ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::put_Priority(
    /*[in]*/ long lPriority
)
/*++

Routine name : CFaxInboundRoutingMethod::put_Priority

Routine description:

	Set the Method's Priority -- Order within the Collection of all Methods.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lPriority      [out]    - the value to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::put_Priority"), hr, _T("PR=%d"), lPriority);

    if (lPriority < 1)
    {
        //
        //  Out Of Range
        //
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxInboundRoutingMethod, IDS_ERROR_OUTOFRANGE, IID_IFaxInboundRoutingMethod, hr);
		CALL_FAIL(GENERAL_ERR, _T("(lPriority < 1)"), hr);
		return hr;
    }

    m_lPriority = lPriority;
    return hr;
}

//
//===================== GET PRIORITY ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::get_Priority(
    /*[out, retval]*/ long *plPriority
)
/*++

Routine name : CFaxInboundRoutingMethod::get_Priority

Routine description:

	Return the Method's Priority -- Order within the Collection of all Methods.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plPriority      [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::get_Priority"), hr);

    hr = GetLong(plPriority, m_lPriority);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr);
        return hr;
    }
    return hr;
}

//
//===================== GET EXTENSION IMAGE NAME ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::get_ExtensionImageName(
    /*[out, retval]*/ BSTR *pbstrExtensionImageName
)
/*++

Routine name : CFaxInboundRoutingMethod::get_ExtensionImageName

Routine description:

	Return the Method's Extension Image Name.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrExtensionImageName             [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::get_ExtensionImageName"), hr);

    hr = GetBstr(pbstrExtensionImageName, m_bstrImageName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr);
        return hr;
    }
    return hr;
}

//
//===================== GET EXTENSION FRIENDLY NAME ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::get_ExtensionFriendlyName(
    /*[out, retval]*/ BSTR *pbstrExtensionFriendlyName
)
/*++

Routine name : CFaxInboundRoutingMethod::get_ExtensionFriendlyName

Routine description:

	Return the Method's Extension Friendly Name.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrExtensionFriendlyName             [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::get_ExtensionFriendlyName"), hr);

    hr = GetBstr(pbstrExtensionFriendlyName, m_bstrFriendlyName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr);
        return hr;
    }
    return hr;
}

//
//===================== GET FUNCTION NAME ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::get_FunctionName(
    /*[out, retval]*/ BSTR *pbstrFunctionName
)
/*++

Routine name : CFaxInboundRoutingMethod::get_FunctionName

Routine description:

	Return the Method's Function Name.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrFunctionName                   [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::get_FunctionName"), hr);

    hr = GetBstr(pbstrFunctionName, m_bstrFunctionName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr);
        return hr;
    }
    return hr;
}

//
//===================== GET GUID ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::get_GUID(
    /*[out, retval]*/ BSTR *pbstrGUID
)
/*++

Routine name : CFaxInboundRoutingMethod::get_GUID

Routine description:

	Return the Method's GUID.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrGUID                   [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::get_GUID"), hr);

    hr = GetBstr(pbstrGUID, m_bstrGUID);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr);
        return hr;
    }
    return hr;
}

//
//===================== GET NAME ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::get_Name(
    /*[out, retval]*/ BSTR *pbstrName
)
/*++

Routine name : CFaxInboundRoutingMethod::get_Name

Routine description:

	Return the Method's Name.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrName                   [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::get_Name"), hr);

    hr = GetBstr(pbstrName, m_bstrName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr);
        return hr;
    }
    return hr;
}

//
//========================= SUPPORT ERROR INFO ====================================
//
STDMETHODIMP 
CFaxInboundRoutingMethod::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxInboundRoutingMethod::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxInboundRoutingMethod
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxinboundroutingmethods.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingMethods.cpp

Abstract:

	Implementation of CFaxInboundRoutingMethods Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxInboundRoutingMethods.h"
#include "FaxInboundRoutingMethod.h"

//
//================== SUPPORT ERROR INFO ========================================
//
STDMETHODIMP 
CFaxInboundRoutingMethods::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxInboundRoutingMethods::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxInboundRoutingMethods
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxInboundRoutingMethods::Create (
	IFaxInboundRoutingMethods **ppMethods
)
/*++

Routine name : CFaxInboundRoutingMethods::Create

Routine description:

	Static function to create the Fax Inbound Routing Methods Collection Object

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	ppMethods              [out]  -- the new Fax Inbound Routing Methods Collection Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingMethods::Create"), hr);

    //
    //  Create Instance of the Collection
    //
	CComObject<CFaxInboundRoutingMethods>		*pClass;
	hr = CComObject<CFaxInboundRoutingMethods>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxInboundRoutingMethods>::CreateInstance(&pClass)"), hr);
		return hr;
	}

    //
    //  Return the desired Interface Ptr
    //
	hr = pClass->QueryInterface(ppMethods);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(ppMethods)"), hr);
		return hr;
	}

	return hr;
}	//	CFaxInboundRoutingMethods::Create()

//
//============================= INIT ============================================
//
STDMETHODIMP
CFaxInboundRoutingMethods::Init(
    IFaxServerInner *pServerInner
)
/*++

Routine name : CFaxInboundRoutingMethods::Init

Routine description:

	Initialize the Collection : 
    1)  get from RPC all IR Methods, 
    2)  create COM objects for each one,
    3)  AddRef() each object,
    4)  put the Ptrs to Objects into the STL::vector.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pServerInner                    [in]    - Ptr to the Fax Server.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethods::Init"), hr);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = pServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethods, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethods, hr);
		return hr;
	}

    //
    //  Bring from the Server all Inbound Routing Methods
    //
    DWORD       dwNum = 0;
    CFaxPtr<FAX_GLOBAL_ROUTING_INFO>    pMethods;
    if (!FaxEnumGlobalRoutingInfo(faxHandle, &pMethods, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumGlobalRoutingInfo(faxHandle, &pMethods, &dwNum)"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethods, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethods, hr);
		return hr;
    }

    //
    //  Fill the Collection with Objects
    //
    CComObject<CFaxInboundRoutingMethod>    *pClass = NULL;
    CComPtr<IFaxInboundRoutingMethod>       pObject = NULL;
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        //
        //  Create IR Method Object
        //
        hr = CComObject<CFaxInboundRoutingMethod>::CreateInstance(&pClass);
        if (FAILED(hr) || (!pClass))
        {
            if (!pClass)
            {
                hr = E_OUTOFMEMORY;
    		    CALL_FAIL(MEM_ERR, _T("CComObject<CFaxInboundRoutingMethod>::CreateInstance(&pClass)"), hr);
            }
            else
            {
    		    CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxInboundRoutingMethod>::CreateInstance(&pClass)"), hr);
            }

            AtlReportError(CLSID_FaxInboundRoutingMethods, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethods, hr);
		    return hr;
        }

        //
        //  Init the IR Method Object
        //
        hr = pClass->Init(&pMethods[i], pServerInner);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("pClass->Init(&pMethods[i], pServerInner)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingMethods, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethods, hr);
            delete pClass;
            return hr;
        }

        //
        //  Get Interface from the pClass.
        //  This will make AddRef() on the Interface. 
        //  This is the Collection's AddRef, which is freed at Collection's Dtor.
        //
        hr = pClass->QueryInterface(&pObject);
        if (FAILED(hr) || (!pObject))
        {
            if (!pObject)
            {
                hr = E_FAIL;
            }
            CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&pObject)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingMethods, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethods, hr);
            delete pClass;
            return hr;
        }

	    //
	    //	Put the Object in the collection
	    //
	    try 
	    {
		    m_coll.push_back(pObject);
	    }
	    catch (exception &)
	    {
		    hr = E_OUTOFMEMORY;
            AtlReportError(CLSID_FaxInboundRoutingMethods, IDS_ERROR_OUTOFMEMORY, IID_IFaxInboundRoutingMethods, hr);
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pObject)"), hr);

            //
            //  pObject will call Release(), which will delete the pClass
            //
		    return hr;
	    }

        //
        //  We want to save the current AddRef() to Collection
        //
        pObject.Detach();
    }

    return hr;
}

//
//============================= GET ITEM =========================================
//
STDMETHODIMP
CFaxInboundRoutingMethods::get_Item(
    /*[in]*/ VARIANT vIndex, 
    /*[out, retval]*/ IFaxInboundRoutingMethod **ppMethod
)
/*++

Routine name : CFaxInboundRoutingMethods::get_Item

Routine description:

	Return an Item from the Collection.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	vIndex                        [in]    - Identifier of the Item to return.
	ppMethod                      [out]    - the result value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethods::get_Item"), hr);

    //
    //  Check the Ptr we have got
    //
    if (::IsBadWritePtr(ppMethod, sizeof(IFaxInboundRoutingMethod *)))
    {
        hr = E_POINTER;
        AtlReportError(CLSID_FaxInboundRoutingMethods, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxInboundRoutingMethods, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppMethod)"), hr);
		return hr;
    }

    CComVariant var;

    if (vIndex.vt != VT_BSTR)
    {
        //
        //  vIndex is not BSTR ==> convert to VT_I4
        //
        hr = var.ChangeType(VT_I4, &vIndex);
        if (SUCCEEDED(hr))
        {
            VERBOSE(DBG_MSG, _T("Parameter is Number : %d"), var.lVal);
            //
            //  call default ATL's implementation
            //
            hr = ICollectionOnSTLImpl<IFaxInboundRoutingMethods, ContainerType, 
                IFaxInboundRoutingMethod*, CollectionCopyType, EnumType>::get_Item(var.lVal, ppMethod);
            return hr;
		}
    }

    //
    //  convert to BSTR
    //
    hr = var.ChangeType(VT_BSTR, &vIndex);
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxInboundRoutingMethods, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxInboundRoutingMethods, hr);
        CALL_FAIL(GENERAL_ERR, _T("var.ChangeType(VT_BSTR, &vIndex)"), hr);
        return hr;
    }

    VERBOSE(DBG_MSG, _T("Parameter is String : %s"), var.bstrVal);

    ContainerType::iterator it = m_coll.begin();
    while (it != m_coll.end())
    {
        CComBSTR    bstrGUID;
        hr = (*it)->get_GUID(&bstrGUID);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_GUID(&bstrGUID)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingMethods, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethods, hr);
            return hr;
        }

        if (_tcsicmp(bstrGUID, var.bstrVal) == 0)
        {
            //
            //  found the desired Method
            //
            (*it)->AddRef();
            *ppMethod = *it;
            return hr;
        }
        it++;
    }

    //
    //  desired Method is not found
    //
	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Method Is Not Found"), hr);
	AtlReportError(CLSID_FaxInboundRoutingMethods, IDS_ERROR_INVALIDMETHODGUID, IID_IFaxInboundRoutingMethods, hr);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxincomingarchive.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingArchive.h

Abstract:

	Declaration of Fax Incoming Archive Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXINCOMINGARCHIVE_H_
#define __FAXINCOMINGARCHIVE_H_

#include "resource.h"       // main symbols
#include "FaxArchiveInner.h"
#include "FaxIncomingMessageIterator.h"


/////////////////////////////////////////////////////////////////////////////
// CFaxIncomingArchive
class ATL_NO_VTABLE CFaxIncomingArchive : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxArchiveInner<IFaxIncomingArchive, &IID_IFaxIncomingArchive, &CLSID_FaxIncomingArchive, 
		FAX_MESSAGE_FOLDER_INBOX, IFaxIncomingMessage, CFaxIncomingMessage,
		IFaxIncomingMessageIterator, CFaxIncomingMessageIterator>
{
public:
	CFaxIncomingArchive() 
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINCOMINGARCHIVE)
DECLARE_NOT_AGGREGATABLE(CFaxIncomingArchive)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxIncomingArchive)
	COM_INTERFACE_ENTRY(IFaxIncomingArchive)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//	Interfaces
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

#endif //__FAXINCOMINGARCHIVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxinboundroutingmethods.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingMethods.h

Abstract:

	Declaration of the CFaxInboundRoutingMethods class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXINBOUNDROUTINGMETHODS_H_
#define __FAXINBOUNDROUTINGMETHODS_H_

#include "resource.h"       // main symbols
#include <vector>
#include "VCUE_Copy.h"
#include "FaxCommon.h"

namespace MethodsNamespace
{

    //
    //  Method Objects are stored in Vector of STL.
    //  When initialized, they got ALL their data, and Fax Server Ptr.
    //  They do not depend on Methods Collection, only on Fax Server.
    //  So, they implemented as usual COM Objects. 
    //  They inherit from CFaxInitInnerAddRef class, which means they make AddRef() 
    //  on Fax Server ( at Init() ).
    //  By doing this, the objects prevent the death of the Fax Server prematurely.
    //  So, if the User frees all its references to the Fax Server, but holds its
    //  reference to the Method Object, the Method Object will continue to work,
    //  because Fax Server Object actually did not died.
    //  The Collection stores Ptrs to them, and makes ONE AddRef(). 
    //  Each time User asks for an Object from the Collection, an additional AddRef() happens. 
    //  When killed, Collection calls Release() on all its Method Objects.
    //  Those that were not requested by the User, dies. 
    //  Those, that have User's AddRef() - remains alive, untill User frees its Reference on them.
    //  Fax Server remains alive untill all the Methods Collections and all Method Objects are killed.
    //  At their death, they Release() the Fax Server.
    //
	typedef	std::vector<IFaxInboundRoutingMethod*>       ContainerType;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT			EnumExposedType;
	typedef	IEnumVARIANT    EnumIfc;

	//  Copy Classes
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<ContainerType::value_type>            CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), EnumExposedType, EnumCopyType, 
        ContainerType >    EnumType;

    typedef ICollectionOnSTLImpl< IFaxInboundRoutingMethods, ContainerType, ContainerType::value_type, 
        CollectionCopyType, EnumType >    CollectionType;
};

using namespace MethodsNamespace;

//
//================= FAX INBOUND ROUTING METHODS ============================================
// 
class ATL_NO_VTABLE CFaxInboundRoutingMethods : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<MethodsNamespace::CollectionType, &IID_IFaxInboundRoutingMethods, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner    //  for Debug + Creation thru CObjectHandler
{
public:
    CFaxInboundRoutingMethods() : CFaxInitInner(_T("FAX INBOUND ROUTING METHODS"))
	{
	}

    ~CFaxInboundRoutingMethods()
    {
        CCollectionKiller<MethodsNamespace::ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINBOUNDROUTINGMETHODS)
DECLARE_NOT_AGGREGATABLE(CFaxInboundRoutingMethods)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxInboundRoutingMethods)
	COM_INTERFACE_ENTRY(IFaxInboundRoutingMethods)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ IFaxInboundRoutingMethod **ppMethod);

//  Internal Use
    static HRESULT Create(IFaxInboundRoutingMethods **ppMethods);
    STDMETHOD(Init)(IFaxServerInner *pServer);
};

#endif //__FAXINBOUNDROUTINGMETHODS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxincomingjob.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingJob.cpp

Abstract:

	Implementation of CFaxIncomingJob Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxIncomingJob.h"

//
//==================== INTERFACE SUPPORT ERROR INFO ========================
//
STDMETHODIMP CFaxIncomingJob::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IFaxIncomingJob
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxIncomingJob::Create (
	IFaxIncomingJob **ppIncomingJob
)
/*++

Routine name : CFaxIncomingJob::Create

Routine description:

	Static function to create the Fax Inbound Message Instance

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	ppIncomingJob             [out]  -- the new Fax Inbound Message Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxIncomingJob>		*pClass;
	HRESULT								hr = S_OK;

	DBG_ENTER (TEXT("CFaxIncomingJob::Create"), hr);

	hr = CComObject<CFaxIncomingJob>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxIncomingJob>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxIncomingJob), (void **) ppIncomingJob);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Inbound Message Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}	//	CFaxIncomingJob::Create()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxincomingjobs.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingJobs.cpp

Abstract:

	Implementation of CFaxIncomingJobs Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxIncomingJobs.h"

//
//==================== CREATE ========================================
//
HRESULT 
CFaxIncomingJobs::Create (
	IFaxIncomingJobs **ppIncomingJobs
)
/*++

Routine name : CFaxIncomingJobs::Create

Routine description:

	Static function to create the Fax IncomingJobs Object

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppIncomingJobs		[out]  -- the new Fax IncomingJobs Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT	        					hr = S_OK;

	DBG_ENTER (TEXT("CFaxIncomingJobs::Create"), hr);

	CComObject<CFaxIncomingJobs>		*pClass;
	hr = CComObject<CFaxIncomingJobs>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxIncomingJobs>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxIncomingJobs), (void **) ppIncomingJobs);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax IncomingJobs Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}	//	CFaxIncomingJobs::Create()

//
//======================== SUPPORT ERROR INFO ====================================
//
STDMETHODIMP CFaxIncomingJobs::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IFaxIncomingJobs
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxincomingjob.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingJob.h

Abstract:

	Declaration of CFaxIncomingJob Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/


#ifndef __FAXINCOMINGJOB_H_
#define __FAXINCOMINGJOB_H_

#include "resource.h"       // main symbols
#include "FaxJobInner.h"


//
//===================== FAX INCOMING JOB ================================================
//
class ATL_NO_VTABLE CFaxIncomingJob : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxJobInner<IFaxIncomingJob, &IID_IFaxIncomingJob, &CLSID_FaxIncomingJob>
{
public:
	CFaxIncomingJob()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINCOMINGJOB)
DECLARE_NOT_AGGREGATABLE(CFaxIncomingJob)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxIncomingJob)
	COM_INTERFACE_ENTRY(IFaxIncomingJob)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//	Internal Use
static HRESULT Create(IFaxIncomingJob **ppIncomingJob);
};

#endif //__FAXINCOMINGJOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxincomingarchive.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingArchive.cpp

Abstract:

	Implementation of CFaxIncomingArchive

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxIncomingArchive.h"

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxIncomingArchive::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxIncomingArchive::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Interface Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Reference of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxIncomingArchive
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxincomingjobs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingJobs.h

Abstract:

	Definition of Fax Incoming JobS Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXINCOMINGJOBS_H_
#define __FAXINCOMINGJOBS_H_

#include "resource.h"       // main symbols

#include <vector>
#include "FaxIncomingJob.h"
#include "FaxJobsCollection.h"


namespace IncomingJobsNamespace
{

	// Jobs stored in array, pointers to them - in vector
	typedef	std::vector<IFaxIncomingJob*>	ContainerType;

	// The collection interface exposes the data as Incoming Job objects
	typedef	IFaxIncomingJob     CollectionExposedType;
	typedef IFaxIncomingJobs	CollectionIfc;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT				EnumExposedType;
	typedef	IEnumVARIANT		EnumIfc;

	// Typedef the copy classes using existing typedefs
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<IFaxIncomingJob*>    CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), 
		EnumExposedType, EnumCopyType, ContainerType >    EnumType;

    typedef JobCollection< CollectionIfc, ContainerType, CollectionExposedType, CollectionCopyType, 
        EnumType, CFaxIncomingJob, &IID_IFaxIncomingJobs, &CLSID_FaxIncomingJobs >    CollectionType;
};

using namespace IncomingJobsNamespace;

//
//==================== CFaxIncomingJobs ==========================================
//
class ATL_NO_VTABLE CFaxIncomingJobs : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<IncomingJobsNamespace::CollectionType, &IID_IFaxIncomingJobs, &LIBID_FAXCOMEXLib>
{
public:
	CFaxIncomingJobs()
	{
        DBG_ENTER(_T("FAX INCOMING JOBS::CREATE"));
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINCOMINGJOBS)
DECLARE_NOT_AGGREGATABLE(CFaxIncomingJobs)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxIncomingJobs)
	COM_INTERFACE_ENTRY(IFaxIncomingJobs)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//  Internal Use
	static HRESULT Create(IFaxIncomingJobs **ppIncomingJobs);
};

#endif //__FAXINCOMINGJOBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxincomingqueue.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	faxincomingqueue.h

Abstract:

	Declaration of the CFaxIncomingQueue Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXINCOMINGQUEUE_H_
#define __FAXINCOMINGQUEUE_H_

#include "resource.h"       // main symbols
#include "FaxQueueInner.h"
#include "FaxIncomingJob.h"
#include "FaxIncomingJobs.h"


//
//==================== FAX INCOMING QUEUE ========================================
//
class ATL_NO_VTABLE CFaxIncomingQueue : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxQueueInner<IFaxIncomingQueue, &IID_IFaxIncomingQueue, &CLSID_FaxIncomingQueue, true,
		IFaxIncomingJob, CFaxIncomingJob, IFaxIncomingJobs, CFaxIncomingJobs>
{
public:
	CFaxIncomingQueue()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINCOMINGQUEUE)
DECLARE_NOT_AGGREGATABLE(CFaxIncomingQueue)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxIncomingQueue)
	COM_INTERFACE_ENTRY(IFaxIncomingQueue)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//	Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
};

#endif //__FAXINCOMINGQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxjobinner.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxJobInner.h

Abstract:

    Implementation of Fax Job Inner Class : 
        Base Class for Inbound and Outbound Job Classes.

Author:

    Iv Garber (IvG) May, 2000

Revision History:

--*/


#ifndef __FAXJOBINNER_H_
#define __FAXJOBINNER_H_

#include "FaxJobStatus.h"
#include "FaxSender.h"

//
//===================== FAX JOB INNER CLASS ===============================
//
template<class T, const IID* piid, const CLSID* pcid> 
class CFaxJobInner : 
    public IDispatchImpl<T, piid, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxJobInner() : CFaxInitInnerAddRef(_T("FAX JOB INNER"))
    {
        m_pSender = NULL;
        m_pRecipient = NULL;
    };

    ~CFaxJobInner()
    {
        if (m_pSender)
        {
            m_pSender->Release();
        }
        if (m_pRecipient)
        {
            m_pRecipient->Release();
        }
    };

    STDMETHOD(Init)(PFAX_JOB_ENTRY_EX pFaxJob, IFaxServerInner *pServer);

//  common for both Jobs
	STDMETHOD(Cancel)();
	STDMETHOD(Refresh)();
	STDMETHOD(CopyTiff)(BSTR bstrTiffPath);
    STDMETHOD(get_Id)(/*[out, retval]*/ BSTR *pbstrId);
    STDMETHOD(get_Size)(/*[out, retval]*/ long *plSize);
	STDMETHOD(get_CSID)(/*[out, retval]*/ BSTR *pbstrCSID);
	STDMETHOD(get_TSID)(/*[out, retval]*/ BSTR *pbstrTSID);
	STDMETHOD(get_Retries)(/*[out, retval]*/ long *plRetries);
	STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *plDeviceId);
	STDMETHOD(get_CurrentPage)(/*[out, retval]*/ long *plCurrentPage);
	STDMETHOD(get_Status)(/*[out, retval]*/ FAX_JOB_STATUS_ENUM *pStatus);
	STDMETHOD(get_ExtendedStatus)(/*[out, retval]*/ BSTR *pbstrExtendedStatus);
	STDMETHOD(get_TransmissionEnd)(/*[out, retval]*/ DATE *pdateTransmissionEnd);
	STDMETHOD(get_TransmissionStart)(/*[out, retval]*/ DATE *pdateTransmissionStart);
	STDMETHOD(get_ExtendedStatusCode)(FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);
	STDMETHOD(get_AvailableOperations)(/*[out, retval]*/ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);

//  specific for Outbound Job
	STDMETHOD(Pause)();
	STDMETHOD(Resume)();
	STDMETHOD(Restart)();
	STDMETHOD(get_Sender)(IFaxSender **ppFaxSender);
	STDMETHOD(get_Pages)(/*[out, retval]*/ long *plPages);
	STDMETHOD(get_Recipient)(IFaxRecipient **ppFaxRecipient);
	STDMETHOD(get_Subject)(/*[out, retval]*/ BSTR *pbstrSubject);
	STDMETHOD(get_ReceiptType)(FAX_RECEIPT_TYPE_ENUM *pReceiptType);
	STDMETHOD(get_DocumentName)(/*[out, retval]*/ BSTR *pbstrDocumentName);
    STDMETHOD(get_SubmissionId)(/*[out, retval] */BSTR *pbstrSubmissionId);
	STDMETHOD(get_OriginalScheduledTime)(DATE *pdateOriginalScheduledTime);
	STDMETHOD(get_ScheduledTime)(/*[out, retval]*/ DATE *pdateScheduledTime);
	STDMETHOD(get_SubmissionTime)(/*[out, retval]*/ DATE *pdateSubmissionTime);
	STDMETHOD(get_Priority)(/*[out, retval]*/ FAX_PRIORITY_TYPE_ENUM *pPriority);
    STDMETHOD(get_GroupBroadcastReceipts)(VARIANT_BOOL *pbGroupBroadcastReceipts);

// specific for Inbound Job
    STDMETHOD(get_CallerId)(/*[out, retval]*/ BSTR *pbstrCallerId);
    STDMETHOD(get_JobType)(/*[out, retval]*/ FAX_JOB_TYPE_ENUM *pJobType);
	STDMETHOD(get_RoutingInformation)(/*[out, retval]*/ BSTR *pbstrRoutingInformation);

private:

    DWORDLONG   m_dwlMessageId;
    DWORDLONG   m_dwlBroadcastId;
    DWORD       m_dwReceiptType;
    CComBSTR    m_bstrSubject;
    CComBSTR    m_bstrDocumentName;
    SYSTEMTIME  m_tmOriginalScheduleTime;
    SYSTEMTIME  m_tmSubmissionTime;
    FAX_PRIORITY_TYPE_ENUM      m_Priority;

    CComObject<CFaxJobStatus>   m_JobStatus;
    CComObject<CFaxSender>      *m_pSender;
    CComObject<CFaxRecipient>   *m_pRecipient;

    STDMETHOD(UpdateJob)(FAX_ENUM_JOB_COMMANDS cmdToPerform);
};

//
//====================== GET JOB TYPE ===============================
//
template<class T, const IID* piid, const CLSID* pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_JobType(
    FAX_JOB_TYPE_ENUM *pJobType
)
/*++

Routine name : CFaxJobInner::get_JobType

Routine description:

    Return the Type of the Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pJobType             [out]    - Return Value of Job Type
    
Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_JobType"), hr);
    hr = m_JobStatus.get_JobType(pJobType);
    return hr;
}

//
//==================== INIT ===================================================
//
template<class T, const IID* piid, const CLSID* pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::Init(
    PFAX_JOB_ENTRY_EX pFaxJob,
    IFaxServerInner* pFaxServerInner
)
/*++

Routine name : CFaxJobInner::Init

Routine description:

    Initialize the JobInner Class : store Job Information and Ptr to Server

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pFaxJob                   [in]    - Job Info
    pFaxServerInner           [in]    - Ptr to Server

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxJobInner::Init"), hr);

    ATLASSERT(pFaxJob->pStatus);

    //
    //  Store the given structure
    //
    m_dwlMessageId = pFaxJob->dwlMessageId;
    m_dwlBroadcastId = pFaxJob->dwlBroadcastId;
    m_dwReceiptType = pFaxJob->dwDeliveryReportType;
    m_Priority = FAX_PRIORITY_TYPE_ENUM(pFaxJob->Priority);

    m_tmOriginalScheduleTime = pFaxJob->tmOriginalScheduleTime;
    m_tmSubmissionTime = pFaxJob->tmSubmissionTime;

    m_bstrSubject = pFaxJob->lpctstrSubject;
    m_bstrDocumentName = pFaxJob->lpctstrDocumentName;
    if ( (pFaxJob->lpctstrSubject && !m_bstrSubject) ||
         (pFaxJob->lpctstrDocumentName && !m_bstrDocumentName) )
    {
        //
        //  Not enough memory to copy the TSID into CComBSTR
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        return hr;
    }
    
    //
    //  Create Status Object
    //
    hr = m_JobStatus.Init(pFaxJob->pStatus);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr);
        CALL_FAIL(MEM_ERR, _T("m_JobStatus.Init"), hr);
        return hr;
    }

    //
    //  When called from Refresh(), no need to set pFaxServerInner
    //
    if (pFaxServerInner)
    {
        hr = CFaxInitInnerAddRef::Init(pFaxServerInner);
    }
    return hr;
}

//
//====================== GET ID ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Id(
    BSTR *pbstrId
)
/*++

Routine name : CFaxJobInner::get_Id

Routine description:

    Return Unique ID of the Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrId             [out]    - pointer to the place to put the ID 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxJobInner::get_Id"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pbstrId, sizeof(BSTR)))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    //
    //  Translate m_dwlMessageId into BSTR
    //
    TCHAR   tcBuffer[25];
    BSTR    bstrTemp;

    ::_i64tot(m_dwlMessageId, tcBuffer, 16);
    bstrTemp = ::SysAllocString(tcBuffer);
    if (!bstrTemp)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr);
        CALL_FAIL(MEM_ERR, _T("SysAllocString()"), hr);
        return hr;
    }

    *pbstrId = bstrTemp;
    return hr;
}

//
//====================== GET SIZE ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Size(
    long *plSize
)
/*++

Routine name : CFaxJobInner::get_Size

Routine description:

    Return Size ( in bytes ) of Fax Job's TIFF File

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plSize                  [out]    - Pointer to the place to put Size

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_Size"), hr);
    hr = m_JobStatus.get_Size(plSize);
    return hr;
}

//
//====================== GET CURRENT PAGE =============================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_CurrentPage(
    long *plCurrentPage
)
/*++

Routine name : CFaxJobInner::get_CurrentPage

Routine description:

    Current Page number being received / sent

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plCurrentPage           [out]    - Pointer to the place to put the Current Page Number

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_CurrentPage"), hr);
    hr = m_JobStatus.get_CurrentPage(plCurrentPage);
	return hr;
}

//
//====================== GET DEVICE ID =============================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_DeviceId(
    long *plDeviceId
)
/*++

Routine name : CFaxJobInner::get_DeviceId

Routine description:

    The Device Id by which the Job is being sent / received.

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plDeviceId              [out]    - Pointer to the place to put the Device Id
    
Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_DeviceId"), hr);
    hr = m_JobStatus.get_DeviceId(plDeviceId);
	return hr;
}

//
//====================== GET STATUS =============================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Status(
    FAX_JOB_STATUS_ENUM *pStatus
)
/*++

Routine name : CFaxJobInner::get_Status

Routine description:

    The current Queue Status of the Fax Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pStatus                    [out]    - Pointer to the place to put the Bit-Wise Combination of status
    
Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_Status"), hr);
    hr = m_JobStatus.get_Status(pStatus);
	return hr;
}

//
//====================== GET EXTENDED STATUS CODE ===============================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_ExtendedStatusCode(
    FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode
)
/*++

Routine name : CFaxJobInner::get_ExtendedStatusCode

Routine description:

    The Code of the Extended Status of the Fax Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pExtendedStatusCode             [out]    - Pointer to the place to put the status code
    
Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_ExtendedStatusCode"), hr);
    hr = m_JobStatus.get_ExtendedStatusCode(pExtendedStatusCode);
    return hr;
}

//
//====================== GET RETRIES =============================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Retries(
    long *plRetries
)
/*++

Routine name : CFaxJobInner::get_Retries

Routine description:

    The number of unsuccessful retries of the Fax Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plRetries                    [out]    - Pointer to the place to put the number of Retries
    
Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_Retries"), hr);
    hr = m_JobStatus.get_Retries(plRetries);
	return hr;
}

//
//====================== GET TSID ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_TSID(
    BSTR *pbstrTSID
)
/*++

Routine name : CFaxJobInner::get_TSID

Routine description:

    Return Transmitting Station ID of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrTSID             [out]    - pointer to the place to put the TSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_TSID"), hr);
    hr = m_JobStatus.get_TSID(pbstrTSID);
	return hr;
}

//
//====================== GET CSID ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_CSID(
    BSTR *pbstrCSID
)
/*++

Routine name : CFaxJobInner::get_CSID

Routine description:

    Return Called Station ID of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrCSID             [out]    - pointer to the place to put the CSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_CSID"), hr);
    hr = m_JobStatus.get_CSID(pbstrCSID);
    return hr;
}

//
//====================== GET EXTENDED STATUS =======================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_ExtendedStatus(
    BSTR *pbstrExtendedStatus
)
/*++

Routine name : CFaxJobInner::get_ExtendedStatus

Routine description:

    Return String Description of the Extended Status of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrExtendedStatus             [out]    - pointer to the place to put the Extended Status 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_ExtendedStatus"), hr);
    hr = m_JobStatus.get_ExtendedStatus(pbstrExtendedStatus);
	return hr;
}

//
//====================== GET SUBJECT ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Subject(
    BSTR *pbstrSubject
)
/*++

Routine name : CFaxJobInner::get_Subject

Routine description:

    Return the Subject field of the Cover Page

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrSubject            [out]    - pointer to the place to put Subject contents

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_Subject"), hr);

    hr = GetBstr(pbstrSubject, m_bstrSubject);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== GET CALLER ID ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_CallerId(
    BSTR *pbstrCallerId
)
/*++

Routine name : CFaxJobInner::get_CallerId

Routine description:

    Return the Caller Id of Job's Phone Call

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrCallerId           [out]    - pointer to the place to put the Caller Id

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_CallerId"), hr);
    hr = m_JobStatus.get_CallerId(pbstrCallerId);
    return hr;
}

//
//====================== GET ROUTING INFORMATION ======================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_RoutingInformation(
    BSTR *pbstrRoutingInformation
)
/*++

Routine name : CFaxJobInner::get_RoutingInformation

Routine description:

    Return the Routing Information of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrRoutingInformation         [out]    - pointer to place to put Routing Information

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_RoutingInformation"), hr);
    hr = m_JobStatus.get_RoutingInformation(pbstrRoutingInformation);
	return hr;
}

//
//====================== GET DOCUMENT NAME ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_DocumentName(
    BSTR *pbstrDocumentName
)
/*++

Routine name : CFaxJobInner::get_DocumentName

Routine description:

    Return the Friendly Name of the Document

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrDocumentName             [out]    - pointer to the place to put Document Name

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_DocumentName"), hr);

    hr = GetBstr(pbstrDocumentName, m_bstrDocumentName);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== GET PAGES ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Pages(
    long *plPages
)
/*++

Routine name : CFaxJobInner::get_Pages

Routine description:

    Return total number of pages of the message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plPages                 [out]    - Pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_Pages"), hr);
    hr = m_JobStatus.get_Pages(plPages);
	return hr;
}


//
//====================== GET PRIORITY ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Priority(
    FAX_PRIORITY_TYPE_ENUM  *pPriority
)
/*++

Routine name : CFaxJobInner::get_Priority

Routine description:

    Return the Priority of Fax Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pPriority                  [out]    - Pointer to the place to put the Priority

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_Priority"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pPriority, sizeof(FAX_PRIORITY_TYPE_ENUM)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr"), hr);
        return hr;
    }

    *pPriority = m_Priority;
    return hr;
}

//
//====================== GET AVAILABLE OPERATIONS ==================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_AvailableOperations(
    FAX_JOB_OPERATIONS_ENUM  *pAvailableOperations
)
/*++

Routine name : CFaxJobInner::get_AvailableOperations

Routine description:

    The operations available for the Fax Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pAvailableOperations                 [out]    - Pointer to the place to put the Bit-Wise Combination of result
    
Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_AvailableOperations"), hr);
    hr = m_JobStatus.get_AvailableOperations(pAvailableOperations);
	return hr;
}


//
//====================== GET SUBMISSION ID ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_SubmissionId(
    BSTR *pbstrSubmissionId
)
/*++

Routine name : CFaxJobInner::get_SubmissionId

Routine description:

    Return Submission ID of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrSubmissionId             [out]    - pointer to the place to put the Submission ID 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_SubmissionId"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pbstrSubmissionId, sizeof(BSTR)))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    //
    //  Translate m_dwlBroadcastId into BSTR
    //
    TCHAR   tcBuffer[25];
    BSTR    bstrTemp;

    ::_i64tot(m_dwlBroadcastId, tcBuffer, 16);
    bstrTemp = ::SysAllocString(tcBuffer);
    if (!bstrTemp)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr);
        CALL_FAIL(MEM_ERR, _T("SysAllocString()"), hr);
        return hr;
    }

    *pbstrSubmissionId = bstrTemp;
    return hr;
}
    
//
//====================== GET RECIPIENT ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP
CFaxJobInner<T, piid, pcid>::get_Recipient(
    /*[out, retval] */IFaxRecipient **ppRecipient
)
/*++

Routine name : CFaxJobInner::get_Recipient

Routine description:

    Return Job's Recipient Information

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    ppRecipient                 [out]    - Ptr to the Place to put Recipient Information

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxJobInner::get_Recipient"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(ppRecipient, sizeof(IFaxRecipient* )))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    if (!m_pRecipient)
    {
        //
        //  First Time Calling. Take the Recipient Info from Server
        //

        //
        //  Get Fax Server Handle
        //
        HANDLE  hFaxHandle = NULL;
        hr = GetFaxHandle(&hFaxHandle);
        if (FAILED(hr))
        {
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            return hr;
        }

        //
        //  Get Personal Profile Info
        //
        CFaxPtr<FAX_PERSONAL_PROFILE>   pPersonalProfile;
        if (!FaxGetRecipientInfo(hFaxHandle, m_dwlMessageId, FAX_MESSAGE_FOLDER_QUEUE, &pPersonalProfile))
        {
            //
            //  Failed to get Personal Profile Info
            //
            hr = Fax_HRESULT_FROM_WIN32(GetLastError());
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            CALL_FAIL(GENERAL_ERR, _T("FaxGetRecipientInfo()"), hr);
            return hr;
        }

        //
        //  Check that pPersonalProfile is valid
        //
	    if (!pPersonalProfile || pPersonalProfile->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE))
	    {
		    //
		    //	Failed to Get Personal Profile
		    //
		    hr = E_FAIL;
		    AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		    CALL_FAIL(GENERAL_ERR, _T("Invalid pPersonalProfile"), hr);
		    return hr;
	    }

        //
        //  Create Recipient Object
        //
        hr = CComObject<CFaxRecipient>::CreateInstance(&m_pRecipient);
        if (FAILED(hr) || !m_pRecipient)
        {
            hr = E_OUTOFMEMORY;
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxRecipient>::CreateInstance(&m_pRecipient)"), hr);
            return hr;
        }

        //
        //  We want Recipient object to live
        //
        m_pRecipient->AddRef();

        //
        //  Fill the Data
        //
        hr = m_pRecipient->PutRecipientProfile(pPersonalProfile);
        if (FAILED(hr))
        {
            //
            //  Failed to fill the Recipient's Object with RPC's data
            //
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            CALL_FAIL(GENERAL_ERR, _T("m_pRecipient->PutRecipientProfile(pPersonalProfile)"), hr);
            m_pRecipient->Release();
            m_pRecipient = NULL;
            return hr;
        }
    }

    //
    //  Return Recipient Object to Caller
    //
    hr = m_pRecipient->QueryInterface(ppRecipient);
    if (FAILED(hr))
    {
        //
        //  Failed to Query Interface
        //
        AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
        CALL_FAIL(MEM_ERR, _T("CComObject<CFaxRecipient>::QueryInterface()"), hr);
        return hr;
    }

    return hr;
}

//
//====================== GET SENDER ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP
CFaxJobInner<T, piid, pcid>::get_Sender(
    /*[out, retval] */IFaxSender **ppSender
)
/*++

Routine name : CFaxJobInner::get_Sender

Routine description:

    Return Job's Sender Information

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    ppSender                [out]    - Ptr to the Place to put Sender Information

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxJobInner::get_Sender"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(ppSender, sizeof(IFaxSender* )))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    if (!m_pSender)
    {
        //
        //  The Function is called for the First Time. Let's bring Sender's Data from Server
        //

        //
        //  Get Fax Server Handle
        //
        HANDLE  hFaxHandle = NULL;
        hr = GetFaxHandle(&hFaxHandle);
        if (FAILED(hr))
        {
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            return hr;
        }

        //
        //  Get Personal Profile Info
        //
        CFaxPtr<FAX_PERSONAL_PROFILE>   pPersonalProfile;
        if (!FaxGetSenderInfo(hFaxHandle, m_dwlMessageId, FAX_MESSAGE_FOLDER_QUEUE, &pPersonalProfile))
        {
            //
            //  Failed to get Personal Profile Info
            //
            hr = Fax_HRESULT_FROM_WIN32(GetLastError());
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            CALL_FAIL(GENERAL_ERR, _T("FaxGetSenderInfo()"), hr);
            return hr;
        }

        //
        //  Check that pPersonalProfile is valid
        //
	    if (!pPersonalProfile || pPersonalProfile->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE))
	    {
		    //
		    //	Failed to Get Personal Profile
		    //
		    hr = E_FAIL;
		    AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		    CALL_FAIL(GENERAL_ERR, _T("Invalid pPersonalProfile"), hr);
		    return hr;
	    }

        //
        //  Create Sender Object
        //
        hr = CComObject<CFaxSender>::CreateInstance(&m_pSender);
        if (FAILED(hr) || !m_pSender)
        {
            hr = E_OUTOFMEMORY;
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxSender>::CreateInstance(&m_pSender)"), hr);
            return hr;
        }

        //
        //  We want Sender object to live
        //
        m_pSender->AddRef();

        //
        //  Fill the Data
        //
        hr = m_pSender->PutSenderProfile(pPersonalProfile);
        if (FAILED(hr))
        {
            //
            //  Failed to fill the Sender's Object with RPC's data
            //
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            CALL_FAIL(GENERAL_ERR, _T("m_pSender->PutSenderProfile(pPersonalProfile)"), hr);
            m_pSender->Release();
            m_pSender = NULL;
            return hr;
        }
    }

    //
    //  Return Sender Object to Caller
    //
    hr = m_pSender->QueryInterface(ppSender);
    if (FAILED(hr))
    {
        //
        //  Failed to Query Interface
        //
        AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
        CALL_FAIL(MEM_ERR, _T("CComObject<CFaxSender>::QueryInterface()"), hr);
        return hr;
    }
    return hr;
}

//
//========================= GET ORIGINAL SCHEDULED TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_OriginalScheduledTime(
    DATE *pdateOriginalScheduledTime
)
/*++

Routine name : CFaxJobInner::get_OriginalScheduledTime

Routine description:

    Return Time the Job was originally scheduled

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateOriginalScheduledTime      [out]    - pointer to place to put Original Scheduled Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_OriginalScheduledTime"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateOriginalScheduledTime, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    hr = SystemTime2LocalDate(m_tmOriginalScheduleTime, pdateOriginalScheduledTime);
    if (FAILED(hr))
    {
        //
        //  Failed to convert the system time to localized variant date
        //
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    return hr;
}

//
//========================= GET SUBMISSION TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_SubmissionTime(
    DATE *pdateSubmissionTime
)
/*++

Routine name : CFaxJobInner::get_SubmissionTime

Routine description:

    Return Time the Job was submitted

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateSubmissionTime      [out]    - pointer to place to put Submission Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_SubmissionTime"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateSubmissionTime, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    hr = SystemTime2LocalDate(m_tmSubmissionTime, pdateSubmissionTime);
    if (FAILED(hr))
    {
        //
        //  Failed to convert the system time to localized variant date
        //
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    return hr;
}

//
//========================= GET SCHEDULED TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_ScheduledTime(
    DATE *pdateScheduledTime
)
/*++

Routine name : CFaxJobInner::get_ScheduledTime

Routine description:

    Return Time the Job is scheduled

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateScheduledTime      [out]    - pointer to place to put Scheduled Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_ScheduledTime"), hr);
    hr = m_JobStatus.get_ScheduledTime(pdateScheduledTime);
    return hr;
}

//
//========================= GET TRANSMISSION START ===============================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_TransmissionStart(
    DATE *pdateTransmissionStart
)
/*++

Routine name : CFaxJobInner::get_TransmissionStart

Routine description:

    Return Time the Job is started to transmit

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateTransmissionStart      [out]    - pointer to place to put the Transmission Start

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_TransmissionStart"), hr);
    hr = m_JobStatus.get_TransmissionStart(pdateTransmissionStart);
    return hr;
}

//    
//====================== GET GROUP BROADCAST REPORTS ========================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_GroupBroadcastReceipts(
    VARIANT_BOOL *pbGroupBroadcastReceipts
)
/*++

Routine name : CFaxJobInner::get_GroupBroadcastReceipts

Routine description:

    Return whether Receipts are grouped

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbGroupBroadcastReceipts      [out]    - pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_GroupBroadcastReceipts"), hr);

    hr = GetVariantBool(pbGroupBroadcastReceipts, ((m_dwReceiptType & DRT_GRP_PARENT) ? VARIANT_TRUE : VARIANT_FALSE));
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//    
//====================== GET RECEIPT TYPE ========================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_ReceiptType(
    FAX_RECEIPT_TYPE_ENUM *pReceiptType
)
/*++

Routine name : CFaxJobInner::get_ReceiptType

Routine description:

    Return the type of the receipts

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbReceiptType      [out]    - pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_ReceiptType"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pReceiptType, sizeof(FAX_RECEIPT_TYPE_ENUM)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    //
    //  return the delivery report type WITHOUT the modifiers bit
    //
    *pReceiptType = FAX_RECEIPT_TYPE_ENUM((m_dwReceiptType) & (~DRT_MODIFIERS));
    return hr;
}

//
//====================== COPY TIFF ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::CopyTiff(
    /*[in]*/ BSTR bstrTiffPath
)
/*++

Routine name : CFaxJobInner::CopyTiff

Routine description:

    Copies the Job's Tiff Image to a file on the local computer.

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    bstrTiffPath                  [in]    - the file to copy to

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    HANDLE      hFaxHandle = NULL;

    DBG_ENTER (TEXT("CFaxJobInner::CopyTiff"), hr, _T("%s"), bstrTiffPath);

    //
    //  Get Fax Server Handle
    //
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    if (!FaxGetMessageTiff(hFaxHandle, m_dwlMessageId, FAX_MESSAGE_FOLDER_QUEUE, bstrTiffPath))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        CALL_FAIL(GENERAL_ERR, 
            _T("FaxGetMessageTiff(hFaxHandle, m_pJobInfo->dwlMessageId, FAX_MESSAGE_FOLDER_QUEUE, bstrTiffPath)"), 
            hr);
        return hr;
    }

    return hr;
}

//
//====================== CANCEL ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::Cancel(
)
/*++

Routine name : CFaxJobInner::Cancel

Routine description:

    Cancel the Job

Author:

    Iv Garber (IvG),    May, 2000

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::Cancel"), hr);
    hr = UpdateJob(JC_DELETE);
    return hr;
}

//
//====================== PAUSE ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::Pause(
)
/*++

Routine name : CFaxJobInner::Pause

Routine description:

    Pause the Job

Author:

    Iv Garber (IvG),    May, 2000

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    HANDLE      hFaxHandle = NULL;
    hr = UpdateJob(JC_PAUSE);
    return hr;
}

//
//====================== RESUME ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::Resume(
)
/*++

Routine name : CFaxJobInner::Resume

Routine description:

    Resume the Job

Author:

    Iv Garber (IvG),    May, 2000

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::Resume"), hr);
    hr = UpdateJob(JC_RESUME);
    return hr;
}

//
//====================== RESTART ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::Restart(
)
/*++

Routine name : CFaxJobInner::Restart

Routine description:

    Restart the Job

Author:

    Iv Garber (IvG),    May, 2000

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::Restart"), hr);
    hr = UpdateJob(JC_RESTART);
    return hr;
}

//
//====================== GET TRANSMISSION END ======================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_TransmissionEnd(
    DATE *pdateTransmissionEnd
)
/*++

Routine name : CFaxJobInner::get_TransmissionEnd

Routine description:

    Return Job's Transmission End

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateTransmissionEnd            [out]    - pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_TransmissionEnd"), hr);
    hr = m_JobStatus.get_TransmissionEnd(pdateTransmissionEnd);
    return hr;
}

//
//====================== REFRESH ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::Refresh(
)
/*++

Routine name : CFaxJobInner::Refresh

Routine description:

    Refresh the Job

Author:

    Iv Garber (IvG),    May, 2000

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    HANDLE      hFaxHandle = NULL;

    DBG_ENTER (TEXT("CFaxJobInner::Refresh"), hr);

    //
    //  Get Fax Server Handle
    //
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    CFaxPtr<FAX_JOB_ENTRY_EX>   pJobInfo;
    if (!FaxGetJobEx(hFaxHandle, m_dwlMessageId, &pJobInfo))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxGetJobEx(hFaxHandle, m_pJobInfo->dwlMessageId, &m_pJobInfo)"), hr);
        return hr;
    }

    hr = Init(pJobInfo, NULL);

    return hr;
}

//
//====================== UPDATE JOB ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::UpdateJob(
    FAX_ENUM_JOB_COMMANDS   cmdToPerform
)
/*++

Routine name : CFaxJobInner::Update

Routine description:

    Perform the desired operation on the Job

Author:

    Iv Garber (IvG),    June, 2000

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    HANDLE      hFaxHandle = NULL;

    DBG_ENTER (TEXT("CFaxJobInner::Update"), hr, _T("command is : %d"), cmdToPerform);

    //
    //  Get Fax Server Handle
    //
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    FAX_JOB_ENTRY fje = {0};
    fje.SizeOfStruct = sizeof(FAX_JOB_ENTRY);

    if (!FaxSetJob(hFaxHandle, m_JobStatus.GetJobId(), cmdToPerform, &fje))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        CALL_FAIL(GENERAL_ERR, 
            _T("FaxSetJob(hFaxHandle, m_JobStatus.GtJobId(), cmdToPerform, &fje)"), 
            hr);
        return hr;
    }

    return hr;
}

#endif //   __FAXJOBINNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxincomingmessage.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingMessage.cpp

Abstract:

	Implementation of Fax Inbound Message COM Object

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxIncomingMessage.h"

//
//=================== SUPPORT ERROR INFO =======================================
//
STDMETHODIMP 
CFaxIncomingMessage::InterfaceSupportsErrorInfo(
	REFIID riid
)
{
	static const IID* arr[] = 
	{
		&IID_IFaxIncomingMessage
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxIncomingMessage::Create (
	IFaxIncomingMessage **ppIncomingMessage
)
/*++

Routine name : CFaxIncomingMessage::Create

Routine description:

	Static function to create the Fax Inbound Message Instance

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	ppIncomingMessage             [out]  -- the new Fax Inbound Message Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxIncomingMessage>		*pClass;
	HRESULT								hr = S_OK;

	DBG_ENTER (TEXT("CFaxIncomingMessage::Create"), hr);

	hr = CComObject<CFaxIncomingMessage>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxIncomingMessage>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxIncomingMessage),
		(void **) ppIncomingMessage);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Inbound Message Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}	//	CFaxIncomingMessage::Create()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxincomingmessageiterator.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingMessageIterator.h

Abstract:

	Definition of Incoming Message Iterator.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXINCOMINGMESSAGEITERATOR_H_
#define __FAXINCOMINGMESSAGEITERATOR_H_

#include "resource.h"       // main symbols
#include "FaxIncomingMessage.h"
#include "FaxMessageIteratorInner.h"


//
//====================== INCOMING MESSAGE ITERATOR =======================================
//
class ATL_NO_VTABLE CFaxIncomingMessageIterator : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxMessageIteratorInner<IFaxIncomingMessageIterator, 
		&IID_IFaxIncomingMessageIterator, &CLSID_FaxIncomingMessageIterator, 
		FAX_MESSAGE_FOLDER_INBOX,
		IFaxIncomingMessage, CFaxIncomingMessage>
{
public:
	CFaxIncomingMessageIterator()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINCOMINGMESSAGEITERATOR)
DECLARE_NOT_AGGREGATABLE(CFaxIncomingMessageIterator)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxIncomingMessageIterator)
	COM_INTERFACE_ENTRY(IFaxIncomingMessageIterator)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//	Interfaces
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//	Internal Use
static HRESULT Create(IFaxIncomingMessageIterator **pIncomingMsgIterator);

};

#endif //__FAXINCOMINGMESSAGEITERATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxincomingqueue.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingQueue.cpp

Abstract:

	Implementation of CFaxIncomingQueue

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxIncomingQueue.h"


//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxIncomingQueue::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxIncomingQueue::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Interface Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Reference of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxIncomingQueue
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxjobscollection.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxJobsCollection.h

Abstract:

	Implementation of Copy Policy Classes and Job Collection Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXJOBSCOLLECTION_H_
#define __FAXJOBSCOLLECTION_H_

#include "VCUE_Copy.h"

//
//================= FAX JOB COLLECTION TEMPLATE ================================
//
template <class CollectionIfc, class ContainerType, class CollectionExposedType, class CollectionCopyType, 
         class EnumType, class JobClass, const IID* piid, const CLSID* pcid>
class JobCollection : public ICollectionOnSTLImpl<CollectionIfc, ContainerType, CollectionExposedType*, 
    CollectionCopyType, EnumType>
{
public :
    JobCollection()
    {
        DBG_ENTER(_T("JOB COLLECTION :: CREATE"));
    }
    ~JobCollection()
    {
        DBG_ENTER(_T("JOB COLLECTION :: DESTROY"));
        CCollectionKiller<ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }

//  Interfaces
    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ CollectionExposedType **pFaxJob);

//  Internal Use
    HRESULT Init(FAX_JOB_ENTRY_EX*  pJobs, DWORD dwJobCount, IFaxServerInner *pFaxServerInner);
};

//
//============================= GET ITEM =========================================
//
template <class CollectionIfc, class ContainerType, class CollectionExposedType, 
            class CollectionCopyType, class EnumType, class JobClass, const IID* piid, 
            const CLSID* pcid>
STDMETHODIMP
JobCollection<CollectionIfc, ContainerType, CollectionExposedType, CollectionCopyType, EnumType, JobClass, 
    piid, pcid>::get_Item(
        /*[in]*/ VARIANT vIndex, 
        /*[out, retval]*/ CollectionExposedType **pFaxJob
)
/*++

Routine name : JobCollection::get_Item

Routine description:

	Return Item Job from the Collection.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	vIndex                        [in]    - Index of the Job to find
	pFaxJob                       [out]    - the resulting Job Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("JobCollection::get_Item"), hr);

    if (::IsBadWritePtr(pFaxJob, sizeof(CollectionExposedType *)))
    {
        //
        //  Invalid Argument
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pFaxJob)"), hr);
		return hr;
    }

    CComVariant var;

    if (vIndex.vt != VT_BSTR)
    {
        //
        //  vIndex is not BSTR ==> convert to VT_I4
        //
        hr = var.ChangeType(VT_I4, &vIndex);
        if (SUCCEEDED(hr))
        {
            VERBOSE(DBG_MSG, _T("Parameter is Number : %d"), var.lVal);
            //
            //  call default ATL's implementation
            //
            hr = ICollectionOnSTLImpl<CollectionIfc, ContainerType, CollectionExposedType*, 
                CollectionCopyType, EnumType>::get_Item(var.lVal, pFaxJob);
            return hr;
		}
    }

    //
    //  convert to BSTR
    //
    hr = var.ChangeType(VT_BSTR, &vIndex);
    if (FAILED(hr))
    {
        //
        //  Got wrong vIndex
        //
        hr = E_INVALIDARG;
        AtlReportError(*pcid, IDS_ERROR_INVALIDINDEX, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("var.ChangeType(VT_BSTR, &vIndex)"), hr);
        return hr;
    }

    VERBOSE(DBG_MSG, _T("Parameter is String : %s"), var.bstrVal);

    ContainerType::iterator it = m_coll.begin();
    while (it != m_coll.end())
    {
        CComBSTR    bstrMsgId;
        hr = (*it)->get_Id(&bstrMsgId);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("it->get_Id(&dwlMsgid)"), hr);
		    AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
		    return hr;
        }

        if (_tcsicmp(bstrMsgId, var.bstrVal) == 0)
        {
            //
            //  found the desired Job
            //
            (*it)->AddRef();
            *pFaxJob = *it;
            return hr;
        }
        it++;
    }

    //
    //  Job not found
    //
	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Job Not Found"), hr);
	AtlReportError(*pcid, IDS_ERROR_INVALIDMSGID, *piid, hr);
	return hr;
}

//
//============================= INIT =========================================
//
template <class CollectionIfc, class ContainerType, class CollectionExposedType, class CollectionCopyType, 
         class EnumType, class JobType, const IID* piid, const CLSID* pcid>
HRESULT
JobCollection<CollectionIfc, ContainerType, CollectionExposedType, CollectionCopyType, EnumType, 
    JobType, piid, pcid>::Init(
        /*[in]*/ FAX_JOB_ENTRY_EX *pJobs, 
        /*[in]*/ DWORD  dwJobCount, 
        /*[in]*/ IFaxServerInner *pFaxServerInner
)
/*++

Routine name : JobCollection::Init

Routine description:

	Fill the collection with pointers to structures

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

    pJobs                     [in]    -   ptr to array of structs
    dwJobCount                [in]    -   num of structs in the array
    pFaxServerInner           [in]    -   ptr to Fax Server object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("JobCollection::Init"), hr);

    //
    //  Fill collection with data :
    //      create object for each element in structure
    //
    for ( long i = 0 ; i < dwJobCount ; i++ )
    {
        //
    	//	Create Job Object
	    //	
	    CComPtr<CollectionExposedType>   pNewJobObject;
	    hr = JobType::Create(&pNewJobObject);
	    if (FAILED(hr))
	    {
		    AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		    CALL_FAIL(GENERAL_ERR, _T("JobType::Create(&pNewJobObject)"), hr);
		    return hr;
	    }

	    //
	    //	Initialize the Job Object
	    //
	    hr = ((JobType *)((CollectionExposedType *)pNewJobObject))->Init(&pJobs[i], pFaxServerInner);
	    if (FAILED(hr))
	    {
		    AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		    CALL_FAIL(GENERAL_ERR, _T("pNewJobObject->Init()"), hr);
		    return hr;
	    }

	    //
	    //	Put the Object in the collection
	    //
	    try 
	    {
		    m_coll.push_back(pNewJobObject);
	    }
	    catch (exception &)
	    {
		    //
		    //	Failed to put ptr to the new Job Object in the vector
		    //
		    hr = E_OUTOFMEMORY;
		    AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr);
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pNewJobObject.Detach())"), hr);
		    return hr;
	    }

        pNewJobObject.Detach();
    }
    
    return hr;
}

#endif  //   __FAXJOBSCOLLECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxincomingmessage.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingMessage.h

Abstract:

	Definition of CFaxIncomingMessage Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXINCOMINGMESSAGE_H_
#define __FAXINCOMINGMESSAGE_H_

#include "resource.h"       // main symbols
#include "FaxMessageInner.h"

//
//=============== FAX INCOMING MESSAGE =============================================
//
class ATL_NO_VTABLE CFaxIncomingMessage : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxMessageInner<IFaxIncomingMessage, &IID_IFaxIncomingMessage, 
		&CLSID_FaxIncomingMessage, FAX_MESSAGE_FOLDER_INBOX>
{
public:
	CFaxIncomingMessage()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINCOMINGMESSAGE)
DECLARE_NOT_AGGREGATABLE(CFaxIncomingMessage)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxIncomingMessage)
	COM_INTERFACE_ENTRY(IFaxIncomingMessage)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//	Interfaces
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//	Internal Use
static HRESULT Create(IFaxIncomingMessage **ppIncomingMessage);
};

#endif //__FAXINCOMINGMESSAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxincomingmessageiterator.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingMessageIterator.cpp

Abstract:

	Implementation of Incoming Message Iterator Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxIncomingMessageIterator.h"
#include "FaxIncomingMessage.h"


//
//========================== SUPPORT ERROR INFO ===============================
//
STDMETHODIMP 
CFaxIncomingMessageIterator::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxIncomingMessageIterator::InterfaceSupportsErrorInfo

Routine description:

	ATL's support Error Info.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	riid                          [in]    - IID of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxIncomingMessageIterator
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxIncomingMessageIterator::Create (
	IFaxIncomingMessageIterator **pIncomingMsgIterator
)
/*++

Routine name : CFaxIncomingMessageIterator::Create

Routine description:

	Static function to create the Fax Incoming Message Iterator Object

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pIncomingMsgIterator		[out]  -- the new Fax Incoming Message Iterator Object

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxIncomingMessageIterator>		*pClass;
	HRESULT			hr = S_OK;

	DBG_ENTER (TEXT("CFaxIncomingMessageIterator::Create"), hr);

	hr = CComObject<CFaxIncomingMessageIterator>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxIncomingMessageIterator>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxIncomingMessageIterator), (void **) pIncomingMsgIterator);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Incoming Message Iterator Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}
	return hr;
}	//	CFaxIncomingMessageIterator::Create()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxjobstatus.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxJobStatus.h

Abstract:

	Declaration of the CFaxJobStatus Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXJOBSTATUS_H_
#define __FAXJOBSTATUS_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

// 
//==================== JOB STATUS ==========================================
//
class ATL_NO_VTABLE CFaxJobStatus : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxJobStatus, &IID_IFaxJobStatus, &LIBID_FAXCOMEXLib>
{
public:
    CFaxJobStatus()
	{
        DBG_ENTER(_T("FAX JOB STATUS -- CREATE"));
	}

    ~CFaxJobStatus()
	{
        DBG_ENTER(_T("FAX JOB STATUS -- DESTROY"));
	}
DECLARE_REGISTRY_RESOURCEID(IDR_FAXJOBSTATUS)
DECLARE_NOT_AGGREGATABLE(CFaxJobStatus)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxJobStatus)
	COM_INTERFACE_ENTRY(IFaxJobStatus)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_Size)(/*[out, retval]*/ long *plSize);
    STDMETHOD(get_Pages)(/*[out, retval]*/ long *plPages);
    STDMETHOD(get_TSID)(/*[out, retval]*/ BSTR *pbstrTSID);
    STDMETHOD(get_CSID)(/*[out, retval]*/ BSTR *pbstrCSID);
    STDMETHOD(get_Retries)(/*[out, retval]*/ long *plRetries);
    STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *plDeviceId);
    STDMETHOD(get_CallerId)(/*[out, retval]*/ BSTR *pbstrCallerId);
    STDMETHOD(get_CurrentPage)(/*[out, retval]*/ long *plCurrentPage);
    STDMETHOD(get_Status)(/*[out, retval]*/ FAX_JOB_STATUS_ENUM *pStatus);
    STDMETHOD(get_JobType)(/*[out, retval]*/ FAX_JOB_TYPE_ENUM *pJobType);
    STDMETHOD(get_ScheduledTime)(/*[out, retval]*/ DATE *pdateScheduledTime);
    STDMETHOD(get_ExtendedStatus)(/*[out, retval]*/ BSTR *pbstrExtendedStatus);
    STDMETHOD(get_TransmissionEnd)(/*[out, retval]*/ DATE *pdateTransmissionEnd);
    STDMETHOD(get_TransmissionStart)(/*[out, retval]*/ DATE *pdateTransmissionStart);
    STDMETHOD(get_RoutingInformation)(/*[out, retval]*/ BSTR *pbstrRoutingInformation);
    STDMETHOD(get_AvailableOperations)(/*[out, retval]*/ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);
    STDMETHOD(get_ExtendedStatusCode)(/*[out, retval]*/ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);

//  Internal Use
    HRESULT Init(FAX_JOB_STATUS *pJobStatus);
    DWORD   GetJobId(void) { return m_dwJobId; };

private:
    DWORD       m_dwSize;
    DWORD       m_dwJobId;
    DWORD       m_dwRetries;
    DWORD       m_dwDeviceId;
    DWORD       m_dwPageCount;
    DWORD       m_dwCurrentPage;
    DWORD       m_dwQueueStatus;
    DWORD       m_dwValidityMask;
    DWORD       m_dwAvailableOperations;

    CComBSTR    m_bstrTSID;
    CComBSTR    m_bstrCSID;
    CComBSTR    m_bstrCallerId;
    CComBSTR    m_bstrRoutingInfo;
    CComBSTR    m_bstrExtendedStatus;

    SYSTEMTIME  m_dtScheduleTime;
    SYSTEMTIME  m_dtTransmissionEnd;
    SYSTEMTIME  m_dtTransmissionStart;

    FAX_JOB_TYPE_ENUM               m_JobType;
    FAX_JOB_EXTENDED_STATUS_ENUM    m_ExtendedStatusCode;
};

#endif //__FAXJOBSTATUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxloggingoptions.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxLoggingOptions.h

Abstract:

	Declaration of the CFaxLoggingOptions Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXLOGGINGOPTIONS_H_
#define __FAXLOGGINGOPTIONS_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include "FaxActivityLogging.h"
#include "FaxEventLogging.h"


// 
//================== LOGGING OPTIONS =======================================
//
class ATL_NO_VTABLE CFaxLoggingOptions : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxLoggingOptions, &IID_IFaxLoggingOptions, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxLoggingOptions() : CFaxInitInner(_T("FAX LOGGING OPTIONS")),
        m_pEvent(NULL),
        m_pActivity(NULL)
	{
	}
    ~CFaxLoggingOptions()
    {
        //
        //  free all the allocated objects
        //
        if (m_pEvent) 
        {
            delete m_pEvent;
        }

        if (m_pActivity) 
        {
            delete m_pActivity;
        }
    }


DECLARE_REGISTRY_RESOURCEID(IDR_FAXLOGGINGOPTIONS)
DECLARE_NOT_AGGREGATABLE(CFaxLoggingOptions)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxLoggingOptions)
	COM_INTERFACE_ENTRY(IFaxLoggingOptions)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IFaxInitInner)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_EventLogging)(/*[out, retval]*/ IFaxEventLogging **pFaxEventLogging);
    STDMETHOD(get_ActivityLogging)(/*[out, retval]*/ IFaxActivityLogging **pFaxActivityLogging);

private:
    CComContainedObject2<CFaxEventLogging>       *m_pEvent;
    CComContainedObject2<CFaxActivityLogging>    *m_pActivity;
};

#endif //__FAXLOGGINGOPTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxloggingoptions.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxLoggingOptions.cpp

Abstract:

	Implementation of Fax Logging Options Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxLoggingOptions.h"


//
//================== GET ACTIVITY LOGGING OBJECT ==============================
//
STDMETHODIMP 
CFaxLoggingOptions::get_ActivityLogging(
    /*[out, retval]*/ IFaxActivityLogging **ppActivityLogging
)
/*++

Routine name : CFaxLoggingOptions::get_ActivityLogging

Routine description:

	Return Activity Logging Object

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	ppActivityLogging              [out]    - the Activity Logging Object

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxLoggingOptions::get_ActivityLogging"), hr);

    CObjectHandler<CFaxActivityLogging, IFaxActivityLogging>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppActivityLogging, &m_pActivity, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxLoggingOptions,
            GetErrorMsgId(hr), 
            IID_IFaxLoggingOptions, 
            hr);
        return hr;
    }
    return hr;
}

//
//================== GET EVENT LOGGING OBJECT ==============================
//
STDMETHODIMP 
CFaxLoggingOptions::get_EventLogging(
    /*[out, retval]*/ IFaxEventLogging **ppEventLogging
)
/*++

Routine name : CFaxLoggingOptions::get_EventLogging

Routine description:

	Return Event Logging Object

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	ppEventLogging              [out]    - the Event Logging Object

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxLoggingOptions::get_EventLogging"), hr);

    CObjectHandler<CFaxEventLogging, IFaxEventLogging>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppEventLogging, &m_pEvent, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxLoggingOptions,
            GetErrorMsgId(hr), 
            IID_IFaxLoggingOptions, 
            hr);
        return hr;
    }
    return hr;
}

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxLoggingOptions::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxLoggingOptions::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	riid                          [in]    - Reference to the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxLoggingOptions,
		&IID_IFaxEventLogging,      // Contained object
		&IID_IFaxActivityLogging    // Contained object
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxmessageinner.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxMessageInner.h

Abstract:

    Implementation of Fax Message Inner Class : 
        Base Class for Inbound and Outbound Message Classes.

Author:

    Iv Garber (IvG) May, 2000

Revision History:

--*/


#ifndef __FAXMESSAGEINNER_H_
#define __FAXMESSAGEINNER_H_

#include "FaxCommon.h"
#include "FaxSender.h"

//
//===================== FAX MESSAGE INNER CLASS ===============================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
class CFaxMessageInner : 
    public IDispatchImpl<T, piid, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxMessageInner() : CFaxInitInnerAddRef(_T("FAX MESSAGE INNER"))
    {
        m_pSender = NULL;
        m_pRecipient = NULL;
    };

    virtual ~CFaxMessageInner() 
    {
        if (m_pSender)
        {
            m_pSender->Release();
        }
        if (m_pRecipient)
        {
            m_pRecipient->Release();
        }
    };

    STDMETHOD(Init)(PFAX_MESSAGE pFaxMessage, IFaxServerInner* pFaxServerInner);

    STDMETHOD(get_Id)(/*[out, retval]*/ BSTR *pbstrId);
    STDMETHOD(get_SubmissionId)(/*[out, retval] */BSTR *pbstrSubmissionId);
    STDMETHOD(get_DeviceName)(/*[out, retval]*/ BSTR *pbstrDeviceName);
    STDMETHOD(get_TSID)(/*[out, retval]*/ BSTR *pbstrTSID);
    STDMETHOD(get_CSID)(/*[out, retval]*/ BSTR *pbstrCSID);
    STDMETHOD(get_CallerId)(/*[out, retval]*/ BSTR *pbstrCallerId);
    STDMETHOD(get_RoutingInformation)(/*[out, retval]*/ BSTR *pbstrRoutingInformation);
    STDMETHOD(get_DocumentName)(/*[out, retval] */BSTR *pbstrDocumentName);
    STDMETHOD(get_Subject)(/*[out, retval] */BSTR *pbstrSubject);
    STDMETHOD(get_Size)(/*[out, retval]*/ long *plSize);
    STDMETHOD(get_Pages)(/*[out, retval]*/ long *plPages);
    STDMETHOD(get_Retries)(/*[out, retval]*/ long *plRetries);
    STDMETHOD(get_Priority)(/*[out, retval] */FAX_PRIORITY_TYPE_ENUM *pPriority);
    STDMETHOD(get_TransmissionStart)(/*[out, retval]*/ DATE *pdateTransmissionStart);
    STDMETHOD(get_TransmissionEnd)(/*[out, retval]*/ DATE *pdateTransmissionEnd);
    STDMETHOD(get_OriginalScheduledTime)(/*[out, retval] */DATE *pdateOriginalScheduledTime);
    STDMETHOD(get_SubmissionTime)(/*[out, retval] */DATE *pdateSubmissionTime);

    STDMETHOD(CopyTiff)(/*[in]*/ BSTR bstrTiffPath);
    STDMETHOD(Delete)();

    STDMETHOD(get_Sender)(/*[out, retval] */IFaxSender **ppFaxSender);
    STDMETHOD(get_Recipient)(/*[out, retval] */IFaxRecipient **ppFaxRecipient);
private:
    CComBSTR    m_bstrSubmissionId;
    CComBSTR    m_bstrTSID;
    CComBSTR    m_bstrDeviceName;
    CComBSTR    m_bstrCSID;
    CComBSTR    m_bstrCallerId;
    CComBSTR    m_bstrRoutingInfo;
    CComBSTR    m_bstrDocName;
    CComBSTR    m_bstrSubject;
    CComBSTR    m_bstrNote;
    long        m_lSize;
    long        m_lPages;
    long        m_lRetries;
    DATE        m_dtTransmissionStart;
    DATE        m_dtTransmissionEnd;
    DATE        m_dtOriginalScheduledTime;
    DATE        m_dtSubmissionTime;
	DWORD		m_dwValidityMask;
    DWORDLONG   m_dwlMsgId;

    FAX_PRIORITY_TYPE_ENUM  m_Priority;

    CComObject<CFaxSender>      *m_pSender;
    CComObject<CFaxRecipient>   *m_pRecipient;
};

//
//====================== GET ID ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_Id(
    BSTR *pbstrId
)
/*++

Routine name : CFaxMessageInner::get_Id

Routine description:

    Return Unique ID of the Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrId             [out]    - pointer to the place to put the ID 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxMessageInner::get_Id"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pbstrId, sizeof(BSTR)))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    //
    //  Convert m_dwlMsgId into BSTR pbstrId
    //
    hr = GetBstrFromDwordlong(m_dwlMsgId, pbstrId);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    return hr;
}

//
//====================== GET SIZE ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_Size(
    long *plSize
)
/*++

Routine name : CFaxMessageInner::get_Size

Routine description:

    Return Size ( in bytes ) of Fax Message's TIFF File

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plSize                  [out]    - Pointer to the place to put Size

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_Size"), hr);

    hr = GetLong(plSize, m_lSize);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== GET PAGES ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_Pages(
    long *plPages
)
/*++

Routine name : CFaxMessageInner::get_Pages

Routine description:

    Return total number of pages of the message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plPages                 [out]    - Pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_Pages"), hr);

    hr = GetLong(plPages, m_lPages);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== GET TSID ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_TSID(
    BSTR *pbstrTSID
)
/*++

Routine name : CFaxMessageInner::get_TSID

Routine description:

    Return Transmitting Station ID of the Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrTSID             [out]    - pointer to the place to put the TSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_TSID"), hr);

    hr = GetBstr(pbstrTSID, m_bstrTSID);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== GET CSID ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_CSID(
    BSTR *pbstrCSID
)
/*++

Routine name : CFaxMessageInner::get_CSID

Routine description:

    Return Called Station ID of the Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrCSID             [out]    - pointer to the place to put the CSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_CSID"), hr);

    hr = GetBstr(pbstrCSID, m_bstrCSID);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== GET PRIORITY ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_Priority(
    FAX_PRIORITY_TYPE_ENUM  *pPriority
)
/*++

Routine name : CFaxMessageInner::get_Priority

Routine description:

    Return the Priority of Fax Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pPriority                  [out]    - Pointer to the place to put the Priority

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_Priority"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pPriority, sizeof(FAX_PRIORITY_TYPE_ENUM)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr"), hr);
        return hr;
    }

    *pPriority = FAX_PRIORITY_TYPE_ENUM(m_Priority);
    return hr;
}

//
//====================== GET RETRIES ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_Retries(
    long *plRetries
)
/*++

Routine name : CFaxMessageInner::get_Retries

Routine description:

    Number of failed transmission retries

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plRetries             [out]    - Pointer to the place to put Retries value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxMessageInner::get_Retries"), hr);

    hr = GetLong(plRetries, m_lRetries);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== GET DEVICE NAME ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_DeviceName(
    BSTR *pbstrDeviceName
)
/*++

Routine name : CFaxMessageInner::get_DeviceName

Routine description:

    Return the Name of the Device by which the Message was Received / Transmitted.

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrDeviceName             [out]    - pointer to the place to put the Device Name

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_DeviceName"), hr);

    hr = GetBstr(pbstrDeviceName, m_bstrDeviceName);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== GET DOCUMENT NAME ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_DocumentName(
    BSTR *pbstrDocumentName
)
/*++

Routine name : CFaxMessageInner::get_DocumentName

Routine description:

    Return the Friendly Name of the Document

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrDocumentName             [out]    - pointer to the place to put Document Name

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_DocumentName"), hr);

    hr = GetBstr(pbstrDocumentName, m_bstrDocName);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== GET SUBJECT ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_Subject(
    BSTR *pbstrSubject
)
/*++

Routine name : CFaxMessageInner::get_Subject

Routine description:

    Return the Subject field of the Cover Page

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrSubject            [out]    - pointer to the place to put Subject contents

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_Subject"), hr);

    hr = GetBstr(pbstrSubject, m_bstrSubject);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== GET CALLER ID ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_CallerId(
    BSTR *pbstrCallerId
)
/*++

Routine name : CFaxMessageInner::get_CallerId

Routine description:

    Return the Caller Id of Message's Phone Call

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrCallerId           [out]    - pointer to the place to put the Caller Id

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_CallerId"), hr);

    hr = GetBstr(pbstrCallerId, m_bstrCallerId);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== GET ROUTING INFORMATION ======================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_RoutingInformation(
    BSTR *pbstrRoutingInformation
)
/*++

Routine name : CFaxMessageInner::get_RoutingInformation

Routine description:

    Return the Routing Information of the Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrRoutingInformation         [out]    - pointer to place to put Routing Information

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_RoutingInformation"), hr);

    hr = GetBstr(pbstrRoutingInformation, m_bstrRoutingInfo);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//========================= GET TRANSMITTION START TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_TransmissionStart(
    DATE *pdateTransmissionStart
)
/*++

Routine name : CFaxMessageInner::get_TransmissionStart

Routine description:

    Return Time the Message started its Transmission

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrTransmissionStart      [out]    - pointer to place to put Transmission Start

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_TransmissionStart"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateTransmissionStart, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pdateTransmissionStart = m_dtTransmissionStart;
    return hr;
}

//
//========================= GET TRANSMITTION END TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_TransmissionEnd(
    DATE *pdateTransmissionEnd
)
/*++

Routine name : CFaxMessageInner::get_TransmissionEnd

Routine description:

    Return Time the Message ended its Transmission

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrTransmissionEnd        [out]    - pointer to place to put Transmission End

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_TransmissionEnd"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateTransmissionEnd, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pdateTransmissionEnd = m_dtTransmissionEnd;
    return hr;
}

//
//========================= GET ORIGINAL SCHEDULED TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_OriginalScheduledTime(
    DATE *pdateOriginalScheduledTime
)
/*++

Routine name : CFaxMessageInner::get_OriginalScheduledTime

Routine description:

    Return Time the Message was originally scheduled

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrOriginalScheduledTime      [out]    - pointer to place to put Original Scheduled Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxMessageInner::get_OriginalScheduledTime"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateOriginalScheduledTime, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pdateOriginalScheduledTime = m_dtOriginalScheduledTime;
    return hr;
}

//
//========================= GET SUBMISSION TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_SubmissionTime(
    DATE *pdateSubmissionTime
)
/*++

Routine name : CFaxMessageInner::get_SubmissionTime

Routine description:

    Return Time the Message was submitted

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateSubmissionTime     [out]    - pointer to place to put Submission Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_SubmissionTime"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateSubmissionTime, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pdateSubmissionTime = m_dtSubmissionTime;
    return hr;
}

//
//====================== GET SUBMISSION ID ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_SubmissionId(
    BSTR *pbstrSubmissionId
)
/*++

Routine name : CFaxMessageInner::get_SubmissionId

Routine description:

    Return Submission ID of the Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrSubmissionId             [out]    - pointer to the place to put the Submission ID 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_SubmissionId"), hr);

    hr = GetBstr(pbstrSubmissionId, m_bstrSubmissionId);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== DELETE ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::Delete()
/*++

Routine name : CFaxMessageInner::Delete

Routine description:

    Delete the Message from the Archive

Author:

    Iv Garber (IvG),    May, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    HANDLE      hFaxHandle = NULL;

    DBG_ENTER (TEXT("CFaxMessageInner::Delete"), hr);

    //
    //  Get Fax Server Handle
    //
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    if (!FaxRemoveMessage(hFaxHandle, m_dwlMsgId, FolderType))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        CALL_FAIL(GENERAL_ERR, 
            _T("FaxRemoveMessage(hFaxHandle, m_FaxMsg.dwlMessageId, FolderType)"), 
            hr);
        return hr;
    }

    return hr;
}

//
//====================== COPY TIFF ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::CopyTiff(
    /*[in]*/ BSTR bstrTiffPath
)
/*++

Routine name : CFaxMessageInner::CopyTiff

Routine description:

    Copies the Fax Message Tiff Image to a file on the local computer.

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    bstrTiffPath                  [in]    - the file to copy to

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    HANDLE      hFaxHandle = NULL;

    DBG_ENTER (TEXT("CFaxMessageInner::CopyTiff"), hr, _T("%s"), bstrTiffPath);

    //
    //  Get Fax Server Handle
    //
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    if (!FaxGetMessageTiff(hFaxHandle, m_dwlMsgId, FolderType, bstrTiffPath))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        CALL_FAIL(GENERAL_ERR, 
            _T("FaxGetMessageTiff(hFaxHandle, m_FaxMsg.dwlMessageId, FolderType, bstrTiffPath)"), 
            hr);
        return hr;
    }

    return hr;
}

//
//==================== INIT ===================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::Init(
    /*[in]*/ PFAX_MESSAGE pFaxMessage,
    IFaxServerInner* pFaxServerInner
)
/*++

Routine name : CFaxMessageInner::Init

Routine description:

    Initialize the Message Inner Class : put Message Information and Ptr to Server

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pFaxMessage                   [in]    - Message Info
    pFaxServerInner               [in]    - Ptr to Server

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxMessageInner::Init"), hr);

    //
    //  dwlBroadcastId is DWORDLONG, we need to convert it to the BSTR
    //
    TCHAR       tcBuffer[25];
    ::_i64tot(pFaxMessage->dwlBroadcastId, tcBuffer, 16);
    m_bstrSubmissionId = tcBuffer;

    m_bstrTSID = pFaxMessage->lpctstrTsid;
    m_bstrCSID = pFaxMessage->lpctstrCsid;
    m_bstrDeviceName = pFaxMessage->lpctstrDeviceName;
    m_bstrDocName = pFaxMessage->lpctstrDocumentName;
    m_bstrSubject = pFaxMessage->lpctstrSubject;
    m_bstrCallerId = pFaxMessage->lpctstrCallerID;
    m_bstrRoutingInfo = pFaxMessage->lpctstrRoutingInfo;
	m_dwValidityMask = pFaxMessage->dwValidityMask;

    if ( (!m_bstrSubmissionId) ||
         (pFaxMessage->lpctstrTsid && !m_bstrTSID) ||
         (pFaxMessage->lpctstrCsid && !m_bstrCSID) ||
         (pFaxMessage->lpctstrDeviceName && !m_bstrDeviceName) ||
         (pFaxMessage->lpctstrDocumentName && !m_bstrDocName) ||
         (pFaxMessage->lpctstrSubject && !m_bstrSubject) ||
         (pFaxMessage->lpctstrCallerID && !m_bstrCallerId) ||
         (pFaxMessage->lpctstrRoutingInfo && !m_bstrRoutingInfo) )
    {
        //
        //  Not Enough Memory
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    m_lSize = pFaxMessage->dwSize;
    m_lPages = pFaxMessage->dwPageCount;
    m_Priority = FAX_PRIORITY_TYPE_ENUM(pFaxMessage->Priority);
    m_lRetries = pFaxMessage->dwRetries;
    m_dwlMsgId = pFaxMessage->dwlMessageId;

    //
    //  convert time fields to local variant date
    //
	if (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME)
	{
		hr = SystemTime2LocalDate(pFaxMessage->tmTransmissionStartTime, &m_dtTransmissionStart);
        if (FAILED(hr))
        {
            hr = E_FAIL;
            CALL_FAIL(GENERAL_ERR, _T("SystemTime2LocalDate(TransmissionStartTime)"), hr);
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            return hr;
        }
    }
    else
    {
        m_dtTransmissionStart = DATE(0);
    }

	if (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME)
	{
        hr = SystemTime2LocalDate(pFaxMessage->tmTransmissionEndTime, &m_dtTransmissionEnd);
        if (FAILED(hr))
        {
            hr = E_FAIL;
            CALL_FAIL(GENERAL_ERR, _T("SystemTime2LocalDate(TransmissionEndTime)"), hr);
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            return hr;
        }
    }
    else
    {
        m_dtTransmissionStart = DATE(0);
    }


	if (m_dwValidityMask & FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME)
	{
        hr = SystemTime2LocalDate(pFaxMessage->tmOriginalScheduleTime, &m_dtOriginalScheduledTime);
        if (FAILED(hr))
        {
            hr = E_FAIL;
            CALL_FAIL(GENERAL_ERR, _T("SystemTime2LocalDate(OriginalScheduledTime)"), hr);
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            return hr;
        }
    }
    else
    {
        m_dtTransmissionStart = DATE(0);
    }

	if (m_dwValidityMask & FAX_JOB_FIELD_SUBMISSION_TIME)
	{
        hr = SystemTime2LocalDate(pFaxMessage->tmSubmissionTime, &m_dtSubmissionTime);
        if (FAILED(hr))
        {
            hr = E_FAIL;
            CALL_FAIL(GENERAL_ERR, _T("SystemTime2LocalDate(SubmissionTime)"), hr);
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            return hr;
        }
    }
    else
    {
        m_dtTransmissionStart = DATE(0);
    }

    hr = CFaxInitInnerAddRef::Init(pFaxServerInner);
    return hr;
}

//
//====================== GET SENDER ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP
CFaxMessageInner<T, piid, pcid, FolderType>::get_Sender(
    /*[out, retval] */IFaxSender **ppFaxSender
)
/*++

Routine name : CFaxMessageInner::get_Sender

Routine description:

    Return Message Sender Information

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    ppFaxSender             [out]    - Ptr to the Place to put Sender object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxMessageInner::get_Sender"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(ppFaxSender, sizeof(IFaxSender* )))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    if (!m_pSender)
    {
        //
        //  We have been called for the First Time. Bring Sender's data from the Server
        //

        //
        //  Get Fax Server Handle
        //
        HANDLE  hFaxHandle = NULL;
        hr = GetFaxHandle(&hFaxHandle);
        if (FAILED(hr))
        {
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            return hr;
        }

        //
        //  Get Sender Info
        //
        CFaxPtr<FAX_PERSONAL_PROFILE>   pPersonalProfile;
        if (!FaxGetSenderInfo(hFaxHandle, m_dwlMsgId, FolderType, &pPersonalProfile))
        {
            //
            //  Failed to get Sender Info
            //
            hr = Fax_HRESULT_FROM_WIN32(GetLastError());
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            CALL_FAIL(GENERAL_ERR, _T("FaxGetSenderInfo()"), hr);
            return hr;
        }

        //
        //  Check that pPersonalProfile is valid
        //
	    if (!pPersonalProfile || pPersonalProfile->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE))
	    {
		    //
		    //	Failed to Get Personal Profile
		    //
		    hr = E_FAIL;
		    AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		    CALL_FAIL(GENERAL_ERR, _T("Invalid pPersonalProfile"), hr);
		    return hr;
	    }

        //
        //  Create Sender Object
        //
        hr = CComObject<CFaxSender>::CreateInstance(&m_pSender);
        if (FAILED(hr) || !m_pSender)
        {
            hr = E_OUTOFMEMORY;
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxSender>::CreateInstance(&m_pSender)"), hr);
            return hr;
        }

        //
        //  We want Sender object to live
        //
        m_pSender->AddRef();

        //
        //  Fill the Data
        //
        hr = m_pSender->PutSenderProfile(pPersonalProfile);
        if (FAILED(hr))
        {
            //
            //  Failed to fill the Sender's Object with RPC's data
            //
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            CALL_FAIL(GENERAL_ERR, _T("m_pSender->PutSenderProfile(pPersonalProfile)"), hr);
            m_pSender->Release();
            m_pSender = NULL;
            return hr;
        }
    }

    //
    //  Return Sender Object to Caller
    //
    hr = m_pSender->QueryInterface(ppFaxSender);
    if (FAILED(hr))
    {
        //
        //  Failed to query interface
        //
        AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
        CALL_FAIL(MEM_ERR, _T("CComObject<CFaxSender>::QueryInterface()"), hr);
        return hr;
    }

    return hr;
}
    
//
//====================== GET RECIPIENT ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP
CFaxMessageInner<T, piid, pcid, FolderType>::get_Recipient(
    /*[out, retval] */IFaxRecipient **ppRecipient
)
/*++

Routine name : CFaxMessageInner::get_Recipient

Routine description:

    Return Message Recipient object

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    ppFaxRecipient          [out]    - Ptr to the Place to put Recipient object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxMessageInner::get_Recipient"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(ppRecipient, sizeof(IFaxRecipient* )))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    if (!m_pRecipient)
    {
        //
        //  We have been called for the first time
        //

        //
        //  Get Fax Server Handle
        //
        HANDLE  hFaxHandle = NULL;
        hr = GetFaxHandle(&hFaxHandle);
        if (FAILED(hr))
        {
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            return hr;
        }

        //
        //  Get Recipient Info
        //
        CFaxPtr<FAX_PERSONAL_PROFILE>   pPersonalProfile;
        if (!FaxGetRecipientInfo(hFaxHandle, m_dwlMsgId, FolderType, &pPersonalProfile))
        {
            //
            //  Failed to get Recipient Info
            //
            hr = Fax_HRESULT_FROM_WIN32(GetLastError());
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            CALL_FAIL(GENERAL_ERR, _T("FaxGetRecipientInfo()"), hr);
            return hr;
        }

        //
        //  Check that pPersonalProfile is valid
        //
	    if (!pPersonalProfile || pPersonalProfile->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE))
	    {
		    //
		    //	Failed to Get Personal Profile
		    //
		    hr = E_FAIL;
		    AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		    CALL_FAIL(GENERAL_ERR, _T("Invalid pPersonalProfile"), hr);
		    return hr;
	    }

        //
        //  Create Recipient Object
        //
        hr = CComObject<CFaxRecipient>::CreateInstance(&m_pRecipient);
        if (FAILED(hr) || !m_pRecipient)
        {
            hr = E_OUTOFMEMORY;
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxRecipient>::CreateInstance(&m_pRecipient)"), hr);
            return hr;
        }

        //
        //  We want Recipient object to live
        //
        m_pRecipient->AddRef();

        //
        //  Fill the Data
        //
        hr = m_pRecipient->PutRecipientProfile(pPersonalProfile);
        if (FAILED(hr))
        {
            //
            //  Failed to fill the Recipient's Object with RPC's data
            //
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
            CALL_FAIL(GENERAL_ERR, _T("m_pRecipient->PutRecipientProfile(pPersonalProfile)"), hr);
            m_pRecipient->Release();
            m_pRecipient = NULL;
            return hr;
        }
    }

    //
    //  Return Recipient Object to Caller
    //
    hr = m_pRecipient->QueryInterface(ppRecipient);
    if (FAILED(hr))
    {
        //
        //  Failed to Query Interface
        //
        AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
        CALL_FAIL(MEM_ERR, _T("CComObject<CFaxRecipient>::QueryInterface()"), hr);
        return hr;
    }

    return hr;
}

#endif //   __FAXMESSAGEINNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutboundrouting.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRouting.cpp

Abstract:

	Implementation of CFaxOutboundRouting class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutboundRouting.h"
#include "FaxOutboundRoutingRules.h"
#include "FaxOutboundRoutingGroups.h"

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxOutboundRouting::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxOutboundRouting::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutboundRouting
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//================== GET RULES COLLECTION OBJECT ==============================
//
STDMETHODIMP 
CFaxOutboundRouting::GetRules(
    IFaxOutboundRoutingRules **ppRules
)
/*++

Routine name : CFaxOutboundRouting::GetRules

Routine description:

	Return Rules Collection Object

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	ppRules             [out]    - the Rules Collection Object 

Return Value:

    Standard HRESULT code

Notes:

    Rules Collection is not cached at this level. It is created from the scratch
    each time user asks for it.

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxOutboundRouting::GetRules"), hr);

    CObjectHandler<CFaxOutboundRoutingRules, IFaxOutboundRoutingRules>    ObjectCreator;
    hr = ObjectCreator.GetObject(ppRules, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutboundRouting, GetErrorMsgId(hr), IID_IFaxOutboundRouting, hr);
        return hr;
    }
    return hr;
}

//
//================== GET GROUPS COLLECTION OBJECT ==============================
//
STDMETHODIMP 
CFaxOutboundRouting::GetGroups(
    IFaxOutboundRoutingGroups **ppGroups
)
/*++

Routine name : CFaxOutboundRouting::GetGroups

Routine description:

	Return Groups Collection Object

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	ppGroups             [out]    - the Groups Collection Object 

Return Value:

    Standard HRESULT code

Notes:

    Groups Collection is not cached at this level. It is created from the scratch
    each time user asks for it.

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxOutboundRouting::GetGroups"), hr);

    CObjectHandler<CFaxOutboundRoutingGroups, IFaxOutboundRoutingGroups>    ObjectCreator;
    hr = ObjectCreator.GetObject(ppGroups, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutboundRouting, GetErrorMsgId(hr), IID_IFaxOutboundRouting, hr);
        return hr;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxlocalptr.h ===
#ifndef __FAXLOCALPTR_H_
#define __FAXLOCALPTR_H_

#include "FaxCommon.h"
#include "faxutil.h"


//
//================== FAX SMART PTR -- LOCAL VERSION ==================================
//
template <typename T>
class CFaxPtrLocal : public CFaxPtrBase<T>
{
protected:
	virtual void Free()
	{
        DBG_ENTER(_T("CFaxPtrLocal::Free()"), _T("PTR:%ld"), p);
		if (p)
		{
			MemFree(p);
            p = NULL;
		}
	}
public:
	virtual ~CFaxPtrLocal()
	{
        Free();
	}

	T* operator=(T* lp)
	{
        DBG_ENTER(_T("CFaxPtrLocal::operator=()"));
        return CFaxPtrBase<T>::operator=(lp);
	}
};

#endif  //  __FAXLOCALPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxmessageiteratorinner.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxMessageIteratorInner.h

Abstract:

	Implementation of Fax Message Iterator  Inner Class : 
		Base Class for Inbound and Outbound Message Iterators Classes.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/


#ifndef __FAXMESSAGEITERATORINNER_H_
#define __FAXMESSAGEITERATORINNER_H_

#include "FaxCommon.h"


//
//===================== FAX MESSAGE ITERATOR INNER CLASS ===============================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
class CFaxMessageIteratorInner : 
	public IDispatchImpl<T, piid, &LIBID_FAXCOMEXLib>,
	public CFaxInitInnerAddRef
{
public:
    CFaxMessageIteratorInner() : CFaxInitInnerAddRef(_T("FAX MESSAGE ITERATOR INNER")),
        m_dwPrefetchSize(prv_DEFAULT_PREFETCH_SIZE),
        m_hEnum(NULL)
	{};

	virtual ~CFaxMessageIteratorInner() 
	{
        DBG_ENTER(_T("CFaxMessageIteratorInner::Dtor"));
		if (m_hEnum)
		{
			//
			//	Close currently active Enumeration
			//
			FaxEndMessagesEnum(m_hEnum);

		}
	}

	STDMETHOD(get_PrefetchSize)(/*[out, retval]*/ long *plPrefetchSize);
	STDMETHOD(put_PrefetchSize)(/*[in]*/ long lPrefetchSize);
	STDMETHOD(get_AtEOF)(/*[out, retval]*/ VARIANT_BOOL *pbEOF);
	STDMETHOD(MoveFirst)();
	STDMETHOD(MoveNext)();
	STDMETHOD(get_Message)(MsgIfc **ppMessage);

private:
	DWORD			        m_dwPrefetchSize;
	HANDLE			        m_hEnum;
	CFaxPtr<FAX_MESSAGE>	m_pMsgList;
	DWORD			        m_dwTotalMsgNum;
	DWORD			        m_dwCurMsgNum;

private:
	HRESULT RetrieveMessages();
	HRESULT SetEOF();
};

//
//====================== GET PREFETCH SIZE ================================================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
STDMETHODIMP 
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::get_PrefetchSize(
	long *plPrefetchSize
)
/*++

Routine name : CFaxMessageIteratorInner::get_PrefetchSize

Routine description:

	Return current Prefetch Size value

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	plPrefetchSize			[out]    - pointer to the place to put the PrefetchSize value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxMessageInner::get_PrefetchSize"), hr);

    hr = GetLong(plPrefetchSize, m_dwPrefetchSize);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== PUT PREFETCH SIZE ================================================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
STDMETHODIMP 
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::put_PrefetchSize(
	long lPrefetchSize
)
/*++

Routine name : CFaxMessageIteratorInner::put_PrefetchSize

Routine description:

	Set the Prefetch Size 

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	lPrefetchSize			[in]    - the value of the Prefetch Size to set

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxMessageInner::put_PrefetchSize"), hr, _T("%ld"), lPrefetchSize);
	//
	//	Check that lPrefetchSize is valid 
	//
	if (lPrefetchSize < 1)
	{
		//
		//	illegal value
		//
		hr = E_INVALIDARG;
		AtlReportError(*pcid, IDS_ERROR_ZERO_PREFETCHSIZE, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("lPrefetchSize < 1"), hr);
		return hr;
	}
	m_dwPrefetchSize = lPrefetchSize;
	return hr;
}

//
//====================== GET AtEOF ====================================================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
STDMETHODIMP 
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::get_AtEOF(
	VARIANT_BOOL *pbEOF
)
/*++

Routine name : CFaxMessageIteratorInner::get_EOF

Routine description:

	Return EOF value

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pbEOF			[out]    - pointer to the place to put the EOF value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxMessageInner::get_EOF"), hr);

    //
    //  If not yet, start Enumeration
    //
    if (!m_hEnum)
    {
        hr = MoveFirst();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbEOF, ((m_pMsgList) ? VARIANT_FALSE : VARIANT_TRUE));
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }
	return hr;
}

//
//====================== MOVE FIRST ================================================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
STDMETHODIMP 
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::MoveFirst(
)
/*++

Routine name : CFaxMessageIteratorInner::MoveFirst

Routine description:

	Start New Enumeration

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxMessageIteratorInner::MoveFirst"), hr);

	//
	//	Clear current Msg List
	//
	SetEOF();

	if (m_hEnum)
	{
		//
		//	Enumeration already started. Close it before starting new one
		//
		if (!FaxEndMessagesEnum(m_hEnum))
		{
			//
			//	Failed to Stop current Enumeration
			//
			hr = Fax_HRESULT_FROM_WIN32(GetLastError());
			AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
			CALL_FAIL(GENERAL_ERR, _T("FaxEndMessagesEnum(hEnum)"), hr);
			return hr;
		}

		m_hEnum = NULL;
	}

	//
	//	Get Fax Server Handle
	//
	HANDLE	hFaxHandle = NULL;
	hr = GetFaxHandle(&hFaxHandle);
	if (FAILED(hr))
	{
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		return hr;
	}

	//
	//	Start new Enumeration
	//
	if (!FaxStartMessagesEnum(hFaxHandle, FolderType, &m_hEnum))
	{
		//
		//	Failed to Start an Enumeration
		//
		DWORD	dwError = GetLastError();

		if (ERROR_NO_MORE_ITEMS == dwError)
		{
			//
			//	EOF case
			//
			return hr;
		}

   		hr = Fax_HRESULT_FROM_WIN32(dwError);
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("FaxStartMessagesEnum()"), hr);
		return hr;
	}

	//
	//	Bring new Msg List
	//
	hr = RetrieveMessages();
	return hr;
}


//
//====================== RETRIEVE MESSAGES ================================================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
HRESULT
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::RetrieveMessages(
)
/*++

Routine name : CFaxMessageIteratorInner::RetrieveMessages

Routine description:

	Retrieve Message List

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxMessageIteratorInner::RetrieveMessages"), hr);

	//
	//	Retrieve List of Messages
	//
	if (!FaxEnumMessages(m_hEnum, m_dwPrefetchSize, &m_pMsgList, &m_dwTotalMsgNum))
	{
		//
		//	Failed to get Msg List
		//
		DWORD	dwError = GetLastError();

		if (dwError == ERROR_NO_MORE_ITEMS)
		{
			//
			//	EOF Case
			//
			return hr;
		}

		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumMessages()"), hr);
		return hr;
	}

	ATLASSERT(m_pMsgList);

	return hr;
}

//
//====================== MOVE NEXT ================================================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
STDMETHODIMP 
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::MoveNext(
)
/*++

Routine name : FolderType>::MoveNext

Routine description:

	Move the cursor to the next Message in the List.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxMessageInner::MoveNext"), hr);

    //
    //  If not yet, start Enumeration
    //
    if (!m_hEnum)
    {
        hr = MoveFirst();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_dwCurMsgNum++;

	if (m_dwCurMsgNum == m_dwTotalMsgNum)
	{
		//
		//	We've read all the Msg List. Let's bring next one
		//
		SetEOF();
		hr = RetrieveMessages();
	}

	return hr;

}

//
//====================== SET EOF ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
HRESULT
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::SetEOF(
)
/*++

Routine name : FolderType>::SetEOF

Routine description:

	Clear all instance variables dealing with Msg List.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxMessageInner::SetEOF"), hr);

	m_dwCurMsgNum = 0;
	m_dwTotalMsgNum = 0;
    m_pMsgList.Detach();
	return hr;
}

//
//====================== GET MESSAGE ================================================
//
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
STDMETHODIMP
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::get_Message(
    MsgIfc **ppMessage
)
/*++

Routine name : CFaxMessageIteratorInner::GetMessage

Routine description:

	Return Next Message Object from the Archive 

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	ppMessage		[out]    - pointer to the place to put the Message Object

Return Value:

	Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxMessageIteratorInner::GetMessage"), hr);


    //
    //  If not yet, start Enumeration
    //
    if (!m_hEnum)
    {
        hr = MoveFirst();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (!m_pMsgList)
    {
        //
        //  Error, we at EOF
        //
        hr = ERROR_HANDLE_EOF;
		AtlReportError(*pcid, IDS_ERROR_EOF, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumMessages()"), hr);
		return hr;
    }

	//
	//	Create Message Object
	//	
	CComPtr<MsgIfc>		pMsg;
	hr = MsgType::Create(&pMsg);
	if (FAILED(hr))
	{
		//
		//	Failed to create Message object
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("MessageClass::Create(&pMsg)"), hr);
		return hr;
	}

	//
	//	Initialize the Message Object
	//
	hr = ((MsgType *)((MsgIfc *)pMsg))->Init(&m_pMsgList[m_dwCurMsgNum], m_pIFaxServerInner);
	if (FAILED(hr))
	{
		//
		// Failed to Init the Message Object
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("pMsg->Init()"), hr);
		return hr;
	}

	//
	//	Return Message Object to the Caller
	//
	hr = pMsg.CopyTo(ppMessage);
	if (FAILED(hr))
	{
		//
		//	Failed to Copy Interface
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("CComPtr::CopyTo"), hr);
		return hr;
	}
	return hr;
}

#endif //	__FAXMESSAGEITERATORINNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxjobstatus.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxJobStatus.cpp

Abstract:

    Implementation of CFaxJobStatus Class.

Author:

    Iv Garber (IvG) Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxJobStatus.h"

//
//====================== GET JOB TYPE ===============================
//
STDMETHODIMP
CFaxJobStatus::get_JobType(
    FAX_JOB_TYPE_ENUM *pJobType
)
/*++

Routine name : CFaxJobStatus::get_JobType

Routine description:

    Return the Type of the Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pJobType             [out]    - Return Value of Job Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_JobType"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pJobType, sizeof(FAX_JOB_TYPE_ENUM)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        AtlReportError(CLSID_FaxJobStatus, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxJobStatus, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr"), hr);
        return hr;
    }

    *pJobType = m_JobType;
    return hr;
}

//
//====================== GET TRANSMISSION END ======================================
//
STDMETHODIMP
CFaxJobStatus::get_TransmissionEnd(
    DATE *pdateTransmissionEnd
)
/*++

Routine name : CFaxJobStatus::get_TransmissionEnd

Routine description:

    Return Job's Transmission End

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateTransmissionEnd            [out]    - pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_TransmissionEnd"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateTransmissionEnd, sizeof(DATE)))
    {
        //
        //  Got Bad Ptr
        //
        hr = E_POINTER;
        AtlReportError(CLSID_FaxJobStatus, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxJobStatus, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    if (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME)
    {
        //
        // Transmission end time is available
        //
        hr = SystemTime2LocalDate(m_dtTransmissionEnd, pdateTransmissionEnd);
        if (FAILED(hr))
        {
            //
            //  Failed to convert the system time to localized variant date
            //
            AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
            return hr;
        }
    }
    else
    {
        //
        // Transmission end time is not available yet
        //
        hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATA);
        AtlReportError(CLSID_FaxJobStatus, IDS_ERROR_NO_END_TIME, IID_IFaxJobStatus, hr);
    }        
    return hr;
}

//
//========================= GET TRANSMISSION START ===============================
//
STDMETHODIMP
CFaxJobStatus::get_TransmissionStart(
    DATE *pdateTransmissionStart
)
/*++

Routine name : CFaxJobStatus::get_TransmissionStart

Routine description:

    Return Time the Job is started to transmit

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pdateTransmissionStart      [out]    - pointer to place to put the Transmission Start

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_TransmissionStart"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateTransmissionStart, sizeof(DATE)))
    {
        //
        //  Got Bad Ptr
        //
        hr = E_POINTER;
        AtlReportError(CLSID_FaxJobStatus, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxJobStatus, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    hr = SystemTime2LocalDate(m_dtTransmissionStart, pdateTransmissionStart);
    if (FAILED(hr))
    {
        //
        //  Failed to convert the system time to localized variant date
        //
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }

    return hr;
}

//
//========================= GET SCHEDULED TIME ===============================
//
STDMETHODIMP
CFaxJobStatus::get_ScheduledTime(
    DATE *pdateScheduledTime
)
/*++

Routine name : CFaxJobStatus::get_ScheduledTime

Routine description:

    Return Time the Job is scheduled

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pdateScheduledTime      [out]    - pointer to place to put Scheduled Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_ScheduledTime"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateScheduledTime, sizeof(DATE)))
    {
        //
        //  Got Bad Ptr
        //
        hr = E_POINTER;
        AtlReportError(CLSID_FaxJobStatus, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxJobStatus, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    hr = SystemTime2LocalDate(m_dtScheduleTime, pdateScheduledTime);
    if (FAILED(hr))
    {
        //
        //  Failed to convert the system time to localized variant date
        //
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }

    return hr;
}

//
//====================== GET AVAILABLE OPERATIONS ==================================
//
STDMETHODIMP
CFaxJobStatus::get_AvailableOperations(
    FAX_JOB_OPERATIONS_ENUM *pAvailableOperations
)
/*++

Routine name : CFaxJobStatus::get_AvailableOperations

Routine description:

    The operations available for the Fax Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pAvailableOperations                 [out]    - Pointer to the place to put the Bit-Wise Combination
                                                    of Available Operations on the current Fax Job

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_AvailableOperations"), hr);

    //
    //  Check that we have got good Ptr
    //
    if (::IsBadWritePtr(pAvailableOperations, sizeof(FAX_JOB_OPERATIONS_ENUM)))
    {
        hr = E_POINTER;
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pAvailableOperations, sizeof(FAX_JOB_OPERATIONS_ENUM))"), hr);
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }

    *pAvailableOperations = FAX_JOB_OPERATIONS_ENUM(m_dwAvailableOperations);
    return hr;
}

//
//====================== GET PAGES ================================================
//
STDMETHODIMP
CFaxJobStatus::get_Pages(
    long *plPages
)
/*++

Routine name : CFaxJobStatus::get_Pages

Routine description:

    Return total number of pages of the message

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    plPages                 [out]    - Pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_Pages"), hr);

    hr = GetLong(plPages, m_dwPageCount);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }
    return hr;
}

//
//====================== GET CALLER ID ================================================
//
STDMETHODIMP
CFaxJobStatus::get_CallerId(
    BSTR *pbstrCallerId
)
/*++

Routine name : CFaxJobStatus::get_CallerId

Routine description:

    Return the Caller Id of Job's Phone Call

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pbstrCallerId           [out]    - pointer to the place to put the Caller Id

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_CallerId"), hr);

    hr = GetBstr(pbstrCallerId, m_bstrCallerId);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }
    return hr;
}

//
//====================== GET ROUTING INFORMATION ======================================
//
STDMETHODIMP
CFaxJobStatus::get_RoutingInformation(
    BSTR *pbstrRoutingInformation
)
/*++

Routine name : CFaxJobStatus::get_RoutingInformation

Routine description:

    Return the Routing Information of the Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pbstrRoutingInformation         [out]    - pointer to place to put Routing Information

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_RoutingInformation"), hr);

    hr = GetBstr(pbstrRoutingInformation, m_bstrRoutingInfo);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }
    return hr;
}

//
//====================== GET STATUS =============================================
//
HRESULT
CFaxJobStatus::get_Status(
    FAX_JOB_STATUS_ENUM *pStatus
)
/*++

Routine name : CFaxJobStatus::get_Status

Routine description:

    The current Queue Status of the Fax Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pStatus                    [out]    - Pointer to the place to put the Bit-Wise Combination of status

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_Status"), hr);

    //
    //  Check that we have got good Ptr
    //
    if (::IsBadWritePtr(pStatus, sizeof(FAX_JOB_STATUS_ENUM)))
    {
        hr = E_POINTER;
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pStatus, sizeof(FAX_JOB_STATUS_ENUM))"), hr);
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }

    *pStatus = FAX_JOB_STATUS_ENUM(m_dwQueueStatus);
    return hr;
}

//
//====================== GET EXTENDED STATUS CODE ===============================
//
STDMETHODIMP
CFaxJobStatus::get_ExtendedStatusCode(
    FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode
)
/*++

Routine name : CFaxJobStatus::get_ExtendedStatusCode

Routine description:

    The Code of the Extended Status of the Fax Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pExtendedStatusCode             [out]    - Pointer to the place to put the status code

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_ExtendedStatusCode"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pExtendedStatusCode, sizeof(FAX_JOB_EXTENDED_STATUS_ENUM)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        AtlReportError(CLSID_FaxJobStatus, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxJobStatus, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr"), hr);
        return hr;
    }

    *pExtendedStatusCode = m_ExtendedStatusCode;
    return hr;
}

//
//====================== GET RETRIES =============================================
//
STDMETHODIMP
CFaxJobStatus::get_Retries(
    long *plRetries
)
/*++

Routine name : CFaxJobStatus::get_Retries

Routine description:

    The number of unsuccessful retries of the Fax Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    plRetries                    [out]    - Pointer to the place to put the number of Retries

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_Retries"), hr);

    hr = GetLong(plRetries, m_dwRetries);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }
    return hr;
}

//
//====================== GET TSID ================================================
//
STDMETHODIMP
CFaxJobStatus::get_TSID(
    BSTR *pbstrTSID
)
/*++

Routine name : CFaxJobStatus::get_TSID

Routine description:

    Return Transmitting Station ID of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrTSID             [out]    - pointer to the place to put the TSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_TSID"), hr);

    hr = GetBstr(pbstrTSID, m_bstrTSID);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }
    return hr;
}

//
//====================== GET CSID ================================================
//
STDMETHODIMP
CFaxJobStatus::get_CSID(
    BSTR *pbstrCSID
)
/*++

Routine name : CFaxJobStatus::get_CSID

Routine description:

    Return Called Station ID of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrCSID             [out]    - pointer to the place to put the CSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_CSID"), hr);

    hr = GetBstr(pbstrCSID, m_bstrCSID);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }
    return hr;
}

//
//====================== GET EXTENDED STATUS =======================================
//
STDMETHODIMP
CFaxJobStatus::get_ExtendedStatus(
    BSTR *pbstrExtendedStatus
)
/*++

Routine name : CFaxJobStatus::get_ExtendedStatus

Routine description:

    Return String Description of the Extended Status of the Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pbstrExtendedStatus             [out]    - pointer to the place to put the Extended Status

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_ExtendedStatus"), hr);

    hr = GetBstr(pbstrExtendedStatus, m_bstrExtendedStatus);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }
    return hr;
}

//
//====================== GET CURRENT PAGE =============================================
//
STDMETHODIMP
CFaxJobStatus::get_CurrentPage(
    long *plCurrentPage
)
/*++

Routine name : CFaxJobStatus::get_CurrentPage

Routine description:

    Current Page number being received / sent

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plCurrentPage           [out]    - Pointer to the place to put the Current Page Number

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_CurrentPage"), hr);

    hr = GetLong(plCurrentPage, m_dwCurrentPage);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }
    return hr;
}

//
//====================== GET DEVICE ID =============================================
//
STDMETHODIMP
CFaxJobStatus::get_DeviceId(
    long *plDeviceId
)
/*++

Routine name : CFaxJobStatus::get_DeviceId

Routine description:

    The Device Id by which the Job is being sent / received.

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plDeviceId              [out]    - Pointer to the place to put the Device Id

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_DeviceId"), hr);

    hr = GetLong(plDeviceId, m_dwDeviceId);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }
    return hr;
}

//
//====================== GET SIZE ================================================
//
STDMETHODIMP
CFaxJobStatus::get_Size(
    long *plSize
)
/*++

Routine name : CFaxJobStatus::get_Size

Routine description:

    Return Size ( in bytes ) of Fax Job's TIFF File

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    plSize                  [out]    - Pointer to the place to put Size

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_Size"), hr);

    hr = GetLong(plSize, m_dwSize);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr);
        return hr;
    }
    return hr;
}

//
//==================== INIT ===================================================
//
HRESULT
CFaxJobStatus::Init(
    FAX_JOB_STATUS *pJobStatus
)
/*++

Routine name : CFaxJobStatus::Init

Routine description:

    Initialize the Job Status Class with the data from FAX_JOB_STATUS struct

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pJobStatus                  [in]    - Job Info

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::Init"), hr);

    ATLASSERT(pJobStatus);

    //
    //  dwQueueStatus cannot contain JS_DELETING value
    //
    ATLASSERT(0 == (pJobStatus->dwQueueStatus & JS_DELETING));

    //
    //  Set Job Type
    //
    switch(pJobStatus->dwJobType)
    {
    case JT_SEND:
        m_JobType = fjtSEND;
        break;

    case JT_RECEIVE:
        m_JobType = fjtRECEIVE;
        break;

    case JT_ROUTING:
        m_JobType = fjtROUTING;
        break;

    default:
        CALL_FAIL(GENERAL_ERR, 
            _T("CFaxJobStatus::Init() got unknown/unsupported Job Type : %ld"), 
            pJobStatus->dwJobType);

        //
        //  This is assert false
        //
        ATLASSERT(pJobStatus->dwJobType == JT_RECEIVE);

        AtlReportError(CLSID_FaxJobStatus, 
            IDS_ERROR_INVALID_ARGUMENT, 
            IID_IFaxJobStatus, 
            hr);
        hr = E_INVALIDARG;
        return hr;
    }

    m_dwSize = pJobStatus->dwSize;
    m_dwJobId = pJobStatus->dwJobID;
    m_dwRetries = pJobStatus->dwRetries;
    m_dwDeviceId = pJobStatus->dwDeviceID;
    m_dwPageCount = pJobStatus->dwPageCount;
    m_dwCurrentPage = pJobStatus->dwCurrentPage;
    m_dwQueueStatus = pJobStatus->dwQueueStatus;
    m_dwAvailableOperations = pJobStatus->dwAvailableJobOperations;
    m_ExtendedStatusCode = FAX_JOB_EXTENDED_STATUS_ENUM(pJobStatus->dwExtendedStatus);

    m_dtScheduleTime = pJobStatus->tmScheduleTime;
    m_dtTransmissionEnd = pJobStatus->tmTransmissionEndTime;
    m_dtTransmissionStart = pJobStatus->tmTransmissionStartTime;

    m_bstrTSID = pJobStatus->lpctstrTsid;
    m_bstrCSID = pJobStatus->lpctstrCsid;
    m_bstrExtendedStatus = pJobStatus->lpctstrExtendedStatus;
    m_bstrRoutingInfo = pJobStatus->lpctstrRoutingInfo;
    m_bstrCallerId = pJobStatus->lpctstrCallerID;
    m_dwValidityMask = pJobStatus->dwValidityMask;
    if ( ((pJobStatus->lpctstrTsid) && !m_bstrTSID) ||
         ((pJobStatus->lpctstrCsid) && !m_bstrCSID) ||
         ((pJobStatus->lpctstrRoutingInfo) && !m_bstrRoutingInfo) ||
         ((pJobStatus->lpctstrExtendedStatus) && !m_bstrExtendedStatus) ||
         ((pJobStatus->lpctstrCallerID) && !m_bstrCallerId) )
    {
        //
        //  Not enough memory to copy the TSID into CComBSTR
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxJobStatus, IDS_ERROR_OUTOFMEMORY, IID_IFaxJobStatus, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        return hr;
    }

    return hr;
}

//
//======================= SUPPORT ERROR INFO ==================================
//
STDMETHODIMP
CFaxJobStatus::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxJobStatus::InterfaceSupportsErrorInfo

Routine description:

    ATL's implementation of Support Error Info.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    riid                          [in]    - reference to the ifc to check.

Return Value:

    Standard HRESULT code

--*/
{
    static const IID* arr[] =
    {
        &IID_IFaxJobStatus
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutboundrouting.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRouting.h

Abstract:

	Declaration of the CFaxOutboundRouting class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXOUTBOUNDROUTING_H_
#define __FAXOUTBOUNDROUTING_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//=================== FAX OUTBOUND ROUTING =============================================
//  Like in FaxInboundRouting, both ORGroups and ORRules Collections are not cached.
//  Rather they are created each time the OutboundRouting is asked for them.
//  To be sure that the Server Object is up during their lifetime, they do 
//      AddRef() on the Server Ojbect at their Init() function.

class ATL_NO_VTABLE CFaxOutboundRouting : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxOutboundRouting, &IID_IFaxOutboundRouting, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxOutboundRouting() : CFaxInitInner(_T("FAX OUTBOUND ROUTING"))
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTBOUNDROUTING)
DECLARE_NOT_AGGREGATABLE(CFaxOutboundRouting)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutboundRouting)
	COM_INTERFACE_ENTRY(IFaxOutboundRouting)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(GetGroups)(/*[out, retval]*/ IFaxOutboundRoutingGroups **ppGroups);
    STDMETHOD(GetRules)(/*[out, retval]*/ IFaxOutboundRoutingRules **ppRules);
};

#endif //__FAXOUTBOUNDROUTING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutboundroutingrule.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingRule.h

Abstract:

	Declaration of the CFaxOutboundRoutingRule class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXOUTBOUNDROUTINGRULE_H_
#define __FAXOUTBOUNDROUTINGRULE_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//======================== FAX OUTBOUND ROUTING RULE =================================
//  FaxOutboundRoutingRule Object is created by FaxOutboundRoutingRuleS Collection.
//  At Init, the Collection passes the Ptr to the Fax Server Object.
//  Rule Object needs this Ptr to perform Save and Refresh.
//  So, Rule Object makes AddRef() on the Fax Server Object, to prevent its death.
//  To do this, Rule Object inherits from the CFaxInitInnerAddRef class.
//
class ATL_NO_VTABLE CFaxOutboundRoutingRule : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxOutboundRoutingRule, &IID_IFaxOutboundRoutingRule, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxOutboundRoutingRule() : CFaxInitInnerAddRef(_T("FAX OUTBOUND ROUTING RULE"))
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTBOUNDROUTINGRULE)
DECLARE_NOT_AGGREGATABLE(CFaxOutboundRoutingRule)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutboundRoutingRule)
	COM_INTERFACE_ENTRY(IFaxOutboundRoutingRule)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_CountryCode)(/*[out, retval]*/ long *plCountryCode);
    STDMETHOD(get_AreaCode)(/*[out, retval]*/ long *plAreaCode);
    STDMETHOD(get_Status)(/*[out, retval]*/ FAX_RULE_STATUS_ENUM *pStatus);

    STDMETHOD(get_UseDevice)(/*[out, retval]*/ VARIANT_BOOL *pbUseDevice);
    STDMETHOD(put_UseDevice)(/*[in]*/ VARIANT_BOOL bUseDevice);

    STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *plDeviceId);
    STDMETHOD(put_DeviceId)(/*[in]*/ long DeviceId);

    STDMETHOD(get_GroupName)(/*[out, retval]*/ BSTR *pbstrGroupName);
	STDMETHOD(put_GroupName)(/*[in]*/ BSTR bstrGroupName);

	STDMETHOD(Save)();
    STDMETHOD(Refresh)();

//  Internal Use
    STDMETHOD(Init)(FAX_OUTBOUND_ROUTING_RULE *pInfo, IFaxServerInner *pServer);

private:
    DWORD       m_dwAreaCode;
    DWORD       m_dwCountryCode;
    DWORD       m_dwDeviceId;
    BOOL        m_bUseDevice;
    CComBSTR    m_bstrGroupName;

    FAX_RULE_STATUS_ENUM    m_Status;
};

#endif //__FAXOUTBOUNDROUTINGRULE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutboundroutinggroups.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingGroups.cpp

Abstract:

	Implementation of CFaxOutboundRoutingGroups class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutboundRoutingGroups.h"
#include "FaxOutboundRoutingGroup.h"

//
//================= FIND GROUP =======================================================
//
STDMETHODIMP
CFaxOutboundRoutingGroups::FindGroup(
    /*[in]*/ VARIANT vIndex,
    /*[out]*/ ContainerType::iterator &it
)
/*++

Routine name : CFaxOutboundRoutingGroups::FindGroup

Routine description:

	Find Group by given Variant : either Group Name either Group Index in the Collection

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	vIndex                        [in]    - the Key to Find the Group 
    it                            [out]   - the found Group Iterator

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroups::FindGroup"), hr);

    CComVariant     var;
    if (vIndex.vt != VT_BSTR)
    {
        //
        //  vIndex is not BSTR ==> convert to VT_I4
        //
        hr = var.ChangeType(VT_I4, &vIndex);
        if (SUCCEEDED(hr))
        {
            VERBOSE(DBG_MSG, _T("Parameter is Number : %d"), var.lVal);

            //
            //  Check the Range of the Index
            //
            if (var.lVal > m_coll.size() || var.lVal < 1)
            {
		        //
		        //	Invalid Index
		        //
        		hr = E_INVALIDARG;
		        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_OUTOFRANGE, IID_IFaxOutboundRoutingGroups, hr);
        		CALL_FAIL(GENERAL_ERR, _T("lIndex < 1 || lIndex > m_coll.size()"), hr);
		        return hr;
        	}

            //
            //  Find the Group Object to Remove
            //
            it = m_coll.begin() + var.lVal - 1;
            return hr;
		}
    }

    //
    //  We didnot success to convert the var to Number
    //  So, try to convert it to the STRING
    //
    hr = var.ChangeType(VT_BSTR, &vIndex);
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutboundRoutingGroups, hr);
        CALL_FAIL(GENERAL_ERR, _T("var.ChangeType(VT_BSTR, &vIndex)"), hr);
        return hr;
    }

    VERBOSE(DBG_MSG, _T("Parameter is String : %s"), var.bstrVal);

    CComBSTR    bstrName;
    it = m_coll.begin();
    while (it != m_coll.end())
    {
        hr = (*it)->get_Name(&bstrName);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_Name(&bstrName)"), hr);
            AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutboundRoutingGroups, hr);
            return hr;
        }

        if (_tcsicmp(bstrName, var.bstrVal) == 0)
        {
            //
            //  found the desired OR Group
            //
            return hr;
        }
        it++;
    }

	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Group Is Not Found"), hr);
    AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutboundRoutingGroups, hr);
    return hr;
}

//
//===================== ADD GROUP =================================================
//
STDMETHODIMP
CFaxOutboundRoutingGroups::AddGroup(
    /*[in]*/ FAX_OUTBOUND_ROUTING_GROUP *pInfo,
    /*[out]*/ IFaxOutboundRoutingGroup **ppNewGroup
)
/*++

Routine name : CFaxOutboundRoutingGroups::AddGroup

Routine description:

	Create new Group Object and add it to the Collection.
    If ppNewGroup is NOT NULL, return in it ptr to the new Group Object.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

    pInfo                   [in]    -   Ptr to the Group's Data
    ppNewGroup              [out]    -  Ptr to the new Group Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroups::AddGroup"), hr);

    //
    //  Create Group Object
    //
    CComObject<CFaxOutboundRoutingGroup>  *pClass = NULL;
    hr = CComObject<CFaxOutboundRoutingGroup>::CreateInstance(&pClass);
    if (FAILED(hr) || (!pClass))
    {
        if (!pClass)
        {
            hr = E_OUTOFMEMORY;
    		CALL_FAIL(MEM_ERR, _T("CComObject<CFaxOutboundRoutingGroup>::CreateInstance(&pClass)"), hr);
        }
        else
        {
    		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutboundRoutingGroup>::CreateInstance(&pClass)"), hr);
        }

        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr);
		return hr;
    }

    //
    //  Init the Group Object
    //
    hr = pClass->Init(pInfo, m_pIFaxServerInner);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("pClass->Init(pInfo, m_pIFaxServerInner)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr);
        delete pClass;
        return hr;
    }

    //
    //  Get Interface from the pClass.
    //  This will make AddRef() on the Interface. 
    //  This is the Collection's AddRef, which is freed at Collection's Dtor.
    //
    CComPtr<IFaxOutboundRoutingGroup>     pObject = NULL;
    hr = pClass->QueryInterface(&pObject);
    if (FAILED(hr) || (!pObject))
    {
        if (!pObject)
        {
            hr = E_FAIL;
        }
        CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&pObject)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr);
        delete pClass;
        return hr;
    }

	//
	//	Put the Object in the collection
	//
	try 
	{
		m_coll.push_back(pObject);
	}
	catch (exception &)
	{
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingGroups, hr);
		CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pObject)"), hr);

        //
        //  pObject will call Release(), which will delete the pClass
        //
		return hr;
	}

    //
    //  We want to save the current AddRef() to Collection
    //
    pObject.Detach();

    //
    //  Return new Group Object, if required
    //
    if (ppNewGroup)
    {
        if (::IsBadWritePtr(ppNewGroup, sizeof(IFaxOutboundRoutingGroup *)))
        {
		    hr = E_POINTER;
		    CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppNewGroup, sizeof(IFaxOutboundRoutingGroup *))"), hr);
		    return hr;
        }
        else
        {
            *ppNewGroup = m_coll.back();
            (*ppNewGroup)->AddRef();
        }
    }

    return hr;
}

//
//================= ADD =======================================================
//
STDMETHODIMP
CFaxOutboundRoutingGroups::Add(
    /*[in]*/ BSTR bstrName, 
    /*[out, retval]*/ IFaxOutboundRoutingGroup **ppGroup
)
/*++

Routine name : CFaxOutboundRoutingGroups::Add

Routine description:

	Add new Group to the Groups Collection

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	bstrName                      [in]    - Name of the new Group
	ppGroup                       [out]    - the Group Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroups::Add"), hr, _T("Name=%s"), bstrName);

    //
    //  Check if the Name is valid
    //
	if (!bstrName)
	{
		hr = E_INVALIDARG;
	    CALL_FAIL(GENERAL_ERR, _T("Empty Group Name"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutboundRoutingGroups, hr);
        return hr;
    }

    if (_tcsicmp(bstrName, ROUTING_GROUP_ALL_DEVICES) == 0)
    {
        //
        //  Cannot Add the "All Devices" Group
        //
	    hr = E_INVALIDARG;
	    CALL_FAIL(GENERAL_ERR, _T("All Devices Group"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_ALLDEVICESGROUP, IID_IFaxOutboundRoutingGroups, hr);
        return hr;
    }

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutboundRoutingGroups, hr);
		return hr;
	}

    //
    //  Add the Group to the Fax Server
    //
    if (!FaxAddOutboundGroup(faxHandle, bstrName))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxAddOutboundGroup(faxHandle, bstrName)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr);
		return hr;
    }

    //
    //  Add the Group to the Collection
    //
    FAX_OUTBOUND_ROUTING_GROUP  groupData;

    groupData.dwNumDevices = 0;
    groupData.dwSizeOfStruct = sizeof(FAX_OUTBOUND_ROUTING_GROUP);
    groupData.lpctstrGroupName = bstrName;
    groupData.lpdwDevices = NULL;
    groupData.Status = FAX_GROUP_STATUS_EMPTY;

    hr = AddGroup(&groupData, ppGroup);
    return hr;
}

//
//================= REMOVE =======================================================
//
STDMETHODIMP
CFaxOutboundRoutingGroups::Remove(
    /*[in]*/ VARIANT vIndex
)
/*++

Routine name : CFaxOutboundRoutingGroups::Remove

Routine description:

	Remove Group by the given key

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	vIndex                        [in]    - the Key to Find the Group to Remove

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroups::Remove"), hr);

    //
    //  Find the Group
    //
    ContainerType::iterator it;
    hr = FindGroup(vIndex, it);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    //  Take the Name of the Group
    //
    CComBSTR    bstrName;
    hr = (*it)->get_Name(&bstrName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr);
        CALL_FAIL(GENERAL_ERR, _T("(*it)->get_Name(&bstrName)"), hr);
		return hr;
    }

    //
    //  Check that Name is valid
    //
    if (_tcsicmp(bstrName, ROUTING_GROUP_ALL_DEVICES) == 0)
    {
        //
        //  Cannot Remove "All Devices" Group
        //
	    hr = E_INVALIDARG;
	    CALL_FAIL(GENERAL_ERR, _T("All Devices Group"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_ALLDEVICESGROUP, IID_IFaxOutboundRoutingGroups, hr);
        return hr;
    }

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutboundRoutingGroups, hr);
		return hr;
	}

    //
    //  Remove from Fax Server
    //
    if (!FaxRemoveOutboundGroup(faxHandle, bstrName))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxRemoveOutboundGroup(faxHandle, bstrName)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr);
		return hr;
    }

    //
    //  If successed, remove from our collection as well
    //
	try
	{
		m_coll.erase(it);
	}
	catch(exception &)
	{
		//
		//	Failed to remove the Group
		//
		hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr);
		CALL_FAIL(MEM_ERR, _T("m_coll.erase(it)"), hr);
		return hr;
	}

    return hr;
}

//
//==================== GET ITEM ===================================================
//
STDMETHODIMP
CFaxOutboundRoutingGroups::get_Item(
    /*[in]*/ VARIANT vIndex, 
    /*[out, retval]*/ IFaxOutboundRoutingGroup **ppGroup
)
/*++

Routine name : CFaxOutboundRoutingGroups::get_Item

Routine description:

	Return Item from the Collection either by Group Name either by its Index inside the Collection.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	vIndex                        [in]    - Group Name or Item Index
	ppGroup                       [out]    - the resultant Group Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroups::get_Item"), hr);

    //
    //  Check the Ptr we have got
    //
    if (::IsBadWritePtr(ppGroup, sizeof(IFaxOutboundRoutingGroup *)))
    {
        hr = E_POINTER;
        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutboundRoutingGroups, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppGroup, sizeof(IFaxOutboundRoutingGroup *))"), hr);
		return hr;
    }

    //
    //  Find the Group
    //
    ContainerType::iterator it;
    hr = FindGroup(vIndex, it);
    if (FAILED(hr))
    {
        return hr;
    };

    //
    //  Return it to Caller
    //
    (*it)->AddRef();
    *ppGroup = *it;
    return hr;
}

//
//==================== INIT ===================================================
//
STDMETHODIMP
CFaxOutboundRoutingGroups::Init(
    /*[in]*/ IFaxServerInner *pServer
)
/*++

Routine name : CFaxOutboundRoutingGroups::Init

Routine description:

	Initialize the Groups Collection : create all Group Objects.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pServer                       [in]    - Ptr to the Fax Server Object.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroups::Init"), hr);

    //
    //  First, set the Ptr to the Server
    //
    hr = CFaxInitInnerAddRef::Init(pServer);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr);
		return hr;
	}

    //
    //  Call Server to Return all OR Groups
    //
    CFaxPtr<FAX_OUTBOUND_ROUTING_GROUP> pGroups;
    DWORD                               dwNum = 0;
    if (!FaxEnumOutboundGroups(faxHandle, &pGroups, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumOutboundGroups(faxHandle, &pGroups, &dwNum)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr);
		return hr;
    }

    //
    //  Fill the Collection with Objects
    //
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        hr = AddGroup(&pGroups[i]);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    return hr;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxOutboundRoutingGroups::Create (
	/*[out, retval]*/IFaxOutboundRoutingGroups **ppGroups
)
/*++

Routine name : CFaxOutboundRoutingGroups::Create

Routine description:

	Static function to create the Fax Outbound Routing Groups Collection Object

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	ppGroups                [out]  -- the new Fax OR Groups Collection Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (_T("CFaxOutboundRoutingGroups::Create"), hr);

    //
    //  Create Instance of the Collection
    //
	CComObject<CFaxOutboundRoutingGroups>		*pClass;
	hr = CComObject<CFaxOutboundRoutingGroups>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutboundRoutingGroups>::CreateInstance(&pClass)"), hr);
		return hr;
	}

    //
    //  Return the desired Interface Ptr
    //
	hr = pClass->QueryInterface(ppGroups);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(ppGroups)"), hr);
		return hr;
	}

	return hr;
}	//	CFaxOutboundRoutingGroups::Create()

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxOutboundRoutingGroups::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxOutboundRoutingGroups::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of the ISupportErrorInfo Interface.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutboundRoutingGroups
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutboundroutingrule.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingRule.cpp

Abstract:

	Implementation of CFaxOutboundRoutingRule class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutboundRoutingRule.h"
#include "..\..\inc\FaxUIConstants.h"

//
//====================== REFRESH ====================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::Refresh(
)
/*++

Routine name : CFaxOutboundRoutingRule::Refresh

Routine description:

	Bring up-to-dated Contents of the Rule Object from the Fax Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::Refresh"), hr);

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr);
		return hr;
	}

    //
    //  Call Server for the Data
    //
    CFaxPtr<FAX_OUTBOUND_ROUTING_RULE>  pRules;
    DWORD                               dwNum = 0;
    if (!FaxEnumOutboundRules(faxHandle, &pRules, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumOutboundRules(faxHandle, &pRules, &dwNum)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr);
		return hr;
    }

    //
    //  Find Current Rule 
    //
    for ( DWORD i=0 ; i<dwNum ; i++ )
    {
        if ( (pRules[i].dwAreaCode == m_dwAreaCode) &&
             (pRules[i].dwCountryCode == m_dwCountryCode) )
        {
            hr = Init(&pRules[i], NULL);
            return hr;
        }
    }

    //
    //  Rule not found
    //
    hr = Fax_HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	CALL_FAIL(GENERAL_ERR, _T("Such Rule is not found anymore"), hr);
    AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr);
    return hr;
}

//
//====================== SAVE ====================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::Save(
)
/*++

Routine name : CFaxOutboundRoutingRule::Save

Routine description:

	Save the Contents of the Rule Object to the Fax Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::Save"), hr);

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr);
		return hr;
	}

    //
    //  Create Structure with Rule's Data
    //
    FAX_OUTBOUND_ROUTING_RULE   ruleData;

    ruleData.bUseGroup = (!m_bUseDevice);

    if (m_bUseDevice)
    {
        ruleData.Destination.dwDeviceId = m_dwDeviceId;
    }
    else
    {
        ruleData.Destination.lpcstrGroupName = m_bstrGroupName;
    }

    ruleData.dwAreaCode = m_dwAreaCode;
    ruleData.dwCountryCode = m_dwCountryCode;
    ruleData.dwSizeOfStruct = sizeof(FAX_OUTBOUND_ROUTING_RULE);
    ruleData.Status = FAX_ENUM_RULE_STATUS(m_Status);

    //
    //  Call Server
    //
    if (!FaxSetOutboundRule(faxHandle, &ruleData))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxSetOutboundRule(faxHandle, &ruleData)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr);
		return hr;
    }

    return hr;
}

//
//====================== PUT GROUP NAME ====================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::put_GroupName(
    /*[in]*/ BSTR bstrGroupName
)
/*++

Routine name : CFaxOutboundRoutingRule::put_GroupName

Routine description:

	Set new Group Name for the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	bstrGroupName               [in]    - the new value for the Group Name 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::put_GroupName"), hr, _T("New Value=%s"), bstrGroupName);

    m_bstrGroupName = bstrGroupName;
    if (bstrGroupName && !m_bstrGroupName)
    {
		hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator =()"), hr);
		AtlReportError(CLSID_FaxOutboundRoutingRule, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingRule, hr);
        return hr;
    }
    return hr;
}

//
//===================== GET GROUP NAME ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::get_GroupName(
    /*[out, retval]*/ BSTR *pbstrGroupName
)
/*++

Routine name : CFaxOutboundRoutingRule::get_GroupName

Routine description:

	Return the Group Name of the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrGroupName                 [out]    - The Result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::get_GroupName"), hr);

    hr = GetBstr(pbstrGroupName, m_bstrGroupName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr);
        return hr;
    }

    return hr;
}

//
//====================== PUT DEVICE ID ====================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::put_DeviceId(
    /*[in]*/ long lDeviceId
)
/*++

Routine name : CFaxOutboundRoutingRule::put_DeviceId

Routine description:

	Set new Device Id for the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lDeviceId           [in]    - the new value for the Device 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::put_DeviceId"), hr, _T("New Value=%ld"), lDeviceId);

    if ((lDeviceId > FXS_MAX_PORT_NUM) || (lDeviceId < FXS_MIN_PORT_NUM)) 
    {
		//
		//	Out of the Range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxOutboundRoutingRule, IDS_ERROR_OUTOFRANGE, IID_IFaxOutboundRoutingRule, hr);
		CALL_FAIL(GENERAL_ERR, _T("Device ID is out of the Range"), hr);
		return hr;
    }

    m_dwDeviceId = lDeviceId;
    return hr;
}

//
//===================== GET DEVICE ID ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::get_DeviceId(
    /*[out, retval]*/ long *plDeviceId
)
/*++

Routine name : CFaxOutboundRoutingRule::get_DeviceId

Routine description:

	Return the Device Id of the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plDeviceId                 [out]    - The Result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::get_DeviceId"), hr);

    hr = GetLong(plDeviceId, m_dwDeviceId);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr);
        return hr;
    }

    return hr;
}

//
//====================== PUT USE DEVICE ====================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::put_UseDevice(
    /*[in]*/ VARIANT_BOOL bUseDevice
)
/*++

Routine name : CFaxOutboundRoutingRule::put_UseDevice

Routine description:

	Set new Value for Use Device Flag.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	bUseDevice                    [in]    - the new value for the Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::put_UseDevice"), hr, _T("New Value=%d"), bUseDevice);
    m_bUseDevice = VARIANT_BOOL2bool(bUseDevice);
    return hr;
}

//
//===================== GET USE DEVICE ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::get_UseDevice(
    /*[out, retval]*/ VARIANT_BOOL *pbUseDevice
)
/*++

Routine name : CFaxOutboundRoutingRule::get_UseDevice

Routine description:

	Return whether the Rule uses Device.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbUseDevice                 [out]    - The Result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::get_UseDevice"), hr);

    hr = GetVariantBool(pbUseDevice, bool2VARIANT_BOOL(m_bUseDevice));
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr);
        return hr;
    }

    return hr;
}

//
//===================== GET STATUS ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::get_Status(
    /*[out, retval]*/ FAX_RULE_STATUS_ENUM  *pStatus
)
/*++

Routine name : CFaxOutboundRoutingRule::get_Status

Routine description:

	Return Status of the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pStatus                      [out]    - The Result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::get_Status"), hr);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pStatus, sizeof(FAX_RULE_STATUS_ENUM)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pStatus, sizeof(FAX_RULE_STATUS_ENUM))"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr);
		return hr;
	}

	*pStatus = m_Status;
	return hr;
}

//
//===================== GET AREA CODE ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::get_AreaCode(
    /*[out, retval]*/ long *plAreaCode
)
/*++

Routine name : CFaxOutboundRoutingRule::get_AreaCode

Routine description:

	Return Area Code of the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plAreaCode                 [out]    - The Result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::get_AreaCode"), hr);

    hr = GetLong(plAreaCode, m_dwAreaCode);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr);
        return hr;
    }

    return hr;
}

//
//===================== GET COUNTRY CODE ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::get_CountryCode(
    /*[out, retval]*/ long *plCountryCode
)
/*++

Routine name : CFaxOutboundRoutingRule::get_CountryCode

Routine description:

	Return Country Code of the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plCountryCode                 [out]    - The Result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::get_CountryCode"), hr);

    hr = GetLong(plCountryCode, m_dwCountryCode);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr);
        return hr;
    }

    return hr;
}

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxOutboundRoutingRule::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxOutboundRoutingRule::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutboundRoutingRule
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//=================== INIT ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::Init(
    /*[in]*/ FAX_OUTBOUND_ROUTING_RULE *pInfo, 
    /*[in]*/ IFaxServerInner *pServer
)
/*++

Routine name : CFaxOutboundRoutingRule::Init

Routine description:

	Initialize the Rule Object.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pInfo                         [in]    - Ptr to the Rule Info Structure
	pServer                       [in]    - Ptr to the Fax Server Object.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::Init"), hr);

    //
    //  Store data from the Struct internally
    //
    m_dwAreaCode = pInfo->dwAreaCode;
    m_dwCountryCode = pInfo->dwCountryCode;
    m_Status = FAX_RULE_STATUS_ENUM(pInfo->Status);
    m_bUseDevice = (!pInfo->bUseGroup);

    if (m_bUseDevice)
    {
        m_dwDeviceId = pInfo->Destination.dwDeviceId;
        m_bstrGroupName.Empty();
    }
    else
    {
        m_dwDeviceId = 0;
        m_bstrGroupName = pInfo->Destination.lpcstrGroupName;
        if (pInfo->Destination.lpcstrGroupName && !m_bstrGroupName)
        {
		    hr = E_OUTOFMEMORY;
            CALL_FAIL(MEM_ERR, _T("CComBSTR::operator =()"), hr);
		    AtlReportError(CLSID_FaxOutboundRoutingRule, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingRule, hr);
            return hr;
        }
    }

    //
    //  When called from Refresh, no need to update Ptr to Fax Server Object 
    //
    if (pServer)
    {

        //
        //  Store the Ptr to the Fax Server Object and make AddRef() on it
        //
        hr = CFaxInitInnerAddRef::Init(pServer);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutboundroutinggroup.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingGroup.cpp

Abstract:

	Implementation of CFaxOutboundRoutingGroup class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutboundRoutingGroup.h"
#include "FaxDeviceIds.h"

//
//========================= GET DEVICE IDS ========================================
//
STDMETHODIMP
CFaxOutboundRoutingGroup::get_DeviceIds(
    /*[out, retval]*/ IFaxDeviceIds **pFaxDeviceIds
)
/*++

Routine name : CFaxOutboundRoutingGroup::get_DeviceIds

Routine description:

	Returns DeviceIds Collection owned by the Group

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pFaxDeviceIds                 [out]    - the Collection to Return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroup::get_DeviceIds"), hr);

    //
    //  Check that Ptr we have got -- is OK
    //
    if (IsBadWritePtr(pFaxDeviceIds, sizeof(IFaxDeviceIds*)))
    {
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pFaxDeviceIds, sizeof(IFaxDeviceIds *))"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroup, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroup, hr);
		return hr;
	}

    //
    //  Return the m_pDeviceIds Collection Object
    //
    hr = m_pDeviceIds.CopyTo(pFaxDeviceIds);
    if (FAILED(hr))
    {
		hr = E_FAIL;
		CALL_FAIL(GENERAL_ERR, _T("CComPtr.CopyTo(pFaxDeviceIds)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroup, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroup, hr);
		return hr;
    }

    return hr;
}

//
//========================= INIT ========================================
//
STDMETHODIMP
CFaxOutboundRoutingGroup::Init(
    /*[in]*/ FAX_OUTBOUND_ROUTING_GROUP *pInfo, 
    /*[in]*/ IFaxServerInner *pServer
)
/*++

Routine name : CFaxOutboundRoutingGroup::Init

Routine description:

	Initialize the Group Object with given Data.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pInfo                         [in]    - Data of the Group
	pServer                       [in]    - Ptr to the Server

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroup::Init"), hr);

    m_Status = FAX_GROUP_STATUS_ENUM(pInfo->Status);

    m_bstrName = pInfo->lpctstrGroupName;
    if (pInfo->lpctstrGroupName && !m_bstrName)
    {
		//	
		//	not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxOutboundRoutingGroup, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingGroup, hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
		return hr;
    }

    //
    //  Create Device Ids Collection
    //
    CComObject<CFaxDeviceIds>    *pClass = NULL;
    hr = CComObject<CFaxDeviceIds>::CreateInstance(&pClass);
    if (FAILED(hr) || (!pClass))
    {
        if (!pClass)
        {
            hr = E_OUTOFMEMORY;
    		CALL_FAIL(MEM_ERR, _T("CComObject<CFaxDeviceIds>::CreateInstance(&pClass)"), hr);
        }
        else
        {
    		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxDeviceIds>::CreateInstance(&pClass)"), hr);
        }

		AtlReportError(CLSID_FaxOutboundRoutingGroup, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingGroup, hr);
		return hr;
    }

    //
    //  Init the DeviceIds Collection
    //
    hr = pClass->Init(pInfo->lpdwDevices, pInfo->dwNumDevices, m_bstrName, pServer);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("pClass->Init(pInfo->lpdwDevices, pInfo->dwNumDevices, m_bstrName, pServer)"), hr);
		AtlReportError(CLSID_FaxOutboundRoutingGroup, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingGroup, hr);
        delete pClass;
        return hr;
    }

    //
    //  Get Interface from the pClass.
    //  This will make AddRef() on the Interface. 
    //  This is the Collection's AddRef, which is freed at Collection's Dtor.
    //
    hr = pClass->QueryInterface(&m_pDeviceIds);
    if (FAILED(hr) || (!m_pDeviceIds))
    {
        if (!m_pDeviceIds)
        {
            hr = E_FAIL;
        }
        CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&m_pDeviceIds)"), hr);
		AtlReportError(CLSID_FaxOutboundRoutingGroup, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingGroup, hr);
        delete pClass;
        return hr;
    }

    return hr;
}

//
//========================= GET STATUS ========================================
//
STDMETHODIMP
CFaxOutboundRoutingGroup::get_Status(
    /*[out, retval]*/ FAX_GROUP_STATUS_ENUM *pStatus
)
/*++

Routine name : CFaxOutboundRoutingGroup::get_Status

Routine description:

    Return the Status of the Group

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

    pStatus             [out]    -  the return value
    
Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutboundRoutingGroup::get_Status"), hr);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pStatus, sizeof(FAX_GROUP_STATUS_ENUM)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pStatus, sizeof(FAX_GROUP_STATUS_ENUM))"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroup, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroup, hr);
		return hr;
	}

	*pStatus = m_Status;
	return hr;
}

//
//========================= GET NAME ========================================
//
STDMETHODIMP 
CFaxOutboundRoutingGroup::get_Name(
	BSTR *pbstrName
)
/*++

Routine name : CFaxOutboundRoutingGroup::get_Name

Routine description:

	Return Name of the OR Group

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrName                   [out]    - Ptr to put the Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutboundRoutingGroup::get_Name"), hr);
    hr = GetBstr(pbstrName, m_bstrName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxOutboundRoutingGroup, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroup, hr);
        return hr;
    }
    return hr;
}

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxOutboundRoutingGroup::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxOutboundRoutingGroup::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of the ISupportErrorInfo Interface.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutboundRoutingGroup
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutboundroutinggroup.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingGroup.h

Abstract:

	Declaration of the CFaxOutboundRoutingGroup class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXOUTBOUNDROUTINGGROUP_H_
#define __FAXOUTBOUNDROUTINGGROUP_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//================= FAX OUTBOUND ROUTING GROUP ===============================
//  Fax Outbound Routing Group does not need Ptr to the Fax Server.
//  All its Properties are taken at Init.
//
class ATL_NO_VTABLE CFaxOutboundRoutingGroup : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxOutboundRoutingGroup, &IID_IFaxOutboundRoutingGroup, &LIBID_FAXCOMEXLib>
{
public:
    CFaxOutboundRoutingGroup() 
    {
        DBG_ENTER(_T("FAX OUTBOUND ROUTING GROUP -- CREATE"));
	}

    ~CFaxOutboundRoutingGroup()
    {
        DBG_ENTER(_T("FAX OUTBOUND ROUTING GROUP -- DESTROY"));
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTBOUNDROUTINGGROUP)
DECLARE_NOT_AGGREGATABLE(CFaxOutboundRoutingGroup)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutboundRoutingGroup)
	COM_INTERFACE_ENTRY(IFaxOutboundRoutingGroup)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);
    STDMETHOD(get_Status)(/*[out, retval]*/ FAX_GROUP_STATUS_ENUM *pStatus);
    STDMETHOD(get_DeviceIds)(/*[out, retval]*/ IFaxDeviceIds **pFaxDeviceIds);

//  Internal Use
    STDMETHOD(Init)(FAX_OUTBOUND_ROUTING_GROUP *pInfo, IFaxServerInner *pServer);

private:
    CComBSTR                m_bstrName;
    FAX_GROUP_STATUS_ENUM   m_Status;
    CComPtr<IFaxDeviceIds>  m_pDeviceIds;
};

#endif //__FAXOUTBOUNDROUTINGGROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutboundroutinggroups.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingGroups.h

Abstract:

	Declaration of the CFaxOutboundRoutingGroups class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXOUTBOUNDROUTINGGROUPS_H_
#define __FAXOUTBOUNDROUTINGGROUPS_H_

#include "resource.h"       // main symbols
#include <vector>
#include "VCUE_Copy.h"
#include "FaxCommon.h"

namespace GroupsNamespace
{
    //
    //  Group Objects are stored in Vector of STL.
    //
    //  When initialized, they got ALL their data, and Fax Server Ptr.
    //  They do NOT depend on Groups Collection, and NOT on the Fax Server Object. 
    //
    //  The Collection makes ONE AddRef() for each Group Object, to prevent its death. 
    //  When killed, Collection calls Release() on all its Group Objects.
    //
	typedef	std::vector<IFaxOutboundRoutingGroup*>       ContainerType;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT			EnumExposedType;
	typedef	IEnumVARIANT    EnumIfc;

	//  Copy Classes
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<ContainerType::value_type>            CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), EnumExposedType, EnumCopyType, 
        ContainerType >    EnumType;

    typedef ICollectionOnSTLImpl< IFaxOutboundRoutingGroups, ContainerType, 
        ContainerType::value_type, CollectionCopyType, EnumType >    CollectionType;
};

using namespace GroupsNamespace;

//
//==================== FAX OUTBOUND ROUTING GROUPS ===================================
//
//  FaxOutboundRoutingGroups creates a collection of all its Group Objects at Init.
//  It needs Ptr to the Fax Server Object, for Add and Remove operations. 
//  To prevent the death of the Fax Server before its own death, the Collection
//  makes AddRef() on Server. To do this, it inherits from CFaxInitInnerAddRef.
//  
//  When creating Group Objects, the Collection passes Ptr to the Fax Server Object
//  to them, and from this moment, the Objects are not dependent on the Collection.
//  They live their own lifes. Collection makes one AddRef() on them, to prevent their 
//  death before its own death, exactly as in the case with the Fax Server Object.
//
//  The Group Object itself does NOT need Ptr to the Fax Server Object.
//
class ATL_NO_VTABLE CFaxOutboundRoutingGroups : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<GroupsNamespace::CollectionType, &IID_IFaxOutboundRoutingGroups, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxOutboundRoutingGroups() : CFaxInitInnerAddRef(_T("FAX OUTBOUND ROUTING GROUPS"))
	{
	}

    ~CFaxOutboundRoutingGroups()
    {
        CCollectionKiller<GroupsNamespace::ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTBOUNDROUTINGGROUPS)
DECLARE_NOT_AGGREGATABLE(CFaxOutboundRoutingGroups)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutboundRoutingGroups)
	COM_INTERFACE_ENTRY(IFaxOutboundRoutingGroups)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ IFaxOutboundRoutingGroup **ppGroup);
    STDMETHOD(Remove)(/*[in]*/ VARIANT vIndex);
    STDMETHOD(Add)(/*[in]*/ BSTR bstrName, /*[out, retval]*/ IFaxOutboundRoutingGroup **ppGroup);

//  Internal Use
    static HRESULT Create(IFaxOutboundRoutingGroups **ppGroups);
    STDMETHOD(Init)(IFaxServerInner *pServer);

private:
    STDMETHOD(AddGroup)(/*[in]*/ FAX_OUTBOUND_ROUTING_GROUP *pInfo, IFaxOutboundRoutingGroup **ppNewGroup = NULL);
    STDMETHOD(FindGroup)(/*[in]*/ VARIANT vIndex, /*[out]*/ GroupsNamespace::ContainerType::iterator &it);
};

#endif //__FAXOUTBOUNDROUTINGGROUPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutboundroutingrules.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingRules.cpp

Abstract:

	Implementation of CFaxOutboundRoutingRules class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutboundRoutingRules.h"
#include "FaxOutboundRoutingRule.h"

//
//======================= ADD RULE ============================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::AddRule(
    /*[in]*/ FAX_OUTBOUND_ROUTING_RULE *pInfo,
    /*[out]*/ IFaxOutboundRoutingRule **ppNewRule
)
/*++

Routine name : CFaxOutboundRoutingRules::AddRule

Routine description:

	Create new Rule Object and put it into the Collection.
    Returns pointer to this new Rule Object, if ppNewRule is valid ptr.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pInfo               [in]    - Ptr to the Rule's Data
    ppRule              [out]   - Ptr to the Rule's Object in the Collection

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::AddRule"), hr);

    //
    //  Create Rule Object
    //
    CComObject<CFaxOutboundRoutingRule>  *pClass = NULL;
    hr = CComObject<CFaxOutboundRoutingRule>::CreateInstance(&pClass);
    if (FAILED(hr) || (!pClass))
    {
        if (!pClass)
        {
            hr = E_OUTOFMEMORY;
    		CALL_FAIL(MEM_ERR, _T("CComObject<CFaxOutboundRoutingRule>::CreateInstance(&pClass)"), hr);
        }
        else
        {
    		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutboundRoutingRule>::CreateInstance(&pClass)"), hr);
        }

        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		return hr;
    }

    //
    //  Init the Rule Object
    //
    hr = pClass->Init(pInfo, m_pIFaxServerInner);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("pClass->Init(pInfo, m_pIFaxServerInner)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
        delete pClass;
        return hr;
    }

    //
    //  Get Interface from the pClass.
    //  This will make AddRef() on the Interface. 
    //  This is the Collection's AddRef, which is freed at Collection's Dtor.
    //
    CComPtr<IFaxOutboundRoutingRule>     pObject = NULL;
    hr = pClass->QueryInterface(&pObject);
    if (FAILED(hr) || (!pObject))
    {
        if (!pObject)
        {
            hr = E_FAIL;
        }
        CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&pObject)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
        delete pClass;
        return hr;
    }

	//
	//	Put the Object in the collection
	//
	try 
	{
		m_coll.push_back(pObject);
	}
	catch (exception &)
	{
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxOutboundRoutingRules, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingRules, hr);
		CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pObject)"), hr);

        //
        //  pObject will call Release(), which will delete the pClass
        //
		return hr;
	}

    //
    //  We want to save the current AddRef() to Collection
    //
    pObject.Detach();

    //
    //  if required, return ptr to the new Rule Object
    //
    if (ppNewRule)
    {
        if (::IsBadWritePtr(ppNewRule, sizeof(IFaxOutboundRoutingRule *)))
	    {
		    hr = E_POINTER;
		    CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppNewRule, sizeof(IFaxOutboundRoutingRule *))"), hr);
		    return hr;
        }
        else
        {
            *ppNewRule = m_coll.back();
            (*ppNewRule)->AddRef();
        }
    }

    return hr;
}

//
//==================== INIT ===================================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::Init(
    /*[in]*/ IFaxServerInner *pServer
)
/*++

Routine name : CFaxOutboundRoutingRules::Init

Routine description:

	Initialize the Rules Collection

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pServer                       [in]    - Ptr to the Server

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::Init"), hr);

    //
    //  First, set the Ptr to the Server
    //
    hr = CFaxInitInnerAddRef::Init(pServer);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		return hr;
	}

    //
    //  Call Server to Return all OR Rules
    //
    CFaxPtr<FAX_OUTBOUND_ROUTING_RULE>  pRules;
    DWORD                               dwNum = 0;
    if (!FaxEnumOutboundRules(faxHandle, &pRules, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumOutboundRules(faxHandle, &pRules, &dwNum)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		return hr;
    }

    //
    //  Fill the Collection with Objects
    //
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        hr = AddRule(&pRules[i]);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    return hr;
}

//
//==================== ADD ===================================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::Add(
    /*[in]*/ long lCountryCode, 
    /*[in]*/ long lAreaCode, 
    /*[in]*/ VARIANT_BOOL bUseDevice, 
    /*[in]*/ BSTR bstrGroupName,
    /*[in]*/ long lDeviceId, 
    /*[out]*/ IFaxOutboundRoutingRule **ppRule
)
/*++

Routine name : CFaxOutboundRoutingRules::Add

Routine description:

	Add new Rule to the Collection and to the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lCountryCode                  [in]    - Country Code of the new Rule
	lAreaCode                     [in]    - Area Code for the new Rule
	bUseDevice                    [in]    - bUseDevice Flag of the new Rule
	bstrGroupName                 [in]    - Group Name of the new Rule
	lDeviceId                     [in]    - Device Id of the new Rule
	ppRule                        [in]    - the created Rule

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::Add"), hr, _T("Country=%ld Area=%ld bUseDevice=%ld Group=%s DeviceId=%ld"), lCountryCode, lAreaCode, bUseDevice, bstrGroupName, lDeviceId);

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		return hr;
	}

    //
    //  Call Server to Add the Rule
    //
    bool bUseDeviceRule = VARIANT_BOOL2bool(bUseDevice);
    if (!FaxAddOutboundRule(faxHandle, lAreaCode, lCountryCode, lDeviceId, bstrGroupName, (!bUseDeviceRule)))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxAddOutboundRule(faxHandle, lAreaCode, lCountryCode, lDeviceId, bstrGroupName, (!bUseDeviceRule))"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		return hr;
    }

    //
    //  Take from the Server updated list of Rules -- because of unknown Status of new Rule
    //
    CFaxPtr<FAX_OUTBOUND_ROUTING_RULE>  pRules;
    DWORD                               dwNum = 0;
    if (!FaxEnumOutboundRules(faxHandle, &pRules, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumOutboundRules(faxHandle, &pRules, &dwNum)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		return hr;
    }

    //
    //  Find Our Rule
    //
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        if ( (pRules[i].dwAreaCode == lAreaCode) && (pRules[i].dwCountryCode == lCountryCode) )
        {
            //
            //  Add it to the Collection
            //
            hr = AddRule(&pRules[i], ppRule);
            return hr;
        }
    }

    return hr;
}

//
//================= FIND RULE =================================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::FindRule(
    /*[in]*/ long lCountryCode,
    /*[in]*/ long lAreaCode,
    /*[out]*/ ContainerType::iterator *pRule
)
/*++

Routine name : CFaxOutboundRoutingRules::FindRule

Routine description:

	Find Rule in the Collection by its Country and Area Code

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lCountryCode                  [in]    - the Country Code to look for
	lAreaCode                     [in]    - the Area Code to look for
	pRule                         [out]    - the resultant Rule

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::FindRule"), hr, _T("Area=%ld Country=%ld"), lAreaCode, lCountryCode);

    long lRuleAreaCode;
    long lRuleCountryCode;

	ContainerType::iterator	it;
	it = m_coll.begin();
    while ( it != m_coll.end() )
    {
        //
        //  Get Country Code of the Current Rule 
        //
        hr = (*it)->get_CountryCode(&lRuleCountryCode);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_CountryCode(&lCountryCode)"), hr);
            AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		    return hr;
        }

        if (lRuleCountryCode == lCountryCode)
        {
            //
            //  Get Area Code of the Current Rule 
            //
            hr = (*it)->get_AreaCode(&lRuleAreaCode);
            if (FAILED(hr))
            {
		        CALL_FAIL(GENERAL_ERR, _T("(*it)->get_AreaCode(&lAreaCode)"), hr);
                AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		        return hr;
            }

            if (lAreaCode == lRuleAreaCode)
            {
                *pRule = it;
                return hr;
            }
        }

        it++;
    }

    //
    //  Rule Not Found
    //
    hr = E_INVALIDARG;
    CALL_FAIL(GENERAL_ERR, _T("Such Rule is not found"), hr);
    AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
    return hr;
};

//
//==================== ITEM BY COUNTRY AND AREA ========================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::ItemByCountryAndArea(
    /*[in]*/ long lCountryCode, 
    /*[in]*/ long lAreaCode, 
    /*[out, retval]*/ IFaxOutboundRoutingRule **ppRule)
/*++

Routine name : CFaxOutboundRoutingRules::ItemByCountryAndArea

Routine description:

	Return Item by given Country and Area Code

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lCountryCode                  [in]    - the Country Code
	lAreaCode                     [in]    - the Area COde
	ppRule                        [out]    - the Rule to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::ItemByCountryAndArea"), hr, _T("Area=%ld Country=%ld"), lAreaCode, lCountryCode);

    //
    //  Check that we have got a good Ptr
    //
    if (::IsBadWritePtr(ppRule, sizeof(IFaxOutboundRoutingRule *)))
    {
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppRule, sizeof(IFaxOutboundRoutingRule *))"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		return hr;
    }

    //
    //  Find the Item
    //
    ContainerType::iterator ruleIt;
    hr = FindRule(lCountryCode, lAreaCode, &ruleIt);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    //  Return the found Rule
    //
    (*ruleIt)->AddRef();
    *ppRule = (*ruleIt);
    return hr;
}

//
//==================== REMOVE BY COUNTRY AND AREA ========================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::RemoveByCountryAndArea(
	/*[in]*/ long lCountryCode,
    /*[in]*/ long lAreaCode
)
/*++

Routine name : CFaxOutboundRoutingRules::RemoveByCountryAndArea

Routine description:

	Remove Rule from the Collection and at Server as well.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

        lAreaCode       [in]    -   Area Code of the Rule to Remove
        lCountryCode    [in]    -   Country Code of the Rule to Remove

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::RemoveByCountryAndArea"), hr, _T("Area=%ld Country=%ld"), lAreaCode, lCountryCode);

    //
    //  Check that this is not a Default Rule
    //
    if (lAreaCode == frrcANY_CODE && lCountryCode == frrcANY_CODE)
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("Remove the Default Rule"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, IDS_ERROR_REMOVEDEFAULTRULE, IID_IFaxOutboundRoutingRules, hr);
        return hr;
    }

    //
    //  Find the Rule
    //
	ContainerType::iterator	ruleIt;
    hr = FindRule(lCountryCode, lAreaCode, &ruleIt);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    //  Remove the found Rule
    //
    hr = RemoveRule(lAreaCode, lCountryCode, ruleIt);
    return hr;
}

//
//==================== REMOVE RULE ========================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::RemoveRule (
	/*[in]*/ long lAreaCode,
    /*[in]*/ long lCountryCode,
    /*[in]*/ ContainerType::iterator &it
)
/*++

Routine name : CFaxOutboundRoutingRules::RemoveRule

Routine description:

	Remove Rule from the Collection and from the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

        lAreaCode       [in]    -   Area Code of the Rule to Remove
        lCountryCode    [in]    -   Country Code of the Rule to Remove
        it              [in]    -   Reference to the Iterator poiting to the Rule in the Collection

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::RemoveRule"), hr, _T("Area=%ld Country=%ld"), lAreaCode, lCountryCode);

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		return hr;
	}

    //
    //  Call Server to Remove the Rule
    //
    if (!FaxRemoveOutboundRule(faxHandle, lAreaCode, lCountryCode))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxRemoveOutboundRule(faxHandle, lAreaCode, lCountryCode)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		return hr;
    }

    //
    //  Remove from our Collection as well
    //
	try
	{
		m_coll.erase(it);
	}
	catch(exception &)
	{
		//
		//	Failed to remove the Rule
		//
		hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		CALL_FAIL(MEM_ERR, _T("m_coll.erase(it)"), hr);
		return hr;
	}

    return hr;
}

//
//==================== REMOVE ========================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::Remove (
	/*[in]*/ long lIndex
)
/*++

Routine name : CFaxOutboundRoutingRules::Remove

Routine description:

	Remove Rule from the Collection and at Server as well.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lIndex                        [in]    - Index of the Rule to Remove.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::Remove"), hr, _T("Index=%ld"), lIndex);

	if (lIndex < 1 || lIndex > m_coll.size()) 
	{
		//
		//	Invalid Index
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxOutboundRoutingRules, IDS_ERROR_OUTOFRANGE, IID_IFaxOutboundRoutingRules, hr);
		CALL_FAIL(GENERAL_ERR, _T("lIndex < 1 || lIndex > m_coll.size()"), hr);
		return hr;
	}

	ContainerType::iterator	it;
	it = m_coll.begin() + lIndex - 1;

    //
    //  Get Area Code of the Rule to Remove
    //
    long lAreaCode;
    hr = (*it)->get_AreaCode(&lAreaCode);
    if (FAILED(hr))
    {
		CALL_FAIL(GENERAL_ERR, _T("(*it)->get_AreaCode(&lAreaCode)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		return hr;
    }

    //
    //  Get Country Code of the Rule to Remove
    //
    long lCountryCode;
    hr = (*it)->get_CountryCode(&lCountryCode);
    if (FAILED(hr))
    {
		CALL_FAIL(GENERAL_ERR, _T("(*it)->get_CountryCode(&lCountryCode)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr);
		return hr;
    }

    //
    //  Check that this is not a Default Rule
    //
    if (lAreaCode == frrcANY_CODE && lCountryCode == frrcANY_CODE)
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("Remove the Default Rule"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, IDS_ERROR_REMOVEDEFAULTRULE, IID_IFaxOutboundRoutingRules, hr);
        return hr;
    }

    //
    //  Remove the Rule from the Server and from our Collection
    //
    hr = RemoveRule(lAreaCode, lCountryCode, it);
    return hr;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxOutboundRoutingRules::Create (
	/*[out, retval]*/IFaxOutboundRoutingRules **ppRules
)
/*++

Routine name : CFaxOutboundRoutingRules::Create

Routine description:

	Static function to create the Fax Outbound Routing Rules Collection Object

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	ppRules                     [out]  -- the new Fax OR Rules Collection Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (_T("CFaxOutboundRoutingRules::Create"), hr);

    //
    //  Create Instance of the Collection
    //
	CComObject<CFaxOutboundRoutingRules>		*pClass;
	hr = CComObject<CFaxOutboundRoutingRules>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutboundRoutingRules>::CreateInstance(&pClass)"), hr);
		return hr;
	}

    //
    //  Return the desired Interface Ptr
    //
	hr = pClass->QueryInterface(ppRules);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(ppRules)"), hr);
		return hr;
	}

	return hr;
}	//	CFaxOutboundRoutingRules::Create()

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxOutboundRoutingRules::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxOutboundRoutingRules::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutboundRoutingRules
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutboundroutingrules.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingRules.h

Abstract:

	Declaration of the CFaxOutboundRoutingRules class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXOUTBOUNDROUTINGRULES_H_
#define __FAXOUTBOUNDROUTINGRULES_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include <vector>
#include "VCUE_Copy.h"

namespace RulesNamespace
{

    //
    //  Rule Objects are stored in Vector of STL.
    //
    //  When initialized, they got ALL their data, and Fax Server Ptr.
    //  They do not depend on Rules Collection, only on Fax Server.
    //  They inherit from CFaxInitInnerAddRef class, which means they make AddRef() 
    //  on Fax Server ( at Init() ).
    //
    //  The Collection makes ONE AddRef() for each Rule Object, to prevent its death. 
    //  When killed, Collection calls Release() on all its Rule Objects.
    //
    //  At Rule Object's death, it calls Release() on the Fax Server Object.
    //
	typedef	std::vector<IFaxOutboundRoutingRule*>       ContainerType;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT			EnumExposedType;
	typedef	IEnumVARIANT    EnumIfc;

	//  Copy Classes
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<ContainerType::value_type>            CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), EnumExposedType, EnumCopyType, 
        ContainerType >    EnumType;

    typedef ICollectionOnSTLImpl< IFaxOutboundRoutingRules, ContainerType, 
        ContainerType::value_type, CollectionCopyType, EnumType >    CollectionType;
};

using namespace RulesNamespace;

//
//==================== FAX OUTBOUND ROUTING RULES ===================================
//
//  FaxOutboundRoutingRules creates a collection of all its Rule Objects at Init.
//  It needs Ptr to the Fax Server Object, for Add and Remove operations. 
//  To prevent the death of the Fax Server before its own death, the Collection
//  makes AddRef() on Server. To do this, it inherits from CFaxInitInnerAddRef.
//  
//  When creating Rule Objects, the Collection passes Ptr to the Fax Server Object
//  to them, and from this moment, the Objects are not dependent on the Collection.
//  They live their own lifes. Collection makes one AddRef() on them, to prevent their 
//  death before its own death, exactly as in the case with the Fax Server Object.
//
//  The Rule Object itself needs Ptr to the Fax Server Object, to perform its 
//  Save and Refresh. So, Rule Object also makes AddRef() on the Fax Server Object,
//  to prevent its permature death.
//
class ATL_NO_VTABLE CFaxOutboundRoutingRules : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<RulesNamespace::CollectionType, &IID_IFaxOutboundRoutingRules, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxOutboundRoutingRules() : CFaxInitInnerAddRef(_T("FAX OUTBOUND ROUTING RULES"))
	{
	}

    ~CFaxOutboundRoutingRules()
    {
        CCollectionKiller<RulesNamespace::ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }


DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTBOUNDROUTINGRULES)
DECLARE_NOT_AGGREGATABLE(CFaxOutboundRoutingRules)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutboundRoutingRules)
	COM_INTERFACE_ENTRY(IFaxOutboundRoutingRules)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(Remove)(/*[in]*/ long lIndex);
    STDMETHOD(RemoveByCountryAndArea)(/*[in]*/ long lCountryCode, /*[in]*/ long lAreaCode);

    STDMETHOD(ItemByCountryAndArea)(/*[in]*/ long lCountryCode, /*[in]*/ long lAreaCode, 
        /*[out, retval]*/ IFaxOutboundRoutingRule **ppRule);

    STDMETHOD(Add)(long lCountryCode, long lAreaCode, VARIANT_BOOL bUseDevice, BSTR bstrGroupName,
        long lDeviceId, IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);

//  Internal Use
    static HRESULT Create(IFaxOutboundRoutingRules **ppRules);
    STDMETHOD(Init)(IFaxServerInner *pServer);

private:
    STDMETHOD(RemoveRule)(long lAreaCode, long lCountryCode, RulesNamespace::ContainerType::iterator &it);
    STDMETHOD(FindRule)(long lCountryCode, long lAreaCode, RulesNamespace::ContainerType::iterator *pRule);
    STDMETHOD(AddRule)(FAX_OUTBOUND_ROUTING_RULE *pInfo, IFaxOutboundRoutingRule **ppNewRule = NULL);
};

#endif //__FAXOUTBOUNDROUTINGRULES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutgoingarchive.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingArchive.cpp

Abstract:

	Implementation of CFaxOutgoingArchive

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutgoingArchive.h"

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxOutgoingArchive::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxOutgoingArchive::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Interface Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Reference of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutgoingArchive
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutgoingarchive.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	faxoutgoingarchive.h

Abstract:

	Declaration of the CFaxOutgoingArchive Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXOUTGOINGARCHIVE_H_
#define __FAXOUTGOINGARCHIVE_H_

#include "resource.h"       // main symbols
#include "FaxArchiveInner.h"
#include "FaxOutgoingMessageIterator.h"


//
//================= FAX OUTGOING ARCHIVE ==================================================
//
class ATL_NO_VTABLE CFaxOutgoingArchive : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxArchiveInner<IFaxOutgoingArchive, &IID_IFaxOutgoingArchive, &CLSID_FaxOutgoingArchive, 
		FAX_MESSAGE_FOLDER_SENTITEMS, IFaxOutgoingMessage, CFaxOutgoingMessage,
		IFaxOutgoingMessageIterator, CFaxOutgoingMessageIterator>
{
public:
	CFaxOutgoingArchive()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTGOINGARCHIVE)
DECLARE_NOT_AGGREGATABLE(CFaxOutgoingArchive)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutgoingArchive)
	COM_INTERFACE_ENTRY(IFaxOutgoingArchive)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//	Interfaces
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

#endif //__FAXOUTGOINGARCHIVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutgoingjob.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingJob.cpp

Abstract:

	Implementation of Fax Outgoing Job Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutgoingJob.h"

//
//==================== INTERFACE SUPPORT ERROR INFO ==========================
//
STDMETHODIMP CFaxOutgoingJob::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutgoingJob
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxOutgoingJob::Create (
	IFaxOutgoingJob **ppOutgoingJob
)
/*++

Routine name : CFaxOutgoingJob::Create

Routine description:

	Static function to create the Fax Inbound Message Instance

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	ppOutgoingJob             [out]  -- the new Fax Inbound Message Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxOutgoingJob>		*pClass;
	HRESULT								hr = S_OK;

	DBG_ENTER (TEXT("CFaxOutgoingJob::Create"), hr);

	hr = CComObject<CFaxOutgoingJob>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutgoingJob>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxOutgoingJob), (void **) ppOutgoingJob);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Inbound Message Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}	//	CFaxOutgoingJob::Create()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutgoingjobs.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingJobs.cpp

Abstract:

	Implementation of Fax Outgoing Jobs Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/


#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutgoingJobs.h"

//
//==================== CREATE ========================================
//
HRESULT 
CFaxOutgoingJobs::Create (
	IFaxOutgoingJobs **ppOutgoingJobs
)
/*++

Routine name : CFaxOutgoingJobs::Create

Routine description:

	Static function to create the Fax OutgoingJobs Object

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppOutgoingJobs		[out]  -- the new Fax OutgoingJobs Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT	        					hr = S_OK;

	DBG_ENTER (TEXT("CFaxOutgoingJobs::Create"), hr);

	CComObject<CFaxOutgoingJobs>		*pClass;
	hr = CComObject<CFaxOutgoingJobs>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutgoingJobs>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxOutgoingJobs), (void **) ppOutgoingJobs);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax OutgoingJobs Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}	//	CFaxIncomingJobs::Create()

//
//=================== SUPPORT ERROR INFO ===========================================
//
STDMETHODIMP CFaxOutgoingJobs::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutgoingJobs
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutgoingjob.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingJob.h

Abstract:

	Definition of Fax Outgoing Job Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/


#ifndef __FAXOUTGOINGJOB_H_
#define __FAXOUTGOINGJOB_H_

#include "resource.h"       // main symbols
#include "FaxJobInner.h"


//
//========================= FAX OUTGOING JOB ============================================
//
class ATL_NO_VTABLE CFaxOutgoingJob : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxJobInner<IFaxOutgoingJob, &IID_IFaxOutgoingJob, &CLSID_FaxOutgoingJob>
{
public:
	CFaxOutgoingJob()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTGOINGJOB)
DECLARE_NOT_AGGREGATABLE(CFaxOutgoingJob)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutgoingJob)
	COM_INTERFACE_ENTRY(IFaxOutgoingJob)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//	Internal Use
    static HRESULT Create(IFaxOutgoingJob **ppOutgoingJob);
};

#endif //__FAXOUTGOINGJOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutgoingjobs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingJobs.h

Abstract:

	Declaration of Fax Outgoing Jobs Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXOUTGOINGJOBS_H_
#define __FAXOUTGOINGJOBS_H_

#include "resource.h"       // main symbols
#include <vector>
#include "FaxOutgoingJob.h"
#include "FaxJobsCollection.h"


namespace OutgoingJobsNamespace
{

	// Jobs stored in array, pointers to them - in vector
	typedef	std::vector<IFaxOutgoingJob*>	ContainerType;

	// The collection interface exposes the data as Job objects
	typedef	IFaxOutgoingJob	    CollectionExposedType;
	typedef IFaxOutgoingJobs	CollectionIfc;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT				EnumExposedType;
	typedef	IEnumVARIANT		EnumIfc;

	// Typedef the copy classes using existing typedefs
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<IFaxOutgoingJob*>    CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), 
		EnumExposedType, EnumCopyType, ContainerType >    EnumType;

    typedef JobCollection< CollectionIfc, ContainerType, CollectionExposedType, CollectionCopyType, 
        EnumType, CFaxOutgoingJob, &IID_IFaxOutgoingJobs, &CLSID_FaxOutgoingJobs >    CollectionType;
};

using namespace OutgoingJobsNamespace;


//
//=================== FAX OUTGOING JOBS =========================================
//
class ATL_NO_VTABLE CFaxOutgoingJobs : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<OutgoingJobsNamespace::CollectionType, &IID_IFaxOutgoingJobs, &LIBID_FAXCOMEXLib>
{
public:
	CFaxOutgoingJobs()
	{
        DBG_ENTER(_T("FAX OUTGOING JOBS::CREATE"));
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTGOINGJOBS)
DECLARE_NOT_AGGREGATABLE(CFaxOutgoingJobs)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutgoingJobs)
	COM_INTERFACE_ENTRY(IFaxOutgoingJobs)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//  Internal Use
	static HRESULT Create(IFaxOutgoingJobs **ppOutgoingJobs);
};

#endif //__FAXOUTGOINGJOBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutgoingmessage.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingMessage.h

Abstract:

	Declaration of Fax Outgoing Message Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/


#ifndef __FAXOUTGOINGMESSAGE_H_
#define __FAXOUTGOINGMESSAGE_H_

#include "resource.h"       // main symbols
#include "FaxMessageInner.h"

//
//===================== FAX OUTGOING MESSAGE ======================================
//
class ATL_NO_VTABLE CFaxOutgoingMessage : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxMessageInner<IFaxOutgoingMessage, &IID_IFaxOutgoingMessage, 
		&CLSID_FaxOutgoingMessage, FAX_MESSAGE_FOLDER_SENTITEMS>
{
public:
	CFaxOutgoingMessage()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTGOINGMESSAGE)
DECLARE_NOT_AGGREGATABLE(CFaxOutgoingMessage)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutgoingMessage)
	COM_INTERFACE_ENTRY(IFaxOutgoingMessage)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//	Interfaces
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//	Internal Use
static HRESULT Create(IFaxOutgoingMessage **ppOutgoingMessage);

};

#endif //__FAXOUTGOINGMESSAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutgoingmessageiterator.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingMessageIterator.h

Abstract:

	Declaration of Fax Outgoing Message Iterator Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXOUTGOINGMESSAGEITERATOR_H_
#define __FAXOUTGOINGMESSAGEITERATOR_H_

#include "resource.h"       // main symbols
#include "FaxMessageIteratorInner.h"
#include "FaxOutgoingMessage.h"


//
//=============== FAX OUTGOING MESSAGE ITERATOR ===========================================
//
class ATL_NO_VTABLE CFaxOutgoingMessageIterator : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxMessageIteratorInner<IFaxOutgoingMessageIterator,
		&IID_IFaxOutgoingMessageIterator, &CLSID_FaxOutgoingMessageIterator, 
		FAX_MESSAGE_FOLDER_SENTITEMS, 
		IFaxOutgoingMessage, CFaxOutgoingMessage>
{
public:
	CFaxOutgoingMessageIterator()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTGOINGMESSAGEITERATOR)
DECLARE_NOT_AGGREGATABLE(CFaxOutgoingMessageIterator)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutgoingMessageIterator)
	COM_INTERFACE_ENTRY(IFaxOutgoingMessageIterator)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//	Interfaces
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//	Internal Use
static HRESULT Create(IFaxOutgoingMessageIterator **pOutgoingMsgIterator);
};

#endif //__FAXOUTGOINGMESSAGEITERATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutgoingqueue.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	faxoutgoingqueue.h

Abstract:

	Declaration of the CFaxOutgoingQueue Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXOUTGOINGQUEUE_H_
#define __FAXOUTGOINGQUEUE_H_

#include "resource.h"       // main symbols
#include "FaxQueueInner.h"
#include "FaxOutgoingJob.h"
#include "FaxOutgoingJobs.h"

//
//================= FAX OUTGOING QUEUE =============================================
//
class ATL_NO_VTABLE CFaxOutgoingQueue : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxQueueInner<IFaxOutgoingQueue, &IID_IFaxOutgoingQueue, &CLSID_FaxOutgoingQueue, false,
		IFaxOutgoingJob, CFaxOutgoingJob, IFaxOutgoingJobs, CFaxOutgoingJobs>
{
public:
	CFaxOutgoingQueue() 
	{
        m_bInited = false;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTGOINGQUEUE)
DECLARE_NOT_AGGREGATABLE(CFaxOutgoingQueue)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutgoingQueue)
	COM_INTERFACE_ENTRY(IFaxOutgoingQueue)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//	Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	STDMETHOD(Save)();
	STDMETHOD(Refresh)();
	STDMETHOD(put_Retries)(long lRetries);
	STDMETHOD(get_Retries)(long *plRetries);
	STDMETHOD(put_AgeLimit)(long lAgeLimit);
	STDMETHOD(get_AgeLimit)(long *plAgeLimit);
	STDMETHOD(put_RetryDelay)(long lRetryDelay);
	STDMETHOD(get_RetryDelay)(long *plRetryDelay);
	STDMETHOD(put_Branding)(VARIANT_BOOL bBranding);
	STDMETHOD(get_Branding)(VARIANT_BOOL *pbBranding);
	STDMETHOD(put_DiscountRateEnd)(DATE dateDiscountRateEnd);
	STDMETHOD(put_UseDeviceTSID)(VARIANT_BOOL bUseDeviceTSID);
	STDMETHOD(get_DiscountRateEnd)(DATE *pdateDiscountRateEnd);
	STDMETHOD(get_UseDeviceTSID)(VARIANT_BOOL *pbUseDeviceTSID);
	STDMETHOD(put_DiscountRateStart)(DATE dateDiscountRateStart);
	STDMETHOD(get_DiscountRateStart)(DATE *pdateDiscountRateStart);
	STDMETHOD(put_AllowPersonalCoverPages)(VARIANT_BOOL bAllowPersonalCoverPages);
	STDMETHOD(get_AllowPersonalCoverPages)(VARIANT_BOOL *pbAllowPersonalCoverPages);

//	Internal Use
    STDMETHOD(GetDate)(FAX_TIME faxTime, DATE *pDate);
    STDMETHOD(SetDate)(DATE date, FAX_TIME *pfaxTime);

private:
    bool                        m_bInited;
    CFaxPtr<FAX_OUTBOX_CONFIG>  m_pConfig;
};

#endif //__FAXOUTGOINGQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxpersonalprofile.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxPersonalProfile.cpp

Abstract:

	Implementation of Fax Personal Profile 

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxPersonalProfile.h"
#include "..\..\inc\FaxUIConstants.h"

//
//===================== GET PROFILE DATA =====================================
//
STDMETHODIMP
CFaxPersonalProfile::GetProfileData(
	FAX_PERSONAL_PROFILE *pProfileData
)
/*++

Routine name : CFaxPersonalProfile::GetProfileData

Routine description:

	Fills the pProfileData with the data of the object.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pProfileData                  [out]    - the FAX_PERSONAL_PROFILE struct to fill

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::GetProfileData"), hr);

	if (::IsBadWritePtr(pProfileData, sizeof(FAX_PERSONAL_PROFILE)))
	{
		//
		//	Bad Return OR Interface Pointer
		//
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

	pProfileData->dwSizeOfStruct	= sizeof(FAX_PERSONAL_PROFILE);
	pProfileData->lptstrCity		= m_bstrCity;
	pProfileData->lptstrCompany		= m_bstrCompany;
	pProfileData->lptstrCountry		= m_bstrCountry;
	pProfileData->lptstrEmail		= m_bstrEmail;
	pProfileData->lptstrName		= m_bstrName;
	pProfileData->lptstrState		= m_bstrState;
	pProfileData->lptstrTitle		= m_bstrTitle;
	pProfileData->lptstrTSID		= m_bstrTSID;
	pProfileData->lptstrZip			= m_bstrZipCode;
	pProfileData->lptstrFaxNumber	= m_bstrFaxNumber;
	pProfileData->lptstrHomePhone	= m_bstrHomePhone;
	pProfileData->lptstrDepartment	= m_bstrDepartment;
	pProfileData->lptstrBillingCode = m_bstrBillingCode;
	pProfileData->lptstrOfficePhone	= m_bstrOfficePhone;
	pProfileData->lptstrOfficeLocation	= m_bstrOfficeLocation;
	pProfileData->lptstrStreetAddress	= m_bstrStreetAddress;

	return hr;
}

//
//============== PUT PROFILE DATA ============================================
//
STDMETHODIMP
CFaxPersonalProfile::PutProfileData(
	FAX_PERSONAL_PROFILE *pProfileData
)
/*++

Routine name : CFaxPersonalProfile::PutProfileData

Routine description:

	Receives FAX_PERSONAL_PROFILE structure and fills the Object's fields.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pProfileData                  [in]    - the data to put into the object's variables

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::PutProfileData"), hr);

	m_bstrCity		=	pProfileData->lptstrCity;
	m_bstrCompany	=	pProfileData->lptstrCompany;
	m_bstrCountry	=	pProfileData->lptstrCountry;
	m_bstrEmail		=	pProfileData->lptstrEmail;
	m_bstrHomePhone	=	pProfileData->lptstrHomePhone;
	m_bstrFaxNumber	=	pProfileData->lptstrFaxNumber;
	m_bstrName		=	pProfileData->lptstrName;
	m_bstrState		=	pProfileData->lptstrState;
	m_bstrZipCode	=	pProfileData->lptstrZip;
	m_bstrTitle		=	pProfileData->lptstrTitle;
	m_bstrTSID		=	pProfileData->lptstrTSID;
	m_bstrBillingCode	=	pProfileData->lptstrBillingCode;
	m_bstrDepartment	=	pProfileData->lptstrDepartment;
	m_bstrStreetAddress	=	pProfileData->lptstrStreetAddress;
	m_bstrOfficePhone	=	pProfileData->lptstrOfficePhone;
	m_bstrOfficeLocation	=	pProfileData->lptstrOfficeLocation;

	if ((pProfileData->lptstrCity && !m_bstrCity) ||
		(pProfileData->lptstrCompany && !m_bstrCompany) ||
		(pProfileData->lptstrCountry && !m_bstrCountry) ||
		(pProfileData->lptstrEmail && !m_bstrEmail) ||
		(pProfileData->lptstrHomePhone && !m_bstrHomePhone) ||
		(pProfileData->lptstrFaxNumber && !m_bstrFaxNumber) ||
		(pProfileData->lptstrName && !m_bstrName) ||
		(pProfileData->lptstrState && !m_bstrState) ||
		(pProfileData->lptstrZip && !m_bstrZipCode) ||
		(pProfileData->lptstrTSID && !m_bstrTSID) ||
		(pProfileData->lptstrBillingCode && !m_bstrBillingCode) ||
		(pProfileData->lptstrDepartment && !m_bstrDepartment) ||
		(pProfileData->lptstrStreetAddress && !m_bstrStreetAddress) ||
		(pProfileData->lptstrOfficePhone && !m_bstrOfficePhone) ||
		(pProfileData->lptstrOfficeLocation && !m_bstrOfficeLocation))
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
	}

	return hr;
}
	
//
//==================== DEFAULT SENDER ===================================
//
STDMETHODIMP 
CFaxPersonalProfile::LoadDefaultSender ( 
)
/*++

Routine name : CFaxPersonalProfile::LoadDefaultSender

Routine description:

	Load Default Sender Information from the local Registry

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	NONE

Return Value:

    Standard HRESULT code

--*/
{
	FAX_PERSONAL_PROFILE	DefaultSenderProfile;
	HRESULT					hr;

	DBG_ENTER (TEXT("CFaxPersonalProfile::LoadDefaultSender"), hr);

	DefaultSenderProfile.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

	hr = FaxGetSenderInformation(&DefaultSenderProfile);
	if (FAILED(hr))
	{
		//
		//	Failed to get Sender Information
		//
		AtlReportError(CLSID_FaxPersonalProfile, 
			GetErrorMsgId(hr), 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(GENERAL_ERR, _T("FaxGetSenderInformation()"), hr);
		return hr;
	}

	hr = PutProfileData(&DefaultSenderProfile);
	if (FAILED(hr))
	{
		//
		//	Not Enough Memory
		//
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		//
		// no return, we still need to free information
		//
	}

	HRESULT hr1 = FaxFreeSenderInformation(&DefaultSenderProfile);
	if (FAILED(hr1))
	{
		hr = hr1;
		CALL_FAIL(GENERAL_ERR, _T("FaxFreeSenderInformation()"), hr);
		return hr;
	}

	return hr;
}

//
//	SaveAs
//
STDMETHODIMP 
CFaxPersonalProfile::SaveDefaultSender (
)
/*++

Routine name : CFaxPersonalProfile::SaveDefaultSender

Routine description:

	Save current Profile as the Default in the Local Registry

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	NONE

Return Value:

    Standard HRESULT code

--*/

{
	FAX_PERSONAL_PROFILE	DefaultSenderProfile;
	HRESULT					hr;

	DBG_ENTER (TEXT("CFaxPersonalProfile::SaveDefaultSender"), hr);
	
	hr = GetProfileData(&DefaultSenderProfile);
	ATLASSERT(SUCCEEDED(hr));

	hr = FaxSetSenderInformation(&DefaultSenderProfile);
	if (FAILED(hr))
	{
		AtlReportError(CLSID_FaxPersonalProfile, 
			GetErrorMsgId(hr), 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(GENERAL_ERR, _T("FaxSetSenderInformation()"), hr);
		return hr;
	}

	return hr;
}

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxPersonalProfile::InterfaceSupportsErrorInfo (
	REFIID riid
)
/*++

Routine name : CFaxPersonalProfile::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Interface ID

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxPersonalProfile
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxPersonalProfile::Create (
	IFaxPersonalProfile **ppPersonalProfile
)
/*++

Routine name : CFaxPersonalProfile::Create

Routine description:

	Static function to create the Fax Personal Profile Instance

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppPersonalProfile             [out]  -- the new Fax Personal Profile Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxPersonalProfile>		*pClass;
	HRESULT								hr = S_OK;

	DBG_ENTER (TEXT("CFaxPersonalProfile::Create"), hr);

	hr = CComObject<CFaxPersonalProfile>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxPersonalProfile>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxPersonalProfile), (void **) ppPersonalProfile);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Personal Profile Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}

//
//==================== BILLING CODE ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_BillingCode(
	BSTR *pbstrBillingCode
)
/*++

Routine name : CFaxPersonalProfile::get_BillingCode

Routine description:

	return Billing Code

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrBillingCode              [out]    - the Billing Code

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_BillingCode"), hr);

    hr = GetBstr(pbstrBillingCode, m_bstrBillingCode);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_BillingCode (
	BSTR bstrBillingCode
)
/*++

Routine name : CFaxPersonalProfile::put_BillingCode

Routine description:

	Set Billing Code

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrBillingCode               [in]    - new Billing Code value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxPersonalProfile::put_BillingCode"), 
		hr, 
		_T("%s"), 
		bstrBillingCode);

	m_bstrBillingCode = bstrBillingCode;
	if (bstrBillingCode && !m_bstrBillingCode)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== CITY ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_City(
	BSTR *pbstrCity
)
/*++

Routine name : CFaxPersonalProfile::get_City

Routine description:

	return City

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrCity              [out]    - the City

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_City"), hr);

    hr = GetBstr(pbstrCity, m_bstrCity);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_City (
	BSTR bstrCity
)
/*++

Routine name : CFaxPersonalProfile::put_City

Routine description:

	Set City

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrCity               [in]    - new City value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_City"), hr, _T("%s"), bstrCity);

	m_bstrCity = bstrCity;
	if (!m_bstrCity && bstrCity)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== COMPANY ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_Company(
	BSTR *pbstrCompany
)
/*++

Routine name : CFaxPersonalProfile::get_Company

Routine description:

	return Company

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrCompany              [out]    - the Company

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_Company"), hr);

    hr = GetBstr(pbstrCompany, m_bstrCompany);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_Company (
	BSTR bstrCompany
)
/*++

Routine name : CFaxPersonalProfile::put_Company

Routine description:

	Set Company

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrCompany               [in]    - new Company value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_Company"), hr, _T("%s"), bstrCompany);

	m_bstrCompany = bstrCompany;
	if (!m_bstrCompany && bstrCompany)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, IDS_ERROR_OUTOFMEMORY, IID_IFaxPersonalProfile, hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== COUNTRY ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_Country(
	BSTR *pbstrCountry
)
/*++

Routine name : CFaxPersonalProfile::get_Country

Routine description:

	return Country

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrCountry	            [out]    - the Country

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_Country"), hr);

    hr = GetBstr(pbstrCountry, m_bstrCountry);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_Country (
	BSTR bstrCountry
)
/*++

Routine name : CFaxPersonalProfile::put_Country

Routine description:

	Set Country

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrCountry               [in]    - new Country value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_Country"), hr, _T("%s"), bstrCountry);

	m_bstrCountry = bstrCountry;
	if (!m_bstrCountry && bstrCountry)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== DEPARTMENT ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_Department(
	BSTR *pbstrDepartment
)
/*++

Routine name : CFaxPersonalProfile::get_Department

Routine description:

	return Department

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrDepartment	            [out]    - the Department

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_Department"), hr);

    hr = GetBstr(pbstrDepartment, m_bstrDepartment);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_Department (
	BSTR bstrDepartment
)
/*++

Routine name : CFaxPersonalProfile::put_Department

Routine description:

	Set Department

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrDepartment               [in]    - new Department value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_Department"), hr, _T("%s"), bstrDepartment);

	m_bstrDepartment = bstrDepartment;
	if (!m_bstrDepartment && bstrDepartment)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== EMAIL ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_Email(
	BSTR *pbstrEmail
)
/*++

Routine name : CFaxPersonalProfile::get_Email

Routine description:

	return Email

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrEmail	            [out]    - the Email

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_Email"), hr);

    hr = GetBstr(pbstrEmail, m_bstrEmail);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_Email (
	BSTR bstrEmail
)
/*++

Routine name : CFaxPersonalProfile::put_Email

Routine description:

	Set Email

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrEmail               [in]    - new Email value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_Email"), hr, _T("%s"), bstrEmail);

	m_bstrEmail = bstrEmail;
	if (!m_bstrEmail && bstrEmail)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== FAX NUMBER ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_FaxNumber(
	BSTR *pbstrFaxNumber
)
/*++

Routine name : CFaxPersonalProfile::get_FaxNumber

Routine description:

	return FaxNumber

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrFaxNumber	            [out]    - the FaxNumber

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_FaxNumber"), hr);

    hr = GetBstr(pbstrFaxNumber, m_bstrFaxNumber);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_FaxNumber (
	BSTR bstrFaxNumber
)
/*++

Routine name : CFaxPersonalProfile::put_FaxNumber

Routine description:

	Set FaxNumber

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrFaxNumber               [in]    - new Fax Number 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_FaxNumber"), hr, _T("%s"), bstrFaxNumber);

	m_bstrFaxNumber = bstrFaxNumber;
	if (!m_bstrFaxNumber && bstrFaxNumber)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== HOME PHONE ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_HomePhone(
	BSTR *pbstrHomePhone
)
/*++

Routine name : CFaxPersonalProfile::get_HomePhone

Routine description:

	return HomePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrHomePhone	            [out]    - the HomePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_HomePhone"), hr);

    hr = GetBstr(pbstrHomePhone, m_bstrHomePhone);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_HomePhone (
	BSTR bstrHomePhone
)
/*++

Routine name : CFaxPersonalProfile::put_HomePhone

Routine description:

	Set HomePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrHomePhone               [in]    - new HomePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_HomePhone"), hr, _T("%s"), bstrHomePhone);

	m_bstrHomePhone = bstrHomePhone;
	if (!m_bstrHomePhone && bstrHomePhone)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== NAME ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_Name(
	BSTR *pbstrName
)
/*++

Routine name : CFaxPersonalProfile::get_Name

Routine description:

	return Name

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrName	            [out]    - the Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_Name"), hr);

    hr = GetBstr(pbstrName, m_bstrName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_Name (
	BSTR bstrName
)
/*++

Routine name : CFaxPersonalProfile::put_Name

Routine description:

	Set Name

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrName               [in]    - new Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_Name"), hr, _T("%s"), bstrName);

	m_bstrName = bstrName;
	if (!m_bstrName && bstrName)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== TSID ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_TSID(
	BSTR *pbstrTSID
)
/*++

Routine name : CFaxPersonalProfile::get_TSID

Routine description:

	return TSID

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrTSID	            [out]    - the TSID

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_TSID"), hr);

    hr = GetBstr(pbstrTSID, m_bstrTSID);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_TSID (
	BSTR bstrTSID
)
/*++

Routine name : CFaxPersonalProfile::put_TSID

Routine description:

	Set TSID

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrTSID               [in]    - new TSID

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_TSID"), hr, _T("%s"), bstrTSID);

    if (SysStringLen(bstrTSID) > FXS_TSID_CSID_MAX_LENGTH)
    {
		//
		//	Out of the Range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxPersonalProfile, IDS_ERROR_OUTOFRANGE, IID_IFaxPersonalProfile, hr);
		CALL_FAIL(GENERAL_ERR, _T("TSID is too long"), hr);
		return hr;
    }
    
    m_bstrTSID = bstrTSID;
	if (!m_bstrTSID && bstrTSID)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== OFFICE PHONE ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_OfficePhone(
	BSTR *pbstrOfficePhone
)
/*++

Routine name : CFaxPersonalProfile::get_OfficePhone

Routine description:

	return OfficePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrOfficePhone	            [out]    - the OfficePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_OfficePhone"), hr);
		
    hr = GetBstr(pbstrOfficePhone, m_bstrOfficePhone);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_OfficePhone (
	BSTR bstrOfficePhone
)
/*++

Routine name : CFaxPersonalProfile::put_OfficePhone

Routine description:

	Set OfficePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrOfficePhone               [in]    - new OfficePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_OfficePhone"), hr, _T("%s"), bstrOfficePhone);

	m_bstrOfficePhone = bstrOfficePhone;
	if (!m_bstrOfficePhone && bstrOfficePhone)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== OFFICE LOCATION ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_OfficeLocation(
	BSTR *pbstrOfficeLocation
)
/*++

Routine name : CFaxPersonalProfile::get_OfficeLocation

Routine description:

	return OfficeLocation

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrOfficeLocation	            [out]    - the OfficeLocation

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_OfficeLocation"), hr);

    hr = GetBstr(pbstrOfficeLocation, m_bstrOfficeLocation);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_OfficeLocation (
	BSTR bstrOfficeLocation
)
/*++

Routine name : CFaxPersonalProfile::put_OfficeLocation

Routine description:

	Set OfficeLocation

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrOfficeLocation               [in]    - new OfficeLocation

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_OfficeLocation"), hr, _T("%s"), bstrOfficeLocation);

	m_bstrOfficeLocation = bstrOfficeLocation;
	if (!m_bstrOfficeLocation && bstrOfficeLocation)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== STATE ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_State(
	BSTR *pbstrState
)
/*++

Routine name : CFaxPersonalProfile::get_State

Routine description:

	return State

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrState	            [out]    - the State

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_State"), hr);

    hr = GetBstr(pbstrState, m_bstrState);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_State (
	BSTR bstrState
)
/*++

Routine name : CFaxPersonalProfile::put_State

Routine description:

	Set State

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrState				[in]    - new State

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_State"), hr, _T("%s"), bstrState);

	m_bstrState = bstrState;
	if (!m_bstrState && bstrState)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== STREET ADDRESS ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_StreetAddress (
	BSTR *pbstrStreetAddress
)
/*++

Routine name : CFaxPersonalProfile::get_StreetAddress

Routine description:

	return StreetAddress

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrStreetAddress	            [out]    - the StreetAddress

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_StreetAddress"), hr);

    hr = GetBstr(pbstrStreetAddress, m_bstrStreetAddress);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_StreetAddress (
	BSTR bstrStreetAddress
)
/*++

Routine name : CFaxPersonalProfile::put_StreetAddress

Routine description:

	Set StreetAddress

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrStreetAddress				[in]    - new StreetAddress

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_StreetAddress"), hr, _T("%s"), bstrStreetAddress);

	m_bstrStreetAddress = bstrStreetAddress;
	if (!m_bstrStreetAddress && bstrStreetAddress)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== TITLE ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_Title (
	BSTR *pbstrTitle
)
/*++

Routine name : CFaxPersonalProfile::get_Title

Routine description:

	return Title

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrTitle	            [out]    - the Title

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_Title"), hr);

    hr = GetBstr(pbstrTitle, m_bstrTitle);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_Title (
	BSTR bstrTitle
)
/*++

Routine name : CFaxPersonalProfile::put_Title

Routine description:

	Set Title

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrTitle				[in]    - new Title

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_Title"), hr, _T("%s"), bstrTitle);

	m_bstrTitle = bstrTitle;
	if (!m_bstrTitle && bstrTitle)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== ZIP CODE ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_ZipCode (
	BSTR *pbstrZipCode
)
/*++

Routine name : CFaxPersonalProfile::get_ZipCode

Routine description:

	return ZipCode

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrZipCode	            [out]    - the ZipCode

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_ZipCode"), hr);

    hr = GetBstr(pbstrZipCode, m_bstrZipCode);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_ZipCode (
	BSTR bstrZipCode
)
/*++

Routine name : CFaxPersonalProfile::put_ZipCode

Routine description:

	Set ZipCode

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrZipCode				[in]    - new ZipCode

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_ZipCode"), hr, _T("%s"), bstrZipCode);

	m_bstrZipCode = bstrZipCode;
	if (!m_bstrZipCode && bstrZipCode)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutgoingmessage.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingMessage.cpp

Abstract:

	Implementation of Fax Outgoing Message Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutgoingMessage.h"


//
//==================== CREATE ========================================
//
HRESULT 
CFaxOutgoingMessage::Create (
	IFaxOutgoingMessage **ppOutgoingMessage
)
/*++

Routine name : CFaxOutgoingMessage::Create

Routine description:

	Static function to create the Fax Outgoing Message Instance

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	ppOutgoingMessage             [out]  -- the new Fax Outgoing Message Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxOutgoingMessage>		*pClass;
	HRESULT								hr = S_OK;

	DBG_ENTER (TEXT("CFaxOutgoingMessage::Create"), hr);

	hr = CComObject<CFaxOutgoingMessage>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutgoingMessage>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxOutgoingMessage),
		(void **) ppOutgoingMessage);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Outgoing Message Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}	//	CFaxOutgoingMessage::Create()

//
//============================ SUPPORT ERROR INFO ==================================================
//
STDMETHODIMP 
CFaxOutgoingMessage::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxOutgoingMessage::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Error Info Support

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	riid                          [in]    -	IID of the interface to check whether supports Error Info

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutgoingMessage
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxpersonalprofile.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxPersonalProfile.h

Abstract:

	Definition of Personal Profile Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXPERSONALPROFILE_H_
#define __FAXPERSONALPROFILE_H_

#include "resource.h"
#include "FaxCommon.h"

//
//================ HIDDEN INTERFACE OF PERSONAL PROFILE ===========================
//

MIDL_INTERFACE("41E2D834-3F09-4860-A426-1698E9ECDC72")
IFaxPersonalProfileInner : public IUnknown
{
	STDMETHOD(GetProfileData)(/*[out, retval]*/ FAX_PERSONAL_PROFILE *pProfileData) = 0;
	STDMETHOD(PutProfileData)(/*[in]*/ FAX_PERSONAL_PROFILE *pProfileData) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// CFaxPersonalProfile
class ATL_NO_VTABLE CFaxPersonalProfile : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxPersonalProfile, &IID_IFaxPersonalProfile, &LIBID_FAXCOMEXLib>,
	public IFaxPersonalProfileInner
{
public:
	CFaxPersonalProfile()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXPERSONALPROFILE)
DECLARE_NOT_AGGREGATABLE(CFaxPersonalProfile)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxPersonalProfile)
	COM_INTERFACE_ENTRY(IFaxPersonalProfile)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxPersonalProfileInner)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IFaxPersonalProfile
public:
	static HRESULT Create(IFaxPersonalProfile **ppFaxPersonalProfile);
	STDMETHOD(GetProfileData)(/*[out, retval]*/ FAX_PERSONAL_PROFILE *pProfileData);
	STDMETHOD(PutProfileData)(/*[in]*/ FAX_PERSONAL_PROFILE *pProfileData);

	STDMETHOD(SaveDefaultSender)();
	STDMETHOD(LoadDefaultSender)();
	STDMETHOD(get_BillingCode)(/*[out, retval]*/ BSTR *pbstrBillingCode);
	STDMETHOD(put_BillingCode)(/*[in]*/ BSTR bstrBillingCode);
	STDMETHOD(get_City)(/*[out, retval]*/ BSTR *pbstrCity);
	STDMETHOD(put_City)(/*[in]*/ BSTR bstrCity);
	STDMETHOD(get_Company)(/*[out, retval]*/ BSTR *pbstrCompany);
	STDMETHOD(put_Company)(/*[in]*/ BSTR bstrCompany);
	STDMETHOD(get_Country)(/*[out, retval]*/ BSTR *pbstrCountry);
	STDMETHOD(put_Country)(/*[in]*/ BSTR bstrCountry);
	STDMETHOD(get_Department)(/*[out, retval]*/ BSTR *pbstrDepartment);
	STDMETHOD(put_Department)(/*[in]*/ BSTR bstrDepartment);
	STDMETHOD(get_Email)(/*[out, retval]*/ BSTR *pbstrEmail);
	STDMETHOD(put_Email)(/*[in]*/ BSTR bstrEmail);
	STDMETHOD(get_FaxNumber)(/*[out, retval]*/ BSTR *pbstrFaxNumber);
	STDMETHOD(put_FaxNumber)(/*[in]*/ BSTR bstrFaxNumber);
	STDMETHOD(get_HomePhone)(/*[out, retval]*/ BSTR *pbstrHomePhone);
	STDMETHOD(put_HomePhone)(/*[in]*/ BSTR bstrHomePhone);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);
	STDMETHOD(put_Name)(/*[in]*/ BSTR bstrName);
	STDMETHOD(get_TSID)(/*[out, retval]*/ BSTR *pbstrTSID);
	STDMETHOD(put_TSID)(/*[in]*/ BSTR bstrTSID);
	STDMETHOD(get_OfficePhone)(/*[out, retval]*/ BSTR *pbstrOfficePhone);
	STDMETHOD(put_OfficePhone)(/*[in]*/ BSTR bstrOfficePhone);
	STDMETHOD(get_OfficeLocation)(/*[out, retval]*/ BSTR *pbstrOfficeLocation);
	STDMETHOD(put_OfficeLocation)(/*[in]*/ BSTR bstrOfficeLocation);
	STDMETHOD(get_State)(/*[out, retval]*/ BSTR *pbstrState);
	STDMETHOD(put_State)(/*[in]*/ BSTR bstrState);
	STDMETHOD(get_StreetAddress)(/*[out, retval]*/ BSTR *pbstrStreetAddress);
	STDMETHOD(put_StreetAddress)(/*[in]*/ BSTR bstrStreetAddress);
	STDMETHOD(get_Title)(/*[out, retval]*/ BSTR *pbstrTitle);
	STDMETHOD(put_Title)(/*[in]*/ BSTR bstrTitle);
	STDMETHOD(get_ZipCode)(/*[out, retval]*/ BSTR *pbstrZipCode);
	STDMETHOD(put_ZipCode)(/*[in]*/ BSTR bstrZipCode);

private:
	CComBSTR	m_bstrOfficeLocation;
	CComBSTR	m_bstrStreetAddress;
	CComBSTR	m_bstrOfficePhone;
	CComBSTR	m_bstrBillingCode;
	CComBSTR	m_bstrDepartment;
	CComBSTR	m_bstrFaxNumber;
	CComBSTR	m_bstrHomePhone;
	CComBSTR	m_bstrCompany;
	CComBSTR	m_bstrCountry;
	CComBSTR	m_bstrZipCode;
	CComBSTR	m_bstrEmail;
	CComBSTR	m_bstrState;
	CComBSTR	m_bstrTitle;
	CComBSTR	m_bstrCity;
	CComBSTR	m_bstrName;
	CComBSTR	m_bstrTSID;
};

#endif //__FAXPERSONALPROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutgoingmessageiterator.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingMessageIterator.cpp

Abstract:

	Implementation of CFaxOutgoingMessageIterator.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutgoingMessageIterator.h"
#include "FaxOutgoingMessage.h"

//
//========================= SUPPORT ERROR INFO =======================================
//
STDMETHODIMP 
CFaxOutgoingMessageIterator::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxOutgoingMessageIterator::InterfaceSupportsErrorInfo

Routine description:

	ATL's Support for Error Info.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	riid                          [in]    - IID of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutgoingMessageIterator
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxOutgoingMessageIterator::Create (
	IFaxOutgoingMessageIterator **pOutgoingMsgIterator
)
/*++

Routine name : CFaxOutgoingMessageIterator::Create

Routine description:

	Static function to create the Fax Outgoing Message Iterator Object

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pOutgoingMsgIterator		[out]  -- the new Fax Outgoing Message Iterator Object

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxOutgoingMessageIterator>		*pClass;
	HRESULT			hr = S_OK;

	DBG_ENTER (TEXT("CFaxOutgoingMessageIterator::Create"), hr);

	hr = CComObject<CFaxOutgoingMessageIterator>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutgoingMessageIterator>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxOutgoingMessageIterator), (void **) pOutgoingMsgIterator);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Outgoing Message Iterator Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}
	return hr;
}	//	CFaxOutgoingMessageIterator::Create()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxoutgoingqueue.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingQueue.cpp

Abstract:

	Implementation of CFaxOutgoingQueue

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutgoingQueue.h"
#include "..\..\inc\FaxUIConstants.h"


//
//==================== GET DATE ===================================================
//
STDMETHODIMP 
CFaxOutgoingQueue::GetDate(
    FAX_TIME faxTime,
	DATE *pDate
)
/*++

Routine name : CFaxOutgoingQueue::GetDate

Routine description:

	Return the date 

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

    faxTime      [in]     - time to convert from
	pDate        [out]    - Ptr to the Place to put the Date

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::GetDate"), hr);

	//
	//	Check that we can write to the given pointer
	//
	if (!pDate)
	{
		//
		//	Got Bad Return Pointer
		//
		hr = E_POINTER;
		AtlReportError(CLSID_FaxOutgoingQueue, GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr);
		CALL_FAIL(GENERAL_ERR, _T("!pDate"), hr);
		return hr;
	}

    SYSTEMTIME  sysTime = {0};
    sysTime.wHour = faxTime.Hour;
    sysTime.wMinute = faxTime.Minute;

    DATE    dtResult = 0;

    if (sysTime.wHour == 0 && sysTime.wMinute == 0)
    {
        *pDate = dtResult;
	    return hr;
    }

    if (!SystemTimeToVariantTime(&sysTime, &dtResult))
    {
        hr = E_FAIL;
		AtlReportError(CLSID_FaxOutgoingQueue, 
            IDS_ERROR_OPERATION_FAILED, 
            IID_IFaxOutgoingQueue, 
            hr);
		CALL_FAIL(GENERAL_ERR, _T("SystemTimeToVariantTime"), hr);
		return hr;
    }

    *pDate = dtResult;
	return hr;
}

//
//==================== SET DATE ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::SetDate(
		DATE date,
        FAX_TIME *pfaxTime
)
/*++

Routine name : CFaxOutgoingQueue::SetDate

Routine description:

	Set new value for the given Time

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	date                [in]    - the new Value for the date
    pfaxTime             [in]    - where to put the value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
    SYSTEMTIME  sysTime;

	DBG_ENTER (_T("CFaxOutgoingQueue::SetDate"), hr);

    if (!VariantTimeToSystemTime(date, &sysTime))
    {
        hr = E_FAIL;
		AtlReportError(CLSID_FaxOutgoingQueue, 
            IDS_ERROR_OPERATION_FAILED, 
            IID_IFaxOutgoingQueue, 
            hr);
		CALL_FAIL(GENERAL_ERR, _T("VariantTimeToSystemTime"), hr);
		return hr;
    }

    pfaxTime->Hour = sysTime.wHour;
    pfaxTime->Minute = sysTime.wMinute;
	return hr;
}

//
//==================== DISCOUNT RATE END ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_DiscountRateEnd(
		DATE *pdateDiscountRateEnd
)
/*++

Routine name : CFaxOutgoingQueue::get_DiscountRateEnd

Routine description:

	Return date when the Discount period begins

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pdateDiscountRateEnd        [out]    - Ptr to the Place to put the DiscountRateEnd

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_DiscountRateEnd"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetDate(m_pConfig->dtDiscountEnd, pdateDiscountRateEnd);
    return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_DiscountRateEnd(
		DATE dateDiscountRateEnd
)
/*++

Routine name : CFaxOutgoingQueue::put_DiscountRateEnd

Routine description:

	Set new value Discount Rate End

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	dateDiscountRateEnd                     [in]    - the new Value for DiscountRateEnd

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_DiscountRateEnd"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = SetDate(dateDiscountRateEnd, &(m_pConfig->dtDiscountEnd));
    return hr;
}

//
//==================== DISCOUNT RATE START ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_DiscountRateStart(
		DATE *pdateDiscountRateStart
)
/*++

Routine name : CFaxOutgoingQueue::get_DiscountRateStart

Routine description:

	Return date when the Discount period begins

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pdateDiscountRateStart        [out]    - Ptr to the Place to put the DiscountRateStart

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_DiscountRateStart"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetDate(m_pConfig->dtDiscountStart, pdateDiscountRateStart);
    return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_DiscountRateStart(
		DATE dateDiscountRateStart
)
/*++

Routine name : CFaxOutgoingQueue::put_DiscountRateStart

Routine description:

	Set new value Discount Rate Start

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	dateDiscountRateStart                     [in]    - the new Value for DiscountRateStart

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_DiscountRateStart"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = SetDate(dateDiscountRateStart, &(m_pConfig->dtDiscountStart));
    return hr;
}

//
//==================== RETRY DELAY ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_RetryDelay(
		long *plRetryDelay
)
/*++

Routine name : CFaxOutgoingQueue::get_RetryDelay

Routine description:

	Return number of RetryDelay

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	plRetryDelay        [out]    - Ptr to the Place to put the number of RetryDelay

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_RetryDelay"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plRetryDelay, m_pConfig->dwRetryDelay);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_RetryDelay(
		long lRetryDelay
)
/*++

Routine name : CFaxOutgoingQueue::put_RetryDelay

Routine description:

	Set new value for this flag

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	lRetryDelay                     [in]    - the new Value of number of RetryDelay

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_RetryDelay"), hr, _T("%ld"), lRetryDelay);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (lRetryDelay > FXS_RETRYDELAY_UPPER || lRetryDelay < FXS_RETRYDELAY_LOWER)
    {
		//
		//	Out of the Range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxOutgoingQueue, IDS_ERROR_OUTOFRANGE, IID_IFaxOutgoingQueue, hr);
		CALL_FAIL(GENERAL_ERR, _T("Type is out of the Range"), hr);
		return hr;
    }

	m_pConfig->dwRetryDelay = lRetryDelay;
	return hr;
}

//
//==================== AGE LIMIT ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_AgeLimit(
    long *plAgeLimit
)
/*++

Routine name : CFaxOutgoingQueue::get_AgeLimit

Routine description:

	Return number of AgeLimit

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	plAgeLimit        [out]    - Ptr to the Place to put the number of AgeLimit

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_AgeLimit"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plAgeLimit, m_pConfig->dwAgeLimit);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_AgeLimit(
		long lAgeLimit
)
/*++

Routine name : CFaxOutgoingQueue::put_AgeLimit

Routine description:

	Set new value for this flag

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	lAgeLimit                     [in]    - the new Value of number of AgeLimit

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_AgeLimit"), hr, _T("%ld"), lAgeLimit);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_pConfig->dwAgeLimit = lAgeLimit;
	return hr;
}

//
//==================== RETRIES ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_Retries(
		long *plRetries
)
/*++

Routine name : CFaxOutgoingQueue::get_Retries

Routine description:

	Return number of Retries

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	plRetries        [out]    - Ptr to the Place to put the number of retries

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_Retries"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plRetries, m_pConfig->dwRetries);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_Retries(
		long lRetries
)
/*++

Routine name : CFaxOutgoingQueue::put_Retries

Routine description:

	Set new value for this flag

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	lRetries                     [in]    - the new Value of number of retries

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_Retries"), hr, _T("%ld"), lRetries);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (lRetries > FXS_RETRIES_UPPER || lRetries < FXS_RETRIES_LOWER)
    {
		//
		//	Out of the Range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxOutgoingQueue, IDS_ERROR_OUTOFRANGE, IID_IFaxOutgoingQueue, hr);
		CALL_FAIL(GENERAL_ERR, _T("Type is out of the Range"), hr);
		return hr;
    }

	m_pConfig->dwRetries = lRetries;
	return hr;
}

//
//==================== BRANDING ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_Branding(
		VARIANT_BOOL *pbBranding
)
/*++

Routine name : CFaxOutgoingQueue::get_Branding

Routine description:

	Return Flag indicating whether Branding exists

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pbBranding        [out]    - Ptr to the Place to put Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_Branding"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbBranding, bool2VARIANT_BOOL(m_pConfig->bBranding));
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_Branding(
		VARIANT_BOOL bBranding
)
/*++

Routine name : CFaxOutgoingQueue::put_Branding

Routine description:

	Set new value for this flag

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	bBranding                     [in]    - the new Value for the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_Branding"), hr, _T("%d"), bBranding);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_pConfig->bBranding = VARIANT_BOOL2bool(bBranding);
	return hr;
}

//
//==================== USE DEVICE TSID ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_UseDeviceTSID(
		VARIANT_BOOL *pbUseDeviceTSID
)
/*++

Routine name : CFaxOutgoingQueue::get_UseDeviceTSID

Routine description:

	Return Flag indicating whether to use device TSID

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pbUseDeviceTSID        [out]    - Ptr to the Place to put Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_UseDeviceTSID"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbUseDeviceTSID, bool2VARIANT_BOOL(m_pConfig->bUseDeviceTSID));
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_UseDeviceTSID(
		VARIANT_BOOL bUseDeviceTSID
)
/*++

Routine name : CFaxOutgoingQueue::put_UseDeviceTSID

Routine description:

	Set new value for this flag

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	bUseDeviceTSID              [in]    - the new Value for the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_UseDeviceTSID"), hr, _T("%d"), bUseDeviceTSID);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_pConfig->bUseDeviceTSID = VARIANT_BOOL2bool(bUseDeviceTSID);
	return hr;
}

//
//==================== ALLOW PERSONAL COVER PAGES ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_AllowPersonalCoverPages(
		VARIANT_BOOL *pbAllowPersonalCoverPages
)
/*++

Routine name : CFaxOutgoingQueue::get_AllowPersonalCoverPages

Routine description:

	Return Flag indicating whether Personal Cover Pages are allowed

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pbAllowPersonalCoverPages   [out]    - Ptr to the Place to put Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
    DBG_ENTER (TEXT("CFaxOutgoingQueue::get_AllowPersonalCoverPages"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbAllowPersonalCoverPages, bool2VARIANT_BOOL(m_pConfig->bAllowPersonalCP));
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_AllowPersonalCoverPages(
		VARIANT_BOOL bAllowPersonalCoverPages
)
/*++

Routine name : CFaxOutgoingQueue::put_AllowPersonalCoverPages

Routine description:

	Set new value for this flag

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	bAllowPersonalCoverPages        [in]    - the new Value for the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxOutgoingQueue::put_AllowPersonalCoverPages"), hr, _T("%d"), bAllowPersonalCoverPages);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_pConfig->bAllowPersonalCP = VARIANT_BOOL2bool(bAllowPersonalCoverPages);
	return hr;
}

//
//==================== SAVE ==============================================
//
STDMETHODIMP 
CFaxOutgoingQueue::Save(
)
/*++

Routine name : CFaxOutgoingQueue::Save

Routine description:

	Save current Outgoing Queue Configuration to the Server.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

	DBG_ENTER (TEXT("CFaxOutgoingQueue::Save"), hr);

    //
    //  Get Fax Handle 
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue, 
            GetErrorMsgId(hr), 
            IID_IFaxOutgoingQueue, 
            hr);
        return hr;
    }

    //
    //  Save Outgoing Queue Configuration
    //
    if (!FaxSetOutboxConfiguration(hFaxHandle, m_pConfig))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxSetOutboxConfiguration"), hr);
        AtlReportError(CLSID_FaxOutgoingQueue, 
            GetErrorMsgId(hr), 
            IID_IFaxOutgoingQueue, 
            hr);
        return hr;
    }

    //
    //  Save Paused and Blocked as well
    //
    hr = CFaxQueueInner<IFaxOutgoingQueue, &IID_IFaxOutgoingQueue, &CLSID_FaxOutgoingQueue, false,
        IFaxOutgoingJob, CFaxOutgoingJob, IFaxOutgoingJobs, CFaxOutgoingJobs>::Save();

    return hr;
}

//
//==================== REFRESH ==============================================
//
STDMETHODIMP 
CFaxOutgoingQueue::Refresh(
)
/*++

Routine name : CFaxOutgoingQueue::Refresh

Routine description:

	Bring Outgoing Queue Configuration from the Server.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

	DBG_ENTER (TEXT("CFaxOutgoingQueue::Refresh"), hr);

    //
    //  Get Fax Handle 
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue, 
            GetErrorMsgId(hr), 
            IID_IFaxOutgoingQueue, 
            hr);
        return hr;
    }

    //
    //  Get Outgoing Queue Configuration
    //
    if (!FaxGetOutboxConfiguration(hFaxHandle, &m_pConfig))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetOutboxConfiguration"), hr);
        AtlReportError(CLSID_FaxOutgoingQueue, 
            GetErrorMsgId(hr), 
            IID_IFaxOutgoingQueue, 
            hr);
        return hr;
    }

	if (!m_pConfig || m_pConfig->dwSizeOfStruct != sizeof(FAX_OUTBOX_CONFIG))
	{
		//
		//	Failed to Get Outgoing Queue Configuration
		//
		hr = E_FAIL;
		AtlReportError(CLSID_FaxOutgoingQueue, 
            IDS_ERROR_OPERATION_FAILED, 
            IID_IFaxOutgoingQueue, 
            hr);
		CALL_FAIL(GENERAL_ERR, _T("Invalid m_pConfig"), hr);
		return hr;
	}

    //
    //  Refresh Paused and Blocked as well
    //
    hr = CFaxQueueInner<IFaxOutgoingQueue, &IID_IFaxOutgoingQueue, &CLSID_FaxOutgoingQueue, false,
        IFaxOutgoingJob, CFaxOutgoingJob, IFaxOutgoingJobs, CFaxOutgoingJobs>::Refresh();

    if (SUCCEEDED(hr))  
    {
        //
        //  We are synced now
        //
        m_bInited = true;
    }

    return hr;
}

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxOutgoingQueue::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxOutgoingQueue::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Interface Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Reference of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutgoingQueue
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxreceiptoptions.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	faxreceiptoptions.h

Abstract:

	Declaration of the CFaxReceiptOptions class.

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#ifndef __FAXRECEIPTOPTIONS_H_
#define __FAXRECEIPTOPTIONS_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//====================== FAX RECEIPT OPTIONS =======================================
//
class ATL_NO_VTABLE CFaxReceiptOptions : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxReceiptOptions, &IID_IFaxReceiptOptions, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxReceiptOptions() : CFaxInitInner(_T("FAX RECEIPT OPTIONS")), 
        m_bInited(false), m_bPasswordDirty(false)
	{
	}

	~CFaxReceiptOptions()
	{
		SecureZeroMemory(m_bstrPassword.m_str, (m_bstrPassword.Length() * sizeof(OLECHAR)));
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXRECEIPTOPTIONS)
DECLARE_NOT_AGGREGATABLE(CFaxReceiptOptions)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxReceiptOptions)
	COM_INTERFACE_ENTRY(IFaxReceiptOptions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(Save)();
    STDMETHOD(Refresh)();

    STDMETHOD(put_SMTPPort)(/*[in]*/ long lSMTPPort);
    STDMETHOD(get_SMTPPort)(/*[out, retval]*/ long *plSMTPPort);

    STDMETHOD(put_SMTPUser)(/*[in]*/ BSTR bstrSMTPUser);
    STDMETHOD(get_SMTPUser)(/*[out, retval]*/ BSTR *pbstrSMTPUser);

    STDMETHOD(put_SMTPSender)(/*[in]*/ BSTR bstrSMTPSender);
    STDMETHOD(get_SMTPSender)(/*[out, retval]*/ BSTR *pbstrSMTPSender);

    STDMETHOD(put_SMTPServer)(/*[in]*/ BSTR bstrSMTPServer);
    STDMETHOD(get_SMTPServer)(/*[out, retval]*/ BSTR *pbstrSMTPServer);

    STDMETHOD(put_SMTPPassword)(/*[in]*/ BSTR bstrSMTPPassword);
    STDMETHOD(get_SMTPPassword)(/*[out, retval]*/ BSTR *pbstrSMTPPassword);

    STDMETHOD(put_AllowedReceipts)(/*[in]*/ FAX_RECEIPT_TYPE_ENUM AllowedReceipts);
    STDMETHOD(get_AllowedReceipts)(/*[out, retval]*/ FAX_RECEIPT_TYPE_ENUM *pAllowedReceipts);

    STDMETHOD(put_AuthenticationType)(/*[in]*/ FAX_SMTP_AUTHENTICATION_TYPE_ENUM Type);
    STDMETHOD(get_AuthenticationType)(/*[out, retval]*/ FAX_SMTP_AUTHENTICATION_TYPE_ENUM *pType);

    STDMETHOD(get_UseForInboundRouting)(/*[out, retval]*/ VARIANT_BOOL *pbUseForInboundRouting);
    STDMETHOD(put_UseForInboundRouting)(/*[in]*/ VARIANT_BOOL bUseForInboundRouting);

private:
    bool            m_bInited;
    bool            m_bPasswordDirty;       // true only if password was set in the object
    DWORD           m_dwPort;
    DWORD           m_dwAllowedReceipts;                      
    CComBSTR        m_bstrSender;
    CComBSTR        m_bstrUser;
    CComBSTR        m_bstrPassword;
    CComBSTR        m_bstrServer;
    VARIANT_BOOL    m_bUseForInboundRouting;
    FAX_SMTP_AUTHENTICATION_TYPE_ENUM   m_AuthType;
};

#endif //__FAXRECEIPTOPTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxreceiptoptions.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxReceiptOptions.cpp

Abstract:

	Implementation of Fax Receipts Options Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxReceiptOptions.h"

//
//========================= USE FOR INBOUND ROUTING ====================================================
//
STDMETHODIMP 
CFaxReceiptOptions::put_UseForInboundRouting(
    VARIANT_BOOL bUseForInboundRouting
)
/*++

Routine name : CFaxReceiptOptions::put_UseForInboundRouting

Routine description:

	Set flag indicating whether current IFaxReceiptsOptions configuration should be used within the MS Routing 
        Extension to route the incoming faxed through SMTP e-mail.

Author:

	Iv Garber (IvG),	Feb, 2001

Arguments:

	bUseForInboundRouting      [out]    - the flag. See description

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::put_UseForInboundRouting"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bUseForInboundRouting = bUseForInboundRouting;
    return hr;
}

//
//========================= USE FOR INBOUND ROUTING ====================================================
//
STDMETHODIMP 
CFaxReceiptOptions::get_UseForInboundRouting(
    VARIANT_BOOL *pbUseForInboundRouting
)
/*++

Routine name : CFaxReceiptOptions::get_UseForInboundRouting

Routine description:

	Return flag indicating whether current IFaxReceiptsOptions configuration should be used within the MS Routing 
        Extension to route the incoming faxed through SMTP e-mail.

Author:

	Iv Garber (IvG),	Feb, 2001

Arguments:

	pbUseForInboundRouting      [out]    - the flag. See description

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_UseForInboundRouting"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbUseForInboundRouting, m_bUseForInboundRouting);
    if (FAILED(hr))
    {
	    AtlReportError(CLSID_FaxReceiptOptions, 
            GetErrorMsgId(hr), 
            IID_IFaxReceiptOptions, 
            hr);
        return hr;
    }
    return hr;
}

//
//========================= ALLOWED RECEIPTS ====================================================
//
STDMETHODIMP 
CFaxReceiptOptions::get_AllowedReceipts(
    FAX_RECEIPT_TYPE_ENUM *pAllowedReceipts
)
/*++

Routine name : CFaxReceiptOptions::get_AllowedReceipts

Routine description:

	Return the Receipt Types allowed by the Server

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pAllowedReceipts       [out]    - the Bit-Wise Combination of Allowed Receipt Types 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_AllowedReceipts"), hr);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(pAllowedReceipts, sizeof(FAX_RECEIPT_TYPE_ENUM)))
	{
		//	
		//	Got Bad Return Pointer
		//
		hr = E_POINTER;
		AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxReceiptOptions, hr);
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    *pAllowedReceipts = FAX_RECEIPT_TYPE_ENUM(m_dwAllowedReceipts);
	return hr;
}

STDMETHODIMP 
CFaxReceiptOptions::put_AllowedReceipts(
    FAX_RECEIPT_TYPE_ENUM AllowedReceipts
)
/*++

Routine name : CFaxReceiptOptions::put_AllowedReceipts

Routine description:

	Change the Receipts Types on Server

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	AllowedReceipts        [in]    - the new Bit-Wise Combination of Allowed Receipt Types 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxReceiptOptions::put_AllowedReceipts"), hr, _T("%d"), AllowedReceipts);

    //
    //  Check that value is valid
    //
    if ((AllowedReceipts != frtNONE) && (AllowedReceipts & ~(frtMAIL | frtMSGBOX))) // Invalid bits
    {
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxReceiptOptions, hr);
		CALL_FAIL(GENERAL_ERR, _T("(AllowedReceipts is wrong)"), hr);
		return hr;
    }

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_dwAllowedReceipts = AllowedReceipts;
	return hr;
}

//
//========================= SMTP PORT ====================================================
//
STDMETHODIMP 
CFaxReceiptOptions::get_SMTPPort(
	long *plSMTPPort
)
/*++

Routine name : CFaxReceiptOptions::get_SMTPPort

Routine description:

	Return the SMTPPort

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	plSMTPPort                     [out]    - the Current SMTPPort

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_SMTPPort"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plSMTPPort, m_dwPort);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxReceiptOptions::put_SMTPPort(
	long lSMTPPort
)
/*++

Routine name : CFaxReceiptOptions::put_SMTPPort

Routine description:

	Set new SMTPPort for Receipts 

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	SMTPPort                    [in]    - the new Receipts SMTPPort

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxReceiptOptions::put_SMTPPort"), hr, _T("%d"), lSMTPPort);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_dwPort = lSMTPPort;
	return hr;
}

//
//========================= TYPE ====================================================
//
STDMETHODIMP 
CFaxReceiptOptions::get_AuthenticationType(
	FAX_SMTP_AUTHENTICATION_TYPE_ENUM *pType
)
/*++

Routine name : CFaxReceiptOptions::get_AuthenticationType

Routine description:

	Return the Authentication Type supported by the Server

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pType                     [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_AuthenticationType"), hr);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(pType, sizeof(FAX_SMTP_AUTHENTICATION_TYPE_ENUM)))
	{
		//	
		//	Got Bad Return Pointer
		//
		hr = E_POINTER;
		AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxReceiptOptions, hr);
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	*pType = m_AuthType;
	return hr;
}

STDMETHODIMP 
CFaxReceiptOptions::put_AuthenticationType(
	FAX_SMTP_AUTHENTICATION_TYPE_ENUM Type
)
/*++

Routine name : CFaxReceiptOptions::put_AuthenticationType

Routine description:

	Set new Authenticatin Type for the Server

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	Type                    [in]    - the new Authentication type for the Server

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxReceiptOptions::put_AuthenticationType"), hr, _T("%d"), Type);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Check Ranges
    //
	if (Type < fsatANONYMOUS || Type > fsatNTLM)
	{
		//
		//	Out of the Range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_OUTOFRANGE, IID_IFaxReceiptOptions, hr);
		CALL_FAIL(GENERAL_ERR, _T("Type is out of the Range"), hr);
		return hr;
	}

	m_AuthType = FAX_SMTP_AUTHENTICATION_TYPE_ENUM(Type);
	return hr;
}

//
//============================= SMTP SENDER ====================================
//
STDMETHODIMP 
CFaxReceiptOptions::put_SMTPSender(
	BSTR bstrSMTPSender
)
/*++

Routine name : CFaxReceiptOptions::put_SMTPSender

Routine description:

	Set the SMTPSender

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrSMTPSender              [in]    - the new value of SMTPSender

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxReceiptOptions::put_SMTPSender"), hr, _T("%s"), bstrSMTPSender);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bstrSender = bstrSMTPSender;
	if (bstrSMTPSender && !m_bstrSender)
	{
		//	
		//	not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxReceiptOptions, 
            IDS_ERROR_OUTOFMEMORY, 
            IID_IFaxReceiptOptions, 
            hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
		return hr;
	}
    return hr;
}

STDMETHODIMP 
CFaxReceiptOptions::get_SMTPSender(
	BSTR *pbstrSMTPSender
)
/*++

Routine name : CFaxReceiptOptions::get_SMTPSender

Routine description:

	Return the SMTP Sender

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrSMTPSender                    [out]    - the SMTPSender

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_SMTPSender"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetBstr(pbstrSMTPSender, m_bstrSender);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr);
        return hr;
    }
	return hr;
}

//
//============================= SMTP USER ====================================
//
STDMETHODIMP 
CFaxReceiptOptions::put_SMTPUser(
	BSTR bstrSMTPUser
)
/*++

Routine name : CFaxReceiptOptions::put_SMTPUser

Routine description:

	Set the SMTPUser

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrSMTPUser              [in]    - the new value of SMTPUser

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxReceiptOptions::put_SMTPUser"), hr, _T("%s"), bstrSMTPUser);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bstrUser = bstrSMTPUser;
	if (bstrSMTPUser && !m_bstrUser)
	{
		//	
		//	not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxReceiptOptions, 
            IDS_ERROR_OUTOFMEMORY, 
            IID_IFaxReceiptOptions, 
            hr);
		CALL_FAIL(MEM_ERR, _T("::SysAllocString()"), hr);
		return hr;
	}

	return hr;
}

STDMETHODIMP 
CFaxReceiptOptions::get_SMTPUser(
	BSTR *pbstrSMTPUser
)
/*++

Routine name : CFaxReceiptOptions::get_SMTPUser

Routine description:

	Return the SMTP User

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrSMTPUser                    [out]    - the SMTPUser

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_SMTPUser"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetBstr(pbstrSMTPUser, m_bstrUser);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr);
        return hr;
    }
	return hr;
}

//
//============================= SMTP PASSWORD ====================================
//
STDMETHODIMP 
CFaxReceiptOptions::put_SMTPPassword(
	BSTR bstrSMTPPassword
)
/*++

Routine name : CFaxReceiptOptions::put_SMTPPassword

Routine description:

	Set the SMTPPassword

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrSMTPPassword              [in]    - the new value of SMTPPassword

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxReceiptOptions::put_SMTPPassword"), hr, _T("%s"), bstrSMTPPassword);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	SecureZeroMemory(m_bstrPassword.m_str, (m_bstrPassword.Length() * sizeof(OLECHAR)));
    m_bstrPassword = bstrSMTPPassword;
	if (bstrSMTPPassword && !m_bstrPassword)
	{
		//	
		//	not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxReceiptOptions, 
            IDS_ERROR_OUTOFMEMORY, 
            IID_IFaxReceiptOptions, 
            hr);
		CALL_FAIL(MEM_ERR, _T("::SysAllocString()"), hr);
		return hr;
	}
    m_bPasswordDirty = true;
	return hr;
}   // CFaxReceiptOptions::put_SMTPPassword

STDMETHODIMP 
CFaxReceiptOptions::get_SMTPPassword(
	BSTR *pbstrSMTPPassword
)
/*++

Routine name : CFaxReceiptOptions::get_SMTPPassword

Routine description:

	Return the SMTP Password

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrSMTPPassword                    [out]    - the SMTPPassword

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxReceiptOptions::get_SMTPPassword"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetBstr(pbstrSMTPPassword, m_bstrPassword);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr);
        return hr;
    }
	return hr;
}

//
//============================= SMTP SERVER ====================================
//
STDMETHODIMP 
CFaxReceiptOptions::put_SMTPServer(
	BSTR bstrSMTPServer
)
/*++

Routine name : CFaxReceiptOptions::put_SMTPServer

Routine description:

	Set the SMTPServer

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrSMTPServer              [in]    - the new value of SMTPServer

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxReceiptOptions::put_SMTPServer"), hr, _T("%s"), bstrSMTPServer);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bstrServer = bstrSMTPServer;
	if (bstrSMTPServer && !m_bstrServer)
	{
		//	
		//	not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxReceiptOptions, 
            IDS_ERROR_OUTOFMEMORY, 
            IID_IFaxReceiptOptions, 
            hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
		return hr;
	}

	return hr;
}

STDMETHODIMP 
CFaxReceiptOptions::get_SMTPServer(
	BSTR *pbstrSMTPServer
)
/*++

Routine name : CFaxReceiptOptions::get_SMTPServer

Routine description:

	Return the SMTP Server

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrSMTPServer                    [out]    - the SMTPServer

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_SMTPServer"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetBstr(pbstrSMTPServer, m_bstrServer);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr);
        return hr;
    }
	return hr;
}


//
//==================== SAVE ========================================
//
STDMETHODIMP
CFaxReceiptOptions::Save(
)
/*++

Routine name : CFaxReceiptOptions::Save

Routine description:

	Save current Receipt Options at the Server.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxReceiptOptions::Save"), hr);

    if (!m_bInited)
    {
        //
        //  nothing was done to the Receipt Options
        //
        return hr;
    }

    if (m_dwAllowedReceipts & frtMAIL)
    {

        //
        //  check validity of values
        //
        switch(m_AuthType)
        {
        case fsatNTLM:
        case fsatBASIC:
            if (m_bstrUser.Length() < 1)
            {
                hr = E_FAIL;
                AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_NOUSERPASSWORD, IID_IFaxReceiptOptions, hr);
                CALL_FAIL(GENERAL_ERR, _T("ReceiptOptions = SMTP_NTLM/BASIC + User/Password is empty"), hr);
                return hr;
            }

            // no break, continue to SMTP_ANONYMOUS case

        case fsatANONYMOUS:
            if ((m_bstrServer.Length() < 1) || (m_bstrSender.Length() < 1) || m_dwPort < 1)
            {
                hr = E_FAIL;
                AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_NOSERVERSENDERPORT, IID_IFaxReceiptOptions, hr);
                CALL_FAIL(GENERAL_ERR, _T("ReceiptOptions = SMTP_... + Server/Sender/Port is empty"), hr);
                return hr;
            }
            break;
        default:
            //
            //  assert (FALSE)
            //
            ATLASSERT(m_AuthType == fsatANONYMOUS);
            break;
        }
    }

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr);
        return hr;
    }

    //
    //  Create ReceiptOptions Struct
    //
    FAX_RECEIPTS_CONFIG    ReceiptsConfig = {0};
    ReceiptsConfig.dwSizeOfStruct = sizeof(FAX_RECEIPTS_CONFIG);
    ReceiptsConfig.dwSMTPPort = m_dwPort;
    ReceiptsConfig.lptstrSMTPFrom = m_bstrSender;
    ReceiptsConfig.lptstrSMTPUserName = m_bstrUser;
    if (m_bPasswordDirty)
    {
        //
        // Password has changed since last save / refresh
        //
        ReceiptsConfig.lptstrSMTPPassword = m_bstrPassword;
    }
    else
    {
        //
        // Password has not changed since last save / refresh.
        // The fax service knows not to change it in the registry if we pass NULL here.
        //
    }
    ReceiptsConfig.lptstrSMTPServer = m_bstrServer;
    ReceiptsConfig.SMTPAuthOption = FAX_ENUM_SMTP_AUTH_OPTIONS(m_AuthType);
    ReceiptsConfig.dwAllowedReceipts = m_dwAllowedReceipts;
    ReceiptsConfig.bIsToUseForMSRouteThroughEmailMethod = VARIANT_BOOL2bool(m_bUseForInboundRouting);
    //
    //  Ask the Server to set the Receipt Configuration
    //
    if (!FaxSetReceiptsConfiguration(hFaxHandle, &ReceiptsConfig))
    {
        //
        //  Failed to set Receipts Options on the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxSetReceiptConfiguration(hFaxHandle, &ReceiptsConfig)"), hr);
        return hr;
    }
    m_bPasswordDirty = false;
    return hr;
}

//
//==================== REFRESH ========================================
//
STDMETHODIMP
CFaxReceiptOptions::Refresh(
)
/*++

Routine name : CFaxReceiptOptions::Refresh

Routine description:

	Bring new Receipt Options from the Server.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxReceiptOptions::Refresh"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxReceiptOptions, 
            GetErrorMsgId(hr), 
            IID_IFaxReceiptOptions, 
            hr);
        return hr;
    }

    //
    //  Ask Server for the Receipts Options Struct
    //
    CFaxPtr<FAX_RECEIPTS_CONFIG>    pReceiptsConfig;
    if (!FaxGetReceiptsConfiguration(hFaxHandle, &pReceiptsConfig))
    {
        //
        //  Failed to get Receipts Options object from the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxReceiptOptions, 
            GetErrorMsgId(hr), 
            IID_IFaxReceiptOptions, 
            hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxGetReceiptConfiguration(hFaxHandle, &pReceiptsConfig)"), hr);
        return hr;
    }

    //  
    //  Check that pReceiptConfig is valid
    //
    if (!pReceiptsConfig || pReceiptsConfig->dwSizeOfStruct != sizeof(FAX_RECEIPTS_CONFIG))
    {
        hr = E_FAIL;
        AtlReportError(CLSID_FaxReceiptOptions, 
            GetErrorMsgId(hr), 
            IID_IFaxReceiptOptions, 
            hr);
        CALL_FAIL(GENERAL_ERR, _T("(!m_pReceiptsConfig || SizeOfStruct != sizeof(FAX_RECEIPTS_CONFIG))"), hr);
        return hr;
    }

    m_dwPort = pReceiptsConfig->dwSMTPPort;
    m_AuthType = FAX_SMTP_AUTHENTICATION_TYPE_ENUM(pReceiptsConfig->SMTPAuthOption);
    m_dwAllowedReceipts = pReceiptsConfig->dwAllowedReceipts;
    m_bUseForInboundRouting = bool2VARIANT_BOOL(pReceiptsConfig->bIsToUseForMSRouteThroughEmailMethod);

    m_bstrSender = pReceiptsConfig->lptstrSMTPFrom;
    m_bstrUser = pReceiptsConfig->lptstrSMTPUserName;
    m_bstrServer = pReceiptsConfig->lptstrSMTPServer;

	SecureZeroMemory(m_bstrPassword.m_str, (m_bstrPassword.Length() * sizeof(OLECHAR)));
    m_bstrPassword = pReceiptsConfig->lptstrSMTPPassword;

    if ( ((pReceiptsConfig->lptstrSMTPFrom) && !m_bstrSender) ||
         ((pReceiptsConfig->lptstrSMTPUserName) && !m_bstrUser) ||
         ((pReceiptsConfig->lptstrSMTPPassword) && !m_bstrPassword) ||
         ((pReceiptsConfig->lptstrSMTPServer) && !m_bstrServer) )
    {
		//
		//	Failed to Copy
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_OUTOFMEMORY, IID_IFaxReceiptOptions, hr);
		CALL_FAIL(MEM_ERR, _T("::SysAllocString()"), hr);
		return hr;
    }
    m_bPasswordDirty = false;
    m_bInited = true;
    return hr;
}

//
//================ SUPPORT ERRRO INFO =========================================
//
STDMETHODIMP 
CFaxReceiptOptions::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxReceiptOptions::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Interface Support Error Info.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	riid                          [in]    - IID of the Interface to check.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxReceiptOptions
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxrecipient.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxRecipient.cpp

Abstract:

	Implementation of Fax Recipient Interface

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxRecipient.h"
#include "..\..\inc\FaxUIConstants.h"

//
//===================== GET RECIPIENT PROFILE =====================================
//
STDMETHODIMP
CFaxRecipient::GetRecipientProfile(
	FAX_PERSONAL_PROFILE *pRecipientProfile
)
/*++

Routine name : CFaxRecipient::GetRecipientProfile

Routine description:

	Fills the pRecipientProfile with the data of the object.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pRecipientProfile               [out]    - the FAX_PERSONAL_PROFILE struct to fill

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxRecipient::GetRecipientProfile"), hr);

	if (::IsBadWritePtr(pRecipientProfile, sizeof(FAX_PERSONAL_PROFILE)))
	{
		//
		//	Bad Return OR Interface Pointer
		//
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

    ZeroMemory(pRecipientProfile, sizeof(FAX_PERSONAL_PROFILE));

	pRecipientProfile->dwSizeOfStruct	= sizeof(FAX_PERSONAL_PROFILE);
	pRecipientProfile->lptstrName		= m_bstrName;
	pRecipientProfile->lptstrFaxNumber	= m_bstrFaxNumber;

	return hr;
}

//
//============== PUT RECIPIENT PROFILE ============================================
//
STDMETHODIMP
CFaxRecipient::PutRecipientProfile(
	FAX_PERSONAL_PROFILE *pRecipientProfile
)
/*++

Routine name : CFaxRecipient::PutRecipientProfile

Routine description:

	Receives FAX_PERSONAL_PROFILE structure and fills the Recipient's fields.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pRecipientProfile               [in]    - the data to put into the object's variables

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxRecipient::PutRecipientProfile"), hr);

	m_bstrFaxNumber	=	pRecipientProfile->lptstrFaxNumber;
	m_bstrName		=	pRecipientProfile->lptstrName;

	if ((pRecipientProfile->lptstrFaxNumber && !m_bstrFaxNumber) ||
		(pRecipientProfile->lptstrName && !m_bstrName))
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
	}

	return hr;
}


//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxRecipient::InterfaceSupportsErrorInfo (
	REFIID riid
)
/*++

Routine name : CFaxRecipient::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Interface ID

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxRecipient
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxRecipient::Create (
	IFaxRecipient **ppRecipient
)
/*++

Routine name : CFaxRecipient::Create

Routine description:

	Static function to create the Fax Recipient Instance

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppRecipient         [out]  -- the new Fax Recipient Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxRecipient>		*pClass;
	HRESULT					        hr = S_OK;

	DBG_ENTER (TEXT("CFaxRecipient::Create"), hr);

	hr = CComObject<CFaxRecipient>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxRecipient>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxRecipient), (void **) ppRecipient);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Recipient Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}


//
//==================== FAX NUMBER ========================================
//
STDMETHODIMP 
CFaxRecipient::get_FaxNumber(
	BSTR *pbstrFaxNumber
)
/*++

Routine name : CFaxRecipient::get_FaxNumber

Routine description:

	return FaxNumber

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrFaxNumber	            [out]    - the FaxNumber

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxRecipient::get_FaxNumber"), hr);

    hr = GetBstr(pbstrFaxNumber, m_bstrFaxNumber);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxRecipient, GetErrorMsgId(hr), IID_IFaxRecipient, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxRecipient::put_FaxNumber (
	BSTR bstrFaxNumber
)
/*++

Routine name : CFaxRecipient::put_FaxNumber

Routine description:

	Set FaxNumber

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrFaxNumber               [in]    - new Fax Number 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxRecipient::put_FaxNumber"), hr, _T("%s"), bstrFaxNumber);

	m_bstrFaxNumber = bstrFaxNumber;
	if (!m_bstrFaxNumber && bstrFaxNumber)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxRecipient, IDS_ERROR_OUTOFMEMORY, IID_IFaxRecipient, hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}


//
//==================== NAME ========================================
//
STDMETHODIMP 
CFaxRecipient::get_Name(
	BSTR *pbstrName
)
/*++

Routine name : CFaxRecipient::get_Name

Routine description:

	return Name

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrName	            [out]    - the Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (_T("CFaxRecipient::get_Name"), hr);

    hr = GetBstr(pbstrName, m_bstrName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxRecipient, GetErrorMsgId(hr), IID_IFaxRecipient, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxRecipient::put_Name (
	BSTR bstrName
)
/*++

Routine name : CFaxRecipient::put_Name

Routine description:

	Set Name

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrName               [in]    - new Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxRecipient::put_Name"), hr, _T("%s"), bstrName);

	m_bstrName = bstrName;
	if (!m_bstrName && bstrName)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxRecipient, IDS_ERROR_OUTOFMEMORY, IID_IFaxRecipient, hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxrecipients.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxRecipients.cpp

Abstract:

	Implementation of Fax Recipients Collection

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxRecipients.h"

//
//====================== ADD & REMOVE ==================================
//
STDMETHODIMP 
CFaxRecipients::Add ( 
	/*[in]*/ BSTR bstrFaxNumber,
	/*[in,defaultvalue("")]*/ BSTR bstrName,
	/*[out, retval]*/ IFaxRecipient **ppRecipient
) 
/*++

Routine name : CFaxRecipients::Add

Routine description:

	Add New Recipient to the Recipients Collection

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppRecipient                [out]    - Ptr to the newly created Recipient

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxRecipients::Add"), hr);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(ppRecipient, sizeof(IFaxRecipient* )))
	{
		//
		//	Got a bad return pointer
		//
		hr = E_POINTER;
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_INVALID_ARGUMENT, 
			IID_IFaxRecipients, 
			hr);
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

	//
	//	Fax Number should exist
	//
	if (::SysStringLen(bstrFaxNumber) < 1)
	{
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_EMPTY_ARGUMENT, 
			IID_IFaxRecipients, 
			hr);
		CALL_FAIL(GENERAL_ERR, _T("::SysStringLen(bstrFaxNumber) < 1"), hr);
		return hr;
	}

	CComPtr<IFaxRecipient>	pNewRecipient;

	hr = CFaxRecipient::Create(&pNewRecipient);
	if (FAILED(hr))
	{
		//
		//	Failed to create Recipient object
		//
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OPERATION_FAILED, 
			IID_IFaxRecipients, 
			hr);
		CALL_FAIL(GENERAL_ERR, _T("CFaxRecipient::Create()"), hr);
		return hr;
	}

	try 
	{
		m_coll.push_back(pNewRecipient);
	}
	catch (exception &)
	{
		//
		//	Failed to add the Recipient to the Collection
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxRecipients, 
			hr);
		CALL_FAIL(MEM_ERR, _T("m_coll.push_back()"), hr);
		return hr;
	}

	//
	//	Put Fax Number
	//
	hr = pNewRecipient->put_FaxNumber(bstrFaxNumber);
	if (FAILED(hr))
	{
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OPERATION_FAILED, 
			IID_IFaxRecipients, 
			hr);
		CALL_FAIL(MEM_ERR, _T("pNewRecipient->put_FaxNumber(bstrFaxNumber)"), hr);
		return hr;
	}

	//
	//	Put Recipient's Name
	//
	hr = pNewRecipient->put_Name(bstrName);
	if (FAILED(hr))
	{
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OPERATION_FAILED, 
			IID_IFaxRecipients, 
			hr);
		CALL_FAIL(MEM_ERR, _T("pNewRecipient->put_Name(bstrName)"), hr);
		return hr;
	}

	//
	//	Additional AddRef() to prevent death of the Recipient
	//
	(*pNewRecipient).AddRef();

	pNewRecipient.CopyTo(ppRecipient);
	return hr; 
};

STDMETHODIMP 
CFaxRecipients::Remove (
	/*[in]*/ long lIndex
) 
/*++

Routine name : CFaxRecipients::Remove

Routine description:

	Remove Recipient at given index from the Collection

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	lIndex                        [in]    - Index of the Recipient to Remove

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxRecipients::Remove"), hr, _T("%d"), lIndex);

	if (lIndex < 1 || lIndex > m_coll.size()) 
	{
		//
		//	Invalid Index
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OUTOFRANGE, 
			IID_IFaxRecipients, 
			hr);
		CALL_FAIL(GENERAL_ERR, _T("lIndex > m_coll.size()"), hr);
		return hr;
	}

	ContainerType::iterator	it;

	it = m_coll.begin() + lIndex - 1;

	hr = (*it)->Release();
	if (FAILED(hr))
	{
		//
		//	Failed to Release the Interface
		//
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OPERATION_FAILED, 
			IID_IFaxRecipients, 
			hr);
		CALL_FAIL(GENERAL_ERR, _T("Release()"), hr);
		return hr;
	}

	try
	{
		m_coll.erase(it);
	}
	catch(exception &)
	{
		//
		//	Failed to remove the Recipient from the Collection
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxRecipients, 
			hr);
		CALL_FAIL(MEM_ERR, _T("m_coll.erase()"), hr);
		return hr;
	}

	return hr; 
};

//
//====================== CREATE ==================================
//
HRESULT 
CFaxRecipients::Create ( 
	IFaxRecipients **ppRecipients
)
/*++

Routine name : CFaxRecipients::Create

Routine description:

	Static function to Create Recipients Collection

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppRecipients                  [out]    - the resulting collection

Return Value:

    Standard HRESULT code

--*/
{
	CComObject<CFaxRecipients>	*pClass;
	HRESULT						hr;

	DBG_ENTER (_T("CFaxRecipients::Create"), hr);

	hr = CComObject<CFaxRecipients>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxRecipients>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxRecipients), (void **) ppRecipients);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Recipients Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxRecipients::InterfaceSupportsErrorInfo (
	REFIID riid
)
/*++

Routine name : CFaxRecipients::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Interface ID

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxRecipients
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxqueueinner.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxQueueInner.h

Abstract:

	Declaration and Implementation of Fax Queue Inner Template Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXQUEUEINNER_H_
#define __FAXQUEUEINNER_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"


//
//================ FAX QUEUE INNER =========================================
//
//	Implementation of Commonality for Fax Incoming and Outgoing Queues
//
template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
class CFaxQueueInner : 
	public IDispatchImpl<T, piid, &LIBID_FAXCOMEXLib>, 
	public CFaxInitInner
{
public:
    CFaxQueueInner() : CFaxInitInner(_T("FAX QUEUE INNER"))
	{
		m_bInited = FALSE;
	}

	virtual ~CFaxQueueInner() 
	{};

//  Interfaces
	STDMETHOD(Save)();
	STDMETHOD(Refresh)();
	STDMETHOD(get_Blocked)(/*[out, retval]*/ VARIANT_BOOL *pbBlocked);
	STDMETHOD(put_Blocked)(/*[in]*/ VARIANT_BOOL bBlocked);
	STDMETHOD(get_Paused)(VARIANT_BOOL *pbPaused);
	STDMETHOD(put_Paused)(VARIANT_BOOL bPaused);
	STDMETHOD(GetJob)(/*[in]*/ BSTR bstrJobId, /*[out, retval]*/ JobIfc **pFaxJob);
	STDMETHOD(GetJobs)(/*[out, retval]*/CollectionIfc ** ppFaxJobsCollection);

private:
	bool			            m_bInited;
	VARIANT_BOOL                m_bBlocked;
	VARIANT_BOOL                m_bPaused;
};

//
//==================== BLOCKED ==========================================
//
template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
	::get_Blocked(
		VARIANT_BOOL *pbBlocked
)
/*++

Routine name : CFaxQueueInner::get_Blocked

Routine description:

	Return Flag indicating whether or not the Queue is blocked

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pbBlocked                  [out]    - Ptr to the Place to put Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxQueueInner::get_Blocked"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbBlocked, m_bBlocked);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr);
        return hr;
    }
	return hr;
}

template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
    ::put_Blocked(
		VARIANT_BOOL bBlocked
)
/*++

Routine name : CFaxQueueInner::put_Blocked

Routine description:

	Set new value for the Blocked flag 

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	bBlocked                   [in]    - the new Value for the Blocked Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxQueueInner::put_Blocked"), hr, _T("%d"), bBlocked);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_bBlocked = bBlocked;
	return hr;
}

//
//==================== REFRESH ==========================================
//
template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
	::Refresh(
)
/*++

Routine name : CFaxQueueInner::Refresh

Routine description:

	Bring the Queue Configuration from the Fax Server.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code.

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxQueueInner::Refresh"), hr);

    //
    //  Get Fax Handle 
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    //
    //  Get Queue Status
    //
    DWORD   dwQueueStates = 0;
    if (!FaxGetQueueStates(hFaxHandle, &dwQueueStates))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetQueueStates"), hr);
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    //
    //  Extract the values
    //
    DWORD   dwBlockState = (bIncoming) ? FAX_INCOMING_BLOCKED : FAX_OUTBOX_BLOCKED;
    m_bBlocked = (dwQueueStates & dwBlockState) ? VARIANT_TRUE : VARIANT_FALSE;

    if (!bIncoming)
    {
        m_bPaused = (dwQueueStates & FAX_OUTBOX_PAUSED) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    m_bInited = true;
    return hr;
}

//
//==================== SAVE ==========================================
//
template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
	::Save(
)
/*++

Routine name : CFaxQueueInner::Save

Routine description:

	Save the current Queue Configuration to the Fax Server.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code.

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxQueueInner::Save"), hr);

    //
    //  Nothing changed
    //
    if (!m_bInited)
    {
        return hr;
    }

    //
    //  Get Fax Handle 
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    //
    //  Get current Queue Status
    //
    DWORD   dwQueueStates;
    if (!FaxGetQueueStates(hFaxHandle, &dwQueueStates))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetQueueStates"), hr);
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    //
    //  Update it with our current state
    //
    DWORD   dwBlockState = (bIncoming) ? FAX_INCOMING_BLOCKED : FAX_OUTBOX_BLOCKED;
    if (m_bBlocked == VARIANT_TRUE)
    {
        dwQueueStates |= dwBlockState;
    }
    else
    {
        dwQueueStates &= ~dwBlockState;
    }

    if (!bIncoming)
    {
        if (m_bPaused == VARIANT_TRUE)
        {
            dwQueueStates |= FAX_OUTBOX_PAUSED;
        }
        else
        {
            dwQueueStates &= ~FAX_OUTBOX_PAUSED;
        }
    }

    //
    //  Store in the Server
    //
    if (!FaxSetQueue(hFaxHandle, dwQueueStates))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxSetQueue"), hr);
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    return hr;
}

//
//==================== PAUSED ==========================================
//
template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
	::get_Paused(
		VARIANT_BOOL *pbPaused
)
/*++

Routine name : CFaxQueueInner::get_Paused

Routine description:

	Return Flag indicating whether or not the Queue is paused

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pbPaused                  [out]    - Ptr to the Place to put Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxQueueInner::get_Paused"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbPaused, m_bPaused);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr);
        return hr;
    }
	return hr;
}

template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
    ::put_Paused(
		VARIANT_BOOL bPaused
)
/*++

Routine name : CFaxQueueInner::put_Paused

Routine description:

	Set new value for the Paused flag 

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	bPaused                   [in]    - the new Value for the Paused Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxQueueInner::put_Paused"), hr, _T("%d"), bPaused);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_bPaused = bPaused;
	return hr;
}

//
//==================== GET JOB ==========================================
//
template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
	::GetJob(
        /*[in]*/ BSTR bstrJobId, 
        /*[out, retval]*/ JobIfc **ppFaxJob
)
/*++

Routine name : CFaxQueueInner::GetJob

Routine description:

	Return Job object corresponding to the given Job Id

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	bstrJobId                  [in]    - Id of the Job
    pFaxJob                    [out]   - resulting Job Object 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxQueueInner::GetJob"), hr, _T("Job ID : %s"), bstrJobId);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(ppFaxJob, sizeof(JobIfc *)))
	{
		//
		//	Got Bad Return Pointer
		//
		hr = E_POINTER;
		AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

    // 
    //  no need to sync first
    //

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

	//
	//	convert Job Id that we've got to hexadecimal DWORDLONG
	//
	DWORDLONG	dwlJobId;
	int iParsed = _stscanf (bstrJobId, _T("%I64x"), &dwlJobId);	
	if ( iParsed != 1)
	{
		//
		//	Failed to conver the number
		//
		hr = E_INVALIDARG;
		CALL_FAIL(GENERAL_ERR, _T("_stscanf()"), hr);
		AtlReportError(*pcid, IDS_ERROR_INVALIDMSGID, *piid, hr);
		return hr;
	}

    //
    //  Get the Job Info from the Server
    //
    CFaxPtr<FAX_JOB_ENTRY_EX>   pJobInfo;
    if (!FaxGetJobEx(hFaxHandle, dwlJobId, &pJobInfo))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxGetJobEx(hFaxHandle, m_JobInfo->dwlMessageId, &m_JobInfo)"), hr);
        return hr;
    }

    //
    //  Check that pJobInfo is valid
    //
	if (!pJobInfo || pJobInfo->dwSizeOfStruct != sizeof(FAX_JOB_ENTRY_EX))
	{
		//
		//	Failed to Get Job
		//
		hr = E_FAIL;
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("Invalid pJobInfo"), hr);
		return hr;
	}

    //
    //  Check that Type of the Job is compatible with the Type of the Queue
    //
    if (bIncoming)
    {
        if ( !((pJobInfo->pStatus->dwJobType) & JT_RECEIVE) && 
             !((pJobInfo->pStatus->dwJobType) & JT_ROUTING) )
        {
            //
            //  the desired Job is not Incoming
            //
		    hr = Fax_HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		    AtlReportError(*pcid, IDS_ERROR_INVALIDMSGID, *piid, hr);
		    CALL_FAIL(GENERAL_ERR, _T("The desired Job is NOT Incoming"), hr);
		    return hr;
        }
    }
    else
    {
        if ( !((pJobInfo->pStatus->dwJobType) & JT_SEND) )
        {
            //
            //  the desired Job is not Outgoing
            //
		    hr = Fax_HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		    AtlReportError(*pcid, IDS_ERROR_INVALIDMSGID, *piid, hr);
		    CALL_FAIL(GENERAL_ERR, _T("The desired Job is NOT Outgoing"), hr);
		    return hr;
        }
    }
    
	//
	//	Create Job Object
	//
	CComPtr<JobIfc>		pTmpJob;
	hr = JobType::Create(&pTmpJob);
	if (FAILED(hr))
	{
		//
		//	Failed to create the Job object
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("JobType::Create()"), hr);
		return hr;
	}

	//
	//	Initialize the Job Object
    //
    //  Job will free the Job Info struct
    //
	hr = ((JobType *)((JobIfc *)pTmpJob))->Init(pJobInfo, m_pIFaxServerInner);
	if (FAILED(hr))
	{
		//
		// Failed to Init the Job Object
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("<casted>pTmpJob->Init(pJobInfo, m_pIFaxServerInner)"), hr);
		return hr;
	}

	//
	//	Return Job Object to the Caller
	//
	hr = pTmpJob.CopyTo(ppFaxJob);
	if (FAILED(hr))
	{
		//
		//	Failed to Copy Interface
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("CComPtr::CopyTo"), hr);
		return hr;
	}

    //
    //  ppFaxJob uses this Job Info. Do not free the memory yet
    //
    pJobInfo.Detach();
	return hr;
}

//
//==================== GET JOBS ==========================================
//
template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
	::GetJobs(
        /*[out, retval]*/CollectionIfc ** ppJobsCollection)
/*++

Routine name : CFaxQueueInner::GetJobs

Routine description:

	Return Jobs Collection

Author:

	Iv Garber (IvG),	May, 2000

Arguments:
    
      ppFaxJobsCollection           [out, retval]   -   the Jobs Collection

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxQueueInner::GetJobs"), hr);

	//
	//	Check that we can write to the given pointer
	//
    if (::IsBadWritePtr(ppJobsCollection, sizeof(CollectionIfc *)))
    {
		//
		//	Got Bad Return Pointer
		//
		hr = E_POINTER;
		AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
        return hr;
    }

    //
    //  Bring the Jobs from the Server
    //
    DWORD   dwJobTypes;
    dwJobTypes = (bIncoming) ? (JT_RECEIVE | JT_ROUTING) : (JT_SEND);

    DWORD   dwJobCount;
    CFaxPtr<FAX_JOB_ENTRY_EX>   pJobCollection;
    if (!FaxEnumJobsEx(hFaxHandle, dwJobTypes, &pJobCollection, &dwJobCount))
    {
		//
		// Failed to Get the Job Collection
		//
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumJobEx(hFaxHandle, dwJobTypes, &m_pJobCollection,...)"), hr);
		return hr;
    }

    //
    //  Create Jobs Collection
    //
	CComPtr<CollectionIfc>		pTmpJobCollection;
	hr = CollectionType::Create(&pTmpJobCollection);
	if (FAILED(hr))
	{
		//
		//	Failed to create the Job Collection
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("CollectionType::Create()"), hr);
		return hr;
	}

	//
	//	Initialize the Job Collection
    //      Job Collection will COPY all the data from pJobCollection
	//
	hr = ((CollectionType *)((CollectionIfc *)pTmpJobCollection))->Init(pJobCollection, 
        dwJobCount, 
        m_pIFaxServerInner);
	if (FAILED(hr))
	{
		//
		// Failed to Init the Job Collection
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("pTmpJobCollection->Init(m_pJobCollection, m_pIFaxServerInner)"), hr);
		return hr;
	}

	//
	//	Return Job Object to the Caller
	//
	hr = pTmpJobCollection.CopyTo(ppJobsCollection);
	if (FAILED(hr))
	{
		//
		//	Failed to Copy Interface
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr);
		CALL_FAIL(GENERAL_ERR, _T("CComPtr::CopyTo"), hr);
		return hr;
	}

	return hr;
}


#endif //__FAXQUEUEINNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxrecipients.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxRecipients.h

Abstract:

	Declaration of the CFaxRecipients class.

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#ifndef __FAXRECIPIENTS_H_
#define __FAXRECIPIENTS_H_

#include "resource.h"       // main symbols

#include <deque>
#include "VCUE_Copy.h"
#include "FaxRecipient.h"

namespace Recipients
{
	// Store the Recipients in the Deque
	typedef	std::deque<IFaxRecipient*>	ContainerType;

    //  Expose the Recipients
	typedef	IFaxRecipient*	            CollectionExposedType;
	typedef IFaxRecipients	            CollectionIfc;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT				EnumExposedType;
	typedef	IEnumVARIANT		EnumIfc;

	// Typedef the copy classes using existing typedefs
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<CollectionExposedType>                CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), 
		EnumExposedType, EnumCopyType, ContainerType >    EnumType;

    typedef ICollectionOnSTLImpl< CollectionIfc, ContainerType, 
		CollectionExposedType, CollectionCopyType, EnumType >    CollectionType;
};

using namespace Recipients;

//
//=============================== FAX RECIPIENTS =====================================
//
class ATL_NO_VTABLE CFaxRecipients : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<Recipients::CollectionType, &IID_IFaxRecipients, &LIBID_FAXCOMEXLib>
{
public:
	CFaxRecipients()
	{
        DBG_ENTER(_T("FAX RECIPIENTS -- CREATE"));
	}

	~CFaxRecipients()
	{
        DBG_ENTER(_T("FAX RECIPIENTS -- DESTROY"));

        //
        //  Free the Collection
        //
        HRESULT hr = S_OK;
        long size = m_coll.size();
        for ( long i = 1 ; i <= size ; i++ )
        {
            hr = Remove(1);
            if (FAILED(hr))
            {
                CALL_FAIL(GENERAL_ERR, _T("Remove(1)"), hr);
            }
        }
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXRECIPIENTS)
DECLARE_NOT_AGGREGATABLE(CFaxRecipients)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxRecipients)
	COM_INTERFACE_ENTRY(IFaxRecipients)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
	STDMETHOD(Add)(/*[in]*/ BSTR bstrFaxNumber, /*[in, defaultvalue("")]*/ BSTR bstrName, IFaxRecipient **ppRecipient);
	STDMETHOD(Remove)(/*[in]*/ long lIndex);

//  Internal Use
	static HRESULT Create(IFaxRecipients **ppFaxRecipients);
};

#endif //__FAXRECIPIENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxrecipient.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxRecipeint.h

Abstract:

	Definition of Recipient Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXRECIPIENT_H_
#define __FAXRECIPIENT_H_

#include "resource.h"
#include "FaxCommon.h"

//
//========================== FAX RECIPIENT ===============================================
//
class ATL_NO_VTABLE CFaxRecipient : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxRecipient, &IID_IFaxRecipient, &LIBID_FAXCOMEXLib>
{
public:
	CFaxRecipient()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXRECIPIENT)
DECLARE_NOT_AGGREGATABLE(CFaxRecipient)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxRecipient)
	COM_INTERFACE_ENTRY(IFaxRecipient)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

public:
	static HRESULT Create(IFaxRecipient **ppRecipient);
	STDMETHOD(GetRecipientProfile)(/*[out, retval]*/ FAX_PERSONAL_PROFILE *pRecipientProfile);
	STDMETHOD(PutRecipientProfile)(/*[in]*/ FAX_PERSONAL_PROFILE *pRecipientProfile);

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IFaxRecipient
	STDMETHOD(get_FaxNumber)(/*[out, retval]*/ BSTR *pbstrFaxNumber);
	STDMETHOD(put_FaxNumber)(/*[in]*/ BSTR bstrFaxNumber);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);
	STDMETHOD(put_Name)(/*[in]*/ BSTR bstrName);

private:
	CComBSTR	m_bstrFaxNumber;
	CComBSTR	m_bstrName;
};

#endif //__FAXRECIPIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxsecurity.h ===
// FaxSecurity.h : Declaration of the CFaxSecurity

#ifndef __FAXSECURITY_H_
#define __FAXSECURITY_H_

#include "resource.h"       // main symbols
#include "FaxLocalPtr.h"


//
//======================== FAX SECURITY ==============================================
//
class ATL_NO_VTABLE CFaxSecurity : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxSecurity, &IID_IFaxSecurity, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxSecurity() : CFaxInitInner(_T("FAX SECURITY")),
        m_bInited(false),
        m_dwSecurityInformation(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION)
	{
	}

    ~CFaxSecurity()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXSECURITY)
DECLARE_NOT_AGGREGATABLE(CFaxSecurity)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxSecurity)
	COM_INTERFACE_ENTRY(IFaxSecurity)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(Save)();
    STDMETHOD(Refresh)();
    STDMETHOD(put_Descriptor)(/*[in]*/ VARIANT vDescriptor);
    STDMETHOD(get_Descriptor)(/*[out, retval]*/ VARIANT *pvDescriptor);
    STDMETHOD(get_GrantedRights)(/*[out, retval]*/ FAX_ACCESS_RIGHTS_ENUM *pGrantedRights);

    STDMETHOD(put_InformationType)(/*[in]*/ long lInformationType);
    STDMETHOD(get_InformationType)(/*[out, retval]*/ long *plInformationType);

private:
    bool                m_bInited;
    DWORD               m_dwAccessRights;
    CFaxPtrLocal<BYTE>  m_pbSD;
    DWORD               m_dwSecurityInformation;
};

#endif //__FAXSECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxsender.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxSender.cpp

Abstract:

	Implementation of Fax Sender Interface

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxSender.h"
#include "..\..\inc\FaxUIConstants.h"

//
//===================== GET SENDER PROFILE =====================================
//
STDMETHODIMP
CFaxSender::GetSenderProfile(
	FAX_PERSONAL_PROFILE *pSenderProfile
)
/*++

Routine name : CFaxSender::GetSenderProfile

Routine description:

	Fills the pSenderProfile with the data of the object.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pSenderProfile          [out]    - the FAX_PERSONAL_PROFILE struct to fill

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::GetSenderProfile"), hr);

    //
    //  First fill the Recipient's fields
    //
    hr = m_Recipient.GetRecipientProfile(pSenderProfile);
    if (FAILED(hr))
    {
		CALL_FAIL(GENERAL_ERR, _T("m_Recipient.GetRecipientProfile(pSenderProfile)"), hr);
        return hr;
    }

    //
    //  now add Sender's fields
    //
	pSenderProfile->lptstrCity		        = m_bstrCity;
	pSenderProfile->lptstrCompany	        = m_bstrCompany;
	pSenderProfile->lptstrCountry	        = m_bstrCountry;
	pSenderProfile->lptstrEmail		        = m_bstrEmail;
	pSenderProfile->lptstrState		        = m_bstrState;
	pSenderProfile->lptstrTitle		        = m_bstrTitle;
	pSenderProfile->lptstrTSID		        = m_bstrTSID;
	pSenderProfile->lptstrZip		        = m_bstrZipCode;
	pSenderProfile->lptstrHomePhone	        = m_bstrHomePhone;
	pSenderProfile->lptstrDepartment        = m_bstrDepartment;
	pSenderProfile->lptstrBillingCode       = m_bstrBillingCode;
	pSenderProfile->lptstrOfficePhone	    = m_bstrOfficePhone;
	pSenderProfile->lptstrOfficeLocation    = m_bstrOfficeLocation;
	pSenderProfile->lptstrStreetAddress	    = m_bstrStreetAddress;

	return hr;
}

//
//============== PUT SENDER PROFILE ============================================
//
STDMETHODIMP
CFaxSender::PutSenderProfile(
	FAX_PERSONAL_PROFILE *pSenderProfile
)
/*++

Routine name : CFaxSender::PutSenderProfile

Routine description:

	Receives FAX_PERSONAL_PROFILE structure and fills the Object's fields.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pSenderProfile          [in]    - the data to put into the object's variables

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::PutSenderProfile"), hr);

    //
    //  First put the Recipient fields
    //
    hr = m_Recipient.PutRecipientProfile(pSenderProfile);
    if (FAILED(hr))
    {
        //
        //  PutRecipientProfile handles the error case
        //
		CALL_FAIL(GENERAL_ERR, _T("m_Recipient.PutRecipientProfile(pSenderProfile)"), hr);
        return hr;
    }

    //
    //  Now set Sender's fields
    //
	m_bstrCity		=	pSenderProfile->lptstrCity;
	m_bstrCompany	=	pSenderProfile->lptstrCompany;
	m_bstrCountry	=	pSenderProfile->lptstrCountry;
	m_bstrEmail		=	pSenderProfile->lptstrEmail;
	m_bstrHomePhone	=	pSenderProfile->lptstrHomePhone;
	m_bstrState		=	pSenderProfile->lptstrState;
	m_bstrZipCode	=	pSenderProfile->lptstrZip;
	m_bstrTitle		=	pSenderProfile->lptstrTitle;
	m_bstrTSID		=	pSenderProfile->lptstrTSID;
	m_bstrBillingCode	=	pSenderProfile->lptstrBillingCode;
	m_bstrDepartment	=	pSenderProfile->lptstrDepartment;
	m_bstrStreetAddress	=	pSenderProfile->lptstrStreetAddress;
	m_bstrOfficePhone	=	pSenderProfile->lptstrOfficePhone;
	m_bstrOfficeLocation	=	pSenderProfile->lptstrOfficeLocation;

	if ((pSenderProfile->lptstrCity && !m_bstrCity) ||
		(pSenderProfile->lptstrCompany && !m_bstrCompany) ||
		(pSenderProfile->lptstrCountry && !m_bstrCountry) ||
		(pSenderProfile->lptstrEmail && !m_bstrEmail) ||
		(pSenderProfile->lptstrHomePhone && !m_bstrHomePhone) ||
		(pSenderProfile->lptstrState && !m_bstrState) ||
		(pSenderProfile->lptstrZip && !m_bstrZipCode) ||
		(pSenderProfile->lptstrTSID && !m_bstrTSID) ||
		(pSenderProfile->lptstrBillingCode && !m_bstrBillingCode) ||
		(pSenderProfile->lptstrDepartment && !m_bstrDepartment) ||
		(pSenderProfile->lptstrStreetAddress && !m_bstrStreetAddress) ||
		(pSenderProfile->lptstrOfficePhone && !m_bstrOfficePhone) ||
		(pSenderProfile->lptstrOfficeLocation && !m_bstrOfficeLocation))
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
	}

	return hr;
}
	
//
//==================== DEFAULT SENDER ===================================
//
STDMETHODIMP 
CFaxSender::LoadDefaultSender ( 
)
/*++

Routine name : CFaxSender::LoadDefaultSender

Routine description:

	Load Default Sender Information from the local Registry

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	NONE

Return Value:

    Standard HRESULT code

--*/
{
	FAX_PERSONAL_PROFILE	DefaultSenderProfile;
	HRESULT					hr;

	DBG_ENTER (TEXT("CFaxSender::LoadDefaultSender"), hr);

	DefaultSenderProfile.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

	hr = FaxGetSenderInformation(&DefaultSenderProfile);
	if (FAILED(hr))
	{
		//
		//	Failed to get Sender Information
		//
		AtlReportError(CLSID_FaxSender, 
			GetErrorMsgId(hr), 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(GENERAL_ERR, _T("FaxGetSenderInformation()"), hr);
		return hr;
	}

	hr = PutSenderProfile(&DefaultSenderProfile);
	if (FAILED(hr))
	{
		//
		//	Not Enough Memory
		//
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		//
		// no return, we still need to free information
		//
	}

	HRESULT hr1 = FaxFreeSenderInformation(&DefaultSenderProfile);
	if (FAILED(hr1))
	{
		hr = hr1;
		CALL_FAIL(GENERAL_ERR, _T("FaxFreeSenderInformation()"), hr);
		return hr;
	}

	return hr;
}

//
//	SaveAs
//
STDMETHODIMP 
CFaxSender::SaveDefaultSender (
)
/*++

Routine name : CFaxSender::SaveDefaultSender

Routine description:

	Save current Profile as the Default in the Local Registry

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	NONE

Return Value:

    Standard HRESULT code

--*/

{
	FAX_PERSONAL_PROFILE	DefaultSenderProfile;
	HRESULT					hr;

	DBG_ENTER (TEXT("CFaxSender::SaveDefaultSender"), hr);
	
	hr = GetSenderProfile(&DefaultSenderProfile);
	ATLASSERT(SUCCEEDED(hr));

	hr = FaxSetSenderInformation(&DefaultSenderProfile);
	if (FAILED(hr))
	{
		AtlReportError(CLSID_FaxSender, 
			GetErrorMsgId(hr), 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(GENERAL_ERR, _T("FaxSetSenderInformation()"), hr);
		return hr;
	}

	return hr;
}

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxSender::InterfaceSupportsErrorInfo (
	REFIID riid
)
/*++

Routine name : CFaxSender::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Interface ID

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxSender
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxSender::Create (
	IFaxSender **ppSender
)
/*++

Routine name : CFaxSender::Create

Routine description:

	Static function to create the Fax Sender Instance

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppSender             [out]  -- the new Fax Sender Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxSender>		*pClass;
	HRESULT								hr = S_OK;

	DBG_ENTER (TEXT("CFaxSender::Create"), hr);

	hr = CComObject<CFaxSender>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxSender>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxSender), (void **) ppSender);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}

//
//==================== BILLING CODE ========================================
//
STDMETHODIMP 
CFaxSender::get_BillingCode(
	BSTR *pbstrBillingCode
)
/*++

Routine name : CFaxSender::get_BillingCode

Routine description:

	return Billing Code

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrBillingCode              [out]    - the Billing Code

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_BillingCode"), hr);

    hr = GetBstr(pbstrBillingCode, m_bstrBillingCode);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_BillingCode (
	BSTR bstrBillingCode
)
/*++

Routine name : CFaxSender::put_BillingCode

Routine description:

	Set Billing Code

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrBillingCode               [in]    - new Billing Code value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxSender::put_BillingCode"), 
		hr, 
		_T("%s"), 
		bstrBillingCode);

	m_bstrBillingCode = bstrBillingCode;
	if (bstrBillingCode && !m_bstrBillingCode)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== CITY ========================================
//
STDMETHODIMP 
CFaxSender::get_City(
	BSTR *pbstrCity
)
/*++

Routine name : CFaxSender::get_City

Routine description:

	return City

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrCity              [out]    - the City

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_City"), hr);

    hr = GetBstr(pbstrCity, m_bstrCity);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_City (
	BSTR bstrCity
)
/*++

Routine name : CFaxSender::put_City

Routine description:

	Set City

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrCity               [in]    - new City value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_City"), hr, _T("%s"), bstrCity);

	m_bstrCity = bstrCity;
	if (!m_bstrCity && bstrCity)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== COMPANY ========================================
//
STDMETHODIMP 
CFaxSender::get_Company(
	BSTR *pbstrCompany
)
/*++

Routine name : CFaxSender::get_Company

Routine description:

	return Company

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrCompany              [out]    - the Company

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_Company"), hr);

    hr = GetBstr(pbstrCompany, m_bstrCompany);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_Company (
	BSTR bstrCompany
)
/*++

Routine name : CFaxSender::put_Company

Routine description:

	Set Company

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrCompany               [in]    - new Company value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_Company"), hr, _T("%s"), bstrCompany);

	m_bstrCompany = bstrCompany;
	if (!m_bstrCompany && bstrCompany)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, IDS_ERROR_OUTOFMEMORY, IID_IFaxSender, hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== COUNTRY ========================================
//
STDMETHODIMP 
CFaxSender::get_Country(
	BSTR *pbstrCountry
)
/*++

Routine name : CFaxSender::get_Country

Routine description:

	return Country

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrCountry	            [out]    - the Country

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_Country"), hr);

    hr = GetBstr(pbstrCountry, m_bstrCountry);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_Country (
	BSTR bstrCountry
)
/*++

Routine name : CFaxSender::put_Country

Routine description:

	Set Country

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrCountry               [in]    - new Country value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_Country"), hr, _T("%s"), bstrCountry);

	m_bstrCountry = bstrCountry;
	if (!m_bstrCountry && bstrCountry)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== DEPARTMENT ========================================
//
STDMETHODIMP 
CFaxSender::get_Department(
	BSTR *pbstrDepartment
)
/*++

Routine name : CFaxSender::get_Department

Routine description:

	return Department

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrDepartment	            [out]    - the Department

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_Department"), hr);

    hr = GetBstr(pbstrDepartment, m_bstrDepartment);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_Department (
	BSTR bstrDepartment
)
/*++

Routine name : CFaxSender::put_Department

Routine description:

	Set Department

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrDepartment               [in]    - new Department value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_Department"), hr, _T("%s"), bstrDepartment);

	m_bstrDepartment = bstrDepartment;
	if (!m_bstrDepartment && bstrDepartment)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== EMAIL ========================================
//
STDMETHODIMP 
CFaxSender::get_Email(
	BSTR *pbstrEmail
)
/*++

Routine name : CFaxSender::get_Email

Routine description:

	return Email

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrEmail	            [out]    - the Email

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_Email"), hr);

    hr = GetBstr(pbstrEmail, m_bstrEmail);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_Email (
	BSTR bstrEmail
)
/*++

Routine name : CFaxSender::put_Email

Routine description:

	Set Email

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrEmail               [in]    - new Email value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_Email"), hr, _T("%s"), bstrEmail);

	m_bstrEmail = bstrEmail;
	if (!m_bstrEmail && bstrEmail)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== HOME PHONE ========================================
//
STDMETHODIMP 
CFaxSender::get_HomePhone(
	BSTR *pbstrHomePhone
)
/*++

Routine name : CFaxSender::get_HomePhone

Routine description:

	return HomePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrHomePhone	            [out]    - the HomePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_HomePhone"), hr);

    hr = GetBstr(pbstrHomePhone, m_bstrHomePhone);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_HomePhone (
	BSTR bstrHomePhone
)
/*++

Routine name : CFaxSender::put_HomePhone

Routine description:

	Set HomePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrHomePhone               [in]    - new HomePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_HomePhone"), hr, _T("%s"), bstrHomePhone);

	m_bstrHomePhone = bstrHomePhone;
	if (!m_bstrHomePhone && bstrHomePhone)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}


//
//==================== TSID ========================================
//
STDMETHODIMP 
CFaxSender::get_TSID(
	BSTR *pbstrTSID
)
/*++

Routine name : CFaxSender::get_TSID

Routine description:

	return TSID

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrTSID	            [out]    - the TSID

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_TSID"), hr);

    hr = GetBstr(pbstrTSID, m_bstrTSID);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_TSID (
	BSTR bstrTSID
)
/*++

Routine name : CFaxSender::put_TSID

Routine description:

	Set TSID

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrTSID               [in]    - new TSID

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_TSID"), hr, _T("%s"), bstrTSID);

    if (SysStringLen(bstrTSID) > FXS_TSID_CSID_MAX_LENGTH)
    {
		//
		//	Out of the Range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxSender, IDS_ERROR_OUTOFRANGE, IID_IFaxSender, hr);
		CALL_FAIL(GENERAL_ERR, _T("TSID is too long"), hr);
		return hr;
    }
    
    m_bstrTSID = bstrTSID;
	if (!m_bstrTSID && bstrTSID)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
